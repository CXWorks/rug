-----------------
src/time_delta.rs time_delta::div_mod_floor_64
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0i64; // None+i64
+time_delta::div_mod_floor_64(p0, p1);
+crate::time_delta::div_mod_floor_64(p0, p1);
+crate::time_delta::div_mod_floor_64(p0, p1);
-----------------
src/date.rs date::map_local
deps:{"date::map_local":{"F":["std::marker::Sized","std::ops::FnMut"],"Tz":["std::marker::Sized","offset::TimeZone"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"date::map_local":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"],"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+date::map_local(p0, p1);
+crate::date::map_local(p0, p1);
+crate::date::map_local(p0, p1);
-----------------
src/datetime/mod.rs datetime::map_local
deps:{"datetime::map_local":{"F":["std::marker::Sized","std::ops::FnMut"],"Tz":["std::marker::Sized","offset::TimeZone"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"datetime::map_local":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"],"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+datetime::map_local(p0, p1);
+crate::datetime::map_local(p0, p1);
+crate::datetime::map_local(p0, p1);
-----------------
src/format/mod.rs format::format_item
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&naive::date::NaiveDate>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&naive::time::NaiveTime>
let mut p3 = std::string::String::new(); // None+std::option::Option<&(std::string::String, offset::fixed::FixedOffset)>
let mut p4 = & MaybeUninit::uninit().assume_init(); // format::Item<'_>
+format::format_item(p0, p1, p2, p3, p4);
+crate::format::format_item(p0, p1, p2, p3, p4);
+crate::format::format_item(p0, p1, p2, p3, p4);
-----------------
src/format/mod.rs format::format_inner
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&naive::date::NaiveDate>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&naive::time::NaiveTime>
let mut p3 = std::string::String::new(); // None+std::option::Option<&(std::string::String, offset::fixed::FixedOffset)>
let mut p4 = & MaybeUninit::uninit().assume_init(); // format::Item<'_>
let mut p5 = MaybeUninit::uninit().assume_init(); // std::option::Option<format::Locale>
+format::format_inner(p0, p1, p2, p3, p4, p5);
+crate::format::format_inner(p0, p1, p2, p3, p4, p5);
+crate::format::format_inner(p0, p1, p2, p3, p4, p5);
-----------------
src/format/mod.rs format::write_local_minus_utc
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p2 = true; // None+bool
let mut p3 = MaybeUninit::uninit().assume_init(); // format::Colons
+format::write_local_minus_utc(p0, p1, p2, p3);
+crate::format::write_local_minus_utc(p0, p1, p2, p3);
+crate::format::write_local_minus_utc(p0, p1, p2, p3);
-----------------
src/format/mod.rs format::write_rfc3339
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p2 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+format::write_rfc3339(p0, p1, p2);
+crate::format::write_rfc3339(p0, p1, p2);
+crate::format::write_rfc3339(p0, p1, p2);
-----------------
src/format/mod.rs format::write_rfc2822
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p2 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+format::write_rfc2822(p0, p1, p2);
+crate::format::write_rfc2822(p0, p1, p2);
+crate::format::write_rfc2822(p0, p1, p2);
-----------------
src/format/mod.rs format::write_rfc2822_inner
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p2 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p3 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p4 = MaybeUninit::uninit().assume_init(); // format::Locales
+format::write_rfc2822_inner(p0, p1, p2, p3, p4);
+crate::format::write_rfc2822_inner(p0, p1, p2, p3, p4);
+crate::format::write_rfc2822_inner(p0, p1, p2, p3, p4);
-----------------
src/format/mod.rs format::write_hundreds
deps:{"<&mut W as std::fmt::Write>":{},"format::write_hundreds":{"impl Write":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"format::write_hundreds":{"impl Write":["std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","std::fmt::Formatter<'_>","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // impl Write
let mut p1 = 0u8; // None+u8
+format::write_hundreds(p0, p1);
+crate::format::write_hundreds(p0, p1);
+crate::format::write_hundreds(p0, p1);
-----------------
src/format/mod.rs format::format
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::format":{"B":["std::borrow::Borrow","std::marker::Sized"],"I":["std::marker::Sized","std::iter::Iterator","std::clone::Clone"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::format":{"B":["std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::ffi::OsString","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::string::String","std::path::PathBuf","std::sync::Arc<T>"],"I":["naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems","naive::date::NaiveDateWeeksIterator"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&naive::date::NaiveDate>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&naive::time::NaiveTime>
let mut p3 = std::string::String::new(); // None+std::option::Option<&(std::string::String, offset::fixed::FixedOffset)>
let mut p4 = MaybeUninit::uninit().assume_init(); // I
+format::format(p0, p1, p2, p3, p4);
+crate::format::format(p0, p1, p2, p3, p4);
+crate::format::format(p0, p1, p2, p3, p4);
-----------------
src/format/parsed.rs format::parsed::set_if_consistent
deps:{"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"format::parsed::set_if_consistent":{"T":["std::marker::Sized","std::cmp::PartialEq"]},"offset::LocalResult":{"T":["std::hash::Hash","std::cmp::PartialEq","std::marker::Copy","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"date::Date":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"format::parsed::set_if_consistent":{"T":["offset::local::tz_info::parser::Cursor","month::ParseMonthError","datetime::DateTime","naive::datetime::NaiveDateTime","format::InternalInternal","weekday::Weekday","naive::date::NaiveDate","OutOfRange","offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::rule::AlternateTime","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","naive::date::NaiveDateWeeksIterator","datetime::SecondsFormat","offset::fixed::FixedOffset","time_delta::TimeDelta","naive::internals::Of","offset::local::tz_info::timezone::TimeZoneName","format::Fixed","format::InternalFixed","format::ParseErrorKind","offset::local::tz_info::timezone::LeapSecond","format::ParseError","time_delta::OutOfRangeError","naive::internals::Mdf","offset::local::tz_info::timezone::Transition","month::Month","offset::local::tz_info::timezone::TimeZoneRef","offset::utc::Utc","format::InternalNumeric","offset::local::tz_info::timezone::LocalTimeType","naive::date::Days","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::parser::Version","naive::isoweek::IsoWeek","format::Numeric","offset::local::tz_info::rule::RuleDay","format::Item","round::RoundingError","weekday::ParseWeekdayError","offset::LocalResult","date::Date","format::Pad","offset::local::tz_info::rule::TransitionRule","naive::date::NaiveDateDaysIterator","naive::internals::YearFlags","format::Void","naive::time::NaiveTime","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","month::Months","format::Colons","format::parsed::Parsed"]},"offset::LocalResult":{"T":["weekday::Weekday","naive::time::NaiveTime","naive::date::NaiveDate","naive::internals::YearFlags","datetime::DateTime","naive::date::Days","format::ParseError","format::ParseErrorKind","time_delta::TimeDelta","offset::utc::Utc","offset::LocalResult","naive::date::NaiveDateWeeksIterator","format::Pad","datetime::SecondsFormat","month::Month","naive::isoweek::IsoWeek","OutOfRange","offset::fixed::FixedOffset","month::Months","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","naive::datetime::NaiveDateTime","naive::date::NaiveDateDaysIterator","date::Date"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::option::Option<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+format::parsed::set_if_consistent(p0, p1);
+crate::format::parsed::set_if_consistent(p0, p1);
+crate::format::parsed::set_if_consistent(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::to_naive_date::resolve_year
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<i32>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<i32>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<i32>
+format::parsed::Parsed::to_naive_date::resolve_year(p0, p1, p2);
+crate::format::parsed::Parsed::to_naive_date::resolve_year(p0, p1, p2);
+<format::parsed::Parsed>::to_naive_date::resolve_year(p0, p1, p2);
-----------------
src/format/parse.rs format::parse::set_weekday_with_num_days_from_sunday
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+format::parse::set_weekday_with_num_days_from_sunday(p0, p1);
+crate::format::parse::set_weekday_with_num_days_from_sunday(p0, p1);
+crate::format::parse::set_weekday_with_num_days_from_sunday(p0, p1);
-----------------
src/format/parse.rs format::parse::set_weekday_with_number_from_monday
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+format::parse::set_weekday_with_number_from_monday(p0, p1);
+crate::format::parse::set_weekday_with_number_from_monday(p0, p1);
+crate::format::parse::set_weekday_with_number_from_monday(p0, p1);
-----------------
src/format/parse.rs format::parse::parse_rfc2822
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = "sample"; // None+&str
+format::parse::parse_rfc2822(p0, &p1);
+crate::format::parse::parse_rfc2822(p0, &p1);
+crate::format::parse::parse_rfc2822(p0, &p1);
-----------------
src/format/parse.rs format::parse::parse_rfc3339
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = "sample"; // None+&str
+format::parse::parse_rfc3339(p0, &p1);
+crate::format::parse::parse_rfc3339(p0, &p1);
+crate::format::parse::parse_rfc3339(p0, &p1);
-----------------
src/format/parse.rs format::parse::parse
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::parse::parse":{"B":["std::borrow::Borrow","std::marker::Sized"],"I":["std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::parse::parse":{"B":["std::sync::Arc<T>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::string::String","std::ffi::OsString","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::rc::Rc<T>","std::ffi::CString"],"I":["naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","format::strftime::StrftimeItems","<&mut I as std::iter::Iterator>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // I
+format::parse::parse(p0, &p1, p2);
+crate::format::parse::parse(p0, &p1, p2);
+crate::format::parse::parse(p0, &p1, p2);
-----------------
src/format/parse.rs format::parse::parse_internal
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::parse::parse_internal":{"B":["std::marker::Sized","std::borrow::Borrow"],"I":["std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::parse::parse_internal":{"B":["std::string::String","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::path::PathBuf","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::ffi::CString"],"I":["<&mut I as std::iter::Iterator>","naive::date::NaiveDateWeeksIterator","naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // I
+format::parse::parse_internal(p0, &p1, p2);
+crate::format::parse::parse_internal(p0, &p1, p2);
+crate::format::parse::parse_internal(p0, &p1, p2);
-----------------
src/format/scan.rs format::scan::equals
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = "sample"; // None+&str
+format::scan::equals(p0, &p1);
+crate::format::scan::equals(p0, &p1);
+crate::format::scan::equals(p0, &p1);
-----------------
src/format/scan.rs format::scan::number
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+format::scan::number(&p0, p1, p2);
+crate::format::scan::number(&p0, p1, p2);
+crate::format::scan::number(&p0, p1, p2);
-----------------
src/format/scan.rs format::scan::nanosecond
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::nanosecond(&p0);
+crate::format::scan::nanosecond(&p0);
+crate::format::scan::nanosecond(&p0);
-----------------
src/format/scan.rs format::scan::nanosecond_fixed
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
+format::scan::nanosecond_fixed(&p0, p1);
+crate::format::scan::nanosecond_fixed(&p0, p1);
+crate::format::scan::nanosecond_fixed(&p0, p1);
-----------------
src/format/scan.rs format::scan::short_month0
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::short_month0(&p0);
+crate::format::scan::short_month0(&p0);
+crate::format::scan::short_month0(&p0);
-----------------
src/format/scan.rs format::scan::short_weekday
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::short_weekday(&p0);
+crate::format::scan::short_weekday(&p0);
+crate::format::scan::short_weekday(&p0);
-----------------
src/format/scan.rs format::scan::short_or_long_month0
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::short_or_long_month0(&p0);
+crate::format::scan::short_or_long_month0(&p0);
+crate::format::scan::short_or_long_month0(&p0);
-----------------
src/format/scan.rs format::scan::short_or_long_weekday
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::short_or_long_weekday(&p0);
+crate::format::scan::short_or_long_weekday(&p0);
+crate::format::scan::short_or_long_weekday(&p0);
-----------------
src/format/scan.rs format::scan::char
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0u8; // None+u8
+format::scan::char(&p0, p1);
+crate::format::scan::char(&p0, p1);
+crate::format::scan::char(&p0, p1);
-----------------
src/format/scan.rs format::scan::space
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::space(&p0);
+crate::format::scan::space(&p0);
+crate::format::scan::space(&p0);
-----------------
src/format/scan.rs format::scan::s_next
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::s_next(&p0);
+crate::format::scan::s_next(&p0);
+crate::format::scan::s_next(&p0);
-----------------
src/format/scan.rs format::scan::trim1
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::trim1(&p0);
+crate::format::scan::trim1(&p0);
+crate::format::scan::trim1(&p0);
-----------------
src/format/scan.rs format::scan::consume_colon_maybe
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::consume_colon_maybe(&p0);
+crate::format::scan::consume_colon_maybe(&p0);
+crate::format::scan::consume_colon_maybe(&p0);
-----------------
src/format/scan.rs format::scan::timezone_offset
deps:{"format::scan::timezone_offset":{"F":["std::ops::FnMut","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"format::scan::timezone_offset":{"F":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+format::scan::timezone_offset(&p0, p1);
+crate::format::scan::timezone_offset(&p0, p1);
+crate::format::scan::timezone_offset(&p0, p1);
-----------------
src/format/scan.rs format::scan::timezone_offset_internal
deps:{"format::scan::timezone_offset_internal":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"format::scan::timezone_offset_internal":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // F
let mut p2 = true; // None+bool
+format::scan::timezone_offset_internal(&p0, p1, p2);
+crate::format::scan::timezone_offset_internal(&p0, p1, p2);
+crate::format::scan::timezone_offset_internal(&p0, p1, p2);
-----------------
src/format/scan.rs format::scan::timezone_offset_internal::digits
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::timezone_offset_internal::digits(&p0);
+crate::format::scan::timezone_offset_internal::digits(&p0);
+crate::format::scan::timezone_offset_internal::digits(&p0);
-----------------
src/format/scan.rs format::scan::timezone_offset_zulu
deps:{"format::scan::timezone_offset_zulu":{"F":["std::ops::FnMut","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"format::scan::timezone_offset_zulu":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+format::scan::timezone_offset_zulu(&p0, p1);
+crate::format::scan::timezone_offset_zulu(&p0, p1);
+crate::format::scan::timezone_offset_zulu(&p0, p1);
-----------------
src/format/scan.rs format::scan::timezone_offset_permissive
deps:{"format::scan::timezone_offset_permissive":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"format::scan::timezone_offset_permissive":{"F":["core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+format::scan::timezone_offset_permissive(&p0, p1);
+crate::format::scan::timezone_offset_permissive(&p0, p1);
+crate::format::scan::timezone_offset_permissive(&p0, p1);
-----------------
src/format/scan.rs format::scan::timezone_offset_2822
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::timezone_offset_2822(&p0);
+crate::format::scan::timezone_offset_2822(&p0);
+crate::format::scan::timezone_offset_2822(&p0);
-----------------
src/format/scan.rs format::scan::timezone_name_skip
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::timezone_name_skip(&p0);
+crate::format::scan::timezone_name_skip(&p0);
+crate::format::scan::timezone_name_skip(&p0);
-----------------
src/format/scan.rs format::scan::comment_2822
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::scan::comment_2822(&p0);
+crate::format::scan::comment_2822(&p0);
+crate::format::scan::comment_2822(&p0);
-----------------
src/naive/date.rs naive::date::div_mod_floor
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0i32; // None+i32
+naive::date::div_mod_floor(p0, p1);
+crate::naive::date::div_mod_floor(p0, p1);
+crate::naive::date::div_mod_floor(p0, p1);
-----------------
src/naive/internals.rs naive::internals::cycle_to_yo
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+naive::internals::cycle_to_yo(p0);
+crate::naive::internals::cycle_to_yo(p0);
+crate::naive::internals::cycle_to_yo(p0);
-----------------
src/naive/internals.rs naive::internals::yo_to_cycle
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+naive::internals::yo_to_cycle(p0, p1);
+crate::naive::internals::yo_to_cycle(p0, p1);
+crate::naive::internals::yo_to_cycle(p0, p1);
-----------------
src/naive/isoweek.rs naive::isoweek::iso_week_from_yof
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::internals::Of
+naive::isoweek::iso_week_from_yof(p0, p1);
+crate::naive::isoweek::iso_week_from_yof(p0, p1);
+crate::naive::isoweek::iso_week_from_yof(p0, p1);
-----------------
src/offset/fixed.rs offset::fixed::add_with_leapsecond
deps:{"offset::fixed::add_with_leapsecond":{"T":["traits::Timelike","std::ops::Add","std::marker::Sized"]}}
candidates:{"offset::fixed::add_with_leapsecond":{"T":["u8","usize","u16","i16","u64","u32","i8","i32","i64"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0i32; // None+i32
+offset::fixed::add_with_leapsecond(p0, p1);
+crate::offset::fixed::add_with_leapsecond(p0, p1);
+crate::offset::fixed::add_with_leapsecond(p0, p1);
-----------------
src/offset/local/unix.rs offset::local::inner::now
deps:{}
candidates:{}
+offset::local::inner::now();
+crate::offset::local::inner::now();
+crate::offset::local::inner::now();
-----------------
src/offset/local/unix.rs offset::local::inner::naive_to_local
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = true; // None+bool
+offset::local::inner::naive_to_local(p0, p1);
+crate::offset::local::inner::naive_to_local(p0, p1);
+crate::offset::local::inner::naive_to_local(p0, p1);
-----------------
/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs offset::local::inner::TZ_INFO::__init
deps:{}
candidates:{}
+offset::local::inner::TZ_INFO::__init();
+crate::offset::local::inner::TZ_INFO::__init();
+crate::offset::local::inner::TZ_INFO::__init();
-----------------
/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs offset::local::inner::TZ_INFO::__getit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<&mut std::option::Option<std::cell::RefCell<std::option::Option<offset::local::inner::Cache>>>>
+offset::local::inner::TZ_INFO::__getit(p0);
+crate::offset::local::inner::TZ_INFO::__getit(p0);
+crate::offset::local::inner::TZ_INFO::__getit(p0);
-----------------
src/offset/local/unix.rs offset::local::inner::fallback_timezone
deps:{}
candidates:{}
+offset::local::inner::fallback_timezone();
+crate::offset::local::inner::fallback_timezone();
+crate::offset::local::inner::fallback_timezone();
-----------------
src/offset/local/unix.rs offset::local::inner::current_zone
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
+offset::local::inner::current_zone(p0);
+crate::offset::local::inner::current_zone(p0);
+crate::offset::local::inner::current_zone(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::find_tz_file
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"offset::local::tz_info::timezone::find_tz_file":{"impl AsRef<Path>":["std::convert::AsRef","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"offset::local::tz_info::timezone::find_tz_file":{"impl AsRef<Path>":["<&mut T as std::convert::AsRef<U>>","offset::local::tz_info::timezone::TimeZoneName"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl AsRef<Path>
+offset::local::tz_info::timezone::find_tz_file(p0);
+crate::offset::local::tz_info::timezone::find_tz_file(p0);
+crate::offset::local::tz_info::timezone::find_tz_file(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::saturating_abs
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+offset::local::tz_info::timezone::saturating_abs(p0);
+crate::offset::local::tz_info::timezone::saturating_abs(p0);
+crate::offset::local::tz_info::timezone::saturating_abs(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::parse
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+offset::local::tz_info::parser::parse(p0);
+crate::offset::local::tz_info::parser::parse(p0);
+crate::offset::local::tz_info::parser::parse(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::read_be_i32
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+offset::local::tz_info::parser::read_be_i32(p0);
+crate::offset::local::tz_info::parser::read_be_i32(p0);
+crate::offset::local::tz_info::parser::read_be_i32(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::read_be_i64
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+offset::local::tz_info::parser::read_be_i64(p0);
+crate::offset::local::tz_info::parser::read_be_i64(p0);
+crate::offset::local::tz_info::parser::read_be_i64(p0);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::parse_name
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
+offset::local::tz_info::rule::parse_name(p0);
+crate::offset::local::tz_info::rule::parse_name(p0);
+crate::offset::local::tz_info::rule::parse_name(p0);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::parse_offset
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'_>
+offset::local::tz_info::rule::parse_offset(p0);
+crate::offset::local::tz_info::rule::parse_offset(p0);
+crate::offset::local::tz_info::rule::parse_offset(p0);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::parse_rule_time
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'_>
+offset::local::tz_info::rule::parse_rule_time(p0);
+crate::offset::local::tz_info::rule::parse_rule_time(p0);
+crate::offset::local::tz_info::rule::parse_rule_time(p0);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::parse_rule_time_extended
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'_>
+offset::local::tz_info::rule::parse_rule_time_extended(p0);
+crate::offset::local::tz_info::rule::parse_rule_time_extended(p0);
+crate::offset::local::tz_info::rule::parse_rule_time_extended(p0);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::parse_hhmmss
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'_>
+offset::local::tz_info::rule::parse_hhmmss(p0);
+crate::offset::local::tz_info::rule::parse_hhmmss(p0);
+crate::offset::local::tz_info::rule::parse_hhmmss(p0);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::parse_signed_hhmmss
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'_>
+offset::local::tz_info::rule::parse_signed_hhmmss(p0);
+crate::offset::local::tz_info::rule::parse_signed_hhmmss(p0);
+crate::offset::local::tz_info::rule::parse_signed_hhmmss(p0);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::days_since_unix_epoch
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0usize; // None+usize
let mut p2 = 0i64; // None+i64
+offset::local::tz_info::rule::days_since_unix_epoch(p0, p1, p2);
+crate::offset::local::tz_info::rule::days_since_unix_epoch(p0, p1, p2);
+crate::offset::local::tz_info::rule::days_since_unix_epoch(p0, p1, p2);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::is_leap_year
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+offset::local::tz_info::rule::is_leap_year(p0);
+crate::offset::local::tz_info::rule::is_leap_year(p0);
+crate::offset::local::tz_info::rule::is_leap_year(p0);
-----------------
src/round.rs round::span_for_digits
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+round::span_for_digits(p0);
+crate::round::span_for_digits(p0);
+crate::round::span_for_digits(p0);
-----------------
src/round.rs round::duration_round
deps:{"date::Date":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"round::duration_round":{"T":["std::ops::Sub","traits::Timelike","std::ops::Add","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"round::duration_round":{"T":["date::Date"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // T
let mut p2 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+round::duration_round(p0, p1, p2);
+crate::round::duration_round(p0, p1, p2);
+crate::round::duration_round(p0, p1, p2);
-----------------
src/round.rs round::duration_trunc
deps:{"date::Date":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"round::duration_trunc":{"T":["traits::Timelike","std::ops::Sub","std::ops::Add","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"round::duration_trunc":{"T":["date::Date"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // T
let mut p2 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+round::duration_trunc(p0, p1, p2);
+crate::round::duration_trunc(p0, p1, p2);
+crate::round::duration_trunc(p0, p1, p2);
-----------------
src/offset/mod.rs offset::Offset::fix
deps:{"offset::Offset::fix":{"Self":["std::marker::Sized","std::fmt::Debug","offset::Offset","std::clone::Clone"]}}
candidates:{"offset::Offset::fix":{"Self":["offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.fix();
+offset::Offset::fix(p0);
+crate::offset::Offset::fix(p0);
+crate::offset::Offset::fix(p0);
-----------------
src/offset/mod.rs offset::TimeZone::with_ymd_and_hms
deps:{"offset::TimeZone::with_ymd_and_hms":{"Self":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]}}
candidates:{"offset::TimeZone::with_ymd_and_hms":{"Self":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
let mut p5 = 0u32; // None+u32
let mut p6 = 0u32; // None+u32
+p0.with_ymd_and_hms(p1, p2, p3, p4, p5, p6);
+offset::TimeZone::with_ymd_and_hms(p0, p1, p2, p3, p4, p5, p6);
+crate::offset::TimeZone::with_ymd_and_hms(p0, p1, p2, p3, p4, p5, p6);
+crate::offset::TimeZone::with_ymd_and_hms(p0, p1, p2, p3, p4, p5, p6);
-----------------
src/offset/mod.rs offset::TimeZone::ymd
deps:{"offset::TimeZone::ymd":{"Self":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]}}
candidates:{"offset::TimeZone::ymd":{"Self":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+p0.ymd(p1, p2, p3);
+offset::TimeZone::ymd(p0, p1, p2, p3);
+crate::offset::TimeZone::ymd(p0, p1, p2, p3);
+crate::offset::TimeZone::ymd(p0, p1, p2, p3);
-----------------
src/offset/mod.rs offset::TimeZone::ymd_opt
deps:{"offset::TimeZone::ymd_opt":{"Self":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]}}
candidates:{"offset::TimeZone::ymd_opt":{"Self":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+p0.ymd_opt(p1, p2, p3);
+offset::TimeZone::ymd_opt(p0, p1, p2, p3);
+crate::offset::TimeZone::ymd_opt(p0, p1, p2, p3);
+crate::offset::TimeZone::ymd_opt(p0, p1, p2, p3);
-----------------
src/offset/mod.rs offset::TimeZone::yo
deps:{"offset::TimeZone::yo":{"Self":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]}}
candidates:{"offset::TimeZone::yo":{"Self":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
let mut p2 = 0u32; // None+u32
+p0.yo(p1, p2);
+offset::TimeZone::yo(p0, p1, p2);
+crate::offset::TimeZone::yo(p0, p1, p2);
+crate::offset::TimeZone::yo(p0, p1, p2);
-----------------
src/offset/mod.rs offset::TimeZone::yo_opt
deps:{"offset::TimeZone::yo_opt":{"Self":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]}}
candidates:{"offset::TimeZone::yo_opt":{"Self":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
let mut p2 = 0u32; // None+u32
+p0.yo_opt(p1, p2);
+offset::TimeZone::yo_opt(p0, p1, p2);
+crate::offset::TimeZone::yo_opt(p0, p1, p2);
+crate::offset::TimeZone::yo_opt(p0, p1, p2);
-----------------
src/offset/mod.rs offset::TimeZone::isoywd
deps:{"offset::TimeZone::isoywd":{"Self":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]}}
candidates:{"offset::TimeZone::isoywd":{"Self":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
let mut p2 = 0u32; // None+u32
let mut p3 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.isoywd(p1, p2, p3);
+offset::TimeZone::isoywd(p0, p1, p2, p3);
+crate::offset::TimeZone::isoywd(p0, p1, p2, p3);
+crate::offset::TimeZone::isoywd(p0, p1, p2, p3);
-----------------
src/offset/mod.rs offset::TimeZone::isoywd_opt
deps:{"offset::TimeZone::isoywd_opt":{"Self":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]}}
candidates:{"offset::TimeZone::isoywd_opt":{"Self":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
let mut p2 = 0u32; // None+u32
let mut p3 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.isoywd_opt(p1, p2, p3);
+offset::TimeZone::isoywd_opt(p0, p1, p2, p3);
+crate::offset::TimeZone::isoywd_opt(p0, p1, p2, p3);
+crate::offset::TimeZone::isoywd_opt(p0, p1, p2, p3);
-----------------
src/offset/mod.rs offset::TimeZone::timestamp
deps:{"offset::TimeZone::timestamp":{"Self":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]}}
candidates:{"offset::TimeZone::timestamp":{"Self":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i64; // None+i64
let mut p2 = 0u32; // None+u32
+p0.timestamp(p1, p2);
+offset::TimeZone::timestamp(p0, p1, p2);
+crate::offset::TimeZone::timestamp(p0, p1, p2);
+crate::offset::TimeZone::timestamp(p0, p1, p2);
-----------------
src/offset/mod.rs offset::TimeZone::timestamp_opt
deps:{"offset::TimeZone::timestamp_opt":{"Self":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]}}
candidates:{"offset::TimeZone::timestamp_opt":{"Self":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i64; // None+i64
let mut p2 = 0u32; // None+u32
+p0.timestamp_opt(p1, p2);
+offset::TimeZone::timestamp_opt(p0, p1, p2);
+crate::offset::TimeZone::timestamp_opt(p0, p1, p2);
+crate::offset::TimeZone::timestamp_opt(p0, p1, p2);
-----------------
src/offset/mod.rs offset::TimeZone::timestamp_millis
deps:{"offset::TimeZone::timestamp_millis":{"Self":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]}}
candidates:{"offset::TimeZone::timestamp_millis":{"Self":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i64; // None+i64
+p0.timestamp_millis(p1);
+offset::TimeZone::timestamp_millis(p0, p1);
+crate::offset::TimeZone::timestamp_millis(p0, p1);
+crate::offset::TimeZone::timestamp_millis(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::timestamp_millis_opt
deps:{"offset::TimeZone::timestamp_millis_opt":{"Self":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]}}
candidates:{"offset::TimeZone::timestamp_millis_opt":{"Self":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i64; // None+i64
+p0.timestamp_millis_opt(p1);
+offset::TimeZone::timestamp_millis_opt(p0, p1);
+crate::offset::TimeZone::timestamp_millis_opt(p0, p1);
+crate::offset::TimeZone::timestamp_millis_opt(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::timestamp_nanos
deps:{"offset::TimeZone::timestamp_nanos":{"Self":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]}}
candidates:{"offset::TimeZone::timestamp_nanos":{"Self":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i64; // None+i64
+p0.timestamp_nanos(p1);
+offset::TimeZone::timestamp_nanos(p0, p1);
+crate::offset::TimeZone::timestamp_nanos(p0, p1);
+crate::offset::TimeZone::timestamp_nanos(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::datetime_from_str
deps:{"offset::TimeZone::datetime_from_str":{"Self":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]}}
candidates:{"offset::TimeZone::datetime_from_str":{"Self":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
let mut p2 = "sample"; // None+&str
+p0.datetime_from_str(&p1, &p2);
+offset::TimeZone::datetime_from_str(p0, &p1, &p2);
+crate::offset::TimeZone::datetime_from_str(p0, &p1, &p2);
+crate::offset::TimeZone::datetime_from_str(p0, &p1, &p2);
-----------------
src/offset/mod.rs offset::TimeZone::from_offset
deps:{"offset::TimeZone::from_offset":{"Self":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]}}
candidates:{"offset::TimeZone::from_offset":{"Self":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <Self as offset::TimeZone>::Offset
+offset::TimeZone::from_offset(p0);
+crate::offset::TimeZone::from_offset(p0);
+crate::offset::TimeZone::from_offset(p0);
-----------------
src/offset/mod.rs offset::TimeZone::offset_from_local_date
deps:{"offset::TimeZone::offset_from_local_date":{"Self":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]}}
candidates:{"offset::TimeZone::offset_from_local_date":{"Self":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.offset_from_local_date(p1);
+offset::TimeZone::offset_from_local_date(p0, p1);
+crate::offset::TimeZone::offset_from_local_date(p0, p1);
+crate::offset::TimeZone::offset_from_local_date(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::offset_from_local_datetime
deps:{"offset::TimeZone::offset_from_local_datetime":{"Self":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]}}
candidates:{"offset::TimeZone::offset_from_local_datetime":{"Self":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.offset_from_local_datetime(p1);
+offset::TimeZone::offset_from_local_datetime(p0, p1);
+crate::offset::TimeZone::offset_from_local_datetime(p0, p1);
+crate::offset::TimeZone::offset_from_local_datetime(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::from_local_date
deps:{"offset::TimeZone::from_local_date":{"Self":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]}}
candidates:{"offset::TimeZone::from_local_date":{"Self":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.from_local_date(p1);
+offset::TimeZone::from_local_date(p0, p1);
+crate::offset::TimeZone::from_local_date(p0, p1);
+crate::offset::TimeZone::from_local_date(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::from_local_datetime
deps:{"offset::TimeZone::from_local_datetime":{"Self":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]}}
candidates:{"offset::TimeZone::from_local_datetime":{"Self":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.from_local_datetime(p1);
+offset::TimeZone::from_local_datetime(p0, p1);
+crate::offset::TimeZone::from_local_datetime(p0, p1);
+crate::offset::TimeZone::from_local_datetime(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::offset_from_utc_date
deps:{"offset::TimeZone::offset_from_utc_date":{"Self":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]}}
candidates:{"offset::TimeZone::offset_from_utc_date":{"Self":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.offset_from_utc_date(p1);
+offset::TimeZone::offset_from_utc_date(p0, p1);
+crate::offset::TimeZone::offset_from_utc_date(p0, p1);
+crate::offset::TimeZone::offset_from_utc_date(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::offset_from_utc_datetime
deps:{"offset::TimeZone::offset_from_utc_datetime":{"Self":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]}}
candidates:{"offset::TimeZone::offset_from_utc_datetime":{"Self":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.offset_from_utc_datetime(p1);
+offset::TimeZone::offset_from_utc_datetime(p0, p1);
+crate::offset::TimeZone::offset_from_utc_datetime(p0, p1);
+crate::offset::TimeZone::offset_from_utc_datetime(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::from_utc_date
deps:{"offset::TimeZone::from_utc_date":{"Self":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]}}
candidates:{"offset::TimeZone::from_utc_date":{"Self":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.from_utc_date(p1);
+offset::TimeZone::from_utc_date(p0, p1);
+crate::offset::TimeZone::from_utc_date(p0, p1);
+crate::offset::TimeZone::from_utc_date(p0, p1);
-----------------
src/offset/mod.rs offset::TimeZone::from_utc_datetime
deps:{"offset::TimeZone::from_utc_datetime":{"Self":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]}}
candidates:{"offset::TimeZone::from_utc_datetime":{"Self":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.from_utc_datetime(p1);
+offset::TimeZone::from_utc_datetime(p0, p1);
+crate::offset::TimeZone::from_utc_datetime(p0, p1);
+crate::offset::TimeZone::from_utc_datetime(p0, p1);
-----------------
src/round.rs round::SubsecRound::round_subsecs
deps:{"<T as round::SubsecRound>":{"T":["traits::Timelike","std::ops::Sub","std::ops::Add","std::marker::Sized"]},"date::Date":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"round::SubsecRound::round_subsecs":{"Self":["round::SubsecRound"]}}
candidates:{"<T as round::SubsecRound>":{"T":["date::Date"]},"date::Date":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"round::SubsecRound::round_subsecs":{"Self":["<T as round::SubsecRound>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u16; // None+u16
+p0.round_subsecs(p1);
+round::SubsecRound::round_subsecs(p0, p1);
+crate::round::SubsecRound::round_subsecs(p0, p1);
+crate::round::SubsecRound::round_subsecs(p0, p1);
-----------------
src/round.rs round::SubsecRound::trunc_subsecs
deps:{"<T as round::SubsecRound>":{"T":["std::marker::Sized","std::ops::Add","std::ops::Sub","traits::Timelike"]},"date::Date":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"round::SubsecRound::trunc_subsecs":{"Self":["round::SubsecRound"]}}
candidates:{"<T as round::SubsecRound>":{"T":["date::Date"]},"date::Date":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"round::SubsecRound::trunc_subsecs":{"Self":["<T as round::SubsecRound>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u16; // None+u16
+p0.trunc_subsecs(p1);
+round::SubsecRound::trunc_subsecs(p0, p1);
+crate::round::SubsecRound::trunc_subsecs(p0, p1);
+crate::round::SubsecRound::trunc_subsecs(p0, p1);
-----------------
src/round.rs round::DurationRound::duration_round
deps:{"datetime::DateTime":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"round::DurationRound::duration_round":{"Self":["std::marker::Sized","round::DurationRound"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"round::DurationRound::duration_round":{"Self":["datetime::DateTime","naive::datetime::NaiveDateTime"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.duration_round(p1);
+round::DurationRound::duration_round(p0, p1);
+crate::round::DurationRound::duration_round(p0, p1);
+crate::round::DurationRound::duration_round(p0, p1);
-----------------
src/round.rs round::DurationRound::duration_trunc
deps:{"datetime::DateTime":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"round::DurationRound::duration_trunc":{"Self":["std::marker::Sized","round::DurationRound"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"round::DurationRound::duration_trunc":{"Self":["naive::datetime::NaiveDateTime","datetime::DateTime"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.duration_trunc(p1);
+round::DurationRound::duration_trunc(p0, p1);
+crate::round::DurationRound::duration_trunc(p0, p1);
+crate::round::DurationRound::duration_trunc(p0, p1);
-----------------
src/traits.rs traits::Datelike::year
deps:{"date::Date":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"traits::Datelike::year":{"Self":["std::marker::Sized","traits::Datelike"]}}
candidates:{"date::Date":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"traits::Datelike::year":{"Self":["date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.year();
+traits::Datelike::year(p0);
+crate::traits::Datelike::year(p0);
+crate::traits::Datelike::year(p0);
-----------------
src/traits.rs traits::Datelike::year_ce
deps:{"date::Date":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"traits::Datelike::year_ce":{"Self":["std::marker::Sized","traits::Datelike"]}}
candidates:{"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"traits::Datelike::year_ce":{"Self":["date::Date","datetime::DateTime","naive::datetime::NaiveDateTime","naive::date::NaiveDate"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.year_ce();
+traits::Datelike::year_ce(p0);
+crate::traits::Datelike::year_ce(p0);
+crate::traits::Datelike::year_ce(p0);
-----------------
src/traits.rs traits::Datelike::month
deps:{"date::Date":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"traits::Datelike::month":{"Self":["traits::Datelike","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"traits::Datelike::month":{"Self":["naive::date::NaiveDate","date::Date","naive::datetime::NaiveDateTime","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.month();
+traits::Datelike::month(p0);
+crate::traits::Datelike::month(p0);
+crate::traits::Datelike::month(p0);
-----------------
src/traits.rs traits::Datelike::month0
deps:{"date::Date":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"traits::Datelike::month0":{"Self":["std::marker::Sized","traits::Datelike"]}}
candidates:{"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"traits::Datelike::month0":{"Self":["naive::datetime::NaiveDateTime","datetime::DateTime","naive::date::NaiveDate","date::Date"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.month0();
+traits::Datelike::month0(p0);
+crate::traits::Datelike::month0(p0);
+crate::traits::Datelike::month0(p0);
-----------------
src/traits.rs traits::Datelike::day
deps:{"date::Date":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"traits::Datelike::day":{"Self":["std::marker::Sized","traits::Datelike"]}}
candidates:{"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"traits::Datelike::day":{"Self":["naive::date::NaiveDate","datetime::DateTime","naive::datetime::NaiveDateTime","date::Date"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.day();
+traits::Datelike::day(p0);
+crate::traits::Datelike::day(p0);
+crate::traits::Datelike::day(p0);
-----------------
src/traits.rs traits::Datelike::day0
deps:{"date::Date":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"traits::Datelike::day0":{"Self":["traits::Datelike","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"traits::Datelike::day0":{"Self":["naive::date::NaiveDate","datetime::DateTime","date::Date","naive::datetime::NaiveDateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.day0();
+traits::Datelike::day0(p0);
+crate::traits::Datelike::day0(p0);
+crate::traits::Datelike::day0(p0);
-----------------
src/traits.rs traits::Datelike::ordinal
deps:{"date::Date":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"traits::Datelike::ordinal":{"Self":["std::marker::Sized","traits::Datelike"]}}
candidates:{"date::Date":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"traits::Datelike::ordinal":{"Self":["date::Date","naive::datetime::NaiveDateTime","naive::date::NaiveDate","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.ordinal();
+traits::Datelike::ordinal(p0);
+crate::traits::Datelike::ordinal(p0);
+crate::traits::Datelike::ordinal(p0);
-----------------
src/traits.rs traits::Datelike::ordinal0
deps:{"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"traits::Datelike::ordinal0":{"Self":["std::marker::Sized","traits::Datelike"]}}
candidates:{"date::Date":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"traits::Datelike::ordinal0":{"Self":["naive::date::NaiveDate","date::Date","naive::datetime::NaiveDateTime","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.ordinal0();
+traits::Datelike::ordinal0(p0);
+crate::traits::Datelike::ordinal0(p0);
+crate::traits::Datelike::ordinal0(p0);
-----------------
src/traits.rs traits::Datelike::weekday
deps:{"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"traits::Datelike::weekday":{"Self":["traits::Datelike","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"traits::Datelike::weekday":{"Self":["naive::datetime::NaiveDateTime","naive::date::NaiveDate","datetime::DateTime","date::Date"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.weekday();
+traits::Datelike::weekday(p0);
+crate::traits::Datelike::weekday(p0);
+crate::traits::Datelike::weekday(p0);
-----------------
src/traits.rs traits::Datelike::iso_week
deps:{"date::Date":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"traits::Datelike::iso_week":{"Self":["std::marker::Sized","traits::Datelike"]}}
candidates:{"date::Date":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"traits::Datelike::iso_week":{"Self":["naive::datetime::NaiveDateTime","date::Date","naive::date::NaiveDate","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.iso_week();
+traits::Datelike::iso_week(p0);
+crate::traits::Datelike::iso_week(p0);
+crate::traits::Datelike::iso_week(p0);
-----------------
src/traits.rs traits::Datelike::with_year
deps:{"date::Date":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"traits::Datelike::with_year":{"Self":["traits::Datelike","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"traits::Datelike::with_year":{"Self":["naive::datetime::NaiveDateTime","date::Date","naive::date::NaiveDate","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0i32; // None+i32
+p0.with_year(p1);
+traits::Datelike::with_year(p0, p1);
+crate::traits::Datelike::with_year(p0, p1);
+crate::traits::Datelike::with_year(p0, p1);
-----------------
src/traits.rs traits::Datelike::with_month
deps:{"date::Date":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"traits::Datelike::with_month":{"Self":["traits::Datelike","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"traits::Datelike::with_month":{"Self":["naive::date::NaiveDate","datetime::DateTime","naive::datetime::NaiveDateTime","date::Date"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_month(p1);
+traits::Datelike::with_month(p0, p1);
+crate::traits::Datelike::with_month(p0, p1);
+crate::traits::Datelike::with_month(p0, p1);
-----------------
src/traits.rs traits::Datelike::with_month0
deps:{"date::Date":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"traits::Datelike::with_month0":{"Self":["traits::Datelike","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"traits::Datelike::with_month0":{"Self":["naive::datetime::NaiveDateTime","naive::date::NaiveDate","date::Date","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_month0(p1);
+traits::Datelike::with_month0(p0, p1);
+crate::traits::Datelike::with_month0(p0, p1);
+crate::traits::Datelike::with_month0(p0, p1);
-----------------
src/traits.rs traits::Datelike::with_day
deps:{"date::Date":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"traits::Datelike::with_day":{"Self":["std::marker::Sized","traits::Datelike"]}}
candidates:{"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"traits::Datelike::with_day":{"Self":["naive::datetime::NaiveDateTime","date::Date","naive::date::NaiveDate","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_day(p1);
+traits::Datelike::with_day(p0, p1);
+crate::traits::Datelike::with_day(p0, p1);
+crate::traits::Datelike::with_day(p0, p1);
-----------------
src/traits.rs traits::Datelike::with_day0
deps:{"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"traits::Datelike::with_day0":{"Self":["traits::Datelike","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"traits::Datelike::with_day0":{"Self":["datetime::DateTime","date::Date","naive::date::NaiveDate","naive::datetime::NaiveDateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_day0(p1);
+traits::Datelike::with_day0(p0, p1);
+crate::traits::Datelike::with_day0(p0, p1);
+crate::traits::Datelike::with_day0(p0, p1);
-----------------
src/traits.rs traits::Datelike::with_ordinal
deps:{"date::Date":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"traits::Datelike::with_ordinal":{"Self":["traits::Datelike","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"traits::Datelike::with_ordinal":{"Self":["naive::datetime::NaiveDateTime","datetime::DateTime","naive::date::NaiveDate","date::Date"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_ordinal(p1);
+traits::Datelike::with_ordinal(p0, p1);
+crate::traits::Datelike::with_ordinal(p0, p1);
+crate::traits::Datelike::with_ordinal(p0, p1);
-----------------
src/traits.rs traits::Datelike::with_ordinal0
deps:{"date::Date":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"traits::Datelike::with_ordinal0":{"Self":["traits::Datelike","std::marker::Sized"]}}
candidates:{"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"traits::Datelike::with_ordinal0":{"Self":["naive::date::NaiveDate","date::Date","datetime::DateTime","naive::datetime::NaiveDateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_ordinal0(p1);
+traits::Datelike::with_ordinal0(p0, p1);
+crate::traits::Datelike::with_ordinal0(p0, p1);
+crate::traits::Datelike::with_ordinal0(p0, p1);
-----------------
src/traits.rs traits::Datelike::num_days_from_ce
deps:{"date::Date":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"traits::Datelike::num_days_from_ce":{"Self":["std::marker::Sized","traits::Datelike"]}}
candidates:{"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"traits::Datelike::num_days_from_ce":{"Self":["naive::datetime::NaiveDateTime","naive::date::NaiveDate","datetime::DateTime","date::Date"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.num_days_from_ce();
+traits::Datelike::num_days_from_ce(p0);
+crate::traits::Datelike::num_days_from_ce(p0);
+crate::traits::Datelike::num_days_from_ce(p0);
-----------------
src/traits.rs traits::Timelike::hour
deps:{"datetime::DateTime":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"traits::Timelike::hour":{"Self":["traits::Timelike","std::marker::Sized"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"traits::Timelike::hour":{"Self":["naive::time::NaiveTime","naive::datetime::NaiveDateTime","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.hour();
+traits::Timelike::hour(p0);
+crate::traits::Timelike::hour(p0);
+crate::traits::Timelike::hour(p0);
-----------------
src/traits.rs traits::Timelike::hour12
deps:{"datetime::DateTime":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"traits::Timelike::hour12":{"Self":["std::marker::Sized","traits::Timelike"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"traits::Timelike::hour12":{"Self":["naive::datetime::NaiveDateTime","datetime::DateTime","naive::time::NaiveTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.hour12();
+traits::Timelike::hour12(p0);
+crate::traits::Timelike::hour12(p0);
+crate::traits::Timelike::hour12(p0);
-----------------
src/traits.rs traits::Timelike::minute
deps:{"datetime::DateTime":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"traits::Timelike::minute":{"Self":["traits::Timelike","std::marker::Sized"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"traits::Timelike::minute":{"Self":["naive::datetime::NaiveDateTime","naive::time::NaiveTime","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.minute();
+traits::Timelike::minute(p0);
+crate::traits::Timelike::minute(p0);
+crate::traits::Timelike::minute(p0);
-----------------
src/traits.rs traits::Timelike::second
deps:{"datetime::DateTime":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"traits::Timelike::second":{"Self":["std::marker::Sized","traits::Timelike"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"traits::Timelike::second":{"Self":["naive::datetime::NaiveDateTime","naive::time::NaiveTime","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.second();
+traits::Timelike::second(p0);
+crate::traits::Timelike::second(p0);
+crate::traits::Timelike::second(p0);
-----------------
src/traits.rs traits::Timelike::nanosecond
deps:{"datetime::DateTime":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"traits::Timelike::nanosecond":{"Self":["traits::Timelike","std::marker::Sized"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"traits::Timelike::nanosecond":{"Self":["datetime::DateTime","naive::time::NaiveTime","naive::datetime::NaiveDateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.nanosecond();
+traits::Timelike::nanosecond(p0);
+crate::traits::Timelike::nanosecond(p0);
+crate::traits::Timelike::nanosecond(p0);
-----------------
src/traits.rs traits::Timelike::with_hour
deps:{"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"traits::Timelike::with_hour":{"Self":["std::marker::Sized","traits::Timelike"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"traits::Timelike::with_hour":{"Self":["datetime::DateTime","naive::time::NaiveTime","naive::datetime::NaiveDateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_hour(p1);
+traits::Timelike::with_hour(p0, p1);
+crate::traits::Timelike::with_hour(p0, p1);
+crate::traits::Timelike::with_hour(p0, p1);
-----------------
src/traits.rs traits::Timelike::with_minute
deps:{"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"traits::Timelike::with_minute":{"Self":["std::marker::Sized","traits::Timelike"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"traits::Timelike::with_minute":{"Self":["naive::datetime::NaiveDateTime","naive::time::NaiveTime","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_minute(p1);
+traits::Timelike::with_minute(p0, p1);
+crate::traits::Timelike::with_minute(p0, p1);
+crate::traits::Timelike::with_minute(p0, p1);
-----------------
src/traits.rs traits::Timelike::with_second
deps:{"datetime::DateTime":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"traits::Timelike::with_second":{"Self":["std::marker::Sized","traits::Timelike"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"traits::Timelike::with_second":{"Self":["naive::datetime::NaiveDateTime","naive::time::NaiveTime","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_second(p1);
+traits::Timelike::with_second(p0, p1);
+crate::traits::Timelike::with_second(p0, p1);
+crate::traits::Timelike::with_second(p0, p1);
-----------------
src/traits.rs traits::Timelike::with_nanosecond
deps:{"datetime::DateTime":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"traits::Timelike::with_nanosecond":{"Self":["std::marker::Sized","traits::Timelike"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"traits::Timelike::with_nanosecond":{"Self":["naive::datetime::NaiveDateTime","naive::time::NaiveTime","datetime::DateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0u32; // None+u32
+p0.with_nanosecond(p1);
+traits::Timelike::with_nanosecond(p0, p1);
+crate::traits::Timelike::with_nanosecond(p0, p1);
+crate::traits::Timelike::with_nanosecond(p0, p1);
-----------------
src/traits.rs traits::Timelike::num_seconds_from_midnight
deps:{"datetime::DateTime":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"traits::Timelike::num_seconds_from_midnight":{"Self":["std::marker::Sized","traits::Timelike"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"traits::Timelike::num_seconds_from_midnight":{"Self":["datetime::DateTime","naive::time::NaiveTime","naive::datetime::NaiveDateTime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.num_seconds_from_midnight();
+traits::Timelike::num_seconds_from_midnight(p0);
+crate::traits::Timelike::num_seconds_from_midnight(p0);
+crate::traits::Timelike::num_seconds_from_midnight(p0);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.clone();
+<time_delta::TimeDelta as std::clone::Clone>::clone(p0);
+crate::<time_delta::TimeDelta as std::clone::Clone>::clone(p0);
+<time_delta::TimeDelta>::clone(p0);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.eq(p1);
+<time_delta::TimeDelta as std::cmp::PartialEq>::eq(p0, p1);
+crate::<time_delta::TimeDelta as std::cmp::PartialEq>::eq(p0, p1);
+<time_delta::TimeDelta>::eq(p0, p1);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.assert_receiver_is_total_eq();
+<time_delta::TimeDelta as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<time_delta::TimeDelta as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<time_delta::TimeDelta>::assert_receiver_is_total_eq(p0);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.partial_cmp(p1);
+<time_delta::TimeDelta as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<time_delta::TimeDelta as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<time_delta::TimeDelta>::partial_cmp(p0, p1);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.cmp(p1);
+<time_delta::TimeDelta as std::cmp::Ord>::cmp(p0, p1);
+crate::<time_delta::TimeDelta as std::cmp::Ord>::cmp(p0, p1);
+<time_delta::TimeDelta>::cmp(p0, p1);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<time_delta::TimeDelta as std::fmt::Debug>::fmt(p0, p1);
+crate::<time_delta::TimeDelta as std::fmt::Debug>::fmt(p0, p1);
+<time_delta::TimeDelta>::fmt(p0, p1);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<time_delta::TimeDelta as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<time_delta::TimeDelta as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<time_delta::TimeDelta as std::hash::Hash>::hash(p0, p1);
+crate::<time_delta::TimeDelta as std::hash::Hash>::hash(p0, p1);
+<time_delta::TimeDelta>::hash(p0, p1);
-----------------
src/time_delta.rs time_delta::TimeDelta::weeks
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+time_delta::TimeDelta::weeks(p0);
+crate::time_delta::TimeDelta::weeks(p0);
+<time_delta::TimeDelta>::weeks(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::days
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+time_delta::TimeDelta::days(p0);
+crate::time_delta::TimeDelta::days(p0);
+<time_delta::TimeDelta>::days(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::hours
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+time_delta::TimeDelta::hours(p0);
+crate::time_delta::TimeDelta::hours(p0);
+<time_delta::TimeDelta>::hours(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::minutes
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+time_delta::TimeDelta::minutes(p0);
+crate::time_delta::TimeDelta::minutes(p0);
+<time_delta::TimeDelta>::minutes(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::seconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+time_delta::TimeDelta::seconds(p0);
+crate::time_delta::TimeDelta::seconds(p0);
+<time_delta::TimeDelta>::seconds(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::milliseconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+time_delta::TimeDelta::milliseconds(p0);
+crate::time_delta::TimeDelta::milliseconds(p0);
+<time_delta::TimeDelta>::milliseconds(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::microseconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+time_delta::TimeDelta::microseconds(p0);
+crate::time_delta::TimeDelta::microseconds(p0);
+<time_delta::TimeDelta>::microseconds(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::nanoseconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+time_delta::TimeDelta::nanoseconds(p0);
+crate::time_delta::TimeDelta::nanoseconds(p0);
+<time_delta::TimeDelta>::nanoseconds(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::num_weeks
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.num_weeks();
+time_delta::TimeDelta::num_weeks(p0);
+crate::time_delta::TimeDelta::num_weeks(p0);
+<time_delta::TimeDelta>::num_weeks(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::num_days
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.num_days();
+time_delta::TimeDelta::num_days(p0);
+crate::time_delta::TimeDelta::num_days(p0);
+<time_delta::TimeDelta>::num_days(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::num_hours
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.num_hours();
+time_delta::TimeDelta::num_hours(p0);
+crate::time_delta::TimeDelta::num_hours(p0);
+<time_delta::TimeDelta>::num_hours(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::num_minutes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.num_minutes();
+time_delta::TimeDelta::num_minutes(p0);
+crate::time_delta::TimeDelta::num_minutes(p0);
+<time_delta::TimeDelta>::num_minutes(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::num_seconds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.num_seconds();
+time_delta::TimeDelta::num_seconds(p0);
+crate::time_delta::TimeDelta::num_seconds(p0);
+<time_delta::TimeDelta>::num_seconds(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::nanos_mod_sec
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.nanos_mod_sec();
+time_delta::TimeDelta::nanos_mod_sec(p0);
+crate::time_delta::TimeDelta::nanos_mod_sec(p0);
+<time_delta::TimeDelta>::nanos_mod_sec(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::num_milliseconds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.num_milliseconds();
+time_delta::TimeDelta::num_milliseconds(p0);
+crate::time_delta::TimeDelta::num_milliseconds(p0);
+<time_delta::TimeDelta>::num_milliseconds(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::num_microseconds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.num_microseconds();
+time_delta::TimeDelta::num_microseconds(p0);
+crate::time_delta::TimeDelta::num_microseconds(p0);
+<time_delta::TimeDelta>::num_microseconds(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::num_nanoseconds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.num_nanoseconds();
+time_delta::TimeDelta::num_nanoseconds(p0);
+crate::time_delta::TimeDelta::num_nanoseconds(p0);
+<time_delta::TimeDelta>::num_nanoseconds(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::checked_add
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_add(p1);
+time_delta::TimeDelta::checked_add(p0, p1);
+crate::time_delta::TimeDelta::checked_add(p0, p1);
+<time_delta::TimeDelta>::checked_add(p0, p1);
-----------------
src/time_delta.rs time_delta::TimeDelta::checked_sub
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_sub(p1);
+time_delta::TimeDelta::checked_sub(p0, p1);
+crate::time_delta::TimeDelta::checked_sub(p0, p1);
+<time_delta::TimeDelta>::checked_sub(p0, p1);
-----------------
src/time_delta.rs time_delta::TimeDelta::abs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.abs();
+time_delta::TimeDelta::abs(p0);
+crate::time_delta::TimeDelta::abs(p0);
+<time_delta::TimeDelta>::abs(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::min_value
deps:{}
candidates:{}
+time_delta::TimeDelta::min_value();
+crate::time_delta::TimeDelta::min_value();
+<time_delta::TimeDelta>::min_value();
-----------------
src/time_delta.rs time_delta::TimeDelta::max_value
deps:{}
candidates:{}
+time_delta::TimeDelta::max_value();
+crate::time_delta::TimeDelta::max_value();
+<time_delta::TimeDelta>::max_value();
-----------------
src/time_delta.rs time_delta::TimeDelta::zero
deps:{}
candidates:{}
+time_delta::TimeDelta::zero();
+crate::time_delta::TimeDelta::zero();
+<time_delta::TimeDelta>::zero();
-----------------
src/time_delta.rs time_delta::TimeDelta::is_zero
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.is_zero();
+time_delta::TimeDelta::is_zero(p0);
+crate::time_delta::TimeDelta::is_zero(p0);
+<time_delta::TimeDelta>::is_zero(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::from_std
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+time_delta::TimeDelta::from_std(p0);
+crate::time_delta::TimeDelta::from_std(p0);
+<time_delta::TimeDelta>::from_std(p0);
-----------------
src/time_delta.rs time_delta::TimeDelta::to_std
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.to_std();
+time_delta::TimeDelta::to_std(p0);
+crate::time_delta::TimeDelta::to_std(p0);
+<time_delta::TimeDelta>::to_std(p0);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::ops::Neg>::neg
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.neg();
+<time_delta::TimeDelta as std::ops::Neg>::neg(p0);
+crate::<time_delta::TimeDelta as std::ops::Neg>::neg(p0);
+<time_delta::TimeDelta>::neg(p0);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::ops::Add>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add(p1);
+<time_delta::TimeDelta as std::ops::Add>::add(p0, p1);
+crate::<time_delta::TimeDelta as std::ops::Add>::add(p0, p1);
+<time_delta::TimeDelta>::add(p0, p1);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub(p1);
+<time_delta::TimeDelta as std::ops::Sub>::sub(p0, p1);
+crate::<time_delta::TimeDelta as std::ops::Sub>::sub(p0, p1);
+<time_delta::TimeDelta>::sub(p0, p1);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::ops::Mul<i32>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = 0i32; // None+i32
+p0.mul(p1);
+<time_delta::TimeDelta as std::ops::Mul<i32>>::mul(p0, p1);
+crate::<time_delta::TimeDelta as std::ops::Mul<i32>>::mul(p0, p1);
+<time_delta::TimeDelta>::mul(p0, p1);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::ops::Div<i32>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = 0i32; // None+i32
+p0.div(p1);
+<time_delta::TimeDelta as std::ops::Div<i32>>::div(p0, p1);
+crate::<time_delta::TimeDelta as std::ops::Div<i32>>::div(p0, p1);
+<time_delta::TimeDelta>::div(p0, p1);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::iter::Sum<&'a time_delta::TimeDelta>>::sum
'a
deps:{"<&mut I as std::iter::Iterator>":{},"<time_delta::TimeDelta as std::iter::Sum<&'a time_delta::TimeDelta>>::sum":{"I":["std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&mut I as std::iter::Iterator>":{},"<time_delta::TimeDelta as std::iter::Sum<&'a time_delta::TimeDelta>>::sum":{"I":["naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","format::strftime::StrftimeItems","<&mut I as std::iter::Iterator>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<time_delta::TimeDelta as std::iter::Sum<&'a time_delta::TimeDelta>>::sum(p0);
+crate::<time_delta::TimeDelta as std::iter::Sum<&'a time_delta::TimeDelta>>::sum(p0);
+<time_delta::TimeDelta>::sum(p0);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::iter::Sum>::sum
deps:{"<&mut I as std::iter::Iterator>":{},"<time_delta::TimeDelta as std::iter::Sum>::sum":{"I":["std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&mut I as std::iter::Iterator>":{},"<time_delta::TimeDelta as std::iter::Sum>::sum":{"I":["format::strftime::StrftimeItems","<&mut I as std::iter::Iterator>","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<time_delta::TimeDelta as std::iter::Sum>::sum(p0);
+crate::<time_delta::TimeDelta as std::iter::Sum>::sum(p0);
+<time_delta::TimeDelta>::sum(p0);
-----------------
src/time_delta.rs <time_delta::TimeDelta as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<time_delta::TimeDelta as std::fmt::Display>::fmt(p0, p1);
+crate::<time_delta::TimeDelta as std::fmt::Display>::fmt(p0, p1);
+<time_delta::TimeDelta>::fmt(p0, p1);
-----------------
src/time_delta.rs <time_delta::OutOfRangeError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::OutOfRangeError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<time_delta::OutOfRangeError as std::fmt::Debug>::fmt(p0, p1);
+crate::<time_delta::OutOfRangeError as std::fmt::Debug>::fmt(p0, p1);
+<time_delta::OutOfRangeError>::fmt(p0, p1);
-----------------
src/time_delta.rs <time_delta::OutOfRangeError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::OutOfRangeError
+p0.clone();
+<time_delta::OutOfRangeError as std::clone::Clone>::clone(p0);
+crate::<time_delta::OutOfRangeError as std::clone::Clone>::clone(p0);
+<time_delta::OutOfRangeError>::clone(p0);
-----------------
src/time_delta.rs <time_delta::OutOfRangeError as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::OutOfRangeError
let mut p1 = & MaybeUninit::uninit().assume_init(); // time_delta::OutOfRangeError
+p0.eq(p1);
+<time_delta::OutOfRangeError as std::cmp::PartialEq>::eq(p0, p1);
+crate::<time_delta::OutOfRangeError as std::cmp::PartialEq>::eq(p0, p1);
+<time_delta::OutOfRangeError>::eq(p0, p1);
-----------------
src/time_delta.rs <time_delta::OutOfRangeError as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::OutOfRangeError
+p0.assert_receiver_is_total_eq();
+<time_delta::OutOfRangeError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<time_delta::OutOfRangeError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<time_delta::OutOfRangeError>::assert_receiver_is_total_eq(p0);
-----------------
src/time_delta.rs <time_delta::OutOfRangeError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::OutOfRangeError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<time_delta::OutOfRangeError as std::fmt::Display>::fmt(p0, p1);
+crate::<time_delta::OutOfRangeError as std::fmt::Display>::fmt(p0, p1);
+<time_delta::OutOfRangeError>::fmt(p0, p1);
-----------------
src/time_delta.rs <time_delta::OutOfRangeError as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time_delta::OutOfRangeError
+p0.description();
+<time_delta::OutOfRangeError as std::error::Error>::description(p0);
+crate::<time_delta::OutOfRangeError as std::error::Error>::description(p0);
+<time_delta::OutOfRangeError>::description(p0);
-----------------
src/date.rs <date::Date<Tz> as std::clone::Clone>::clone
deps:{"<date::Date<Tz> as std::clone::Clone>::clone":{"<Tz as offset::TimeZone>::Offset":["std::clone::Clone"],"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"offset::LocalResult":{"T":["std::marker::Sized","std::hash::Hash","std::clone::Clone","std::marker::Copy","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<date::Date<Tz> as std::clone::Clone>::clone":{"<Tz as offset::TimeZone>::Offset":["offset::local::Local","naive::datetime::NaiveDateTime","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::parser::Version","time_delta::OutOfRangeError","offset::utc::Utc","offset::local::tz_info::timezone::TimeZone","std::clone::impls::<impl std::clone::Clone for &T>","naive::internals::YearFlags","naive::date::NaiveDate","offset::local::tz_info::timezone::TimeZoneRef","format::ParseError","month::Months","round::RoundingError","format::Pad","datetime::DateTime","format::InternalNumeric","format::Numeric","month::ParseMonthError","offset::local::tz_info::rule::TransitionRule","weekday::Weekday","format::strftime::StrftimeItems","offset::local::tz_info::timezone::Transition","naive::internals::Mdf","format::Fixed","format::InternalInternal","datetime::SecondsFormat","weekday::ParseWeekdayError","format::Item","offset::fixed::FixedOffset","naive::date::Days","date::Date","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::rule::RuleDay","month::Month","offset::LocalResult","offset::local::tz_info::rule::AlternateTime","format::Void","naive::date::NaiveDateDaysIterator","format::InternalFixed","format::parsed::Parsed","naive::isoweek::IsoWeek","offset::local::tz_info::timezone::TimeZoneName","naive::internals::Of","format::Colons","naive::date::NaiveDateWeeksIterator","naive::time::NaiveTime","offset::local::tz_info::timezone::LeapSecond","time_delta::TimeDelta","format::ParseErrorKind","OutOfRange"],"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"date::Date":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"offset::LocalResult":{"T":["datetime::SecondsFormat","naive::internals::YearFlags","naive::date::Days","time_delta::TimeDelta","format::Pad","naive::date::NaiveDateDaysIterator","naive::datetime::NaiveDateTime","format::ParseError","std::clone::impls::<impl std::clone::Clone for *mut T>","format::ParseErrorKind","offset::LocalResult","naive::isoweek::IsoWeek","OutOfRange","date::Date","offset::utc::Utc","datetime::DateTime","month::Months","offset::fixed::FixedOffset","month::Month","naive::date::NaiveDate","weekday::Weekday","naive::date::NaiveDateWeeksIterator","naive::time::NaiveTime"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.clone();
+<date::Date<Tz> as std::clone::Clone>::clone(p0);
+crate::<date::Date<Tz> as std::clone::Clone>::clone(p0);
+<date::Date<Tz>>::clone(p0);
-----------------
src/date.rs date::Date::<Tz>::from_utc
deps:{"date::Date::<Tz>::from_utc":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::from_utc":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // <Tz as offset::TimeZone>::Offset
+date::Date::<Tz>::from_utc(p0, p1);
+crate::date::Date::<Tz>::from_utc(p0, p1);
+<date::Date<Tz>>::from_utc(p0, p1);
-----------------
src/date.rs date::Date::<Tz>::and_time
deps:{"date::Date::<Tz>::and_time":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::and_time":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.and_time(p1);
+date::Date::<Tz>::and_time(p0, p1);
+crate::date::Date::<Tz>::and_time(p0, p1);
+<date::Date<Tz>>::and_time(p0, p1);
-----------------
src/date.rs date::Date::<Tz>::and_hms
deps:{"date::Date::<Tz>::and_hms":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"date::Date::<Tz>::and_hms":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+p0.and_hms(p1, p2, p3);
+date::Date::<Tz>::and_hms(p0, p1, p2, p3);
+crate::date::Date::<Tz>::and_hms(p0, p1, p2, p3);
+<date::Date<Tz>>::and_hms(p0, p1, p2, p3);
-----------------
src/date.rs date::Date::<Tz>::and_hms_opt
deps:{"date::Date::<Tz>::and_hms_opt":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"date::Date::<Tz>::and_hms_opt":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+p0.and_hms_opt(p1, p2, p3);
+date::Date::<Tz>::and_hms_opt(p0, p1, p2, p3);
+crate::date::Date::<Tz>::and_hms_opt(p0, p1, p2, p3);
+<date::Date<Tz>>::and_hms_opt(p0, p1, p2, p3);
-----------------
src/date.rs date::Date::<Tz>::and_hms_milli
deps:{"date::Date::<Tz>::and_hms_milli":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::and_hms_milli":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_milli(p1, p2, p3, p4);
+date::Date::<Tz>::and_hms_milli(p0, p1, p2, p3, p4);
+crate::date::Date::<Tz>::and_hms_milli(p0, p1, p2, p3, p4);
+<date::Date<Tz>>::and_hms_milli(p0, p1, p2, p3, p4);
-----------------
src/date.rs date::Date::<Tz>::and_hms_milli_opt
deps:{"date::Date::<Tz>::and_hms_milli_opt":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::and_hms_milli_opt":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_milli_opt(p1, p2, p3, p4);
+date::Date::<Tz>::and_hms_milli_opt(p0, p1, p2, p3, p4);
+crate::date::Date::<Tz>::and_hms_milli_opt(p0, p1, p2, p3, p4);
+<date::Date<Tz>>::and_hms_milli_opt(p0, p1, p2, p3, p4);
-----------------
src/date.rs date::Date::<Tz>::and_hms_micro
deps:{"date::Date::<Tz>::and_hms_micro":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"date::Date::<Tz>::and_hms_micro":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_micro(p1, p2, p3, p4);
+date::Date::<Tz>::and_hms_micro(p0, p1, p2, p3, p4);
+crate::date::Date::<Tz>::and_hms_micro(p0, p1, p2, p3, p4);
+<date::Date<Tz>>::and_hms_micro(p0, p1, p2, p3, p4);
-----------------
src/date.rs date::Date::<Tz>::and_hms_micro_opt
deps:{"date::Date::<Tz>::and_hms_micro_opt":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"date::Date::<Tz>::and_hms_micro_opt":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_micro_opt(p1, p2, p3, p4);
+date::Date::<Tz>::and_hms_micro_opt(p0, p1, p2, p3, p4);
+crate::date::Date::<Tz>::and_hms_micro_opt(p0, p1, p2, p3, p4);
+<date::Date<Tz>>::and_hms_micro_opt(p0, p1, p2, p3, p4);
-----------------
src/date.rs date::Date::<Tz>::and_hms_nano
deps:{"date::Date::<Tz>::and_hms_nano":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"date::Date::<Tz>::and_hms_nano":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_nano(p1, p2, p3, p4);
+date::Date::<Tz>::and_hms_nano(p0, p1, p2, p3, p4);
+crate::date::Date::<Tz>::and_hms_nano(p0, p1, p2, p3, p4);
+<date::Date<Tz>>::and_hms_nano(p0, p1, p2, p3, p4);
-----------------
src/date.rs date::Date::<Tz>::and_hms_nano_opt
deps:{"date::Date::<Tz>::and_hms_nano_opt":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::and_hms_nano_opt":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_nano_opt(p1, p2, p3, p4);
+date::Date::<Tz>::and_hms_nano_opt(p0, p1, p2, p3, p4);
+crate::date::Date::<Tz>::and_hms_nano_opt(p0, p1, p2, p3, p4);
+<date::Date<Tz>>::and_hms_nano_opt(p0, p1, p2, p3, p4);
-----------------
src/date.rs date::Date::<Tz>::succ
deps:{"date::Date::<Tz>::succ":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::succ":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.succ();
+date::Date::<Tz>::succ(p0);
+crate::date::Date::<Tz>::succ(p0);
+<date::Date<Tz>>::succ(p0);
-----------------
src/date.rs date::Date::<Tz>::succ_opt
deps:{"date::Date::<Tz>::succ_opt":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::succ_opt":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.succ_opt();
+date::Date::<Tz>::succ_opt(p0);
+crate::date::Date::<Tz>::succ_opt(p0);
+<date::Date<Tz>>::succ_opt(p0);
-----------------
src/date.rs date::Date::<Tz>::pred
deps:{"date::Date::<Tz>::pred":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::pred":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.pred();
+date::Date::<Tz>::pred(p0);
+crate::date::Date::<Tz>::pred(p0);
+<date::Date<Tz>>::pred(p0);
-----------------
src/date.rs date::Date::<Tz>::pred_opt
deps:{"date::Date::<Tz>::pred_opt":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"date::Date::<Tz>::pred_opt":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.pred_opt();
+date::Date::<Tz>::pred_opt(p0);
+crate::date::Date::<Tz>::pred_opt(p0);
+<date::Date<Tz>>::pred_opt(p0);
-----------------
src/date.rs date::Date::<Tz>::offset
deps:{"date::Date::<Tz>::offset":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::offset":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.offset();
+date::Date::<Tz>::offset(p0);
+crate::date::Date::<Tz>::offset(p0);
+<date::Date<Tz>>::offset(p0);
-----------------
src/date.rs date::Date::<Tz>::timezone
deps:{"date::Date::<Tz>::timezone":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::timezone":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.timezone();
+date::Date::<Tz>::timezone(p0);
+crate::date::Date::<Tz>::timezone(p0);
+<date::Date<Tz>>::timezone(p0);
-----------------
src/date.rs date::Date::<Tz>::with_timezone
deps:{"date::Date::<Tz>::with_timezone":{"Tz":["offset::TimeZone","std::marker::Sized"],"Tz2":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"date::Date::<Tz>::with_timezone":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"],"Tz2":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Tz2
+p0.with_timezone(p1);
+date::Date::<Tz>::with_timezone(p0, p1);
+crate::date::Date::<Tz>::with_timezone(p0, p1);
+<date::Date<Tz>>::with_timezone(p0, p1);
-----------------
src/date.rs date::Date::<Tz>::checked_add_signed
deps:{"date::Date::<Tz>::checked_add_signed":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::checked_add_signed":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_add_signed(p1);
+date::Date::<Tz>::checked_add_signed(p0, p1);
+crate::date::Date::<Tz>::checked_add_signed(p0, p1);
+<date::Date<Tz>>::checked_add_signed(p0, p1);
-----------------
src/date.rs date::Date::<Tz>::checked_sub_signed
deps:{"date::Date::<Tz>::checked_sub_signed":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::checked_sub_signed":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_sub_signed(p1);
+date::Date::<Tz>::checked_sub_signed(p0, p1);
+crate::date::Date::<Tz>::checked_sub_signed(p0, p1);
+<date::Date<Tz>>::checked_sub_signed(p0, p1);
-----------------
src/date.rs date::Date::<Tz>::signed_duration_since
deps:{"date::Date::<Tz>::signed_duration_since":{"Tz":["offset::TimeZone","std::marker::Sized"],"Tz2":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::signed_duration_since":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"],"Tz2":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // date::Date<Tz2>
+p0.signed_duration_since(p1);
+date::Date::<Tz>::signed_duration_since(p0, p1);
+crate::date::Date::<Tz>::signed_duration_since(p0, p1);
+<date::Date<Tz>>::signed_duration_since(p0, p1);
-----------------
src/date.rs date::Date::<Tz>::naive_utc
deps:{"date::Date::<Tz>::naive_utc":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::naive_utc":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.naive_utc();
+date::Date::<Tz>::naive_utc(p0);
+crate::date::Date::<Tz>::naive_utc(p0);
+<date::Date<Tz>>::naive_utc(p0);
-----------------
src/date.rs date::Date::<Tz>::naive_local
deps:{"date::Date::<Tz>::naive_local":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"date::Date::<Tz>::naive_local":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.naive_local();
+date::Date::<Tz>::naive_local(p0);
+crate::date::Date::<Tz>::naive_local(p0);
+<date::Date<Tz>>::naive_local(p0);
-----------------
src/date.rs date::Date::<Tz>::years_since
deps:{"date::Date::<Tz>::years_since":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"date::Date::<Tz>::years_since":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.years_since(p1);
+date::Date::<Tz>::years_since(p0, p1);
+crate::date::Date::<Tz>::years_since(p0, p1);
+<date::Date<Tz>>::years_since(p0, p1);
-----------------
src/date.rs date::Date::<Tz>::format_with_items
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Display>":{},"<T as std::borrow::Borrow<T>>":{},"date::Date":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"date::Date::<Tz>::format_with_items":{"<Tz as offset::TimeZone>::Offset":["std::fmt::Display"],"B":["std::borrow::Borrow","std::marker::Sized"],"I":["std::marker::Sized","std::iter::Iterator","std::clone::Clone"],"Tz":["std::marker::Sized","offset::TimeZone"]},"datetime::DateTime":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"format::DelayedFormat":{"I":["std::iter::Iterator","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Display>":{},"<T as std::borrow::Borrow<T>>":{},"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"date::Date::<Tz>::format_with_items":{"<Tz as offset::TimeZone>::Offset":["offset::utc::Utc","offset::fixed::FixedOffset","naive::datetime::NaiveDateTime","naive::time::NaiveTime","time_delta::OutOfRangeError","time_delta::TimeDelta","OutOfRange","<&mut T as std::fmt::Display>","naive::date::NaiveDate","offset::local::tz_info::Error","weekday::Weekday","round::RoundingError","datetime::DateTime","weekday::ParseWeekdayError","format::DelayedFormat","date::Date","format::ParseError"],"B":["std::ffi::OsString","std::boxed::Box<T, A>","std::string::String","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::path::PathBuf","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::rc::Rc<T>"],"I":["naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","format::strftime::StrftimeItems"],"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"format::DelayedFormat":{"I":["naive::date::NaiveDateWeeksIterator","naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.format_with_items(p1);
+date::Date::<Tz>::format_with_items(p0, p1);
+crate::date::Date::<Tz>::format_with_items(p0, p1);
+<date::Date<Tz>>::format_with_items(p0, p1);
-----------------
src/date.rs date::Date::<Tz>::format
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"date::Date::<Tz>::format":{"<Tz as offset::TimeZone>::Offset":["std::fmt::Display"],"Tz":["std::marker::Sized","offset::TimeZone"]},"datetime::DateTime":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"format::DelayedFormat":{"I":["std::iter::Iterator","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"date::Date::<Tz>::format":{"<Tz as offset::TimeZone>::Offset":["naive::date::NaiveDate","offset::fixed::FixedOffset","datetime::DateTime","offset::local::tz_info::Error","weekday::Weekday","offset::utc::Utc","round::RoundingError","weekday::ParseWeekdayError","naive::time::NaiveTime","OutOfRange","time_delta::OutOfRangeError","time_delta::TimeDelta","format::ParseError","naive::datetime::NaiveDateTime","date::Date","<&T as std::fmt::Display>","format::DelayedFormat"],"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"format::DelayedFormat":{"I":["naive::date::NaiveDateWeeksIterator","format::strftime::StrftimeItems","naive::date::NaiveDateDaysIterator"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = "sample"; // None+&str
+p0.format(&p1);
+date::Date::<Tz>::format(p0, &p1);
+crate::date::Date::<Tz>::format(p0, &p1);
+<date::Date<Tz>>::format(p0, &p1);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::year
deps:{"<date::Date<Tz> as traits::Datelike>::year":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::year":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.year();
+<date::Date<Tz> as traits::Datelike>::year(p0);
+crate::<date::Date<Tz> as traits::Datelike>::year(p0);
+<date::Date<Tz>>::year(p0);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::month
deps:{"<date::Date<Tz> as traits::Datelike>::month":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::month":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.month();
+<date::Date<Tz> as traits::Datelike>::month(p0);
+crate::<date::Date<Tz> as traits::Datelike>::month(p0);
+<date::Date<Tz>>::month(p0);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::month0
deps:{"<date::Date<Tz> as traits::Datelike>::month0":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::month0":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.month0();
+<date::Date<Tz> as traits::Datelike>::month0(p0);
+crate::<date::Date<Tz> as traits::Datelike>::month0(p0);
+<date::Date<Tz>>::month0(p0);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::day
deps:{"<date::Date<Tz> as traits::Datelike>::day":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::day":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.day();
+<date::Date<Tz> as traits::Datelike>::day(p0);
+crate::<date::Date<Tz> as traits::Datelike>::day(p0);
+<date::Date<Tz>>::day(p0);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::day0
deps:{"<date::Date<Tz> as traits::Datelike>::day0":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::day0":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.day0();
+<date::Date<Tz> as traits::Datelike>::day0(p0);
+crate::<date::Date<Tz> as traits::Datelike>::day0(p0);
+<date::Date<Tz>>::day0(p0);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::ordinal
deps:{"<date::Date<Tz> as traits::Datelike>::ordinal":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::ordinal":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.ordinal();
+<date::Date<Tz> as traits::Datelike>::ordinal(p0);
+crate::<date::Date<Tz> as traits::Datelike>::ordinal(p0);
+<date::Date<Tz>>::ordinal(p0);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::ordinal0
deps:{"<date::Date<Tz> as traits::Datelike>::ordinal0":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::ordinal0":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.ordinal0();
+<date::Date<Tz> as traits::Datelike>::ordinal0(p0);
+crate::<date::Date<Tz> as traits::Datelike>::ordinal0(p0);
+<date::Date<Tz>>::ordinal0(p0);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::weekday
deps:{"<date::Date<Tz> as traits::Datelike>::weekday":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::weekday":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.weekday();
+<date::Date<Tz> as traits::Datelike>::weekday(p0);
+crate::<date::Date<Tz> as traits::Datelike>::weekday(p0);
+<date::Date<Tz>>::weekday(p0);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::iso_week
deps:{"<date::Date<Tz> as traits::Datelike>::iso_week":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::iso_week":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.iso_week();
+<date::Date<Tz> as traits::Datelike>::iso_week(p0);
+crate::<date::Date<Tz> as traits::Datelike>::iso_week(p0);
+<date::Date<Tz>>::iso_week(p0);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::with_year
deps:{"<date::Date<Tz> as traits::Datelike>::with_year":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::with_year":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0i32; // None+i32
+p0.with_year(p1);
+<date::Date<Tz> as traits::Datelike>::with_year(p0, p1);
+crate::<date::Date<Tz> as traits::Datelike>::with_year(p0, p1);
+<date::Date<Tz>>::with_year(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::with_month
deps:{"<date::Date<Tz> as traits::Datelike>::with_month":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::with_month":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_month(p1);
+<date::Date<Tz> as traits::Datelike>::with_month(p0, p1);
+crate::<date::Date<Tz> as traits::Datelike>::with_month(p0, p1);
+<date::Date<Tz>>::with_month(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::with_month0
deps:{"<date::Date<Tz> as traits::Datelike>::with_month0":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::with_month0":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_month0(p1);
+<date::Date<Tz> as traits::Datelike>::with_month0(p0, p1);
+crate::<date::Date<Tz> as traits::Datelike>::with_month0(p0, p1);
+<date::Date<Tz>>::with_month0(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::with_day
deps:{"<date::Date<Tz> as traits::Datelike>::with_day":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::with_day":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_day(p1);
+<date::Date<Tz> as traits::Datelike>::with_day(p0, p1);
+crate::<date::Date<Tz> as traits::Datelike>::with_day(p0, p1);
+<date::Date<Tz>>::with_day(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::with_day0
deps:{"<date::Date<Tz> as traits::Datelike>::with_day0":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::with_day0":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_day0(p1);
+<date::Date<Tz> as traits::Datelike>::with_day0(p0, p1);
+crate::<date::Date<Tz> as traits::Datelike>::with_day0(p0, p1);
+<date::Date<Tz>>::with_day0(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::with_ordinal
deps:{"<date::Date<Tz> as traits::Datelike>::with_ordinal":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::with_ordinal":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_ordinal(p1);
+<date::Date<Tz> as traits::Datelike>::with_ordinal(p0, p1);
+crate::<date::Date<Tz> as traits::Datelike>::with_ordinal(p0, p1);
+<date::Date<Tz>>::with_ordinal(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as traits::Datelike>::with_ordinal0
deps:{"<date::Date<Tz> as traits::Datelike>::with_ordinal0":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as traits::Datelike>::with_ordinal0":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_ordinal0(p1);
+<date::Date<Tz> as traits::Datelike>::with_ordinal0(p0, p1);
+crate::<date::Date<Tz> as traits::Datelike>::with_ordinal0(p0, p1);
+<date::Date<Tz>>::with_ordinal0(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::cmp::PartialEq<date::Date<Tz2>>>::eq
deps:{"<date::Date<Tz> as std::cmp::PartialEq<date::Date<Tz2>>>::eq":{"Tz":["offset::TimeZone","std::marker::Sized"],"Tz2":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as std::cmp::PartialEq<date::Date<Tz2>>>::eq":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"],"Tz2":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz2>
+p0.eq(p1);
+<date::Date<Tz> as std::cmp::PartialEq<date::Date<Tz2>>>::eq(p0, p1);
+crate::<date::Date<Tz> as std::cmp::PartialEq<date::Date<Tz2>>>::eq(p0, p1);
+<date::Date<Tz>>::eq(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::cmp::PartialOrd>::partial_cmp
deps:{"<date::Date<Tz> as std::cmp::PartialOrd>::partial_cmp":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as std::cmp::PartialOrd>::partial_cmp":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.partial_cmp(p1);
+<date::Date<Tz> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<date::Date<Tz> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<date::Date<Tz>>::partial_cmp(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::cmp::Ord>::cmp
deps:{"<date::Date<Tz> as std::cmp::Ord>::cmp":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as std::cmp::Ord>::cmp":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.cmp(p1);
+<date::Date<Tz> as std::cmp::Ord>::cmp(p0, p1);
+crate::<date::Date<Tz> as std::cmp::Ord>::cmp(p0, p1);
+<date::Date<Tz>>::cmp(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<date::Date<Tz> as std::hash::Hash>::hash":{"H":["std::hash::Hasher","std::marker::Sized"],"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<date::Date<Tz> as std::hash::Hash>::hash":{"H":["std::hash::sip::Hasher<S>","std::hash::SipHasher","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher"],"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<date::Date<Tz> as std::hash::Hash>::hash(p0, p1);
+crate::<date::Date<Tz> as std::hash::Hash>::hash(p0, p1);
+<date::Date<Tz>>::hash(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::ops::Add<time_delta::TimeDelta>>::add
deps:{"<date::Date<Tz> as std::ops::Add<time_delta::TimeDelta>>::add":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as std::ops::Add<time_delta::TimeDelta>>::add":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add(p1);
+<date::Date<Tz> as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+crate::<date::Date<Tz> as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+<date::Date<Tz>>::add(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign
deps:{"<date::Date<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add_assign(p1);
+<date::Date<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+crate::<date::Date<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+<date::Date<Tz>>::add_assign(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub
deps:{"<date::Date<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub(p1);
+<date::Date<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+crate::<date::Date<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+<date::Date<Tz>>::sub(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign
deps:{"<date::Date<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub_assign(p1);
+<date::Date<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+crate::<date::Date<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+<date::Date<Tz>>::sub_assign(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::ops::Sub>::sub
deps:{"<date::Date<Tz> as std::ops::Sub>::sub":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<date::Date<Tz> as std::ops::Sub>::sub":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // date::Date<Tz>
+p0.sub(p1);
+<date::Date<Tz> as std::ops::Sub>::sub(p0, p1);
+crate::<date::Date<Tz> as std::ops::Sub>::sub(p0, p1);
+<date::Date<Tz>>::sub(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::fmt::Debug>::fmt
deps:{"<date::Date<Tz> as std::fmt::Debug>::fmt":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<date::Date<Tz> as std::fmt::Debug>::fmt":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<date::Date<Tz> as std::fmt::Debug>::fmt(p0, p1);
+crate::<date::Date<Tz> as std::fmt::Debug>::fmt(p0, p1);
+<date::Date<Tz>>::fmt(p0, p1);
-----------------
src/date.rs <date::Date<Tz> as std::fmt::Display>::fmt
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<date::Date<Tz> as std::fmt::Display>::fmt":{"<Tz as offset::TimeZone>::Offset":["std::fmt::Display"],"Tz":["std::marker::Sized","offset::TimeZone"]},"date::Date":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"format::DelayedFormat":{"I":["std::clone::Clone","std::marker::Sized","std::iter::Iterator","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<date::Date<Tz> as std::fmt::Display>::fmt":{"<Tz as offset::TimeZone>::Offset":["format::DelayedFormat","weekday::Weekday","naive::datetime::NaiveDateTime","OutOfRange","time_delta::OutOfRangeError","time_delta::TimeDelta","datetime::DateTime","<&mut T as std::fmt::Display>","round::RoundingError","weekday::ParseWeekdayError","format::ParseError","offset::local::tz_info::Error","offset::utc::Utc","naive::time::NaiveTime","date::Date","naive::date::NaiveDate","offset::fixed::FixedOffset"],"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"format::DelayedFormat":{"I":["naive::date::NaiveDateWeeksIterator","naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date<Tz>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<date::Date<Tz> as std::fmt::Display>::fmt(p0, p1);
+crate::<date::Date<Tz> as std::fmt::Display>::fmt(p0, p1);
+<date::Date<Tz>>::fmt(p0, p1);
-----------------
src/datetime/mod.rs <datetime::SecondsFormat as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::SecondsFormat
+p0.clone();
+<datetime::SecondsFormat as std::clone::Clone>::clone(p0);
+crate::<datetime::SecondsFormat as std::clone::Clone>::clone(p0);
+<datetime::SecondsFormat>::clone(p0);
-----------------
src/datetime/mod.rs <datetime::SecondsFormat as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::SecondsFormat
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::SecondsFormat as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::SecondsFormat as std::fmt::Debug>::fmt(p0, p1);
+<datetime::SecondsFormat>::fmt(p0, p1);
-----------------
src/datetime/mod.rs <datetime::SecondsFormat as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::SecondsFormat
+p0.assert_receiver_is_total_eq();
+<datetime::SecondsFormat as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<datetime::SecondsFormat as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<datetime::SecondsFormat>::assert_receiver_is_total_eq(p0);
-----------------
src/datetime/mod.rs <datetime::SecondsFormat as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::SecondsFormat
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::SecondsFormat
+p0.eq(p1);
+<datetime::SecondsFormat as std::cmp::PartialEq>::eq(p0, p1);
+crate::<datetime::SecondsFormat as std::cmp::PartialEq>::eq(p0, p1);
+<datetime::SecondsFormat>::eq(p0, p1);
-----------------
src/datetime/mod.rs <datetime::SecondsFormat as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<datetime::SecondsFormat as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<datetime::SecondsFormat as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::SecondsFormat
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<datetime::SecondsFormat as std::hash::Hash>::hash(p0, p1);
+crate::<datetime::SecondsFormat as std::hash::Hash>::hash(p0, p1);
+<datetime::SecondsFormat>::hash(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::clone::Clone>::clone
deps:{"<datetime::DateTime<Tz> as std::clone::Clone>::clone":{"<Tz as offset::TimeZone>::Offset":["std::clone::Clone"],"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"date::Date":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"offset::LocalResult":{"T":["std::cmp::Eq","std::hash::Hash","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::marker::Copy","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{}}
candidates:{"<datetime::DateTime<Tz> as std::clone::Clone>::clone":{"<Tz as offset::TimeZone>::Offset":["naive::internals::Of","offset::local::tz_info::timezone::LocalTimeType","weekday::ParseWeekdayError","format::Fixed","naive::time::NaiveTime","round::RoundingError","format::InternalNumeric","format::Item","time_delta::OutOfRangeError","offset::LocalResult","format::Numeric","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::rule::RuleDay","naive::date::NaiveDateWeeksIterator","naive::date::Days","std::clone::impls::<impl std::clone::Clone for *mut T>","time_delta::TimeDelta","format::InternalInternal","weekday::Weekday","naive::internals::YearFlags","format::ParseErrorKind","OutOfRange","month::Month","offset::local::tz_info::timezone::LeapSecond","month::Months","offset::local::tz_info::parser::Version","format::Colons","naive::date::NaiveDate","date::Date","datetime::DateTime","naive::internals::Mdf","offset::fixed::FixedOffset","naive::date::NaiveDateDaysIterator","datetime::SecondsFormat","format::parsed::Parsed","format::Void","month::ParseMonthError","offset::utc::Utc","naive::isoweek::IsoWeek","format::ParseError","offset::local::tz_info::rule::AlternateTime","format::InternalFixed","offset::local::tz_info::timezone::Transition","naive::datetime::NaiveDateTime","offset::local::tz_info::timezone::TimeZone","format::Pad","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::rule::UtcDateTime","format::strftime::StrftimeItems","offset::local::Local","offset::local::tz_info::rule::TransitionRule"],"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"offset::LocalResult":{"T":["month::Month","naive::date::NaiveDate","naive::isoweek::IsoWeek","naive::time::NaiveTime","std::marker::copy_impls::<impl std::marker::Copy for *const T>","offset::utc::Utc","weekday::Weekday","naive::datetime::NaiveDateTime","OutOfRange","format::Pad","offset::LocalResult","naive::internals::YearFlags","format::ParseError","time_delta::TimeDelta","datetime::SecondsFormat","date::Date","naive::date::NaiveDateDaysIterator","month::Months","offset::fixed::FixedOffset","format::ParseErrorKind","naive::date::NaiveDateWeeksIterator","datetime::DateTime","naive::date::Days"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.clone();
+<datetime::DateTime<Tz> as std::clone::Clone>::clone(p0);
+crate::<datetime::DateTime<Tz> as std::clone::Clone>::clone(p0);
+<datetime::DateTime<Tz>>::clone(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::from_utc
deps:{"datetime::DateTime::<Tz>::from_utc":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::from_utc":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // <Tz as offset::TimeZone>::Offset
+datetime::DateTime::<Tz>::from_utc(p0, p1);
+crate::datetime::DateTime::<Tz>::from_utc(p0, p1);
+<datetime::DateTime<Tz>>::from_utc(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::from_local
deps:{"datetime::DateTime::<Tz>::from_local":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::from_local":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // <Tz as offset::TimeZone>::Offset
+datetime::DateTime::<Tz>::from_local(p0, p1);
+crate::datetime::DateTime::<Tz>::from_local(p0, p1);
+<datetime::DateTime<Tz>>::from_local(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::date
deps:{"datetime::DateTime::<Tz>::date":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::date":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.date();
+datetime::DateTime::<Tz>::date(p0);
+crate::datetime::DateTime::<Tz>::date(p0);
+<datetime::DateTime<Tz>>::date(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::date_naive
deps:{"datetime::DateTime::<Tz>::date_naive":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::date_naive":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.date_naive();
+datetime::DateTime::<Tz>::date_naive(p0);
+crate::datetime::DateTime::<Tz>::date_naive(p0);
+<datetime::DateTime<Tz>>::date_naive(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::time
deps:{"datetime::DateTime::<Tz>::time":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::time":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.time();
+datetime::DateTime::<Tz>::time(p0);
+crate::datetime::DateTime::<Tz>::time(p0);
+<datetime::DateTime<Tz>>::time(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::timestamp
deps:{"datetime::DateTime::<Tz>::timestamp":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::timestamp":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.timestamp();
+datetime::DateTime::<Tz>::timestamp(p0);
+crate::datetime::DateTime::<Tz>::timestamp(p0);
+<datetime::DateTime<Tz>>::timestamp(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::timestamp_millis
deps:{"datetime::DateTime::<Tz>::timestamp_millis":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::timestamp_millis":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.timestamp_millis();
+datetime::DateTime::<Tz>::timestamp_millis(p0);
+crate::datetime::DateTime::<Tz>::timestamp_millis(p0);
+<datetime::DateTime<Tz>>::timestamp_millis(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::timestamp_micros
deps:{"datetime::DateTime::<Tz>::timestamp_micros":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::timestamp_micros":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.timestamp_micros();
+datetime::DateTime::<Tz>::timestamp_micros(p0);
+crate::datetime::DateTime::<Tz>::timestamp_micros(p0);
+<datetime::DateTime<Tz>>::timestamp_micros(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::timestamp_nanos
deps:{"datetime::DateTime::<Tz>::timestamp_nanos":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::timestamp_nanos":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.timestamp_nanos();
+datetime::DateTime::<Tz>::timestamp_nanos(p0);
+crate::datetime::DateTime::<Tz>::timestamp_nanos(p0);
+<datetime::DateTime<Tz>>::timestamp_nanos(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::timestamp_subsec_millis
deps:{"datetime::DateTime::<Tz>::timestamp_subsec_millis":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::timestamp_subsec_millis":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.timestamp_subsec_millis();
+datetime::DateTime::<Tz>::timestamp_subsec_millis(p0);
+crate::datetime::DateTime::<Tz>::timestamp_subsec_millis(p0);
+<datetime::DateTime<Tz>>::timestamp_subsec_millis(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::timestamp_subsec_micros
deps:{"datetime::DateTime::<Tz>::timestamp_subsec_micros":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::timestamp_subsec_micros":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.timestamp_subsec_micros();
+datetime::DateTime::<Tz>::timestamp_subsec_micros(p0);
+crate::datetime::DateTime::<Tz>::timestamp_subsec_micros(p0);
+<datetime::DateTime<Tz>>::timestamp_subsec_micros(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::timestamp_subsec_nanos
deps:{"datetime::DateTime::<Tz>::timestamp_subsec_nanos":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::timestamp_subsec_nanos":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.timestamp_subsec_nanos();
+datetime::DateTime::<Tz>::timestamp_subsec_nanos(p0);
+crate::datetime::DateTime::<Tz>::timestamp_subsec_nanos(p0);
+<datetime::DateTime<Tz>>::timestamp_subsec_nanos(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::offset
deps:{"datetime::DateTime::<Tz>::offset":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::offset":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.offset();
+datetime::DateTime::<Tz>::offset(p0);
+crate::datetime::DateTime::<Tz>::offset(p0);
+<datetime::DateTime<Tz>>::offset(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::timezone
deps:{"datetime::DateTime::<Tz>::timezone":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::timezone":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.timezone();
+datetime::DateTime::<Tz>::timezone(p0);
+crate::datetime::DateTime::<Tz>::timezone(p0);
+<datetime::DateTime<Tz>>::timezone(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::with_timezone
deps:{"datetime::DateTime::<Tz>::with_timezone":{"Tz":["std::marker::Sized","offset::TimeZone"],"Tz2":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::with_timezone":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"],"Tz2":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Tz2
+p0.with_timezone(p1);
+datetime::DateTime::<Tz>::with_timezone(p0, p1);
+crate::datetime::DateTime::<Tz>::with_timezone(p0, p1);
+<datetime::DateTime<Tz>>::with_timezone(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::fixed_offset
deps:{"datetime::DateTime::<Tz>::fixed_offset":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::fixed_offset":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.fixed_offset();
+datetime::DateTime::<Tz>::fixed_offset(p0);
+crate::datetime::DateTime::<Tz>::fixed_offset(p0);
+<datetime::DateTime<Tz>>::fixed_offset(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::checked_add_signed
deps:{"datetime::DateTime::<Tz>::checked_add_signed":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::checked_add_signed":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_add_signed(p1);
+datetime::DateTime::<Tz>::checked_add_signed(p0, p1);
+crate::datetime::DateTime::<Tz>::checked_add_signed(p0, p1);
+<datetime::DateTime<Tz>>::checked_add_signed(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::checked_add_months
deps:{"datetime::DateTime::<Tz>::checked_add_months":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::checked_add_months":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.checked_add_months(p1);
+datetime::DateTime::<Tz>::checked_add_months(p0, p1);
+crate::datetime::DateTime::<Tz>::checked_add_months(p0, p1);
+<datetime::DateTime<Tz>>::checked_add_months(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::checked_sub_signed
deps:{"datetime::DateTime::<Tz>::checked_sub_signed":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::checked_sub_signed":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_sub_signed(p1);
+datetime::DateTime::<Tz>::checked_sub_signed(p0, p1);
+crate::datetime::DateTime::<Tz>::checked_sub_signed(p0, p1);
+<datetime::DateTime<Tz>>::checked_sub_signed(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::checked_sub_months
deps:{"datetime::DateTime::<Tz>::checked_sub_months":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::checked_sub_months":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.checked_sub_months(p1);
+datetime::DateTime::<Tz>::checked_sub_months(p0, p1);
+crate::datetime::DateTime::<Tz>::checked_sub_months(p0, p1);
+<datetime::DateTime<Tz>>::checked_sub_months(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::checked_add_days
deps:{"datetime::DateTime::<Tz>::checked_add_days":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::checked_add_days":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.checked_add_days(p1);
+datetime::DateTime::<Tz>::checked_add_days(p0, p1);
+crate::datetime::DateTime::<Tz>::checked_add_days(p0, p1);
+<datetime::DateTime<Tz>>::checked_add_days(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::checked_sub_days
deps:{"datetime::DateTime::<Tz>::checked_sub_days":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::checked_sub_days":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.checked_sub_days(p1);
+datetime::DateTime::<Tz>::checked_sub_days(p0, p1);
+crate::datetime::DateTime::<Tz>::checked_sub_days(p0, p1);
+<datetime::DateTime<Tz>>::checked_sub_days(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::signed_duration_since
deps:{"datetime::DateTime::<Tz>::signed_duration_since":{"Tz":["std::marker::Sized","offset::TimeZone"],"Tz2":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::signed_duration_since":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"],"Tz2":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz2>
+p0.signed_duration_since(p1);
+datetime::DateTime::<Tz>::signed_duration_since(p0, p1);
+crate::datetime::DateTime::<Tz>::signed_duration_since(p0, p1);
+<datetime::DateTime<Tz>>::signed_duration_since(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::naive_utc
deps:{"datetime::DateTime::<Tz>::naive_utc":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::DateTime::<Tz>::naive_utc":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.naive_utc();
+datetime::DateTime::<Tz>::naive_utc(p0);
+crate::datetime::DateTime::<Tz>::naive_utc(p0);
+<datetime::DateTime<Tz>>::naive_utc(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::naive_local
deps:{"datetime::DateTime::<Tz>::naive_local":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::naive_local":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.naive_local();
+datetime::DateTime::<Tz>::naive_local(p0);
+crate::datetime::DateTime::<Tz>::naive_local(p0);
+<datetime::DateTime<Tz>>::naive_local(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::years_since
deps:{"datetime::DateTime::<Tz>::years_since":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"datetime::DateTime::<Tz>::years_since":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.years_since(p1);
+datetime::DateTime::<Tz>::years_since(p0, p1);
+crate::datetime::DateTime::<Tz>::years_since(p0, p1);
+<datetime::DateTime<Tz>>::years_since(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::utc::Utc> as std::default::Default>::default
deps:{}
candidates:{}
+<datetime::DateTime<offset::utc::Utc> as std::default::Default>::default();
+crate::<datetime::DateTime<offset::utc::Utc> as std::default::Default>::default();
+<datetime::DateTime<offset::utc::Utc>>::default();
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::local::Local> as std::default::Default>::default
deps:{}
candidates:{}
+<datetime::DateTime<offset::local::Local> as std::default::Default>::default();
+crate::<datetime::DateTime<offset::local::Local> as std::default::Default>::default();
+<datetime::DateTime<offset::local::Local>>::default();
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::fixed::FixedOffset> as std::default::Default>::default
deps:{}
candidates:{}
+<datetime::DateTime<offset::fixed::FixedOffset> as std::default::Default>::default();
+crate::<datetime::DateTime<offset::fixed::FixedOffset> as std::default::Default>::default();
+<datetime::DateTime<offset::fixed::FixedOffset>>::default();
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<offset::utc::Utc>
+<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from(p0);
+crate::<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from(p0);
+<datetime::DateTime<offset::fixed::FixedOffset>>::from(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<offset::utc::Utc>
+<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from(p0);
+crate::<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from(p0);
+<datetime::DateTime<offset::local::Local>>::from(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<offset::fixed::FixedOffset>
+<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from(p0);
+crate::<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from(p0);
+<datetime::DateTime<offset::utc::Utc>>::from(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<offset::fixed::FixedOffset>
+<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from(p0);
+crate::<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from(p0);
+<datetime::DateTime<offset::local::Local>>::from(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<offset::local::Local>
+<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from(p0);
+crate::<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from(p0);
+<datetime::DateTime<offset::utc::Utc>>::from(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<offset::local::Local>
+<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from(p0);
+crate::<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from(p0);
+<datetime::DateTime<offset::fixed::FixedOffset>>::from(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc2822
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc2822(&p0);
+crate::datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc2822(&p0);
+<datetime::DateTime<offset::fixed::FixedOffset>>::parse_from_rfc2822(&p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc3339
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc3339(&p0);
+crate::datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc3339(&p0);
+<datetime::DateTime<offset::fixed::FixedOffset>>::parse_from_rfc3339(&p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = "sample"; // None+&str
+datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_str(&p0, &p1);
+crate::datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_str(&p0, &p1);
+<datetime::DateTime<offset::fixed::FixedOffset>>::parse_from_str(&p0, &p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<offset::utc::Utc>::parse_from_rfc2822
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+datetime::DateTime::<offset::utc::Utc>::parse_from_rfc2822(&p0);
+crate::datetime::DateTime::<offset::utc::Utc>::parse_from_rfc2822(&p0);
+<datetime::DateTime<offset::utc::Utc>>::parse_from_rfc2822(&p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<offset::utc::Utc>::parse_from_rfc3339
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+datetime::DateTime::<offset::utc::Utc>::parse_from_rfc3339(&p0);
+crate::datetime::DateTime::<offset::utc::Utc>::parse_from_rfc3339(&p0);
+<datetime::DateTime<offset::utc::Utc>>::parse_from_rfc3339(&p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<offset::utc::Utc>::parse_from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = "sample"; // None+&str
+datetime::DateTime::<offset::utc::Utc>::parse_from_str(&p0, &p1);
+crate::datetime::DateTime::<offset::utc::Utc>::parse_from_str(&p0, &p1);
+<datetime::DateTime<offset::utc::Utc>>::parse_from_str(&p0, &p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::to_rfc2822
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"datetime::DateTime::<Tz>::to_rfc2822":{"<Tz as offset::TimeZone>::Offset":["std::fmt::Display"],"Tz":["std::marker::Sized","offset::TimeZone"]},"format::DelayedFormat":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"datetime::DateTime::<Tz>::to_rfc2822":{"<Tz as offset::TimeZone>::Offset":["datetime::DateTime","naive::time::NaiveTime","format::DelayedFormat","offset::local::tz_info::Error","offset::fixed::FixedOffset","time_delta::TimeDelta","format::ParseError","date::Date","<&mut T as std::fmt::Display>","round::RoundingError","naive::datetime::NaiveDateTime","time_delta::OutOfRangeError","weekday::ParseWeekdayError","OutOfRange","offset::utc::Utc","naive::date::NaiveDate","weekday::Weekday"],"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"format::DelayedFormat":{"I":["format::strftime::StrftimeItems","naive::date::NaiveDateWeeksIterator","naive::date::NaiveDateDaysIterator"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.to_rfc2822();
+datetime::DateTime::<Tz>::to_rfc2822(p0);
+crate::datetime::DateTime::<Tz>::to_rfc2822(p0);
+<datetime::DateTime<Tz>>::to_rfc2822(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::to_rfc3339
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"datetime::DateTime::<Tz>::to_rfc3339":{"<Tz as offset::TimeZone>::Offset":["std::fmt::Display"],"Tz":["std::marker::Sized","offset::TimeZone"]},"format::DelayedFormat":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::iter::Iterator"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"datetime::DateTime::<Tz>::to_rfc3339":{"<Tz as offset::TimeZone>::Offset":["naive::date::NaiveDate","naive::time::NaiveTime","datetime::DateTime","OutOfRange","offset::local::tz_info::Error","time_delta::OutOfRangeError","weekday::ParseWeekdayError","round::RoundingError","time_delta::TimeDelta","offset::fixed::FixedOffset","date::Date","<&mut T as std::fmt::Display>","offset::utc::Utc","format::DelayedFormat","format::ParseError","naive::datetime::NaiveDateTime","weekday::Weekday"],"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"format::DelayedFormat":{"I":["naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems","naive::date::NaiveDateWeeksIterator"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.to_rfc3339();
+datetime::DateTime::<Tz>::to_rfc3339(p0);
+crate::datetime::DateTime::<Tz>::to_rfc3339(p0);
+<datetime::DateTime<Tz>>::to_rfc3339(p0);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::to_rfc3339_opts
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime::<Tz>::to_rfc3339_opts":{"<Tz as offset::TimeZone>::Offset":["std::fmt::Display"],"Tz":["std::marker::Sized","offset::TimeZone"]},"format::DelayedFormat":{"I":["std::iter::Iterator","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"datetime::DateTime::<Tz>::to_rfc3339_opts":{"<Tz as offset::TimeZone>::Offset":["format::DelayedFormat","OutOfRange","round::RoundingError","naive::date::NaiveDate","<&T as std::fmt::Display>","time_delta::OutOfRangeError","weekday::ParseWeekdayError","offset::utc::Utc","date::Date","offset::local::tz_info::Error","naive::time::NaiveTime","time_delta::TimeDelta","weekday::Weekday","datetime::DateTime","format::ParseError","naive::datetime::NaiveDateTime","offset::fixed::FixedOffset"],"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"format::DelayedFormat":{"I":["format::strftime::StrftimeItems","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // datetime::SecondsFormat
let mut p2 = true; // None+bool
+p0.to_rfc3339_opts(p1, p2);
+datetime::DateTime::<Tz>::to_rfc3339_opts(p0, p1, p2);
+crate::datetime::DateTime::<Tz>::to_rfc3339_opts(p0, p1, p2);
+<datetime::DateTime<Tz>>::to_rfc3339_opts(p0, p1, p2);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::format_with_items
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Display>":{},"<T as std::borrow::Borrow<T>>":{},"date::Date":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"datetime::DateTime::<Tz>::format_with_items":{"<Tz as offset::TimeZone>::Offset":["std::fmt::Display"],"B":["std::marker::Sized","std::borrow::Borrow"],"I":["std::marker::Sized","std::iter::Iterator","std::clone::Clone"],"Tz":["offset::TimeZone","std::marker::Sized"]},"format::DelayedFormat":{"I":["std::fmt::Debug","std::clone::Clone","std::iter::Iterator","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Display>":{},"<T as std::borrow::Borrow<T>>":{},"date::Date":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"datetime::DateTime::<Tz>::format_with_items":{"<Tz as offset::TimeZone>::Offset":["round::RoundingError","format::ParseError","date::Date","weekday::Weekday","format::DelayedFormat","offset::fixed::FixedOffset","offset::local::tz_info::Error","datetime::DateTime","<&mut T as std::fmt::Display>","time_delta::TimeDelta","weekday::ParseWeekdayError","time_delta::OutOfRangeError","OutOfRange","naive::date::NaiveDate","offset::utc::Utc","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"B":["std::rc::Rc<T>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::string::String","std::sync::Arc<T>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::path::PathBuf"],"I":["naive::date::NaiveDateWeeksIterator","naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems"],"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"format::DelayedFormat":{"I":["naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","format::strftime::StrftimeItems"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.format_with_items(p1);
+datetime::DateTime::<Tz>::format_with_items(p0, p1);
+crate::datetime::DateTime::<Tz>::format_with_items(p0, p1);
+<datetime::DateTime<Tz>>::format_with_items(p0, p1);
-----------------
src/datetime/mod.rs datetime::DateTime::<Tz>::format
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"datetime::DateTime":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"datetime::DateTime::<Tz>::format":{"<Tz as offset::TimeZone>::Offset":["std::fmt::Display"],"Tz":["std::marker::Sized","offset::TimeZone"]},"format::DelayedFormat":{"I":["std::fmt::Debug","std::marker::Sized","std::iter::Iterator","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"datetime::DateTime::<Tz>::format":{"<Tz as offset::TimeZone>::Offset":["datetime::DateTime","weekday::Weekday","round::RoundingError","time_delta::TimeDelta","time_delta::OutOfRangeError","weekday::ParseWeekdayError","naive::time::NaiveTime","format::DelayedFormat","naive::date::NaiveDate","format::ParseError","<&mut T as std::fmt::Display>","OutOfRange","offset::utc::Utc","naive::datetime::NaiveDateTime","offset::fixed::FixedOffset","offset::local::tz_info::Error","date::Date"],"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"format::DelayedFormat":{"I":["naive::date::NaiveDateWeeksIterator","naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = "sample"; // None+&str
+p0.format(&p1);
+datetime::DateTime::<Tz>::format(p0, &p1);
+crate::datetime::DateTime::<Tz>::format(p0, &p1);
+<datetime::DateTime<Tz>>::format(p0, &p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::year
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::year":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::year":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.year();
+<datetime::DateTime<Tz> as traits::Datelike>::year(p0);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::year(p0);
+<datetime::DateTime<Tz>>::year(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::month
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::month":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::month":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.month();
+<datetime::DateTime<Tz> as traits::Datelike>::month(p0);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::month(p0);
+<datetime::DateTime<Tz>>::month(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::month0
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::month0":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::month0":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.month0();
+<datetime::DateTime<Tz> as traits::Datelike>::month0(p0);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::month0(p0);
+<datetime::DateTime<Tz>>::month0(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::day
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::day":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::day":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.day();
+<datetime::DateTime<Tz> as traits::Datelike>::day(p0);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::day(p0);
+<datetime::DateTime<Tz>>::day(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::day0
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::day0":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::day0":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.day0();
+<datetime::DateTime<Tz> as traits::Datelike>::day0(p0);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::day0(p0);
+<datetime::DateTime<Tz>>::day0(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::ordinal
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::ordinal":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::ordinal":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.ordinal();
+<datetime::DateTime<Tz> as traits::Datelike>::ordinal(p0);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::ordinal(p0);
+<datetime::DateTime<Tz>>::ordinal(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::ordinal0
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::ordinal0":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::ordinal0":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.ordinal0();
+<datetime::DateTime<Tz> as traits::Datelike>::ordinal0(p0);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::ordinal0(p0);
+<datetime::DateTime<Tz>>::ordinal0(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::weekday
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::weekday":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::weekday":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.weekday();
+<datetime::DateTime<Tz> as traits::Datelike>::weekday(p0);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::weekday(p0);
+<datetime::DateTime<Tz>>::weekday(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::iso_week
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::iso_week":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::iso_week":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.iso_week();
+<datetime::DateTime<Tz> as traits::Datelike>::iso_week(p0);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::iso_week(p0);
+<datetime::DateTime<Tz>>::iso_week(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::with_year
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::with_year":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::with_year":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0i32; // None+i32
+p0.with_year(p1);
+<datetime::DateTime<Tz> as traits::Datelike>::with_year(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::with_year(p0, p1);
+<datetime::DateTime<Tz>>::with_year(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::with_month
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::with_month":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::with_month":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_month(p1);
+<datetime::DateTime<Tz> as traits::Datelike>::with_month(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::with_month(p0, p1);
+<datetime::DateTime<Tz>>::with_month(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::with_month0
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::with_month0":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::with_month0":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_month0(p1);
+<datetime::DateTime<Tz> as traits::Datelike>::with_month0(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::with_month0(p0, p1);
+<datetime::DateTime<Tz>>::with_month0(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::with_day
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::with_day":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::with_day":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_day(p1);
+<datetime::DateTime<Tz> as traits::Datelike>::with_day(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::with_day(p0, p1);
+<datetime::DateTime<Tz>>::with_day(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::with_day0
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::with_day0":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::with_day0":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_day0(p1);
+<datetime::DateTime<Tz> as traits::Datelike>::with_day0(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::with_day0(p0, p1);
+<datetime::DateTime<Tz>>::with_day0(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::with_ordinal
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_ordinal(p1);
+<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal(p0, p1);
+<datetime::DateTime<Tz>>::with_ordinal(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Datelike>::with_ordinal0
deps:{"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal0":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal0":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_ordinal0(p1);
+<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal0(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal0(p0, p1);
+<datetime::DateTime<Tz>>::with_ordinal0(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Timelike>::hour
deps:{"<datetime::DateTime<Tz> as traits::Timelike>::hour":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Timelike>::hour":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.hour();
+<datetime::DateTime<Tz> as traits::Timelike>::hour(p0);
+crate::<datetime::DateTime<Tz> as traits::Timelike>::hour(p0);
+<datetime::DateTime<Tz>>::hour(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Timelike>::minute
deps:{"<datetime::DateTime<Tz> as traits::Timelike>::minute":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Timelike>::minute":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.minute();
+<datetime::DateTime<Tz> as traits::Timelike>::minute(p0);
+crate::<datetime::DateTime<Tz> as traits::Timelike>::minute(p0);
+<datetime::DateTime<Tz>>::minute(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Timelike>::second
deps:{"<datetime::DateTime<Tz> as traits::Timelike>::second":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Timelike>::second":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.second();
+<datetime::DateTime<Tz> as traits::Timelike>::second(p0);
+crate::<datetime::DateTime<Tz> as traits::Timelike>::second(p0);
+<datetime::DateTime<Tz>>::second(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Timelike>::nanosecond
deps:{"<datetime::DateTime<Tz> as traits::Timelike>::nanosecond":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Timelike>::nanosecond":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.nanosecond();
+<datetime::DateTime<Tz> as traits::Timelike>::nanosecond(p0);
+crate::<datetime::DateTime<Tz> as traits::Timelike>::nanosecond(p0);
+<datetime::DateTime<Tz>>::nanosecond(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Timelike>::with_hour
deps:{"<datetime::DateTime<Tz> as traits::Timelike>::with_hour":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Timelike>::with_hour":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_hour(p1);
+<datetime::DateTime<Tz> as traits::Timelike>::with_hour(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Timelike>::with_hour(p0, p1);
+<datetime::DateTime<Tz>>::with_hour(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Timelike>::with_minute
deps:{"<datetime::DateTime<Tz> as traits::Timelike>::with_minute":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Timelike>::with_minute":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_minute(p1);
+<datetime::DateTime<Tz> as traits::Timelike>::with_minute(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Timelike>::with_minute(p0, p1);
+<datetime::DateTime<Tz>>::with_minute(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Timelike>::with_second
deps:{"<datetime::DateTime<Tz> as traits::Timelike>::with_second":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Timelike>::with_second":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_second(p1);
+<datetime::DateTime<Tz> as traits::Timelike>::with_second(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Timelike>::with_second(p0, p1);
+<datetime::DateTime<Tz>>::with_second(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as traits::Timelike>::with_nanosecond
deps:{"<datetime::DateTime<Tz> as traits::Timelike>::with_nanosecond":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as traits::Timelike>::with_nanosecond":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = 0u32; // None+u32
+p0.with_nanosecond(p1);
+<datetime::DateTime<Tz> as traits::Timelike>::with_nanosecond(p0, p1);
+crate::<datetime::DateTime<Tz> as traits::Timelike>::with_nanosecond(p0, p1);
+<datetime::DateTime<Tz>>::with_nanosecond(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::cmp::PartialEq<datetime::DateTime<Tz2>>>::eq
deps:{"<datetime::DateTime<Tz> as std::cmp::PartialEq<datetime::DateTime<Tz2>>>::eq":{"Tz":["std::marker::Sized","offset::TimeZone"],"Tz2":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as std::cmp::PartialEq<datetime::DateTime<Tz2>>>::eq":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"],"Tz2":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz2>
+p0.eq(p1);
+<datetime::DateTime<Tz> as std::cmp::PartialEq<datetime::DateTime<Tz2>>>::eq(p0, p1);
+crate::<datetime::DateTime<Tz> as std::cmp::PartialEq<datetime::DateTime<Tz2>>>::eq(p0, p1);
+<datetime::DateTime<Tz>>::eq(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::cmp::PartialOrd<datetime::DateTime<Tz2>>>::partial_cmp
deps:{"<datetime::DateTime<Tz> as std::cmp::PartialOrd<datetime::DateTime<Tz2>>>::partial_cmp":{"Tz":["offset::TimeZone","std::marker::Sized"],"Tz2":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::cmp::PartialOrd<datetime::DateTime<Tz2>>>::partial_cmp":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"],"Tz2":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz2>
+p0.partial_cmp(p1);
+<datetime::DateTime<Tz> as std::cmp::PartialOrd<datetime::DateTime<Tz2>>>::partial_cmp(p0, p1);
+crate::<datetime::DateTime<Tz> as std::cmp::PartialOrd<datetime::DateTime<Tz2>>>::partial_cmp(p0, p1);
+<datetime::DateTime<Tz>>::partial_cmp(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::cmp::Ord>::cmp
deps:{"<datetime::DateTime<Tz> as std::cmp::Ord>::cmp":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as std::cmp::Ord>::cmp":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.cmp(p1);
+<datetime::DateTime<Tz> as std::cmp::Ord>::cmp(p0, p1);
+crate::<datetime::DateTime<Tz> as std::cmp::Ord>::cmp(p0, p1);
+<datetime::DateTime<Tz>>::cmp(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<datetime::DateTime<Tz> as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"],"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<datetime::DateTime<Tz> as std::hash::Hash>::hash":{"H":["std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::hash::SipHasher13","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>"],"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<datetime::DateTime<Tz> as std::hash::Hash>::hash(p0, p1);
+crate::<datetime::DateTime<Tz> as std::hash::Hash>::hash(p0, p1);
+<datetime::DateTime<Tz>>::hash(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::ops::Add<time_delta::TimeDelta>>::add
deps:{"<datetime::DateTime<Tz> as std::ops::Add<time_delta::TimeDelta>>::add":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::ops::Add<time_delta::TimeDelta>>::add":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add(p1);
+<datetime::DateTime<Tz> as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+crate::<datetime::DateTime<Tz> as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+<datetime::DateTime<Tz>>::add(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign
deps:{"<datetime::DateTime<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add_assign(p1);
+<datetime::DateTime<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+crate::<datetime::DateTime<Tz> as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+<datetime::DateTime<Tz>>::add_assign(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::ops::Add<month::Months>>::add
deps:{"<datetime::DateTime<Tz> as std::ops::Add<month::Months>>::add":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::ops::Add<month::Months>>::add":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.add(p1);
+<datetime::DateTime<Tz> as std::ops::Add<month::Months>>::add(p0, p1);
+crate::<datetime::DateTime<Tz> as std::ops::Add<month::Months>>::add(p0, p1);
+<datetime::DateTime<Tz>>::add(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub
deps:{"<datetime::DateTime<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub(p1);
+<datetime::DateTime<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+crate::<datetime::DateTime<Tz> as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+<datetime::DateTime<Tz>>::sub(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign
deps:{"<datetime::DateTime<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub_assign(p1);
+<datetime::DateTime<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+crate::<datetime::DateTime<Tz> as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+<datetime::DateTime<Tz>>::sub_assign(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::ops::Sub<month::Months>>::sub
deps:{"<datetime::DateTime<Tz> as std::ops::Sub<month::Months>>::sub":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::ops::Sub<month::Months>>::sub":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.sub(p1);
+<datetime::DateTime<Tz> as std::ops::Sub<month::Months>>::sub(p0, p1);
+crate::<datetime::DateTime<Tz> as std::ops::Sub<month::Months>>::sub(p0, p1);
+<datetime::DateTime<Tz>>::sub(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::ops::Sub>::sub
deps:{"<datetime::DateTime<Tz> as std::ops::Sub>::sub":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::ops::Sub>::sub":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+p0.sub(p1);
+<datetime::DateTime<Tz> as std::ops::Sub>::sub(p0, p1);
+crate::<datetime::DateTime<Tz> as std::ops::Sub>::sub(p0, p1);
+<datetime::DateTime<Tz>>::sub(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::ops::Add<naive::date::Days>>::add
deps:{"<datetime::DateTime<Tz> as std::ops::Add<naive::date::Days>>::add":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::ops::Add<naive::date::Days>>::add":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.add(p1);
+<datetime::DateTime<Tz> as std::ops::Add<naive::date::Days>>::add(p0, p1);
+crate::<datetime::DateTime<Tz> as std::ops::Add<naive::date::Days>>::add(p0, p1);
+<datetime::DateTime<Tz>>::add(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::ops::Sub<naive::date::Days>>::sub
deps:{"<datetime::DateTime<Tz> as std::ops::Sub<naive::date::Days>>::sub":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::ops::Sub<naive::date::Days>>::sub":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.sub(p1);
+<datetime::DateTime<Tz> as std::ops::Sub<naive::date::Days>>::sub(p0, p1);
+crate::<datetime::DateTime<Tz> as std::ops::Sub<naive::date::Days>>::sub(p0, p1);
+<datetime::DateTime<Tz>>::sub(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::fmt::Debug>::fmt
deps:{"<datetime::DateTime<Tz> as std::fmt::Debug>::fmt":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as std::fmt::Debug>::fmt":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::DateTime<Tz> as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::DateTime<Tz> as std::fmt::Debug>::fmt(p0, p1);
+<datetime::DateTime<Tz>>::fmt(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<Tz> as std::fmt::Display>::fmt
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<datetime::DateTime<Tz> as std::fmt::Display>::fmt":{"<Tz as offset::TimeZone>::Offset":["std::fmt::Display"],"Tz":["std::marker::Sized","offset::TimeZone"]},"date::Date":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]},"format::DelayedFormat":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::iter::Iterator"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<datetime::DateTime<Tz> as std::fmt::Display>::fmt":{"<Tz as offset::TimeZone>::Offset":["datetime::DateTime","naive::datetime::NaiveDateTime","naive::time::NaiveTime","time_delta::OutOfRangeError","naive::date::NaiveDate","round::RoundingError","offset::local::tz_info::Error","date::Date","weekday::Weekday","OutOfRange","offset::utc::Utc","time_delta::TimeDelta","<&mut T as std::fmt::Display>","format::DelayedFormat","format::ParseError","weekday::ParseWeekdayError","offset::fixed::FixedOffset"],"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"date::Date":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"format::DelayedFormat":{"I":["naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","format::strftime::StrftimeItems"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::DateTime<Tz> as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::DateTime<Tz> as std::fmt::Display>::fmt(p0, p1);
+<datetime::DateTime<Tz>>::fmt(p0, p1);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::utc::Utc> as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<datetime::DateTime<offset::utc::Utc> as std::str::FromStr>::from_str(&p0);
+crate::<datetime::DateTime<offset::utc::Utc> as std::str::FromStr>::from_str(&p0);
+<datetime::DateTime<offset::utc::Utc>>::from_str(&p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::local::Local> as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<datetime::DateTime<offset::local::Local> as std::str::FromStr>::from_str(&p0);
+crate::<datetime::DateTime<offset::local::Local> as std::str::FromStr>::from_str(&p0);
+<datetime::DateTime<offset::local::Local>>::from_str(&p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::utc::Utc> as std::convert::From<std::time::SystemTime>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::SystemTime
+<datetime::DateTime<offset::utc::Utc> as std::convert::From<std::time::SystemTime>>::from(p0);
+crate::<datetime::DateTime<offset::utc::Utc> as std::convert::From<std::time::SystemTime>>::from(p0);
+<datetime::DateTime<offset::utc::Utc>>::from(p0);
-----------------
src/datetime/mod.rs <datetime::DateTime<offset::local::Local> as std::convert::From<std::time::SystemTime>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::SystemTime
+<datetime::DateTime<offset::local::Local> as std::convert::From<std::time::SystemTime>>::from(p0);
+crate::<datetime::DateTime<offset::local::Local> as std::convert::From<std::time::SystemTime>>::from(p0);
+<datetime::DateTime<offset::local::Local>>::from(p0);
-----------------
src/datetime/mod.rs datetime::<impl std::convert::From<datetime::DateTime<Tz>> for std::time::SystemTime>::from
deps:{"datetime::<impl std::convert::From<datetime::DateTime<Tz>> for std::time::SystemTime>::from":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"datetime::<impl std::convert::From<datetime::DateTime<Tz>> for std::time::SystemTime>::from":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
+datetime::<impl std::convert::From<datetime::DateTime<Tz>> for std::time::SystemTime>::from(p0);
+crate::datetime::<impl std::convert::From<datetime::DateTime<Tz>> for std::time::SystemTime>::from(p0);
+<std::time::SystemTime>::from(p0);
-----------------
src/format/mod.rs <format::Locale as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Locale
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::Locale as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::Locale as std::fmt::Debug>::fmt(p0, p1);
+<format::Locale>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::Void as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Void
+p0.clone();
+<format::Void as std::clone::Clone>::clone(p0);
+crate::<format::Void as std::clone::Clone>::clone(p0);
+<format::Void>::clone(p0);
-----------------
src/format/mod.rs <format::Void as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Void
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::Void
+p0.eq(p1);
+<format::Void as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::Void as std::cmp::PartialEq>::eq(p0, p1);
+<format::Void>::eq(p0, p1);
-----------------
src/format/mod.rs <format::Void as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Void
+p0.assert_receiver_is_total_eq();
+<format::Void as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::Void as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::Void>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::Void as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::Void as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::Void as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::boxed::Box<T, A>","std::hash::SipHasher","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Void
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::Void as std::hash::Hash>::hash(p0, p1);
+crate::<format::Void as std::hash::Hash>::hash(p0, p1);
+<format::Void>::hash(p0, p1);
-----------------
src/format/mod.rs <format::Pad as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Pad
+p0.clone();
+<format::Pad as std::clone::Clone>::clone(p0);
+crate::<format::Pad as std::clone::Clone>::clone(p0);
+<format::Pad>::clone(p0);
-----------------
src/format/mod.rs <format::Pad as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Pad
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::Pad
+p0.eq(p1);
+<format::Pad as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::Pad as std::cmp::PartialEq>::eq(p0, p1);
+<format::Pad>::eq(p0, p1);
-----------------
src/format/mod.rs <format::Pad as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Pad
+p0.assert_receiver_is_total_eq();
+<format::Pad as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::Pad as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::Pad>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::Pad as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Pad
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::Pad as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::Pad as std::fmt::Debug>::fmt(p0, p1);
+<format::Pad>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::Pad as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::Pad as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::Pad as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Pad
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::Pad as std::hash::Hash>::hash(p0, p1);
+crate::<format::Pad as std::hash::Hash>::hash(p0, p1);
+<format::Pad>::hash(p0, p1);
-----------------
src/format/mod.rs <format::Numeric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Numeric
+p0.clone();
+<format::Numeric as std::clone::Clone>::clone(p0);
+crate::<format::Numeric as std::clone::Clone>::clone(p0);
+<format::Numeric>::clone(p0);
-----------------
src/format/mod.rs <format::Numeric as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Numeric
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::Numeric
+p0.eq(p1);
+<format::Numeric as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::Numeric as std::cmp::PartialEq>::eq(p0, p1);
+<format::Numeric>::eq(p0, p1);
-----------------
src/format/mod.rs <format::Numeric as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Numeric
+p0.assert_receiver_is_total_eq();
+<format::Numeric as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::Numeric as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::Numeric>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::Numeric as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Numeric
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::Numeric as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::Numeric as std::fmt::Debug>::fmt(p0, p1);
+<format::Numeric>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::Numeric as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::Numeric as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::Numeric as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Numeric
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::Numeric as std::hash::Hash>::hash(p0, p1);
+crate::<format::Numeric as std::hash::Hash>::hash(p0, p1);
+<format::Numeric>::hash(p0, p1);
-----------------
src/format/mod.rs <format::InternalNumeric as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalNumeric
+p0.clone();
+<format::InternalNumeric as std::clone::Clone>::clone(p0);
+crate::<format::InternalNumeric as std::clone::Clone>::clone(p0);
+<format::InternalNumeric>::clone(p0);
-----------------
src/format/mod.rs <format::InternalNumeric as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalNumeric
+p0.assert_receiver_is_total_eq();
+<format::InternalNumeric as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::InternalNumeric as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::InternalNumeric>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::InternalNumeric as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::InternalNumeric as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::InternalNumeric as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalNumeric
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::InternalNumeric as std::hash::Hash>::hash(p0, p1);
+crate::<format::InternalNumeric as std::hash::Hash>::hash(p0, p1);
+<format::InternalNumeric>::hash(p0, p1);
-----------------
src/format/mod.rs <format::InternalNumeric as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalNumeric
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::InternalNumeric
+p0.eq(p1);
+<format::InternalNumeric as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::InternalNumeric as std::cmp::PartialEq>::eq(p0, p1);
+<format::InternalNumeric>::eq(p0, p1);
-----------------
src/format/mod.rs <format::InternalNumeric as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalNumeric
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::InternalNumeric as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::InternalNumeric as std::fmt::Debug>::fmt(p0, p1);
+<format::InternalNumeric>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::Fixed as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Fixed
+p0.clone();
+<format::Fixed as std::clone::Clone>::clone(p0);
+crate::<format::Fixed as std::clone::Clone>::clone(p0);
+<format::Fixed>::clone(p0);
-----------------
src/format/mod.rs <format::Fixed as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Fixed
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::Fixed
+p0.eq(p1);
+<format::Fixed as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::Fixed as std::cmp::PartialEq>::eq(p0, p1);
+<format::Fixed>::eq(p0, p1);
-----------------
src/format/mod.rs <format::Fixed as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Fixed
+p0.assert_receiver_is_total_eq();
+<format::Fixed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::Fixed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::Fixed>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::Fixed as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Fixed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::Fixed as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::Fixed as std::fmt::Debug>::fmt(p0, p1);
+<format::Fixed>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::Fixed as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::Fixed as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::Fixed as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Fixed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::Fixed as std::hash::Hash>::hash(p0, p1);
+crate::<format::Fixed as std::hash::Hash>::hash(p0, p1);
+<format::Fixed>::hash(p0, p1);
-----------------
src/format/mod.rs <format::InternalFixed as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalFixed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::InternalFixed as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::InternalFixed as std::fmt::Debug>::fmt(p0, p1);
+<format::InternalFixed>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::InternalFixed as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalFixed
+p0.clone();
+<format::InternalFixed as std::clone::Clone>::clone(p0);
+crate::<format::InternalFixed as std::clone::Clone>::clone(p0);
+<format::InternalFixed>::clone(p0);
-----------------
src/format/mod.rs <format::InternalFixed as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalFixed
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::InternalFixed
+p0.eq(p1);
+<format::InternalFixed as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::InternalFixed as std::cmp::PartialEq>::eq(p0, p1);
+<format::InternalFixed>::eq(p0, p1);
-----------------
src/format/mod.rs <format::InternalFixed as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalFixed
+p0.assert_receiver_is_total_eq();
+<format::InternalFixed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::InternalFixed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::InternalFixed>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::InternalFixed as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::InternalFixed as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::InternalFixed as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::hash::SipHasher13","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalFixed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::InternalFixed as std::hash::Hash>::hash(p0, p1);
+crate::<format::InternalFixed as std::hash::Hash>::hash(p0, p1);
+<format::InternalFixed>::hash(p0, p1);
-----------------
src/format/mod.rs <format::InternalInternal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalInternal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::InternalInternal as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::InternalInternal as std::fmt::Debug>::fmt(p0, p1);
+<format::InternalInternal>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::InternalInternal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalInternal
+p0.clone();
+<format::InternalInternal as std::clone::Clone>::clone(p0);
+crate::<format::InternalInternal as std::clone::Clone>::clone(p0);
+<format::InternalInternal>::clone(p0);
-----------------
src/format/mod.rs <format::InternalInternal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalInternal
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::InternalInternal
+p0.eq(p1);
+<format::InternalInternal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::InternalInternal as std::cmp::PartialEq>::eq(p0, p1);
+<format::InternalInternal>::eq(p0, p1);
-----------------
src/format/mod.rs <format::InternalInternal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalInternal
+p0.assert_receiver_is_total_eq();
+<format::InternalInternal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::InternalInternal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::InternalInternal>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::InternalInternal as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::InternalInternal as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::InternalInternal as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::InternalInternal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::InternalInternal as std::hash::Hash>::hash(p0, p1);
+crate::<format::InternalInternal as std::hash::Hash>::hash(p0, p1);
+<format::InternalInternal>::hash(p0, p1);
-----------------
src/format/mod.rs <format::Colons as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Colons
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::Colons as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::Colons as std::fmt::Debug>::fmt(p0, p1);
+<format::Colons>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::Colons as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Colons
+p0.clone();
+<format::Colons as std::clone::Clone>::clone(p0);
+crate::<format::Colons as std::clone::Clone>::clone(p0);
+<format::Colons>::clone(p0);
-----------------
src/format/mod.rs <format::Colons as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Colons
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::Colons
+p0.eq(p1);
+<format::Colons as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::Colons as std::cmp::PartialEq>::eq(p0, p1);
+<format::Colons>::eq(p0, p1);
-----------------
src/format/mod.rs <format::Colons as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Colons
+p0.assert_receiver_is_total_eq();
+<format::Colons as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::Colons as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::Colons>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::Colons as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::Colons as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::Colons as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Colons
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::Colons as std::hash::Hash>::hash(p0, p1);
+crate::<format::Colons as std::hash::Hash>::hash(p0, p1);
+<format::Colons>::hash(p0, p1);
-----------------
src/format/mod.rs <format::Item<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Item<'a>
+p0.clone();
+<format::Item<'a> as std::clone::Clone>::clone(p0);
+crate::<format::Item<'a> as std::clone::Clone>::clone(p0);
+<format::Item<'a>>::clone(p0);
-----------------
src/format/mod.rs <format::Item<'a> as std::cmp::PartialEq>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Item<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::Item<'a>
+p0.eq(p1);
+<format::Item<'a> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::Item<'a> as std::cmp::PartialEq>::eq(p0, p1);
+<format::Item<'a>>::eq(p0, p1);
-----------------
src/format/mod.rs <format::Item<'a> as std::cmp::Eq>::assert_receiver_is_total_eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Item<'a>
+p0.assert_receiver_is_total_eq();
+<format::Item<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::Item<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::Item<'a>>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::Item<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Item<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::Item<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::Item<'a> as std::fmt::Debug>::fmt(p0, p1);
+<format::Item<'a>>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::Item<'a> as std::hash::Hash>::hash
'a
deps:{"<&mut H as std::hash::Hasher>":{},"<format::Item<'a> as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::Item<'a> as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::hash::SipHasher13","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::Item<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::Item<'a> as std::hash::Hash>::hash(p0, p1);
+crate::<format::Item<'a> as std::hash::Hash>::hash(p0, p1);
+<format::Item<'a>>::hash(p0, p1);
-----------------
src/format/mod.rs <format::ParseError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::ParseError as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::ParseError as std::fmt::Debug>::fmt(p0, p1);
+<format::ParseError>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::ParseError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseError
+p0.clone();
+<format::ParseError as std::clone::Clone>::clone(p0);
+crate::<format::ParseError as std::clone::Clone>::clone(p0);
+<format::ParseError>::clone(p0);
-----------------
src/format/mod.rs <format::ParseError as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseError
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::ParseError
+p0.eq(p1);
+<format::ParseError as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::ParseError as std::cmp::PartialEq>::eq(p0, p1);
+<format::ParseError>::eq(p0, p1);
-----------------
src/format/mod.rs <format::ParseError as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseError
+p0.assert_receiver_is_total_eq();
+<format::ParseError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::ParseError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::ParseError>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::ParseError as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::ParseError as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::ParseError as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::ParseError as std::hash::Hash>::hash(p0, p1);
+crate::<format::ParseError as std::hash::Hash>::hash(p0, p1);
+<format::ParseError>::hash(p0, p1);
-----------------
src/format/mod.rs format::ParseError::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseError
+p0.kind();
+format::ParseError::kind(p0);
+crate::format::ParseError::kind(p0);
+<format::ParseError>::kind(p0);
-----------------
src/format/mod.rs <format::ParseErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::ParseErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::ParseErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<format::ParseErrorKind>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::ParseErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseErrorKind
+p0.clone();
+<format::ParseErrorKind as std::clone::Clone>::clone(p0);
+crate::<format::ParseErrorKind as std::clone::Clone>::clone(p0);
+<format::ParseErrorKind>::clone(p0);
-----------------
src/format/mod.rs <format::ParseErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::ParseErrorKind
+p0.eq(p1);
+<format::ParseErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::ParseErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<format::ParseErrorKind>::eq(p0, p1);
-----------------
src/format/mod.rs <format::ParseErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseErrorKind
+p0.assert_receiver_is_total_eq();
+<format::ParseErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::ParseErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::ParseErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
src/format/mod.rs <format::ParseErrorKind as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::ParseErrorKind as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::ParseErrorKind as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::ParseErrorKind as std::hash::Hash>::hash(p0, p1);
+crate::<format::ParseErrorKind as std::hash::Hash>::hash(p0, p1);
+<format::ParseErrorKind>::hash(p0, p1);
-----------------
src/format/mod.rs <format::ParseError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<format::ParseError as std::fmt::Display>::fmt(p0, p1);
+crate::<format::ParseError as std::fmt::Display>::fmt(p0, p1);
+<format::ParseError>::fmt(p0, p1);
-----------------
src/format/mod.rs <format::ParseError as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::ParseError
+p0.description();
+<format::ParseError as std::error::Error>::description(p0);
+crate::<format::ParseError as std::error::Error>::description(p0);
+<format::ParseError>::description(p0);
-----------------
src/format/mod.rs format::Locales::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<format::Locale>
+format::Locales::new(p0);
+crate::format::Locales::new(p0);
+<format::Locales>::new(p0);
-----------------
src/format/parsed.rs <format::parsed::Parsed as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
+p0.clone();
+<format::parsed::Parsed as std::clone::Clone>::clone(p0);
+crate::<format::parsed::Parsed as std::clone::Clone>::clone(p0);
+<format::parsed::Parsed>::clone(p0);
-----------------
src/format/parsed.rs <format::parsed::Parsed as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
+p0.eq(p1);
+<format::parsed::Parsed as std::cmp::PartialEq>::eq(p0, p1);
+crate::<format::parsed::Parsed as std::cmp::PartialEq>::eq(p0, p1);
+<format::parsed::Parsed>::eq(p0, p1);
-----------------
src/format/parsed.rs <format::parsed::Parsed as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
+p0.assert_receiver_is_total_eq();
+<format::parsed::Parsed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<format::parsed::Parsed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<format::parsed::Parsed>::assert_receiver_is_total_eq(p0);
-----------------
src/format/parsed.rs <format::parsed::Parsed as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::parsed::Parsed as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::parsed::Parsed as std::fmt::Debug>::fmt(p0, p1);
+<format::parsed::Parsed>::fmt(p0, p1);
-----------------
src/format/parsed.rs <format::parsed::Parsed as std::default::Default>::default
deps:{}
candidates:{}
+<format::parsed::Parsed as std::default::Default>::default();
+crate::<format::parsed::Parsed as std::default::Default>::default();
+<format::parsed::Parsed>::default();
-----------------
src/format/parsed.rs <format::parsed::Parsed as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<format::parsed::Parsed as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<format::parsed::Parsed as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<format::parsed::Parsed as std::hash::Hash>::hash(p0, p1);
+crate::<format::parsed::Parsed as std::hash::Hash>::hash(p0, p1);
+<format::parsed::Parsed>::hash(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::new
deps:{}
candidates:{}
+format::parsed::Parsed::new();
+crate::format::parsed::Parsed::new();
+<format::parsed::Parsed>::new();
-----------------
src/format/parsed.rs format::parsed::Parsed::set_year
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_year(p1);
+format::parsed::Parsed::set_year(p0, p1);
+crate::format::parsed::Parsed::set_year(p0, p1);
+<format::parsed::Parsed>::set_year(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_year_div_100
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_year_div_100(p1);
+format::parsed::Parsed::set_year_div_100(p0, p1);
+crate::format::parsed::Parsed::set_year_div_100(p0, p1);
+<format::parsed::Parsed>::set_year_div_100(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_year_mod_100
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_year_mod_100(p1);
+format::parsed::Parsed::set_year_mod_100(p0, p1);
+crate::format::parsed::Parsed::set_year_mod_100(p0, p1);
+<format::parsed::Parsed>::set_year_mod_100(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_isoyear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_isoyear(p1);
+format::parsed::Parsed::set_isoyear(p0, p1);
+crate::format::parsed::Parsed::set_isoyear(p0, p1);
+<format::parsed::Parsed>::set_isoyear(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_isoyear_div_100
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_isoyear_div_100(p1);
+format::parsed::Parsed::set_isoyear_div_100(p0, p1);
+crate::format::parsed::Parsed::set_isoyear_div_100(p0, p1);
+<format::parsed::Parsed>::set_isoyear_div_100(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_isoyear_mod_100
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_isoyear_mod_100(p1);
+format::parsed::Parsed::set_isoyear_mod_100(p0, p1);
+crate::format::parsed::Parsed::set_isoyear_mod_100(p0, p1);
+<format::parsed::Parsed>::set_isoyear_mod_100(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_month
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_month(p1);
+format::parsed::Parsed::set_month(p0, p1);
+crate::format::parsed::Parsed::set_month(p0, p1);
+<format::parsed::Parsed>::set_month(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_week_from_sun
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_week_from_sun(p1);
+format::parsed::Parsed::set_week_from_sun(p0, p1);
+crate::format::parsed::Parsed::set_week_from_sun(p0, p1);
+<format::parsed::Parsed>::set_week_from_sun(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_week_from_mon
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_week_from_mon(p1);
+format::parsed::Parsed::set_week_from_mon(p0, p1);
+crate::format::parsed::Parsed::set_week_from_mon(p0, p1);
+<format::parsed::Parsed>::set_week_from_mon(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_isoweek
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_isoweek(p1);
+format::parsed::Parsed::set_isoweek(p0, p1);
+crate::format::parsed::Parsed::set_isoweek(p0, p1);
+<format::parsed::Parsed>::set_isoweek(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_weekday
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.set_weekday(p1);
+format::parsed::Parsed::set_weekday(p0, p1);
+crate::format::parsed::Parsed::set_weekday(p0, p1);
+<format::parsed::Parsed>::set_weekday(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_ordinal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_ordinal(p1);
+format::parsed::Parsed::set_ordinal(p0, p1);
+crate::format::parsed::Parsed::set_ordinal(p0, p1);
+<format::parsed::Parsed>::set_ordinal(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_day
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_day(p1);
+format::parsed::Parsed::set_day(p0, p1);
+crate::format::parsed::Parsed::set_day(p0, p1);
+<format::parsed::Parsed>::set_day(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_ampm
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = true; // None+bool
+p0.set_ampm(p1);
+format::parsed::Parsed::set_ampm(p0, p1);
+crate::format::parsed::Parsed::set_ampm(p0, p1);
+<format::parsed::Parsed>::set_ampm(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_hour12
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_hour12(p1);
+format::parsed::Parsed::set_hour12(p0, p1);
+crate::format::parsed::Parsed::set_hour12(p0, p1);
+<format::parsed::Parsed>::set_hour12(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_hour
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_hour(p1);
+format::parsed::Parsed::set_hour(p0, p1);
+crate::format::parsed::Parsed::set_hour(p0, p1);
+<format::parsed::Parsed>::set_hour(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_minute
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_minute(p1);
+format::parsed::Parsed::set_minute(p0, p1);
+crate::format::parsed::Parsed::set_minute(p0, p1);
+<format::parsed::Parsed>::set_minute(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_second
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_second(p1);
+format::parsed::Parsed::set_second(p0, p1);
+crate::format::parsed::Parsed::set_second(p0, p1);
+<format::parsed::Parsed>::set_second(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_nanosecond
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_nanosecond(p1);
+format::parsed::Parsed::set_nanosecond(p0, p1);
+crate::format::parsed::Parsed::set_nanosecond(p0, p1);
+<format::parsed::Parsed>::set_nanosecond(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_timestamp
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_timestamp(p1);
+format::parsed::Parsed::set_timestamp(p0, p1);
+crate::format::parsed::Parsed::set_timestamp(p0, p1);
+<format::parsed::Parsed>::set_timestamp(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::set_offset
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i64; // None+i64
+p0.set_offset(p1);
+format::parsed::Parsed::set_offset(p0, p1);
+crate::format::parsed::Parsed::set_offset(p0, p1);
+<format::parsed::Parsed>::set_offset(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::to_naive_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
+p0.to_naive_date();
+format::parsed::Parsed::to_naive_date(p0);
+crate::format::parsed::Parsed::to_naive_date(p0);
+<format::parsed::Parsed>::to_naive_date(p0);
-----------------
src/format/parsed.rs format::parsed::Parsed::to_naive_time
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
+p0.to_naive_time();
+format::parsed::Parsed::to_naive_time(p0);
+crate::format::parsed::Parsed::to_naive_time(p0);
+<format::parsed::Parsed>::to_naive_time(p0);
-----------------
src/format/parsed.rs format::parsed::Parsed::to_naive_datetime_with_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = 0i32; // None+i32
+p0.to_naive_datetime_with_offset(p1);
+format::parsed::Parsed::to_naive_datetime_with_offset(p0, p1);
+crate::format::parsed::Parsed::to_naive_datetime_with_offset(p0, p1);
+<format::parsed::Parsed>::to_naive_datetime_with_offset(p0, p1);
-----------------
src/format/parsed.rs format::parsed::Parsed::to_fixed_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
+p0.to_fixed_offset();
+format::parsed::Parsed::to_fixed_offset(p0);
+crate::format::parsed::Parsed::to_fixed_offset(p0);
+<format::parsed::Parsed>::to_fixed_offset(p0);
-----------------
src/format/parsed.rs format::parsed::Parsed::to_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
+p0.to_datetime();
+format::parsed::Parsed::to_datetime(p0);
+crate::format::parsed::Parsed::to_datetime(p0);
+<format::parsed::Parsed>::to_datetime(p0);
-----------------
src/format/parsed.rs format::parsed::Parsed::to_datetime_with_timezone
deps:{"format::parsed::Parsed::to_datetime_with_timezone":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"format::parsed::Parsed::to_datetime_with_timezone":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::parsed::Parsed
let mut p1 = & MaybeUninit::uninit().assume_init(); // Tz
+p0.to_datetime_with_timezone(p1);
+format::parsed::Parsed::to_datetime_with_timezone(p0, p1);
+crate::format::parsed::Parsed::to_datetime_with_timezone(p0, p1);
+<format::parsed::Parsed>::to_datetime_with_timezone(p0, p1);
-----------------
src/format/parse.rs format::parse::<impl std::str::FromStr for datetime::DateTime<offset::fixed::FixedOffset>>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::parse::<impl std::str::FromStr for datetime::DateTime<offset::fixed::FixedOffset>>::from_str(&p0);
+crate::format::parse::<impl std::str::FromStr for datetime::DateTime<offset::fixed::FixedOffset>>::from_str(&p0);
+<datetime::DateTime<offset::fixed::FixedOffset>>::from_str(&p0);
-----------------
src/format/strftime.rs <format::strftime::StrftimeItems<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::strftime::StrftimeItems<'a>
+p0.clone();
+<format::strftime::StrftimeItems<'a> as std::clone::Clone>::clone(p0);
+crate::<format::strftime::StrftimeItems<'a> as std::clone::Clone>::clone(p0);
+<format::strftime::StrftimeItems<'a>>::clone(p0);
-----------------
src/format/strftime.rs <format::strftime::StrftimeItems<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::strftime::StrftimeItems<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::strftime::StrftimeItems<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::strftime::StrftimeItems<'a> as std::fmt::Debug>::fmt(p0, p1);
+<format::strftime::StrftimeItems<'a>>::fmt(p0, p1);
-----------------
src/format/strftime.rs format::strftime::StrftimeItems::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::strftime::StrftimeItems::<'a>::new(&p0);
+crate::format::strftime::StrftimeItems::<'a>::new(&p0);
+<format::strftime::StrftimeItems<'a>>::new(&p0);
-----------------
src/format/strftime.rs format::strftime::StrftimeItems::<'a>::with_remainer
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::strftime::StrftimeItems::<'a>::with_remainer(&p0);
+crate::format::strftime::StrftimeItems::<'a>::with_remainer(&p0);
+<format::strftime::StrftimeItems<'a>>::with_remainer(&p0);
-----------------
src/format/strftime.rs <format::strftime::StrftimeItems<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // format::strftime::StrftimeItems<'a>
+p0.next();
+<format::strftime::StrftimeItems<'a> as std::iter::Iterator>::next(p0);
+crate::<format::strftime::StrftimeItems<'a> as std::iter::Iterator>::next(p0);
+<format::strftime::StrftimeItems<'a>>::next(p0);
-----------------
src/format/mod.rs <format::DelayedFormat<I> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<format::DelayedFormat<I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"date::Date":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"format::DelayedFormat":{"I":["std::iter::Iterator","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"offset::LocalResult":{"T":["std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::marker::Copy"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<format::DelayedFormat<I> as std::fmt::Debug>::fmt":{"I":["offset::local::tz_info::timezone::LeapSecond","format::parsed::Parsed","naive::internals::YearFlags","offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::rule::TransitionRule","naive::date::NaiveWeek","round::RoundingError","format::Fixed","naive::time::NaiveTime","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::parser::Version","format::Item","offset::local::tz_info::Error","date::Date","time_delta::OutOfRangeError","time_delta::TimeDelta","format::DelayedFormat","offset::LocalResult","weekday::Weekday","month::Month","offset::local::tz_info::rule::UtcDateTime","offset::fixed::FixedOffset","weekday::ParseWeekdayError","naive::internals::Mdf","offset::local::tz_info::timezone::Transition","format::Colons","format::InternalInternal","format::Numeric","month::ParseMonthError","offset::local::tz_info::timezone::LocalTimeType","naive::date::Days","format::InternalNumeric","naive::datetime::NaiveDateTime","OutOfRange","naive::date::NaiveDate","offset::local::tz_info::timezone::TimeZoneRef","naive::isoweek::IsoWeek","naive::internals::Of","offset::local::tz_info::parser::Cursor","offset::utc::Utc","<&T as std::fmt::Debug>","offset::local::tz_info::rule::RuleDay","datetime::DateTime","month::Months","format::strftime::StrftimeItems","naive::date::NaiveDateDaysIterator","format::ParseError","offset::local::tz_info::rule::AlternateTime","datetime::SecondsFormat","offset::local::tz_info::parser::Header","naive::date::NaiveDateWeeksIterator","offset::local::Local","format::ParseErrorKind","format::Locale","format::InternalFixed","<*const T as std::fmt::Debug>","format::Pad"]},"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"format::DelayedFormat":{"I":["naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems","naive::date::NaiveDateWeeksIterator"]},"offset::LocalResult":{"T":["month::Months","offset::LocalResult","format::ParseError","format::Pad","naive::isoweek::IsoWeek","naive::date::NaiveDateWeeksIterator","month::Month","datetime::SecondsFormat","naive::date::NaiveDate","naive::date::Days","offset::utc::Utc","weekday::Weekday","OutOfRange","date::Date","naive::internals::YearFlags","naive::datetime::NaiveDateTime","format::ParseErrorKind","naive::date::NaiveDateDaysIterator","offset::fixed::FixedOffset","std::hash::impls::<impl std::hash::Hash for *mut T>","datetime::DateTime","naive::time::NaiveTime","time_delta::TimeDelta"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::DelayedFormat<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<format::DelayedFormat<I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<format::DelayedFormat<I> as std::fmt::Debug>::fmt(p0, p1);
+<format::DelayedFormat<I>>::fmt(p0, p1);
-----------------
src/format/mod.rs format::DelayedFormat::<I>::new
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::DelayedFormat::<I>::new":{"B":["std::marker::Sized","std::borrow::Borrow"],"I":["std::marker::Sized","std::iter::Iterator","std::clone::Clone"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::DelayedFormat::<I>::new":{"B":["std::boxed::Box<T, A>","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::ffi::OsString","std::rc::Rc<T>","std::string::String"],"I":["naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","format::strftime::StrftimeItems"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<naive::date::NaiveDate>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<naive::time::NaiveTime>
let mut p2 = MaybeUninit::uninit().assume_init(); // I
+format::DelayedFormat::<I>::new(p0, p1, p2);
+crate::format::DelayedFormat::<I>::new(p0, p1, p2);
+<format::DelayedFormat<I>>::new(p0, p1, p2);
-----------------
src/format/mod.rs format::DelayedFormat::<I>::new_with_offset
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::DelayedFormat::<I>::new_with_offset":{"B":["std::borrow::Borrow","std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone","std::iter::Iterator"],"Off":["std::marker::Sized","std::fmt::Display","offset::Offset"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"format::DelayedFormat::<I>::new_with_offset":{"B":["std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::rc::Rc<T>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::string::String","std::ffi::CString","std::boxed::Box<T, A>","std::vec::Vec<T, A>"],"I":["naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems","naive::date::NaiveDateWeeksIterator"],"Off":["offset::utc::Utc","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<naive::date::NaiveDate>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<naive::time::NaiveTime>
let mut p2 = & MaybeUninit::uninit().assume_init(); // Off
let mut p3 = MaybeUninit::uninit().assume_init(); // I
+format::DelayedFormat::<I>::new_with_offset(p0, p1, p2, p3);
+crate::format::DelayedFormat::<I>::new_with_offset(p0, p1, p2, p3);
+<format::DelayedFormat<I>>::new_with_offset(p0, p1, p2, p3);
-----------------
src/format/mod.rs <format::DelayedFormat<I> as std::fmt::Display>::fmt
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<format::DelayedFormat<I> as std::fmt::Display>::fmt":{"B":["std::marker::Sized","std::borrow::Borrow"],"I":["std::clone::Clone","std::iter::Iterator","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<format::DelayedFormat<I> as std::fmt::Display>::fmt":{"B":["std::rc::Rc<T>","std::vec::Vec<T, A>","std::ffi::CString","std::ffi::OsString","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::string::String","std::path::PathBuf"],"I":["naive::date::NaiveDateWeeksIterator","naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // format::DelayedFormat<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<format::DelayedFormat<I> as std::fmt::Display>::fmt(p0, p1);
+crate::<format::DelayedFormat<I> as std::fmt::Display>::fmt(p0, p1);
+<format::DelayedFormat<I>>::fmt(p0, p1);
-----------------
src/format/mod.rs format::<impl std::str::FromStr for weekday::Weekday>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::<impl std::str::FromStr for weekday::Weekday>::from_str(&p0);
+crate::format::<impl std::str::FromStr for weekday::Weekday>::from_str(&p0);
+<weekday::Weekday>::from_str(&p0);
-----------------
src/format/mod.rs format::<impl std::str::FromStr for month::Month>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+format::<impl std::str::FromStr for month::Month>::from_str(&p0);
+crate::format::<impl std::str::FromStr for month::Month>::from_str(&p0);
+<month::Month>::from_str(&p0);
-----------------
src/naive/date.rs <naive::date::NaiveWeek as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveWeek
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::date::NaiveWeek as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::date::NaiveWeek as std::fmt::Debug>::fmt(p0, p1);
+<naive::date::NaiveWeek>::fmt(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveWeek::first_day
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveWeek
+p0.first_day();
+naive::date::NaiveWeek::first_day(p0);
+crate::naive::date::NaiveWeek::first_day(p0);
+<naive::date::NaiveWeek>::first_day(p0);
-----------------
src/naive/date.rs naive::date::NaiveWeek::last_day
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveWeek
+p0.last_day();
+naive::date::NaiveWeek::last_day(p0);
+crate::naive::date::NaiveWeek::last_day(p0);
+<naive::date::NaiveWeek>::last_day(p0);
-----------------
src/naive/date.rs naive::date::NaiveWeek::days
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveWeek
+p0.days();
+naive::date::NaiveWeek::days(p0);
+crate::naive::date::NaiveWeek::days(p0);
+<naive::date::NaiveWeek>::days(p0);
-----------------
src/naive/date.rs <naive::date::Days as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.clone();
+<naive::date::Days as std::clone::Clone>::clone(p0);
+crate::<naive::date::Days as std::clone::Clone>::clone(p0);
+<naive::date::Days>::clone(p0);
-----------------
src/naive/date.rs <naive::date::Days as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::Days
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::date::Days as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::date::Days as std::fmt::Debug>::fmt(p0, p1);
+<naive::date::Days>::fmt(p0, p1);
-----------------
src/naive/date.rs <naive::date::Days as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.assert_receiver_is_total_eq();
+<naive::date::Days as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<naive::date::Days as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<naive::date::Days>::assert_receiver_is_total_eq(p0);
-----------------
src/naive/date.rs <naive::date::Days as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<naive::date::Days as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<naive::date::Days as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::SipHasher13","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::Days
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<naive::date::Days as std::hash::Hash>::hash(p0, p1);
+crate::<naive::date::Days as std::hash::Hash>::hash(p0, p1);
+<naive::date::Days>::hash(p0, p1);
-----------------
src/naive/date.rs <naive::date::Days as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::Days
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.eq(p1);
+<naive::date::Days as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::date::Days as std::cmp::PartialEq>::eq(p0, p1);
+<naive::date::Days>::eq(p0, p1);
-----------------
src/naive/date.rs <naive::date::Days as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::Days
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.partial_cmp(p1);
+<naive::date::Days as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<naive::date::Days as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<naive::date::Days>::partial_cmp(p0, p1);
-----------------
src/naive/date.rs naive::date::Days::new
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+naive::date::Days::new(p0);
+crate::naive::date::Days::new(p0);
+<naive::date::Days>::new(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.eq(p1);
+<naive::date::NaiveDate as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::date::NaiveDate as std::cmp::PartialEq>::eq(p0, p1);
+<naive::date::NaiveDate>::eq(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.assert_receiver_is_total_eq();
+<naive::date::NaiveDate as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<naive::date::NaiveDate as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<naive::date::NaiveDate>::assert_receiver_is_total_eq(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<naive::date::NaiveDate as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<naive::date::NaiveDate as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<naive::date::NaiveDate as std::hash::Hash>::hash(p0, p1);
+crate::<naive::date::NaiveDate as std::hash::Hash>::hash(p0, p1);
+<naive::date::NaiveDate>::hash(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.partial_cmp(p1);
+<naive::date::NaiveDate as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<naive::date::NaiveDate as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<naive::date::NaiveDate>::partial_cmp(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.cmp(p1);
+<naive::date::NaiveDate as std::cmp::Ord>::cmp(p0, p1);
+crate::<naive::date::NaiveDate as std::cmp::Ord>::cmp(p0, p1);
+<naive::date::NaiveDate>::cmp(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.clone();
+<naive::date::NaiveDate as std::clone::Clone>::clone(p0);
+crate::<naive::date::NaiveDate as std::clone::Clone>::clone(p0);
+<naive::date::NaiveDate>::clone(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::weeks_from
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.weeks_from(p1);
+naive::date::NaiveDate::weeks_from(p0, p1);
+crate::naive::date::NaiveDate::weeks_from(p0, p1);
+<naive::date::NaiveDate>::weeks_from(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_of
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::internals::Of
+naive::date::NaiveDate::from_of(p0, p1);
+crate::naive::date::NaiveDate::from_of(p0, p1);
+<naive::date::NaiveDate>::from_of(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_mdf
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
+naive::date::NaiveDate::from_mdf(p0, p1);
+crate::naive::date::NaiveDate::from_mdf(p0, p1);
+<naive::date::NaiveDate>::from_mdf(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_ymd
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+naive::date::NaiveDate::from_ymd(p0, p1, p2);
+crate::naive::date::NaiveDate::from_ymd(p0, p1, p2);
+<naive::date::NaiveDate>::from_ymd(p0, p1, p2);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_ymd_opt
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+naive::date::NaiveDate::from_ymd_opt(p0, p1, p2);
+crate::naive::date::NaiveDate::from_ymd_opt(p0, p1, p2);
+<naive::date::NaiveDate>::from_ymd_opt(p0, p1, p2);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_yo
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+naive::date::NaiveDate::from_yo(p0, p1);
+crate::naive::date::NaiveDate::from_yo(p0, p1);
+<naive::date::NaiveDate>::from_yo(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_yo_opt
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
+naive::date::NaiveDate::from_yo_opt(p0, p1);
+crate::naive::date::NaiveDate::from_yo_opt(p0, p1);
+<naive::date::NaiveDate>::from_yo_opt(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_isoywd
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
let mut p2 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+naive::date::NaiveDate::from_isoywd(p0, p1, p2);
+crate::naive::date::NaiveDate::from_isoywd(p0, p1, p2);
+<naive::date::NaiveDate>::from_isoywd(p0, p1, p2);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_isoywd_opt
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
let mut p2 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+naive::date::NaiveDate::from_isoywd_opt(p0, p1, p2);
+crate::naive::date::NaiveDate::from_isoywd_opt(p0, p1, p2);
+<naive::date::NaiveDate>::from_isoywd_opt(p0, p1, p2);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_num_days_from_ce
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+naive::date::NaiveDate::from_num_days_from_ce(p0);
+crate::naive::date::NaiveDate::from_num_days_from_ce(p0);
+<naive::date::NaiveDate>::from_num_days_from_ce(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_num_days_from_ce_opt
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+naive::date::NaiveDate::from_num_days_from_ce_opt(p0);
+crate::naive::date::NaiveDate::from_num_days_from_ce_opt(p0);
+<naive::date::NaiveDate>::from_num_days_from_ce_opt(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_weekday_of_month
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
let mut p2 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p3 = 0u8; // None+u8
+naive::date::NaiveDate::from_weekday_of_month(p0, p1, p2, p3);
+crate::naive::date::NaiveDate::from_weekday_of_month(p0, p1, p2, p3);
+<naive::date::NaiveDate>::from_weekday_of_month(p0, p1, p2, p3);
-----------------
src/naive/date.rs naive::date::NaiveDate::from_weekday_of_month_opt
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u32; // None+u32
let mut p2 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p3 = 0u8; // None+u8
+naive::date::NaiveDate::from_weekday_of_month_opt(p0, p1, p2, p3);
+crate::naive::date::NaiveDate::from_weekday_of_month_opt(p0, p1, p2, p3);
+<naive::date::NaiveDate>::from_weekday_of_month_opt(p0, p1, p2, p3);
-----------------
src/naive/date.rs naive::date::NaiveDate::parse_from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = "sample"; // None+&str
+naive::date::NaiveDate::parse_from_str(&p0, &p1);
+crate::naive::date::NaiveDate::parse_from_str(&p0, &p1);
+<naive::date::NaiveDate>::parse_from_str(&p0, &p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::checked_add_months
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.checked_add_months(p1);
+naive::date::NaiveDate::checked_add_months(p0, p1);
+crate::naive::date::NaiveDate::checked_add_months(p0, p1);
+<naive::date::NaiveDate>::checked_add_months(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::checked_sub_months
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.checked_sub_months(p1);
+naive::date::NaiveDate::checked_sub_months(p0, p1);
+crate::naive::date::NaiveDate::checked_sub_months(p0, p1);
+<naive::date::NaiveDate>::checked_sub_months(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::diff_months
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0i32; // None+i32
+p0.diff_months(p1);
+naive::date::NaiveDate::diff_months(p0, p1);
+crate::naive::date::NaiveDate::diff_months(p0, p1);
+<naive::date::NaiveDate>::diff_months(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::checked_add_days
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.checked_add_days(p1);
+naive::date::NaiveDate::checked_add_days(p0, p1);
+crate::naive::date::NaiveDate::checked_add_days(p0, p1);
+<naive::date::NaiveDate>::checked_add_days(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::checked_sub_days
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.checked_sub_days(p1);
+naive::date::NaiveDate::checked_sub_days(p0, p1);
+crate::naive::date::NaiveDate::checked_sub_days(p0, p1);
+<naive::date::NaiveDate>::checked_sub_days(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::diff_days
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0i64; // None+i64
+p0.diff_days(p1);
+naive::date::NaiveDate::diff_days(p0, p1);
+crate::naive::date::NaiveDate::diff_days(p0, p1);
+<naive::date::NaiveDate>::diff_days(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::and_time
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.and_time(p1);
+naive::date::NaiveDate::and_time(p0, p1);
+crate::naive::date::NaiveDate::and_time(p0, p1);
+<naive::date::NaiveDate>::and_time(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::and_hms
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+p0.and_hms(p1, p2, p3);
+naive::date::NaiveDate::and_hms(p0, p1, p2, p3);
+crate::naive::date::NaiveDate::and_hms(p0, p1, p2, p3);
+<naive::date::NaiveDate>::and_hms(p0, p1, p2, p3);
-----------------
src/naive/date.rs naive::date::NaiveDate::and_hms_opt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+p0.and_hms_opt(p1, p2, p3);
+naive::date::NaiveDate::and_hms_opt(p0, p1, p2, p3);
+crate::naive::date::NaiveDate::and_hms_opt(p0, p1, p2, p3);
+<naive::date::NaiveDate>::and_hms_opt(p0, p1, p2, p3);
-----------------
src/naive/date.rs naive::date::NaiveDate::and_hms_milli
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_milli(p1, p2, p3, p4);
+naive::date::NaiveDate::and_hms_milli(p0, p1, p2, p3, p4);
+crate::naive::date::NaiveDate::and_hms_milli(p0, p1, p2, p3, p4);
+<naive::date::NaiveDate>::and_hms_milli(p0, p1, p2, p3, p4);
-----------------
src/naive/date.rs naive::date::NaiveDate::and_hms_milli_opt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_milli_opt(p1, p2, p3, p4);
+naive::date::NaiveDate::and_hms_milli_opt(p0, p1, p2, p3, p4);
+crate::naive::date::NaiveDate::and_hms_milli_opt(p0, p1, p2, p3, p4);
+<naive::date::NaiveDate>::and_hms_milli_opt(p0, p1, p2, p3, p4);
-----------------
src/naive/date.rs naive::date::NaiveDate::and_hms_micro
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_micro(p1, p2, p3, p4);
+naive::date::NaiveDate::and_hms_micro(p0, p1, p2, p3, p4);
+crate::naive::date::NaiveDate::and_hms_micro(p0, p1, p2, p3, p4);
+<naive::date::NaiveDate>::and_hms_micro(p0, p1, p2, p3, p4);
-----------------
src/naive/date.rs naive::date::NaiveDate::and_hms_micro_opt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_micro_opt(p1, p2, p3, p4);
+naive::date::NaiveDate::and_hms_micro_opt(p0, p1, p2, p3, p4);
+crate::naive::date::NaiveDate::and_hms_micro_opt(p0, p1, p2, p3, p4);
+<naive::date::NaiveDate>::and_hms_micro_opt(p0, p1, p2, p3, p4);
-----------------
src/naive/date.rs naive::date::NaiveDate::and_hms_nano
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_nano(p1, p2, p3, p4);
+naive::date::NaiveDate::and_hms_nano(p0, p1, p2, p3, p4);
+crate::naive::date::NaiveDate::and_hms_nano(p0, p1, p2, p3, p4);
+<naive::date::NaiveDate>::and_hms_nano(p0, p1, p2, p3, p4);
-----------------
src/naive/date.rs naive::date::NaiveDate::and_hms_nano_opt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_nano_opt(p1, p2, p3, p4);
+naive::date::NaiveDate::and_hms_nano_opt(p0, p1, p2, p3, p4);
+crate::naive::date::NaiveDate::and_hms_nano_opt(p0, p1, p2, p3, p4);
+<naive::date::NaiveDate>::and_hms_nano_opt(p0, p1, p2, p3, p4);
-----------------
src/naive/date.rs naive::date::NaiveDate::mdf
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.mdf();
+naive::date::NaiveDate::mdf(p0);
+crate::naive::date::NaiveDate::mdf(p0);
+<naive::date::NaiveDate>::mdf(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::of
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.of();
+naive::date::NaiveDate::of(p0);
+crate::naive::date::NaiveDate::of(p0);
+<naive::date::NaiveDate>::of(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::with_mdf
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
+p0.with_mdf(p1);
+naive::date::NaiveDate::with_mdf(p0, p1);
+crate::naive::date::NaiveDate::with_mdf(p0, p1);
+<naive::date::NaiveDate>::with_mdf(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::with_of
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.with_of(p1);
+naive::date::NaiveDate::with_of(p0, p1);
+crate::naive::date::NaiveDate::with_of(p0, p1);
+<naive::date::NaiveDate>::with_of(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::succ
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.succ();
+naive::date::NaiveDate::succ(p0);
+crate::naive::date::NaiveDate::succ(p0);
+<naive::date::NaiveDate>::succ(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::succ_opt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.succ_opt();
+naive::date::NaiveDate::succ_opt(p0);
+crate::naive::date::NaiveDate::succ_opt(p0);
+<naive::date::NaiveDate>::succ_opt(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::pred
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.pred();
+naive::date::NaiveDate::pred(p0);
+crate::naive::date::NaiveDate::pred(p0);
+<naive::date::NaiveDate>::pred(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::pred_opt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.pred_opt();
+naive::date::NaiveDate::pred_opt(p0);
+crate::naive::date::NaiveDate::pred_opt(p0);
+<naive::date::NaiveDate>::pred_opt(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::checked_add_signed
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_add_signed(p1);
+naive::date::NaiveDate::checked_add_signed(p0, p1);
+crate::naive::date::NaiveDate::checked_add_signed(p0, p1);
+<naive::date::NaiveDate>::checked_add_signed(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::checked_sub_signed
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_sub_signed(p1);
+naive::date::NaiveDate::checked_sub_signed(p0, p1);
+crate::naive::date::NaiveDate::checked_sub_signed(p0, p1);
+<naive::date::NaiveDate>::checked_sub_signed(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::signed_duration_since
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.signed_duration_since(p1);
+naive::date::NaiveDate::signed_duration_since(p0, p1);
+crate::naive::date::NaiveDate::signed_duration_since(p0, p1);
+<naive::date::NaiveDate>::signed_duration_since(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::years_since
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.years_since(p1);
+naive::date::NaiveDate::years_since(p0, p1);
+crate::naive::date::NaiveDate::years_since(p0, p1);
+<naive::date::NaiveDate>::years_since(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::format_with_items
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"naive::date::NaiveDate::format_with_items":{"B":["std::marker::Sized","std::borrow::Borrow"],"I":["std::marker::Sized","std::iter::Iterator","std::clone::Clone"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"naive::date::NaiveDate::format_with_items":{"B":["std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::OsString","std::boxed::Box<T, A>","std::rc::Rc<T>","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::string::String","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>"],"I":["format::strftime::StrftimeItems","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.format_with_items(p1);
+naive::date::NaiveDate::format_with_items(p0, p1);
+crate::naive::date::NaiveDate::format_with_items(p0, p1);
+<naive::date::NaiveDate>::format_with_items(p0, p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::format
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = "sample"; // None+&str
+p0.format(&p1);
+naive::date::NaiveDate::format(p0, &p1);
+crate::naive::date::NaiveDate::format(p0, &p1);
+<naive::date::NaiveDate>::format(p0, &p1);
-----------------
src/naive/date.rs naive::date::NaiveDate::iter_days
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.iter_days();
+naive::date::NaiveDate::iter_days(p0);
+crate::naive::date::NaiveDate::iter_days(p0);
+<naive::date::NaiveDate>::iter_days(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::iter_weeks
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.iter_weeks();
+naive::date::NaiveDate::iter_weeks(p0);
+crate::naive::date::NaiveDate::iter_weeks(p0);
+<naive::date::NaiveDate>::iter_weeks(p0);
-----------------
src/naive/date.rs naive::date::NaiveDate::week
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.week(p1);
+naive::date::NaiveDate::week(p0, p1);
+crate::naive::date::NaiveDate::week(p0, p1);
+<naive::date::NaiveDate>::week(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::year
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.year();
+<naive::date::NaiveDate as traits::Datelike>::year(p0);
+crate::<naive::date::NaiveDate as traits::Datelike>::year(p0);
+<naive::date::NaiveDate>::year(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::month
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.month();
+<naive::date::NaiveDate as traits::Datelike>::month(p0);
+crate::<naive::date::NaiveDate as traits::Datelike>::month(p0);
+<naive::date::NaiveDate>::month(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::month0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.month0();
+<naive::date::NaiveDate as traits::Datelike>::month0(p0);
+crate::<naive::date::NaiveDate as traits::Datelike>::month0(p0);
+<naive::date::NaiveDate>::month0(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::day
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.day();
+<naive::date::NaiveDate as traits::Datelike>::day(p0);
+crate::<naive::date::NaiveDate as traits::Datelike>::day(p0);
+<naive::date::NaiveDate>::day(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::day0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.day0();
+<naive::date::NaiveDate as traits::Datelike>::day0(p0);
+crate::<naive::date::NaiveDate as traits::Datelike>::day0(p0);
+<naive::date::NaiveDate>::day0(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::ordinal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.ordinal();
+<naive::date::NaiveDate as traits::Datelike>::ordinal(p0);
+crate::<naive::date::NaiveDate as traits::Datelike>::ordinal(p0);
+<naive::date::NaiveDate>::ordinal(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::ordinal0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.ordinal0();
+<naive::date::NaiveDate as traits::Datelike>::ordinal0(p0);
+crate::<naive::date::NaiveDate as traits::Datelike>::ordinal0(p0);
+<naive::date::NaiveDate>::ordinal0(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::weekday
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.weekday();
+<naive::date::NaiveDate as traits::Datelike>::weekday(p0);
+crate::<naive::date::NaiveDate as traits::Datelike>::weekday(p0);
+<naive::date::NaiveDate>::weekday(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::iso_week
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.iso_week();
+<naive::date::NaiveDate as traits::Datelike>::iso_week(p0);
+crate::<naive::date::NaiveDate as traits::Datelike>::iso_week(p0);
+<naive::date::NaiveDate>::iso_week(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::with_year
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0i32; // None+i32
+p0.with_year(p1);
+<naive::date::NaiveDate as traits::Datelike>::with_year(p0, p1);
+crate::<naive::date::NaiveDate as traits::Datelike>::with_year(p0, p1);
+<naive::date::NaiveDate>::with_year(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::with_month
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
+p0.with_month(p1);
+<naive::date::NaiveDate as traits::Datelike>::with_month(p0, p1);
+crate::<naive::date::NaiveDate as traits::Datelike>::with_month(p0, p1);
+<naive::date::NaiveDate>::with_month(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::with_month0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
+p0.with_month0(p1);
+<naive::date::NaiveDate as traits::Datelike>::with_month0(p0, p1);
+crate::<naive::date::NaiveDate as traits::Datelike>::with_month0(p0, p1);
+<naive::date::NaiveDate>::with_month0(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::with_day
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
+p0.with_day(p1);
+<naive::date::NaiveDate as traits::Datelike>::with_day(p0, p1);
+crate::<naive::date::NaiveDate as traits::Datelike>::with_day(p0, p1);
+<naive::date::NaiveDate>::with_day(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::with_day0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
+p0.with_day0(p1);
+<naive::date::NaiveDate as traits::Datelike>::with_day0(p0, p1);
+crate::<naive::date::NaiveDate as traits::Datelike>::with_day0(p0, p1);
+<naive::date::NaiveDate>::with_day0(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::with_ordinal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
+p0.with_ordinal(p1);
+<naive::date::NaiveDate as traits::Datelike>::with_ordinal(p0, p1);
+crate::<naive::date::NaiveDate as traits::Datelike>::with_ordinal(p0, p1);
+<naive::date::NaiveDate>::with_ordinal(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as traits::Datelike>::with_ordinal0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = 0u32; // None+u32
+p0.with_ordinal0(p1);
+<naive::date::NaiveDate as traits::Datelike>::with_ordinal0(p0, p1);
+crate::<naive::date::NaiveDate as traits::Datelike>::with_ordinal0(p0, p1);
+<naive::date::NaiveDate>::with_ordinal0(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::ops::Add<time_delta::TimeDelta>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add(p1);
+<naive::date::NaiveDate as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+crate::<naive::date::NaiveDate as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+<naive::date::NaiveDate>::add(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add_assign(p1);
+<naive::date::NaiveDate as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+crate::<naive::date::NaiveDate as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+<naive::date::NaiveDate>::add_assign(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::ops::Add<month::Months>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.add(p1);
+<naive::date::NaiveDate as std::ops::Add<month::Months>>::add(p0, p1);
+crate::<naive::date::NaiveDate as std::ops::Add<month::Months>>::add(p0, p1);
+<naive::date::NaiveDate>::add(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::ops::Sub<month::Months>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.sub(p1);
+<naive::date::NaiveDate as std::ops::Sub<month::Months>>::sub(p0, p1);
+crate::<naive::date::NaiveDate as std::ops::Sub<month::Months>>::sub(p0, p1);
+<naive::date::NaiveDate>::sub(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::ops::Add<naive::date::Days>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.add(p1);
+<naive::date::NaiveDate as std::ops::Add<naive::date::Days>>::add(p0, p1);
+crate::<naive::date::NaiveDate as std::ops::Add<naive::date::Days>>::add(p0, p1);
+<naive::date::NaiveDate>::add(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::ops::Sub<naive::date::Days>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.sub(p1);
+<naive::date::NaiveDate as std::ops::Sub<naive::date::Days>>::sub(p0, p1);
+crate::<naive::date::NaiveDate as std::ops::Sub<naive::date::Days>>::sub(p0, p1);
+<naive::date::NaiveDate>::sub(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::ops::Sub<time_delta::TimeDelta>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub(p1);
+<naive::date::NaiveDate as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+crate::<naive::date::NaiveDate as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+<naive::date::NaiveDate>::sub(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub_assign(p1);
+<naive::date::NaiveDate as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+crate::<naive::date::NaiveDate as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+<naive::date::NaiveDate>::sub_assign(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.sub(p1);
+<naive::date::NaiveDate as std::ops::Sub>::sub(p0, p1);
+crate::<naive::date::NaiveDate as std::ops::Sub>::sub(p0, p1);
+<naive::date::NaiveDate>::sub(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::convert::From<naive::datetime::NaiveDateTime>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+<naive::date::NaiveDate as std::convert::From<naive::datetime::NaiveDateTime>>::from(p0);
+crate::<naive::date::NaiveDate as std::convert::From<naive::datetime::NaiveDateTime>>::from(p0);
+<naive::date::NaiveDate>::from(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::date::NaiveDateDaysIterator as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::date::NaiveDateDaysIterator as std::fmt::Debug>::fmt(p0, p1);
+<naive::date::NaiveDateDaysIterator>::fmt(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
+p0.clone();
+<naive::date::NaiveDateDaysIterator as std::clone::Clone>::clone(p0);
+crate::<naive::date::NaiveDateDaysIterator as std::clone::Clone>::clone(p0);
+<naive::date::NaiveDateDaysIterator>::clone(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<naive::date::NaiveDateDaysIterator as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<naive::date::NaiveDateDaysIterator as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::hash::SipHasher13","std::hash::SipHasher","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<naive::date::NaiveDateDaysIterator as std::hash::Hash>::hash(p0, p1);
+crate::<naive::date::NaiveDateDaysIterator as std::hash::Hash>::hash(p0, p1);
+<naive::date::NaiveDateDaysIterator>::hash(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
+p0.eq(p1);
+<naive::date::NaiveDateDaysIterator as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::date::NaiveDateDaysIterator as std::cmp::PartialEq>::eq(p0, p1);
+<naive::date::NaiveDateDaysIterator>::eq(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
+p0.partial_cmp(p1);
+<naive::date::NaiveDateDaysIterator as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<naive::date::NaiveDateDaysIterator as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<naive::date::NaiveDateDaysIterator>::partial_cmp(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
+p0.assert_receiver_is_total_eq();
+<naive::date::NaiveDateDaysIterator as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<naive::date::NaiveDateDaysIterator as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<naive::date::NaiveDateDaysIterator>::assert_receiver_is_total_eq(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
+p0.cmp(p1);
+<naive::date::NaiveDateDaysIterator as std::cmp::Ord>::cmp(p0, p1);
+crate::<naive::date::NaiveDateDaysIterator as std::cmp::Ord>::cmp(p0, p1);
+<naive::date::NaiveDateDaysIterator>::cmp(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
+p0.next();
+<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::next(p0);
+crate::<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::next(p0);
+<naive::date::NaiveDateDaysIterator>::next(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::iter::Iterator>::size_hint
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
+p0.size_hint();
+<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::size_hint(p0);
+crate::<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::size_hint(p0);
+<naive::date::NaiveDateDaysIterator>::size_hint(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateDaysIterator as std::iter::DoubleEndedIterator>::next_back
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateDaysIterator
+p0.next_back();
+<naive::date::NaiveDateDaysIterator as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<naive::date::NaiveDateDaysIterator as std::iter::DoubleEndedIterator>::next_back(p0);
+<naive::date::NaiveDateDaysIterator>::next_back(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::date::NaiveDateWeeksIterator as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::date::NaiveDateWeeksIterator as std::fmt::Debug>::fmt(p0, p1);
+<naive::date::NaiveDateWeeksIterator>::fmt(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
+p0.clone();
+<naive::date::NaiveDateWeeksIterator as std::clone::Clone>::clone(p0);
+crate::<naive::date::NaiveDateWeeksIterator as std::clone::Clone>::clone(p0);
+<naive::date::NaiveDateWeeksIterator>::clone(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<naive::date::NaiveDateWeeksIterator as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<naive::date::NaiveDateWeeksIterator as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<naive::date::NaiveDateWeeksIterator as std::hash::Hash>::hash(p0, p1);
+crate::<naive::date::NaiveDateWeeksIterator as std::hash::Hash>::hash(p0, p1);
+<naive::date::NaiveDateWeeksIterator>::hash(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
+p0.eq(p1);
+<naive::date::NaiveDateWeeksIterator as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::date::NaiveDateWeeksIterator as std::cmp::PartialEq>::eq(p0, p1);
+<naive::date::NaiveDateWeeksIterator>::eq(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
+p0.partial_cmp(p1);
+<naive::date::NaiveDateWeeksIterator as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<naive::date::NaiveDateWeeksIterator as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<naive::date::NaiveDateWeeksIterator>::partial_cmp(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
+p0.assert_receiver_is_total_eq();
+<naive::date::NaiveDateWeeksIterator as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<naive::date::NaiveDateWeeksIterator as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<naive::date::NaiveDateWeeksIterator>::assert_receiver_is_total_eq(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
+p0.cmp(p1);
+<naive::date::NaiveDateWeeksIterator as std::cmp::Ord>::cmp(p0, p1);
+crate::<naive::date::NaiveDateWeeksIterator as std::cmp::Ord>::cmp(p0, p1);
+<naive::date::NaiveDateWeeksIterator>::cmp(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
+p0.next();
+<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::next(p0);
+crate::<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::next(p0);
+<naive::date::NaiveDateWeeksIterator>::next(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::size_hint
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
+p0.size_hint();
+<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::size_hint(p0);
+crate::<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::size_hint(p0);
+<naive::date::NaiveDateWeeksIterator>::size_hint(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDateWeeksIterator as std::iter::DoubleEndedIterator>::next_back
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::date::NaiveDateWeeksIterator
+p0.next_back();
+<naive::date::NaiveDateWeeksIterator as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<naive::date::NaiveDateWeeksIterator as std::iter::DoubleEndedIterator>::next_back(p0);
+<naive::date::NaiveDateWeeksIterator>::next_back(p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::date::NaiveDate as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::date::NaiveDate as std::fmt::Debug>::fmt(p0, p1);
+<naive::date::NaiveDate>::fmt(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<naive::date::NaiveDate as std::fmt::Display>::fmt(p0, p1);
+crate::<naive::date::NaiveDate as std::fmt::Display>::fmt(p0, p1);
+<naive::date::NaiveDate>::fmt(p0, p1);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<naive::date::NaiveDate as std::str::FromStr>::from_str(&p0);
+crate::<naive::date::NaiveDate as std::str::FromStr>::from_str(&p0);
+<naive::date::NaiveDate>::from_str(&p0);
-----------------
src/naive/date.rs <naive::date::NaiveDate as std::default::Default>::default
deps:{}
candidates:{}
+<naive::date::NaiveDate as std::default::Default>::default();
+crate::<naive::date::NaiveDate as std::default::Default>::default();
+<naive::date::NaiveDate>::default();
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.eq(p1);
+<naive::datetime::NaiveDateTime as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::cmp::PartialEq>::eq(p0, p1);
+<naive::datetime::NaiveDateTime>::eq(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.assert_receiver_is_total_eq();
+<naive::datetime::NaiveDateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<naive::datetime::NaiveDateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<naive::datetime::NaiveDateTime>::assert_receiver_is_total_eq(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<naive::datetime::NaiveDateTime as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<naive::datetime::NaiveDateTime as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<naive::datetime::NaiveDateTime as std::hash::Hash>::hash(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::hash::Hash>::hash(p0, p1);
+<naive::datetime::NaiveDateTime>::hash(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.partial_cmp(p1);
+<naive::datetime::NaiveDateTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<naive::datetime::NaiveDateTime>::partial_cmp(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.cmp(p1);
+<naive::datetime::NaiveDateTime as std::cmp::Ord>::cmp(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::cmp::Ord>::cmp(p0, p1);
+<naive::datetime::NaiveDateTime>::cmp(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.clone();
+<naive::datetime::NaiveDateTime as std::clone::Clone>::clone(p0);
+crate::<naive::datetime::NaiveDateTime as std::clone::Clone>::clone(p0);
+<naive::datetime::NaiveDateTime>::clone(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+naive::datetime::NaiveDateTime::new(p0, p1);
+crate::naive::datetime::NaiveDateTime::new(p0, p1);
+<naive::datetime::NaiveDateTime>::new(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::from_timestamp
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+naive::datetime::NaiveDateTime::from_timestamp(p0, p1);
+crate::naive::datetime::NaiveDateTime::from_timestamp(p0, p1);
+<naive::datetime::NaiveDateTime>::from_timestamp(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::from_timestamp_millis
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+naive::datetime::NaiveDateTime::from_timestamp_millis(p0);
+crate::naive::datetime::NaiveDateTime::from_timestamp_millis(p0);
+<naive::datetime::NaiveDateTime>::from_timestamp_millis(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::from_timestamp_micros
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+naive::datetime::NaiveDateTime::from_timestamp_micros(p0);
+crate::naive::datetime::NaiveDateTime::from_timestamp_micros(p0);
+<naive::datetime::NaiveDateTime>::from_timestamp_micros(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::from_timestamp_opt
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0u32; // None+u32
+naive::datetime::NaiveDateTime::from_timestamp_opt(p0, p1);
+crate::naive::datetime::NaiveDateTime::from_timestamp_opt(p0, p1);
+<naive::datetime::NaiveDateTime>::from_timestamp_opt(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::parse_from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = "sample"; // None+&str
+naive::datetime::NaiveDateTime::parse_from_str(&p0, &p1);
+crate::naive::datetime::NaiveDateTime::parse_from_str(&p0, &p1);
+<naive::datetime::NaiveDateTime>::parse_from_str(&p0, &p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.date();
+naive::datetime::NaiveDateTime::date(p0);
+crate::naive::datetime::NaiveDateTime::date(p0);
+<naive::datetime::NaiveDateTime>::date(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::time
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.time();
+naive::datetime::NaiveDateTime::time(p0);
+crate::naive::datetime::NaiveDateTime::time(p0);
+<naive::datetime::NaiveDateTime>::time(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::timestamp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.timestamp();
+naive::datetime::NaiveDateTime::timestamp(p0);
+crate::naive::datetime::NaiveDateTime::timestamp(p0);
+<naive::datetime::NaiveDateTime>::timestamp(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::timestamp_millis
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.timestamp_millis();
+naive::datetime::NaiveDateTime::timestamp_millis(p0);
+crate::naive::datetime::NaiveDateTime::timestamp_millis(p0);
+<naive::datetime::NaiveDateTime>::timestamp_millis(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::timestamp_micros
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.timestamp_micros();
+naive::datetime::NaiveDateTime::timestamp_micros(p0);
+crate::naive::datetime::NaiveDateTime::timestamp_micros(p0);
+<naive::datetime::NaiveDateTime>::timestamp_micros(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::timestamp_nanos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.timestamp_nanos();
+naive::datetime::NaiveDateTime::timestamp_nanos(p0);
+crate::naive::datetime::NaiveDateTime::timestamp_nanos(p0);
+<naive::datetime::NaiveDateTime>::timestamp_nanos(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::timestamp_subsec_millis
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.timestamp_subsec_millis();
+naive::datetime::NaiveDateTime::timestamp_subsec_millis(p0);
+crate::naive::datetime::NaiveDateTime::timestamp_subsec_millis(p0);
+<naive::datetime::NaiveDateTime>::timestamp_subsec_millis(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::timestamp_subsec_micros
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.timestamp_subsec_micros();
+naive::datetime::NaiveDateTime::timestamp_subsec_micros(p0);
+crate::naive::datetime::NaiveDateTime::timestamp_subsec_micros(p0);
+<naive::datetime::NaiveDateTime>::timestamp_subsec_micros(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::timestamp_subsec_nanos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.timestamp_subsec_nanos();
+naive::datetime::NaiveDateTime::timestamp_subsec_nanos(p0);
+crate::naive::datetime::NaiveDateTime::timestamp_subsec_nanos(p0);
+<naive::datetime::NaiveDateTime>::timestamp_subsec_nanos(p0);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::checked_add_signed
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_add_signed(p1);
+naive::datetime::NaiveDateTime::checked_add_signed(p0, p1);
+crate::naive::datetime::NaiveDateTime::checked_add_signed(p0, p1);
+<naive::datetime::NaiveDateTime>::checked_add_signed(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::checked_add_months
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.checked_add_months(p1);
+naive::datetime::NaiveDateTime::checked_add_months(p0, p1);
+crate::naive::datetime::NaiveDateTime::checked_add_months(p0, p1);
+<naive::datetime::NaiveDateTime>::checked_add_months(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::checked_sub_signed
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.checked_sub_signed(p1);
+naive::datetime::NaiveDateTime::checked_sub_signed(p0, p1);
+crate::naive::datetime::NaiveDateTime::checked_sub_signed(p0, p1);
+<naive::datetime::NaiveDateTime>::checked_sub_signed(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::checked_sub_months
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.checked_sub_months(p1);
+naive::datetime::NaiveDateTime::checked_sub_months(p0, p1);
+crate::naive::datetime::NaiveDateTime::checked_sub_months(p0, p1);
+<naive::datetime::NaiveDateTime>::checked_sub_months(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::checked_add_days
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.checked_add_days(p1);
+naive::datetime::NaiveDateTime::checked_add_days(p0, p1);
+crate::naive::datetime::NaiveDateTime::checked_add_days(p0, p1);
+<naive::datetime::NaiveDateTime>::checked_add_days(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::checked_sub_days
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.checked_sub_days(p1);
+naive::datetime::NaiveDateTime::checked_sub_days(p0, p1);
+crate::naive::datetime::NaiveDateTime::checked_sub_days(p0, p1);
+<naive::datetime::NaiveDateTime>::checked_sub_days(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::signed_duration_since
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.signed_duration_since(p1);
+naive::datetime::NaiveDateTime::signed_duration_since(p0, p1);
+crate::naive::datetime::NaiveDateTime::signed_duration_since(p0, p1);
+<naive::datetime::NaiveDateTime>::signed_duration_since(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::format_with_items
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"naive::datetime::NaiveDateTime::format_with_items":{"B":["std::borrow::Borrow","std::marker::Sized"],"I":["std::iter::Iterator","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"naive::datetime::NaiveDateTime::format_with_items":{"B":["std::rc::Rc<T>","std::sync::Arc<T>","std::string::String","std::path::PathBuf","<T as std::borrow::Borrow<T>>","std::ffi::CString","std::boxed::Box<T, A>","std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::borrow::Cow<'a, B>"],"I":["naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems","naive::date::NaiveDateWeeksIterator"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.format_with_items(p1);
+naive::datetime::NaiveDateTime::format_with_items(p0, p1);
+crate::naive::datetime::NaiveDateTime::format_with_items(p0, p1);
+<naive::datetime::NaiveDateTime>::format_with_items(p0, p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::format
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = "sample"; // None+&str
+p0.format(&p1);
+naive::datetime::NaiveDateTime::format(p0, &p1);
+crate::naive::datetime::NaiveDateTime::format(p0, &p1);
+<naive::datetime::NaiveDateTime>::format(p0, &p1);
-----------------
src/naive/datetime/mod.rs naive::datetime::NaiveDateTime::and_local_timezone
deps:{"naive::datetime::NaiveDateTime::and_local_timezone":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"naive::datetime::NaiveDateTime::and_local_timezone":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // Tz
+p0.and_local_timezone(p1);
+naive::datetime::NaiveDateTime::and_local_timezone(p0, p1);
+crate::naive::datetime::NaiveDateTime::and_local_timezone(p0, p1);
+<naive::datetime::NaiveDateTime>::and_local_timezone(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::year
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.year();
+<naive::datetime::NaiveDateTime as traits::Datelike>::year(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::year(p0);
+<naive::datetime::NaiveDateTime>::year(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::month
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.month();
+<naive::datetime::NaiveDateTime as traits::Datelike>::month(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::month(p0);
+<naive::datetime::NaiveDateTime>::month(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::month0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.month0();
+<naive::datetime::NaiveDateTime as traits::Datelike>::month0(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::month0(p0);
+<naive::datetime::NaiveDateTime>::month0(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::day
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.day();
+<naive::datetime::NaiveDateTime as traits::Datelike>::day(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::day(p0);
+<naive::datetime::NaiveDateTime>::day(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::day0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.day0();
+<naive::datetime::NaiveDateTime as traits::Datelike>::day0(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::day0(p0);
+<naive::datetime::NaiveDateTime>::day0(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::ordinal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.ordinal();
+<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal(p0);
+<naive::datetime::NaiveDateTime>::ordinal(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::ordinal0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.ordinal0();
+<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal0(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal0(p0);
+<naive::datetime::NaiveDateTime>::ordinal0(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::weekday
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.weekday();
+<naive::datetime::NaiveDateTime as traits::Datelike>::weekday(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::weekday(p0);
+<naive::datetime::NaiveDateTime>::weekday(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::iso_week
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.iso_week();
+<naive::datetime::NaiveDateTime as traits::Datelike>::iso_week(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::iso_week(p0);
+<naive::datetime::NaiveDateTime>::iso_week(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::with_year
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0i32; // None+i32
+p0.with_year(p1);
+<naive::datetime::NaiveDateTime as traits::Datelike>::with_year(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::with_year(p0, p1);
+<naive::datetime::NaiveDateTime>::with_year(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::with_month
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_month(p1);
+<naive::datetime::NaiveDateTime as traits::Datelike>::with_month(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::with_month(p0, p1);
+<naive::datetime::NaiveDateTime>::with_month(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::with_month0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_month0(p1);
+<naive::datetime::NaiveDateTime as traits::Datelike>::with_month0(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::with_month0(p0, p1);
+<naive::datetime::NaiveDateTime>::with_month0(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::with_day
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_day(p1);
+<naive::datetime::NaiveDateTime as traits::Datelike>::with_day(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::with_day(p0, p1);
+<naive::datetime::NaiveDateTime>::with_day(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::with_day0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_day0(p1);
+<naive::datetime::NaiveDateTime as traits::Datelike>::with_day0(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::with_day0(p0, p1);
+<naive::datetime::NaiveDateTime>::with_day0(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_ordinal(p1);
+<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal(p0, p1);
+<naive::datetime::NaiveDateTime>::with_ordinal(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_ordinal0(p1);
+<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal0(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal0(p0, p1);
+<naive::datetime::NaiveDateTime>::with_ordinal0(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Timelike>::hour
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.hour();
+<naive::datetime::NaiveDateTime as traits::Timelike>::hour(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Timelike>::hour(p0);
+<naive::datetime::NaiveDateTime>::hour(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Timelike>::minute
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.minute();
+<naive::datetime::NaiveDateTime as traits::Timelike>::minute(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Timelike>::minute(p0);
+<naive::datetime::NaiveDateTime>::minute(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Timelike>::second
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.second();
+<naive::datetime::NaiveDateTime as traits::Timelike>::second(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Timelike>::second(p0);
+<naive::datetime::NaiveDateTime>::second(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Timelike>::nanosecond
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.nanosecond();
+<naive::datetime::NaiveDateTime as traits::Timelike>::nanosecond(p0);
+crate::<naive::datetime::NaiveDateTime as traits::Timelike>::nanosecond(p0);
+<naive::datetime::NaiveDateTime>::nanosecond(p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Timelike>::with_hour
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_hour(p1);
+<naive::datetime::NaiveDateTime as traits::Timelike>::with_hour(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Timelike>::with_hour(p0, p1);
+<naive::datetime::NaiveDateTime>::with_hour(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Timelike>::with_minute
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_minute(p1);
+<naive::datetime::NaiveDateTime as traits::Timelike>::with_minute(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Timelike>::with_minute(p0, p1);
+<naive::datetime::NaiveDateTime>::with_minute(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Timelike>::with_second
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_second(p1);
+<naive::datetime::NaiveDateTime as traits::Timelike>::with_second(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Timelike>::with_second(p0, p1);
+<naive::datetime::NaiveDateTime>::with_second(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as traits::Timelike>::with_nanosecond
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = 0u32; // None+u32
+p0.with_nanosecond(p1);
+<naive::datetime::NaiveDateTime as traits::Timelike>::with_nanosecond(p0, p1);
+crate::<naive::datetime::NaiveDateTime as traits::Timelike>::with_nanosecond(p0, p1);
+<naive::datetime::NaiveDateTime>::with_nanosecond(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::ops::Add<time_delta::TimeDelta>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add(p1);
+<naive::datetime::NaiveDateTime as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+<naive::datetime::NaiveDateTime>::add(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add_assign(p1);
+<naive::datetime::NaiveDateTime as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+<naive::datetime::NaiveDateTime>::add_assign(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::ops::Add<month::Months>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.add(p1);
+<naive::datetime::NaiveDateTime as std::ops::Add<month::Months>>::add(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::ops::Add<month::Months>>::add(p0, p1);
+<naive::datetime::NaiveDateTime>::add(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::ops::Sub<time_delta::TimeDelta>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub(p1);
+<naive::datetime::NaiveDateTime as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+<naive::datetime::NaiveDateTime>::sub(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub_assign(p1);
+<naive::datetime::NaiveDateTime as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+<naive::datetime::NaiveDateTime>::sub_assign(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::ops::Sub<month::Months>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Months
+p0.sub(p1);
+<naive::datetime::NaiveDateTime as std::ops::Sub<month::Months>>::sub(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::ops::Sub<month::Months>>::sub(p0, p1);
+<naive::datetime::NaiveDateTime>::sub(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.sub(p1);
+<naive::datetime::NaiveDateTime as std::ops::Sub>::sub(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::ops::Sub>::sub(p0, p1);
+<naive::datetime::NaiveDateTime>::sub(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::ops::Add<naive::date::Days>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.add(p1);
+<naive::datetime::NaiveDateTime as std::ops::Add<naive::date::Days>>::add(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::ops::Add<naive::date::Days>>::add(p0, p1);
+<naive::datetime::NaiveDateTime>::add(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::ops::Sub<naive::date::Days>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::date::Days
+p0.sub(p1);
+<naive::datetime::NaiveDateTime as std::ops::Sub<naive::date::Days>>::sub(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::ops::Sub<naive::date::Days>>::sub(p0, p1);
+<naive::datetime::NaiveDateTime>::sub(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::datetime::NaiveDateTime as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::fmt::Debug>::fmt(p0, p1);
+<naive::datetime::NaiveDateTime>::fmt(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<naive::datetime::NaiveDateTime as std::fmt::Display>::fmt(p0, p1);
+crate::<naive::datetime::NaiveDateTime as std::fmt::Display>::fmt(p0, p1);
+<naive::datetime::NaiveDateTime>::fmt(p0, p1);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<naive::datetime::NaiveDateTime as std::str::FromStr>::from_str(&p0);
+crate::<naive::datetime::NaiveDateTime as std::str::FromStr>::from_str(&p0);
+<naive::datetime::NaiveDateTime>::from_str(&p0);
-----------------
src/naive/datetime/mod.rs <naive::datetime::NaiveDateTime as std::default::Default>::default
deps:{}
candidates:{}
+<naive::datetime::NaiveDateTime as std::default::Default>::default();
+crate::<naive::datetime::NaiveDateTime as std::default::Default>::default();
+<naive::datetime::NaiveDateTime>::default();
-----------------
src/naive/internals.rs <naive::internals::YearFlags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
+p0.eq(p1);
+<naive::internals::YearFlags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::internals::YearFlags as std::cmp::PartialEq>::eq(p0, p1);
+<naive::internals::YearFlags>::eq(p0, p1);
-----------------
src/naive/internals.rs <naive::internals::YearFlags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
+p0.assert_receiver_is_total_eq();
+<naive::internals::YearFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<naive::internals::YearFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<naive::internals::YearFlags>::assert_receiver_is_total_eq(p0);
-----------------
src/naive/internals.rs <naive::internals::YearFlags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
+p0.clone();
+<naive::internals::YearFlags as std::clone::Clone>::clone(p0);
+crate::<naive::internals::YearFlags as std::clone::Clone>::clone(p0);
+<naive::internals::YearFlags>::clone(p0);
-----------------
src/naive/internals.rs <naive::internals::YearFlags as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<naive::internals::YearFlags as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<naive::internals::YearFlags as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<naive::internals::YearFlags as std::hash::Hash>::hash(p0, p1);
+crate::<naive::internals::YearFlags as std::hash::Hash>::hash(p0, p1);
+<naive::internals::YearFlags>::hash(p0, p1);
-----------------
src/naive/internals.rs naive::internals::YearFlags::from_year
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+naive::internals::YearFlags::from_year(p0);
+crate::naive::internals::YearFlags::from_year(p0);
+<naive::internals::YearFlags>::from_year(p0);
-----------------
src/naive/internals.rs naive::internals::YearFlags::from_year_mod_400
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+naive::internals::YearFlags::from_year_mod_400(p0);
+crate::naive::internals::YearFlags::from_year_mod_400(p0);
+<naive::internals::YearFlags>::from_year_mod_400(p0);
-----------------
src/naive/internals.rs naive::internals::YearFlags::ndays
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
+p0.ndays();
+naive::internals::YearFlags::ndays(p0);
+crate::naive::internals::YearFlags::ndays(p0);
+<naive::internals::YearFlags>::ndays(p0);
-----------------
src/naive/internals.rs naive::internals::YearFlags::isoweek_delta
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
+p0.isoweek_delta();
+naive::internals::YearFlags::isoweek_delta(p0);
+crate::naive::internals::YearFlags::isoweek_delta(p0);
+<naive::internals::YearFlags>::isoweek_delta(p0);
-----------------
src/naive/internals.rs naive::internals::YearFlags::nisoweeks
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
+p0.nisoweeks();
+naive::internals::YearFlags::nisoweeks(p0);
+crate::naive::internals::YearFlags::nisoweeks(p0);
+<naive::internals::YearFlags>::nisoweeks(p0);
-----------------
src/naive/internals.rs <naive::internals::YearFlags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::internals::YearFlags as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::internals::YearFlags as std::fmt::Debug>::fmt(p0, p1);
+<naive::internals::YearFlags>::fmt(p0, p1);
-----------------
src/naive/internals.rs <naive::internals::Of as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.eq(p1);
+<naive::internals::Of as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::internals::Of as std::cmp::PartialEq>::eq(p0, p1);
+<naive::internals::Of>::eq(p0, p1);
-----------------
src/naive/internals.rs <naive::internals::Of as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.partial_cmp(p1);
+<naive::internals::Of as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<naive::internals::Of as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<naive::internals::Of>::partial_cmp(p0, p1);
-----------------
src/naive/internals.rs <naive::internals::Of as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.clone();
+<naive::internals::Of as std::clone::Clone>::clone(p0);
+crate::<naive::internals::Of as std::clone::Clone>::clone(p0);
+<naive::internals::Of>::clone(p0);
-----------------
src/naive/internals.rs naive::internals::Of::new
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
+naive::internals::Of::new(p0, p1);
+crate::naive::internals::Of::new(p0, p1);
+<naive::internals::Of>::new(p0, p1);
-----------------
src/naive/internals.rs naive::internals::Of::from_mdf
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
+naive::internals::Of::from_mdf(p0);
+crate::naive::internals::Of::from_mdf(p0);
+<naive::internals::Of>::from_mdf(p0);
-----------------
src/naive/internals.rs naive::internals::Of::valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.valid();
+naive::internals::Of::valid(p0);
+crate::naive::internals::Of::valid(p0);
+<naive::internals::Of>::valid(p0);
-----------------
src/naive/internals.rs naive::internals::Of::ordinal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.ordinal();
+naive::internals::Of::ordinal(p0);
+crate::naive::internals::Of::ordinal(p0);
+<naive::internals::Of>::ordinal(p0);
-----------------
src/naive/internals.rs naive::internals::Of::with_ordinal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
let mut p1 = 0u32; // None+u32
+p0.with_ordinal(p1);
+naive::internals::Of::with_ordinal(p0, p1);
+crate::naive::internals::Of::with_ordinal(p0, p1);
+<naive::internals::Of>::with_ordinal(p0, p1);
-----------------
src/naive/internals.rs naive::internals::Of::flags
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.flags();
+naive::internals::Of::flags(p0);
+crate::naive::internals::Of::flags(p0);
+<naive::internals::Of>::flags(p0);
-----------------
src/naive/internals.rs naive::internals::Of::weekday
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.weekday();
+naive::internals::Of::weekday(p0);
+crate::naive::internals::Of::weekday(p0);
+<naive::internals::Of>::weekday(p0);
-----------------
src/naive/internals.rs naive::internals::Of::isoweekdate_raw
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.isoweekdate_raw();
+naive::internals::Of::isoweekdate_raw(p0);
+crate::naive::internals::Of::isoweekdate_raw(p0);
+<naive::internals::Of>::isoweekdate_raw(p0);
-----------------
src/naive/internals.rs naive::internals::Of::to_mdf
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.to_mdf();
+naive::internals::Of::to_mdf(p0);
+crate::naive::internals::Of::to_mdf(p0);
+<naive::internals::Of>::to_mdf(p0);
-----------------
src/naive/internals.rs naive::internals::Of::succ
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.succ();
+naive::internals::Of::succ(p0);
+crate::naive::internals::Of::succ(p0);
+<naive::internals::Of>::succ(p0);
-----------------
src/naive/internals.rs naive::internals::Of::pred
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
+p0.pred();
+naive::internals::Of::pred(p0);
+crate::naive::internals::Of::pred(p0);
+<naive::internals::Of>::pred(p0);
-----------------
src/naive/internals.rs <naive::internals::Of as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Of
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::internals::Of as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::internals::Of as std::fmt::Debug>::fmt(p0, p1);
+<naive::internals::Of>::fmt(p0, p1);
-----------------
src/naive/internals.rs <naive::internals::Mdf as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
+p0.eq(p1);
+<naive::internals::Mdf as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::internals::Mdf as std::cmp::PartialEq>::eq(p0, p1);
+<naive::internals::Mdf>::eq(p0, p1);
-----------------
src/naive/internals.rs <naive::internals::Mdf as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
+p0.partial_cmp(p1);
+<naive::internals::Mdf as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<naive::internals::Mdf as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<naive::internals::Mdf>::partial_cmp(p0, p1);
-----------------
src/naive/internals.rs <naive::internals::Mdf as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
+p0.clone();
+<naive::internals::Mdf as std::clone::Clone>::clone(p0);
+crate::<naive::internals::Mdf as std::clone::Clone>::clone(p0);
+<naive::internals::Mdf>::clone(p0);
-----------------
src/naive/internals.rs naive::internals::Mdf::new
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
+naive::internals::Mdf::new(p0, p1, p2);
+crate::naive::internals::Mdf::new(p0, p1, p2);
+<naive::internals::Mdf>::new(p0, p1, p2);
-----------------
src/naive/internals.rs naive::internals::Mdf::from_of
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::internals::Of
+naive::internals::Mdf::from_of(p0);
+crate::naive::internals::Mdf::from_of(p0);
+<naive::internals::Mdf>::from_of(p0);
-----------------
src/naive/internals.rs naive::internals::Mdf::month
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
+p0.month();
+naive::internals::Mdf::month(p0);
+crate::naive::internals::Mdf::month(p0);
+<naive::internals::Mdf>::month(p0);
-----------------
src/naive/internals.rs naive::internals::Mdf::with_month
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
let mut p1 = 0u32; // None+u32
+p0.with_month(p1);
+naive::internals::Mdf::with_month(p0, p1);
+crate::naive::internals::Mdf::with_month(p0, p1);
+<naive::internals::Mdf>::with_month(p0, p1);
-----------------
src/naive/internals.rs naive::internals::Mdf::day
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
+p0.day();
+naive::internals::Mdf::day(p0);
+crate::naive::internals::Mdf::day(p0);
+<naive::internals::Mdf>::day(p0);
-----------------
src/naive/internals.rs naive::internals::Mdf::with_day
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
let mut p1 = 0u32; // None+u32
+p0.with_day(p1);
+naive::internals::Mdf::with_day(p0, p1);
+crate::naive::internals::Mdf::with_day(p0, p1);
+<naive::internals::Mdf>::with_day(p0, p1);
-----------------
src/naive/internals.rs naive::internals::Mdf::with_flags
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::internals::YearFlags
+p0.with_flags(p1);
+naive::internals::Mdf::with_flags(p0, p1);
+crate::naive::internals::Mdf::with_flags(p0, p1);
+<naive::internals::Mdf>::with_flags(p0, p1);
-----------------
src/naive/internals.rs naive::internals::Mdf::to_of
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
+p0.to_of();
+naive::internals::Mdf::to_of(p0);
+crate::naive::internals::Mdf::to_of(p0);
+<naive::internals::Mdf>::to_of(p0);
-----------------
src/naive/internals.rs <naive::internals::Mdf as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::internals::Mdf
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::internals::Mdf as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::internals::Mdf as std::fmt::Debug>::fmt(p0, p1);
+<naive::internals::Mdf>::fmt(p0, p1);
-----------------
src/naive/isoweek.rs <naive::isoweek::IsoWeek as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
+p0.eq(p1);
+<naive::isoweek::IsoWeek as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::isoweek::IsoWeek as std::cmp::PartialEq>::eq(p0, p1);
+<naive::isoweek::IsoWeek>::eq(p0, p1);
-----------------
src/naive/isoweek.rs <naive::isoweek::IsoWeek as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
+p0.assert_receiver_is_total_eq();
+<naive::isoweek::IsoWeek as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<naive::isoweek::IsoWeek as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<naive::isoweek::IsoWeek>::assert_receiver_is_total_eq(p0);
-----------------
src/naive/isoweek.rs <naive::isoweek::IsoWeek as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
+p0.partial_cmp(p1);
+<naive::isoweek::IsoWeek as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<naive::isoweek::IsoWeek as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<naive::isoweek::IsoWeek>::partial_cmp(p0, p1);
-----------------
src/naive/isoweek.rs <naive::isoweek::IsoWeek as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
+p0.cmp(p1);
+<naive::isoweek::IsoWeek as std::cmp::Ord>::cmp(p0, p1);
+crate::<naive::isoweek::IsoWeek as std::cmp::Ord>::cmp(p0, p1);
+<naive::isoweek::IsoWeek>::cmp(p0, p1);
-----------------
src/naive/isoweek.rs <naive::isoweek::IsoWeek as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
+p0.clone();
+<naive::isoweek::IsoWeek as std::clone::Clone>::clone(p0);
+crate::<naive::isoweek::IsoWeek as std::clone::Clone>::clone(p0);
+<naive::isoweek::IsoWeek>::clone(p0);
-----------------
src/naive/isoweek.rs <naive::isoweek::IsoWeek as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<naive::isoweek::IsoWeek as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<naive::isoweek::IsoWeek as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<naive::isoweek::IsoWeek as std::hash::Hash>::hash(p0, p1);
+crate::<naive::isoweek::IsoWeek as std::hash::Hash>::hash(p0, p1);
+<naive::isoweek::IsoWeek>::hash(p0, p1);
-----------------
src/naive/isoweek.rs naive::isoweek::IsoWeek::year
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
+p0.year();
+naive::isoweek::IsoWeek::year(p0);
+crate::naive::isoweek::IsoWeek::year(p0);
+<naive::isoweek::IsoWeek>::year(p0);
-----------------
src/naive/isoweek.rs naive::isoweek::IsoWeek::week
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
+p0.week();
+naive::isoweek::IsoWeek::week(p0);
+crate::naive::isoweek::IsoWeek::week(p0);
+<naive::isoweek::IsoWeek>::week(p0);
-----------------
src/naive/isoweek.rs naive::isoweek::IsoWeek::week0
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
+p0.week0();
+naive::isoweek::IsoWeek::week0(p0);
+crate::naive::isoweek::IsoWeek::week0(p0);
+<naive::isoweek::IsoWeek>::week0(p0);
-----------------
src/naive/isoweek.rs <naive::isoweek::IsoWeek as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::isoweek::IsoWeek
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::isoweek::IsoWeek as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::isoweek::IsoWeek as std::fmt::Debug>::fmt(p0, p1);
+<naive::isoweek::IsoWeek>::fmt(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.eq(p1);
+<naive::time::NaiveTime as std::cmp::PartialEq>::eq(p0, p1);
+crate::<naive::time::NaiveTime as std::cmp::PartialEq>::eq(p0, p1);
+<naive::time::NaiveTime>::eq(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.assert_receiver_is_total_eq();
+<naive::time::NaiveTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<naive::time::NaiveTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<naive::time::NaiveTime>::assert_receiver_is_total_eq(p0);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<naive::time::NaiveTime as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<naive::time::NaiveTime as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<naive::time::NaiveTime as std::hash::Hash>::hash(p0, p1);
+crate::<naive::time::NaiveTime as std::hash::Hash>::hash(p0, p1);
+<naive::time::NaiveTime>::hash(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.partial_cmp(p1);
+<naive::time::NaiveTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<naive::time::NaiveTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<naive::time::NaiveTime>::partial_cmp(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.cmp(p1);
+<naive::time::NaiveTime as std::cmp::Ord>::cmp(p0, p1);
+crate::<naive::time::NaiveTime as std::cmp::Ord>::cmp(p0, p1);
+<naive::time::NaiveTime>::cmp(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.clone();
+<naive::time::NaiveTime as std::clone::Clone>::clone(p0);
+crate::<naive::time::NaiveTime as std::clone::Clone>::clone(p0);
+<naive::time::NaiveTime>::clone(p0);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_hms
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+naive::time::NaiveTime::from_hms(p0, p1, p2);
+crate::naive::time::NaiveTime::from_hms(p0, p1, p2);
+<naive::time::NaiveTime>::from_hms(p0, p1, p2);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_hms_opt
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+naive::time::NaiveTime::from_hms_opt(p0, p1, p2);
+crate::naive::time::NaiveTime::from_hms_opt(p0, p1, p2);
+<naive::time::NaiveTime>::from_hms_opt(p0, p1, p2);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_hms_milli
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+naive::time::NaiveTime::from_hms_milli(p0, p1, p2, p3);
+crate::naive::time::NaiveTime::from_hms_milli(p0, p1, p2, p3);
+<naive::time::NaiveTime>::from_hms_milli(p0, p1, p2, p3);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_hms_milli_opt
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+naive::time::NaiveTime::from_hms_milli_opt(p0, p1, p2, p3);
+crate::naive::time::NaiveTime::from_hms_milli_opt(p0, p1, p2, p3);
+<naive::time::NaiveTime>::from_hms_milli_opt(p0, p1, p2, p3);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_hms_micro
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+naive::time::NaiveTime::from_hms_micro(p0, p1, p2, p3);
+crate::naive::time::NaiveTime::from_hms_micro(p0, p1, p2, p3);
+<naive::time::NaiveTime>::from_hms_micro(p0, p1, p2, p3);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_hms_micro_opt
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+naive::time::NaiveTime::from_hms_micro_opt(p0, p1, p2, p3);
+crate::naive::time::NaiveTime::from_hms_micro_opt(p0, p1, p2, p3);
+<naive::time::NaiveTime>::from_hms_micro_opt(p0, p1, p2, p3);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_hms_nano
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+naive::time::NaiveTime::from_hms_nano(p0, p1, p2, p3);
+crate::naive::time::NaiveTime::from_hms_nano(p0, p1, p2, p3);
+<naive::time::NaiveTime>::from_hms_nano(p0, p1, p2, p3);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_hms_nano_opt
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+naive::time::NaiveTime::from_hms_nano_opt(p0, p1, p2, p3);
+crate::naive::time::NaiveTime::from_hms_nano_opt(p0, p1, p2, p3);
+<naive::time::NaiveTime>::from_hms_nano_opt(p0, p1, p2, p3);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_num_seconds_from_midnight
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+naive::time::NaiveTime::from_num_seconds_from_midnight(p0, p1);
+crate::naive::time::NaiveTime::from_num_seconds_from_midnight(p0, p1);
+<naive::time::NaiveTime>::from_num_seconds_from_midnight(p0, p1);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::from_num_seconds_from_midnight_opt
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = 0u32; // None+u32
+naive::time::NaiveTime::from_num_seconds_from_midnight_opt(p0, p1);
+crate::naive::time::NaiveTime::from_num_seconds_from_midnight_opt(p0, p1);
+<naive::time::NaiveTime>::from_num_seconds_from_midnight_opt(p0, p1);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::parse_from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = "sample"; // None+&str
+naive::time::NaiveTime::parse_from_str(&p0, &p1);
+crate::naive::time::NaiveTime::parse_from_str(&p0, &p1);
+<naive::time::NaiveTime>::parse_from_str(&p0, &p1);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::overflowing_add_signed
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.overflowing_add_signed(p1);
+naive::time::NaiveTime::overflowing_add_signed(p0, p1);
+crate::naive::time::NaiveTime::overflowing_add_signed(p0, p1);
+<naive::time::NaiveTime>::overflowing_add_signed(p0, p1);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::overflowing_sub_signed
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.overflowing_sub_signed(p1);
+naive::time::NaiveTime::overflowing_sub_signed(p0, p1);
+crate::naive::time::NaiveTime::overflowing_sub_signed(p0, p1);
+<naive::time::NaiveTime>::overflowing_sub_signed(p0, p1);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::signed_duration_since
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.signed_duration_since(p1);
+naive::time::NaiveTime::signed_duration_since(p0, p1);
+crate::naive::time::NaiveTime::signed_duration_since(p0, p1);
+<naive::time::NaiveTime>::signed_duration_since(p0, p1);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::format_with_items
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"naive::time::NaiveTime::format_with_items":{"B":["std::marker::Sized","std::borrow::Borrow"],"I":["std::iter::Iterator","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"naive::time::NaiveTime::format_with_items":{"B":["<&T as std::borrow::Borrow<T>>","std::ffi::OsString","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::string::String","std::ffi::CString","std::boxed::Box<T, A>","std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf"],"I":["naive::date::NaiveDateWeeksIterator","format::strftime::StrftimeItems","naive::date::NaiveDateDaysIterator"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.format_with_items(p1);
+naive::time::NaiveTime::format_with_items(p0, p1);
+crate::naive::time::NaiveTime::format_with_items(p0, p1);
+<naive::time::NaiveTime>::format_with_items(p0, p1);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::format
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = "sample"; // None+&str
+p0.format(&p1);
+naive::time::NaiveTime::format(p0, &p1);
+crate::naive::time::NaiveTime::format(p0, &p1);
+<naive::time::NaiveTime>::format(p0, &p1);
-----------------
src/naive/time/mod.rs naive::time::NaiveTime::hms
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.hms();
+naive::time::NaiveTime::hms(p0);
+crate::naive::time::NaiveTime::hms(p0);
+<naive::time::NaiveTime>::hms(p0);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as traits::Timelike>::hour
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.hour();
+<naive::time::NaiveTime as traits::Timelike>::hour(p0);
+crate::<naive::time::NaiveTime as traits::Timelike>::hour(p0);
+<naive::time::NaiveTime>::hour(p0);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as traits::Timelike>::minute
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.minute();
+<naive::time::NaiveTime as traits::Timelike>::minute(p0);
+crate::<naive::time::NaiveTime as traits::Timelike>::minute(p0);
+<naive::time::NaiveTime>::minute(p0);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as traits::Timelike>::second
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.second();
+<naive::time::NaiveTime as traits::Timelike>::second(p0);
+crate::<naive::time::NaiveTime as traits::Timelike>::second(p0);
+<naive::time::NaiveTime>::second(p0);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as traits::Timelike>::nanosecond
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.nanosecond();
+<naive::time::NaiveTime as traits::Timelike>::nanosecond(p0);
+crate::<naive::time::NaiveTime as traits::Timelike>::nanosecond(p0);
+<naive::time::NaiveTime>::nanosecond(p0);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as traits::Timelike>::with_hour
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = 0u32; // None+u32
+p0.with_hour(p1);
+<naive::time::NaiveTime as traits::Timelike>::with_hour(p0, p1);
+crate::<naive::time::NaiveTime as traits::Timelike>::with_hour(p0, p1);
+<naive::time::NaiveTime>::with_hour(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as traits::Timelike>::with_minute
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = 0u32; // None+u32
+p0.with_minute(p1);
+<naive::time::NaiveTime as traits::Timelike>::with_minute(p0, p1);
+crate::<naive::time::NaiveTime as traits::Timelike>::with_minute(p0, p1);
+<naive::time::NaiveTime>::with_minute(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as traits::Timelike>::with_second
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = 0u32; // None+u32
+p0.with_second(p1);
+<naive::time::NaiveTime as traits::Timelike>::with_second(p0, p1);
+crate::<naive::time::NaiveTime as traits::Timelike>::with_second(p0, p1);
+<naive::time::NaiveTime>::with_second(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as traits::Timelike>::with_nanosecond
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = 0u32; // None+u32
+p0.with_nanosecond(p1);
+<naive::time::NaiveTime as traits::Timelike>::with_nanosecond(p0, p1);
+crate::<naive::time::NaiveTime as traits::Timelike>::with_nanosecond(p0, p1);
+<naive::time::NaiveTime>::with_nanosecond(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as traits::Timelike>::num_seconds_from_midnight
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.num_seconds_from_midnight();
+<naive::time::NaiveTime as traits::Timelike>::num_seconds_from_midnight(p0);
+crate::<naive::time::NaiveTime as traits::Timelike>::num_seconds_from_midnight(p0);
+<naive::time::NaiveTime>::num_seconds_from_midnight(p0);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::ops::Add<time_delta::TimeDelta>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add(p1);
+<naive::time::NaiveTime as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+crate::<naive::time::NaiveTime as std::ops::Add<time_delta::TimeDelta>>::add(p0, p1);
+<naive::time::NaiveTime>::add(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.add_assign(p1);
+<naive::time::NaiveTime as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+crate::<naive::time::NaiveTime as std::ops::AddAssign<time_delta::TimeDelta>>::add_assign(p0, p1);
+<naive::time::NaiveTime>::add_assign(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::ops::Sub<time_delta::TimeDelta>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub(p1);
+<naive::time::NaiveTime as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+crate::<naive::time::NaiveTime as std::ops::Sub<time_delta::TimeDelta>>::sub(p0, p1);
+<naive::time::NaiveTime>::sub(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.sub_assign(p1);
+<naive::time::NaiveTime as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+crate::<naive::time::NaiveTime as std::ops::SubAssign<time_delta::TimeDelta>>::sub_assign(p0, p1);
+<naive::time::NaiveTime>::sub_assign(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.sub(p1);
+<naive::time::NaiveTime as std::ops::Sub>::sub(p0, p1);
+crate::<naive::time::NaiveTime as std::ops::Sub>::sub(p0, p1);
+<naive::time::NaiveTime>::sub(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<naive::time::NaiveTime as std::fmt::Debug>::fmt(p0, p1);
+crate::<naive::time::NaiveTime as std::fmt::Debug>::fmt(p0, p1);
+<naive::time::NaiveTime>::fmt(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<naive::time::NaiveTime as std::fmt::Display>::fmt(p0, p1);
+crate::<naive::time::NaiveTime as std::fmt::Display>::fmt(p0, p1);
+<naive::time::NaiveTime>::fmt(p0, p1);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<naive::time::NaiveTime as std::str::FromStr>::from_str(&p0);
+crate::<naive::time::NaiveTime as std::str::FromStr>::from_str(&p0);
+<naive::time::NaiveTime>::from_str(&p0);
-----------------
src/naive/time/mod.rs <naive::time::NaiveTime as std::default::Default>::default
deps:{}
candidates:{}
+<naive::time::NaiveTime as std::default::Default>::default();
+crate::<naive::time::NaiveTime as std::default::Default>::default();
+<naive::time::NaiveTime>::default();
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.eq(p1);
+<offset::fixed::FixedOffset as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::fixed::FixedOffset as std::cmp::PartialEq>::eq(p0, p1);
+<offset::fixed::FixedOffset>::eq(p0, p1);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.assert_receiver_is_total_eq();
+<offset::fixed::FixedOffset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::fixed::FixedOffset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::fixed::FixedOffset>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<offset::fixed::FixedOffset as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<offset::fixed::FixedOffset as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<offset::fixed::FixedOffset as std::hash::Hash>::hash(p0, p1);
+crate::<offset::fixed::FixedOffset as std::hash::Hash>::hash(p0, p1);
+<offset::fixed::FixedOffset>::hash(p0, p1);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.clone();
+<offset::fixed::FixedOffset as std::clone::Clone>::clone(p0);
+crate::<offset::fixed::FixedOffset as std::clone::Clone>::clone(p0);
+<offset::fixed::FixedOffset>::clone(p0);
-----------------
src/offset/fixed.rs offset::fixed::FixedOffset::east
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+offset::fixed::FixedOffset::east(p0);
+crate::offset::fixed::FixedOffset::east(p0);
+<offset::fixed::FixedOffset>::east(p0);
-----------------
src/offset/fixed.rs offset::fixed::FixedOffset::east_opt
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+offset::fixed::FixedOffset::east_opt(p0);
+crate::offset::fixed::FixedOffset::east_opt(p0);
+<offset::fixed::FixedOffset>::east_opt(p0);
-----------------
src/offset/fixed.rs offset::fixed::FixedOffset::west
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+offset::fixed::FixedOffset::west(p0);
+crate::offset::fixed::FixedOffset::west(p0);
+<offset::fixed::FixedOffset>::west(p0);
-----------------
src/offset/fixed.rs offset::fixed::FixedOffset::west_opt
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+offset::fixed::FixedOffset::west_opt(p0);
+crate::offset::fixed::FixedOffset::west_opt(p0);
+<offset::fixed::FixedOffset>::west_opt(p0);
-----------------
src/offset/fixed.rs offset::fixed::FixedOffset::local_minus_utc
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.local_minus_utc();
+offset::fixed::FixedOffset::local_minus_utc(p0);
+crate::offset::fixed::FixedOffset::local_minus_utc(p0);
+<offset::fixed::FixedOffset>::local_minus_utc(p0);
-----------------
src/offset/fixed.rs offset::fixed::FixedOffset::utc_minus_local
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.utc_minus_local();
+offset::fixed::FixedOffset::utc_minus_local(p0);
+crate::offset::fixed::FixedOffset::utc_minus_local(p0);
+<offset::fixed::FixedOffset>::utc_minus_local(p0);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as offset::TimeZone>::from_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+<offset::fixed::FixedOffset as offset::TimeZone>::from_offset(p0);
+crate::<offset::fixed::FixedOffset as offset::TimeZone>::from_offset(p0);
+<offset::fixed::FixedOffset>::from_offset(p0);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.offset_from_local_date(p1);
+<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_date(p0, p1);
+crate::<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_date(p0, p1);
+<offset::fixed::FixedOffset>::offset_from_local_date(p0, p1);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.offset_from_local_datetime(p1);
+<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_datetime(p0, p1);
+crate::<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_datetime(p0, p1);
+<offset::fixed::FixedOffset>::offset_from_local_datetime(p0, p1);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.offset_from_utc_date(p1);
+<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_date(p0, p1);
+crate::<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_date(p0, p1);
+<offset::fixed::FixedOffset>::offset_from_utc_date(p0, p1);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.offset_from_utc_datetime(p1);
+<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_datetime(p0, p1);
+crate::<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_datetime(p0, p1);
+<offset::fixed::FixedOffset>::offset_from_utc_datetime(p0, p1);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as offset::Offset>::fix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.fix();
+<offset::fixed::FixedOffset as offset::Offset>::fix(p0);
+crate::<offset::fixed::FixedOffset as offset::Offset>::fix(p0);
+<offset::fixed::FixedOffset>::fix(p0);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::fixed::FixedOffset as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::fixed::FixedOffset as std::fmt::Debug>::fmt(p0, p1);
+<offset::fixed::FixedOffset>::fmt(p0, p1);
-----------------
src/offset/fixed.rs <offset::fixed::FixedOffset as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<offset::fixed::FixedOffset as std::fmt::Display>::fmt(p0, p1);
+crate::<offset::fixed::FixedOffset as std::fmt::Display>::fmt(p0, p1);
+<offset::fixed::FixedOffset>::fmt(p0, p1);
-----------------
src/offset/fixed.rs offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::time::NaiveTime>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.add(p1);
+offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::time::NaiveTime>::add(p0, p1);
+crate::offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::time::NaiveTime>::add(p0, p1);
+<naive::time::NaiveTime>::add(p0, p1);
-----------------
src/offset/fixed.rs offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::time::NaiveTime>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
let mut p1 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.sub(p1);
+offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::time::NaiveTime>::sub(p0, p1);
+crate::offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::time::NaiveTime>::sub(p0, p1);
+<naive::time::NaiveTime>::sub(p0, p1);
-----------------
src/offset/fixed.rs offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.add(p1);
+offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::add(p0, p1);
+crate::offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::add(p0, p1);
+<naive::datetime::NaiveDateTime>::add(p0, p1);
-----------------
src/offset/fixed.rs offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.sub(p1);
+offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::sub(p0, p1);
+crate::offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::sub(p0, p1);
+<naive::datetime::NaiveDateTime>::sub(p0, p1);
-----------------
src/offset/fixed.rs offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::add
deps:{"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::add":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::add":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.add(p1);
+offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::add(p0, p1);
+crate::offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::add(p0, p1);
+<datetime::DateTime<Tz>>::add(p0, p1);
-----------------
src/offset/fixed.rs offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::sub
deps:{"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::sub":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::sub":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+p0.sub(p1);
+offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::sub(p0, p1);
+crate::offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::sub(p0, p1);
+<datetime::DateTime<Tz>>::sub(p0, p1);
-----------------
src/offset/local/unix.rs offset::local::inner::Source::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
+offset::local::inner::Source::new(p0);
+crate::offset::local::inner::Source::new(p0);
+<offset::local::inner::Source>::new(p0);
-----------------
src/offset/local/unix.rs <offset::local::inner::Cache as std::default::Default>::default
deps:{}
candidates:{}
+<offset::local::inner::Cache as std::default::Default>::default();
+crate::<offset::local::inner::Cache as std::default::Default>::default();
+<offset::local::inner::Cache>::default();
-----------------
src/offset/local/unix.rs offset::local::inner::Cache::offset
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::inner::Cache
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p2 = true; // None+bool
+p0.offset(p1, p2);
+offset::local::inner::Cache::offset(p0, p1, p2);
+crate::offset::local::inner::Cache::offset(p0, p1, p2);
+<offset::local::inner::Cache>::offset(p0, p1, p2);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZone as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZone
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::timezone::TimeZone as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::timezone::TimeZone as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::timezone::TimeZone>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZone as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZone
+p0.clone();
+<offset::local::tz_info::timezone::TimeZone as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::timezone::TimeZone as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::timezone::TimeZone>::clone(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZone as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZone
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::timezone::TimeZone as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::timezone::TimeZone as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::timezone::TimeZone>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZone as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZone
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZone
+p0.eq(p1);
+<offset::local::tz_info::timezone::TimeZone as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::timezone::TimeZone as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::timezone::TimeZone>::eq(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::local
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
+offset::local::tz_info::timezone::TimeZone::local(p0);
+crate::offset::local::tz_info::timezone::TimeZone::local(p0);
+<offset::local::tz_info::timezone::TimeZone>::local(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::from_posix_tz
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+offset::local::tz_info::timezone::TimeZone::from_posix_tz(&p0);
+crate::offset::local::tz_info::timezone::TimeZone::from_posix_tz(&p0);
+<offset::local::tz_info::timezone::TimeZone>::from_posix_tz(&p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<offset::local::tz_info::timezone::Transition>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<offset::local::tz_info::timezone::LocalTimeType>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<offset::local::tz_info::timezone::LeapSecond>
let mut p3 = MaybeUninit::uninit().assume_init(); // std::option::Option<offset::local::tz_info::rule::TransitionRule>
+offset::local::tz_info::timezone::TimeZone::new(p0, p1, p2, p3);
+crate::offset::local::tz_info::timezone::TimeZone::new(p0, p1, p2, p3);
+<offset::local::tz_info::timezone::TimeZone>::new(p0, p1, p2, p3);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::from_file
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::fs::File
+offset::local::tz_info::timezone::TimeZone::from_file(p0);
+crate::offset::local::tz_info::timezone::TimeZone::from_file(p0);
+<offset::local::tz_info::timezone::TimeZone>::from_file(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::from_tz_data
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+offset::local::tz_info::timezone::TimeZone::from_tz_data(p0);
+crate::offset::local::tz_info::timezone::TimeZone::from_tz_data(p0);
+<offset::local::tz_info::timezone::TimeZone>::from_tz_data(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::fixed
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+offset::local::tz_info::timezone::TimeZone::fixed(p0);
+crate::offset::local::tz_info::timezone::TimeZone::fixed(p0);
+<offset::local::tz_info::timezone::TimeZone>::fixed(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::utc
deps:{}
candidates:{}
+offset::local::tz_info::timezone::TimeZone::utc();
+crate::offset::local::tz_info::timezone::TimeZone::utc();
+<offset::local::tz_info::timezone::TimeZone>::utc();
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::find_local_time_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZone
let mut p1 = 0i64; // None+i64
+p0.find_local_time_type(p1);
+offset::local::tz_info::timezone::TimeZone::find_local_time_type(p0, p1);
+crate::offset::local::tz_info::timezone::TimeZone::find_local_time_type(p0, p1);
+<offset::local::tz_info::timezone::TimeZone>::find_local_time_type(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::find_local_time_type_from_local
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZone
let mut p1 = 0i64; // None+i64
let mut p2 = 0i32; // None+i32
+p0.find_local_time_type_from_local(p1, p2);
+offset::local::tz_info::timezone::TimeZone::find_local_time_type_from_local(p0, p1, p2);
+crate::offset::local::tz_info::timezone::TimeZone::find_local_time_type_from_local(p0, p1, p2);
+<offset::local::tz_info::timezone::TimeZone>::find_local_time_type_from_local(p0, p1, p2);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZone::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZone
+p0.as_ref();
+offset::local::tz_info::timezone::TimeZone::as_ref(p0);
+crate::offset::local::tz_info::timezone::TimeZone::as_ref(p0);
+<offset::local::tz_info::timezone::TimeZone>::as_ref(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZoneRef<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::timezone::TimeZoneRef<'a>>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZoneRef<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
+p0.clone();
+<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::timezone::TimeZoneRef<'a>>::clone(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZoneRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::timezone::TimeZoneRef<'a>>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZoneRef<'a> as std::cmp::PartialEq>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
+p0.eq(p1);
+<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::timezone::TimeZoneRef<'a>>::eq(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
let mut p1 = 0i64; // None+i64
+p0.find_local_time_type(p1);
+offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type(p0, p1);
+crate::offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type(p0, p1);
+<offset::local::tz_info::timezone::TimeZoneRef<'a>>::find_local_time_type(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type_from_local
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
let mut p1 = 0i64; // None+i64
let mut p2 = 0i32; // None+i32
+p0.find_local_time_type_from_local(p1, p2);
+offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type_from_local(p0, p1, p2);
+crate::offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type_from_local(p0, p1, p2);
+<offset::local::tz_info::timezone::TimeZoneRef<'a>>::find_local_time_type_from_local(p0, p1, p2);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZoneRef::<'a>::validate
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
+p0.validate();
+offset::local::tz_info::timezone::TimeZoneRef::<'a>::validate(p0);
+crate::offset::local::tz_info::timezone::TimeZoneRef::<'a>::validate(p0);
+<offset::local::tz_info::timezone::TimeZoneRef<'a>>::validate(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_time_to_unix_leap_time
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
let mut p1 = 0i64; // None+i64
+p0.unix_time_to_unix_leap_time(p1);
+offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_time_to_unix_leap_time(p0, p1);
+crate::offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_time_to_unix_leap_time(p0, p1);
+<offset::local::tz_info::timezone::TimeZoneRef<'a>>::unix_time_to_unix_leap_time(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_leap_time_to_unix_time
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneRef<'a>
let mut p1 = 0i64; // None+i64
+p0.unix_leap_time_to_unix_time(p1);
+offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_leap_time_to_unix_time(p0, p1);
+crate::offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_leap_time_to_unix_time(p0, p1);
+<offset::local::tz_info::timezone::TimeZoneRef<'a>>::unix_leap_time_to_unix_time(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::Transition as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::Transition
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::timezone::Transition as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::timezone::Transition as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::timezone::Transition>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::Transition as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::Transition
+p0.clone();
+<offset::local::tz_info::timezone::Transition as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::timezone::Transition as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::timezone::Transition>::clone(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::Transition as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::Transition
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::timezone::Transition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::timezone::Transition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::timezone::Transition>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::Transition as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::Transition
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::Transition
+p0.eq(p1);
+<offset::local::tz_info::timezone::Transition as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::timezone::Transition as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::timezone::Transition>::eq(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::Transition::new
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0usize; // None+usize
+offset::local::tz_info::timezone::Transition::new(p0, p1);
+crate::offset::local::tz_info::timezone::Transition::new(p0, p1);
+<offset::local::tz_info::timezone::Transition>::new(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::Transition::unix_leap_time
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::Transition
+p0.unix_leap_time();
+offset::local::tz_info::timezone::Transition::unix_leap_time(p0);
+crate::offset::local::tz_info::timezone::Transition::unix_leap_time(p0);
+<offset::local::tz_info::timezone::Transition>::unix_leap_time(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::LeapSecond as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LeapSecond
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::timezone::LeapSecond as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::timezone::LeapSecond as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::timezone::LeapSecond>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::LeapSecond as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LeapSecond
+p0.clone();
+<offset::local::tz_info::timezone::LeapSecond as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::timezone::LeapSecond as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::timezone::LeapSecond>::clone(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::LeapSecond as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LeapSecond
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::timezone::LeapSecond as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::timezone::LeapSecond as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::timezone::LeapSecond>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::LeapSecond as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LeapSecond
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LeapSecond
+p0.eq(p1);
+<offset::local::tz_info::timezone::LeapSecond as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::timezone::LeapSecond as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::timezone::LeapSecond>::eq(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::LeapSecond::new
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0i32; // None+i32
+offset::local::tz_info::timezone::LeapSecond::new(p0, p1);
+crate::offset::local::tz_info::timezone::LeapSecond::new(p0, p1);
+<offset::local::tz_info::timezone::LeapSecond>::new(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::LeapSecond::unix_leap_time
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LeapSecond
+p0.unix_leap_time();
+offset::local::tz_info::timezone::LeapSecond::unix_leap_time(p0);
+crate::offset::local::tz_info::timezone::LeapSecond::unix_leap_time(p0);
+<offset::local::tz_info::timezone::LeapSecond>::unix_leap_time(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZoneName as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneName
+p0.clone();
+<offset::local::tz_info::timezone::TimeZoneName as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::timezone::TimeZoneName as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::timezone::TimeZoneName>::clone(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZoneName as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneName
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::timezone::TimeZoneName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::timezone::TimeZoneName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::timezone::TimeZoneName>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZoneName as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneName
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneName
+p0.eq(p1);
+<offset::local::tz_info::timezone::TimeZoneName as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::timezone::TimeZoneName as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::timezone::TimeZoneName>::eq(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZoneName::new
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+offset::local::tz_info::timezone::TimeZoneName::new(p0);
+crate::offset::local::tz_info::timezone::TimeZoneName::new(p0);
+<offset::local::tz_info::timezone::TimeZoneName>::new(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZoneName::as_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneName
+p0.as_bytes();
+offset::local::tz_info::timezone::TimeZoneName::as_bytes(p0);
+crate::offset::local::tz_info::timezone::TimeZoneName::as_bytes(p0);
+<offset::local::tz_info::timezone::TimeZoneName>::as_bytes(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::TimeZoneName::equal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneName
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneName
+p0.equal(p1);
+offset::local::tz_info::timezone::TimeZoneName::equal(p0, p1);
+crate::offset::local::tz_info::timezone::TimeZoneName::equal(p0, p1);
+<offset::local::tz_info::timezone::TimeZoneName>::equal(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZoneName as std::convert::AsRef<str>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneName
+p0.as_ref();
+<offset::local::tz_info::timezone::TimeZoneName as std::convert::AsRef<str>>::as_ref(p0);
+crate::<offset::local::tz_info::timezone::TimeZoneName as std::convert::AsRef<str>>::as_ref(p0);
+<offset::local::tz_info::timezone::TimeZoneName>::as_ref(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::TimeZoneName as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::TimeZoneName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::timezone::TimeZoneName as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::timezone::TimeZoneName as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::timezone::TimeZoneName>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::LocalTimeType as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::timezone::LocalTimeType as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::timezone::LocalTimeType as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::timezone::LocalTimeType>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::LocalTimeType as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
+p0.clone();
+<offset::local::tz_info::timezone::LocalTimeType as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::timezone::LocalTimeType as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::timezone::LocalTimeType>::clone(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::LocalTimeType as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::timezone::LocalTimeType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::timezone::LocalTimeType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::timezone::LocalTimeType>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/timezone.rs <offset::local::tz_info::timezone::LocalTimeType as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
+p0.eq(p1);
+<offset::local::tz_info::timezone::LocalTimeType as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::timezone::LocalTimeType as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::timezone::LocalTimeType>::eq(p0, p1);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::LocalTimeType::new
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = true; // None+bool
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&[u8]>
+offset::local::tz_info::timezone::LocalTimeType::new(p0, p1, p2);
+crate::offset::local::tz_info::timezone::LocalTimeType::new(p0, p1, p2);
+<offset::local::tz_info::timezone::LocalTimeType>::new(p0, p1, p2);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::LocalTimeType::with_offset
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+offset::local::tz_info::timezone::LocalTimeType::with_offset(p0);
+crate::offset::local::tz_info::timezone::LocalTimeType::with_offset(p0);
+<offset::local::tz_info::timezone::LocalTimeType>::with_offset(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::LocalTimeType::offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
+p0.offset();
+offset::local::tz_info::timezone::LocalTimeType::offset(p0);
+crate::offset::local::tz_info::timezone::LocalTimeType::offset(p0);
+<offset::local::tz_info::timezone::LocalTimeType>::offset(p0);
-----------------
src/offset/local/tz_info/timezone.rs offset::local::tz_info::timezone::LocalTimeType::is_dst
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
+p0.is_dst();
+offset::local::tz_info::timezone::LocalTimeType::is_dst(p0);
+crate::offset::local::tz_info::timezone::LocalTimeType::is_dst(p0);
+<offset::local::tz_info::timezone::LocalTimeType>::is_dst(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::State::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
let mut p1 = true; // None+bool
+offset::local::tz_info::parser::State::<'a>::new(p0, p1);
+crate::offset::local::tz_info::parser::State::<'a>::new(p0, p1);
+<offset::local::tz_info::parser::State<'a>>::new(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::State::<'a>::parse_time
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::State<'a>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Version
+p0.parse_time(p1, p2);
+offset::local::tz_info::parser::State::<'a>::parse_time(p0, p1, p2);
+crate::offset::local::tz_info::parser::State::<'a>::parse_time(p0, p1, p2);
+<offset::local::tz_info::parser::State<'a>>::parse_time(p0, p1, p2);
-----------------
src/offset/local/tz_info/parser.rs <offset::local::tz_info::parser::Header as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Header
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::parser::Header as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::parser::Header as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::parser::Header>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Header::new
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'_>
+offset::local::tz_info::parser::Header::new(p0);
+crate::offset::local::tz_info::parser::Header::new(p0);
+<offset::local::tz_info::parser::Header>::new(p0);
-----------------
src/offset/local/tz_info/parser.rs <offset::local::tz_info::parser::Cursor<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::parser::Cursor<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::parser::Cursor<'a> as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::parser::Cursor<'a>>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs <offset::local::tz_info::parser::Cursor<'a> as std::cmp::Eq>::assert_receiver_is_total_eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::parser::Cursor<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::parser::Cursor<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::parser::Cursor<'a>>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/parser.rs <offset::local::tz_info::parser::Cursor<'a> as std::cmp::PartialEq>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
+p0.eq(p1);
+<offset::local::tz_info::parser::Cursor<'a> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::parser::Cursor<'a> as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::parser::Cursor<'a>>::eq(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+offset::local::tz_info::parser::Cursor::<'a>::new(p0);
+crate::offset::local::tz_info::parser::Cursor::<'a>::new(p0);
+<offset::local::tz_info::parser::Cursor<'a>>::new(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::peek
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
+p0.peek();
+offset::local::tz_info::parser::Cursor::<'a>::peek(p0);
+crate::offset::local::tz_info::parser::Cursor::<'a>::peek(p0);
+<offset::local::tz_info::parser::Cursor<'a>>::peek(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::remaining
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
+p0.remaining();
+offset::local::tz_info::parser::Cursor::<'a>::remaining(p0);
+crate::offset::local::tz_info::parser::Cursor::<'a>::remaining(p0);
+<offset::local::tz_info::parser::Cursor<'a>>::remaining(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::is_empty
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
+p0.is_empty();
+offset::local::tz_info::parser::Cursor::<'a>::is_empty(p0);
+crate::offset::local::tz_info::parser::Cursor::<'a>::is_empty(p0);
+<offset::local::tz_info::parser::Cursor<'a>>::is_empty(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::read_be_u32
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
+p0.read_be_u32();
+offset::local::tz_info::parser::Cursor::<'a>::read_be_u32(p0);
+crate::offset::local::tz_info::parser::Cursor::<'a>::read_be_u32(p0);
+<offset::local::tz_info::parser::Cursor<'a>>::read_be_u32(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::read_exact
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
let mut p1 = 0usize; // None+usize
+p0.read_exact(p1);
+offset::local::tz_info::parser::Cursor::<'a>::read_exact(p0, p1);
+crate::offset::local::tz_info::parser::Cursor::<'a>::read_exact(p0, p1);
+<offset::local::tz_info::parser::Cursor<'a>>::read_exact(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::read_tag
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.read_tag(p1);
+offset::local::tz_info::parser::Cursor::<'a>::read_tag(p0, p1);
+crate::offset::local::tz_info::parser::Cursor::<'a>::read_tag(p0, p1);
+<offset::local::tz_info::parser::Cursor<'a>>::read_tag(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::read_optional_tag
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.read_optional_tag(p1);
+offset::local::tz_info::parser::Cursor::<'a>::read_optional_tag(p0, p1);
+crate::offset::local::tz_info::parser::Cursor::<'a>::read_optional_tag(p0, p1);
+<offset::local::tz_info::parser::Cursor<'a>>::read_optional_tag(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::read_while
'a
deps:{"offset::local::tz_info::parser::Cursor::<'a>::read_while":{"F":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"offset::local::tz_info::parser::Cursor::<'a>::read_while":{"F":["core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.read_while(p1);
+offset::local::tz_info::parser::Cursor::<'a>::read_while(p0, p1);
+crate::offset::local::tz_info::parser::Cursor::<'a>::read_while(p0, p1);
+<offset::local::tz_info::parser::Cursor<'a>>::read_while(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::read_int
'a
deps:{"datetime::DateTime":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"offset::local::tz_info::parser::Cursor::<'a>::read_int":{"T":["std::marker::Sized","std::str::FromStr"]}}
candidates:{"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"offset::local::tz_info::parser::Cursor::<'a>::read_int":{"T":["weekday::Weekday","datetime::DateTime","month::Month","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
+p0.read_int();
+offset::local::tz_info::parser::Cursor::<'a>::read_int(p0);
+crate::offset::local::tz_info::parser::Cursor::<'a>::read_int(p0);
+<offset::local::tz_info::parser::Cursor<'a>>::read_int(p0);
-----------------
src/offset/local/tz_info/parser.rs offset::local::tz_info::parser::Cursor::<'a>::read_until
'a
deps:{"offset::local::tz_info::parser::Cursor::<'a>::read_until":{"F":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"offset::local::tz_info::parser::Cursor::<'a>::read_until":{"F":["core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.read_until(p1);
+offset::local::tz_info::parser::Cursor::<'a>::read_until(p0, p1);
+crate::offset::local::tz_info::parser::Cursor::<'a>::read_until(p0, p1);
+<offset::local::tz_info::parser::Cursor<'a>>::read_until(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs <offset::local::tz_info::parser::Version as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Version
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::parser::Version as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::parser::Version as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::parser::Version>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/parser.rs <offset::local::tz_info::parser::Version as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Version
+p0.clone();
+<offset::local::tz_info::parser::Version as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::parser::Version as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::parser::Version>::clone(p0);
-----------------
src/offset/local/tz_info/parser.rs <offset::local::tz_info::parser::Version as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Version
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::parser::Version as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::parser::Version as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::parser::Version>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/parser.rs <offset::local::tz_info::parser::Version as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Version
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Version
+p0.eq(p1);
+<offset::local::tz_info::parser::Version as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::parser::Version as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::parser::Version>::eq(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::TransitionRule as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::TransitionRule
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::rule::TransitionRule as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::rule::TransitionRule as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::rule::TransitionRule>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::TransitionRule as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::TransitionRule
+p0.clone();
+<offset::local::tz_info::rule::TransitionRule as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::rule::TransitionRule as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::rule::TransitionRule>::clone(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::TransitionRule as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::TransitionRule
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::rule::TransitionRule as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::rule::TransitionRule as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::rule::TransitionRule>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::TransitionRule as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::TransitionRule
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::TransitionRule
+p0.eq(p1);
+<offset::local::tz_info::rule::TransitionRule as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::rule::TransitionRule as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::rule::TransitionRule>::eq(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::TransitionRule::from_tz_string
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = true; // None+bool
+offset::local::tz_info::rule::TransitionRule::from_tz_string(p0, p1);
+crate::offset::local::tz_info::rule::TransitionRule::from_tz_string(p0, p1);
+<offset::local::tz_info::rule::TransitionRule>::from_tz_string(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::TransitionRule::find_local_time_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::TransitionRule
let mut p1 = 0i64; // None+i64
+p0.find_local_time_type(p1);
+offset::local::tz_info::rule::TransitionRule::find_local_time_type(p0, p1);
+crate::offset::local::tz_info::rule::TransitionRule::find_local_time_type(p0, p1);
+<offset::local::tz_info::rule::TransitionRule>::find_local_time_type(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::TransitionRule::find_local_time_type_from_local
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::TransitionRule
let mut p1 = 0i64; // None+i64
let mut p2 = 0i32; // None+i32
+p0.find_local_time_type_from_local(p1, p2);
+offset::local::tz_info::rule::TransitionRule::find_local_time_type_from_local(p0, p1, p2);
+crate::offset::local::tz_info::rule::TransitionRule::find_local_time_type_from_local(p0, p1, p2);
+<offset::local::tz_info::rule::TransitionRule>::find_local_time_type_from_local(p0, p1, p2);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::timezone::LocalTimeType>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
+<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::timezone::LocalTimeType>>::from(p0);
+crate::<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::timezone::LocalTimeType>>::from(p0);
+<offset::local::tz_info::rule::TransitionRule>::from(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::rule::AlternateTime>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::AlternateTime
+<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::rule::AlternateTime>>::from(p0);
+crate::<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::rule::AlternateTime>>::from(p0);
+<offset::local::tz_info::rule::TransitionRule>::from(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::AlternateTime as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::AlternateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::rule::AlternateTime as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::rule::AlternateTime as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::rule::AlternateTime>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::AlternateTime as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::AlternateTime
+p0.clone();
+<offset::local::tz_info::rule::AlternateTime as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::rule::AlternateTime as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::rule::AlternateTime>::clone(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::AlternateTime as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::AlternateTime
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::rule::AlternateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::rule::AlternateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::rule::AlternateTime>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::AlternateTime as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::AlternateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::AlternateTime
+p0.eq(p1);
+<offset::local::tz_info::rule::AlternateTime as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::rule::AlternateTime as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::rule::AlternateTime>::eq(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::AlternateTime::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
let mut p1 = MaybeUninit::uninit().assume_init(); // offset::local::tz_info::timezone::LocalTimeType
let mut p2 = MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::RuleDay
let mut p3 = 0i32; // None+i32
let mut p4 = MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::RuleDay
let mut p5 = 0i32; // None+i32
+offset::local::tz_info::rule::AlternateTime::new(p0, p1, p2, p3, p4, p5);
+crate::offset::local::tz_info::rule::AlternateTime::new(p0, p1, p2, p3, p4, p5);
+<offset::local::tz_info::rule::AlternateTime>::new(p0, p1, p2, p3, p4, p5);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::AlternateTime::find_local_time_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::AlternateTime
let mut p1 = 0i64; // None+i64
+p0.find_local_time_type(p1);
+offset::local::tz_info::rule::AlternateTime::find_local_time_type(p0, p1);
+crate::offset::local::tz_info::rule::AlternateTime::find_local_time_type(p0, p1);
+<offset::local::tz_info::rule::AlternateTime>::find_local_time_type(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::AlternateTime::find_local_time_type_from_local
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::AlternateTime
let mut p1 = 0i64; // None+i64
let mut p2 = 0i32; // None+i32
+p0.find_local_time_type_from_local(p1, p2);
+offset::local::tz_info::rule::AlternateTime::find_local_time_type_from_local(p0, p1, p2);
+crate::offset::local::tz_info::rule::AlternateTime::find_local_time_type_from_local(p0, p1, p2);
+<offset::local::tz_info::rule::AlternateTime>::find_local_time_type_from_local(p0, p1, p2);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::RuleDay as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::RuleDay
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::rule::RuleDay as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::rule::RuleDay as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::rule::RuleDay>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::RuleDay as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::RuleDay
+p0.clone();
+<offset::local::tz_info::rule::RuleDay as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::rule::RuleDay as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::rule::RuleDay>::clone(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::RuleDay as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::RuleDay
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::rule::RuleDay as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::rule::RuleDay as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::rule::RuleDay>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::RuleDay as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::RuleDay
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::RuleDay
+p0.eq(p1);
+<offset::local::tz_info::rule::RuleDay as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::rule::RuleDay as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::rule::RuleDay>::eq(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::RuleDay::parse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset::local::tz_info::parser::Cursor<'_>
let mut p1 = true; // None+bool
+offset::local::tz_info::rule::RuleDay::parse(p0, p1);
+crate::offset::local::tz_info::rule::RuleDay::parse(p0, p1);
+<offset::local::tz_info::rule::RuleDay>::parse(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::RuleDay::julian_1
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+offset::local::tz_info::rule::RuleDay::julian_1(p0);
+crate::offset::local::tz_info::rule::RuleDay::julian_1(p0);
+<offset::local::tz_info::rule::RuleDay>::julian_1(p0);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::RuleDay::julian_0
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+offset::local::tz_info::rule::RuleDay::julian_0(p0);
+crate::offset::local::tz_info::rule::RuleDay::julian_0(p0);
+<offset::local::tz_info::rule::RuleDay>::julian_0(p0);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::RuleDay::month_weekday
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
+offset::local::tz_info::rule::RuleDay::month_weekday(p0, p1, p2);
+crate::offset::local::tz_info::rule::RuleDay::month_weekday(p0, p1, p2);
+<offset::local::tz_info::rule::RuleDay>::month_weekday(p0, p1, p2);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::RuleDay::transition_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::RuleDay
let mut p1 = 0i32; // None+i32
+p0.transition_date(p1);
+offset::local::tz_info::rule::RuleDay::transition_date(p0, p1);
+crate::offset::local::tz_info::rule::RuleDay::transition_date(p0, p1);
+<offset::local::tz_info::rule::RuleDay>::transition_date(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::RuleDay::unix_time
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::RuleDay
let mut p1 = 0i32; // None+i32
let mut p2 = 0i64; // None+i64
+p0.unix_time(p1, p2);
+offset::local::tz_info::rule::RuleDay::unix_time(p0, p1, p2);
+crate::offset::local::tz_info::rule::RuleDay::unix_time(p0, p1, p2);
+<offset::local::tz_info::rule::RuleDay>::unix_time(p0, p1, p2);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::UtcDateTime as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::UtcDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::rule::UtcDateTime as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::rule::UtcDateTime as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::rule::UtcDateTime>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::UtcDateTime as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::UtcDateTime
+p0.clone();
+<offset::local::tz_info::rule::UtcDateTime as std::clone::Clone>::clone(p0);
+crate::<offset::local::tz_info::rule::UtcDateTime as std::clone::Clone>::clone(p0);
+<offset::local::tz_info::rule::UtcDateTime>::clone(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::UtcDateTime as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::UtcDateTime
+p0.assert_receiver_is_total_eq();
+<offset::local::tz_info::rule::UtcDateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::local::tz_info::rule::UtcDateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::local::tz_info::rule::UtcDateTime>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::UtcDateTime as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::UtcDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::UtcDateTime
+p0.eq(p1);
+<offset::local::tz_info::rule::UtcDateTime as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::local::tz_info::rule::UtcDateTime as std::cmp::PartialEq>::eq(p0, p1);
+<offset::local::tz_info::rule::UtcDateTime>::eq(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::UtcDateTime as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::UtcDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::UtcDateTime
+p0.cmp(p1);
+<offset::local::tz_info::rule::UtcDateTime as std::cmp::Ord>::cmp(p0, p1);
+crate::<offset::local::tz_info::rule::UtcDateTime as std::cmp::Ord>::cmp(p0, p1);
+<offset::local::tz_info::rule::UtcDateTime>::cmp(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs <offset::local::tz_info::rule::UtcDateTime as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::UtcDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::rule::UtcDateTime
+p0.partial_cmp(p1);
+<offset::local::tz_info::rule::UtcDateTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<offset::local::tz_info::rule::UtcDateTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<offset::local::tz_info::rule::UtcDateTime>::partial_cmp(p0, p1);
-----------------
src/offset/local/tz_info/rule.rs offset::local::tz_info::rule::UtcDateTime::from_timespec
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+offset::local::tz_info::rule::UtcDateTime::from_timespec(p0);
+crate::offset::local::tz_info::rule::UtcDateTime::from_timespec(p0);
+<offset::local::tz_info::rule::UtcDateTime>::from_timespec(p0);
-----------------
src/offset/local/tz_info/mod.rs <offset::local::tz_info::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::tz_info::Error as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::tz_info::Error>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/mod.rs <offset::local::tz_info::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::tz_info::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<offset::local::tz_info::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<offset::local::tz_info::Error as std::fmt::Display>::fmt(p0, p1);
+<offset::local::tz_info::Error>::fmt(p0, p1);
-----------------
src/offset/local/tz_info/mod.rs <offset::local::tz_info::Error as std::convert::From<std::io::Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::io::Error
+<offset::local::tz_info::Error as std::convert::From<std::io::Error>>::from(p0);
+crate::<offset::local::tz_info::Error as std::convert::From<std::io::Error>>::from(p0);
+<offset::local::tz_info::Error>::from(p0);
-----------------
src/offset/local/tz_info/mod.rs <offset::local::tz_info::Error as std::convert::From<std::num::ParseIntError>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::ParseIntError
+<offset::local::tz_info::Error as std::convert::From<std::num::ParseIntError>>::from(p0);
+crate::<offset::local::tz_info::Error as std::convert::From<std::num::ParseIntError>>::from(p0);
+<offset::local::tz_info::Error>::from(p0);
-----------------
src/offset/local/tz_info/mod.rs <offset::local::tz_info::Error as std::convert::From<std::time::SystemTimeError>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::SystemTimeError
+<offset::local::tz_info::Error as std::convert::From<std::time::SystemTimeError>>::from(p0);
+crate::<offset::local::tz_info::Error as std::convert::From<std::time::SystemTimeError>>::from(p0);
+<offset::local::tz_info::Error>::from(p0);
-----------------
src/offset/local/tz_info/mod.rs <offset::local::tz_info::Error as std::convert::From<std::str::Utf8Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::str::Utf8Error
+<offset::local::tz_info::Error as std::convert::From<std::str::Utf8Error>>::from(p0);
+crate::<offset::local::tz_info::Error as std::convert::From<std::str::Utf8Error>>::from(p0);
+<offset::local::tz_info::Error>::from(p0);
-----------------
src/offset/local/mod.rs <offset::local::Local as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
+p0.clone();
+<offset::local::Local as std::clone::Clone>::clone(p0);
+crate::<offset::local::Local as std::clone::Clone>::clone(p0);
+<offset::local::Local>::clone(p0);
-----------------
src/offset/local/mod.rs <offset::local::Local as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::local::Local as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::local::Local as std::fmt::Debug>::fmt(p0, p1);
+<offset::local::Local>::fmt(p0, p1);
-----------------
src/offset/local/mod.rs offset::local::Local::today
deps:{}
candidates:{}
+offset::local::Local::today();
+crate::offset::local::Local::today();
+<offset::local::Local>::today();
-----------------
src/offset/local/mod.rs offset::local::Local::now
deps:{}
candidates:{}
+offset::local::Local::now();
+crate::offset::local::Local::now();
+<offset::local::Local>::now();
-----------------
src/offset/local/mod.rs <offset::local::Local as offset::TimeZone>::from_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::fixed::FixedOffset
+<offset::local::Local as offset::TimeZone>::from_offset(p0);
+crate::<offset::local::Local as offset::TimeZone>::from_offset(p0);
+<offset::local::Local>::from_offset(p0);
-----------------
src/offset/local/mod.rs <offset::local::Local as offset::TimeZone>::offset_from_local_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.offset_from_local_date(p1);
+<offset::local::Local as offset::TimeZone>::offset_from_local_date(p0, p1);
+crate::<offset::local::Local as offset::TimeZone>::offset_from_local_date(p0, p1);
+<offset::local::Local>::offset_from_local_date(p0, p1);
-----------------
src/offset/local/mod.rs <offset::local::Local as offset::TimeZone>::offset_from_local_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.offset_from_local_datetime(p1);
+<offset::local::Local as offset::TimeZone>::offset_from_local_datetime(p0, p1);
+crate::<offset::local::Local as offset::TimeZone>::offset_from_local_datetime(p0, p1);
+<offset::local::Local>::offset_from_local_datetime(p0, p1);
-----------------
src/offset/local/mod.rs <offset::local::Local as offset::TimeZone>::offset_from_utc_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.offset_from_utc_date(p1);
+<offset::local::Local as offset::TimeZone>::offset_from_utc_date(p0, p1);
+crate::<offset::local::Local as offset::TimeZone>::offset_from_utc_date(p0, p1);
+<offset::local::Local>::offset_from_utc_date(p0, p1);
-----------------
src/offset/local/mod.rs <offset::local::Local as offset::TimeZone>::offset_from_utc_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.offset_from_utc_datetime(p1);
+<offset::local::Local as offset::TimeZone>::offset_from_utc_datetime(p0, p1);
+crate::<offset::local::Local as offset::TimeZone>::offset_from_utc_datetime(p0, p1);
+<offset::local::Local>::offset_from_utc_datetime(p0, p1);
-----------------
src/offset/local/mod.rs <offset::local::Local as offset::TimeZone>::from_local_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.from_local_date(p1);
+<offset::local::Local as offset::TimeZone>::from_local_date(p0, p1);
+crate::<offset::local::Local as offset::TimeZone>::from_local_date(p0, p1);
+<offset::local::Local>::from_local_date(p0, p1);
-----------------
src/offset/local/mod.rs <offset::local::Local as offset::TimeZone>::from_local_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.from_local_datetime(p1);
+<offset::local::Local as offset::TimeZone>::from_local_datetime(p0, p1);
+crate::<offset::local::Local as offset::TimeZone>::from_local_datetime(p0, p1);
+<offset::local::Local>::from_local_datetime(p0, p1);
-----------------
src/offset/local/mod.rs <offset::local::Local as offset::TimeZone>::from_utc_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.from_utc_date(p1);
+<offset::local::Local as offset::TimeZone>::from_utc_date(p0, p1);
+crate::<offset::local::Local as offset::TimeZone>::from_utc_date(p0, p1);
+<offset::local::Local>::from_utc_date(p0, p1);
-----------------
src/offset/local/mod.rs <offset::local::Local as offset::TimeZone>::from_utc_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::local::Local
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.from_utc_datetime(p1);
+<offset::local::Local as offset::TimeZone>::from_utc_datetime(p0, p1);
+crate::<offset::local::Local as offset::TimeZone>::from_utc_datetime(p0, p1);
+<offset::local::Local>::from_utc_datetime(p0, p1);
-----------------
src/offset/utc.rs <offset::utc::Utc as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
+p0.clone();
+<offset::utc::Utc as std::clone::Clone>::clone(p0);
+crate::<offset::utc::Utc as std::clone::Clone>::clone(p0);
+<offset::utc::Utc>::clone(p0);
-----------------
src/offset/utc.rs <offset::utc::Utc as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
+p0.eq(p1);
+<offset::utc::Utc as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::utc::Utc as std::cmp::PartialEq>::eq(p0, p1);
+<offset::utc::Utc>::eq(p0, p1);
-----------------
src/offset/utc.rs <offset::utc::Utc as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
+p0.assert_receiver_is_total_eq();
+<offset::utc::Utc as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::utc::Utc as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::utc::Utc>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/utc.rs <offset::utc::Utc as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<offset::utc::Utc as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<offset::utc::Utc as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<offset::utc::Utc as std::hash::Hash>::hash(p0, p1);
+crate::<offset::utc::Utc as std::hash::Hash>::hash(p0, p1);
+<offset::utc::Utc>::hash(p0, p1);
-----------------
src/offset/utc.rs offset::utc::Utc::today
deps:{}
candidates:{}
+offset::utc::Utc::today();
+crate::offset::utc::Utc::today();
+<offset::utc::Utc>::today();
-----------------
src/offset/utc.rs offset::utc::Utc::now
deps:{}
candidates:{}
+offset::utc::Utc::now();
+crate::offset::utc::Utc::now();
+<offset::utc::Utc>::now();
-----------------
src/offset/utc.rs <offset::utc::Utc as offset::TimeZone>::from_offset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
+<offset::utc::Utc as offset::TimeZone>::from_offset(p0);
+crate::<offset::utc::Utc as offset::TimeZone>::from_offset(p0);
+<offset::utc::Utc>::from_offset(p0);
-----------------
src/offset/utc.rs <offset::utc::Utc as offset::TimeZone>::offset_from_local_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.offset_from_local_date(p1);
+<offset::utc::Utc as offset::TimeZone>::offset_from_local_date(p0, p1);
+crate::<offset::utc::Utc as offset::TimeZone>::offset_from_local_date(p0, p1);
+<offset::utc::Utc>::offset_from_local_date(p0, p1);
-----------------
src/offset/utc.rs <offset::utc::Utc as offset::TimeZone>::offset_from_local_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.offset_from_local_datetime(p1);
+<offset::utc::Utc as offset::TimeZone>::offset_from_local_datetime(p0, p1);
+crate::<offset::utc::Utc as offset::TimeZone>::offset_from_local_datetime(p0, p1);
+<offset::utc::Utc>::offset_from_local_datetime(p0, p1);
-----------------
src/offset/utc.rs <offset::utc::Utc as offset::TimeZone>::offset_from_utc_date
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::date::NaiveDate
+p0.offset_from_utc_date(p1);
+<offset::utc::Utc as offset::TimeZone>::offset_from_utc_date(p0, p1);
+crate::<offset::utc::Utc as offset::TimeZone>::offset_from_utc_date(p0, p1);
+<offset::utc::Utc>::offset_from_utc_date(p0, p1);
-----------------
src/offset/utc.rs <offset::utc::Utc as offset::TimeZone>::offset_from_utc_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
let mut p1 = & MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
+p0.offset_from_utc_datetime(p1);
+<offset::utc::Utc as offset::TimeZone>::offset_from_utc_datetime(p0, p1);
+crate::<offset::utc::Utc as offset::TimeZone>::offset_from_utc_datetime(p0, p1);
+<offset::utc::Utc>::offset_from_utc_datetime(p0, p1);
-----------------
src/offset/utc.rs <offset::utc::Utc as offset::Offset>::fix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
+p0.fix();
+<offset::utc::Utc as offset::Offset>::fix(p0);
+crate::<offset::utc::Utc as offset::Offset>::fix(p0);
+<offset::utc::Utc>::fix(p0);
-----------------
src/offset/utc.rs <offset::utc::Utc as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::utc::Utc as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::utc::Utc as std::fmt::Debug>::fmt(p0, p1);
+<offset::utc::Utc>::fmt(p0, p1);
-----------------
src/offset/utc.rs <offset::utc::Utc as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::utc::Utc
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<offset::utc::Utc as std::fmt::Display>::fmt(p0, p1);
+crate::<offset::utc::Utc as std::fmt::Display>::fmt(p0, p1);
+<offset::utc::Utc>::fmt(p0, p1);
-----------------
src/offset/mod.rs <offset::LocalResult<T> as std::clone::Clone>::clone
deps:{"<*const T as std::fmt::Debug>":{},"<offset::LocalResult<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"date::Date":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"offset::LocalResult":{"T":["std::fmt::Debug","std::marker::Copy","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<offset::LocalResult<T> as std::clone::Clone>::clone":{"T":["format::Pad","offset::local::tz_info::timezone::Transition","round::RoundingError","format::InternalNumeric","offset::local::Local","format::Numeric","naive::date::NaiveDateDaysIterator","offset::local::tz_info::timezone::LocalTimeType","format::ParseError","format::ParseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::rule::RuleDay","format::Fixed","offset::utc::Utc","month::ParseMonthError","naive::isoweek::IsoWeek","format::Item","naive::internals::YearFlags","format::Colons","format::strftime::StrftimeItems","month::Month","time_delta::OutOfRangeError","weekday::Weekday","month::Months","datetime::SecondsFormat","format::InternalFixed","naive::date::NaiveDate","offset::local::tz_info::rule::TransitionRule","time_delta::TimeDelta","offset::local::tz_info::timezone::TimeZoneRef","std::clone::impls::<impl std::clone::Clone for *mut T>","offset::LocalResult","naive::time::NaiveTime","OutOfRange","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","offset::local::tz_info::timezone::TimeZone","datetime::DateTime","format::parsed::Parsed","naive::date::Days","naive::internals::Mdf","date::Date","offset::fixed::FixedOffset","naive::internals::Of","offset::local::tz_info::rule::AlternateTime","format::Void","offset::local::tz_info::rule::UtcDateTime","weekday::ParseWeekdayError","format::InternalInternal","offset::local::tz_info::parser::Version"]},"date::Date":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"offset::LocalResult":{"T":["naive::datetime::NaiveDateTime","weekday::Weekday","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","naive::internals::YearFlags","naive::date::Days","format::ParseErrorKind","offset::LocalResult","naive::date::NaiveDateWeeksIterator","time_delta::TimeDelta","format::ParseError","format::Pad","naive::isoweek::IsoWeek","offset::utc::Utc","month::Months","naive::date::NaiveDate","month::Month","date::Date","datetime::DateTime","OutOfRange","datetime::SecondsFormat","offset::fixed::FixedOffset","naive::time::NaiveTime","naive::date::NaiveDateDaysIterator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
+p0.clone();
+<offset::LocalResult<T> as std::clone::Clone>::clone(p0);
+crate::<offset::LocalResult<T> as std::clone::Clone>::clone(p0);
+<offset::LocalResult<T>>::clone(p0);
-----------------
src/offset/mod.rs <offset::LocalResult<T> as std::cmp::PartialEq>::eq
deps:{"<*mut T as std::fmt::Debug>":{},"<offset::LocalResult<T> as std::cmp::PartialEq>::eq":{"T":["std::marker::Sized","std::cmp::PartialEq"]},"date::Date":{"Tz":["offset::TimeZone","std::marker::Sized","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"offset::LocalResult":{"T":["std::clone::Clone","std::marker::Copy","std::marker::Sized","std::cmp::Eq","std::hash::Hash","std::cmp::PartialEq","std::fmt::Debug"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<offset::LocalResult<T> as std::cmp::PartialEq>::eq":{"T":["offset::local::tz_info::timezone::TimeZoneRef","naive::datetime::NaiveDateTime","offset::utc::Utc","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::Transition","format::parsed::Parsed","format::ParseErrorKind","format::Numeric","naive::date::NaiveDate","naive::internals::Of","format::Colons","naive::time::NaiveTime","naive::date::Days","round::RoundingError","datetime::SecondsFormat","weekday::ParseWeekdayError","time_delta::TimeDelta","month::ParseMonthError","offset::local::tz_info::timezone::TimeZone","weekday::Weekday","offset::local::tz_info::rule::AlternateTime","format::InternalInternal","offset::local::tz_info::rule::RuleDay","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","offset::fixed::FixedOffset","naive::isoweek::IsoWeek","offset::LocalResult","format::Fixed","date::Date","offset::local::tz_info::rule::UtcDateTime","naive::date::NaiveDateWeeksIterator","month::Months","format::ParseError","offset::local::tz_info::parser::Version","format::Void","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","format::InternalNumeric","format::InternalFixed","offset::local::tz_info::parser::Cursor","OutOfRange","offset::local::tz_info::timezone::TimeZoneName","naive::date::NaiveDateDaysIterator","datetime::DateTime","offset::local::tz_info::timezone::LocalTimeType","format::Pad","format::Item","month::Month","naive::internals::Mdf","offset::local::tz_info::rule::TransitionRule","naive::internals::YearFlags","time_delta::OutOfRangeError"]},"date::Date":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"offset::LocalResult":{"T":["offset::fixed::FixedOffset","format::ParseErrorKind","offset::utc::Utc","naive::date::Days","time_delta::TimeDelta","weekday::Weekday","datetime::DateTime","naive::date::NaiveDate","datetime::SecondsFormat","naive::date::NaiveDateWeeksIterator","naive::date::NaiveDateDaysIterator","date::Date","month::Month","month::Months","naive::internals::YearFlags","OutOfRange","std::hash::impls::<impl std::hash::Hash for *const T>","offset::LocalResult","naive::isoweek::IsoWeek","naive::time::NaiveTime","format::ParseError","naive::datetime::NaiveDateTime","format::Pad"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
+p0.eq(p1);
+<offset::LocalResult<T> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset::LocalResult<T> as std::cmp::PartialEq>::eq(p0, p1);
+<offset::LocalResult<T>>::eq(p0, p1);
-----------------
src/offset/mod.rs <offset::LocalResult<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<offset::LocalResult<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"date::Date":{"Tz":["offset::TimeZone","std::clone::Clone","std::marker::Sized"]},"datetime::DateTime":{"Tz":["std::clone::Clone","std::marker::Sized","offset::TimeZone"]},"format::DelayedFormat":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::iter::Iterator"]},"offset::LocalResult":{"T":["std::fmt::Debug","std::cmp::Eq","std::hash::Hash","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::marker::Copy"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<offset::LocalResult<T> as std::fmt::Debug>::fmt":{"T":["naive::date::NaiveDateDaysIterator","format::strftime::StrftimeItems","format::Item","format::ParseError","naive::isoweek::IsoWeek","format::Colons","format::InternalFixed","offset::local::tz_info::timezone::TimeZone","format::Pad","offset::LocalResult","date::Date","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::rule::AlternateTime","naive::date::NaiveDateWeeksIterator","offset::local::tz_info::timezone::LocalTimeType","datetime::DateTime","naive::date::Days","round::RoundingError","naive::time::NaiveTime","naive::internals::Mdf","month::Month","weekday::Weekday","time_delta::OutOfRangeError","offset::fixed::FixedOffset","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::parser::Cursor","OutOfRange","<*mut T as std::fmt::Debug>","offset::local::tz_info::Error","naive::internals::Of","naive::date::NaiveWeek","weekday::ParseWeekdayError","offset::local::tz_info::parser::Version","format::InternalNumeric","month::ParseMonthError","datetime::SecondsFormat","format::InternalInternal","naive::internals::YearFlags","offset::local::Local","time_delta::TimeDelta","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::TimeZoneRef","format::Numeric","offset::local::tz_info::parser::Header","month::Months","format::DelayedFormat","offset::local::tz_info::rule::RuleDay","<*const T as std::fmt::Debug>","naive::datetime::NaiveDateTime","format::Fixed","format::Locale","format::parsed::Parsed","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::Transition","offset::utc::Utc","format::ParseErrorKind","naive::date::NaiveDate"]},"date::Date":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"format::DelayedFormat":{"I":["format::strftime::StrftimeItems","naive::date::NaiveDateWeeksIterator","naive::date::NaiveDateDaysIterator"]},"offset::LocalResult":{"T":["naive::date::NaiveDateWeeksIterator","naive::date::NaiveDate","naive::internals::YearFlags","naive::isoweek::IsoWeek","format::Pad","naive::datetime::NaiveDateTime","datetime::SecondsFormat","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","naive::date::NaiveDateDaysIterator","OutOfRange","weekday::Weekday","date::Date","month::Months","offset::LocalResult","time_delta::TimeDelta","naive::date::Days","format::ParseErrorKind","month::Month","datetime::DateTime","format::ParseError","offset::utc::Utc","offset::fixed::FixedOffset","naive::time::NaiveTime"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset::LocalResult<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset::LocalResult<T> as std::fmt::Debug>::fmt(p0, p1);
+<offset::LocalResult<T>>::fmt(p0, p1);
-----------------
src/offset/mod.rs <offset::LocalResult<T> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<offset::LocalResult<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["std::marker::Sized","std::cmp::Eq"]},"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"offset::LocalResult":{"T":["std::hash::Hash","std::fmt::Debug","std::cmp::PartialEq","std::marker::Copy","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<offset::LocalResult<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["weekday::ParseWeekdayError","offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::timezone::TimeZoneName","naive::datetime::NaiveDateTime","month::Months","naive::internals::YearFlags","offset::local::tz_info::rule::TransitionRule","naive::time::NaiveTime","month::ParseMonthError","offset::local::tz_info::timezone::LeapSecond","naive::date::NaiveDateDaysIterator","offset::local::tz_info::timezone::TimeZone","format::Numeric","date::Date","offset::local::tz_info::rule::UtcDateTime","offset::utc::Utc","format::InternalInternal","format::InternalNumeric","OutOfRange","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::parser::Version","format::Void","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","format::ParseErrorKind","naive::date::Days","format::Colons","format::ParseError","month::Month","format::Fixed","naive::date::NaiveDateWeeksIterator","round::RoundingError","datetime::DateTime","format::Pad","offset::local::tz_info::timezone::TimeZoneRef","format::parsed::Parsed","offset::fixed::FixedOffset","format::InternalFixed","format::Item","naive::isoweek::IsoWeek","std::cmp::impls::<impl std::cmp::Eq for &A>","offset::local::tz_info::parser::Cursor","offset::LocalResult","naive::date::NaiveDate","offset::local::tz_info::rule::RuleDay","time_delta::OutOfRangeError","datetime::SecondsFormat","time_delta::TimeDelta","offset::local::tz_info::timezone::Transition","weekday::Weekday"]},"date::Date":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"offset::LocalResult":{"T":["month::Month","time_delta::TimeDelta","naive::internals::YearFlags","month::Months","format::ParseError","datetime::DateTime","naive::date::Days","format::ParseErrorKind","offset::utc::Utc","std::marker::copy_impls::<impl std::marker::Copy for *mut T>","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","offset::fixed::FixedOffset","offset::LocalResult","datetime::SecondsFormat","date::Date","format::Pad","naive::isoweek::IsoWeek","weekday::Weekday","naive::date::NaiveDateWeeksIterator","naive::time::NaiveTime","OutOfRange","naive::datetime::NaiveDateTime"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::marker::copy_impls::<impl std::marker::Copy for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
+p0.assert_receiver_is_total_eq();
+<offset::LocalResult<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset::LocalResult<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset::LocalResult<T>>::assert_receiver_is_total_eq(p0);
-----------------
src/offset/mod.rs <offset::LocalResult<T> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<offset::LocalResult<T> as std::hash::Hash>::hash":{"T":["std::hash::Hash","std::marker::Sized"],"__H":["std::hash::Hasher","std::marker::Sized"]},"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]},"offset::LocalResult":{"T":["std::clone::Clone","std::hash::Hash","std::marker::Sized","std::marker::Copy","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<offset::LocalResult<T> as std::hash::Hash>::hash":{"T":["datetime::SecondsFormat","naive::isoweek::IsoWeek","date::Date","format::Void","weekday::Weekday","naive::time::NaiveTime","std::hash::impls::<impl std::hash::Hash for &T>","format::ParseError","naive::date::NaiveDate","month::Month","naive::date::NaiveDateWeeksIterator","format::parsed::Parsed","OutOfRange","format::InternalNumeric","offset::fixed::FixedOffset","format::Item","format::InternalInternal","format::Fixed","naive::date::Days","month::Months","format::Pad","format::InternalFixed","naive::datetime::NaiveDateTime","time_delta::TimeDelta","naive::internals::YearFlags","datetime::DateTime","format::Numeric","format::ParseErrorKind","offset::LocalResult","naive::date::NaiveDateDaysIterator","offset::utc::Utc","format::Colons"],"__H":["std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::hash::SipHasher13","std::boxed::Box<T, A>"]},"date::Date":{"Tz":["offset::local::Local","offset::utc::Utc","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]},"offset::LocalResult":{"T":["format::ParseError","naive::time::NaiveTime","datetime::DateTime","OutOfRange","date::Date","naive::date::NaiveDate","naive::date::Days","offset::utc::Utc","naive::isoweek::IsoWeek","weekday::Weekday","naive::date::NaiveDateDaysIterator","offset::LocalResult","time_delta::TimeDelta","month::Months","month::Month","naive::date::NaiveDateWeeksIterator","format::ParseErrorKind","offset::fixed::FixedOffset","naive::datetime::NaiveDateTime","std::hash::impls::<impl std::hash::Hash for *const T>","datetime::SecondsFormat","format::Pad","naive::internals::YearFlags"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<offset::LocalResult<T> as std::hash::Hash>::hash(p0, p1);
+crate::<offset::LocalResult<T> as std::hash::Hash>::hash(p0, p1);
+<offset::LocalResult<T>>::hash(p0, p1);
-----------------
src/offset/mod.rs offset::LocalResult::<T>::single
deps:{"offset::LocalResult::<T>::single":{"T":["std::marker::Sized"]}}
candidates:{"offset::LocalResult::<T>::single":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
+p0.single();
+offset::LocalResult::<T>::single(p0);
+crate::offset::LocalResult::<T>::single(p0);
+<offset::LocalResult<T>>::single(p0);
-----------------
src/offset/mod.rs offset::LocalResult::<T>::earliest
deps:{"offset::LocalResult::<T>::earliest":{"T":["std::marker::Sized"]}}
candidates:{"offset::LocalResult::<T>::earliest":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
+p0.earliest();
+offset::LocalResult::<T>::earliest(p0);
+crate::offset::LocalResult::<T>::earliest(p0);
+<offset::LocalResult<T>>::earliest(p0);
-----------------
src/offset/mod.rs offset::LocalResult::<T>::latest
deps:{"offset::LocalResult::<T>::latest":{"T":["std::marker::Sized"]}}
candidates:{"offset::LocalResult::<T>::latest":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
+p0.latest();
+offset::LocalResult::<T>::latest(p0);
+crate::offset::LocalResult::<T>::latest(p0);
+<offset::LocalResult<T>>::latest(p0);
-----------------
src/offset/mod.rs offset::LocalResult::<T>::map
deps:{"offset::LocalResult::<T>::map":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"offset::LocalResult::<T>::map":{"F":["core::str::IsWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+offset::LocalResult::<T>::map(p0, p1);
+crate::offset::LocalResult::<T>::map(p0, p1);
+<offset::LocalResult<T>>::map(p0, p1);
-----------------
src/offset/mod.rs offset::LocalResult::<date::Date<Tz>>::and_time
deps:{"offset::LocalResult::<date::Date<Tz>>::and_time":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"offset::LocalResult::<date::Date<Tz>>::and_time":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<date::Date<Tz>>
let mut p1 = MaybeUninit::uninit().assume_init(); // naive::time::NaiveTime
+p0.and_time(p1);
+offset::LocalResult::<date::Date<Tz>>::and_time(p0, p1);
+crate::offset::LocalResult::<date::Date<Tz>>::and_time(p0, p1);
+<offset::LocalResult<date::Date<Tz>>>::and_time(p0, p1);
-----------------
src/offset/mod.rs offset::LocalResult::<date::Date<Tz>>::and_hms_opt
deps:{"offset::LocalResult::<date::Date<Tz>>::and_hms_opt":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"offset::LocalResult::<date::Date<Tz>>::and_hms_opt":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<date::Date<Tz>>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
+p0.and_hms_opt(p1, p2, p3);
+offset::LocalResult::<date::Date<Tz>>::and_hms_opt(p0, p1, p2, p3);
+crate::offset::LocalResult::<date::Date<Tz>>::and_hms_opt(p0, p1, p2, p3);
+<offset::LocalResult<date::Date<Tz>>>::and_hms_opt(p0, p1, p2, p3);
-----------------
src/offset/mod.rs offset::LocalResult::<date::Date<Tz>>::and_hms_milli_opt
deps:{"offset::LocalResult::<date::Date<Tz>>::and_hms_milli_opt":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"offset::LocalResult::<date::Date<Tz>>::and_hms_milli_opt":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<date::Date<Tz>>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_milli_opt(p1, p2, p3, p4);
+offset::LocalResult::<date::Date<Tz>>::and_hms_milli_opt(p0, p1, p2, p3, p4);
+crate::offset::LocalResult::<date::Date<Tz>>::and_hms_milli_opt(p0, p1, p2, p3, p4);
+<offset::LocalResult<date::Date<Tz>>>::and_hms_milli_opt(p0, p1, p2, p3, p4);
-----------------
src/offset/mod.rs offset::LocalResult::<date::Date<Tz>>::and_hms_micro_opt
deps:{"offset::LocalResult::<date::Date<Tz>>::and_hms_micro_opt":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"offset::LocalResult::<date::Date<Tz>>::and_hms_micro_opt":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<date::Date<Tz>>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_micro_opt(p1, p2, p3, p4);
+offset::LocalResult::<date::Date<Tz>>::and_hms_micro_opt(p0, p1, p2, p3, p4);
+crate::offset::LocalResult::<date::Date<Tz>>::and_hms_micro_opt(p0, p1, p2, p3, p4);
+<offset::LocalResult<date::Date<Tz>>>::and_hms_micro_opt(p0, p1, p2, p3, p4);
-----------------
src/offset/mod.rs offset::LocalResult::<date::Date<Tz>>::and_hms_nano_opt
deps:{"offset::LocalResult::<date::Date<Tz>>::and_hms_nano_opt":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"offset::LocalResult::<date::Date<Tz>>::and_hms_nano_opt":{"Tz":["offset::fixed::FixedOffset","offset::utc::Utc","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<date::Date<Tz>>
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.and_hms_nano_opt(p1, p2, p3, p4);
+offset::LocalResult::<date::Date<Tz>>::and_hms_nano_opt(p0, p1, p2, p3, p4);
+crate::offset::LocalResult::<date::Date<Tz>>::and_hms_nano_opt(p0, p1, p2, p3, p4);
+<offset::LocalResult<date::Date<Tz>>>::and_hms_nano_opt(p0, p1, p2, p3, p4);
-----------------
src/offset/mod.rs offset::LocalResult::<T>::unwrap
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"date::Date":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"datetime::DateTime":{"Tz":["std::marker::Sized","std::clone::Clone","offset::TimeZone"]},"format::DelayedFormat":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::iter::Iterator"]},"offset::LocalResult":{"T":["std::marker::Sized","std::marker::Copy","std::cmp::Eq","std::hash::Hash","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"offset::LocalResult::<T>::unwrap":{"T":["std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"date::Date":{"Tz":["offset::utc::Utc","offset::local::Local","offset::fixed::FixedOffset"]},"datetime::DateTime":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]},"format::DelayedFormat":{"I":["naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","format::strftime::StrftimeItems"]},"offset::LocalResult":{"T":["month::Months","naive::time::NaiveTime","weekday::Weekday","naive::isoweek::IsoWeek","format::ParseError","month::Month","naive::date::NaiveDateDaysIterator","offset::fixed::FixedOffset","date::Date","naive::date::NaiveDate","time_delta::TimeDelta","offset::utc::Utc","naive::date::Days","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","datetime::DateTime","datetime::SecondsFormat","offset::LocalResult","naive::internals::YearFlags","OutOfRange","format::Pad","format::ParseErrorKind","<*mut T as std::fmt::Debug>"]},"offset::LocalResult::<T>::unwrap":{"T":["datetime::DateTime","time_delta::TimeDelta","offset::utc::Utc","OutOfRange","format::ParseError","offset::local::tz_info::timezone::TimeZoneRef","format::strftime::StrftimeItems","offset::local::tz_info::parser::Version","weekday::ParseWeekdayError","offset::local::tz_info::timezone::LeapSecond","month::Months","offset::fixed::FixedOffset","weekday::Weekday","offset::local::tz_info::parser::Cursor","date::Date","format::InternalFixed","format::InternalNumeric","format::parsed::Parsed","format::Fixed","time_delta::OutOfRangeError","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::rule::RuleDay","naive::date::NaiveDate","format::InternalInternal","naive::internals::YearFlags","naive::date::Days","month::Month","naive::date::NaiveDateWeeksIterator","format::DelayedFormat","format::Colons","datetime::SecondsFormat","<*const T as std::fmt::Debug>","offset::local::Local","offset::local::tz_info::rule::AlternateTime","naive::datetime::NaiveDateTime","offset::local::tz_info::Error","round::RoundingError","format::Item","format::Numeric","offset::local::tz_info::timezone::TimeZone","month::ParseMonthError","offset::local::tz_info::parser::Header","naive::isoweek::IsoWeek","naive::date::NaiveWeek","naive::date::NaiveDateDaysIterator","naive::internals::Mdf","<*mut T as std::fmt::Debug>","offset::LocalResult","offset::local::tz_info::timezone::Transition","format::ParseErrorKind","format::Locale","offset::local::tz_info::rule::TransitionRule","naive::internals::Of","format::Pad","naive::time::NaiveTime"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset::LocalResult<T>
+p0.unwrap();
+offset::LocalResult::<T>::unwrap(p0);
+crate::offset::LocalResult::<T>::unwrap(p0);
+<offset::LocalResult<T>>::unwrap(p0);
-----------------
src/round.rs <T as round::SubsecRound>::round_subsecs
deps:{"<T as round::SubsecRound>::round_subsecs":{"T":["std::ops::Sub","std::ops::Add","traits::Timelike","std::marker::Sized"]},"date::Date":{"Tz":["std::clone::Clone","offset::TimeZone","std::marker::Sized"]}}
candidates:{"<T as round::SubsecRound>::round_subsecs":{"T":["date::Date"]},"date::Date":{"Tz":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0u16; // None+u16
+p0.round_subsecs(p1);
+<T as round::SubsecRound>::round_subsecs(p0, p1);
+crate::<T as round::SubsecRound>::round_subsecs(p0, p1);
+<T>::round_subsecs(p0, p1);
-----------------
src/round.rs <T as round::SubsecRound>::trunc_subsecs
deps:{"<T as round::SubsecRound>::trunc_subsecs":{"T":["std::ops::Sub","std::marker::Sized","traits::Timelike","std::ops::Add"]},"date::Date":{"Tz":["std::marker::Sized","offset::TimeZone","std::clone::Clone"]}}
candidates:{"<T as round::SubsecRound>::trunc_subsecs":{"T":["date::Date"]},"date::Date":{"Tz":["offset::utc::Utc","offset::fixed::FixedOffset","offset::local::Local"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0u16; // None+u16
+p0.trunc_subsecs(p1);
+<T as round::SubsecRound>::trunc_subsecs(p0, p1);
+crate::<T as round::SubsecRound>::trunc_subsecs(p0, p1);
+<T>::trunc_subsecs(p0, p1);
-----------------
src/round.rs <datetime::DateTime<Tz> as round::DurationRound>::duration_round
deps:{"<datetime::DateTime<Tz> as round::DurationRound>::duration_round":{"Tz":["offset::TimeZone","std::marker::Sized"]}}
candidates:{"<datetime::DateTime<Tz> as round::DurationRound>::duration_round":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.duration_round(p1);
+<datetime::DateTime<Tz> as round::DurationRound>::duration_round(p0, p1);
+crate::<datetime::DateTime<Tz> as round::DurationRound>::duration_round(p0, p1);
+<datetime::DateTime<Tz>>::duration_round(p0, p1);
-----------------
src/round.rs <datetime::DateTime<Tz> as round::DurationRound>::duration_trunc
deps:{"<datetime::DateTime<Tz> as round::DurationRound>::duration_trunc":{"Tz":["std::marker::Sized","offset::TimeZone"]}}
candidates:{"<datetime::DateTime<Tz> as round::DurationRound>::duration_trunc":{"Tz":["offset::local::Local","offset::fixed::FixedOffset","offset::utc::Utc"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::DateTime<Tz>
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.duration_trunc(p1);
+<datetime::DateTime<Tz> as round::DurationRound>::duration_trunc(p0, p1);
+crate::<datetime::DateTime<Tz> as round::DurationRound>::duration_trunc(p0, p1);
+<datetime::DateTime<Tz>>::duration_trunc(p0, p1);
-----------------
src/round.rs <naive::datetime::NaiveDateTime as round::DurationRound>::duration_round
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.duration_round(p1);
+<naive::datetime::NaiveDateTime as round::DurationRound>::duration_round(p0, p1);
+crate::<naive::datetime::NaiveDateTime as round::DurationRound>::duration_round(p0, p1);
+<naive::datetime::NaiveDateTime>::duration_round(p0, p1);
-----------------
src/round.rs <naive::datetime::NaiveDateTime as round::DurationRound>::duration_trunc
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // naive::datetime::NaiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time_delta::TimeDelta
+p0.duration_trunc(p1);
+<naive::datetime::NaiveDateTime as round::DurationRound>::duration_trunc(p0, p1);
+crate::<naive::datetime::NaiveDateTime as round::DurationRound>::duration_trunc(p0, p1);
+<naive::datetime::NaiveDateTime>::duration_trunc(p0, p1);
-----------------
src/round.rs <round::RoundingError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // round::RoundingError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<round::RoundingError as std::fmt::Debug>::fmt(p0, p1);
+crate::<round::RoundingError as std::fmt::Debug>::fmt(p0, p1);
+<round::RoundingError>::fmt(p0, p1);
-----------------
src/round.rs <round::RoundingError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // round::RoundingError
+p0.clone();
+<round::RoundingError as std::clone::Clone>::clone(p0);
+crate::<round::RoundingError as std::clone::Clone>::clone(p0);
+<round::RoundingError>::clone(p0);
-----------------
src/round.rs <round::RoundingError as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // round::RoundingError
let mut p1 = & MaybeUninit::uninit().assume_init(); // round::RoundingError
+p0.eq(p1);
+<round::RoundingError as std::cmp::PartialEq>::eq(p0, p1);
+crate::<round::RoundingError as std::cmp::PartialEq>::eq(p0, p1);
+<round::RoundingError>::eq(p0, p1);
-----------------
src/round.rs <round::RoundingError as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // round::RoundingError
+p0.assert_receiver_is_total_eq();
+<round::RoundingError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<round::RoundingError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<round::RoundingError>::assert_receiver_is_total_eq(p0);
-----------------
src/round.rs <round::RoundingError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // round::RoundingError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<round::RoundingError as std::fmt::Display>::fmt(p0, p1);
+crate::<round::RoundingError as std::fmt::Display>::fmt(p0, p1);
+<round::RoundingError>::fmt(p0, p1);
-----------------
src/round.rs <round::RoundingError as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // round::RoundingError
+p0.description();
+<round::RoundingError as std::error::Error>::description(p0);
+crate::<round::RoundingError as std::error::Error>::description(p0);
+<round::RoundingError>::description(p0);
-----------------
src/weekday.rs <weekday::Weekday as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p1 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.eq(p1);
+<weekday::Weekday as std::cmp::PartialEq>::eq(p0, p1);
+crate::<weekday::Weekday as std::cmp::PartialEq>::eq(p0, p1);
+<weekday::Weekday>::eq(p0, p1);
-----------------
src/weekday.rs <weekday::Weekday as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.assert_receiver_is_total_eq();
+<weekday::Weekday as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<weekday::Weekday as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<weekday::Weekday>::assert_receiver_is_total_eq(p0);
-----------------
src/weekday.rs <weekday::Weekday as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.clone();
+<weekday::Weekday as std::clone::Clone>::clone(p0);
+crate::<weekday::Weekday as std::clone::Clone>::clone(p0);
+<weekday::Weekday>::clone(p0);
-----------------
src/weekday.rs <weekday::Weekday as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<weekday::Weekday as std::fmt::Debug>::fmt(p0, p1);
+crate::<weekday::Weekday as std::fmt::Debug>::fmt(p0, p1);
+<weekday::Weekday>::fmt(p0, p1);
-----------------
src/weekday.rs <weekday::Weekday as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<weekday::Weekday as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<weekday::Weekday as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<weekday::Weekday as std::hash::Hash>::hash(p0, p1);
+crate::<weekday::Weekday as std::hash::Hash>::hash(p0, p1);
+<weekday::Weekday>::hash(p0, p1);
-----------------
src/weekday.rs weekday::Weekday::succ
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.succ();
+weekday::Weekday::succ(p0);
+crate::weekday::Weekday::succ(p0);
+<weekday::Weekday>::succ(p0);
-----------------
src/weekday.rs weekday::Weekday::pred
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.pred();
+weekday::Weekday::pred(p0);
+crate::weekday::Weekday::pred(p0);
+<weekday::Weekday>::pred(p0);
-----------------
src/weekday.rs weekday::Weekday::number_from_monday
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.number_from_monday();
+weekday::Weekday::number_from_monday(p0);
+crate::weekday::Weekday::number_from_monday(p0);
+<weekday::Weekday>::number_from_monday(p0);
-----------------
src/weekday.rs weekday::Weekday::number_from_sunday
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.number_from_sunday();
+weekday::Weekday::number_from_sunday(p0);
+crate::weekday::Weekday::number_from_sunday(p0);
+<weekday::Weekday>::number_from_sunday(p0);
-----------------
src/weekday.rs weekday::Weekday::num_days_from_monday
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.num_days_from_monday();
+weekday::Weekday::num_days_from_monday(p0);
+crate::weekday::Weekday::num_days_from_monday(p0);
+<weekday::Weekday>::num_days_from_monday(p0);
-----------------
src/weekday.rs weekday::Weekday::num_days_from_sunday
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.num_days_from_sunday();
+weekday::Weekday::num_days_from_sunday(p0);
+crate::weekday::Weekday::num_days_from_sunday(p0);
+<weekday::Weekday>::num_days_from_sunday(p0);
-----------------
src/weekday.rs weekday::Weekday::num_days_from
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p1 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.num_days_from(p1);
+weekday::Weekday::num_days_from(p0, p1);
+crate::weekday::Weekday::num_days_from(p0, p1);
+<weekday::Weekday>::num_days_from(p0, p1);
-----------------
src/weekday.rs <weekday::Weekday as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<weekday::Weekday as std::fmt::Display>::fmt(p0, p1);
+crate::<weekday::Weekday as std::fmt::Display>::fmt(p0, p1);
+<weekday::Weekday>::fmt(p0, p1);
-----------------
src/weekday.rs <weekday::Weekday as std::convert::TryFrom<u8>>::try_from
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<weekday::Weekday as std::convert::TryFrom<u8>>::try_from(p0);
+crate::<weekday::Weekday as std::convert::TryFrom<u8>>::try_from(p0);
+<weekday::Weekday>::try_from(p0);
-----------------
src/weekday.rs <weekday::ParseWeekdayError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::ParseWeekdayError
+p0.clone();
+<weekday::ParseWeekdayError as std::clone::Clone>::clone(p0);
+crate::<weekday::ParseWeekdayError as std::clone::Clone>::clone(p0);
+<weekday::ParseWeekdayError>::clone(p0);
-----------------
src/weekday.rs <weekday::ParseWeekdayError as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::ParseWeekdayError
let mut p1 = & MaybeUninit::uninit().assume_init(); // weekday::ParseWeekdayError
+p0.eq(p1);
+<weekday::ParseWeekdayError as std::cmp::PartialEq>::eq(p0, p1);
+crate::<weekday::ParseWeekdayError as std::cmp::PartialEq>::eq(p0, p1);
+<weekday::ParseWeekdayError>::eq(p0, p1);
-----------------
src/weekday.rs <weekday::ParseWeekdayError as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::ParseWeekdayError
+p0.assert_receiver_is_total_eq();
+<weekday::ParseWeekdayError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<weekday::ParseWeekdayError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<weekday::ParseWeekdayError>::assert_receiver_is_total_eq(p0);
-----------------
src/weekday.rs <weekday::ParseWeekdayError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::ParseWeekdayError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<weekday::ParseWeekdayError as std::fmt::Display>::fmt(p0, p1);
+crate::<weekday::ParseWeekdayError as std::fmt::Display>::fmt(p0, p1);
+<weekday::ParseWeekdayError>::fmt(p0, p1);
-----------------
src/weekday.rs <weekday::ParseWeekdayError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::ParseWeekdayError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<weekday::ParseWeekdayError as std::fmt::Debug>::fmt(p0, p1);
+crate::<weekday::ParseWeekdayError as std::fmt::Debug>::fmt(p0, p1);
+<weekday::ParseWeekdayError>::fmt(p0, p1);
-----------------
src/month.rs <month::Month as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
let mut p1 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.eq(p1);
+<month::Month as std::cmp::PartialEq>::eq(p0, p1);
+crate::<month::Month as std::cmp::PartialEq>::eq(p0, p1);
+<month::Month>::eq(p0, p1);
-----------------
src/month.rs <month::Month as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.assert_receiver_is_total_eq();
+<month::Month as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<month::Month as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<month::Month>::assert_receiver_is_total_eq(p0);
-----------------
src/month.rs <month::Month as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.clone();
+<month::Month as std::clone::Clone>::clone(p0);
+crate::<month::Month as std::clone::Clone>::clone(p0);
+<month::Month>::clone(p0);
-----------------
src/month.rs <month::Month as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<month::Month as std::fmt::Debug>::fmt(p0, p1);
+crate::<month::Month as std::fmt::Debug>::fmt(p0, p1);
+<month::Month>::fmt(p0, p1);
-----------------
src/month.rs <month::Month as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<month::Month as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<month::Month as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::hash::SipHasher","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<month::Month as std::hash::Hash>::hash(p0, p1);
+crate::<month::Month as std::hash::Hash>::hash(p0, p1);
+<month::Month>::hash(p0, p1);
-----------------
src/month.rs <month::Month as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
let mut p1 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.partial_cmp(p1);
+<month::Month as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<month::Month as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<month::Month>::partial_cmp(p0, p1);
-----------------
src/month.rs month::Month::succ
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.succ();
+month::Month::succ(p0);
+crate::month::Month::succ(p0);
+<month::Month>::succ(p0);
-----------------
src/month.rs month::Month::pred
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.pred();
+month::Month::pred(p0);
+crate::month::Month::pred(p0);
+<month::Month>::pred(p0);
-----------------
src/month.rs month::Month::number_from_month
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.number_from_month();
+month::Month::number_from_month(p0);
+crate::month::Month::number_from_month(p0);
+<month::Month>::number_from_month(p0);
-----------------
src/month.rs month::Month::name
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.name();
+month::Month::name(p0);
+crate::month::Month::name(p0);
+<month::Month>::name(p0);
-----------------
src/month.rs <month::Month as std::convert::TryFrom<u8>>::try_from
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<month::Month as std::convert::TryFrom<u8>>::try_from(p0);
+crate::<month::Month as std::convert::TryFrom<u8>>::try_from(p0);
+<month::Month>::try_from(p0);
-----------------
src/month.rs <month::Months as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Months
+p0.clone();
+<month::Months as std::clone::Clone>::clone(p0);
+crate::<month::Months as std::clone::Clone>::clone(p0);
+<month::Months>::clone(p0);
-----------------
src/month.rs <month::Months as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Months
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<month::Months as std::fmt::Debug>::fmt(p0, p1);
+crate::<month::Months as std::fmt::Debug>::fmt(p0, p1);
+<month::Months>::fmt(p0, p1);
-----------------
src/month.rs <month::Months as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Months
+p0.assert_receiver_is_total_eq();
+<month::Months as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<month::Months as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<month::Months>::assert_receiver_is_total_eq(p0);
-----------------
src/month.rs <month::Months as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<month::Months as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<month::Months as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Months
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<month::Months as std::hash::Hash>::hash(p0, p1);
+crate::<month::Months as std::hash::Hash>::hash(p0, p1);
+<month::Months>::hash(p0, p1);
-----------------
src/month.rs <month::Months as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Months
let mut p1 = & MaybeUninit::uninit().assume_init(); // month::Months
+p0.eq(p1);
+<month::Months as std::cmp::PartialEq>::eq(p0, p1);
+crate::<month::Months as std::cmp::PartialEq>::eq(p0, p1);
+<month::Months>::eq(p0, p1);
-----------------
src/month.rs <month::Months as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Months
let mut p1 = & MaybeUninit::uninit().assume_init(); // month::Months
+p0.partial_cmp(p1);
+<month::Months as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<month::Months as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<month::Months>::partial_cmp(p0, p1);
-----------------
src/month.rs month::Months::new
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+month::Months::new(p0);
+crate::month::Months::new(p0);
+<month::Months>::new(p0);
-----------------
src/month.rs <month::ParseMonthError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::ParseMonthError
+p0.clone();
+<month::ParseMonthError as std::clone::Clone>::clone(p0);
+crate::<month::ParseMonthError as std::clone::Clone>::clone(p0);
+<month::ParseMonthError>::clone(p0);
-----------------
src/month.rs <month::ParseMonthError as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::ParseMonthError
let mut p1 = & MaybeUninit::uninit().assume_init(); // month::ParseMonthError
+p0.eq(p1);
+<month::ParseMonthError as std::cmp::PartialEq>::eq(p0, p1);
+crate::<month::ParseMonthError as std::cmp::PartialEq>::eq(p0, p1);
+<month::ParseMonthError>::eq(p0, p1);
-----------------
src/month.rs <month::ParseMonthError as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::ParseMonthError
+p0.assert_receiver_is_total_eq();
+<month::ParseMonthError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<month::ParseMonthError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<month::ParseMonthError>::assert_receiver_is_total_eq(p0);
-----------------
src/month.rs <month::ParseMonthError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::ParseMonthError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<month::ParseMonthError as std::fmt::Debug>::fmt(p0, p1);
+crate::<month::ParseMonthError as std::fmt::Debug>::fmt(p0, p1);
+<month::ParseMonthError>::fmt(p0, p1);
-----------------
src/lib.rs <OutOfRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // OutOfRange
+p0.clone();
+<OutOfRange as std::clone::Clone>::clone(p0);
+crate::<OutOfRange as std::clone::Clone>::clone(p0);
+<OutOfRange>::clone(p0);
-----------------
src/lib.rs <OutOfRange as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<OutOfRange as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<OutOfRange as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>","std::hash::SipHasher13","std::hash::SipHasher","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // OutOfRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<OutOfRange as std::hash::Hash>::hash(p0, p1);
+crate::<OutOfRange as std::hash::Hash>::hash(p0, p1);
+<OutOfRange>::hash(p0, p1);
-----------------
src/lib.rs <OutOfRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // OutOfRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // OutOfRange
+p0.eq(p1);
+<OutOfRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<OutOfRange as std::cmp::PartialEq>::eq(p0, p1);
+<OutOfRange>::eq(p0, p1);
-----------------
src/lib.rs <OutOfRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // OutOfRange
+p0.assert_receiver_is_total_eq();
+<OutOfRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<OutOfRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<OutOfRange>::assert_receiver_is_total_eq(p0);
-----------------
src/lib.rs OutOfRange::new
deps:{}
candidates:{}
+OutOfRange::new();
+crate::OutOfRange::new();
+<OutOfRange>::new();
-----------------
src/lib.rs <OutOfRange as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // OutOfRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<OutOfRange as std::fmt::Display>::fmt(p0, p1);
+crate::<OutOfRange as std::fmt::Display>::fmt(p0, p1);
+<OutOfRange>::fmt(p0, p1);
-----------------
src/lib.rs <OutOfRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // OutOfRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<OutOfRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<OutOfRange as std::fmt::Debug>::fmt(p0, p1);
+<OutOfRange>::fmt(p0, p1);