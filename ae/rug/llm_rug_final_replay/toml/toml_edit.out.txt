-----------------
crates/toml_datetime/src/datetime.rs datetime::digit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::str::Chars<'_>
+datetime::digit(p0);
+crate::datetime::digit(p0);
+crate::datetime::digit(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.eq(p1);
+<datetime::Datetime as std::cmp::PartialEq>::eq(p0, p1);
+crate::<datetime::Datetime as std::cmp::PartialEq>::eq(p0, p1);
+<datetime::Datetime>::eq(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.assert_receiver_is_total_eq();
+<datetime::Datetime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<datetime::Datetime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<datetime::Datetime>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.partial_cmp(p1);
+<datetime::Datetime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<datetime::Datetime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<datetime::Datetime>::partial_cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.cmp(p1);
+<datetime::Datetime as std::cmp::Ord>::cmp(p0, p1);
+crate::<datetime::Datetime as std::cmp::Ord>::cmp(p0, p1);
+<datetime::Datetime>::cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
+p0.clone();
+<datetime::Datetime as std::clone::Clone>::clone(p0);
+crate::<datetime::Datetime as std::clone::Clone>::clone(p0);
+<datetime::Datetime>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::Datetime as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::Datetime as std::fmt::Debug>::fmt(p0, p1);
+<datetime::Datetime>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::DatetimeParseError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DatetimeParseError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::DatetimeParseError as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::DatetimeParseError as std::fmt::Debug>::fmt(p0, p1);
+<datetime::DatetimeParseError>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::DatetimeParseError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DatetimeParseError
+p0.clone();
+<datetime::DatetimeParseError as std::clone::Clone>::clone(p0);
+crate::<datetime::DatetimeParseError as std::clone::Clone>::clone(p0);
+<datetime::DatetimeParseError>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.eq(p1);
+<datetime::Date as std::cmp::PartialEq>::eq(p0, p1);
+crate::<datetime::Date as std::cmp::PartialEq>::eq(p0, p1);
+<datetime::Date>::eq(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.assert_receiver_is_total_eq();
+<datetime::Date as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<datetime::Date as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<datetime::Date>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.partial_cmp(p1);
+<datetime::Date as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<datetime::Date as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<datetime::Date>::partial_cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.cmp(p1);
+<datetime::Date as std::cmp::Ord>::cmp(p0, p1);
+crate::<datetime::Date as std::cmp::Ord>::cmp(p0, p1);
+<datetime::Date>::cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
+p0.clone();
+<datetime::Date as std::clone::Clone>::clone(p0);
+crate::<datetime::Date as std::clone::Clone>::clone(p0);
+<datetime::Date>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::Date as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::Date as std::fmt::Debug>::fmt(p0, p1);
+<datetime::Date>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.eq(p1);
+<datetime::Time as std::cmp::PartialEq>::eq(p0, p1);
+crate::<datetime::Time as std::cmp::PartialEq>::eq(p0, p1);
+<datetime::Time>::eq(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.assert_receiver_is_total_eq();
+<datetime::Time as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<datetime::Time as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<datetime::Time>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.partial_cmp(p1);
+<datetime::Time as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<datetime::Time as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<datetime::Time>::partial_cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.cmp(p1);
+<datetime::Time as std::cmp::Ord>::cmp(p0, p1);
+crate::<datetime::Time as std::cmp::Ord>::cmp(p0, p1);
+<datetime::Time>::cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
+p0.clone();
+<datetime::Time as std::clone::Clone>::clone(p0);
+crate::<datetime::Time as std::clone::Clone>::clone(p0);
+<datetime::Time>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::Time as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::Time as std::fmt::Debug>::fmt(p0, p1);
+<datetime::Time>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.eq(p1);
+<datetime::Offset as std::cmp::PartialEq>::eq(p0, p1);
+crate::<datetime::Offset as std::cmp::PartialEq>::eq(p0, p1);
+<datetime::Offset>::eq(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.assert_receiver_is_total_eq();
+<datetime::Offset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<datetime::Offset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<datetime::Offset>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.partial_cmp(p1);
+<datetime::Offset as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<datetime::Offset as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<datetime::Offset>::partial_cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.cmp(p1);
+<datetime::Offset as std::cmp::Ord>::cmp(p0, p1);
+crate::<datetime::Offset as std::cmp::Ord>::cmp(p0, p1);
+<datetime::Offset>::cmp(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
+p0.clone();
+<datetime::Offset as std::clone::Clone>::clone(p0);
+crate::<datetime::Offset as std::clone::Clone>::clone(p0);
+<datetime::Offset>::clone(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<datetime::Offset as std::fmt::Debug>::fmt(p0, p1);
+crate::<datetime::Offset as std::fmt::Debug>::fmt(p0, p1);
+<datetime::Offset>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::convert::From<datetime::Date>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::Date
+<datetime::Datetime as std::convert::From<datetime::Date>>::from(p0);
+crate::<datetime::Datetime as std::convert::From<datetime::Date>>::from(p0);
+<datetime::Datetime>::from(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::convert::From<datetime::Time>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // datetime::Time
+<datetime::Datetime as std::convert::From<datetime::Time>>::from(p0);
+crate::<datetime::Datetime as std::convert::From<datetime::Time>>::from(p0);
+<datetime::Datetime>::from(p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Datetime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::Datetime as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::Datetime as std::fmt::Display>::fmt(p0, p1);
+<datetime::Datetime>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Date as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Date
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::Date as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::Date as std::fmt::Display>::fmt(p0, p1);
+<datetime::Date>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Time as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Time
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::Time as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::Time as std::fmt::Display>::fmt(p0, p1);
+<datetime::Time>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Offset as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::Offset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::Offset as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::Offset as std::fmt::Display>::fmt(p0, p1);
+<datetime::Offset>::fmt(p0, p1);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::Datetime as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<datetime::Datetime as std::str::FromStr>::from_str(&p0);
+crate::<datetime::Datetime as std::str::FromStr>::from_str(&p0);
+<datetime::Datetime>::from_str(&p0);
-----------------
crates/toml_datetime/src/datetime.rs <datetime::DatetimeParseError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // datetime::DatetimeParseError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<datetime::DatetimeParseError as std::fmt::Display>::fmt(p0, p1);
+crate::<datetime::DatetimeParseError as std::fmt::Display>::fmt(p0, p1);
+<datetime::DatetimeParseError>::fmt(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::decorate_array
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+array::decorate_array(p0);
+crate::array::decorate_array(p0);
+crate::array::decorate_array(p0);
-----------------
crates/toml_edit/src/encode.rs encode::visit_nested_tables
't
deps:{"encode::visit_nested_tables":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"encode::visit_nested_tables":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = true; // None+bool
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // F
+encode::visit_nested_tables(p0, p1, p2, p3);
+crate::encode::visit_nested_tables(p0, p1, p2, p3);
+crate::encode::visit_nested_tables(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs encode::visit_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p2 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p3 = & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p4 = true; // None+bool
let mut p5 = &mut true; // None+bool
+encode::visit_table(p0, p1, p2, p3, p4, p5);
+crate::encode::visit_table(p0, p1, p2, p3, p4, p5);
+crate::encode::visit_table(p0, p1, p2, p3, p4, p5);
-----------------
crates/toml_edit/src/encode.rs encode::to_string_repr
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<encode::StringStyle>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<bool>
+encode::to_string_repr(&p0, p1, p2);
+crate::encode::to_string_repr(&p0, p1, p2);
+crate::encode::to_string_repr(&p0, p1, p2);
-----------------
crates/toml_edit/src/encode.rs encode::infer_style
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+encode::infer_style(&p0);
+crate::encode::infer_style(&p0);
+crate::encode::infer_style(&p0);
-----------------
crates/toml_edit/src/encode.rs encode::to_f64_repr
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+encode::to_f64_repr(p0);
+crate::encode::to_f64_repr(p0);
+crate::encode::to_f64_repr(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::decorate_inline_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+inline_table::decorate_inline_table(p0);
+crate::inline_table::decorate_inline_table(p0);
+crate::inline_table::decorate_inline_table(p0);
-----------------
crates/toml_edit/src/item.rs item::value
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"item::value":{"V":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"item::value":{"V":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // V
+item::value(p0);
+crate::item::value(p0);
+crate::item::value(p0);
-----------------
crates/toml_edit/src/item.rs item::table
deps:{}
candidates:{}
+item::table();
+crate::item::table();
+crate::item::table();
-----------------
crates/toml_edit/src/item.rs item::array
deps:{}
candidates:{}
+item::array();
+crate::item::array();
+crate::item::array();
-----------------
crates/toml_edit/src/key.rs key::to_key_repr
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+key::to_key_repr(&p0);
+crate::key::to_key_repr(&p0);
+crate::key::to_key_repr(&p0);
-----------------
crates/toml_edit/src/parser/array.rs parser::array::array
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::array::array(p0);
+crate::parser::array::array(p0);
+crate::parser::array::array(p0);
-----------------
crates/toml_edit/src/parser/array.rs parser::array::array_values
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::array::array_values(p0);
+crate::parser::array::array_values(p0);
+crate::parser::array::array_values(p0);
-----------------
crates/toml_edit/src/parser/array.rs parser::array::array_value
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::array::array_value(p0);
+crate::parser::array::array_value(p0);
+crate::parser::array::array_value(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::date_time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::date_time(p0);
+crate::parser::datetime::date_time(p0);
+crate::parser::datetime::date_time(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::full_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::full_date(p0);
+crate::parser::datetime::full_date(p0);
+crate::parser::datetime::full_date(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::partial_time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::partial_time(p0);
+crate::parser::datetime::partial_time(p0);
+crate::parser::datetime::partial_time(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_offset
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_offset(p0);
+crate::parser::datetime::time_offset(p0);
+crate::parser::datetime::time_offset(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::date_fullyear
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::date_fullyear(p0);
+crate::parser::datetime::date_fullyear(p0);
+crate::parser::datetime::date_fullyear(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::date_month
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::date_month(p0);
+crate::parser::datetime::date_month(p0);
+crate::parser::datetime::date_month(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::date_mday
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::date_mday(p0);
+crate::parser::datetime::date_mday(p0);
+crate::parser::datetime::date_mday(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_delim
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_delim(p0);
+crate::parser::datetime::time_delim(p0);
+crate::parser::datetime::time_delim(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_hour
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_hour(p0);
+crate::parser::datetime::time_hour(p0);
+crate::parser::datetime::time_hour(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_minute
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_minute(p0);
+crate::parser::datetime::time_minute(p0);
+crate::parser::datetime::time_minute(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_second
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_second(p0);
+crate::parser::datetime::time_second(p0);
+crate::parser::datetime::time_second(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::time_secfrac
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::time_secfrac(p0);
+crate::parser::datetime::time_secfrac(p0);
+crate::parser::datetime::time_secfrac(p0);
-----------------
crates/toml_edit/src/parser/datetime.rs parser::datetime::unsigned_digits
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::datetime::unsigned_digits(p0);
+crate::parser::datetime::unsigned_digits(p0);
+crate::parser::datetime::unsigned_digits(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::document
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::document::document(p0);
+crate::parser::document::document(p0);
+crate::parser::document::document(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::parse_comment
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::document::parse_comment(p0);
+crate::parser::document::parse_comment(p0);
+crate::parser::document::parse_comment(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::parse_ws
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::document::parse_ws(p0);
+crate::parser::document::parse_ws(p0);
+crate::parser::document::parse_ws(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::parse_newline
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::document::parse_newline(p0);
+crate::parser::document::parse_newline(p0);
+crate::parser::document::parse_newline(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::keyval
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::document::keyval(p0);
+crate::parser::document::keyval(p0);
+crate::parser::document::keyval(p0);
-----------------
crates/toml_edit/src/parser/document.rs parser::document::parse_keyval
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::document::parse_keyval(p0);
+crate::parser::document::parse_keyval(p0);
+crate::parser::document::parse_keyval(p0);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::translate_position
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
+parser::errors::translate_position(p0, p1);
+crate::parser::errors::translate_position(p0, p1);
+crate::parser::errors::translate_position(p0, p1);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::inline_table
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::inline_table::inline_table(p0);
+crate::parser::inline_table::inline_table(p0);
+crate::parser::inline_table::inline_table(p0);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::table_from_pairs
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<(std::vec::Vec<key::Key>, table::TableKeyValue)>
let mut p1 = MaybeUninit::uninit().assume_init(); // raw_string::RawString
+parser::inline_table::table_from_pairs(p0, p1);
+crate::parser::inline_table::table_from_pairs(p0, p1);
+crate::parser::inline_table::table_from_pairs(p0, p1);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::descend_path
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // [key::Key]
+parser::inline_table::descend_path(p0, p1);
+crate::parser::inline_table::descend_path(p0, p1);
+crate::parser::inline_table::descend_path(p0, p1);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::inline_table_keyvals
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::inline_table::inline_table_keyvals(p0);
+crate::parser::inline_table::inline_table_keyvals(p0);
+crate::parser::inline_table::inline_table_keyvals(p0);
-----------------
crates/toml_edit/src/parser/inline_table.rs parser::inline_table::keyval
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::inline_table::keyval(p0);
+crate::parser::inline_table::keyval(p0);
+crate::parser::inline_table::keyval(p0);
-----------------
crates/toml_edit/src/parser/key.rs parser::key::key
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::key::key(p0);
+crate::parser::key::key(p0);
+crate::parser::key::key(p0);
-----------------
crates/toml_edit/src/parser/key.rs parser::key::simple_key
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::key::simple_key(p0);
+crate::parser::key::simple_key(p0);
+crate::parser::key::simple_key(p0);
-----------------
crates/toml_edit/src/parser/key.rs parser::key::unquoted_key
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::key::unquoted_key(p0);
+crate::parser::key::unquoted_key(p0);
+crate::parser::key::unquoted_key(p0);
-----------------
crates/toml_edit/src/parser/key.rs parser::key::is_unquoted_char
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+parser::key::is_unquoted_char(p0);
+crate::parser::key::is_unquoted_char(p0);
+crate::parser::key::is_unquoted_char(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::boolean
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::boolean(p0);
+crate::parser::numbers::boolean(p0);
+crate::parser::numbers::boolean(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::true_
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::true_(p0);
+crate::parser::numbers::true_(p0);
+crate::parser::numbers::true_(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::false_
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::false_(p0);
+crate::parser::numbers::false_(p0);
+crate::parser::numbers::false_(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::integer
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::integer(p0);
+crate::parser::numbers::integer(p0);
+crate::parser::numbers::integer(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::dec_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::dec_int(p0);
+crate::parser::numbers::dec_int(p0);
+crate::parser::numbers::dec_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::hex_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::hex_int(p0);
+crate::parser::numbers::hex_int(p0);
+crate::parser::numbers::hex_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::oct_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::oct_int(p0);
+crate::parser::numbers::oct_int(p0);
+crate::parser::numbers::oct_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::bin_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::bin_int(p0);
+crate::parser::numbers::bin_int(p0);
+crate::parser::numbers::bin_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::float
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::float(p0);
+crate::parser::numbers::float(p0);
+crate::parser::numbers::float(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::float_
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::float_(p0);
+crate::parser::numbers::float_(p0);
+crate::parser::numbers::float_(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::frac
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::frac(p0);
+crate::parser::numbers::frac(p0);
+crate::parser::numbers::frac(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::zero_prefixable_int
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::zero_prefixable_int(p0);
+crate::parser::numbers::zero_prefixable_int(p0);
+crate::parser::numbers::zero_prefixable_int(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::exp
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::exp(p0);
+crate::parser::numbers::exp(p0);
+crate::parser::numbers::exp(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::special_float
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::special_float(p0);
+crate::parser::numbers::special_float(p0);
+crate::parser::numbers::special_float(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::inf
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::inf(p0);
+crate::parser::numbers::inf(p0);
+crate::parser::numbers::inf(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::nan
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::nan(p0);
+crate::parser::numbers::nan(p0);
+crate::parser::numbers::nan(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::digit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::digit(p0);
+crate::parser::numbers::digit(p0);
+crate::parser::numbers::digit(p0);
-----------------
crates/toml_edit/src/parser/numbers.rs parser::numbers::hexdig
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::numbers::hexdig(p0);
+crate::parser::numbers::hexdig(p0);
+crate::parser::numbers::hexdig(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::string(p0);
+crate::parser::strings::string(p0);
+crate::parser::strings::string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::basic_string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::basic_string(p0);
+crate::parser::strings::basic_string(p0);
+crate::parser::strings::basic_string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::basic_chars
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::basic_chars(p0);
+crate::parser::strings::basic_chars(p0);
+crate::parser::strings::basic_chars(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::escaped
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::escaped(p0);
+crate::parser::strings::escaped(p0);
+crate::parser::strings::escaped(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::escape_seq_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::escape_seq_char(p0);
+crate::parser::strings::escape_seq_char(p0);
+crate::parser::strings::escape_seq_char(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::hexescape
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::hexescape(p0);
+crate::parser::strings::hexescape(p0);
+crate::parser::strings::hexescape(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::ml_basic_string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::ml_basic_string(p0);
+crate::parser::strings::ml_basic_string(p0);
+crate::parser::strings::ml_basic_string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::ml_basic_body
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::ml_basic_body(p0);
+crate::parser::strings::ml_basic_body(p0);
+crate::parser::strings::ml_basic_body(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mlb_content
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::mlb_content(p0);
+crate::parser::strings::mlb_content(p0);
+crate::parser::strings::mlb_content(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mlb_quotes
'i
deps:{"<F as winnow::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"parser::strings::mlb_quotes":{"impl winnow::Parser<Input<'i>, (), ParserError<'i>>":["winnow::Parser","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as winnow::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte"]},"parser::strings::mlb_quotes":{"impl winnow::Parser<Input<'i>, (), ParserError<'i>>":["<F as winnow::Parser<I, O, E>>","u8","char"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl winnow::Parser<Input<'i>, (), ParserError<'i>>
+parser::strings::mlb_quotes(p0);
+crate::parser::strings::mlb_quotes(p0);
+crate::parser::strings::mlb_quotes(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mlb_escaped_nl
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::mlb_escaped_nl(p0);
+crate::parser::strings::mlb_escaped_nl(p0);
+crate::parser::strings::mlb_escaped_nl(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::literal_string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::literal_string(p0);
+crate::parser::strings::literal_string(p0);
+crate::parser::strings::literal_string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::ml_literal_string
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::ml_literal_string(p0);
+crate::parser::strings::ml_literal_string(p0);
+crate::parser::strings::ml_literal_string(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::ml_literal_body
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::ml_literal_body(p0);
+crate::parser::strings::ml_literal_body(p0);
+crate::parser::strings::ml_literal_body(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mll_content
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::strings::mll_content(p0);
+crate::parser::strings::mll_content(p0);
+crate::parser::strings::mll_content(p0);
-----------------
crates/toml_edit/src/parser/strings.rs parser::strings::mll_quotes
'i
deps:{"<F as winnow::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"parser::strings::mll_quotes":{"impl winnow::Parser<Input<'i>, (), ParserError<'i>>":["winnow::Parser","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as winnow::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>"]},"parser::strings::mll_quotes":{"impl winnow::Parser<Input<'i>, (), ParserError<'i>>":["<F as winnow::Parser<I, O, E>>","char","u8"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl winnow::Parser<Input<'i>, (), ParserError<'i>>
+parser::strings::mll_quotes(p0);
+crate::parser::strings::mll_quotes(p0);
+crate::parser::strings::mll_quotes(p0);
-----------------
crates/toml_edit/src/parser/table.rs parser::table::std_table
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::table::std_table(p0);
+crate::parser::table::std_table(p0);
+crate::parser::table::std_table(p0);
-----------------
crates/toml_edit/src/parser/table.rs parser::table::array_table
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::table::array_table(p0);
+crate::parser::table::array_table(p0);
+crate::parser::table::array_table(p0);
-----------------
crates/toml_edit/src/parser/table.rs parser::table::table
'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<parser::state::ParseState>
+parser::table::table(p0);
+crate::parser::table::table(p0);
+crate::parser::table::table(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::from_utf8_unchecked
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = "sample"; // None+&str
+parser::trivia::from_utf8_unchecked(p0, &p1);
+crate::parser::trivia::from_utf8_unchecked(p0, &p1);
+crate::parser::trivia::from_utf8_unchecked(p0, &p1);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::ws
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::ws(p0);
+crate::parser::trivia::ws(p0);
+crate::parser::trivia::ws(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::comment
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::comment(p0);
+crate::parser::trivia::comment(p0);
+crate::parser::trivia::comment(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::newline
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::newline(p0);
+crate::parser::trivia::newline(p0);
+crate::parser::trivia::newline(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::ws_newline
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::ws_newline(p0);
+crate::parser::trivia::ws_newline(p0);
+crate::parser::trivia::ws_newline(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::ws_newlines
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::ws_newlines(p0);
+crate::parser::trivia::ws_newlines(p0);
+crate::parser::trivia::ws_newlines(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::ws_comment_newline
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::ws_comment_newline(p0);
+crate::parser::trivia::ws_comment_newline(p0);
+crate::parser::trivia::ws_comment_newline(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::line_ending
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::line_ending(p0);
+crate::parser::trivia::line_ending(p0);
+crate::parser::trivia::line_ending(p0);
-----------------
crates/toml_edit/src/parser/trivia.rs parser::trivia::line_trailing
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::trivia::line_trailing(p0);
+crate::parser::trivia::line_trailing(p0);
+crate::parser::trivia::line_trailing(p0);
-----------------
crates/toml_edit/src/parser/value.rs parser::value::value
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+parser::value::value(p0);
+crate::parser::value::value(p0);
+crate::parser::value::value(p0);
-----------------
crates/toml_edit/src/parser/value.rs parser::value::apply_raw
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+parser::value::apply_raw(p0, p1);
+crate::parser::value::apply_raw(p0, p1);
+crate::parser::value::apply_raw(p0, p1);
-----------------
crates/toml_edit/src/parser/mod.rs parser::parse_document
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::parse_document(&p0);
+crate::parser::parse_document(&p0);
+crate::parser::parse_document(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::parse_key
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::parse_key(&p0);
+crate::parser::parse_key(&p0);
+crate::parser::parse_key(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::parse_key_path
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::parse_key_path(&p0);
+crate::parser::parse_key_path(&p0);
+crate::parser::parse_key_path(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::parse_value
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::parse_value(&p0);
+crate::parser::parse_value(&p0);
+crate::parser::parse_value(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::new_input
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::prelude::new_input(&p0);
+crate::parser::prelude::new_input(&p0);
+crate::parser::prelude::new_input(&p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::ok_error
deps:{"parser::prelude::ok_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]}}
candidates:{"parser::prelude::ok_error":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<(I, O), winnow::error::ErrMode<E>>
+parser::prelude::ok_error(p0);
+crate::parser::prelude::ok_error(p0);
+crate::parser::prelude::ok_error(p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::trace
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as winnow::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"parser::prelude::trace":{"E":["std::fmt::Debug","std::marker::Sized"],"I":["std::marker::Sized","std::fmt::Debug"],"O":["std::fmt::Debug","std::marker::Sized"],"impl std::fmt::Display":["std::fmt::Display","std::marker::Sized"],"impl winnow::Parser<I, O, E>":["winnow::Parser","std::marker::Sized"]},"repr::Formatted":{"T":["std::hash::Hash","std::fmt::Debug","repr::ValueRepr","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as winnow::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault"]},"parser::prelude::trace":{"E":["parser::prelude::RecursionCheck","inline_table::InlineTable","array::Array","table::TableKeyValue","document::Document","table::Table","encode::StringStyle","repr::Formatted","parser::errors::Context","<*mut T as std::fmt::Debug>","value::Value","parser::errors::ParserError","key::Key","repr::Decor","internal_string::InternalString","raw_string::RawString","item::Item","parser::errors::CustomError","repr::Repr","parser::errors::TomlError","parser::errors::ParserValue","key::KeyMut","array_of_tables::ArrayOfTables"],"I":["parser::errors::ParserValue","array_of_tables::ArrayOfTables","parser::errors::CustomError","table::TableKeyValue","encode::StringStyle","raw_string::RawString","key::Key","parser::errors::TomlError","repr::Repr","array::Array","inline_table::InlineTable","parser::errors::ParserError","repr::Decor","document::Document","<&T as std::fmt::Debug>","parser::prelude::RecursionCheck","<&mut T as std::fmt::Debug>","table::Table","item::Item","value::Value","repr::Formatted","key::KeyMut","parser::errors::Context","internal_string::InternalString"],"O":["internal_string::InternalString","document::Document","repr::Formatted","parser::prelude::RecursionCheck","parser::errors::ParserValue","encode::StringStyle","item::Item","key::KeyMut","table::Table","parser::errors::ParserError","key::Key","parser::errors::TomlError","<*mut T as std::fmt::Debug>","inline_table::InlineTable","raw_string::RawString","repr::Decor","parser::errors::Context","array_of_tables::ArrayOfTables","value::Value","array::Array","parser::errors::CustomError","repr::Repr","table::TableKeyValue"],"impl std::fmt::Display":["array::Array","parser::errors::CustomError","value::Value","<&T as std::fmt::Display>","array_of_tables::ArrayOfTables","parser::errors::ParserError","item::Item","parser::errors::TomlError","table::Table","inline_table::InlineTable","key::Key","internal_string::InternalString","repr::Formatted","key::KeyMut","document::Document","<&mut T as std::fmt::Display>","parser::errors::ParserValue"],"impl winnow::Parser<I, O, E>":["u8","<F as winnow::Parser<I, O, E>>","char"]},"repr::Formatted":{"T":[]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl std::fmt::Display
let mut p1 = MaybeUninit::uninit().assume_init(); // impl winnow::Parser<I, O, E>
+parser::prelude::trace(p0, p1);
+crate::parser::prelude::trace(p0, p1);
+crate::parser::prelude::trace(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::decorate_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+table::decorate_table(p0);
+crate::table::decorate_table(p0);
+crate::table::decorate_table(p0);
-----------------
crates/toml_edit/src/visit.rs visit::visit_document
'doc
deps:{"visit::visit_document":{"V":["visit::Visit"]}}
candidates:{"visit::visit_document":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // document::Document
+visit::visit_document(p0, p1);
+crate::visit::visit_document(p0, p1);
+crate::visit::visit_document(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_item
'doc
deps:{"visit::visit_item":{"V":["visit::Visit"]}}
candidates:{"visit::visit_item":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+visit::visit_item(p0, p1);
+crate::visit::visit_item(p0, p1);
+crate::visit::visit_item(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_table
'doc
deps:{"visit::visit_table":{"V":["visit::Visit"]}}
candidates:{"visit::visit_table":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // table::Table
+visit::visit_table(p0, p1);
+crate::visit::visit_table(p0, p1);
+crate::visit::visit_table(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_inline_table
'doc
deps:{"visit::visit_inline_table":{"V":["visit::Visit"]}}
candidates:{"visit::visit_inline_table":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+visit::visit_inline_table(p0, p1);
+crate::visit::visit_inline_table(p0, p1);
+crate::visit::visit_inline_table(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_table_like
'doc
deps:{"visit::visit_table_like":{"V":["visit::Visit"]}}
candidates:{"visit::visit_table_like":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // (dyn table::TableLike + 'doc)
+visit::visit_table_like(p0, p1);
+crate::visit::visit_table_like(p0, p1);
+crate::visit::visit_table_like(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_table_like_kv
'doc
deps:{"visit::visit_table_like_kv":{"V":["visit::Visit"]}}
candidates:{"visit::visit_table_like_kv":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // item::Item
+visit::visit_table_like_kv(p0, &p1, p2);
+crate::visit::visit_table_like_kv(p0, &p1, p2);
+crate::visit::visit_table_like_kv(p0, &p1, p2);
-----------------
crates/toml_edit/src/visit.rs visit::visit_array
'doc
deps:{"visit::visit_array":{"V":["visit::Visit"]}}
candidates:{"visit::visit_array":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // array::Array
+visit::visit_array(p0, p1);
+crate::visit::visit_array(p0, p1);
+crate::visit::visit_array(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_array_of_tables
'doc
deps:{"visit::visit_array_of_tables":{"V":["visit::Visit"]}}
candidates:{"visit::visit_array_of_tables":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+visit::visit_array_of_tables(p0, p1);
+crate::visit::visit_array_of_tables(p0, p1);
+crate::visit::visit_array_of_tables(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_value
'doc
deps:{"visit::visit_value":{"V":["visit::Visit"]}}
candidates:{"visit::visit_value":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+visit::visit_value(p0, p1);
+crate::visit::visit_value(p0, p1);
+crate::visit::visit_value(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_boolean
'doc
deps:{"visit::visit_boolean":{"V":["visit::Visit"]}}
candidates:{"visit::visit_boolean":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<bool>
+visit::visit_boolean(p0, p1);
+crate::visit::visit_boolean(p0, p1);
+crate::visit::visit_boolean(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_datetime
'doc
deps:{"visit::visit_datetime":{"V":["visit::Visit"]}}
candidates:{"visit::visit_datetime":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<toml_datetime::Datetime>
+visit::visit_datetime(p0, p1);
+crate::visit::visit_datetime(p0, p1);
+crate::visit::visit_datetime(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_float
'doc
deps:{"visit::visit_float":{"V":["visit::Visit"]}}
candidates:{"visit::visit_float":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<f64>
+visit::visit_float(p0, p1);
+crate::visit::visit_float(p0, p1);
+crate::visit::visit_float(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_integer
'doc
deps:{"visit::visit_integer":{"V":["visit::Visit"]}}
candidates:{"visit::visit_integer":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<i64>
+visit::visit_integer(p0, p1);
+crate::visit::visit_integer(p0, p1);
+crate::visit::visit_integer(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::visit_string
'doc
deps:{"visit::visit_string":{"V":["visit::Visit"]}}
candidates:{"visit::visit_string":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = & std::string::String::new(); // None+repr::Formatted<std::string::String>
+visit::visit_string(p0, p1);
+crate::visit::visit_string(p0, p1);
+crate::visit::visit_string(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_document_mut
deps:{"visit_mut::visit_document_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_document_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+visit_mut::visit_document_mut(p0, p1);
+crate::visit_mut::visit_document_mut(p0, p1);
+crate::visit_mut::visit_document_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_item_mut
deps:{"visit_mut::visit_item_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_item_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+visit_mut::visit_item_mut(p0, p1);
+crate::visit_mut::visit_item_mut(p0, p1);
+crate::visit_mut::visit_item_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_table_mut
deps:{"visit_mut::visit_table_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_table_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+visit_mut::visit_table_mut(p0, p1);
+crate::visit_mut::visit_table_mut(p0, p1);
+crate::visit_mut::visit_table_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_inline_table_mut
deps:{"visit_mut::visit_inline_table_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_inline_table_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+visit_mut::visit_inline_table_mut(p0, p1);
+crate::visit_mut::visit_inline_table_mut(p0, p1);
+crate::visit_mut::visit_inline_table_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_table_like_mut
deps:{"visit_mut::visit_table_like_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_table_like_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn table::TableLike
+visit_mut::visit_table_like_mut(p0, p1);
+crate::visit_mut::visit_table_like_mut(p0, p1);
+crate::visit_mut::visit_table_like_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_table_like_kv_mut
deps:{"visit_mut::visit_table_like_kv_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_table_like_kv_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = MaybeUninit::uninit().assume_init(); // key::KeyMut<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+visit_mut::visit_table_like_kv_mut(p0, p1, p2);
+crate::visit_mut::visit_table_like_kv_mut(p0, p1, p2);
+crate::visit_mut::visit_table_like_kv_mut(p0, p1, p2);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_array_mut
deps:{"visit_mut::visit_array_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_array_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+visit_mut::visit_array_mut(p0, p1);
+crate::visit_mut::visit_array_mut(p0, p1);
+crate::visit_mut::visit_array_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_array_of_tables_mut
deps:{"visit_mut::visit_array_of_tables_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_array_of_tables_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+visit_mut::visit_array_of_tables_mut(p0, p1);
+crate::visit_mut::visit_array_of_tables_mut(p0, p1);
+crate::visit_mut::visit_array_of_tables_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_value_mut
deps:{"visit_mut::visit_value_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_value_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+visit_mut::visit_value_mut(p0, p1);
+crate::visit_mut::visit_value_mut(p0, p1);
+crate::visit_mut::visit_value_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_boolean_mut
deps:{"visit_mut::visit_boolean_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_boolean_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<bool>
+visit_mut::visit_boolean_mut(p0, p1);
+crate::visit_mut::visit_boolean_mut(p0, p1);
+crate::visit_mut::visit_boolean_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_datetime_mut
deps:{"visit_mut::visit_datetime_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_datetime_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<toml_datetime::Datetime>
+visit_mut::visit_datetime_mut(p0, p1);
+crate::visit_mut::visit_datetime_mut(p0, p1);
+crate::visit_mut::visit_datetime_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_float_mut
deps:{"visit_mut::visit_float_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_float_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<f64>
+visit_mut::visit_float_mut(p0, p1);
+crate::visit_mut::visit_float_mut(p0, p1);
+crate::visit_mut::visit_float_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_integer_mut
deps:{"visit_mut::visit_integer_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_integer_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<i64>
+visit_mut::visit_integer_mut(p0, p1);
+crate::visit_mut::visit_integer_mut(p0, p1);
+crate::visit_mut::visit_integer_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::visit_string_mut
deps:{"visit_mut::visit_string_mut":{"V":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::visit_string_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // V
let mut p1 = &mut std::string::String::new(); // None+repr::Formatted<std::string::String>
+visit_mut::visit_string_mut(p0, p1);
+crate::visit_mut::visit_string_mut(p0, p1);
+crate::visit_mut::visit_string_mut(p0, p1);
-----------------
crates/toml_edit/src/encode.rs encode::Encode::encode
deps:{"encode::Encode::encode":{"Self":["encode::Encode"]},"repr::Formatted":{"T":["std::fmt::Debug","repr::ValueRepr","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::hash::Hash","std::cmp::PartialEq"]}}
candidates:{"encode::Encode::encode":{"Self":["repr::Formatted","key::Key","value::Value","inline_table::InlineTable","array::Array"]},"repr::Formatted":{"T":["bool","i64"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+encode::Encode::encode(p0, p1, p2, p3);
+crate::encode::Encode::encode(p0, p1, p2, p3);
+crate::encode::Encode::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/index.rs index::Index::index
deps:{"<&'a T as index::Index>":{},"index::Index::index":{"Self":["index::Index","private::Sealed"]}}
candidates:{"<&'a T as index::Index>":{},"index::Index::index":{"Self":["std::string::String","<&'a T as index::Index>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+index::Index::index(p0, p1);
+crate::index::Index::index(p0, p1);
+crate::index::Index::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs index::Index::index_mut
deps:{"<&'a T as private::Sealed>":{},"index::Index::index_mut":{"Self":["private::Sealed","index::Index"]}}
candidates:{"<&'a T as private::Sealed>":{},"index::Index::index_mut":{"Self":["std::string::String","<&'a T as private::Sealed>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+index::Index::index_mut(p0, p1);
+crate::index::Index::index_mut(p0, p1);
+crate::index::Index::index_mut(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::ValueRepr::to_repr
deps:{"repr::ValueRepr::to_repr":{"Self":["repr::ValueRepr","private::Sealed"]}}
candidates:{"repr::ValueRepr::to_repr":{"Self":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_repr();
+repr::ValueRepr::to_repr(p0);
+crate::repr::ValueRepr::to_repr(p0);
+crate::repr::ValueRepr::to_repr(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::iter
deps:{"table::TableLike::iter":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::iter":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.iter();
+table::TableLike::iter(p0);
+crate::table::TableLike::iter(p0);
+crate::table::TableLike::iter(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::iter_mut
deps:{"table::TableLike::iter_mut":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::iter_mut":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.iter_mut();
+table::TableLike::iter_mut(p0);
+crate::table::TableLike::iter_mut(p0);
+crate::table::TableLike::iter_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::len
deps:{"table::TableLike::len":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::len":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.len();
+table::TableLike::len(p0);
+crate::table::TableLike::len(p0);
+crate::table::TableLike::len(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::is_empty
deps:{"table::TableLike::is_empty":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::is_empty":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_empty();
+table::TableLike::is_empty(p0);
+crate::table::TableLike::is_empty(p0);
+crate::table::TableLike::is_empty(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::clear
deps:{"table::TableLike::clear":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::clear":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.clear();
+table::TableLike::clear(p0);
+crate::table::TableLike::clear(p0);
+crate::table::TableLike::clear(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::entry
deps:{"table::TableLike::entry":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::entry":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.entry(&p1);
+table::TableLike::entry(p0, &p1);
+crate::table::TableLike::entry(p0, &p1);
+crate::table::TableLike::entry(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::entry_format
deps:{"table::TableLike::entry_format":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::entry_format":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+table::TableLike::entry_format(p0, p1);
+crate::table::TableLike::entry_format(p0, p1);
+crate::table::TableLike::entry_format(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get
deps:{"table::TableLike::get":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::get":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+table::TableLike::get(p0, &p1);
+crate::table::TableLike::get(p0, &p1);
+crate::table::TableLike::get(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get_mut
deps:{"table::TableLike::get_mut":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::get_mut":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+table::TableLike::get_mut(p0, &p1);
+crate::table::TableLike::get_mut(p0, &p1);
+crate::table::TableLike::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get_key_value
deps:{"table::TableLike::get_key_value":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::get_key_value":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+table::TableLike::get_key_value(p0, &p1);
+crate::table::TableLike::get_key_value(p0, &p1);
+crate::table::TableLike::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get_key_value_mut
deps:{"table::TableLike::get_key_value_mut":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::get_key_value_mut":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+table::TableLike::get_key_value_mut(p0, &p1);
+crate::table::TableLike::get_key_value_mut(p0, &p1);
+crate::table::TableLike::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::contains_key
deps:{"table::TableLike::contains_key":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::contains_key":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+table::TableLike::contains_key(p0, &p1);
+crate::table::TableLike::contains_key(p0, &p1);
+crate::table::TableLike::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::insert
deps:{"table::TableLike::insert":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::insert":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(&p1, p2);
+table::TableLike::insert(p0, &p1, p2);
+crate::table::TableLike::insert(p0, &p1, p2);
+crate::table::TableLike::insert(p0, &p1, p2);
-----------------
crates/toml_edit/src/table.rs table::TableLike::remove
deps:{"table::TableLike::remove":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::remove":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+table::TableLike::remove(p0, &p1);
+crate::table::TableLike::remove(p0, &p1);
+crate::table::TableLike::remove(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::get_values
deps:{"table::TableLike::get_values":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::get_values":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.get_values();
+table::TableLike::get_values(p0);
+crate::table::TableLike::get_values(p0);
+crate::table::TableLike::get_values(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::fmt
deps:{"table::TableLike::fmt":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::fmt":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.fmt();
+table::TableLike::fmt(p0);
+crate::table::TableLike::fmt(p0);
+crate::table::TableLike::fmt(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::sort_values
deps:{"table::TableLike::sort_values":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::sort_values":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.sort_values();
+table::TableLike::sort_values(p0);
+crate::table::TableLike::sort_values(p0);
+crate::table::TableLike::sort_values(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::set_dotted
deps:{"table::TableLike::set_dotted":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::set_dotted":{"Self":["table::Table","inline_table::InlineTable"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+table::TableLike::set_dotted(p0, p1);
+crate::table::TableLike::set_dotted(p0, p1);
+crate::table::TableLike::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::is_dotted
deps:{"table::TableLike::is_dotted":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::is_dotted":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_dotted();
+table::TableLike::is_dotted(p0);
+crate::table::TableLike::is_dotted(p0);
+crate::table::TableLike::is_dotted(p0);
-----------------
crates/toml_edit/src/table.rs table::TableLike::key_decor_mut
deps:{"table::TableLike::key_decor_mut":{"Self":["table::TableLike","private::Sealed"]}}
candidates:{"table::TableLike::key_decor_mut":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+table::TableLike::key_decor_mut(p0, &p1);
+crate::table::TableLike::key_decor_mut(p0, &p1);
+crate::table::TableLike::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::TableLike::key_decor
deps:{"table::TableLike::key_decor":{"Self":["private::Sealed","table::TableLike"]}}
candidates:{"table::TableLike::key_decor":{"Self":["inline_table::InlineTable","table::Table"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+table::TableLike::key_decor(p0, &p1);
+crate::table::TableLike::key_decor(p0, &p1);
+crate::table::TableLike::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_document
'doc
deps:{"visit::Visit::visit_document":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_document":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.visit_document(p1);
+visit::Visit::visit_document(p0, p1);
+crate::visit::Visit::visit_document(p0, p1);
+crate::visit::Visit::visit_document(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_item
'doc
deps:{"visit::Visit::visit_item":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_item":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.visit_item(p1);
+visit::Visit::visit_item(p0, p1);
+crate::visit::Visit::visit_item(p0, p1);
+crate::visit::Visit::visit_item(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_table
'doc
deps:{"visit::Visit::visit_table":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_table":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.visit_table(p1);
+visit::Visit::visit_table(p0, p1);
+crate::visit::Visit::visit_table(p0, p1);
+crate::visit::Visit::visit_table(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_inline_table
'doc
deps:{"visit::Visit::visit_inline_table":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_inline_table":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.visit_inline_table(p1);
+visit::Visit::visit_inline_table(p0, p1);
+crate::visit::Visit::visit_inline_table(p0, p1);
+crate::visit::Visit::visit_inline_table(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_table_like
'doc
deps:{"visit::Visit::visit_table_like":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_table_like":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // (dyn table::TableLike + 'doc)
+p0.visit_table_like(p1);
+visit::Visit::visit_table_like(p0, p1);
+crate::visit::Visit::visit_table_like(p0, p1);
+crate::visit::Visit::visit_table_like(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_table_like_kv
'doc
deps:{"visit::Visit::visit_table_like_kv":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_table_like_kv":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.visit_table_like_kv(&p1, p2);
+visit::Visit::visit_table_like_kv(p0, &p1, p2);
+crate::visit::Visit::visit_table_like_kv(p0, &p1, p2);
+crate::visit::Visit::visit_table_like_kv(p0, &p1, p2);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_array
'doc
deps:{"visit::Visit::visit_array":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_array":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.visit_array(p1);
+visit::Visit::visit_array(p0, p1);
+crate::visit::Visit::visit_array(p0, p1);
+crate::visit::Visit::visit_array(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_array_of_tables
'doc
deps:{"visit::Visit::visit_array_of_tables":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_array_of_tables":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.visit_array_of_tables(p1);
+visit::Visit::visit_array_of_tables(p0, p1);
+crate::visit::Visit::visit_array_of_tables(p0, p1);
+crate::visit::Visit::visit_array_of_tables(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_value
'doc
deps:{"visit::Visit::visit_value":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_value":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.visit_value(p1);
+visit::Visit::visit_value(p0, p1);
+crate::visit::Visit::visit_value(p0, p1);
+crate::visit::Visit::visit_value(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_boolean
'doc
deps:{"visit::Visit::visit_boolean":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_boolean":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<bool>
+p0.visit_boolean(p1);
+visit::Visit::visit_boolean(p0, p1);
+crate::visit::Visit::visit_boolean(p0, p1);
+crate::visit::Visit::visit_boolean(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_datetime
'doc
deps:{"visit::Visit::visit_datetime":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_datetime":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<toml_datetime::Datetime>
+p0.visit_datetime(p1);
+visit::Visit::visit_datetime(p0, p1);
+crate::visit::Visit::visit_datetime(p0, p1);
+crate::visit::Visit::visit_datetime(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_float
'doc
deps:{"visit::Visit::visit_float":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_float":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<f64>
+p0.visit_float(p1);
+visit::Visit::visit_float(p0, p1);
+crate::visit::Visit::visit_float(p0, p1);
+crate::visit::Visit::visit_float(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_integer
'doc
deps:{"visit::Visit::visit_integer":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_integer":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<i64>
+p0.visit_integer(p1);
+visit::Visit::visit_integer(p0, p1);
+crate::visit::Visit::visit_integer(p0, p1);
+crate::visit::Visit::visit_integer(p0, p1);
-----------------
crates/toml_edit/src/visit.rs visit::Visit::visit_string
'doc
deps:{"visit::Visit::visit_string":{"Self":["visit::Visit"]}}
candidates:{"visit::Visit::visit_string":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & std::string::String::new(); // None+repr::Formatted<std::string::String>
+p0.visit_string(p1);
+visit::Visit::visit_string(p0, p1);
+crate::visit::Visit::visit_string(p0, p1);
+crate::visit::Visit::visit_string(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_document_mut
deps:{"visit_mut::VisitMut::visit_document_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_document_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.visit_document_mut(p1);
+visit_mut::VisitMut::visit_document_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_document_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_document_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_item_mut
deps:{"visit_mut::VisitMut::visit_item_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_item_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.visit_item_mut(p1);
+visit_mut::VisitMut::visit_item_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_item_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_item_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_table_mut
deps:{"visit_mut::VisitMut::visit_table_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_table_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.visit_table_mut(p1);
+visit_mut::VisitMut::visit_table_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_table_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_table_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_inline_table_mut
deps:{"visit_mut::VisitMut::visit_inline_table_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_inline_table_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.visit_inline_table_mut(p1);
+visit_mut::VisitMut::visit_inline_table_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_inline_table_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_inline_table_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_table_like_mut
deps:{"visit_mut::VisitMut::visit_table_like_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_table_like_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn table::TableLike
+p0.visit_table_like_mut(p1);
+visit_mut::VisitMut::visit_table_like_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_table_like_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_table_like_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_table_like_kv_mut
deps:{"visit_mut::VisitMut::visit_table_like_kv_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_table_like_kv_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // key::KeyMut<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.visit_table_like_kv_mut(p1, p2);
+visit_mut::VisitMut::visit_table_like_kv_mut(p0, p1, p2);
+crate::visit_mut::VisitMut::visit_table_like_kv_mut(p0, p1, p2);
+crate::visit_mut::VisitMut::visit_table_like_kv_mut(p0, p1, p2);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_array_mut
deps:{"visit_mut::VisitMut::visit_array_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_array_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.visit_array_mut(p1);
+visit_mut::VisitMut::visit_array_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_array_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_array_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_array_of_tables_mut
deps:{"visit_mut::VisitMut::visit_array_of_tables_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_array_of_tables_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.visit_array_of_tables_mut(p1);
+visit_mut::VisitMut::visit_array_of_tables_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_array_of_tables_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_array_of_tables_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_value_mut
deps:{"visit_mut::VisitMut::visit_value_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_value_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.visit_value_mut(p1);
+visit_mut::VisitMut::visit_value_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_value_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_value_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_boolean_mut
deps:{"visit_mut::VisitMut::visit_boolean_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_boolean_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<bool>
+p0.visit_boolean_mut(p1);
+visit_mut::VisitMut::visit_boolean_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_boolean_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_boolean_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_datetime_mut
deps:{"visit_mut::VisitMut::visit_datetime_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_datetime_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<toml_datetime::Datetime>
+p0.visit_datetime_mut(p1);
+visit_mut::VisitMut::visit_datetime_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_datetime_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_datetime_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_float_mut
deps:{"visit_mut::VisitMut::visit_float_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_float_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<f64>
+p0.visit_float_mut(p1);
+visit_mut::VisitMut::visit_float_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_float_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_float_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_integer_mut
deps:{"visit_mut::VisitMut::visit_integer_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_integer_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<i64>
+p0.visit_integer_mut(p1);
+visit_mut::VisitMut::visit_integer_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_integer_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_integer_mut(p0, p1);
-----------------
crates/toml_edit/src/visit_mut.rs visit_mut::VisitMut::visit_string_mut
deps:{"visit_mut::VisitMut::visit_string_mut":{"Self":["visit_mut::VisitMut"]}}
candidates:{"visit_mut::VisitMut::visit_string_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut std::string::String::new(); // None+repr::Formatted<std::string::String>
+p0.visit_string_mut(p1);
+visit_mut::VisitMut::visit_string_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_string_mut(p0, p1);
+crate::visit_mut::VisitMut::visit_string_mut(p0, p1);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<array::Array as std::fmt::Debug>::fmt(p0, p1);
+crate::<array::Array as std::fmt::Debug>::fmt(p0, p1);
+<array::Array>::fmt(p0, p1);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::default::Default>::default
deps:{}
candidates:{}
+<array::Array as std::default::Default>::default();
+crate::<array::Array as std::default::Default>::default();
+<array::Array>::default();
-----------------
crates/toml_edit/src/array.rs <array::Array as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.clone();
+<array::Array as std::clone::Clone>::clone(p0);
+crate::<array::Array as std::clone::Clone>::clone(p0);
+<array::Array>::clone(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::new
deps:{}
candidates:{}
+array::Array::new();
+crate::array::Array::new();
+<array::Array>::new();
-----------------
crates/toml_edit/src/array.rs array::Array::with_vec
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<item::Item>
+array::Array::with_vec(p0);
+crate::array::Array::with_vec(p0);
+<array::Array>::with_vec(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.fmt();
+array::Array::fmt(p0);
+crate::array::Array::fmt(p0);
+<array::Array>::fmt(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::set_trailing_comma
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = true; // None+bool
+p0.set_trailing_comma(p1);
+array::Array::set_trailing_comma(p0, p1);
+crate::array::Array::set_trailing_comma(p0, p1);
+<array::Array>::set_trailing_comma(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::trailing_comma
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.trailing_comma();
+array::Array::trailing_comma(p0);
+crate::array::Array::trailing_comma(p0);
+<array::Array>::trailing_comma(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::set_trailing
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"array::Array::set_trailing":{"impl Into<RawString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"array::Array::set_trailing":{"impl Into<RawString>":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_trailing(p1);
+array::Array::set_trailing(p0, p1);
+crate::array::Array::set_trailing(p0, p1);
+<array::Array>::set_trailing(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::trailing
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.trailing();
+array::Array::trailing(p0);
+crate::array::Array::trailing(p0);
+<array::Array>::trailing(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.decor_mut();
+array::Array::decor_mut(p0);
+crate::array::Array::decor_mut(p0);
+<array::Array>::decor_mut(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.decor();
+array::Array::decor(p0);
+crate::array::Array::decor(p0);
+<array::Array>::decor(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.span();
+array::Array::span(p0);
+crate::array::Array::span(p0);
+<array::Array>::span(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+array::Array::despan(p0, &p1);
+crate::array::Array::despan(p0, &p1);
+<array::Array>::despan(p0, &p1);
-----------------
crates/toml_edit/src/array.rs array::Array::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.iter();
+array::Array::iter(p0);
+crate::array::Array::iter(p0);
+<array::Array>::iter(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.iter_mut();
+array::Array::iter_mut(p0);
+crate::array::Array::iter_mut(p0);
+<array::Array>::iter_mut(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.len();
+array::Array::len(p0);
+crate::array::Array::len(p0);
+<array::Array>::len(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.is_empty();
+array::Array::is_empty(p0);
+crate::array::Array::is_empty(p0);
+<array::Array>::is_empty(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
+p0.clear();
+array::Array::clear(p0);
+crate::array::Array::clear(p0);
+<array::Array>::clear(p0);
-----------------
crates/toml_edit/src/array.rs array::Array::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+array::Array::get(p0, p1);
+crate::array::Array::get(p0, p1);
+<array::Array>::get(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
+p0.get_mut(p1);
+array::Array::get_mut(p0, p1);
+crate::array::Array::get_mut(p0, p1);
+<array::Array>::get_mut(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::push
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"array::Array::push":{"V":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"array::Array::push":{"V":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.push(p1);
+array::Array::push(p0, p1);
+crate::array::Array::push(p0, p1);
+<array::Array>::push(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::push_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.push_formatted(p1);
+array::Array::push_formatted(p0, p1);
+crate::array::Array::push_formatted(p0, p1);
+<array::Array>::push_formatted(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::insert
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"array::Array::insert":{"V":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"array::Array::insert":{"V":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.insert(p1, p2);
+array::Array::insert(p0, p1, p2);
+crate::array::Array::insert(p0, p1, p2);
+<array::Array>::insert(p0, p1, p2);
-----------------
crates/toml_edit/src/array.rs array::Array::insert_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert_formatted(p1, p2);
+array::Array::insert_formatted(p0, p1, p2);
+crate::array::Array::insert_formatted(p0, p1, p2);
+<array::Array>::insert_formatted(p0, p1, p2);
-----------------
crates/toml_edit/src/array.rs array::Array::replace
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"array::Array::replace":{"V":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"array::Array::replace":{"V":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.replace(p1, p2);
+array::Array::replace(p0, p1, p2);
+crate::array::Array::replace(p0, p1, p2);
+<array::Array>::replace(p0, p1, p2);
-----------------
crates/toml_edit/src/array.rs array::Array::replace_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.replace_formatted(p1, p2);
+array::Array::replace_formatted(p0, p1, p2);
+crate::array::Array::replace_formatted(p0, p1, p2);
+<array::Array>::replace_formatted(p0, p1, p2);
-----------------
crates/toml_edit/src/array.rs array::Array::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = 0usize; // None+usize
+p0.remove(p1);
+array::Array::remove(p0, p1);
+crate::array::Array::remove(p0, p1);
+<array::Array>::remove(p0, p1);
-----------------
crates/toml_edit/src/array.rs array::Array::value_op
deps:{"array::Array::value_op":{"T":["std::marker::Sized"],"impl FnOnce(&mut Vec<Item>, Value) -> T":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"array::Array::value_op":{"T":["RUG_ANY"],"impl FnOnce(&mut Vec<Item>, Value) -> T":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p2 = true; // None+bool
let mut p3 = MaybeUninit::uninit().assume_init(); // impl FnOnce(&mut Vec<Item>, Value) -> T
+p0.value_op(p1, p2, p3);
+array::Array::value_op(p0, p1, p2, p3);
+crate::array::Array::value_op(p0, p1, p2, p3);
+<array::Array>::value_op(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<array::Array as std::fmt::Display>::fmt(p0, p1);
+crate::<array::Array as std::fmt::Display>::fmt(p0, p1);
+<array::Array>::fmt(p0, p1);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::iter::Extend<V>>::extend
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<array::Array as std::iter::Extend<V>>::extend":{"T":["std::marker::Sized","std::iter::IntoIterator"],"V":["std::marker::Sized","std::convert::Into"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Fuse<I>","std::path::Iter<'a>","std::char::ToLowercase","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::option::Iter<'a, A>","std::sync::mpsc::Iter<'a, T>","std::collections::vec_deque::IterMut<'a, T>","std::io::Split<B>","std::collections::btree_set::Union<'a, T>","std::iter::Inspect<I, F>","std::collections::hash_set::Intersection<'a, T, S>","std::vec::DrainFilter<'_, T, F, A>","std::slice::RChunksExact<'a, T>","std::iter::SkipWhile<I, P>","std::vec::Drain<'_, T, A>","std::ops::index_range::IndexRange","std::iter::IntersperseWith<I, G>","std::path::Ancestors<'a>","std::collections::btree_map::IntoValues<K, V, A>","std::iter::ArrayChunks<I, N>","std::iter::Repeat<A>","std::collections::btree_map::Range<'a, K, V>","std::slice::GroupByMut<'a, T, P>","std::str::RMatchIndices<'a, P>","std::collections::hash_set::DrainFilter<'_, K, F>","std::iter::Peekable<I>","std::iter::Copied<I>","std::collections::hash_set::Difference<'a, T, S>","std::fs::ReadDir","std::slice::RSplit<'a, T, P>","std::process::CommandEnvs<'a>","std::slice::Windows<'a, T>","std::collections::binary_heap::DrainSorted<'_, T>","std::iter::Enumerate<I>","std::collections::linked_list::Iter<'a, T>","std::iter::FlatMap<I, U, F>","std::iter::Map<I, F>","std::iter::Skip<I>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::collections::btree_map::IntoKeys<K, V, A>","std::net::Incoming<'a>","std::sys::unix::os::Env","std::result::Iter<'a, T>","std::collections::hash_set::Drain<'a, K>","std::str::MatchIndices<'a, P>","std::iter::ByRefSized<'_, I>","std::slice::SplitMut<'a, T, P>","std::os::unix::net::ScmCredentials<'a>","std::iter::FilterMap<I, F>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::collections::hash_map::IntoValues<K, V>","std::iter::StepBy<I>","std::string::Drain<'_>","std::char::DecodeUtf16<I>","std::str::EscapeDefault<'a>","std::iter::RepeatN<A>","std::collections::linked_list::IterMut<'a, T>","std::collections::btree_set::Intersection<'a, T, A>","std::iter::Rev<I>","std::process::CommandArgs<'a>","std::iter::sources::from_generator::FromGenerator<G>","std::iter::FromFn<F>","std::os::unix::net::ScmRights<'a>","std::str::LinesAny<'a>","std::collections::binary_heap::Iter<'a, T>","std::iter::Cycle<I>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::collections::btree_map::Keys<'a, K, V>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::collections::hash_map::Values<'a, K, V>","std::io::Lines<B>","core::slice::iter::GenericSplitN<I>","std::iter::Zip<A, B>","std::slice::ArrayChunks<'a, T, N>","std::collections::btree_map::IterMut<'a, K, V>","std::collections::linked_list::DrainFilter<'_, T, F>","std::str::SplitWhitespace<'a>","std::collections::btree_set::Difference<'a, T, A>","std::iter::Cloned<I>","std::collections::binary_heap::IntoIterSorted<T>","std::slice::Chunks<'a, T>","std::collections::hash_set::IntoIter<K>","std::slice::Iter<'a, T>","std::sys::unix::process::process_common::CommandArgs<'a>","std::str::EncodeUtf16<'a>","std::char::EscapeDebug","std::slice::ChunksExact<'a, T>","std::str::RMatches<'a, P>","std::str::Bytes<'_>","std::str::SplitInclusive<'a, P>","std::path::Components<'a>","std::slice::SplitInclusive<'a, T, P>","std::str::SplitN<'a, P>","std::result::IntoIter<T>","std::str::RSplit<'a, P>","std::iter::RepeatWith<F>","std::env::ArgsOs","std::str::RSplitN<'a, P>","std::net::IntoIncoming","std::collections::hash_set::Union<'a, T, S>","std::collections::hash_set::Iter<'a, K>","std::env::VarsOs","std::iter::Flatten<I>","std::iter::Chain<A, B>","std::vec::Splice<'_, I, A>","std::ascii::EscapeDefault","std::str::SplitAsciiWhitespace<'a>","std::collections::btree_set::Iter<'a, T>","std::collections::hash_map::Iter<'a, K, V>","std::env::Args","std::collections::btree_map::Iter<'a, K, V>","std::str::Matches<'a, P>","std::option::IterMut<'a, A>","std::result::IterMut<'a, T>","std::slice::ChunksExactMut<'a, T>","std::env::Vars","std::slice::EscapeAscii<'a>","std::boxed::Box<I, A>","std::iter::TakeWhile<I, P>","std::io::Bytes<R>","std::char::CaseMappingIter","std::collections::btree_set::Range<'a, T>","std::str::Chars<'a>","std::slice::RSplitN<'a, T, P>","std::ops::Range<A>","std::iter::Successors<T, F>","std::slice::RChunks<'a, T>","std::iter::Scan<I, St, F>","std::collections::btree_map::Values<'a, K, V>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::str::EscapeDebug<'a>","std::iter::OnceWith<F>","std::ops::RangeInclusive<A>","std::sys_common::wstr::WStrUnits<'_>","std::sys::unix::args::Args","std::str::RSplitTerminator<'a, P>","std::iter::Filter<I, P>","std::char::EscapeUnicode","std::collections::vec_deque::Iter<'a, T>","std::collections::vec_deque::IntoIter<T, A>","std::sync::mpsc::TryIter<'a, T>","std::collections::hash_map::Keys<'a, K, V>","std::option::Item<A>","std::slice::ArrayWindows<'a, T, N>","core::error::Source<'a>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::array::IntoIter<T, N>","std::sys_common::net::LookupHost","std::collections::btree_set::SymmetricDifference<'a, T>","std::iter::Empty<T>","std::slice::GroupBy<'a, T, P>","std::collections::btree_map::IntoIter<K, V, A>","std::str::EscapeUnicode<'a>","std::collections::btree_map::ValuesMut<'a, K, V>","std::iter::Intersperse<I>","std::option::IntoIter<A>","std::sys_common::wtf8::EncodeWide<'a>","std::os::unix::net::Incoming<'a>","std::collections::hash_map::IntoIter<K, V>","std::collections::vec_deque::Drain<'_, T, A>","std::str::Split<'a, P>","std::slice::SplitNMut<'a, T, P>","std::slice::IterMut<'a, T>","std::slice::RSplitMut<'a, T, P>","std::iter::Take<I>","std::vec::IntoIter<T, A>","std::env::SplitPaths<'a>","std::collections::hash_map::Drain<'a, K, V>","std::slice::RChunksMut<'a, T>","std::str::Utf8Chunks<'a>","std::collections::btree_set::IntoIter<T, A>","std::collections::binary_heap::IntoIter<T>","std::char::EscapeDefault","std::str::CharIndices<'a>","std::collections::hash_map::IterMut<'a, K, V>","std::sync::mpsc::IntoIter<T>","std::str::SplitTerminator<'a, P>","std::slice::SplitInclusiveMut<'a, T, P>","std::slice::SplitN<'a, T, P>","std::collections::hash_map::IntoKeys<K, V>","std::collections::linked_list::IntoIter<T>","std::slice::RSplitNMut<'a, T, P>","std::collections::binary_heap::Drain<'_, T>","std::iter::Once<T>","std::iter::MapWhile<I, P>","std::slice::ArrayChunksMut<'a, T, N>","std::collections::btree_map::RangeMut<'a, K, V>","std::sys::unix::os::SplitPaths<'a>","std::slice::ChunksMut<'a, T>","std::slice::Split<'a, T, P>","std::os::unix::net::Messages<'a>","<&mut I as std::iter::Iterator>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::iter::adapters::GenericShunt<'_, I, R>","std::sys::unix::fs::ReadDir","std::str::Lines<'a>","std::char::ToUppercase","std::collections::hash_map::ValuesMut<'a, K, V>","std::slice::RChunksExactMut<'a, T>","std::ops::RangeFrom<A>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<array::Array as std::iter::Extend<V>>::extend":{"T":["table::Table","inline_table::InlineTable","array_of_tables::ArrayOfTables","<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>","array::Array","<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>"],"V":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<array::Array as std::iter::Extend<V>>::extend(p0, p1);
+crate::<array::Array as std::iter::Extend<V>>::extend(p0, p1);
+<array::Array>::extend(p0, p1);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::iter::FromIterator<V>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<array::Array as std::iter::FromIterator<V>>::from_iter":{"I":["std::marker::Sized","std::iter::IntoIterator"],"V":["std::convert::Into","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::env::Vars","std::iter::Scan<I, St, F>","std::slice::Windows<'a, T>","std::option::Item<A>","std::collections::btree_map::Values<'a, K, V>","std::iter::Filter<I, P>","std::io::Split<B>","std::str::EscapeUnicode<'a>","std::iter::Once<T>","std::os::unix::net::Incoming<'a>","std::env::ArgsOs","std::process::CommandArgs<'a>","std::iter::TakeWhile<I, P>","std::vec::IntoIter<T, A>","std::sync::mpsc::IntoIter<T>","std::boxed::Box<I, A>","std::ascii::EscapeDefault","std::str::Matches<'a, P>","std::char::CaseMappingIter","std::iter::MapWhile<I, P>","std::str::RSplit<'a, P>","std::net::Incoming<'a>","std::char::ToUppercase","std::sys::unix::process::process_common::CommandArgs<'a>","std::iter::Cloned<I>","std::iter::adapters::GenericShunt<'_, I, R>","std::sys::unix::fs::ReadDir","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::iter::Take<I>","std::iter::Flatten<I>","std::slice::ArrayChunksMut<'a, T, N>","std::slice::ChunksExactMut<'a, T>","std::iter::Skip<I>","std::collections::vec_deque::IntoIter<T, A>","std::option::IntoIter<A>","std::slice::RSplitNMut<'a, T, P>","std::vec::Drain<'_, T, A>","std::iter::Map<I, F>","std::str::SplitAsciiWhitespace<'a>","core::slice::iter::GenericSplitN<I>","std::slice::ChunksMut<'a, T>","std::str::EncodeUtf16<'a>","std::collections::hash_set::Union<'a, T, S>","std::ops::RangeInclusive<A>","std::char::EscapeDefault","std::str::RSplitN<'a, P>","std::collections::hash_set::Iter<'a, K>","std::iter::FilterMap<I, F>","std::collections::btree_map::Keys<'a, K, V>","std::slice::RChunksExactMut<'a, T>","std::collections::binary_heap::Iter<'a, T>","std::collections::btree_set::Difference<'a, T, A>","std::iter::ArrayChunks<I, N>","std::collections::hash_map::Iter<'a, K, V>","std::sys::unix::os::SplitPaths<'a>","std::str::SplitTerminator<'a, P>","std::iter::OnceWith<F>","std::slice::RSplitMut<'a, T, P>","std::slice::ArrayWindows<'a, T, N>","std::slice::Iter<'a, T>","std::str::Lines<'a>","std::array::IntoIter<T, N>","std::collections::btree_set::IntoIter<T, A>","std::collections::btree_map::RangeMut<'a, K, V>","std::iter::StepBy<I>","std::str::SplitInclusive<'a, P>","std::sync::mpsc::TryIter<'a, T>","std::str::Utf8Chunks<'a>","std::env::Args","std::slice::Chunks<'a, T>","std::iter::Cycle<I>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::os::unix::net::Messages<'a>","std::str::EscapeDefault<'a>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::hash_set::DrainFilter<'_, K, F>","std::iter::RepeatN<A>","std::slice::SplitInclusive<'a, T, P>","std::slice::SplitN<'a, T, P>","std::process::CommandEnvs<'a>","std::collections::linked_list::IntoIter<T>","std::collections::hash_map::IntoIter<K, V>","std::option::Iter<'a, A>","std::collections::linked_list::DrainFilter<'_, T, F>","std::slice::RSplit<'a, T, P>","std::collections::binary_heap::IntoIter<T>","std::result::IterMut<'a, T>","std::collections::linked_list::Iter<'a, T>","std::path::Ancestors<'a>","std::iter::Peekable<I>","std::slice::GroupBy<'a, T, P>","std::iter::Repeat<A>","std::slice::SplitNMut<'a, T, P>","std::iter::FromFn<F>","std::iter::Enumerate<I>","std::option::IterMut<'a, A>","std::net::IntoIncoming","std::str::SplitWhitespace<'a>","std::slice::GroupByMut<'a, T, P>","std::collections::vec_deque::IterMut<'a, T>","std::str::MatchIndices<'a, P>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::iter::ByRefSized<'_, I>","std::result::IntoIter<T>","std::collections::hash_map::ValuesMut<'a, K, V>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::collections::hash_set::IntoIter<K>","std::char::ToLowercase","std::sys::unix::os::Env","std::slice::RChunks<'a, T>","std::sys::unix::args::Args","std::string::Drain<'_>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::slice::ArrayChunks<'a, T, N>","std::slice::Split<'a, T, P>","std::path::Components<'a>","std::char::EscapeDebug","std::collections::hash_map::IterMut<'a, K, V>","std::vec::Splice<'_, I, A>","std::collections::btree_map::IntoKeys<K, V, A>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::slice::ChunksExact<'a, T>","std::slice::SplitMut<'a, T, P>","std::collections::btree_map::IterMut<'a, K, V>","std::collections::btree_map::IntoValues<K, V, A>","std::sys_common::net::LookupHost","std::collections::binary_heap::DrainSorted<'_, T>","std::str::CharIndices<'a>","std::collections::hash_map::IntoValues<K, V>","std::vec::DrainFilter<'_, T, F, A>","std::iter::Fuse<I>","std::collections::binary_heap::IntoIterSorted<T>","std::collections::vec_deque::Iter<'a, T>","std::collections::btree_set::Union<'a, T>","std::collections::binary_heap::Drain<'_, T>","std::slice::SplitInclusiveMut<'a, T, P>","std::str::RSplitTerminator<'a, P>","std::sys_common::wstr::WStrUnits<'_>","std::str::EscapeDebug<'a>","std::collections::hash_set::Drain<'a, K>","std::str::Bytes<'_>","std::iter::Rev<I>","std::str::SplitN<'a, P>","std::iter::Copied<I>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::path::Iter<'a>","std::slice::RChunksMut<'a, T>","std::slice::IterMut<'a, T>","core::error::Source<'a>","std::iter::RepeatWith<F>","std::collections::btree_set::SymmetricDifference<'a, T>","std::iter::Successors<T, F>","std::ops::index_range::IndexRange","std::os::unix::net::ScmRights<'a>","std::collections::hash_map::Values<'a, K, V>","std::iter::Zip<A, B>","std::str::Chars<'a>","std::str::RMatches<'a, P>","std::collections::hash_set::Intersection<'a, T, S>","std::slice::RSplitN<'a, T, P>","std::char::EscapeUnicode","std::collections::hash_map::Drain<'a, K, V>","std::iter::sources::from_generator::FromGenerator<G>","std::iter::Chain<A, B>","std::collections::btree_map::Range<'a, K, V>","std::collections::btree_set::Intersection<'a, T, A>","std::sync::mpsc::Iter<'a, T>","std::iter::Intersperse<I>","std::collections::btree_map::IntoIter<K, V, A>","std::collections::btree_map::Iter<'a, K, V>","std::str::RMatchIndices<'a, P>","std::collections::btree_map::ValuesMut<'a, K, V>","std::env::VarsOs","std::io::Bytes<R>","std::result::Iter<'a, T>","std::iter::IntersperseWith<I, G>","std::collections::hash_map::Keys<'a, K, V>","std::collections::hash_set::Difference<'a, T, S>","std::collections::btree_set::Iter<'a, T>","std::ops::Range<A>","std::iter::FlatMap<I, U, F>","std::ops::RangeFrom<A>","std::iter::Empty<T>","std::os::unix::net::ScmCredentials<'a>","std::str::LinesAny<'a>","std::fs::ReadDir","std::collections::btree_set::Range<'a, T>","std::iter::SkipWhile<I, P>","std::str::Split<'a, P>","std::slice::EscapeAscii<'a>","std::env::SplitPaths<'a>","std::collections::vec_deque::Drain<'_, T, A>","std::io::Lines<B>","std::iter::Inspect<I, F>","std::collections::hash_map::IntoKeys<K, V>","std::sys_common::wtf8::EncodeWide<'a>","std::char::DecodeUtf16<I>","std::slice::RChunksExact<'a, T>","std::collections::linked_list::IterMut<'a, T>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<array::Array as std::iter::FromIterator<V>>::from_iter":{"I":["indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>","array::Array","table::Table","<&'a std::option::Option<T> as std::iter::IntoIterator>","array_of_tables::ArrayOfTables","inline_table::InlineTable"],"V":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<array::Array as std::iter::FromIterator<V>>::from_iter(p0);
+crate::<array::Array as std::iter::FromIterator<V>>::from_iter(p0);
+<array::Array>::from_iter(p0);
-----------------
crates/toml_edit/src/array.rs <array::Array as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array::Array
+p0.into_iter();
+<array::Array as std::iter::IntoIterator>::into_iter(p0);
+crate::<array::Array as std::iter::IntoIterator>::into_iter(p0);
+<array::Array>::into_iter(p0);
-----------------
crates/toml_edit/src/array.rs <&'s array::Array as std::iter::IntoIterator>::into_iter
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
+p0.into_iter();
+<&'s array::Array as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'s array::Array as std::iter::IntoIterator>::into_iter(p0);
+<&'s array::Array>::into_iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.clone();
+<array_of_tables::ArrayOfTables as std::clone::Clone>::clone(p0);
+crate::<array_of_tables::ArrayOfTables as std::clone::Clone>::clone(p0);
+<array_of_tables::ArrayOfTables>::clone(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<array_of_tables::ArrayOfTables as std::fmt::Debug>::fmt(p0, p1);
+crate::<array_of_tables::ArrayOfTables as std::fmt::Debug>::fmt(p0, p1);
+<array_of_tables::ArrayOfTables>::fmt(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::default::Default>::default
deps:{}
candidates:{}
+<array_of_tables::ArrayOfTables as std::default::Default>::default();
+crate::<array_of_tables::ArrayOfTables as std::default::Default>::default();
+<array_of_tables::ArrayOfTables>::default();
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::new
deps:{}
candidates:{}
+array_of_tables::ArrayOfTables::new();
+crate::array_of_tables::ArrayOfTables::new();
+<array_of_tables::ArrayOfTables>::new();
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::into_array
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.into_array();
+array_of_tables::ArrayOfTables::into_array(p0);
+crate::array_of_tables::ArrayOfTables::into_array(p0);
+<array_of_tables::ArrayOfTables>::into_array(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.span();
+array_of_tables::ArrayOfTables::span(p0);
+crate::array_of_tables::ArrayOfTables::span(p0);
+<array_of_tables::ArrayOfTables>::span(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+array_of_tables::ArrayOfTables::despan(p0, &p1);
+crate::array_of_tables::ArrayOfTables::despan(p0, &p1);
+<array_of_tables::ArrayOfTables>::despan(p0, &p1);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.iter();
+array_of_tables::ArrayOfTables::iter(p0);
+crate::array_of_tables::ArrayOfTables::iter(p0);
+<array_of_tables::ArrayOfTables>::iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.iter_mut();
+array_of_tables::ArrayOfTables::iter_mut(p0);
+crate::array_of_tables::ArrayOfTables::iter_mut(p0);
+<array_of_tables::ArrayOfTables>::iter_mut(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.len();
+array_of_tables::ArrayOfTables::len(p0);
+crate::array_of_tables::ArrayOfTables::len(p0);
+<array_of_tables::ArrayOfTables>::len(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.is_empty();
+array_of_tables::ArrayOfTables::is_empty(p0);
+crate::array_of_tables::ArrayOfTables::is_empty(p0);
+<array_of_tables::ArrayOfTables>::is_empty(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.clear();
+array_of_tables::ArrayOfTables::clear(p0);
+crate::array_of_tables::ArrayOfTables::clear(p0);
+<array_of_tables::ArrayOfTables>::clear(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+array_of_tables::ArrayOfTables::get(p0, p1);
+crate::array_of_tables::ArrayOfTables::get(p0, p1);
+<array_of_tables::ArrayOfTables>::get(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = 0usize; // None+usize
+p0.get_mut(p1);
+array_of_tables::ArrayOfTables::get_mut(p0, p1);
+crate::array_of_tables::ArrayOfTables::get_mut(p0, p1);
+<array_of_tables::ArrayOfTables>::get_mut(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = MaybeUninit::uninit().assume_init(); // table::Table
+p0.push(p1);
+array_of_tables::ArrayOfTables::push(p0, p1);
+crate::array_of_tables::ArrayOfTables::push(p0, p1);
+<array_of_tables::ArrayOfTables>::push(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs array_of_tables::ArrayOfTables::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = 0usize; // None+usize
+p0.remove(p1);
+array_of_tables::ArrayOfTables::remove(p0, p1);
+crate::array_of_tables::ArrayOfTables::remove(p0, p1);
+<array_of_tables::ArrayOfTables>::remove(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend":{"T":["std::iter::IntoIterator","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::result::Iter<'a, T>","std::collections::btree_set::Union<'a, T>","std::sys::unix::os::SplitPaths<'a>","std::process::CommandEnvs<'a>","std::net::Incoming<'a>","std::collections::btree_map::Iter<'a, K, V>","std::io::Lines<B>","std::sys::unix::process::process_common::CommandArgs<'a>","std::ops::RangeInclusive<A>","std::str::SplitAsciiWhitespace<'a>","std::str::SplitWhitespace<'a>","std::str::Split<'a, P>","std::io::Bytes<R>","std::str::RMatches<'a, P>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::iter::Rev<I>","std::collections::btree_set::IntoIter<T, A>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::str::SplitTerminator<'a, P>","std::sys_common::wstr::WStrUnits<'_>","std::sys_common::wtf8::EncodeWide<'a>","std::slice::EscapeAscii<'a>","std::collections::vec_deque::IntoIter<T, A>","std::collections::binary_heap::Iter<'a, T>","std::slice::SplitInclusiveMut<'a, T, P>","std::char::CaseMappingIter","std::slice::ArrayChunksMut<'a, T, N>","std::iter::TakeWhile<I, P>","std::iter::FilterMap<I, F>","std::collections::btree_set::SymmetricDifference<'a, T>","std::collections::vec_deque::Iter<'a, T>","std::iter::Successors<T, F>","std::str::RSplitN<'a, P>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::iter::Enumerate<I>","std::char::EscapeDefault","std::sys::unix::args::Args","std::char::DecodeUtf16<I>","std::iter::Chain<A, B>","std::slice::ArrayChunks<'a, T, N>","std::slice::ChunksMut<'a, T>","std::slice::GroupByMut<'a, T, P>","std::iter::Intersperse<I>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::option::IterMut<'a, A>","std::net::IntoIncoming","std::iter::ByRefSized<'_, I>","std::slice::RSplitN<'a, T, P>","std::iter::OnceWith<F>","std::collections::btree_map::IntoKeys<K, V, A>","std::iter::Cloned<I>","std::vec::IntoIter<T, A>","std::collections::binary_heap::IntoIter<T>","std::slice::Iter<'a, T>","std::io::Split<B>","std::collections::btree_map::IterMut<'a, K, V>","std::iter::StepBy<I>","std::iter::Copied<I>","std::option::Item<A>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::iter::Cycle<I>","std::collections::btree_set::Range<'a, T>","std::sys::unix::os::Env","std::ascii::EscapeDefault","std::str::RMatchIndices<'a, P>","std::slice::SplitMut<'a, T, P>","std::iter::Take<I>","std::collections::hash_set::Intersection<'a, T, S>","std::slice::RChunksExactMut<'a, T>","<&mut I as std::iter::Iterator>","std::collections::hash_map::IntoValues<K, V>","std::result::IntoIter<T>","std::fs::ReadDir","std::env::Vars","std::char::EscapeDebug","std::str::LinesAny<'a>","std::string::Drain<'_>","std::env::VarsOs","std::collections::linked_list::Iter<'a, T>","std::iter::Fuse<I>","std::slice::SplitN<'a, T, P>","std::slice::SplitInclusive<'a, T, P>","std::slice::RChunksMut<'a, T>","std::str::EscapeDebug<'a>","std::env::ArgsOs","std::vec::DrainFilter<'_, T, F, A>","std::collections::hash_set::Iter<'a, K>","std::slice::RSplit<'a, T, P>","std::str::MatchIndices<'a, P>","std::collections::hash_map::Drain<'a, K, V>","std::iter::Empty<T>","std::str::EscapeUnicode<'a>","std::collections::vec_deque::IterMut<'a, T>","std::str::Lines<'a>","std::collections::hash_map::IterMut<'a, K, V>","std::iter::Map<I, F>","std::str::CharIndices<'a>","std::char::EscapeUnicode","std::slice::ChunksExactMut<'a, T>","std::collections::btree_map::IntoIter<K, V, A>","std::os::unix::net::Messages<'a>","std::collections::hash_map::Keys<'a, K, V>","std::iter::Inspect<I, F>","std::slice::SplitNMut<'a, T, P>","std::env::SplitPaths<'a>","std::sys_common::net::LookupHost","std::os::unix::net::ScmRights<'a>","std::collections::hash_set::Difference<'a, T, S>","std::collections::hash_map::Iter<'a, K, V>","std::collections::linked_list::IntoIter<T>","std::path::Ancestors<'a>","std::collections::btree_map::IntoValues<K, V, A>","std::str::EncodeUtf16<'a>","std::iter::Peekable<I>","std::char::ToLowercase","std::collections::hash_map::IntoIter<K, V>","std::env::Args","std::boxed::Box<I, A>","std::iter::Flatten<I>","std::slice::RChunksExact<'a, T>","std::iter::SkipWhile<I, P>","std::sys::unix::fs::ReadDir","std::slice::ArrayWindows<'a, T, N>","std::str::SplitInclusive<'a, P>","std::char::ToUppercase","std::slice::RChunks<'a, T>","std::sync::mpsc::Iter<'a, T>","std::collections::btree_set::Difference<'a, T, A>","std::iter::Once<T>","std::option::IntoIter<A>","std::str::RSplitTerminator<'a, P>","std::str::EscapeDefault<'a>","std::collections::linked_list::IterMut<'a, T>","std::iter::Skip<I>","std::sync::mpsc::TryIter<'a, T>","std::ops::index_range::IndexRange","std::iter::Filter<I, P>","std::iter::FromFn<F>","std::collections::btree_map::RangeMut<'a, K, V>","std::slice::Chunks<'a, T>","std::str::Chars<'a>","std::iter::ArrayChunks<I, N>","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::btree_map::Range<'a, K, V>","std::vec::Drain<'_, T, A>","std::collections::binary_heap::IntoIterSorted<T>","std::iter::Zip<A, B>","std::collections::hash_map::Values<'a, K, V>","std::ops::Range<A>","std::iter::Repeat<A>","std::array::IntoIter<T, N>","std::slice::RSplitNMut<'a, T, P>","std::os::unix::net::Incoming<'a>","std::collections::hash_set::DrainFilter<'_, K, F>","std::collections::hash_map::ValuesMut<'a, K, V>","std::collections::hash_set::IntoIter<K>","std::option::Iter<'a, A>","core::error::Source<'a>","std::str::SplitN<'a, P>","std::str::RSplit<'a, P>","std::collections::btree_set::Intersection<'a, T, A>","std::collections::hash_set::Union<'a, T, S>","std::collections::btree_set::Iter<'a, T>","core::slice::iter::GenericSplitN<I>","std::iter::Scan<I, St, F>","std::collections::vec_deque::Drain<'_, T, A>","std::slice::IterMut<'a, T>","std::str::Bytes<'_>","std::slice::RSplitMut<'a, T, P>","std::slice::Windows<'a, T>","std::iter::IntersperseWith<I, G>","std::iter::RepeatN<A>","std::collections::hash_set::Drain<'a, K>","std::collections::binary_heap::Drain<'_, T>","std::ops::RangeFrom<A>","std::str::Utf8Chunks<'a>","std::slice::Split<'a, T, P>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::btree_map::Keys<'a, K, V>","std::iter::MapWhile<I, P>","std::result::IterMut<'a, T>","std::vec::Splice<'_, I, A>","std::slice::ChunksExact<'a, T>","std::iter::FlatMap<I, U, F>","std::str::Matches<'a, P>","std::collections::hash_map::IntoKeys<K, V>","std::path::Components<'a>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::collections::linked_list::DrainFilter<'_, T, F>","std::collections::btree_map::Values<'a, K, V>","std::sync::mpsc::IntoIter<T>","std::iter::sources::from_generator::FromGenerator<G>","std::os::unix::net::ScmCredentials<'a>","std::slice::GroupBy<'a, T, P>","std::process::CommandArgs<'a>","std::path::Iter<'a>","std::iter::adapters::GenericShunt<'_, I, R>","std::iter::RepeatWith<F>"]},"<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend":{"T":["<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>","array_of_tables::ArrayOfTables","array::Array","<&'a std::result::Result<T, E> as std::iter::IntoIterator>","inline_table::InlineTable","table::Table"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend(p0, p1);
+crate::<array_of_tables::ArrayOfTables as std::iter::Extend<table::Table>>::extend(p0, p1);
+<array_of_tables::ArrayOfTables>::extend(p0, p1);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter":{"I":["std::marker::Sized","std::iter::IntoIterator"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::str::RMatchIndices<'a, P>","std::collections::btree_set::Intersection<'a, T, A>","std::collections::hash_map::IntoValues<K, V>","std::os::unix::net::Incoming<'a>","std::iter::IntersperseWith<I, G>","std::slice::IterMut<'a, T>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::iter::ByRefSized<'_, I>","std::str::LinesAny<'a>","std::slice::ChunksExact<'a, T>","std::collections::vec_deque::Iter<'a, T>","std::slice::RSplitNMut<'a, T, P>","std::ops::Range<A>","std::collections::btree_map::Keys<'a, K, V>","std::iter::Cycle<I>","std::process::CommandArgs<'a>","std::iter::Zip<A, B>","std::collections::btree_map::ValuesMut<'a, K, V>","std::str::RSplitN<'a, P>","std::slice::RChunksExactMut<'a, T>","<&mut I as std::iter::Iterator>","std::collections::hash_map::Iter<'a, K, V>","std::slice::ArrayChunks<'a, T, N>","std::collections::btree_set::Range<'a, T>","std::array::IntoIter<T, N>","std::collections::btree_map::Range<'a, K, V>","std::iter::Intersperse<I>","std::iter::FilterMap<I, F>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::str::Lines<'a>","std::collections::hash_map::Values<'a, K, V>","std::slice::EscapeAscii<'a>","std::collections::hash_set::IntoIter<K>","std::slice::SplitN<'a, T, P>","std::slice::SplitInclusive<'a, T, P>","std::slice::RChunksExact<'a, T>","std::env::SplitPaths<'a>","std::iter::Cloned<I>","std::fs::ReadDir","std::iter::Once<T>","std::sys::unix::args::Args","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::env::VarsOs","std::collections::linked_list::IntoIter<T>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::char::ToUppercase","std::char::DecodeUtf16<I>","std::collections::btree_map::IterMut<'a, K, V>","std::collections::hash_map::Drain<'a, K, V>","std::slice::GroupBy<'a, T, P>","std::collections::btree_map::Iter<'a, K, V>","std::iter::sources::from_generator::FromGenerator<G>","std::slice::Split<'a, T, P>","std::result::IntoIter<T>","std::iter::Skip<I>","std::collections::binary_heap::Drain<'_, T>","std::iter::Fuse<I>","std::char::EscapeDefault","std::sys_common::wtf8::EncodeWide<'a>","std::char::CaseMappingIter","std::collections::linked_list::IterMut<'a, T>","std::collections::vec_deque::IntoIter<T, A>","std::option::Iter<'a, A>","std::net::Incoming<'a>","std::iter::Flatten<I>","std::slice::RChunks<'a, T>","std::str::MatchIndices<'a, P>","std::ops::RangeInclusive<A>","std::result::IterMut<'a, T>","std::slice::Chunks<'a, T>","std::collections::binary_heap::DrainSorted<'_, T>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::slice::SplitNMut<'a, T, P>","std::slice::RChunksMut<'a, T>","std::iter::OnceWith<F>","std::collections::btree_set::SymmetricDifference<'a, T>","std::str::EncodeUtf16<'a>","std::iter::SkipWhile<I, P>","std::iter::Scan<I, St, F>","std::collections::vec_deque::Drain<'_, T, A>","std::slice::ArrayChunksMut<'a, T, N>","std::str::SplitN<'a, P>","std::char::EscapeDebug","std::str::SplitWhitespace<'a>","std::slice::RSplitN<'a, T, P>","std::iter::StepBy<I>","std::slice::Windows<'a, T>","std::str::Chars<'a>","std::ascii::EscapeDefault","std::sys::unix::process::process_common::CommandArgs<'a>","std::str::Utf8Chunks<'a>","std::collections::btree_set::Iter<'a, T>","std::process::CommandEnvs<'a>","std::vec::IntoIter<T, A>","std::env::Args","std::io::Bytes<R>","std::iter::Successors<T, F>","std::collections::btree_map::Values<'a, K, V>","std::iter::Take<I>","std::collections::linked_list::Iter<'a, T>","std::collections::hash_set::Drain<'a, K>","std::collections::btree_set::Difference<'a, T, A>","std::path::Components<'a>","std::sys_common::net::LookupHost","std::collections::vec_deque::IterMut<'a, T>","std::str::SplitAsciiWhitespace<'a>","std::option::IntoIter<A>","std::collections::hash_set::Union<'a, T, S>","std::boxed::Box<I, A>","std::iter::RepeatWith<F>","std::iter::MapWhile<I, P>","std::iter::Rev<I>","core::error::Source<'a>","std::iter::Copied<I>","std::iter::Repeat<A>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::string::Drain<'_>","std::net::IntoIncoming","std::char::EscapeUnicode","std::slice::ChunksExactMut<'a, T>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::sync::mpsc::TryIter<'a, T>","std::iter::Peekable<I>","std::iter::Inspect<I, F>","std::iter::Filter<I, P>","std::str::Bytes<'_>","std::collections::binary_heap::IntoIterSorted<T>","std::iter::TakeWhile<I, P>","std::iter::Chain<A, B>","std::ops::index_range::IndexRange","std::collections::hash_map::IterMut<'a, K, V>","std::str::SplitInclusive<'a, P>","std::io::Lines<B>","std::slice::SplitMut<'a, T, P>","std::sys::unix::os::SplitPaths<'a>","std::iter::FlatMap<I, U, F>","std::slice::Iter<'a, T>","std::sys::unix::os::Env","std::vec::DrainFilter<'_, T, F, A>","std::os::unix::net::Messages<'a>","std::collections::hash_set::Difference<'a, T, S>","std::sync::mpsc::IntoIter<T>","std::str::Split<'a, P>","std::path::Iter<'a>","std::result::Iter<'a, T>","std::slice::RSplitMut<'a, T, P>","std::iter::adapters::GenericShunt<'_, I, R>","std::option::IterMut<'a, A>","std::iter::Empty<T>","std::collections::btree_set::Union<'a, T>","std::collections::hash_set::Intersection<'a, T, S>","std::iter::RepeatN<A>","std::sys_common::wstr::WStrUnits<'_>","core::slice::iter::GenericSplitN<I>","std::iter::Map<I, F>","std::str::RSplitTerminator<'a, P>","std::env::Vars","std::collections::binary_heap::Iter<'a, T>","std::char::ToLowercase","std::iter::Enumerate<I>","std::str::RSplit<'a, P>","std::str::EscapeUnicode<'a>","std::collections::btree_map::IntoKeys<K, V, A>","std::slice::GroupByMut<'a, T, P>","std::collections::hash_map::IntoIter<K, V>","std::str::Matches<'a, P>","std::iter::FromFn<F>","std::collections::linked_list::DrainFilter<'_, T, F>","std::str::RMatches<'a, P>","std::option::Item<A>","std::env::ArgsOs","std::slice::ArrayWindows<'a, T, N>","std::str::SplitTerminator<'a, P>","std::slice::ChunksMut<'a, T>","std::collections::btree_set::IntoIter<T, A>","std::os::unix::net::ScmRights<'a>","std::collections::hash_set::DrainFilter<'_, K, F>","std::vec::Splice<'_, I, A>","std::sys::unix::fs::ReadDir","std::collections::binary_heap::IntoIter<T>","std::collections::hash_set::Iter<'a, K>","std::ops::RangeFrom<A>","std::slice::SplitInclusiveMut<'a, T, P>","std::collections::btree_map::RangeMut<'a, K, V>","std::iter::ArrayChunks<I, N>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::collections::hash_map::ValuesMut<'a, K, V>","std::collections::hash_map::IntoKeys<K, V>","std::str::CharIndices<'a>","std::collections::btree_map::IntoIter<K, V, A>","std::sync::mpsc::Iter<'a, T>","std::slice::RSplit<'a, T, P>","std::path::Ancestors<'a>","std::collections::hash_map::Keys<'a, K, V>","std::os::unix::net::ScmCredentials<'a>","std::collections::btree_map::IntoValues<K, V, A>","std::str::EscapeDebug<'a>","std::io::Split<B>","std::str::EscapeDefault<'a>","std::vec::Drain<'_, T, A>"]},"<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter":{"I":["<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>","inline_table::InlineTable","table::Table","array_of_tables::ArrayOfTables","array::Array","<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter(p0);
+crate::<array_of_tables::ArrayOfTables as std::iter::FromIterator<table::Table>>::from_iter(p0);
+<array_of_tables::ArrayOfTables>::from_iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.into_iter();
+<array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter(p0);
+crate::<array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter(p0);
+<array_of_tables::ArrayOfTables>::into_iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
+p0.into_iter();
+<&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'s array_of_tables::ArrayOfTables as std::iter::IntoIterator>::into_iter(p0);
+<&'s array_of_tables::ArrayOfTables>::into_iter(p0);
-----------------
crates/toml_edit/src/array_of_tables.rs <array_of_tables::ArrayOfTables as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array_of_tables::ArrayOfTables
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<array_of_tables::ArrayOfTables as std::fmt::Display>::fmt(p0, p1);
+crate::<array_of_tables::ArrayOfTables as std::fmt::Display>::fmt(p0, p1);
+<array_of_tables::ArrayOfTables>::fmt(p0, p1);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<document::Document as std::fmt::Debug>::fmt(p0, p1);
+crate::<document::Document as std::fmt::Debug>::fmt(p0, p1);
+<document::Document>::fmt(p0, p1);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.clone();
+<document::Document as std::clone::Clone>::clone(p0);
+crate::<document::Document as std::clone::Clone>::clone(p0);
+<document::Document>::clone(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::new
deps:{}
candidates:{}
+document::Document::new();
+crate::document::Document::new();
+<document::Document>::new();
-----------------
crates/toml_edit/src/document.rs document::Document::as_item
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.as_item();
+document::Document::as_item(p0);
+crate::document::Document::as_item(p0);
+<document::Document>::as_item(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::as_item_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.as_item_mut();
+document::Document::as_item_mut(p0);
+crate::document::Document::as_item_mut(p0);
+<document::Document>::as_item_mut(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::as_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.as_table();
+document::Document::as_table(p0);
+crate::document::Document::as_table(p0);
+<document::Document>::as_table(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::as_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.as_table_mut();
+document::Document::as_table_mut(p0);
+crate::document::Document::as_table_mut(p0);
+<document::Document>::as_table_mut(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.iter();
+document::Document::iter(p0);
+crate::document::Document::iter(p0);
+<document::Document>::iter(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::set_trailing
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"document::Document::set_trailing":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"document::Document::set_trailing":{"impl Into<RawString>":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_trailing(p1);
+document::Document::set_trailing(p0, p1);
+crate::document::Document::set_trailing(p0, p1);
+<document::Document>::set_trailing(p0, p1);
-----------------
crates/toml_edit/src/document.rs document::Document::trailing
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.trailing();
+document::Document::trailing(p0);
+crate::document::Document::trailing(p0);
+<document::Document>::trailing(p0);
-----------------
crates/toml_edit/src/document.rs document::Document::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.despan();
+document::Document::despan(p0);
+crate::document::Document::despan(p0);
+<document::Document>::despan(p0);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::default::Default>::default
deps:{}
candidates:{}
+<document::Document as std::default::Default>::default();
+crate::<document::Document as std::default::Default>::default();
+<document::Document>::default();
-----------------
crates/toml_edit/src/document.rs <document::Document as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<document::Document as std::str::FromStr>::from_str(&p0);
+crate::<document::Document as std::str::FromStr>::from_str(&p0);
+<document::Document>::from_str(&p0);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
+p0.deref();
+<document::Document as std::ops::Deref>::deref(p0);
+crate::<document::Document as std::ops::Deref>::deref(p0);
+<document::Document>::deref(p0);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::ops::DerefMut>::deref_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
+p0.deref_mut();
+<document::Document as std::ops::DerefMut>::deref_mut(p0);
+crate::<document::Document as std::ops::DerefMut>::deref_mut(p0);
+<document::Document>::deref_mut(p0);
-----------------
crates/toml_edit/src/document.rs <document::Document as std::convert::From<table::Table>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Table
+<document::Document as std::convert::From<table::Table>>::from(p0);
+crate::<document::Document as std::convert::From<table::Table>>::from(p0);
+<document::Document>::from(p0);
-----------------
crates/toml_edit/src/encode.rs <key::Key as encode::Encode>::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<key::Key as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<key::Key as encode::Encode>::encode(p0, p1, p2, p3);
+<key::Key>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <&'k [key::Key] as encode::Encode>::encode
'k
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<&'k [key::Key] as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<&'k [key::Key] as encode::Encode>::encode(p0, p1, p2, p3);
+<&'k [key::Key]>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <&'k [&'k key::Key] as encode::Encode>::encode
'k
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [&'k key::Key]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<&'k [&'k key::Key] as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<&'k [&'k key::Key] as encode::Encode>::encode(p0, p1, p2, p3);
+<&'k [&'k key::Key]>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <repr::Formatted<T> as encode::Encode>::encode
deps:{"<repr::Formatted<T> as encode::Encode>::encode":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"<repr::Formatted<T> as encode::Encode>::encode":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<repr::Formatted<T> as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<repr::Formatted<T> as encode::Encode>::encode(p0, p1, p2, p3);
+<repr::Formatted<T>>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <array::Array as encode::Encode>::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // array::Array
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<array::Array as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<array::Array as encode::Encode>::encode(p0, p1, p2, p3);
+<array::Array>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <inline_table::InlineTable as encode::Encode>::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<inline_table::InlineTable as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<inline_table::InlineTable as encode::Encode>::encode(p0, p1, p2, p3);
+<inline_table::InlineTable>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs <value::Value as encode::Encode>::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = MaybeUninit::uninit().assume_init(); // (&str, &str)
+p0.encode(p1, p2, p3);
+<value::Value as encode::Encode>::encode(p0, p1, p2, p3);
+crate::<value::Value as encode::Encode>::encode(p0, p1, p2, p3);
+<value::Value>::encode(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/encode.rs encode::<impl std::fmt::Display for document::Document>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+encode::<impl std::fmt::Display for document::Document>::fmt(p0, p1);
+crate::encode::<impl std::fmt::Display for document::Document>::fmt(p0, p1);
+<document::Document>::fmt(p0, p1);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for std::string::String>::to_repr
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+p0.to_repr();
+encode::<impl repr::ValueRepr for std::string::String>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for std::string::String>::to_repr(p0);
+<std::string::String>::to_repr(p0);
-----------------
crates/toml_edit/src/encode.rs <encode::StringStyle as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.clone();
+<encode::StringStyle as std::clone::Clone>::clone(p0);
+crate::<encode::StringStyle as std::clone::Clone>::clone(p0);
+<encode::StringStyle>::clone(p0);
-----------------
crates/toml_edit/src/encode.rs <encode::StringStyle as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<encode::StringStyle as std::fmt::Debug>::fmt(p0, p1);
+crate::<encode::StringStyle as std::fmt::Debug>::fmt(p0, p1);
+<encode::StringStyle>::fmt(p0, p1);
-----------------
crates/toml_edit/src/encode.rs <encode::StringStyle as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
let mut p1 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.eq(p1);
+<encode::StringStyle as std::cmp::PartialEq>::eq(p0, p1);
+crate::<encode::StringStyle as std::cmp::PartialEq>::eq(p0, p1);
+<encode::StringStyle>::eq(p0, p1);
-----------------
crates/toml_edit/src/encode.rs <encode::StringStyle as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.assert_receiver_is_total_eq();
+<encode::StringStyle as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<encode::StringStyle as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<encode::StringStyle>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/encode.rs encode::StringStyle::literal_start
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.literal_start();
+encode::StringStyle::literal_start(p0);
+crate::encode::StringStyle::literal_start(p0);
+<encode::StringStyle>::literal_start(p0);
-----------------
crates/toml_edit/src/encode.rs encode::StringStyle::literal_end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.literal_end();
+encode::StringStyle::literal_end(p0);
+crate::encode::StringStyle::literal_end(p0);
+<encode::StringStyle>::literal_end(p0);
-----------------
crates/toml_edit/src/encode.rs encode::StringStyle::standard_start
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.standard_start();
+encode::StringStyle::standard_start(p0);
+crate::encode::StringStyle::standard_start(p0);
+<encode::StringStyle>::standard_start(p0);
-----------------
crates/toml_edit/src/encode.rs encode::StringStyle::standard_end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // encode::StringStyle
+p0.standard_end();
+encode::StringStyle::standard_end(p0);
+crate::encode::StringStyle::standard_end(p0);
+<encode::StringStyle>::standard_end(p0);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for i64>::to_repr
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
+p0.to_repr();
+encode::<impl repr::ValueRepr for i64>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for i64>::to_repr(p0);
+<i64>::to_repr(p0);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for f64>::to_repr
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
+p0.to_repr();
+encode::<impl repr::ValueRepr for f64>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for f64>::to_repr(p0);
+<f64>::to_repr(p0);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for bool>::to_repr
deps:{}
candidates:{}
let mut p0 = & true; // None+bool
+p0.to_repr();
+encode::<impl repr::ValueRepr for bool>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for bool>::to_repr(p0);
+<bool>::to_repr(p0);
-----------------
crates/toml_edit/src/encode.rs encode::<impl repr::ValueRepr for toml_datetime::Datetime>::to_repr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // toml_datetime::Datetime
+p0.to_repr();
+encode::<impl repr::ValueRepr for toml_datetime::Datetime>::to_repr(p0);
+crate::encode::<impl repr::ValueRepr for toml_datetime::Datetime>::to_repr(p0);
+<toml_datetime::Datetime>::to_repr(p0);
-----------------
crates/toml_edit/src/index.rs <usize as index::Index>::index
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+<usize as index::Index>::index(p0, p1);
+crate::<usize as index::Index>::index(p0, p1);
+<usize>::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs <usize as index::Index>::index_mut
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+<usize as index::Index>::index_mut(p0, p1);
+crate::<usize as index::Index>::index_mut(p0, p1);
+<usize>::index_mut(p0, p1);
-----------------
crates/toml_edit/src/index.rs <str as index::Index>::index
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+<str as index::Index>::index(&p0, p1);
+crate::<str as index::Index>::index(&p0, p1);
+<str>::index(&p0, p1);
-----------------
crates/toml_edit/src/index.rs <str as index::Index>::index_mut
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+<str as index::Index>::index_mut(&p0, p1);
+crate::<str as index::Index>::index_mut(&p0, p1);
+<str>::index_mut(&p0, p1);
-----------------
crates/toml_edit/src/index.rs <std::string::String as index::Index>::index
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+<std::string::String as index::Index>::index(p0, p1);
+crate::<std::string::String as index::Index>::index(p0, p1);
+<std::string::String>::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs <std::string::String as index::Index>::index_mut
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+<std::string::String as index::Index>::index_mut(p0, p1);
+crate::<std::string::String as index::Index>::index_mut(p0, p1);
+<std::string::String>::index_mut(p0, p1);
-----------------
crates/toml_edit/src/index.rs <&'a T as index::Index>::index
'a
deps:{"<&'a T as index::Index>":{},"<&'a T as index::Index>::index":{"T":["index::Index"]}}
candidates:{"<&'a T as index::Index>":{},"<&'a T as index::Index>::index":{"T":["<&'a T as index::Index>","std::string::String"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.index(p1);
+<&'a T as index::Index>::index(p0, p1);
+crate::<&'a T as index::Index>::index(p0, p1);
+<&'a T>::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs <&'a T as index::Index>::index_mut
'a
deps:{"<&'a T as index::Index>":{},"<&'a T as index::Index>::index_mut":{"T":["index::Index"]}}
candidates:{"<&'a T as index::Index>":{},"<&'a T as index::Index>::index_mut":{"T":["<&'a T as index::Index>","std::string::String"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.index_mut(p1);
+<&'a T as index::Index>::index_mut(p0, p1);
+crate::<&'a T as index::Index>::index_mut(p0, p1);
+<&'a T>::index_mut(p0, p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::Index<I> for item::Item>::index
deps:{"<&'a T as index::Index>":{},"index::<impl std::ops::Index<I> for item::Item>::index":{"I":["std::marker::Sized","index::Index"]}}
candidates:{"<&'a T as index::Index>":{},"index::<impl std::ops::Index<I> for item::Item>::index":{"I":["std::string::String","<&'a T as index::Index>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.index(p1);
+index::<impl std::ops::Index<I> for item::Item>::index(p0, p1);
+crate::index::<impl std::ops::Index<I> for item::Item>::index(p0, p1);
+<item::Item>::index(p0, p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::IndexMut<I> for item::Item>::index_mut
deps:{"<&'a T as index::Index>":{},"index::<impl std::ops::IndexMut<I> for item::Item>::index_mut":{"I":["index::Index","std::marker::Sized"]}}
candidates:{"<&'a T as index::Index>":{},"index::<impl std::ops::IndexMut<I> for item::Item>::index_mut":{"I":["<&'a T as index::Index>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.index_mut(p1);
+index::<impl std::ops::IndexMut<I> for item::Item>::index_mut(p0, p1);
+crate::index::<impl std::ops::IndexMut<I> for item::Item>::index_mut(p0, p1);
+<item::Item>::index_mut(p0, p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::Index<&'s str> for table::Table>::index
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+index::<impl std::ops::Index<&'s str> for table::Table>::index(p0, &p1);
+crate::index::<impl std::ops::Index<&'s str> for table::Table>::index(p0, &p1);
+<table::Table>::index(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::IndexMut<&'s str> for table::Table>::index_mut
's
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.index_mut(&p1);
+index::<impl std::ops::IndexMut<&'s str> for table::Table>::index_mut(p0, &p1);
+crate::index::<impl std::ops::IndexMut<&'s str> for table::Table>::index_mut(p0, &p1);
+<table::Table>::index_mut(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::Index<&'s str> for inline_table::InlineTable>::index
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+index::<impl std::ops::Index<&'s str> for inline_table::InlineTable>::index(p0, &p1);
+crate::index::<impl std::ops::Index<&'s str> for inline_table::InlineTable>::index(p0, &p1);
+<inline_table::InlineTable>::index(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::IndexMut<&'s str> for inline_table::InlineTable>::index_mut
's
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.index_mut(&p1);
+index::<impl std::ops::IndexMut<&'s str> for inline_table::InlineTable>::index_mut(p0, &p1);
+crate::index::<impl std::ops::IndexMut<&'s str> for inline_table::InlineTable>::index_mut(p0, &p1);
+<inline_table::InlineTable>::index_mut(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::Index<&'s str> for document::Document>::index
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+index::<impl std::ops::Index<&'s str> for document::Document>::index(p0, &p1);
+crate::index::<impl std::ops::Index<&'s str> for document::Document>::index(p0, &p1);
+<document::Document>::index(p0, &p1);
-----------------
crates/toml_edit/src/index.rs index::<impl std::ops::IndexMut<&'s str> for document::Document>::index_mut
's
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // document::Document
let mut p1 = "sample"; // None+&str
+p0.index_mut(&p1);
+index::<impl std::ops::IndexMut<&'s str> for document::Document>::index_mut(p0, &p1);
+crate::index::<impl std::ops::IndexMut<&'s str> for document::Document>::index_mut(p0, &p1);
+<document::Document>::index_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<inline_table::InlineTable as std::fmt::Debug>::fmt(p0, p1);
+crate::<inline_table::InlineTable as std::fmt::Debug>::fmt(p0, p1);
+<inline_table::InlineTable>::fmt(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::default::Default>::default
deps:{}
candidates:{}
+<inline_table::InlineTable as std::default::Default>::default();
+crate::<inline_table::InlineTable as std::default::Default>::default();
+<inline_table::InlineTable>::default();
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.clone();
+<inline_table::InlineTable as std::clone::Clone>::clone(p0);
+crate::<inline_table::InlineTable as std::clone::Clone>::clone(p0);
+<inline_table::InlineTable>::clone(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::new
deps:{}
candidates:{}
+inline_table::InlineTable::new();
+crate::inline_table::InlineTable::new();
+<inline_table::InlineTable>::new();
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::with_pairs
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // indexmap::IndexMap<internal_string::InternalString, table::TableKeyValue>
+inline_table::InlineTable::with_pairs(p0);
+crate::inline_table::InlineTable::with_pairs(p0);
+<inline_table::InlineTable>::with_pairs(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::into_table
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.into_table();
+inline_table::InlineTable::into_table(p0);
+crate::inline_table::InlineTable::into_table(p0);
+<inline_table::InlineTable>::into_table(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.get_values();
+inline_table::InlineTable::get_values(p0);
+crate::inline_table::InlineTable::get_values(p0);
+<inline_table::InlineTable>::get_values(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::append_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // [&'s key::Key]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<(std::vec::Vec<&'s key::Key>, &'s value::Value)>
+p0.append_values(p1, p2);
+inline_table::InlineTable::append_values(p0, p1, p2);
+crate::inline_table::InlineTable::append_values(p0, p1, p2);
+<inline_table::InlineTable>::append_values(p0, p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.fmt();
+inline_table::InlineTable::fmt(p0);
+crate::inline_table::InlineTable::fmt(p0);
+<inline_table::InlineTable>::fmt(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::sort_values
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.sort_values();
+inline_table::InlineTable::sort_values(p0);
+crate::inline_table::InlineTable::sort_values(p0);
+<inline_table::InlineTable>::sort_values(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::sort_values_by
deps:{"inline_table::InlineTable::sort_values_by":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"inline_table::InlineTable::sort_values_by":{"F":["core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.sort_values_by(p1);
+inline_table::InlineTable::sort_values_by(p0, p1);
+crate::inline_table::InlineTable::sort_values_by(p0, p1);
+<inline_table::InlineTable>::sort_values_by(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::sort_values_by_internal
deps:{"inline_table::InlineTable::sort_values_by_internal":{"F":["std::ops::FnMut","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"inline_table::InlineTable::sort_values_by_internal":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // F
+p0.sort_values_by_internal(p1);
+inline_table::InlineTable::sort_values_by_internal(p0, p1);
+crate::inline_table::InlineTable::sort_values_by_internal(p0, p1);
+<inline_table::InlineTable>::sort_values_by_internal(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::set_dotted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+inline_table::InlineTable::set_dotted(p0, p1);
+crate::inline_table::InlineTable::set_dotted(p0, p1);
+<inline_table::InlineTable>::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::is_dotted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.is_dotted();
+inline_table::InlineTable::is_dotted(p0);
+crate::inline_table::InlineTable::is_dotted(p0);
+<inline_table::InlineTable>::is_dotted(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.decor_mut();
+inline_table::InlineTable::decor_mut(p0);
+crate::inline_table::InlineTable::decor_mut(p0);
+<inline_table::InlineTable>::decor_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.decor();
+inline_table::InlineTable::decor(p0);
+crate::inline_table::InlineTable::decor(p0);
+<inline_table::InlineTable>::decor(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::key_decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+inline_table::InlineTable::key_decor_mut(p0, &p1);
+crate::inline_table::InlineTable::key_decor_mut(p0, &p1);
+<inline_table::InlineTable>::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::key_decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+inline_table::InlineTable::key_decor(p0, &p1);
+crate::inline_table::InlineTable::key_decor(p0, &p1);
+<inline_table::InlineTable>::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::set_preamble
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"inline_table::InlineTable::set_preamble":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"inline_table::InlineTable::set_preamble":{"impl Into<RawString>":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_preamble(p1);
+inline_table::InlineTable::set_preamble(p0, p1);
+crate::inline_table::InlineTable::set_preamble(p0, p1);
+<inline_table::InlineTable>::set_preamble(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::preamble
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.preamble();
+inline_table::InlineTable::preamble(p0);
+crate::inline_table::InlineTable::preamble(p0);
+<inline_table::InlineTable>::preamble(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.span();
+inline_table::InlineTable::span(p0);
+crate::inline_table::InlineTable::span(p0);
+<inline_table::InlineTable>::span(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+inline_table::InlineTable::despan(p0, &p1);
+crate::inline_table::InlineTable::despan(p0, &p1);
+<inline_table::InlineTable>::despan(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.iter();
+inline_table::InlineTable::iter(p0);
+crate::inline_table::InlineTable::iter(p0);
+<inline_table::InlineTable>::iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.iter_mut();
+inline_table::InlineTable::iter_mut(p0);
+crate::inline_table::InlineTable::iter_mut(p0);
+<inline_table::InlineTable>::iter_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.len();
+inline_table::InlineTable::len(p0);
+crate::inline_table::InlineTable::len(p0);
+<inline_table::InlineTable>::len(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.is_empty();
+inline_table::InlineTable::is_empty(p0);
+crate::inline_table::InlineTable::is_empty(p0);
+<inline_table::InlineTable>::is_empty(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.clear();
+inline_table::InlineTable::clear(p0);
+crate::inline_table::InlineTable::clear(p0);
+<inline_table::InlineTable>::clear(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::entry
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"inline_table::InlineTable::entry":{"impl Into<InternalString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"inline_table::InlineTable::entry":{"impl Into<InternalString>":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<InternalString>
+p0.entry(p1);
+inline_table::InlineTable::entry(p0, p1);
+crate::inline_table::InlineTable::entry(p0, p1);
+<inline_table::InlineTable>::entry(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::entry_format
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+inline_table::InlineTable::entry_format(p0, p1);
+crate::inline_table::InlineTable::entry_format(p0, p1);
+<inline_table::InlineTable>::entry_format(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+inline_table::InlineTable::get(p0, &p1);
+crate::inline_table::InlineTable::get(p0, &p1);
+<inline_table::InlineTable>::get(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+inline_table::InlineTable::get_mut(p0, &p1);
+crate::inline_table::InlineTable::get_mut(p0, &p1);
+<inline_table::InlineTable>::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_key_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+inline_table::InlineTable::get_key_value(p0, &p1);
+crate::inline_table::InlineTable::get_key_value(p0, &p1);
+<inline_table::InlineTable>::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_key_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+inline_table::InlineTable::get_key_value_mut(p0, &p1);
+crate::inline_table::InlineTable::get_key_value_mut(p0, &p1);
+<inline_table::InlineTable>::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::contains_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+inline_table::InlineTable::contains_key(p0, &p1);
+crate::inline_table::InlineTable::contains_key(p0, &p1);
+<inline_table::InlineTable>::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::get_or_insert
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"inline_table::InlineTable::get_or_insert":{"V":["std::convert::Into","std::marker::Sized"],"impl Into<InternalString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"inline_table::InlineTable::get_or_insert":{"V":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"],"impl Into<InternalString>":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<InternalString>
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.get_or_insert(p1, p2);
+inline_table::InlineTable::get_or_insert(p0, p1, p2);
+crate::inline_table::InlineTable::get_or_insert(p0, p1, p2);
+<inline_table::InlineTable>::get_or_insert(p0, p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::insert
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"inline_table::InlineTable::insert":{"impl Into<InternalString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"inline_table::InlineTable::insert":{"impl Into<InternalString>":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<InternalString>
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1, p2);
+inline_table::InlineTable::insert(p0, p1, p2);
+crate::inline_table::InlineTable::insert(p0, p1, p2);
+<inline_table::InlineTable>::insert(p0, p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::insert_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert_formatted(p1, p2);
+inline_table::InlineTable::insert_formatted(p0, p1, p2);
+crate::inline_table::InlineTable::insert_formatted(p0, p1, p2);
+<inline_table::InlineTable>::insert_formatted(p0, p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+inline_table::InlineTable::remove(p0, &p1);
+crate::inline_table::InlineTable::remove(p0, &p1);
+<inline_table::InlineTable>::remove(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineTable::remove_entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.remove_entry(&p1);
+inline_table::InlineTable::remove_entry(p0, &p1);
+crate::inline_table::InlineTable::remove_entry(p0, &p1);
+<inline_table::InlineTable>::remove_entry(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<inline_table::InlineTable as std::fmt::Display>::fmt(p0, p1);
+crate::<inline_table::InlineTable as std::fmt::Display>::fmt(p0, p1);
+<inline_table::InlineTable>::fmt(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend":{"K":["std::marker::Sized","std::convert::Into"],"T":["std::marker::Sized","std::iter::IntoIterator"],"V":["std::marker::Sized","std::convert::Into"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::collections::hash_set::Drain<'a, K>","std::iter::FlatMap<I, U, F>","std::option::Item<A>","std::os::unix::net::ScmCredentials<'a>","std::iter::ArrayChunks<I, N>","std::str::CharIndices<'a>","std::collections::hash_map::Drain<'a, K, V>","std::collections::hash_set::IntoIter<K>","std::iter::Scan<I, St, F>","std::collections::vec_deque::Iter<'a, T>","std::char::DecodeUtf16<I>","std::env::SplitPaths<'a>","std::collections::hash_map::Keys<'a, K, V>","std::iter::Fuse<I>","std::collections::hash_map::IterMut<'a, K, V>","std::boxed::Box<I, A>","std::collections::btree_set::Union<'a, T>","std::os::unix::net::Incoming<'a>","core::slice::iter::GenericSplitN<I>","std::slice::RChunks<'a, T>","std::slice::RSplitNMut<'a, T, P>","std::slice::RChunksExact<'a, T>","std::str::LinesAny<'a>","std::string::Drain<'_>","std::collections::btree_set::IntoIter<T, A>","std::iter::Intersperse<I>","std::iter::Rev<I>","std::result::IntoIter<T>","std::collections::btree_map::IntoIter<K, V, A>","std::collections::btree_map::Keys<'a, K, V>","std::iter::TakeWhile<I, P>","std::iter::Repeat<A>","std::char::ToUppercase","std::slice::GroupByMut<'a, T, P>","std::collections::linked_list::Iter<'a, T>","std::collections::btree_map::Range<'a, K, V>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::process::CommandEnvs<'a>","std::collections::hash_map::IntoIter<K, V>","std::str::MatchIndices<'a, P>","std::iter::OnceWith<F>","std::str::RMatchIndices<'a, P>","std::path::Iter<'a>","std::collections::btree_set::Range<'a, T>","std::iter::adapters::GenericShunt<'_, I, R>","std::iter::Flatten<I>","std::slice::SplitNMut<'a, T, P>","std::iter::Once<T>","std::iter::Enumerate<I>","std::ascii::EscapeDefault","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::sys_common::wtf8::EncodeWide<'a>","std::iter::RepeatN<A>","std::slice::SplitN<'a, T, P>","std::option::IntoIter<A>","std::collections::binary_heap::IntoIterSorted<T>","std::ops::RangeInclusive<A>","std::collections::vec_deque::Drain<'_, T, A>","std::slice::RChunksMut<'a, T>","std::slice::GroupBy<'a, T, P>","std::str::SplitAsciiWhitespace<'a>","std::collections::btree_map::Values<'a, K, V>","std::slice::ChunksMut<'a, T>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::collections::vec_deque::IntoIter<T, A>","std::sync::mpsc::IntoIter<T>","core::error::Source<'a>","std::slice::RSplit<'a, T, P>","std::sys::unix::os::SplitPaths<'a>","std::str::EscapeUnicode<'a>","std::collections::vec_deque::IterMut<'a, T>","std::iter::Copied<I>","std::collections::btree_map::Iter<'a, K, V>","std::collections::btree_set::SymmetricDifference<'a, T>","std::iter::Map<I, F>","std::slice::SplitInclusiveMut<'a, T, P>","std::env::ArgsOs","std::iter::Chain<A, B>","std::collections::hash_set::Difference<'a, T, S>","std::slice::ArrayChunksMut<'a, T, N>","std::str::Bytes<'_>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::collections::btree_map::RangeMut<'a, K, V>","std::os::unix::net::Messages<'a>","std::str::EscapeDefault<'a>","std::collections::hash_map::ValuesMut<'a, K, V>","std::io::Bytes<R>","std::collections::btree_map::IntoKeys<K, V, A>","std::str::RSplitTerminator<'a, P>","std::slice::ArrayChunks<'a, T, N>","std::env::VarsOs","std::str::RSplit<'a, P>","std::str::SplitTerminator<'a, P>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::btree_set::Intersection<'a, T, A>","std::str::Chars<'a>","std::str::Split<'a, P>","std::collections::binary_heap::Drain<'_, T>","std::str::Matches<'a, P>","std::slice::RChunksExactMut<'a, T>","std::slice::RSplitN<'a, T, P>","std::iter::Peekable<I>","std::slice::ArrayWindows<'a, T, N>","std::env::Args","std::collections::hash_map::Values<'a, K, V>","std::slice::SplitMut<'a, T, P>","std::fs::ReadDir","std::collections::hash_set::DrainFilter<'_, K, F>","std::vec::IntoIter<T, A>","std::collections::binary_heap::IntoIter<T>","std::iter::Inspect<I, F>","std::sys_common::wstr::WStrUnits<'_>","std::ops::Range<A>","std::sys::unix::fs::ReadDir","std::str::EscapeDebug<'a>","std::slice::ChunksExactMut<'a, T>","std::ops::index_range::IndexRange","std::slice::ChunksExact<'a, T>","std::str::SplitN<'a, P>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::os::unix::net::ScmRights<'a>","std::char::EscapeUnicode","std::char::EscapeDefault","std::path::Components<'a>","std::str::Lines<'a>","std::str::RSplitN<'a, P>","std::iter::SkipWhile<I, P>","std::process::CommandArgs<'a>","std::collections::hash_map::IntoValues<K, V>","std::iter::RepeatWith<F>","std::slice::Iter<'a, T>","std::vec::DrainFilter<'_, T, F, A>","std::sys_common::net::LookupHost","std::collections::hash_set::Iter<'a, K>","std::str::RMatches<'a, P>","std::sys::unix::os::Env","std::iter::Cycle<I>","<&mut I as std::iter::Iterator>","std::collections::hash_set::Union<'a, T, S>","std::collections::btree_set::Iter<'a, T>","std::result::IterMut<'a, T>","std::iter::Filter<I, P>","std::collections::linked_list::IterMut<'a, T>","std::vec::Drain<'_, T, A>","std::net::IntoIncoming","std::slice::RSplitMut<'a, T, P>","std::char::ToLowercase","std::option::IterMut<'a, A>","std::result::Iter<'a, T>","std::collections::btree_map::IterMut<'a, K, V>","std::ops::RangeFrom<A>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::collections::linked_list::DrainFilter<'_, T, F>","std::collections::btree_map::IntoValues<K, V, A>","std::slice::SplitInclusive<'a, T, P>","std::net::Incoming<'a>","std::iter::Successors<T, F>","std::iter::Cloned<I>","std::collections::hash_set::Intersection<'a, T, S>","std::collections::btree_set::Difference<'a, T, A>","std::iter::IntersperseWith<I, G>","std::str::SplitWhitespace<'a>","std::str::SplitInclusive<'a, P>","std::slice::Windows<'a, T>","std::iter::MapWhile<I, P>","std::iter::FilterMap<I, F>","std::collections::hash_map::IntoKeys<K, V>","std::slice::IterMut<'a, T>","std::iter::sources::from_generator::FromGenerator<G>","std::str::EncodeUtf16<'a>","std::iter::FromFn<F>","std::path::Ancestors<'a>","std::io::Lines<B>","std::iter::Skip<I>","std::collections::hash_map::Iter<'a, K, V>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::slice::EscapeAscii<'a>","std::sys::unix::process::process_common::CommandArgs<'a>","std::vec::Splice<'_, I, A>","std::str::Utf8Chunks<'a>","std::collections::linked_list::IntoIter<T>","std::env::Vars","std::option::Iter<'a, A>","std::slice::Split<'a, T, P>","std::char::CaseMappingIter","std::collections::binary_heap::DrainSorted<'_, T>","std::sync::mpsc::Iter<'a, T>","std::collections::binary_heap::Iter<'a, T>","std::iter::Empty<T>","std::iter::Take<I>","std::char::EscapeDebug","std::sync::mpsc::TryIter<'a, T>","std::sys::unix::args::Args","std::array::IntoIter<T, N>","std::iter::StepBy<I>","std::collections::btree_map::ValuesMut<'a, K, V>","std::slice::Chunks<'a, T>","std::iter::ByRefSized<'_, I>","std::io::Split<B>","std::iter::Zip<A, B>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend":{"K":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError"],"T":["<I as std::iter::IntoIterator>","array_of_tables::ArrayOfTables","<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","table::Table","array::Array","inline_table::InlineTable"],"V":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend(p0, p1);
+crate::<inline_table::InlineTable as std::iter::Extend<(K, V)>>::extend(p0, p1);
+<inline_table::InlineTable>::extend(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["std::marker::Sized","std::iter::IntoIterator"],"K":["std::marker::Sized","std::convert::Into"],"V":["std::convert::Into","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::path::Iter<'a>","std::str::RSplit<'a, P>","std::iter::SkipWhile<I, P>","std::env::Vars","std::ascii::EscapeDefault","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::vec_deque::IntoIter<T, A>","std::char::DecodeUtf16<I>","std::iter::MapWhile<I, P>","std::sys::unix::os::Env","std::collections::hash_set::DrainFilter<'_, K, F>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","<&mut I as std::iter::Iterator>","std::iter::Take<I>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::str::SplitAsciiWhitespace<'a>","std::slice::SplitInclusiveMut<'a, T, P>","std::collections::hash_set::Iter<'a, K>","std::iter::TakeWhile<I, P>","std::slice::Windows<'a, T>","std::str::Chars<'a>","std::str::SplitInclusive<'a, P>","std::iter::Once<T>","std::iter::FromFn<F>","std::char::EscapeDebug","std::iter::ByRefSized<'_, I>","std::path::Components<'a>","std::iter::Flatten<I>","std::slice::RSplit<'a, T, P>","std::char::ToLowercase","std::sys_common::net::LookupHost","std::iter::Map<I, F>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::slice::Split<'a, T, P>","std::result::Iter<'a, T>","std::vec::Splice<'_, I, A>","std::ops::RangeInclusive<A>","std::slice::RChunksMut<'a, T>","std::collections::hash_map::Values<'a, K, V>","std::str::EscapeDebug<'a>","std::collections::vec_deque::Drain<'_, T, A>","std::iter::Chain<A, B>","std::slice::GroupByMut<'a, T, P>","std::iter::Zip<A, B>","std::char::EscapeUnicode","std::slice::RSplitNMut<'a, T, P>","std::str::RSplitTerminator<'a, P>","std::str::Matches<'a, P>","std::slice::SplitInclusive<'a, T, P>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::str::EscapeUnicode<'a>","std::path::Ancestors<'a>","std::str::MatchIndices<'a, P>","std::collections::btree_map::IntoKeys<K, V, A>","std::env::Args","std::sys::unix::args::Args","std::collections::linked_list::IterMut<'a, T>","std::iter::OnceWith<F>","std::collections::binary_heap::Iter<'a, T>","std::slice::ChunksExactMut<'a, T>","std::collections::btree_set::SymmetricDifference<'a, T>","std::result::IntoIter<T>","std::sync::mpsc::Iter<'a, T>","std::slice::IterMut<'a, T>","std::collections::binary_heap::IntoIterSorted<T>","std::collections::btree_set::Difference<'a, T, A>","std::vec::Drain<'_, T, A>","std::io::Split<B>","std::iter::Inspect<I, F>","std::vec::IntoIter<T, A>","std::str::SplitTerminator<'a, P>","std::iter::IntersperseWith<I, G>","std::str::RMatchIndices<'a, P>","std::iter::Intersperse<I>","std::slice::ArrayWindows<'a, T, N>","std::iter::Repeat<A>","std::option::Iter<'a, A>","std::slice::ChunksExact<'a, T>","std::io::Lines<B>","std::sys::unix::process::process_common::CommandArgs<'a>","core::slice::iter::GenericSplitN<I>","std::str::SplitN<'a, P>","std::iter::Copied<I>","std::collections::hash_map::Drain<'a, K, V>","std::boxed::Box<I, A>","std::slice::Iter<'a, T>","std::iter::Fuse<I>","std::collections::vec_deque::Iter<'a, T>","std::slice::ChunksMut<'a, T>","std::str::RMatches<'a, P>","std::net::Incoming<'a>","std::str::EscapeDefault<'a>","std::env::ArgsOs","std::iter::ArrayChunks<I, N>","std::slice::Chunks<'a, T>","std::iter::Empty<T>","std::collections::hash_map::ValuesMut<'a, K, V>","std::str::Utf8Chunks<'a>","std::collections::hash_set::Drain<'a, K>","std::env::SplitPaths<'a>","std::collections::binary_heap::Drain<'_, T>","std::collections::binary_heap::IntoIter<T>","std::slice::RSplitN<'a, T, P>","std::str::CharIndices<'a>","std::result::IterMut<'a, T>","std::slice::SplitMut<'a, T, P>","std::iter::Peekable<I>","std::ops::RangeFrom<A>","std::collections::btree_map::IterMut<'a, K, V>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::collections::hash_set::Union<'a, T, S>","std::collections::btree_map::IntoIter<K, V, A>","std::char::ToUppercase","std::str::EncodeUtf16<'a>","std::iter::RepeatWith<F>","std::array::IntoIter<T, N>","std::os::unix::net::ScmRights<'a>","std::iter::Cycle<I>","std::iter::Cloned<I>","std::os::unix::net::ScmCredentials<'a>","std::iter::StepBy<I>","std::slice::RChunksExactMut<'a, T>","std::collections::btree_map::Keys<'a, K, V>","std::collections::hash_map::Iter<'a, K, V>","std::char::CaseMappingIter","std::slice::SplitN<'a, T, P>","std::os::unix::net::Messages<'a>","std::sys_common::wtf8::EncodeWide<'a>","std::collections::vec_deque::IterMut<'a, T>","std::slice::RChunks<'a, T>","std::fs::ReadDir","std::io::Bytes<R>","std::process::CommandEnvs<'a>","std::option::Item<A>","std::str::RSplitN<'a, P>","std::iter::Filter<I, P>","std::collections::hash_set::Difference<'a, T, S>","std::ops::index_range::IndexRange","std::slice::GroupBy<'a, T, P>","std::slice::SplitNMut<'a, T, P>","std::char::EscapeDefault","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::btree_set::IntoIter<T, A>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::iter::Skip<I>","std::collections::btree_set::Union<'a, T>","std::str::Lines<'a>","std::slice::ArrayChunksMut<'a, T, N>","std::option::IterMut<'a, A>","std::iter::adapters::GenericShunt<'_, I, R>","std::collections::hash_map::IntoKeys<K, V>","std::collections::btree_set::Intersection<'a, T, A>","std::process::CommandArgs<'a>","std::collections::btree_map::IntoValues<K, V, A>","std::vec::DrainFilter<'_, T, F, A>","std::ops::Range<A>","std::collections::hash_map::IntoIter<K, V>","std::collections::btree_map::Range<'a, K, V>","std::collections::hash_map::Keys<'a, K, V>","std::iter::RepeatN<A>","std::collections::btree_map::Iter<'a, K, V>","std::iter::FlatMap<I, U, F>","std::collections::btree_map::RangeMut<'a, K, V>","std::net::IntoIncoming","std::collections::linked_list::DrainFilter<'_, T, F>","std::string::Drain<'_>","std::os::unix::net::Incoming<'a>","core::error::Source<'a>","std::slice::EscapeAscii<'a>","std::slice::ArrayChunks<'a, T, N>","std::iter::Enumerate<I>","std::collections::linked_list::IntoIter<T>","std::iter::Rev<I>","std::sys::unix::fs::ReadDir","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::str::LinesAny<'a>","std::collections::linked_list::Iter<'a, T>","std::collections::hash_map::IterMut<'a, K, V>","std::option::IntoIter<A>","std::str::Bytes<'_>","std::sync::mpsc::IntoIter<T>","std::str::Split<'a, P>","std::collections::btree_set::Iter<'a, T>","std::collections::hash_set::Intersection<'a, T, S>","std::iter::sources::from_generator::FromGenerator<G>","std::iter::Successors<T, F>","std::iter::FilterMap<I, F>","std::collections::hash_map::IntoValues<K, V>","std::str::SplitWhitespace<'a>","std::collections::btree_set::Range<'a, T>","std::slice::RSplitMut<'a, T, P>","std::slice::RChunksExact<'a, T>","std::env::VarsOs","std::iter::Scan<I, St, F>","std::collections::btree_map::Values<'a, K, V>","std::sys::unix::os::SplitPaths<'a>","std::collections::hash_set::IntoIter<K>","std::sync::mpsc::TryIter<'a, T>","std::sys_common::wstr::WStrUnits<'_>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","array::Array","inline_table::InlineTable","indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>","table::Table","array_of_tables::ArrayOfTables"],"K":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"],"V":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+crate::<inline_table::InlineTable as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+<inline_table::InlineTable>::from_iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.into_iter();
+<inline_table::InlineTable as std::iter::IntoIterator>::into_iter(p0);
+crate::<inline_table::InlineTable as std::iter::IntoIterator>::into_iter(p0);
+<inline_table::InlineTable>::into_iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs <&'s inline_table::InlineTable as std::iter::IntoIterator>::into_iter
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.into_iter();
+<&'s inline_table::InlineTable as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'s inline_table::InlineTable as std::iter::IntoIterator>::into_iter(p0);
+<&'s inline_table::InlineTable>::into_iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.iter();
+<inline_table::InlineTable as table::TableLike>::iter(p0);
+crate::<inline_table::InlineTable as table::TableLike>::iter(p0);
+<inline_table::InlineTable>::iter(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.iter_mut();
+<inline_table::InlineTable as table::TableLike>::iter_mut(p0);
+crate::<inline_table::InlineTable as table::TableLike>::iter_mut(p0);
+<inline_table::InlineTable>::iter_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.clear();
+<inline_table::InlineTable as table::TableLike>::clear(p0);
+crate::<inline_table::InlineTable as table::TableLike>::clear(p0);
+<inline_table::InlineTable>::clear(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.entry(&p1);
+<inline_table::InlineTable as table::TableLike>::entry(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::entry(p0, &p1);
+<inline_table::InlineTable>::entry(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::entry_format
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+<inline_table::InlineTable as table::TableLike>::entry_format(p0, p1);
+crate::<inline_table::InlineTable as table::TableLike>::entry_format(p0, p1);
+<inline_table::InlineTable>::entry_format(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+<inline_table::InlineTable as table::TableLike>::get(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::get(p0, &p1);
+<inline_table::InlineTable>::get(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+<inline_table::InlineTable as table::TableLike>::get_mut(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::get_mut(p0, &p1);
+<inline_table::InlineTable>::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get_key_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+<inline_table::InlineTable as table::TableLike>::get_key_value(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::get_key_value(p0, &p1);
+<inline_table::InlineTable>::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get_key_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+<inline_table::InlineTable as table::TableLike>::get_key_value_mut(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::get_key_value_mut(p0, &p1);
+<inline_table::InlineTable>::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::contains_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+<inline_table::InlineTable as table::TableLike>::contains_key(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::contains_key(p0, &p1);
+<inline_table::InlineTable>::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(&p1, p2);
+<inline_table::InlineTable as table::TableLike>::insert(p0, &p1, p2);
+crate::<inline_table::InlineTable as table::TableLike>::insert(p0, &p1, p2);
+<inline_table::InlineTable>::insert(p0, &p1, p2);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+<inline_table::InlineTable as table::TableLike>::remove(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::remove(p0, &p1);
+<inline_table::InlineTable>::remove(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::get_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.get_values();
+<inline_table::InlineTable as table::TableLike>::get_values(p0);
+crate::<inline_table::InlineTable as table::TableLike>::get_values(p0);
+<inline_table::InlineTable>::get_values(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.fmt();
+<inline_table::InlineTable as table::TableLike>::fmt(p0);
+crate::<inline_table::InlineTable as table::TableLike>::fmt(p0);
+<inline_table::InlineTable>::fmt(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::sort_values
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.sort_values();
+<inline_table::InlineTable as table::TableLike>::sort_values(p0);
+crate::<inline_table::InlineTable as table::TableLike>::sort_values(p0);
+<inline_table::InlineTable>::sort_values(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::set_dotted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+<inline_table::InlineTable as table::TableLike>::set_dotted(p0, p1);
+crate::<inline_table::InlineTable as table::TableLike>::set_dotted(p0, p1);
+<inline_table::InlineTable>::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::is_dotted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+p0.is_dotted();
+<inline_table::InlineTable as table::TableLike>::is_dotted(p0);
+crate::<inline_table::InlineTable as table::TableLike>::is_dotted(p0);
+<inline_table::InlineTable>::is_dotted(p0);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::key_decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+<inline_table::InlineTable as table::TableLike>::key_decor_mut(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::key_decor_mut(p0, &p1);
+<inline_table::InlineTable>::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs <inline_table::InlineTable as table::TableLike>::key_decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+<inline_table::InlineTable as table::TableLike>::key_decor(p0, &p1);
+crate::<inline_table::InlineTable as table::TableLike>::key_decor(p0, &p1);
+<inline_table::InlineTable>::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineEntry<'a>
+p0.key();
+inline_table::InlineEntry::<'a>::key(p0);
+crate::inline_table::InlineEntry::<'a>::key(p0);
+<inline_table::InlineEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineEntry::<'a>::or_insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.or_insert(p1);
+inline_table::InlineEntry::<'a>::or_insert(p0, p1);
+crate::inline_table::InlineEntry::<'a>::or_insert(p0, p1);
+<inline_table::InlineEntry<'a>>::or_insert(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineEntry::<'a>::or_insert_with
'a
deps:{"inline_table::InlineEntry::<'a>::or_insert_with":{"F":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"inline_table::InlineEntry::<'a>::or_insert_with":{"F":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.or_insert_with(p1);
+inline_table::InlineEntry::<'a>::or_insert_with(p0, p1);
+crate::inline_table::InlineEntry::<'a>::or_insert_with(p0, p1);
+<inline_table::InlineEntry<'a>>::or_insert_with(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.key();
+inline_table::InlineOccupiedEntry::<'a>::key(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::key(p0);
+<inline_table::InlineOccupiedEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::key_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.key_mut();
+inline_table::InlineOccupiedEntry::<'a>::key_mut(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::key_mut(p0);
+<inline_table::InlineOccupiedEntry<'a>>::key_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::get
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.get();
+inline_table::InlineOccupiedEntry::<'a>::get(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::get(p0);
+<inline_table::InlineOccupiedEntry<'a>>::get(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::get_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.get_mut();
+inline_table::InlineOccupiedEntry::<'a>::get_mut(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::get_mut(p0);
+<inline_table::InlineOccupiedEntry<'a>>::get_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::into_mut
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.into_mut();
+inline_table::InlineOccupiedEntry::<'a>::into_mut(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::into_mut(p0);
+<inline_table::InlineOccupiedEntry<'a>>::into_mut(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1);
+inline_table::InlineOccupiedEntry::<'a>::insert(p0, p1);
+crate::inline_table::InlineOccupiedEntry::<'a>::insert(p0, p1);
+<inline_table::InlineOccupiedEntry<'a>>::insert(p0, p1);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineOccupiedEntry::<'a>::remove
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineOccupiedEntry<'a>
+p0.remove();
+inline_table::InlineOccupiedEntry::<'a>::remove(p0);
+crate::inline_table::InlineOccupiedEntry::<'a>::remove(p0);
+<inline_table::InlineOccupiedEntry<'a>>::remove(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineVacantEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // inline_table::InlineVacantEntry<'a>
+p0.key();
+inline_table::InlineVacantEntry::<'a>::key(p0);
+crate::inline_table::InlineVacantEntry::<'a>::key(p0);
+<inline_table::InlineVacantEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/inline_table.rs inline_table::InlineVacantEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineVacantEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1);
+inline_table::InlineVacantEntry::<'a>::insert(p0, p1);
+crate::inline_table::InlineVacantEntry::<'a>::insert(p0, p1);
+<inline_table::InlineVacantEntry<'a>>::insert(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::default::Default>::default
deps:{}
candidates:{}
+<internal_string::InternalString as std::default::Default>::default();
+crate::<internal_string::InternalString as std::default::Default>::default();
+<internal_string::InternalString>::default();
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.clone();
+<internal_string::InternalString as std::clone::Clone>::clone(p0);
+crate::<internal_string::InternalString as std::clone::Clone>::clone(p0);
+<internal_string::InternalString>::clone(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.eq(p1);
+<internal_string::InternalString as std::cmp::PartialEq>::eq(p0, p1);
+crate::<internal_string::InternalString as std::cmp::PartialEq>::eq(p0, p1);
+<internal_string::InternalString>::eq(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.assert_receiver_is_total_eq();
+<internal_string::InternalString as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<internal_string::InternalString as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<internal_string::InternalString>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.partial_cmp(p1);
+<internal_string::InternalString as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<internal_string::InternalString as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<internal_string::InternalString>::partial_cmp(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.cmp(p1);
+<internal_string::InternalString as std::cmp::Ord>::cmp(p0, p1);
+crate::<internal_string::InternalString as std::cmp::Ord>::cmp(p0, p1);
+<internal_string::InternalString>::cmp(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<internal_string::InternalString as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<internal_string::InternalString as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<internal_string::InternalString as std::hash::Hash>::hash(p0, p1);
+crate::<internal_string::InternalString as std::hash::Hash>::hash(p0, p1);
+<internal_string::InternalString>::hash(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs internal_string::InternalString::new
deps:{}
candidates:{}
+internal_string::InternalString::new();
+crate::internal_string::InternalString::new();
+<internal_string::InternalString>::new();
-----------------
crates/toml_edit/src/internal_string.rs internal_string::InternalString::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.as_str();
+internal_string::InternalString::as_str(p0);
+crate::internal_string::InternalString::as_str(p0);
+<internal_string::InternalString>::as_str(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<internal_string::InternalString as std::fmt::Debug>::fmt(p0, p1);
+crate::<internal_string::InternalString as std::fmt::Debug>::fmt(p0, p1);
+<internal_string::InternalString>::fmt(p0, p1);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.deref();
+<internal_string::InternalString as std::ops::Deref>::deref(p0);
+crate::<internal_string::InternalString as std::ops::Deref>::deref(p0);
+<internal_string::InternalString>::deref(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::borrow::Borrow<str>>::borrow
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.borrow();
+<internal_string::InternalString as std::borrow::Borrow<str>>::borrow(p0);
+crate::<internal_string::InternalString as std::borrow::Borrow<str>>::borrow(p0);
+<internal_string::InternalString>::borrow(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::AsRef<str>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+p0.as_ref();
+<internal_string::InternalString as std::convert::AsRef<str>>::as_ref(p0);
+crate::<internal_string::InternalString as std::convert::AsRef<str>>::as_ref(p0);
+<internal_string::InternalString>::as_ref(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<&str>>::from
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<internal_string::InternalString as std::convert::From<&str>>::from(&p0);
+crate::<internal_string::InternalString as std::convert::From<&str>>::from(&p0);
+<internal_string::InternalString>::from(&p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<internal_string::InternalString as std::convert::From<std::string::String>>::from(p0);
+crate::<internal_string::InternalString as std::convert::From<std::string::String>>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<&std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<internal_string::InternalString as std::convert::From<&std::string::String>>::from(p0);
+crate::<internal_string::InternalString as std::convert::From<&std::string::String>>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<&internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<internal_string::InternalString as std::convert::From<&internal_string::InternalString>>::from(p0);
+crate::<internal_string::InternalString as std::convert::From<&internal_string::InternalString>>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::convert::From<std::boxed::Box<str>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::boxed::Box<str>
+<internal_string::InternalString as std::convert::From<std::boxed::Box<str>>>::from(p0);
+crate::<internal_string::InternalString as std::convert::From<std::boxed::Box<str>>>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<internal_string::InternalString as std::str::FromStr>::from_str(&p0);
+crate::<internal_string::InternalString as std::str::FromStr>::from_str(&p0);
+<internal_string::InternalString>::from_str(&p0);
-----------------
crates/toml_edit/src/internal_string.rs <internal_string::InternalString as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<internal_string::InternalString as std::fmt::Display>::fmt(p0, p1);
+crate::<internal_string::InternalString as std::fmt::Display>::fmt(p0, p1);
+<internal_string::InternalString>::fmt(p0, p1);
-----------------
crates/toml_edit/src/item.rs <item::Item as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<item::Item as std::fmt::Debug>::fmt(p0, p1);
+crate::<item::Item as std::fmt::Debug>::fmt(p0, p1);
+<item::Item>::fmt(p0, p1);
-----------------
crates/toml_edit/src/item.rs <item::Item as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.clone();
+<item::Item as std::clone::Clone>::clone(p0);
+crate::<item::Item as std::clone::Clone>::clone(p0);
+<item::Item>::clone(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::or_insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.or_insert(p1);
+item::Item::or_insert(p0, p1);
+crate::item::Item::or_insert(p0, p1);
+<item::Item>::or_insert(p0, p1);
-----------------
crates/toml_edit/src/item.rs item::Item::type_name
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.type_name();
+item::Item::type_name(p0);
+crate::item::Item::type_name(p0);
+<item::Item>::type_name(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::get
deps:{"<&'a T as index::Index>":{},"item::Item::get":{"I":["index::Index","std::marker::Sized"]}}
candidates:{"<&'a T as index::Index>":{},"item::Item::get":{"I":["<&'a T as index::Index>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.get(p1);
+item::Item::get(p0, p1);
+crate::item::Item::get(p0, p1);
+<item::Item>::get(p0, p1);
-----------------
crates/toml_edit/src/item.rs item::Item::get_mut
deps:{"<&'a T as index::Index>":{},"item::Item::get_mut":{"I":["index::Index","std::marker::Sized"]}}
candidates:{"<&'a T as index::Index>":{},"item::Item::get_mut":{"I":["<&'a T as index::Index>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.get_mut(p1);
+item::Item::get_mut(p0, p1);
+crate::item::Item::get_mut(p0, p1);
+<item::Item>::get_mut(p0, p1);
-----------------
crates/toml_edit/src/item.rs item::Item::as_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_value();
+item::Item::as_value(p0);
+crate::item::Item::as_value(p0);
+<item::Item>::as_value(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_table();
+item::Item::as_table(p0);
+crate::item::Item::as_table(p0);
+<item::Item>::as_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_array_of_tables
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_array_of_tables();
+item::Item::as_array_of_tables(p0);
+crate::item::Item::as_array_of_tables(p0);
+<item::Item>::as_array_of_tables(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_value_mut();
+item::Item::as_value_mut(p0);
+crate::item::Item::as_value_mut(p0);
+<item::Item>::as_value_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_table_mut();
+item::Item::as_table_mut(p0);
+crate::item::Item::as_table_mut(p0);
+<item::Item>::as_table_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_array_of_tables_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_array_of_tables_mut();
+item::Item::as_array_of_tables_mut(p0);
+crate::item::Item::as_array_of_tables_mut(p0);
+<item::Item>::as_array_of_tables_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::into_value
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.into_value();
+item::Item::into_value(p0);
+crate::item::Item::into_value(p0);
+<item::Item>::into_value(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::make_value
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.make_value();
+item::Item::make_value(p0);
+crate::item::Item::make_value(p0);
+<item::Item>::make_value(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::into_table
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.into_table();
+item::Item::into_table(p0);
+crate::item::Item::into_table(p0);
+<item::Item>::into_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::into_array_of_tables
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.into_array_of_tables();
+item::Item::into_array_of_tables(p0);
+crate::item::Item::into_array_of_tables(p0);
+<item::Item>::into_array_of_tables(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::make_item
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.make_item();
+item::Item::make_item(p0);
+crate::item::Item::make_item(p0);
+<item::Item>::make_item(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_value();
+item::Item::is_value(p0);
+crate::item::Item::is_value(p0);
+<item::Item>::is_value(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_table();
+item::Item::is_table(p0);
+crate::item::Item::is_table(p0);
+<item::Item>::is_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_array_of_tables
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_array_of_tables();
+item::Item::is_array_of_tables(p0);
+crate::item::Item::is_array_of_tables(p0);
+<item::Item>::is_array_of_tables(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_none
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_none();
+item::Item::is_none(p0);
+crate::item::Item::is_none(p0);
+<item::Item>::is_none(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_integer();
+item::Item::as_integer(p0);
+crate::item::Item::as_integer(p0);
+<item::Item>::as_integer(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_integer();
+item::Item::is_integer(p0);
+crate::item::Item::is_integer(p0);
+<item::Item>::is_integer(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_float();
+item::Item::as_float(p0);
+crate::item::Item::as_float(p0);
+<item::Item>::as_float(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_float();
+item::Item::is_float(p0);
+crate::item::Item::is_float(p0);
+<item::Item>::is_float(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_bool();
+item::Item::as_bool(p0);
+crate::item::Item::as_bool(p0);
+<item::Item>::as_bool(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_bool();
+item::Item::is_bool(p0);
+crate::item::Item::is_bool(p0);
+<item::Item>::is_bool(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_str();
+item::Item::as_str(p0);
+crate::item::Item::as_str(p0);
+<item::Item>::as_str(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_str();
+item::Item::is_str(p0);
+crate::item::Item::is_str(p0);
+<item::Item>::is_str(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_datetime();
+item::Item::as_datetime(p0);
+crate::item::Item::as_datetime(p0);
+<item::Item>::as_datetime(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_datetime();
+item::Item::is_datetime(p0);
+crate::item::Item::is_datetime(p0);
+<item::Item>::is_datetime(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_array();
+item::Item::as_array(p0);
+crate::item::Item::as_array(p0);
+<item::Item>::as_array(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_array_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_array_mut();
+item::Item::as_array_mut(p0);
+crate::item::Item::as_array_mut(p0);
+<item::Item>::as_array_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_array();
+item::Item::is_array(p0);
+crate::item::Item::is_array(p0);
+<item::Item>::is_array(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_inline_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_inline_table();
+item::Item::as_inline_table(p0);
+crate::item::Item::as_inline_table(p0);
+<item::Item>::as_inline_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_inline_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_inline_table_mut();
+item::Item::as_inline_table_mut(p0);
+crate::item::Item::as_inline_table_mut(p0);
+<item::Item>::as_inline_table_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_inline_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_inline_table();
+item::Item::is_inline_table(p0);
+crate::item::Item::is_inline_table(p0);
+<item::Item>::is_inline_table(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_table_like
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_table_like();
+item::Item::as_table_like(p0);
+crate::item::Item::as_table_like(p0);
+<item::Item>::as_table_like(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::as_table_like_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
+p0.as_table_like_mut();
+item::Item::as_table_like_mut(p0);
+crate::item::Item::as_table_like_mut(p0);
+<item::Item>::as_table_like_mut(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::is_table_like
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.is_table_like();
+item::Item::is_table_like(p0);
+crate::item::Item::is_table_like(p0);
+<item::Item>::is_table_like(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
+p0.span();
+item::Item::span(p0);
+crate::item::Item::span(p0);
+<item::Item>::span(p0);
-----------------
crates/toml_edit/src/item.rs item::Item::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+item::Item::despan(p0, &p1);
+crate::item::Item::despan(p0, &p1);
+<item::Item>::despan(p0, &p1);
-----------------
crates/toml_edit/src/item.rs <item::Item as std::default::Default>::default
deps:{}
candidates:{}
+<item::Item as std::default::Default>::default();
+crate::<item::Item as std::default::Default>::default();
+<item::Item>::default();
-----------------
crates/toml_edit/src/item.rs <item::Item as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<item::Item as std::str::FromStr>::from_str(&p0);
+crate::<item::Item as std::str::FromStr>::from_str(&p0);
+<item::Item>::from_str(&p0);
-----------------
crates/toml_edit/src/item.rs <item::Item as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // item::Item
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<item::Item as std::fmt::Display>::fmt(p0, p1);
+crate::<item::Item as std::fmt::Display>::fmt(p0, p1);
+<item::Item>::fmt(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<key::Key as std::fmt::Debug>::fmt(p0, p1);
+crate::<key::Key as std::fmt::Debug>::fmt(p0, p1);
+<key::Key>::fmt(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.clone();
+<key::Key as std::clone::Clone>::clone(p0);
+crate::<key::Key as std::clone::Clone>::clone(p0);
+<key::Key>::clone(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::new
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"key::Key::new":{"impl Into<InternalString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"key::Key::new":{"impl Into<InternalString>":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl Into<InternalString>
+key::Key::new(p0);
+crate::key::Key::new(p0);
+<key::Key>::new(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::parse
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+key::Key::parse(&p0);
+crate::key::Key::parse(&p0);
+<key::Key>::parse(&p0);
-----------------
crates/toml_edit/src/key.rs key::Key::with_repr_unchecked
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.with_repr_unchecked(p1);
+key::Key::with_repr_unchecked(p0, p1);
+crate::key::Key::with_repr_unchecked(p0, p1);
+<key::Key>::with_repr_unchecked(p0, p1);
-----------------
crates/toml_edit/src/key.rs key::Key::with_decor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.with_decor(p1);
+key::Key::with_decor(p0, p1);
+crate::key::Key::with_decor(p0, p1);
+<key::Key>::with_decor(p0, p1);
-----------------
crates/toml_edit/src/key.rs key::Key::as_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::Key
+p0.as_mut();
+key::Key::as_mut(p0);
+crate::key::Key::as_mut(p0);
+<key::Key>::as_mut(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.get();
+key::Key::get(p0);
+crate::key::Key::get(p0);
+<key::Key>::get(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::get_internal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.get_internal();
+key::Key::get_internal(p0);
+crate::key::Key::get_internal(p0);
+<key::Key>::get_internal(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::as_repr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.as_repr();
+key::Key::as_repr(p0);
+crate::key::Key::as_repr(p0);
+<key::Key>::as_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::default_repr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.default_repr();
+key::Key::default_repr(p0);
+crate::key::Key::default_repr(p0);
+<key::Key>::default_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::display_repr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.display_repr();
+key::Key::display_repr(p0);
+crate::key::Key::display_repr(p0);
+<key::Key>::display_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::Key
+p0.decor_mut();
+key::Key::decor_mut(p0);
+crate::key::Key::decor_mut(p0);
+<key::Key>::decor_mut(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.decor();
+key::Key::decor(p0);
+crate::key::Key::decor(p0);
+<key::Key>::decor(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+key::Key::despan(p0, &p1);
+crate::key::Key::despan(p0, &p1);
+<key::Key>::despan(p0, &p1);
-----------------
crates/toml_edit/src/key.rs key::Key::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::Key
+p0.fmt();
+key::Key::fmt(p0);
+crate::key::Key::fmt(p0);
+<key::Key>::fmt(p0);
-----------------
crates/toml_edit/src/key.rs key::Key::try_parse_simple
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+key::Key::try_parse_simple(&p0);
+crate::key::Key::try_parse_simple(&p0);
+<key::Key>::try_parse_simple(&p0);
-----------------
crates/toml_edit/src/key.rs key::Key::try_parse_path
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+key::Key::try_parse_path(&p0);
+crate::key::Key::try_parse_path(&p0);
+<key::Key>::try_parse_path(&p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.deref();
+<key::Key as std::ops::Deref>::deref(p0);
+crate::<key::Key as std::ops::Deref>::deref(p0);
+<key::Key>::deref(p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<key::Key as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<key::Key as std::hash::Hash>::hash":{"H":["std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<key::Key as std::hash::Hash>::hash(p0, p1);
+crate::<key::Key as std::hash::Hash>::hash(p0, p1);
+<key::Key>::hash(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.cmp(p1);
+<key::Key as std::cmp::Ord>::cmp(p0, p1);
+crate::<key::Key as std::cmp::Ord>::cmp(p0, p1);
+<key::Key>::cmp(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.partial_cmp(p1);
+<key::Key as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<key::Key as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<key::Key>::partial_cmp(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.eq(p1);
+<key::Key as std::cmp::PartialEq>::eq(p0, p1);
+crate::<key::Key as std::cmp::PartialEq>::eq(p0, p1);
+<key::Key>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialEq<str>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<key::Key as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<key::Key as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<key::Key>::eq(p0, &p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialEq<&'s str>>::eq
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & "a"; // None+&str
+p0.eq(p1);
+<key::Key as std::cmp::PartialEq<&'s str>>::eq(p0, p1);
+crate::<key::Key as std::cmp::PartialEq<&'s str>>::eq(p0, p1);
+<key::Key>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::cmp::PartialEq<std::string::String>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.eq(p1);
+<key::Key as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+crate::<key::Key as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+<key::Key>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<key::Key as std::fmt::Display>::fmt(p0, p1);
+crate::<key::Key as std::fmt::Display>::fmt(p0, p1);
+<key::Key>::fmt(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<key::Key as std::str::FromStr>::from_str(&p0);
+crate::<key::Key as std::str::FromStr>::from_str(&p0);
+<key::Key>::from_str(&p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::convert::From<&'b str>>::from
'b
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<key::Key as std::convert::From<&'b str>>::from(&p0);
+crate::<key::Key as std::convert::From<&'b str>>::from(&p0);
+<key::Key>::from(&p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::convert::From<&'b std::string::String>>::from
'b
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<key::Key as std::convert::From<&'b std::string::String>>::from(p0);
+crate::<key::Key as std::convert::From<&'b std::string::String>>::from(p0);
+<key::Key>::from(p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<key::Key as std::convert::From<std::string::String>>::from(p0);
+crate::<key::Key as std::convert::From<std::string::String>>::from(p0);
+<key::Key>::from(p0);
-----------------
crates/toml_edit/src/key.rs <key::Key as std::convert::From<internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<key::Key as std::convert::From<internal_string::InternalString>>::from(p0);
+crate::<key::Key as std::convert::From<internal_string::InternalString>>::from(p0);
+<key::Key>::from(p0);
-----------------
crates/toml_edit/src/key.rs key::<impl std::convert::From<key::Key> for internal_string::InternalString>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // key::Key
+key::<impl std::convert::From<key::Key> for internal_string::InternalString>::from(p0);
+crate::key::<impl std::convert::From<key::Key> for internal_string::InternalString>::from(p0);
+<internal_string::InternalString>::from(p0);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::fmt::Debug>::fmt
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<key::KeyMut<'k> as std::fmt::Debug>::fmt(p0, p1);
+crate::<key::KeyMut<'k> as std::fmt::Debug>::fmt(p0, p1);
+<key::KeyMut<'k>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::cmp::Eq>::assert_receiver_is_total_eq
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.assert_receiver_is_total_eq();
+<key::KeyMut<'k> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<key::KeyMut<'k> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<key::KeyMut<'k>>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::cmp::PartialEq>::eq
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.eq(p1);
+<key::KeyMut<'k> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<key::KeyMut<'k> as std::cmp::PartialEq>::eq(p0, p1);
+<key::KeyMut<'k>>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::cmp::PartialOrd>::partial_cmp
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.partial_cmp(p1);
+<key::KeyMut<'k> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<key::KeyMut<'k> as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<key::KeyMut<'k>>::partial_cmp(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::cmp::Ord>::cmp
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.cmp(p1);
+<key::KeyMut<'k> as std::cmp::Ord>::cmp(p0, p1);
+crate::<key::KeyMut<'k> as std::cmp::Ord>::cmp(p0, p1);
+<key::KeyMut<'k>>::cmp(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::hash::Hash>::hash
'k
deps:{"<&mut H as std::hash::Hasher>":{},"<key::KeyMut<'k> as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<key::KeyMut<'k> as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::boxed::Box<T, A>","std::hash::SipHasher","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<key::KeyMut<'k> as std::hash::Hash>::hash(p0, p1);
+crate::<key::KeyMut<'k> as std::hash::Hash>::hash(p0, p1);
+<key::KeyMut<'k>>::hash(p0, p1);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::get
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.get();
+key::KeyMut::<'k>::get(p0);
+crate::key::KeyMut::<'k>::get(p0);
+<key::KeyMut<'k>>::get(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::as_repr
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.as_repr();
+key::KeyMut::<'k>::as_repr(p0);
+crate::key::KeyMut::<'k>::as_repr(p0);
+<key::KeyMut<'k>>::as_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::default_repr
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.default_repr();
+key::KeyMut::<'k>::default_repr(p0);
+crate::key::KeyMut::<'k>::default_repr(p0);
+<key::KeyMut<'k>>::default_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::display_repr
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.display_repr();
+key::KeyMut::<'k>::display_repr(p0);
+crate::key::KeyMut::<'k>::display_repr(p0);
+<key::KeyMut<'k>>::display_repr(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::decor_mut
'k
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.decor_mut();
+key::KeyMut::<'k>::decor_mut(p0);
+crate::key::KeyMut::<'k>::decor_mut(p0);
+<key::KeyMut<'k>>::decor_mut(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::decor
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.decor();
+key::KeyMut::<'k>::decor(p0);
+crate::key::KeyMut::<'k>::decor(p0);
+<key::KeyMut<'k>>::decor(p0);
-----------------
crates/toml_edit/src/key.rs key::KeyMut::<'k>::fmt
'k
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.fmt();
+key::KeyMut::<'k>::fmt(p0);
+crate::key::KeyMut::<'k>::fmt(p0);
+<key::KeyMut<'k>>::fmt(p0);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::ops::Deref>::deref
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
+p0.deref();
+<key::KeyMut<'k> as std::ops::Deref>::deref(p0);
+crate::<key::KeyMut<'k> as std::ops::Deref>::deref(p0);
+<key::KeyMut<'k>>::deref(p0);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'s> as std::cmp::PartialEq<str>>::eq
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'s>
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<key::KeyMut<'s> as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<key::KeyMut<'s> as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<key::KeyMut<'s>>::eq(p0, &p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'s> as std::cmp::PartialEq<&'s str>>::eq
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'s>
let mut p1 = & "a"; // None+&str
+p0.eq(p1);
+<key::KeyMut<'s> as std::cmp::PartialEq<&'s str>>::eq(p0, p1);
+crate::<key::KeyMut<'s> as std::cmp::PartialEq<&'s str>>::eq(p0, p1);
+<key::KeyMut<'s>>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'s> as std::cmp::PartialEq<std::string::String>>::eq
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'s>
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.eq(p1);
+<key::KeyMut<'s> as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+crate::<key::KeyMut<'s> as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+<key::KeyMut<'s>>::eq(p0, p1);
-----------------
crates/toml_edit/src/key.rs <key::KeyMut<'k> as std::fmt::Display>::fmt
'k
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // key::KeyMut<'k>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<key::KeyMut<'k> as std::fmt::Display>::fmt(p0, p1);
+crate::<key::KeyMut<'k> as std::fmt::Display>::fmt(p0, p1);
+<key::KeyMut<'k>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::TomlError as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::TomlError as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::TomlError>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.clone();
+<parser::errors::TomlError as std::clone::Clone>::clone(p0);
+crate::<parser::errors::TomlError as std::clone::Clone>::clone(p0);
+<parser::errors::TomlError>::clone(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.assert_receiver_is_total_eq();
+<parser::errors::TomlError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<parser::errors::TomlError as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<parser::errors::TomlError>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.eq(p1);
+<parser::errors::TomlError as std::cmp::PartialEq>::eq(p0, p1);
+crate::<parser::errors::TomlError as std::cmp::PartialEq>::eq(p0, p1);
+<parser::errors::TomlError>::eq(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<parser::errors::TomlError as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<parser::errors::TomlError as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","std::hash::sip::Hasher<S>","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<parser::errors::TomlError as std::hash::Hash>::hash(p0, p1);
+crate::<parser::errors::TomlError as std::hash::Hash>::hash(p0, p1);
+<parser::errors::TomlError>::hash(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'_>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+parser::errors::TomlError::new(p0, p1);
+crate::parser::errors::TomlError::new(p0, p1);
+<parser::errors::TomlError>::new(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::message
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.message();
+parser::errors::TomlError::message(p0);
+crate::parser::errors::TomlError::message(p0);
+<parser::errors::TomlError>::message(p0);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::TomlError::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.span();
+parser::errors::TomlError::span(p0);
+crate::parser::errors::TomlError::span(p0);
+<parser::errors::TomlError>::span(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<parser::errors::TomlError as std::fmt::Display>::fmt(p0, p1);
+crate::<parser::errors::TomlError as std::fmt::Display>::fmt(p0, p1);
+<parser::errors::TomlError>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::TomlError as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::TomlError
+p0.description();
+<parser::errors::TomlError as std::error::Error>::description(p0);
+crate::<parser::errors::TomlError as std::error::Error>::description(p0);
+<parser::errors::TomlError>::description(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as std::fmt::Debug>::fmt
'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::ParserError<'b> as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::ParserError<'b> as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::ParserError<'b>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::from_error_kind
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&'b winnow::BStr>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
+<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::from_error_kind(p0, p1);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::from_error_kind(p0, p1);
+<parser::errors::ParserError<'b>>::from_error_kind(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::append
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::Located<&'b winnow::BStr>
let mut p2 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
+p0.append(p1, p2);
+<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::append(p0, p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::append(p0, p1, p2);
+<parser::errors::ParserError<'b>>::append(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::or
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
+p0.or(p1);
+<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::or(p0, p1);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<winnow::Located<&'b winnow::BStr>>>::or(p0, p1);
+<parser::errors::ParserError<'b>>::or(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::from_error_kind
'b
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
+<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::from_error_kind(&p0, p1);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::from_error_kind(&p0, p1);
+<parser::errors::ParserError<'b>>::from_error_kind(&p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::append
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
+p0.append(&p1, p2);
+<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::append(p0, &p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::append(p0, &p1, p2);
+<parser::errors::ParserError<'b>>::append(p0, &p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::or
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
+p0.or(p1);
+<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::or(p0, p1);
+crate::<parser::errors::ParserError<'b> as winnow::error::ParseError<&'b str>>::or(p0, p1);
+<parser::errors::ParserError<'b>>::or(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::ContextError<winnow::Located<&'b winnow::BStr>, parser::errors::Context>>::add_context
'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::Located<&'b winnow::BStr>
let mut p2 = MaybeUninit::uninit().assume_init(); // parser::errors::Context
+p0.add_context(p1, p2);
+<parser::errors::ParserError<'b> as winnow::error::ContextError<winnow::Located<&'b winnow::BStr>, parser::errors::Context>>::add_context(p0, p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::ContextError<winnow::Located<&'b winnow::BStr>, parser::errors::Context>>::add_context(p0, p1, p2);
+<parser::errors::ParserError<'b>>::add_context(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error
'b
deps:{"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error":{"E":["std::marker::Send","std::error::Error","std::marker::Sync","std::marker::Sized"]}}
candidates:{"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error":{"E":["std::sync::Arc<T>","std::boxed::ThinBox<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // winnow::Located<&'b winnow::BStr>
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error(p0, p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::FromExternalError<winnow::Located<&'b winnow::BStr>, E>>::from_external_error(p0, p1, p2);
+<parser::errors::ParserError<'b>>::from_external_error(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error
'b
deps:{"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error":{"E":["std::marker::Sync","std::error::Error","std::marker::Send","std::marker::Sized"]}}
candidates:{"<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error":{"E":["std::sync::Arc<T>","std::boxed::ThinBox<T>"]}}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error(&p0, p1, p2);
+crate::<parser::errors::ParserError<'b> as winnow::error::FromExternalError<&'b str, E>>::from_external_error(&p0, p1, p2);
+<parser::errors::ParserError<'b>>::from_external_error(&p0, p1, p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'b> as std::cmp::PartialEq>::eq
'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
let mut p1 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'b>
+p0.eq(p1);
+<parser::errors::ParserError<'b> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<parser::errors::ParserError<'b> as std::cmp::PartialEq>::eq(p0, p1);
+<parser::errors::ParserError<'b>>::eq(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserError<'a> as std::fmt::Display>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserError<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<parser::errors::ParserError<'a> as std::fmt::Display>::fmt(p0, p1);
+crate::<parser::errors::ParserError<'a> as std::fmt::Display>::fmt(p0, p1);
+<parser::errors::ParserError<'a>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::Context as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::Context
+p0.clone();
+<parser::errors::Context as std::clone::Clone>::clone(p0);
+crate::<parser::errors::Context as std::clone::Clone>::clone(p0);
+<parser::errors::Context>::clone(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::Context as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::Context
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::Context as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::Context as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::Context>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::Context as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::Context
let mut p1 = & MaybeUninit::uninit().assume_init(); // parser::errors::Context
+p0.eq(p1);
+<parser::errors::Context as std::cmp::PartialEq>::eq(p0, p1);
+crate::<parser::errors::Context as std::cmp::PartialEq>::eq(p0, p1);
+<parser::errors::Context>::eq(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserValue as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
+p0.clone();
+<parser::errors::ParserValue as std::clone::Clone>::clone(p0);
+crate::<parser::errors::ParserValue as std::clone::Clone>::clone(p0);
+<parser::errors::ParserValue>::clone(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserValue as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::ParserValue as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::ParserValue as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::ParserValue>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserValue as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
let mut p1 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
+p0.eq(p1);
+<parser::errors::ParserValue as std::cmp::PartialEq>::eq(p0, p1);
+crate::<parser::errors::ParserValue as std::cmp::PartialEq>::eq(p0, p1);
+<parser::errors::ParserValue>::eq(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::ParserValue as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::ParserValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<parser::errors::ParserValue as std::fmt::Display>::fmt(p0, p1);
+crate::<parser::errors::ParserValue as std::fmt::Display>::fmt(p0, p1);
+<parser::errors::ParserValue>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::CustomError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::CustomError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::errors::CustomError as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::errors::CustomError as std::fmt::Debug>::fmt(p0, p1);
+<parser::errors::CustomError>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::CustomError as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::CustomError
+p0.clone();
+<parser::errors::CustomError as std::clone::Clone>::clone(p0);
+crate::<parser::errors::CustomError as std::clone::Clone>::clone(p0);
+<parser::errors::CustomError>::clone(p0);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::CustomError::duplicate_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p1 = 0usize; // None+usize
+parser::errors::CustomError::duplicate_key(p0, p1);
+crate::parser::errors::CustomError::duplicate_key(p0, p1);
+<parser::errors::CustomError>::duplicate_key(p0, p1);
-----------------
crates/toml_edit/src/parser/errors.rs parser::errors::CustomError::extend_wrong_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p1 = 0usize; // None+usize
let mut p2 = "sample"; // None+&str
+parser::errors::CustomError::extend_wrong_type(p0, p1, &p2);
+crate::parser::errors::CustomError::extend_wrong_type(p0, p1, &p2);
+<parser::errors::CustomError>::extend_wrong_type(p0, p1, &p2);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::CustomError as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::CustomError
+p0.description();
+<parser::errors::CustomError as std::error::Error>::description(p0);
+crate::<parser::errors::CustomError as std::error::Error>::description(p0);
+<parser::errors::CustomError>::description(p0);
-----------------
crates/toml_edit/src/parser/errors.rs <parser::errors::CustomError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::errors::CustomError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<parser::errors::CustomError as std::fmt::Display>::fmt(p0, p1);
+crate::<parser::errors::CustomError as std::fmt::Display>::fmt(p0, p1);
+<parser::errors::CustomError>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::into_document
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::state::ParseState
+p0.into_document();
+parser::state::ParseState::into_document(p0);
+crate::parser::state::ParseState::into_document(p0);
+<parser::state::ParseState>::into_document(p0);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_ws
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.on_ws(p1);
+parser::state::ParseState::on_ws(p0, p1);
+crate::parser::state::ParseState::on_ws(p0, p1);
+<parser::state::ParseState>::on_ws(p0, p1);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_comment
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.on_comment(p1);
+parser::state::ParseState::on_comment(p0, p1);
+crate::parser::state::ParseState::on_comment(p0, p1);
+<parser::state::ParseState>::on_comment(p0, p1);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_keyval
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // table::TableKeyValue
+p0.on_keyval(p1, p2);
+parser::state::ParseState::on_keyval(p0, p1, p2);
+crate::parser::state::ParseState::on_keyval(p0, p1, p2);
+<parser::state::ParseState>::on_keyval(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::start_aray_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p3 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.start_aray_table(p1, p2, p3);
+parser::state::ParseState::start_aray_table(p0, p1, p2, p3);
+crate::parser::state::ParseState::start_aray_table(p0, p1, p2, p3);
+<parser::state::ParseState>::start_aray_table(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::start_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p3 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.start_table(p1, p2, p3);
+parser::state::ParseState::start_table(p0, p1, p2, p3);
+crate::parser::state::ParseState::start_table(p0, p1, p2, p3);
+<parser::state::ParseState>::start_table(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::finalize_table
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
+p0.finalize_table();
+parser::state::ParseState::finalize_table(p0);
+crate::parser::state::ParseState::finalize_table(p0);
+<parser::state::ParseState>::finalize_table(p0);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::descend_path
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // [key::Key]
let mut p2 = true; // None+bool
+parser::state::ParseState::descend_path(p0, p1, p2);
+crate::parser::state::ParseState::descend_path(p0, p1, p2);
+<parser::state::ParseState>::descend_path(p0, p1, p2);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_std_header
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
let mut p3 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.on_std_header(p1, p2, p3);
+parser::state::ParseState::on_std_header(p0, p1, p2, p3);
+crate::parser::state::ParseState::on_std_header(p0, p1, p2, p3);
+<parser::state::ParseState>::on_std_header(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/parser/state.rs parser::state::ParseState::on_array_header
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::state::ParseState
let mut p1 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<key::Key>
let mut p2 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
let mut p3 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.on_array_header(p1, p2, p3);
+parser::state::ParseState::on_array_header(p0, p1, p2, p3);
+crate::parser::state::ParseState::on_array_header(p0, p1, p2, p3);
+<parser::state::ParseState>::on_array_header(p0, p1, p2, p3);
-----------------
crates/toml_edit/src/parser/state.rs <parser::state::ParseState as std::default::Default>::default
deps:{}
candidates:{}
+<parser::state::ParseState as std::default::Default>::default();
+crate::<parser::state::ParseState as std::default::Default>::default();
+<parser::state::ParseState>::default();
-----------------
crates/toml_edit/src/parser/mod.rs <parser::prelude::RecursionCheck as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
+p0.clone();
+<parser::prelude::RecursionCheck as std::clone::Clone>::clone(p0);
+crate::<parser::prelude::RecursionCheck as std::clone::Clone>::clone(p0);
+<parser::prelude::RecursionCheck>::clone(p0);
-----------------
crates/toml_edit/src/parser/mod.rs <parser::prelude::RecursionCheck as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::prelude::RecursionCheck as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::prelude::RecursionCheck as std::fmt::Debug>::fmt(p0, p1);
+<parser::prelude::RecursionCheck>::fmt(p0, p1);
-----------------
crates/toml_edit/src/parser/mod.rs <parser::prelude::RecursionCheck as std::default::Default>::default
deps:{}
candidates:{}
+<parser::prelude::RecursionCheck as std::default::Default>::default();
+crate::<parser::prelude::RecursionCheck as std::default::Default>::default();
+<parser::prelude::RecursionCheck>::default();
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::RecursionCheck::check_depth
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+parser::prelude::RecursionCheck::check_depth(p0);
+crate::parser::prelude::RecursionCheck::check_depth(p0);
+<parser::prelude::RecursionCheck>::check_depth(p0);
-----------------
crates/toml_edit/src/parser/mod.rs parser::prelude::RecursionCheck::recursing
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // parser::prelude::RecursionCheck
let mut p1 = MaybeUninit::uninit().assume_init(); // winnow::Located<&winnow::BStr>
+p0.recursing(p1);
+parser::prelude::RecursionCheck::recursing(p0, p1);
+crate::parser::prelude::RecursionCheck::recursing(p0, p1);
+<parser::prelude::RecursionCheck>::recursing(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.eq(p1);
+<raw_string::RawString as std::cmp::PartialEq>::eq(p0, p1);
+crate::<raw_string::RawString as std::cmp::PartialEq>::eq(p0, p1);
+<raw_string::RawString>::eq(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.assert_receiver_is_total_eq();
+<raw_string::RawString as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<raw_string::RawString as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<raw_string::RawString>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.clone();
+<raw_string::RawString as std::clone::Clone>::clone(p0);
+crate::<raw_string::RawString as std::clone::Clone>::clone(p0);
+<raw_string::RawString>::clone(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<raw_string::RawString as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<raw_string::RawString as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<raw_string::RawString as std::hash::Hash>::hash(p0, p1);
+crate::<raw_string::RawString as std::hash::Hash>::hash(p0, p1);
+<raw_string::RawString>::hash(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawStringInner as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
let mut p1 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
+p0.eq(p1);
+<raw_string::RawStringInner as std::cmp::PartialEq>::eq(p0, p1);
+crate::<raw_string::RawStringInner as std::cmp::PartialEq>::eq(p0, p1);
+<raw_string::RawStringInner>::eq(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawStringInner as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
+p0.assert_receiver_is_total_eq();
+<raw_string::RawStringInner as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<raw_string::RawStringInner as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<raw_string::RawStringInner>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawStringInner as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
+p0.clone();
+<raw_string::RawStringInner as std::clone::Clone>::clone(p0);
+crate::<raw_string::RawStringInner as std::clone::Clone>::clone(p0);
+<raw_string::RawStringInner>::clone(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawStringInner as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<raw_string::RawStringInner as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<raw_string::RawStringInner as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>","std::hash::SipHasher13","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawStringInner
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<raw_string::RawStringInner as std::hash::Hash>::hash(p0, p1);
+crate::<raw_string::RawStringInner as std::hash::Hash>::hash(p0, p1);
+<raw_string::RawStringInner>::hash(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::with_span
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+raw_string::RawString::with_span(p0);
+crate::raw_string::RawString::with_span(p0);
+<raw_string::RawString>::with_span(p0);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.as_str();
+raw_string::RawString::as_str(p0);
+crate::raw_string::RawString::as_str(p0);
+<raw_string::RawString>::as_str(p0);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::to_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = "sample"; // None+&str
+p0.to_str(&p1);
+raw_string::RawString::to_str(p0, &p1);
+crate::raw_string::RawString::to_str(p0, &p1);
+<raw_string::RawString>::to_str(p0, &p1);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::to_str_with_default
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&'s str>
let mut p2 = "sample"; // None+&str
+p0.to_str_with_default(p1, &p2);
+raw_string::RawString::to_str_with_default(p0, p1, &p2);
+crate::raw_string::RawString::to_str_with_default(p0, p1, &p2);
+<raw_string::RawString>::to_str_with_default(p0, p1, &p2);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
+p0.span();
+raw_string::RawString::span(p0);
+crate::raw_string::RawString::span(p0);
+<raw_string::RawString>::span(p0);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+raw_string::RawString::despan(p0, &p1);
+crate::raw_string::RawString::despan(p0, &p1);
+<raw_string::RawString>::despan(p0, &p1);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = "sample"; // None+&str
+p0.encode(p1, &p2);
+raw_string::RawString::encode(p0, p1, &p2);
+crate::raw_string::RawString::encode(p0, p1, &p2);
+<raw_string::RawString>::encode(p0, p1, &p2);
-----------------
crates/toml_edit/src/raw_string.rs raw_string::RawString::encode_with_default
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = "sample"; // None+&str
+p0.encode_with_default(p1, p2, &p3);
+raw_string::RawString::encode_with_default(p0, p1, p2, &p3);
+crate::raw_string::RawString::encode_with_default(p0, p1, p2, &p3);
+<raw_string::RawString>::encode_with_default(p0, p1, p2, &p3);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::default::Default>::default
deps:{}
candidates:{}
+<raw_string::RawString as std::default::Default>::default();
+crate::<raw_string::RawString as std::default::Default>::default();
+<raw_string::RawString>::default();
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // raw_string::RawString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<raw_string::RawString as std::fmt::Debug>::fmt(p0, p1);
+crate::<raw_string::RawString as std::fmt::Debug>::fmt(p0, p1);
+<raw_string::RawString>::fmt(p0, p1);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<&str>>::from
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<raw_string::RawString as std::convert::From<&str>>::from(&p0);
+crate::<raw_string::RawString as std::convert::From<&str>>::from(&p0);
+<raw_string::RawString>::from(&p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<raw_string::RawString as std::convert::From<std::string::String>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<std::string::String>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<&std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<raw_string::RawString as std::convert::From<&std::string::String>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<&std::string::String>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<raw_string::RawString as std::convert::From<internal_string::InternalString>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<internal_string::InternalString>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<&internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<raw_string::RawString as std::convert::From<&internal_string::InternalString>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<&internal_string::InternalString>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/raw_string.rs <raw_string::RawString as std::convert::From<std::boxed::Box<str>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::boxed::Box<str>
+<raw_string::RawString as std::convert::From<std::boxed::Box<str>>>::from(p0);
+crate::<raw_string::RawString as std::convert::From<std::boxed::Box<str>>>::from(p0);
+<raw_string::RawString>::from(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["std::marker::Sized","std::cmp::Eq"]},"repr::Formatted":{"T":["std::marker::Sized","repr::ValueRepr","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::hash::Hash","std::fmt::Debug"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["key::KeyMut","repr::Repr","key::Key","internal_string::InternalString","repr::Formatted","encode::StringStyle","repr::Decor","raw_string::RawString","raw_string::RawStringInner","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","parser::errors::TomlError"]},"repr::Formatted":{"T":["i64","bool"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.assert_receiver_is_total_eq();
+<repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<repr::Formatted<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<repr::Formatted<T>>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::cmp::PartialEq>::eq
deps:{"<repr::Formatted<T> as std::cmp::PartialEq>::eq":{"T":["std::marker::Sized","std::cmp::PartialEq"]},"repr::Formatted":{"T":["std::hash::Hash","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone","repr::ValueRepr","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<repr::Formatted<T> as std::cmp::PartialEq>::eq":{"T":["key::KeyMut","repr::Decor","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","repr::Repr","repr::Formatted","raw_string::RawStringInner","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal_string::InternalString","parser::errors::Context","raw_string::RawString","parser::errors::ParserValue","parser::errors::TomlError","encode::StringStyle","parser::errors::ParserError"]},"repr::Formatted":{"T":["bool","i64"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.eq(p1);
+<repr::Formatted<T> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<repr::Formatted<T> as std::cmp::PartialEq>::eq(p0, p1);
+<repr::Formatted<T>>::eq(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::clone::Clone>::clone
deps:{"<repr::Formatted<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"repr::Formatted":{"T":["std::clone::Clone","std::marker::Sized","std::hash::Hash","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","repr::ValueRepr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<repr::Formatted<T> as std::clone::Clone>::clone":{"T":["table::Table","key::Key","parser::errors::ParserValue","parser::prelude::RecursionCheck","parser::errors::Context","table::TableKeyValue","array_of_tables::ArrayOfTables","std::clone::impls::<impl std::clone::Clone for *mut T>","document::Document","raw_string::RawStringInner","value::Value","internal_string::InternalString","array::Array","repr::Formatted","parser::errors::CustomError","parser::errors::TomlError","raw_string::RawString","item::Item","inline_table::InlineTable","repr::Decor","encode::StringStyle","repr::Repr"]},"repr::Formatted":{"T":[]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.clone();
+<repr::Formatted<T> as std::clone::Clone>::clone(p0);
+crate::<repr::Formatted<T> as std::clone::Clone>::clone(p0);
+<repr::Formatted<T>>::clone(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<repr::Formatted<T> as std::hash::Hash>::hash":{"T":["std::marker::Sized","std::hash::Hash"],"__H":["std::hash::Hasher","std::marker::Sized"]},"repr::Formatted":{"T":["std::fmt::Debug","std::marker::Sized","repr::ValueRepr","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::hash::Hash"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<repr::Formatted<T> as std::hash::Hash>::hash":{"T":["internal_string::InternalString","raw_string::RawStringInner","std::hash::impls::<impl std::hash::Hash for *mut T>","parser::errors::TomlError","key::Key","repr::Repr","repr::Formatted","raw_string::RawString","repr::Decor","key::KeyMut"],"__H":["std::hash::SipHasher13","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher"]},"repr::Formatted":{"T":[]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<repr::Formatted<T> as std::hash::Hash>::hash(p0, p1);
+crate::<repr::Formatted<T> as std::hash::Hash>::hash(p0, p1);
+<repr::Formatted<T>>::hash(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::new
deps:{"repr::Formatted::<T>::new":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::new":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+repr::Formatted::<T>::new(p0);
+crate::repr::Formatted::<T>::new(p0);
+<repr::Formatted<T>>::new(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::set_repr_unchecked
deps:{"repr::Formatted::<T>::set_repr_unchecked":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"repr::Formatted::<T>::set_repr_unchecked":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.set_repr_unchecked(p1);
+repr::Formatted::<T>::set_repr_unchecked(p0, p1);
+crate::repr::Formatted::<T>::set_repr_unchecked(p0, p1);
+<repr::Formatted<T>>::set_repr_unchecked(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::value
deps:{"repr::Formatted::<T>::value":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::value":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.value();
+repr::Formatted::<T>::value(p0);
+crate::repr::Formatted::<T>::value(p0);
+<repr::Formatted<T>>::value(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::into_value
deps:{"repr::Formatted::<T>::into_value":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::into_value":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.into_value();
+repr::Formatted::<T>::into_value(p0);
+crate::repr::Formatted::<T>::into_value(p0);
+<repr::Formatted<T>>::into_value(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::as_repr
deps:{"repr::Formatted::<T>::as_repr":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"repr::Formatted::<T>::as_repr":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.as_repr();
+repr::Formatted::<T>::as_repr(p0);
+crate::repr::Formatted::<T>::as_repr(p0);
+<repr::Formatted<T>>::as_repr(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::default_repr
deps:{"repr::Formatted::<T>::default_repr":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::default_repr":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.default_repr();
+repr::Formatted::<T>::default_repr(p0);
+crate::repr::Formatted::<T>::default_repr(p0);
+<repr::Formatted<T>>::default_repr(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::display_repr
deps:{"repr::Formatted::<T>::display_repr":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::display_repr":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.display_repr();
+repr::Formatted::<T>::display_repr(p0);
+crate::repr::Formatted::<T>::display_repr(p0);
+<repr::Formatted<T>>::display_repr(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::span
deps:{"repr::Formatted::<T>::span":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"repr::Formatted::<T>::span":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.span();
+repr::Formatted::<T>::span(p0);
+crate::repr::Formatted::<T>::span(p0);
+<repr::Formatted<T>>::span(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::despan
deps:{"repr::Formatted::<T>::despan":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::despan":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+repr::Formatted::<T>::despan(p0, &p1);
+crate::repr::Formatted::<T>::despan(p0, &p1);
+<repr::Formatted<T>>::despan(p0, &p1);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::decor_mut
deps:{"repr::Formatted::<T>::decor_mut":{"T":["repr::ValueRepr","std::marker::Sized"]}}
candidates:{"repr::Formatted::<T>::decor_mut":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.decor_mut();
+repr::Formatted::<T>::decor_mut(p0);
+crate::repr::Formatted::<T>::decor_mut(p0);
+<repr::Formatted<T>>::decor_mut(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::decor
deps:{"repr::Formatted::<T>::decor":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"repr::Formatted::<T>::decor":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.decor();
+repr::Formatted::<T>::decor(p0);
+crate::repr::Formatted::<T>::decor(p0);
+<repr::Formatted<T>>::decor(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Formatted::<T>::fmt
deps:{"repr::Formatted::<T>::fmt":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"repr::Formatted::<T>::fmt":{"T":["toml_datetime::Datetime","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
+p0.fmt();
+repr::Formatted::<T>::fmt(p0);
+crate::repr::Formatted::<T>::fmt(p0);
+<repr::Formatted<T>>::fmt(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<repr::Formatted<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"repr::Formatted":{"T":["std::cmp::PartialEq","std::hash::Hash","repr::ValueRepr","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<repr::Formatted<T> as std::fmt::Debug>::fmt":{"T":["value::Value","parser::errors::Context","table::Table","repr::Decor","<*const T as std::fmt::Debug>","document::Document","parser::errors::TomlError","parser::prelude::RecursionCheck","raw_string::RawString","repr::Repr","table::TableKeyValue","key::KeyMut","repr::Formatted","item::Item","parser::errors::CustomError","array_of_tables::ArrayOfTables","internal_string::InternalString","array::Array","key::Key","inline_table::InlineTable","parser::errors::ParserError","parser::errors::ParserValue","<&T as std::fmt::Debug>","encode::StringStyle"]},"repr::Formatted":{"T":["i64","bool"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<repr::Formatted<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<repr::Formatted<T> as std::fmt::Debug>::fmt(p0, p1);
+<repr::Formatted<T>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Formatted<T> as std::fmt::Display>::fmt
deps:{"<repr::Formatted<T> as std::fmt::Display>::fmt":{"T":["std::marker::Sized","repr::ValueRepr"]}}
candidates:{"<repr::Formatted<T> as std::fmt::Display>::fmt":{"T":["std::string::String","toml_datetime::Datetime"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Formatted<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<repr::Formatted<T> as std::fmt::Display>::fmt(p0, p1);
+crate::<repr::Formatted<T> as std::fmt::Display>::fmt(p0, p1);
+<repr::Formatted<T>>::fmt(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.assert_receiver_is_total_eq();
+<repr::Repr as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<repr::Repr as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<repr::Repr>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.eq(p1);
+<repr::Repr as std::cmp::PartialEq>::eq(p0, p1);
+crate::<repr::Repr as std::cmp::PartialEq>::eq(p0, p1);
+<repr::Repr>::eq(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.clone();
+<repr::Repr as std::clone::Clone>::clone(p0);
+crate::<repr::Repr as std::clone::Clone>::clone(p0);
+<repr::Repr>::clone(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<repr::Repr as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<repr::Repr as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::hash::SipHasher13","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<repr::Repr as std::hash::Hash>::hash(p0, p1);
+crate::<repr::Repr as std::hash::Hash>::hash(p0, p1);
+<repr::Repr>::hash(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::new_unchecked
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"repr::Repr::new_unchecked":{"impl Into<RawString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"repr::Repr::new_unchecked":{"impl Into<RawString>":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+repr::Repr::new_unchecked(p0);
+crate::repr::Repr::new_unchecked(p0);
+<repr::Repr>::new_unchecked(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::as_raw
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.as_raw();
+repr::Repr::as_raw(p0);
+crate::repr::Repr::as_raw(p0);
+<repr::Repr>::as_raw(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
+p0.span();
+repr::Repr::span(p0);
+crate::repr::Repr::span(p0);
+<repr::Repr>::span(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+repr::Repr::despan(p0, &p1);
+crate::repr::Repr::despan(p0, &p1);
+<repr::Repr>::despan(p0, &p1);
-----------------
crates/toml_edit/src/repr.rs repr::Repr::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = "sample"; // None+&str
+p0.encode(p1, &p2);
+repr::Repr::encode(p0, p1, &p2);
+crate::repr::Repr::encode(p0, p1, &p2);
+<repr::Repr>::encode(p0, p1, &p2);
-----------------
crates/toml_edit/src/repr.rs <repr::Repr as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Repr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<repr::Repr as std::fmt::Debug>::fmt(p0, p1);
+crate::<repr::Repr as std::fmt::Debug>::fmt(p0, p1);
+<repr::Repr>::fmt(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.assert_receiver_is_total_eq();
+<repr::Decor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<repr::Decor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<repr::Decor>::assert_receiver_is_total_eq(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.eq(p1);
+<repr::Decor as std::cmp::PartialEq>::eq(p0, p1);
+crate::<repr::Decor as std::cmp::PartialEq>::eq(p0, p1);
+<repr::Decor>::eq(p0, p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.clone();
+<repr::Decor as std::clone::Clone>::clone(p0);
+crate::<repr::Decor as std::clone::Clone>::clone(p0);
+<repr::Decor>::clone(p0);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::default::Default>::default
deps:{}
candidates:{}
+<repr::Decor as std::default::Default>::default();
+crate::<repr::Decor as std::default::Default>::default();
+<repr::Decor>::default();
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<repr::Decor as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<repr::Decor as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::hash::sip::Hasher<S>","std::hash::SipHasher","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<repr::Decor as std::hash::Hash>::hash(p0, p1);
+crate::<repr::Decor as std::hash::Hash>::hash(p0, p1);
+<repr::Decor>::hash(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::new
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"repr::Decor::new":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"repr::Decor::new":{"impl Into<RawString>":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+repr::Decor::new(p0, p1);
+crate::repr::Decor::new(p0, p1);
+<repr::Decor>::new(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.clear();
+repr::Decor::clear(p0);
+crate::repr::Decor::clear(p0);
+<repr::Decor>::clear(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::prefix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.prefix();
+repr::Decor::prefix(p0);
+crate::repr::Decor::prefix(p0);
+<repr::Decor>::prefix(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::prefix_encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = "sample"; // None+&str
+p0.prefix_encode(p1, p2, &p3);
+repr::Decor::prefix_encode(p0, p1, p2, &p3);
+crate::repr::Decor::prefix_encode(p0, p1, p2, &p3);
+<repr::Decor>::prefix_encode(p0, p1, p2, &p3);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::set_prefix
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"repr::Decor::set_prefix":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"repr::Decor::set_prefix":{"impl Into<RawString>":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_prefix(p1);
+repr::Decor::set_prefix(p0, p1);
+crate::repr::Decor::set_prefix(p0, p1);
+<repr::Decor>::set_prefix(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
+p0.suffix();
+repr::Decor::suffix(p0);
+crate::repr::Decor::suffix(p0);
+<repr::Decor>::suffix(p0);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::suffix_encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // dyn std::fmt::Write
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<&str>
let mut p3 = "sample"; // None+&str
+p0.suffix_encode(p1, p2, &p3);
+repr::Decor::suffix_encode(p0, p1, p2, &p3);
+crate::repr::Decor::suffix_encode(p0, p1, p2, &p3);
+<repr::Decor>::suffix_encode(p0, p1, p2, &p3);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::set_suffix
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"repr::Decor::set_suffix":{"impl Into<RawString>":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"repr::Decor::set_suffix":{"impl Into<RawString>":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.set_suffix(p1);
+repr::Decor::set_suffix(p0, p1);
+crate::repr::Decor::set_suffix(p0, p1);
+<repr::Decor>::set_suffix(p0, p1);
-----------------
crates/toml_edit/src/repr.rs repr::Decor::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+repr::Decor::despan(p0, &p1);
+crate::repr::Decor::despan(p0, &p1);
+<repr::Decor>::despan(p0, &p1);
-----------------
crates/toml_edit/src/repr.rs <repr::Decor as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // repr::Decor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<repr::Decor as std::fmt::Debug>::fmt(p0, p1);
+crate::<repr::Decor as std::fmt::Debug>::fmt(p0, p1);
+<repr::Decor>::fmt(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.clone();
+<table::Table as std::clone::Clone>::clone(p0);
+crate::<table::Table as std::clone::Clone>::clone(p0);
+<table::Table>::clone(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<table::Table as std::fmt::Debug>::fmt(p0, p1);
+crate::<table::Table as std::fmt::Debug>::fmt(p0, p1);
+<table::Table>::fmt(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::default::Default>::default
deps:{}
candidates:{}
+<table::Table as std::default::Default>::default();
+crate::<table::Table as std::default::Default>::default();
+<table::Table>::default();
-----------------
crates/toml_edit/src/table.rs table::Table::new
deps:{}
candidates:{}
+table::Table::new();
+crate::table::Table::new();
+<table::Table>::new();
-----------------
crates/toml_edit/src/table.rs table::Table::with_pos
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+table::Table::with_pos(p0);
+crate::table::Table::with_pos(p0);
+<table::Table>::with_pos(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::with_pairs
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // indexmap::IndexMap<internal_string::InternalString, table::TableKeyValue>
+table::Table::with_pairs(p0);
+crate::table::Table::with_pairs(p0);
+<table::Table>::with_pairs(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::into_inline_table
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Table
+p0.into_inline_table();
+table::Table::into_inline_table(p0);
+crate::table::Table::into_inline_table(p0);
+<table::Table>::into_inline_table(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::get_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.get_values();
+table::Table::get_values(p0);
+crate::table::Table::get_values(p0);
+<table::Table>::get_values(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::append_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // [&'s key::Key]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<(std::vec::Vec<&'s key::Key>, &'s value::Value)>
+p0.append_values(p1, p2);
+table::Table::append_values(p0, p1, p2);
+crate::table::Table::append_values(p0, p1, p2);
+<table::Table>::append_values(p0, p1, p2);
-----------------
crates/toml_edit/src/table.rs table::Table::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.fmt();
+table::Table::fmt(p0);
+crate::table::Table::fmt(p0);
+<table::Table>::fmt(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::sort_values
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.sort_values();
+table::Table::sort_values(p0);
+crate::table::Table::sort_values(p0);
+<table::Table>::sort_values(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::sort_values_by
deps:{"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"table::Table::sort_values_by":{"F":["std::marker::Sized","std::ops::FnMut"]}}
candidates:{"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"table::Table::sort_values_by":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.sort_values_by(p1);
+table::Table::sort_values_by(p0, p1);
+crate::table::Table::sort_values_by(p0, p1);
+<table::Table>::sort_values_by(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::sort_values_by_internal
deps:{"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"table::Table::sort_values_by_internal":{"F":["std::ops::FnMut","std::marker::Sized"]}}
candidates:{"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"table::Table::sort_values_by_internal":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsNotEmpty"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // F
+p0.sort_values_by_internal(p1);
+table::Table::sort_values_by_internal(p0, p1);
+crate::table::Table::sort_values_by_internal(p0, p1);
+<table::Table>::sort_values_by_internal(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::set_implicit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = true; // None+bool
+p0.set_implicit(p1);
+table::Table::set_implicit(p0, p1);
+crate::table::Table::set_implicit(p0, p1);
+<table::Table>::set_implicit(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::is_implicit
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.is_implicit();
+table::Table::is_implicit(p0);
+crate::table::Table::is_implicit(p0);
+<table::Table>::is_implicit(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::set_dotted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+table::Table::set_dotted(p0, p1);
+crate::table::Table::set_dotted(p0, p1);
+<table::Table>::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::is_dotted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.is_dotted();
+table::Table::is_dotted(p0);
+crate::table::Table::is_dotted(p0);
+<table::Table>::is_dotted(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::set_position
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = 0usize; // None+usize
+p0.set_position(p1);
+table::Table::set_position(p0, p1);
+crate::table::Table::set_position(p0, p1);
+<table::Table>::set_position(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::position
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.position();
+table::Table::position(p0);
+crate::table::Table::position(p0);
+<table::Table>::position(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.decor_mut();
+table::Table::decor_mut(p0);
+crate::table::Table::decor_mut(p0);
+<table::Table>::decor_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.decor();
+table::Table::decor(p0);
+crate::table::Table::decor(p0);
+<table::Table>::decor(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::key_decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+table::Table::key_decor_mut(p0, &p1);
+crate::table::Table::key_decor_mut(p0, &p1);
+<table::Table>::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::key_decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+table::Table::key_decor(p0, &p1);
+crate::table::Table::key_decor(p0, &p1);
+<table::Table>::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.span();
+table::Table::span(p0);
+crate::table::Table::span(p0);
+<table::Table>::span(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+table::Table::despan(p0, &p1);
+crate::table::Table::despan(p0, &p1);
+<table::Table>::despan(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.iter();
+table::Table::iter(p0);
+crate::table::Table::iter(p0);
+<table::Table>::iter(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.iter_mut();
+table::Table::iter_mut(p0);
+crate::table::Table::iter_mut(p0);
+<table::Table>::iter_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.len();
+table::Table::len(p0);
+crate::table::Table::len(p0);
+<table::Table>::len(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.is_empty();
+table::Table::is_empty(p0);
+crate::table::Table::is_empty(p0);
+<table::Table>::is_empty(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.clear();
+table::Table::clear(p0);
+crate::table::Table::clear(p0);
+<table::Table>::clear(p0);
-----------------
crates/toml_edit/src/table.rs table::Table::entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.entry(&p1);
+table::Table::entry(p0, &p1);
+crate::table::Table::entry(p0, &p1);
+<table::Table>::entry(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::entry_format
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+table::Table::entry_format(p0, p1);
+crate::table::Table::entry_format(p0, p1);
+<table::Table>::entry_format(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Table::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+table::Table::get(p0, &p1);
+crate::table::Table::get(p0, &p1);
+<table::Table>::get(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+table::Table::get_mut(p0, &p1);
+crate::table::Table::get_mut(p0, &p1);
+<table::Table>::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::get_key_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+table::Table::get_key_value(p0, &p1);
+crate::table::Table::get_key_value(p0, &p1);
+<table::Table>::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::get_key_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+table::Table::get_key_value_mut(p0, &p1);
+crate::table::Table::get_key_value_mut(p0, &p1);
+<table::Table>::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::contains_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+table::Table::contains_key(p0, &p1);
+crate::table::Table::contains_key(p0, &p1);
+<table::Table>::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::contains_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_table(&p1);
+table::Table::contains_table(p0, &p1);
+crate::table::Table::contains_table(p0, &p1);
+<table::Table>::contains_table(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::contains_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_value(&p1);
+table::Table::contains_value(p0, &p1);
+crate::table::Table::contains_value(p0, &p1);
+<table::Table>::contains_value(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::contains_array_of_tables
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_array_of_tables(&p1);
+table::Table::contains_array_of_tables(p0, &p1);
+crate::table::Table::contains_array_of_tables(p0, &p1);
+<table::Table>::contains_array_of_tables(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(&p1, p2);
+table::Table::insert(p0, &p1, p2);
+crate::table::Table::insert(p0, &p1, p2);
+<table::Table>::insert(p0, &p1, p2);
-----------------
crates/toml_edit/src/table.rs table::Table::insert_formatted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert_formatted(p1, p2);
+table::Table::insert_formatted(p0, p1, p2);
+crate::table::Table::insert_formatted(p0, p1, p2);
+<table::Table>::insert_formatted(p0, p1, p2);
-----------------
crates/toml_edit/src/table.rs table::Table::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+table::Table::remove(p0, &p1);
+crate::table::Table::remove(p0, &p1);
+<table::Table>::remove(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Table::remove_entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.remove_entry(&p1);
+table::Table::remove_entry(p0, &p1);
+crate::table::Table::remove_entry(p0, &p1);
+<table::Table>::remove_entry(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<table::Table as std::fmt::Display>::fmt(p0, p1);
+crate::<table::Table as std::fmt::Display>::fmt(p0, p1);
+<table::Table>::fmt(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::iter::Extend<(K, V)>>::extend
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<table::Table as std::iter::Extend<(K, V)>>::extend":{"K":["std::convert::Into","std::marker::Sized"],"T":["std::iter::IntoIterator","std::marker::Sized"],"V":["std::convert::Into","std::marker::Sized"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::str::Chars<'a>","std::str::RMatchIndices<'a, P>","std::sync::mpsc::TryIter<'a, T>","std::collections::hash_map::Keys<'a, K, V>","std::collections::btree_map::Values<'a, K, V>","std::str::SplitWhitespace<'a>","std::fs::ReadDir","std::iter::Take<I>","std::env::ArgsOs","std::iter::RepeatWith<F>","std::collections::hash_map::Iter<'a, K, V>","std::char::EscapeUnicode","std::ops::RangeInclusive<A>","std::iter::Cloned<I>","std::iter::Map<I, F>","std::collections::btree_map::IntoIter<K, V, A>","std::slice::ArrayChunksMut<'a, T, N>","std::slice::ChunksMut<'a, T>","std::slice::Chunks<'a, T>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::str::Matches<'a, P>","std::collections::btree_map::Keys<'a, K, V>","std::collections::hash_set::DrainFilter<'_, K, F>","std::collections::hash_map::Drain<'a, K, V>","std::sys::unix::fs::ReadDir","std::collections::hash_set::Iter<'a, K>","std::collections::btree_set::Range<'a, T>","std::collections::linked_list::DrainFilter<'_, T, F>","std::collections::binary_heap::Iter<'a, T>","std::slice::ArrayWindows<'a, T, N>","std::iter::Rev<I>","std::slice::Split<'a, T, P>","std::str::Split<'a, P>","std::str::MatchIndices<'a, P>","std::char::CaseMappingIter","std::collections::hash_set::Drain<'a, K>","std::iter::sources::from_generator::FromGenerator<G>","std::vec::Splice<'_, I, A>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::char::EscapeDefault","std::sys::unix::process::process_common::CommandArgs<'a>","std::iter::Copied<I>","std::collections::linked_list::IntoIter<T>","std::slice::RChunksExact<'a, T>","std::iter::RepeatN<A>","std::iter::TakeWhile<I, P>","std::result::Iter<'a, T>","std::vec::DrainFilter<'_, T, F, A>","std::collections::vec_deque::IntoIter<T, A>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::btree_map::IntoValues<K, V, A>","std::slice::RChunksExactMut<'a, T>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::collections::btree_map::IterMut<'a, K, V>","std::result::IterMut<'a, T>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::collections::btree_map::IntoKeys<K, V, A>","std::ops::Range<A>","std::option::IterMut<'a, A>","std::sys_common::wstr::WStrUnits<'_>","std::sys_common::net::LookupHost","std::slice::SplitN<'a, T, P>","std::iter::adapters::GenericShunt<'_, I, R>","std::iter::ArrayChunks<I, N>","std::env::VarsOs","std::env::Vars","std::iter::Once<T>","std::iter::Filter<I, P>","std::collections::vec_deque::Drain<'_, T, A>","std::str::RMatches<'a, P>","std::iter::Scan<I, St, F>","std::collections::btree_set::IntoIter<T, A>","std::collections::vec_deque::IterMut<'a, T>","std::slice::RSplitMut<'a, T, P>","std::collections::btree_set::Difference<'a, T, A>","core::slice::iter::GenericSplitN<I>","std::slice::GroupByMut<'a, T, P>","std::path::Ancestors<'a>","std::slice::RChunks<'a, T>","std::iter::Cycle<I>","std::net::Incoming<'a>","std::collections::btree_map::RangeMut<'a, K, V>","std::os::unix::net::Incoming<'a>","std::collections::hash_map::ValuesMut<'a, K, V>","std::collections::binary_heap::DrainSorted<'_, T>","std::os::unix::net::Messages<'a>","std::slice::RChunksMut<'a, T>","std::slice::SplitMut<'a, T, P>","std::path::Iter<'a>","std::env::SplitPaths<'a>","std::slice::RSplitNMut<'a, T, P>","std::iter::Flatten<I>","std::str::SplitTerminator<'a, P>","core::error::Source<'a>","std::str::RSplitN<'a, P>","std::collections::binary_heap::IntoIter<T>","std::vec::IntoIter<T, A>","std::slice::GroupBy<'a, T, P>","std::iter::Repeat<A>","std::collections::hash_map::IterMut<'a, K, V>","std::io::Bytes<R>","std::iter::Inspect<I, F>","<&mut I as std::iter::Iterator>","std::str::SplitInclusive<'a, P>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::sys_common::wtf8::EncodeWide<'a>","std::boxed::Box<I, A>","std::env::Args","std::collections::linked_list::Iter<'a, T>","std::str::LinesAny<'a>","std::sys::unix::os::Env","std::str::EscapeDefault<'a>","std::collections::hash_map::IntoIter<K, V>","std::option::Item<A>","std::slice::SplitNMut<'a, T, P>","std::sync::mpsc::Iter<'a, T>","std::collections::btree_set::SymmetricDifference<'a, T>","std::collections::linked_list::IterMut<'a, T>","std::option::Iter<'a, A>","std::iter::StepBy<I>","std::net::IntoIncoming","std::collections::hash_set::Intersection<'a, T, S>","std::slice::ChunksExactMut<'a, T>","std::collections::hash_set::Union<'a, T, S>","std::char::ToUppercase","std::iter::Enumerate<I>","std::iter::ByRefSized<'_, I>","std::iter::FilterMap<I, F>","std::vec::Drain<'_, T, A>","std::iter::Intersperse<I>","std::io::Split<B>","std::iter::MapWhile<I, P>","std::path::Components<'a>","std::collections::vec_deque::Iter<'a, T>","std::collections::btree_set::Iter<'a, T>","std::process::CommandArgs<'a>","std::str::Utf8Chunks<'a>","std::str::EscapeUnicode<'a>","std::collections::hash_set::Difference<'a, T, S>","std::iter::FromFn<F>","std::str::SplitN<'a, P>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::iter::Skip<I>","std::str::CharIndices<'a>","std::slice::EscapeAscii<'a>","std::ascii::EscapeDefault","std::iter::Empty<T>","std::slice::ChunksExact<'a, T>","std::collections::hash_map::IntoValues<K, V>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::collections::btree_set::Union<'a, T>","std::slice::Iter<'a, T>","std::string::Drain<'_>","std::collections::hash_map::Values<'a, K, V>","std::iter::SkipWhile<I, P>","std::option::IntoIter<A>","std::slice::Windows<'a, T>","std::result::IntoIter<T>","std::array::IntoIter<T, N>","std::slice::IterMut<'a, T>","std::collections::hash_set::IntoIter<K>","std::sys::unix::os::SplitPaths<'a>","std::ops::index_range::IndexRange","std::sync::mpsc::IntoIter<T>","std::os::unix::net::ScmRights<'a>","std::ops::RangeFrom<A>","std::collections::btree_set::Intersection<'a, T, A>","std::iter::Chain<A, B>","std::str::EscapeDebug<'a>","std::iter::FlatMap<I, U, F>","std::slice::RSplitN<'a, T, P>","std::os::unix::net::ScmCredentials<'a>","std::iter::IntersperseWith<I, G>","std::char::DecodeUtf16<I>","std::slice::SplitInclusiveMut<'a, T, P>","std::iter::Peekable<I>","std::str::RSplit<'a, P>","std::io::Lines<B>","std::slice::ArrayChunks<'a, T, N>","std::collections::btree_map::Iter<'a, K, V>","std::iter::Zip<A, B>","std::collections::hash_map::IntoKeys<K, V>","std::iter::Fuse<I>","std::str::Bytes<'_>","std::slice::RSplit<'a, T, P>","std::char::EscapeDebug","std::str::RSplitTerminator<'a, P>","std::sys::unix::args::Args","std::str::EncodeUtf16<'a>","std::slice::SplitInclusive<'a, T, P>","std::char::ToLowercase","std::iter::OnceWith<F>","std::collections::btree_map::Range<'a, K, V>","std::str::SplitAsciiWhitespace<'a>","std::process::CommandEnvs<'a>","std::collections::binary_heap::IntoIterSorted<T>","std::iter::Successors<T, F>","std::collections::binary_heap::Drain<'_, T>","std::str::Lines<'a>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<table::Table as std::iter::Extend<(K, V)>>::extend":{"K":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"],"T":["array::Array","<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","array_of_tables::ArrayOfTables","<I as std::iter::IntoIterator>","table::Table","inline_table::InlineTable"],"V":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<table::Table as std::iter::Extend<(K, V)>>::extend(p0, p1);
+crate::<table::Table as std::iter::Extend<(K, V)>>::extend(p0, p1);
+<table::Table>::extend(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::iter::FromIterator<(K, V)>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<table::Table as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["std::iter::IntoIterator","std::marker::Sized"],"K":["std::marker::Sized","std::convert::Into"],"V":["std::marker::Sized","std::convert::Into"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::str::RSplitTerminator<'a, P>","std::collections::hash_set::Union<'a, T, S>","std::sys::unix::process::process_common::CommandArgs<'a>","std::collections::hash_map::Drain<'a, K, V>","std::collections::vec_deque::IntoIter<T, A>","std::iter::FilterMap<I, F>","std::sys_common::net::LookupHost","std::result::IntoIter<T>","std::iter::MapWhile<I, P>","std::sys::unix::fs::ReadDir","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::os::unix::net::ScmRights<'a>","std::iter::FromFn<F>","std::iter::Copied<I>","std::iter::OnceWith<F>","std::str::RSplitN<'a, P>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::net::IntoIncoming","std::iter::ByRefSized<'_, I>","std::str::SplitTerminator<'a, P>","std::slice::IterMut<'a, T>","std::iter::Cloned<I>","std::str::RMatches<'a, P>","std::collections::binary_heap::IntoIterSorted<T>","std::ops::index_range::IndexRange","std::option::Iter<'a, A>","std::collections::hash_map::Iter<'a, K, V>","std::slice::ChunksMut<'a, T>","std::iter::Inspect<I, F>","std::collections::btree_set::Difference<'a, T, A>","std::path::Ancestors<'a>","std::str::Matches<'a, P>","std::collections::hash_set::Difference<'a, T, S>","std::iter::ArrayChunks<I, N>","std::collections::vec_deque::Iter<'a, T>","std::sync::mpsc::TryIter<'a, T>","std::str::MatchIndices<'a, P>","std::sys_common::wtf8::EncodeWide<'a>","std::iter::Map<I, F>","std::collections::btree_map::Keys<'a, K, V>","std::slice::Chunks<'a, T>","std::slice::SplitInclusive<'a, T, P>","std::collections::vec_deque::IterMut<'a, T>","std::iter::Intersperse<I>","std::iter::IntersperseWith<I, G>","std::path::Components<'a>","std::sys::unix::args::Args","std::iter::SkipWhile<I, P>","std::option::IterMut<'a, A>","std::option::Item<A>","std::str::SplitAsciiWhitespace<'a>","core::slice::iter::GenericSplitN<I>","std::collections::vec_deque::Drain<'_, T, A>","std::str::EscapeUnicode<'a>","std::iter::Scan<I, St, F>","std::iter::Flatten<I>","std::iter::sources::from_generator::FromGenerator<G>","std::collections::btree_map::IntoKeys<K, V, A>","std::collections::btree_set::Iter<'a, T>","std::iter::adapters::GenericShunt<'_, I, R>","std::char::EscapeDebug","std::iter::Zip<A, B>","std::str::EncodeUtf16<'a>","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::collections::hash_map::Keys<'a, K, V>","std::char::EscapeDefault","std::str::Bytes<'_>","std::char::ToUppercase","std::collections::btree_map::Range<'a, K, V>","std::collections::hash_map::IntoKeys<K, V>","std::char::DecodeUtf16<I>","std::collections::btree_map::IntoIter<K, V, A>","std::sys::unix::os::SplitPaths<'a>","std::collections::btree_map::IterMut<'a, K, V>","std::str::RSplit<'a, P>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::str::Chars<'a>","std::slice::ChunksExactMut<'a, T>","std::iter::Cycle<I>","std::env::Vars","std::os::unix::net::ScmCredentials<'a>","std::env::SplitPaths<'a>","std::io::Lines<B>","std::char::ToLowercase","std::net::Incoming<'a>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::collections::btree_map::Iter<'a, K, V>","std::iter::Chain<A, B>","std::iter::Once<T>","std::env::ArgsOs","core::error::Source<'a>","std::collections::hash_set::DrainFilter<'_, K, F>","std::slice::Windows<'a, T>","std::collections::linked_list::DrainFilter<'_, T, F>","std::iter::Filter<I, P>","std::iter::Empty<T>","std::iter::Peekable<I>","std::io::Split<B>","std::collections::hash_map::IntoValues<K, V>","std::iter::Enumerate<I>","std::io::Bytes<R>","std::str::RMatchIndices<'a, P>","std::slice::RSplitN<'a, T, P>","std::sync::mpsc::IntoIter<T>","std::slice::RChunksExactMut<'a, T>","std::slice::SplitNMut<'a, T, P>","std::iter::Take<I>","std::str::LinesAny<'a>","std::vec::Splice<'_, I, A>","std::slice::RSplitMut<'a, T, P>","std::iter::FlatMap<I, U, F>","std::str::SplitInclusive<'a, P>","std::slice::RChunksMut<'a, T>","std::slice::EscapeAscii<'a>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::iter::TakeWhile<I, P>","std::str::Utf8Chunks<'a>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::char::EscapeUnicode","std::slice::RSplit<'a, T, P>","std::vec::DrainFilter<'_, T, F, A>","std::sys::unix::os::Env","std::iter::RepeatN<A>","std::collections::btree_set::Union<'a, T>","std::collections::hash_map::IterMut<'a, K, V>","std::collections::linked_list::Iter<'a, T>","std::str::EscapeDefault<'a>","std::boxed::Box<I, A>","std::result::IterMut<'a, T>","std::env::Args","std::slice::ArrayChunksMut<'a, T, N>","std::str::EscapeDebug<'a>","std::slice::ChunksExact<'a, T>","std::ops::RangeFrom<A>","std::iter::Skip<I>","std::iter::RepeatWith<F>","std::slice::SplitMut<'a, T, P>","std::collections::btree_set::Intersection<'a, T, A>","std::slice::ArrayWindows<'a, T, N>","std::slice::Iter<'a, T>","std::iter::Repeat<A>","std::collections::binary_heap::Drain<'_, T>","std::sync::mpsc::Iter<'a, T>","std::collections::linked_list::IterMut<'a, T>","std::string::Drain<'_>","std::char::CaseMappingIter","std::collections::btree_set::Range<'a, T>","std::str::Lines<'a>","std::vec::Drain<'_, T, A>","std::slice::ArrayChunks<'a, T, N>","std::iter::StepBy<I>","std::iter::Rev<I>","std::process::CommandEnvs<'a>","std::collections::btree_map::IntoValues<K, V, A>","std::collections::hash_set::Drain<'a, K>","std::collections::btree_set::SymmetricDifference<'a, T>","std::str::Split<'a, P>","std::iter::Fuse<I>","std::collections::hash_map::IntoIter<K, V>","std::collections::linked_list::IntoIter<T>","std::slice::SplitInclusiveMut<'a, T, P>","std::collections::hash_set::Intersection<'a, T, S>","std::option::IntoIter<A>","std::collections::btree_map::ValuesMut<'a, K, V>","std::ops::Range<A>","std::str::SplitWhitespace<'a>","std::vec::IntoIter<T, A>","std::path::Iter<'a>","std::slice::GroupBy<'a, T, P>","std::collections::btree_map::RangeMut<'a, K, V>","std::process::CommandArgs<'a>","std::ops::RangeInclusive<A>","std::collections::hash_set::IntoIter<K>","std::os::unix::net::Incoming<'a>","std::slice::Split<'a, T, P>","std::slice::RChunksExact<'a, T>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::collections::hash_set::Iter<'a, K>","std::env::VarsOs","std::str::CharIndices<'a>","std::str::SplitN<'a, P>","std::ascii::EscapeDefault","std::slice::RSplitNMut<'a, T, P>","std::sys_common::wstr::WStrUnits<'_>","std::collections::hash_map::Values<'a, K, V>","std::collections::btree_set::IntoIter<T, A>","std::collections::binary_heap::IntoIter<T>","std::iter::Successors<T, F>","std::result::Iter<'a, T>","std::slice::GroupByMut<'a, T, P>","std::collections::hash_map::ValuesMut<'a, K, V>","std::array::IntoIter<T, N>","std::collections::binary_heap::Iter<'a, T>","std::collections::btree_map::Values<'a, K, V>","std::os::unix::net::Messages<'a>","std::slice::RChunks<'a, T>","std::fs::ReadDir","std::slice::SplitN<'a, T, P>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<table::Table as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["array::Array","array_of_tables::ArrayOfTables","inline_table::InlineTable","table::Table","indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>","<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>"],"K":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"],"V":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sync::mpmc::select::Selected"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<table::Table as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+crate::<table::Table as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+<table::Table>::from_iter(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Table
+p0.into_iter();
+<table::Table as std::iter::IntoIterator>::into_iter(p0);
+crate::<table::Table as std::iter::IntoIterator>::into_iter(p0);
+<table::Table>::into_iter(p0);
-----------------
crates/toml_edit/src/table.rs <&'s table::Table as std::iter::IntoIterator>::into_iter
's
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.into_iter();
+<&'s table::Table as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'s table::Table as std::iter::IntoIterator>::into_iter(p0);
+<&'s table::Table>::into_iter(p0);
-----------------
crates/toml_edit/src/table.rs <table::TableKeyValue as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::TableKeyValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<table::TableKeyValue as std::fmt::Debug>::fmt(p0, p1);
+crate::<table::TableKeyValue as std::fmt::Debug>::fmt(p0, p1);
+<table::TableKeyValue>::fmt(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::TableKeyValue as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::TableKeyValue
+p0.clone();
+<table::TableKeyValue as std::clone::Clone>::clone(p0);
+crate::<table::TableKeyValue as std::clone::Clone>::clone(p0);
+<table::TableKeyValue>::clone(p0);
-----------------
crates/toml_edit/src/table.rs table::TableKeyValue::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // key::Key
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+table::TableKeyValue::new(p0, p1);
+crate::table::TableKeyValue::new(p0, p1);
+<table::TableKeyValue>::new(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.iter();
+<table::Table as table::TableLike>::iter(p0);
+crate::<table::Table as table::TableLike>::iter(p0);
+<table::Table>::iter(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.iter_mut();
+<table::Table as table::TableLike>::iter_mut(p0);
+crate::<table::Table as table::TableLike>::iter_mut(p0);
+<table::Table>::iter_mut(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.clear();
+<table::Table as table::TableLike>::clear(p0);
+crate::<table::Table as table::TableLike>::clear(p0);
+<table::Table>::clear(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::entry
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.entry(&p1);
+<table::Table as table::TableLike>::entry(p0, &p1);
+crate::<table::Table as table::TableLike>::entry(p0, &p1);
+<table::Table>::entry(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::entry_format
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = & MaybeUninit::uninit().assume_init(); // key::Key
+p0.entry_format(p1);
+<table::Table as table::TableLike>::entry_format(p0, p1);
+crate::<table::Table as table::TableLike>::entry_format(p0, p1);
+<table::Table>::entry_format(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get(&p1);
+<table::Table as table::TableLike>::get(p0, &p1);
+crate::<table::Table as table::TableLike>::get(p0, &p1);
+<table::Table>::get(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_mut(&p1);
+<table::Table as table::TableLike>::get_mut(p0, &p1);
+crate::<table::Table as table::TableLike>::get_mut(p0, &p1);
+<table::Table>::get_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get_key_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_key_value(&p1);
+<table::Table as table::TableLike>::get_key_value(p0, &p1);
+crate::<table::Table as table::TableLike>::get_key_value(p0, &p1);
+<table::Table>::get_key_value(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get_key_value_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.get_key_value_mut(&p1);
+<table::Table as table::TableLike>::get_key_value_mut(p0, &p1);
+crate::<table::Table as table::TableLike>::get_key_value_mut(p0, &p1);
+<table::Table>::get_key_value_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::contains_key
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.contains_key(&p1);
+<table::Table as table::TableLike>::contains_key(p0, &p1);
+crate::<table::Table as table::TableLike>::contains_key(p0, &p1);
+<table::Table>::contains_key(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(&p1, p2);
+<table::Table as table::TableLike>::insert(p0, &p1, p2);
+crate::<table::Table as table::TableLike>::insert(p0, &p1, p2);
+<table::Table>::insert(p0, &p1, p2);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.remove(&p1);
+<table::Table as table::TableLike>::remove(p0, &p1);
+crate::<table::Table as table::TableLike>::remove(p0, &p1);
+<table::Table>::remove(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::get_values
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.get_values();
+<table::Table as table::TableLike>::get_values(p0);
+crate::<table::Table as table::TableLike>::get_values(p0);
+<table::Table>::get_values(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::fmt
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.fmt();
+<table::Table as table::TableLike>::fmt(p0);
+crate::<table::Table as table::TableLike>::fmt(p0);
+<table::Table>::fmt(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::sort_values
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
+p0.sort_values();
+<table::Table as table::TableLike>::sort_values(p0);
+crate::<table::Table as table::TableLike>::sort_values(p0);
+<table::Table>::sort_values(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::is_dotted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
+p0.is_dotted();
+<table::Table as table::TableLike>::is_dotted(p0);
+crate::<table::Table as table::TableLike>::is_dotted(p0);
+<table::Table>::is_dotted(p0);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::set_dotted
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = true; // None+bool
+p0.set_dotted(p1);
+<table::Table as table::TableLike>::set_dotted(p0, p1);
+crate::<table::Table as table::TableLike>::set_dotted(p0, p1);
+<table::Table>::set_dotted(p0, p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::key_decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.key_decor_mut(&p1);
+<table::Table as table::TableLike>::key_decor_mut(p0, &p1);
+crate::<table::Table as table::TableLike>::key_decor_mut(p0, &p1);
+<table::Table>::key_decor_mut(p0, &p1);
-----------------
crates/toml_edit/src/table.rs <table::Table as table::TableLike>::key_decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Table
let mut p1 = "sample"; // None+&str
+p0.key_decor(&p1);
+<table::Table as table::TableLike>::key_decor(p0, &p1);
+crate::<table::Table as table::TableLike>::key_decor(p0, &p1);
+<table::Table>::key_decor(p0, &p1);
-----------------
crates/toml_edit/src/table.rs table::Entry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::Entry<'a>
+p0.key();
+table::Entry::<'a>::key(p0);
+crate::table::Entry::<'a>::key(p0);
+<table::Entry<'a>>::key(p0);
-----------------
crates/toml_edit/src/table.rs table::Entry::<'a>::or_insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Entry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.or_insert(p1);
+table::Entry::<'a>::or_insert(p0, p1);
+crate::table::Entry::<'a>::or_insert(p0, p1);
+<table::Entry<'a>>::or_insert(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::Entry::<'a>::or_insert_with
'a
deps:{"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"table::Entry::<'a>::or_insert_with":{"F":["std::marker::Sized","std::ops::FnOnce"]}}
candidates:{"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"table::Entry::<'a>::or_insert_with":{"F":["core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::panic::AssertUnwindSafe<F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::Entry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.or_insert_with(p1);
+table::Entry::<'a>::or_insert_with(p0, p1);
+crate::table::Entry::<'a>::or_insert_with(p0, p1);
+<table::Entry<'a>>::or_insert_with(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.key();
+table::OccupiedEntry::<'a>::key(p0);
+crate::table::OccupiedEntry::<'a>::key(p0);
+<table::OccupiedEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::key_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.key_mut();
+table::OccupiedEntry::<'a>::key_mut(p0);
+crate::table::OccupiedEntry::<'a>::key_mut(p0);
+<table::OccupiedEntry<'a>>::key_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::get
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.get();
+table::OccupiedEntry::<'a>::get(p0);
+crate::table::OccupiedEntry::<'a>::get(p0);
+<table::OccupiedEntry<'a>>::get(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::get_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.get_mut();
+table::OccupiedEntry::<'a>::get_mut(p0);
+crate::table::OccupiedEntry::<'a>::get_mut(p0);
+<table::OccupiedEntry<'a>>::get_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::into_mut
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.into_mut();
+table::OccupiedEntry::<'a>::into_mut(p0);
+crate::table::OccupiedEntry::<'a>::into_mut(p0);
+<table::OccupiedEntry<'a>>::into_mut(p0);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(p1);
+table::OccupiedEntry::<'a>::insert(p0, p1);
+crate::table::OccupiedEntry::<'a>::insert(p0, p1);
+<table::OccupiedEntry<'a>>::insert(p0, p1);
-----------------
crates/toml_edit/src/table.rs table::OccupiedEntry::<'a>::remove
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::OccupiedEntry<'a>
+p0.remove();
+table::OccupiedEntry::<'a>::remove(p0);
+crate::table::OccupiedEntry::<'a>::remove(p0);
+<table::OccupiedEntry<'a>>::remove(p0);
-----------------
crates/toml_edit/src/table.rs table::VacantEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // table::VacantEntry<'a>
+p0.key();
+table::VacantEntry::<'a>::key(p0);
+crate::table::VacantEntry::<'a>::key(p0);
+<table::VacantEntry<'a>>::key(p0);
-----------------
crates/toml_edit/src/table.rs table::VacantEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // table::VacantEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // item::Item
+p0.insert(p1);
+table::VacantEntry::<'a>::insert(p0, p1);
+crate::table::VacantEntry::<'a>::insert(p0, p1);
+<table::VacantEntry<'a>>::insert(p0, p1);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<value::Value as std::fmt::Debug>::fmt(p0, p1);
+crate::<value::Value as std::fmt::Debug>::fmt(p0, p1);
+<value::Value>::fmt(p0, p1);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.clone();
+<value::Value as std::clone::Clone>::clone(p0);
+crate::<value::Value as std::clone::Clone>::clone(p0);
+<value::Value>::clone(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::type_name
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.type_name();
+value::Value::type_name(p0);
+crate::value::Value::type_name(p0);
+<value::Value>::type_name(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_str();
+value::Value::as_str(p0);
+crate::value::Value::as_str(p0);
+<value::Value>::as_str(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_str();
+value::Value::is_str(p0);
+crate::value::Value::is_str(p0);
+<value::Value>::is_str(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_integer();
+value::Value::as_integer(p0);
+crate::value::Value::as_integer(p0);
+<value::Value>::as_integer(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_integer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_integer();
+value::Value::is_integer(p0);
+crate::value::Value::is_integer(p0);
+<value::Value>::is_integer(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_float();
+value::Value::as_float(p0);
+crate::value::Value::as_float(p0);
+<value::Value>::as_float(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_float
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_float();
+value::Value::is_float(p0);
+crate::value::Value::is_float(p0);
+<value::Value>::is_float(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_bool();
+value::Value::as_bool(p0);
+crate::value::Value::as_bool(p0);
+<value::Value>::as_bool(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_bool();
+value::Value::is_bool(p0);
+crate::value::Value::is_bool(p0);
+<value::Value>::is_bool(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_datetime();
+value::Value::as_datetime(p0);
+crate::value::Value::as_datetime(p0);
+<value::Value>::as_datetime(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_datetime
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_datetime();
+value::Value::is_datetime(p0);
+crate::value::Value::is_datetime(p0);
+<value::Value>::is_datetime(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_array();
+value::Value::as_array(p0);
+crate::value::Value::as_array(p0);
+<value::Value>::as_array(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_array_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_array_mut();
+value::Value::as_array_mut(p0);
+crate::value::Value::as_array_mut(p0);
+<value::Value>::as_array_mut(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_array();
+value::Value::is_array(p0);
+crate::value::Value::is_array(p0);
+<value::Value>::is_array(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_inline_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_inline_table();
+value::Value::as_inline_table(p0);
+crate::value::Value::as_inline_table(p0);
+<value::Value>::as_inline_table(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::as_inline_table_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_inline_table_mut();
+value::Value::as_inline_table_mut(p0);
+crate::value::Value::as_inline_table_mut(p0);
+<value::Value>::as_inline_table_mut(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::is_inline_table
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_inline_table();
+value::Value::is_inline_table(p0);
+crate::value::Value::is_inline_table(p0);
+<value::Value>::is_inline_table(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::decor_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.decor_mut();
+value::Value::decor_mut(p0);
+crate::value::Value::decor_mut(p0);
+<value::Value>::decor_mut(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::decor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.decor();
+value::Value::decor(p0);
+crate::value::Value::decor(p0);
+<value::Value>::decor(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::decorated
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"value::Value::decorated":{"impl Into<RawString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"value::Value::decorated":{"impl Into<RawString>":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.decorated(p1, p2);
+value::Value::decorated(p0, p1, p2);
+crate::value::Value::decorated(p0, p1, p2);
+<value::Value>::decorated(p0, p1, p2);
-----------------
crates/toml_edit/src/value.rs value::Value::decorate
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"value::Value::decorate":{"impl Into<RawString>":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"value::Value::decorate":{"impl Into<RawString>":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
let mut p2 = MaybeUninit::uninit().assume_init(); // impl Into<RawString>
+p0.decorate(p1, p2);
+value::Value::decorate(p0, p1, p2);
+crate::value::Value::decorate(p0, p1, p2);
+<value::Value>::decorate(p0, p1, p2);
-----------------
crates/toml_edit/src/value.rs value::Value::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.span();
+value::Value::span(p0);
+crate::value::Value::span(p0);
+<value::Value>::span(p0);
-----------------
crates/toml_edit/src/value.rs value::Value::despan
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
+p0.despan(&p1);
+value::Value::despan(p0, &p1);
+crate::value::Value::despan(p0, &p1);
+<value::Value>::despan(p0, &p1);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<value::Value as std::str::FromStr>::from_str(&p0);
+crate::<value::Value as std::str::FromStr>::from_str(&p0);
+<value::Value>::from_str(&p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<&'b value::Value>>::from
'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+<value::Value as std::convert::From<&'b value::Value>>::from(p0);
+crate::<value::Value as std::convert::From<&'b value::Value>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<&'b str>>::from
'b
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<value::Value as std::convert::From<&'b str>>::from(&p0);
+crate::<value::Value as std::convert::From<&'b str>>::from(&p0);
+<value::Value>::from(&p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<&'b std::string::String>>::from
'b
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<value::Value as std::convert::From<&'b std::string::String>>::from(p0);
+crate::<value::Value as std::convert::From<&'b std::string::String>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<value::Value as std::convert::From<std::string::String>>::from(p0);
+crate::<value::Value as std::convert::From<std::string::String>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<&'b internal_string::InternalString>>::from
'b
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<value::Value as std::convert::From<&'b internal_string::InternalString>>::from(p0);
+crate::<value::Value as std::convert::From<&'b internal_string::InternalString>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<internal_string::InternalString>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal_string::InternalString
+<value::Value as std::convert::From<internal_string::InternalString>>::from(p0);
+crate::<value::Value as std::convert::From<internal_string::InternalString>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<i64>>::from
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<value::Value as std::convert::From<i64>>::from(p0);
+crate::<value::Value as std::convert::From<i64>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<f64>>::from
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+<value::Value as std::convert::From<f64>>::from(p0);
+crate::<value::Value as std::convert::From<f64>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<bool>>::from
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+<value::Value as std::convert::From<bool>>::from(p0);
+crate::<value::Value as std::convert::From<bool>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<toml_datetime::Datetime>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_datetime::Datetime
+<value::Value as std::convert::From<toml_datetime::Datetime>>::from(p0);
+crate::<value::Value as std::convert::From<toml_datetime::Datetime>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<toml_datetime::Date>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_datetime::Date
+<value::Value as std::convert::From<toml_datetime::Date>>::from(p0);
+crate::<value::Value as std::convert::From<toml_datetime::Date>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<toml_datetime::Time>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // toml_datetime::Time
+<value::Value as std::convert::From<toml_datetime::Time>>::from(p0);
+crate::<value::Value as std::convert::From<toml_datetime::Time>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<array::Array>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // array::Array
+<value::Value as std::convert::From<array::Array>>::from(p0);
+crate::<value::Value as std::convert::From<array::Array>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::convert::From<inline_table::InlineTable>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // inline_table::InlineTable
+<value::Value as std::convert::From<inline_table::InlineTable>>::from(p0);
+crate::<value::Value as std::convert::From<inline_table::InlineTable>>::from(p0);
+<value::Value>::from(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::iter::FromIterator<V>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<value::Value as std::iter::FromIterator<V>>::from_iter":{"I":["std::marker::Sized","std::iter::IntoIterator"],"V":["std::marker::Sized","std::convert::Into"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::char::CaseMappingIter","std::result::IterMut<'a, T>","std::iter::RepeatN<A>","std::iter::Map<I, F>","std::iter::MapWhile<I, P>","std::slice::Chunks<'a, T>","std::collections::hash_set::IntoIter<K>","std::process::CommandEnvs<'a>","std::slice::RSplitMut<'a, T, P>","std::collections::hash_map::IntoKeys<K, V>","std::slice::RChunksExactMut<'a, T>","std::collections::hash_map::IterMut<'a, K, V>","std::sync::mpsc::TryIter<'a, T>","std::slice::SplitInclusive<'a, T, P>","std::slice::IterMut<'a, T>","core::slice::iter::GenericSplitN<I>","std::slice::Split<'a, T, P>","std::slice::RChunksMut<'a, T>","std::str::RSplitN<'a, P>","std::sys_common::wstr::WStrUnits<'_>","std::boxed::Box<I, A>","std::slice::SplitNMut<'a, T, P>","std::iter::Cloned<I>","std::iter::sources::from_generator::FromGenerator<G>","std::collections::btree_map::Values<'a, K, V>","std::iter::FilterMap<I, F>","std::collections::linked_list::IterMut<'a, T>","std::iter::Repeat<A>","std::str::Matches<'a, P>","std::ops::Range<A>","std::env::ArgsOs","std::collections::hash_map::Values<'a, K, V>","std::iter::Flatten<I>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::os::unix::net::Messages<'a>","std::collections::btree_map::RangeMut<'a, K, V>","std::char::ToUppercase","std::iter::TakeWhile<I, P>","std::collections::linked_list::DrainFilter<'_, T, F>","std::collections::btree_map::IntoKeys<K, V, A>","std::iter::FlatMap<I, U, F>","std::collections::hash_map::IntoValues<K, V>","std::result::IntoIter<T>","std::io::Lines<B>","std::vec::IntoIter<T, A>","std::collections::btree_set::IntoIter<T, A>","std::slice::Iter<'a, T>","std::collections::hash_map::Drain<'a, K, V>","std::sys::unix::fs::ReadDir","std::string::Drain<'_>","std::collections::btree_map::IntoIter<K, V, A>","std::sys::unix::os::Env","std::collections::vec_deque::Drain<'_, T, A>","std::iter::Fuse<I>","std::sys_common::net::LookupHost","std::iter::adapters::GenericShunt<'_, I, R>","std::iter::StepBy<I>","core::error::Source<'a>","std::iter::Skip<I>","std::option::IntoIter<A>","std::str::Utf8Chunks<'a>","std::str::SplitAsciiWhitespace<'a>","std::iter::Chain<A, B>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::str::SplitTerminator<'a, P>","std::collections::hash_map::IntoIter<K, V>","std::path::Iter<'a>","std::collections::linked_list::Iter<'a, T>","std::slice::RChunks<'a, T>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::iter::Once<T>","std::collections::btree_map::IntoValues<K, V, A>","std::iter::ByRefSized<'_, I>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::path::Components<'a>","std::str::EscapeUnicode<'a>","std::collections::btree_set::Range<'a, T>","std::io::Split<B>","std::option::Iter<'a, A>","std::collections::hash_set::Difference<'a, T, S>","std::iter::Zip<A, B>","std::collections::btree_map::IterMut<'a, K, V>","std::slice::RSplitN<'a, T, P>","std::str::LinesAny<'a>","std::slice::EscapeAscii<'a>","std::net::Incoming<'a>","std::sys_common::wtf8::EncodeWide<'a>","std::str::RSplitTerminator<'a, P>","std::vec::Drain<'_, T, A>","std::collections::btree_set::Difference<'a, T, A>","std::str::EscapeDefault<'a>","std::collections::binary_heap::DrainSorted<'_, T>","std::iter::SkipWhile<I, P>","std::array::IntoIter<T, N>","std::slice::SplitInclusiveMut<'a, T, P>","std::slice::ArrayChunks<'a, T, N>","std::slice::RChunksExact<'a, T>","std::slice::RSplit<'a, T, P>","std::ops::RangeFrom<A>","std::collections::hash_set::DrainFilter<'_, K, F>","std::os::unix::net::Incoming<'a>","std::char::EscapeUnicode","std::iter::ArrayChunks<I, N>","std::str::Split<'a, P>","std::collections::btree_set::Intersection<'a, T, A>","std::collections::hash_set::Intersection<'a, T, S>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::char::ToLowercase","std::collections::hash_map::Keys<'a, K, V>","std::sys::unix::os::SplitPaths<'a>","std::collections::binary_heap::IntoIterSorted<T>","std::collections::btree_set::Iter<'a, T>","std::str::Lines<'a>","std::net::IntoIncoming","std::collections::btree_map::ValuesMut<'a, K, V>","std::iter::Successors<T, F>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::slice::ChunksExact<'a, T>","std::collections::btree_set::SymmetricDifference<'a, T>","std::str::Bytes<'_>","std::fs::ReadDir","std::str::MatchIndices<'a, P>","std::iter::Take<I>","std::collections::binary_heap::Drain<'_, T>","std::str::SplitWhitespace<'a>","std::iter::Empty<T>","std::vec::DrainFilter<'_, T, F, A>","std::collections::hash_set::Drain<'a, K>","std::iter::OnceWith<F>","std::iter::Cycle<I>","std::str::Chars<'a>","std::char::EscapeDebug","std::os::unix::net::ScmCredentials<'a>","std::collections::hash_map::ValuesMut<'a, K, V>","std::char::EscapeDefault","std::iter::Filter<I, P>","std::iter::Peekable<I>","std::str::RMatches<'a, P>","std::slice::ArrayChunksMut<'a, T, N>","std::io::Bytes<R>","std::ops::index_range::IndexRange","std::str::EscapeDebug<'a>","std::str::RMatchIndices<'a, P>","std::str::SplitInclusive<'a, P>","std::str::RSplit<'a, P>","std::iter::FromFn<F>","std::sync::mpsc::Iter<'a, T>","std::slice::RSplitNMut<'a, T, P>","std::slice::GroupByMut<'a, T, P>","std::env::Args","std::ascii::EscapeDefault","std::process::CommandArgs<'a>","std::iter::IntersperseWith<I, G>","std::collections::btree_map::Range<'a, K, V>","std::os::unix::net::ScmRights<'a>","std::collections::hash_map::Iter<'a, K, V>","std::iter::Inspect<I, F>","std::sys::unix::args::Args","std::str::SplitN<'a, P>","std::slice::GroupBy<'a, T, P>","std::str::EncodeUtf16<'a>","std::option::Item<A>","std::result::Iter<'a, T>","std::slice::ArrayWindows<'a, T, N>","std::slice::SplitMut<'a, T, P>","std::option::IterMut<'a, A>","std::iter::Copied<I>","std::env::SplitPaths<'a>","std::iter::Enumerate<I>","std::collections::hash_set::Iter<'a, K>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::collections::btree_map::Keys<'a, K, V>","std::collections::btree_set::Union<'a, T>","std::env::VarsOs","std::env::Vars","std::slice::Windows<'a, T>","std::str::CharIndices<'a>","std::collections::vec_deque::Iter<'a, T>","std::iter::Intersperse<I>","std::path::Ancestors<'a>","std::sync::mpsc::IntoIter<T>","std::ops::RangeInclusive<A>","std::collections::binary_heap::IntoIter<T>","std::sys::unix::process::process_common::CommandArgs<'a>","std::collections::hash_set::Union<'a, T, S>","std::iter::Scan<I, St, F>","std::slice::ChunksMut<'a, T>","std::collections::binary_heap::Iter<'a, T>","std::slice::SplitN<'a, T, P>","std::collections::vec_deque::IntoIter<T, A>","std::slice::ChunksExactMut<'a, T>","std::iter::RepeatWith<F>","std::collections::btree_map::Iter<'a, K, V>","std::vec::Splice<'_, I, A>","std::collections::vec_deque::IterMut<'a, T>","std::iter::Rev<I>","std::char::DecodeUtf16<I>","std::collections::linked_list::IntoIter<T>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<value::Value as std::iter::FromIterator<V>>::from_iter":{"I":["table::Table","<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>","inline_table::InlineTable","<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>","array_of_tables::ArrayOfTables","array::Array"],"V":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<value::Value as std::iter::FromIterator<V>>::from_iter(p0);
+crate::<value::Value as std::iter::FromIterator<V>>::from_iter(p0);
+<value::Value>::from_iter(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::iter::FromIterator<(K, V)>>::from_iter
deps:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<value::Value as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["std::iter::IntoIterator","std::marker::Sized"],"K":["std::convert::Into","std::marker::Sized"],"V":["std::marker::Sized","std::convert::Into"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
candidates:{"<&'a indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a indexmap::set::Slice<T> as std::iter::IntoIterator>":{},"<&'a mut indexmap::map::Slice<K, V> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::char::ToLowercase","std::ascii::EscapeDefault","std::collections::hash_set::Intersection<'a, T, S>","std::io::Bytes<R>","std::slice::RChunksExact<'a, T>","std::option::Item<A>","std::collections::btree_map::Values<'a, K, V>","std::sys_common::wtf8::EncodeWide<'a>","std::slice::IterMut<'a, T>","std::iter::Take<I>","std::ops::RangeInclusive<A>","std::env::SplitPaths<'a>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::str::Matches<'a, P>","std::str::EncodeUtf16<'a>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::option::Iter<'a, A>","std::array::IntoIter<T, N>","std::collections::hash_map::IntoIter<K, V>","std::slice::RChunksMut<'a, T>","std::sys::unix::os::SplitPaths<'a>","std::process::CommandArgs<'a>","std::slice::Split<'a, T, P>","std::result::IterMut<'a, T>","std::slice::RSplitN<'a, T, P>","std::collections::btree_map::IntoValues<K, V, A>","std::str::LinesAny<'a>","std::boxed::Box<I, A>","std::collections::binary_heap::Iter<'a, T>","std::os::unix::net::ScmCredentials<'a>","std::collections::hash_set::Difference<'a, T, S>","std::iter::ByRefSized<'_, I>","std::sys::unix::fs::ReadDir","std::collections::hash_map::IntoValues<K, V>","std::char::ToUppercase","std::iter::Cloned<I>","std::slice::SplitN<'a, T, P>","std::net::IntoIncoming","std::string::Drain<'_>","std::str::RMatchIndices<'a, P>","std::str::Bytes<'_>","std::str::RMatches<'a, P>","std::iter::Filter<I, P>","std::collections::linked_list::DrainFilter<'_, T, F>","std::slice::SplitInclusiveMut<'a, T, P>","std::io::Split<B>","std::slice::Windows<'a, T>","std::collections::hash_map::Values<'a, K, V>","std::env::ArgsOs","std::collections::hash_map::ValuesMut<'a, K, V>","std::collections::binary_heap::IntoIter<T>","std::str::RSplitN<'a, P>","std::collections::binary_heap::DrainSorted<'_, T>","std::collections::btree_map::Range<'a, K, V>","std::collections::hash_map::Iter<'a, K, V>","std::iter::TakeWhile<I, P>","<&'a mut winnow::combinator::ParserIterator<F, I, O, E> as std::iter::Iterator>","std::str::Lines<'a>","std::str::Utf8Chunks<'a>","std::slice::EscapeAscii<'a>","std::str::MatchIndices<'a, P>","std::collections::hash_set::IntoIter<K>","std::sys::unix::process::process_common::CommandArgs<'a>","std::os::unix::net::Messages<'a>","std::iter::IntersperseWith<I, G>","std::slice::GroupBy<'a, T, P>","std::str::SplitTerminator<'a, P>","std::slice::RChunksExactMut<'a, T>","std::char::DecodeUtf16<I>","std::collections::btree_map::Keys<'a, K, V>","std::process::CommandEnvs<'a>","std::slice::Iter<'a, T>","std::slice::ArrayChunksMut<'a, T, N>","std::iter::Empty<T>","std::collections::btree_map::IntoIter<K, V, A>","std::iter::Enumerate<I>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::iter::SkipWhile<I, P>","std::iter::FlatMap<I, U, F>","std::collections::btree_map::RangeMut<'a, K, V>","std::str::SplitAsciiWhitespace<'a>","core::slice::iter::GenericSplitN<I>","std::collections::btree_set::Range<'a, T>","std::slice::RChunks<'a, T>","std::collections::hash_set::Iter<'a, K>","std::collections::linked_list::IterMut<'a, T>","std::iter::sources::from_generator::FromGenerator<G>","std::fs::ReadDir","std::iter::Chain<A, B>","std::iter::Once<T>","std::iter::RepeatN<A>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::result::Iter<'a, T>","std::iter::Flatten<I>","std::str::RSplit<'a, P>","std::str::CharIndices<'a>","std::slice::ArrayWindows<'a, T, N>","std::collections::vec_deque::Iter<'a, T>","std::collections::hash_map::IntoKeys<K, V>","std::collections::btree_map::IntoKeys<K, V, A>","std::collections::vec_deque::IntoIter<T, A>","std::iter::Repeat<A>","std::ops::Range<A>","std::char::EscapeUnicode","std::path::Components<'a>","std::collections::hash_map::Drain<'a, K, V>","std::sync::mpsc::TryIter<'a, T>","std::collections::btree_set::Intersection<'a, T, A>","std::ops::index_range::IndexRange","std::slice::ChunksMut<'a, T>","std::slice::ChunksExact<'a, T>","std::collections::btree_set::Iter<'a, T>","std::vec::DrainFilter<'_, T, F, A>","std::collections::binary_heap::Drain<'_, T>","std::os::unix::net::Incoming<'a>","std::sys::unix::os::Env","std::env::VarsOs","std::io::Lines<B>","std::iter::FromFn<F>","std::str::RSplitTerminator<'a, P>","std::collections::binary_heap::IntoIterSorted<T>","std::collections::linked_list::IntoIter<T>","std::collections::btree_map::Iter<'a, K, V>","std::collections::btree_set::SymmetricDifference<'a, T>","std::collections::btree_set::Difference<'a, T, A>","std::collections::btree_set::IntoIter<T, A>","std::collections::vec_deque::IterMut<'a, T>","std::collections::hash_map::Keys<'a, K, V>","std::env::Args","std::slice::ArrayChunks<'a, T, N>","std::vec::Splice<'_, I, A>","std::iter::Zip<A, B>","std::iter::OnceWith<F>","std::net::Incoming<'a>","std::collections::hash_map::IterMut<'a, K, V>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::iter::Fuse<I>","std::iter::Peekable<I>","std::iter::Skip<I>","std::collections::btree_set::Union<'a, T>","std::slice::SplitNMut<'a, T, P>","std::sync::mpsc::Iter<'a, T>","std::iter::RepeatWith<F>","std::env::Vars","std::iter::Successors<T, F>","std::str::SplitN<'a, P>","std::iter::FilterMap<I, F>","std::str::SplitWhitespace<'a>","std::slice::SplitMut<'a, T, P>","std::iter::Scan<I, St, F>","std::option::IterMut<'a, A>","std::sync::mpsc::IntoIter<T>","std::collections::linked_list::Iter<'a, T>","std::iter::Inspect<I, F>","std::collections::vec_deque::Drain<'_, T, A>","std::slice::SplitInclusive<'a, T, P>","std::collections::hash_set::DrainFilter<'_, K, F>","std::vec::Drain<'_, T, A>","std::iter::adapters::GenericShunt<'_, I, R>","std::collections::btree_map::IterMut<'a, K, V>","std::ops::RangeFrom<A>","std::str::Split<'a, P>","std::iter::Map<I, F>","std::vec::IntoIter<T, A>","std::str::Chars<'a>","std::option::IntoIter<A>","std::collections::btree_map::ValuesMut<'a, K, V>","std::sys_common::wstr::WStrUnits<'_>","std::slice::ChunksExactMut<'a, T>","core::error::Source<'a>","std::slice::RSplit<'a, T, P>","std::collections::hash_set::Union<'a, T, S>","std::char::CaseMappingIter","std::sys::unix::args::Args","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::os::unix::net::ScmRights<'a>","std::iter::Intersperse<I>","std::char::EscapeDefault","std::str::SplitInclusive<'a, P>","std::iter::ArrayChunks<I, N>","std::result::IntoIter<T>","std::iter::MapWhile<I, P>","std::slice::Chunks<'a, T>","std::str::EscapeDebug<'a>","std::slice::RSplitNMut<'a, T, P>","std::slice::RSplitMut<'a, T, P>","std::char::EscapeDebug","std::iter::StepBy<I>","std::str::EscapeDefault<'a>","std::path::Ancestors<'a>","std::sys_common::net::LookupHost","std::slice::GroupByMut<'a, T, P>","std::iter::Copied<I>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::collections::hash_set::Drain<'a, K>","std::str::EscapeUnicode<'a>","std::path::Iter<'a>","std::iter::Cycle<I>","std::iter::Rev<I>"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<value::Value as std::iter::FromIterator<(K, V)>>::from_iter":{"I":["table::Table","array_of_tables::ArrayOfTables","<I as std::iter::IntoIterator>","array::Array","inline_table::InlineTable","<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>"],"K":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"],"V":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"]},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexMap<K, V, S>>":{},"indexmap::map::iter::<impl std::iter::IntoIterator for &'a mut indexmap::IndexMap<K, V, S>>":{},"indexmap::set::iter::<impl std::iter::IntoIterator for &'a indexmap::IndexSet<T, S>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<value::Value as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+crate::<value::Value as std::iter::FromIterator<(K, V)>>::from_iter(p0);
+<value::Value>::from_iter(p0);
-----------------
crates/toml_edit/src/value.rs <value::Value as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<value::Value as std::fmt::Display>::fmt(p0, p1);
+crate::<value::Value as std::fmt::Display>::fmt(p0, p1);
+<value::Value>::fmt(p0, p1);