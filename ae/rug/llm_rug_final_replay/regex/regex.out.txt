-----------------
src/backtrack.rs backtrack::should_exec
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+backtrack::should_exec(p0, p1);
+crate::backtrack::should_exec(p0, p1);
+crate::backtrack::should_exec(p0, p1);
-----------------
src/backtrack.rs backtrack::usize_to_u32
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+backtrack::usize_to_u32(p0);
+crate::backtrack::usize_to_u32(p0);
+crate::backtrack::usize_to_u32(p0);
-----------------
src/compile.rs compile::u32_to_usize
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+compile::u32_to_usize(p0);
+crate::compile::u32_to_usize(p0);
+crate::compile::u32_to_usize(p0);
-----------------
src/dfa.rs dfa::can_exec
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+dfa::can_exec(p0);
+crate::dfa::can_exec(p0);
+crate::dfa::can_exec(p0);
-----------------
src/dfa.rs dfa::push_inst_ptr
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p1 = &mut 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+dfa::push_inst_ptr(p0, p1, p2);
+crate::dfa::push_inst_ptr(p0, p1, p2);
+crate::dfa::push_inst_ptr(p0, p1, p2);
-----------------
src/dfa.rs dfa::vb
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+dfa::vb(p0);
+crate::dfa::vb(p0);
+crate::dfa::vb(p0);
-----------------
src/dfa.rs dfa::usize_to_u32
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+dfa::usize_to_u32(p0);
+crate::dfa::usize_to_u32(p0);
+crate::dfa::usize_to_u32(p0);
-----------------
src/dfa.rs dfa::show_state_ptr
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+dfa::show_state_ptr(p0);
+crate::dfa::show_state_ptr(p0);
+crate::dfa::show_state_ptr(p0);
-----------------
src/dfa.rs dfa::write_vari32
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p1 = 0i32; // None+i32
+dfa::write_vari32(p0, p1);
+crate::dfa::write_vari32(p0, p1);
+crate::dfa::write_vari32(p0, p1);
-----------------
src/dfa.rs dfa::read_vari32
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+dfa::read_vari32(p0);
+crate::dfa::read_vari32(p0);
+crate::dfa::read_vari32(p0);
-----------------
src/dfa.rs dfa::write_varu32
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p1 = 0u32; // None+u32
+dfa::write_varu32(p0, p1);
+crate::dfa::write_varu32(p0, p1);
+crate::dfa::write_varu32(p0, p1);
-----------------
src/dfa.rs dfa::read_varu32
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+dfa::read_varu32(p0);
+crate::dfa::read_varu32(p0);
+crate::dfa::read_varu32(p0);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::is_anchor_end_match::imp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+exec::ExecNoSync::<'c>::is_anchor_end_match::imp(p0, p1);
+crate::exec::ExecNoSync::<'c>::is_anchor_end_match::imp(p0, p1);
+<exec::ExecNoSync<'c>>::is_anchor_end_match::imp(p0, p1);
-----------------
src/exec.rs exec::ExecReadOnly::choose_literal_match_type::imp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+exec::ExecReadOnly::choose_literal_match_type::imp(p0);
+crate::exec::ExecReadOnly::choose_literal_match_type::imp(p0);
+<exec::ExecReadOnly>::choose_literal_match_type::imp(p0);
-----------------
src/exec.rs exec::ExecReadOnly::choose_dfa_match_type::imp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+exec::ExecReadOnly::choose_dfa_match_type::imp(p0);
+crate::exec::ExecReadOnly::choose_dfa_match_type::imp(p0);
+<exec::ExecReadOnly>::choose_dfa_match_type::imp(p0);
-----------------
src/exec.rs exec::alternation_literals
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
+exec::alternation_literals(p0);
+crate::exec::alternation_literals(p0);
+crate::exec::alternation_literals(p0);
-----------------
src/exec.rs exec::literal_analysis
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
+exec::literal_analysis(p0);
+crate::exec::literal_analysis(p0);
+crate::exec::literal_analysis(p0);
-----------------
src/expand.rs expand::expand_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p1 = "sample"; // None+&str
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+expand::expand_str(p0, &p1, p2);
+crate::expand::expand_str(p0, &p1, p2);
+crate::expand::expand_str(p0, &p1, p2);
-----------------
src/expand.rs expand::expand_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+expand::expand_bytes(p0, p1, p2);
+crate::expand::expand_bytes(p0, p1, p2);
+crate::expand::expand_bytes(p0, p1, p2);
-----------------
src/expand.rs expand::find_cap_ref
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+expand::find_cap_ref(p0);
+crate::expand::find_cap_ref(p0);
+crate::expand::find_cap_ref(p0);
-----------------
src/expand.rs expand::find_cap_ref_braced
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
+expand::find_cap_ref_braced(p0, p1);
+crate::expand::find_cap_ref_braced(p0, p1);
+crate::expand::find_cap_ref_braced(p0, p1);
-----------------
src/expand.rs expand::is_valid_cap_letter
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+expand::is_valid_cap_letter(p0);
+crate::expand::is_valid_cap_letter(p0);
+crate::expand::is_valid_cap_letter(p0);
-----------------
src/find_byte.rs find_byte::find_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+find_byte::find_byte(p0, p1);
+crate::find_byte::find_byte(p0, p1);
+crate::find_byte::find_byte(p0, p1);
-----------------
src/find_byte.rs find_byte::find_byte::imp
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+find_byte::find_byte::imp(p0, p1);
+crate::find_byte::find_byte::imp(p0, p1);
+crate::find_byte::find_byte::imp(p0, p1);
-----------------
src/literal/imp.rs literal::imp::char_len_lossy
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+literal::imp::char_len_lossy(p0);
+crate::literal::imp::char_len_lossy(p0);
+crate::literal::imp::char_len_lossy(p0);
-----------------
/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs pool::THREAD_ID::__init
deps:{}
candidates:{}
+pool::THREAD_ID::__init();
+crate::pool::THREAD_ID::__init();
+crate::pool::THREAD_ID::__init();
-----------------
/home/xiang/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs pool::THREAD_ID::__getit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<&mut std::option::Option<usize>>
+pool::THREAD_ID::__getit(p0);
+crate::pool::THREAD_ID::__getit(p0);
+crate::pool::THREAD_ID::__getit(p0);
-----------------
src/prog.rs <prog::Program as std::fmt::Debug>::fmt::with_goto
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = std::string::String::new(); // None+std::string::String
+<prog::Program as std::fmt::Debug>::fmt::with_goto(p0, p1, p2);
+crate::<prog::Program as std::fmt::Debug>::fmt::with_goto(p0, p1, p2);
+<prog::Program>::fmt::with_goto(p0, p1, p2);
-----------------
src/prog.rs <prog::Program as std::fmt::Debug>::fmt::visible_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<prog::Program as std::fmt::Debug>::fmt::visible_byte(p0);
+crate::<prog::Program as std::fmt::Debug>::fmt::visible_byte(p0);
+<prog::Program>::fmt::visible_byte(p0);
-----------------
src/re_bytes.rs <re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_bytes(p0);
+crate::<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_bytes(p0);
+<re_bytes::CapturesDebug<'c, 't>>::fmt::escape_bytes(p0);
-----------------
src/re_bytes.rs <re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_byte(p0);
+crate::<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_byte(p0);
+<re_bytes::CapturesDebug<'c, 't>>::fmt::escape_byte(p0);
-----------------
src/re_bytes.rs re_bytes::no_expansion
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"re_bytes::no_expansion":{"T":["std::marker::Sized","std::convert::AsRef"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"re_bytes::no_expansion":{"T":["std::vec::Drain<'a, T, A>","std::ffi::CString","<&mut T as std::convert::AsRef<U>>","std::borrow::Cow<'_, std::ffi::OsStr>","std::rc::Rc<T>","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, T>","<&T as std::convert::AsRef<U>>","std::ffi::CStr","std::vec::IntoIter<T, A>","std::slice::Iter<'_, T>","std::slice::IterMut<'_, T>","std::boxed::Box<T, A>","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+re_bytes::no_expansion(p0);
+crate::re_bytes::no_expansion(p0);
+crate::re_bytes::no_expansion(p0);
-----------------
src/re_set.rs re_set::unicode::as_bytes_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_set::unicode::as_bytes_str(&p0);
+crate::re_set::unicode::as_bytes_str(&p0);
+crate::re_set::unicode::as_bytes_str(&p0);
-----------------
src/re_set.rs re_set::unicode::as_bytes_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+re_set::unicode::as_bytes_bytes(p0);
+crate::re_set::unicode::as_bytes_bytes(p0);
+crate::re_set::unicode::as_bytes_bytes(p0);
-----------------
src/re_set.rs re_set::bytes::as_bytes_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_set::bytes::as_bytes_str(&p0);
+crate::re_set::bytes::as_bytes_str(&p0);
+crate::re_set::bytes::as_bytes_str(&p0);
-----------------
src/re_set.rs re_set::bytes::as_bytes_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+re_set::bytes::as_bytes_bytes(p0);
+crate::re_set::bytes::as_bytes_bytes(p0);
+crate::re_set::bytes::as_bytes_bytes(p0);
-----------------
src/re_unicode.rs re_unicode::escape
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_unicode::escape(&p0);
+crate::re_unicode::escape(&p0);
+crate::re_unicode::escape(&p0);
-----------------
src/re_unicode.rs re_unicode::no_expansion
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"re_unicode::no_expansion":{"T":["std::convert::AsRef","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"re_unicode::no_expansion":{"T":["std::vec::Drain<'a, T, A>","std::ffi::CString","<&mut T as std::convert::AsRef<U>>","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, std::ffi::OsStr>","std::borrow::Cow<'_, T>","std::slice::IterMut<'_, T>","std::ffi::CStr","std::vec::IntoIter<T, A>","std::rc::Rc<T>","std::slice::Iter<'_, T>","std::boxed::Box<T, A>","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+re_unicode::no_expansion(p0);
+crate::re_unicode::no_expansion(p0);
+crate::re_unicode::no_expansion(p0);
-----------------
src/utf8.rs utf8::next_utf8
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
+utf8::next_utf8(p0, p1);
+crate::utf8::next_utf8(p0, p1);
+crate::utf8::next_utf8(p0, p1);
-----------------
src/utf8.rs utf8::decode_utf8
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+utf8::decode_utf8(p0);
+crate::utf8::decode_utf8(p0);
+crate::utf8::decode_utf8(p0);
-----------------
src/utf8.rs utf8::decode_last_utf8
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+utf8::decode_last_utf8(p0);
+crate::utf8::decode_last_utf8(p0);
+crate::utf8::decode_last_utf8(p0);
-----------------
src/utf8.rs utf8::is_start_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+utf8::is_start_byte(p0);
+crate::utf8::is_start_byte(p0);
+crate::utf8::is_start_byte(p0);
-----------------
src/input.rs input::Input::at
deps:{"input::Input::at":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::at":{"Self":["input::ByteInput","input::CharInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.at(p1);
+input::Input::at(p0, p1);
+crate::input::Input::at(p0, p1);
+crate::input::Input::at(p0, p1);
-----------------
src/input.rs input::Input::next_char
deps:{"input::Input::next_char":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::next_char":{"Self":["input::CharInput","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_char(p1);
+input::Input::next_char(p0, p1);
+crate::input::Input::next_char(p0, p1);
+crate::input::Input::next_char(p0, p1);
-----------------
src/input.rs input::Input::previous_char
deps:{"input::Input::previous_char":{"Self":["input::Input","std::fmt::Debug"]}}
candidates:{"input::Input::previous_char":{"Self":["input::CharInput","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.previous_char(p1);
+input::Input::previous_char(p0, p1);
+crate::input::Input::previous_char(p0, p1);
+crate::input::Input::previous_char(p0, p1);
-----------------
src/input.rs input::Input::is_empty_match
deps:{"input::Input::is_empty_match":{"Self":["input::Input","std::fmt::Debug"]}}
candidates:{"input::Input::is_empty_match":{"Self":["input::CharInput","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.is_empty_match(p1, p2);
+input::Input::is_empty_match(p0, p1, p2);
+crate::input::Input::is_empty_match(p0, p1, p2);
+crate::input::Input::is_empty_match(p0, p1, p2);
-----------------
src/input.rs input::Input::prefix_at
deps:{"input::Input::prefix_at":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::prefix_at":{"Self":["input::CharInput","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.prefix_at(p1, p2);
+input::Input::prefix_at(p0, p1, p2);
+crate::input::Input::prefix_at(p0, p1, p2);
+crate::input::Input::prefix_at(p0, p1, p2);
-----------------
src/input.rs input::Input::len
deps:{"input::Input::len":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::len":{"Self":["input::CharInput","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.len();
+input::Input::len(p0);
+crate::input::Input::len(p0);
+crate::input::Input::len(p0);
-----------------
src/input.rs input::Input::is_empty
deps:{"input::Input::is_empty":{"Self":["input::Input","std::fmt::Debug"]}}
candidates:{"input::Input::is_empty":{"Self":["input::CharInput","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_empty();
+input::Input::is_empty(p0);
+crate::input::Input::is_empty(p0);
+crate::input::Input::is_empty(p0);
-----------------
src/input.rs input::Input::as_bytes
deps:{"input::Input::as_bytes":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::as_bytes":{"Self":["input::ByteInput","input::CharInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.as_bytes();
+input::Input::as_bytes(p0);
+crate::input::Input::as_bytes(p0);
+crate::input::Input::as_bytes(p0);
-----------------
src/re_bytes.rs re_bytes::Replacer::replace_append
deps:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"re_bytes::Replacer::replace_append":{"Self":["re_bytes::Replacer"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty"]},"<T as std::borrow::ToOwned>":{"T":["re_unicode::Regex","dfa::Byte","prog::InstSave","error::Error","re_unicode::CaptureNames","compile::InstHole","input::ByteInput","prog::InstRanges","re_trait::Locations","literal::imp::SingleByteSet","std::clone::impls::<impl std::clone::Clone for *const T>","re_unicode::CaptureLocations","dfa::EmptyFlags","expand::Ref","re_set::bytes::RegexSet","literal::imp::Matcher","literal::imp::LiteralSearcher","pikevm::Threads","dfa::Transitions","re_unicode::NoExpand","backtrack::Cache","prog::InstChar","re_unicode::Match","prog::EmptyLook","re_set::bytes::SetMatches","prog::InstSplit","re_builder::RegexOptions","compile::SuffixCacheKey","re_bytes::CaptureNames","re_bytes::Match","prog::Inst","re_bytes::SubCaptureMatches","pikevm::FollowEpsilon","compile::SuffixCacheEntry","input::Char","exec::Exec","exec::MatchNfaType","re_bytes::NoExpand","re_bytes::Regex","expand::CaptureRef","prog::InstBytes","input::CharInput","dfa::StateFlags","compile::MaybeInst","re_unicode::SubCaptureMatches","input::InputAt","re_bytes::CaptureLocations","dfa::Result","exec::MatchType","dfa::State","re_trait::SubCapturesPosIter","prog::InstEmptyLook","exec::MatchLiteralType","pikevm::Cache","sparse::SparseSet","re_set::unicode::RegexSet","re_set::unicode::SetMatches","re_set::bytes::SetMatchesIter","backtrack::Job","prog::Program","re_set::unicode::SetMatchesIter","literal::imp::Memmem"]},"dfa::Result":{"T":["dfa::Byte","compile::InstHole","prog::InstSplit","re_bytes::CaptureLocations","prog::InstSave","re_bytes::Regex","sparse::SparseSet","pikevm::Threads","prog::InstEmptyLook","compile::SuffixCacheEntry","re_bytes::CaptureNames","re_unicode::CaptureNames","literal::imp::SingleByteSet","exec::MatchType","re_set::bytes::RegexSet","exec::MatchNfaType","<&T as std::fmt::Debug>","dfa::Result","re_unicode::CaptureLocations","dfa::State","prog::InstRanges","prog::Inst","prog::EmptyLook","literal::imp::LiteralSearcher","expand::Ref","pikevm::FollowEpsilon","re_set::unicode::SetMatchesIter","re_set::unicode::SetMatches","dfa::EmptyFlags","re_builder::RegexOptions","literal::imp::Memmem","re_bytes::Match","exec::Exec","re_trait::Locations","input::ByteInput","re_unicode::SubCaptureMatches","re_trait::SubCapturesPosIter","re_set::bytes::SetMatches","pikevm::Cache","re_unicode::NoExpand","re_set::bytes::SetMatchesIter","expand::CaptureRef","re_unicode::Match","input::InputAt","input::Char","compile::MaybeInst","backtrack::Cache","dfa::StateFlags","exec::MatchLiteralType","prog::Program","error::Error","re_bytes::NoExpand","prog::InstBytes","re_unicode::Regex","re_set::unicode::RegexSet","literal::imp::Matcher","compile::SuffixCacheKey","re_bytes::SubCaptureMatches","prog::InstChar","backtrack::Job","input::CharInput","dfa::Transitions"]},"re_bytes::Replacer::replace_append":{"Self":["<&'a std::vec::Vec<u8> as re_bytes::Replacer>","std::borrow::Cow","std::vec::Vec","re_bytes::NoExpand","re_bytes::ReplacerRef"]},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::path::Path","std::ffi::OsStr","std::ffi::CStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+re_bytes::Replacer::replace_append(p0, p1, p2);
+crate::re_bytes::Replacer::replace_append(p0, p1, p2);
+crate::re_bytes::Replacer::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Replacer::no_expansion
deps:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"re_bytes::Replacer::no_expansion":{"Self":["re_bytes::Replacer"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace"]},"<T as std::borrow::ToOwned>":{"T":["prog::EmptyLook","pikevm::Threads","exec::MatchType","re_bytes::SubCaptureMatches","input::CharInput","re_bytes::Regex","input::ByteInput","dfa::State","re_unicode::CaptureNames","dfa::StateFlags","pikevm::FollowEpsilon","prog::InstSplit","compile::SuffixCacheEntry","prog::Program","exec::MatchLiteralType","re_trait::Locations","re_bytes::CaptureLocations","error::Error","expand::Ref","re_set::bytes::SetMatchesIter","backtrack::Job","re_bytes::CaptureNames","compile::SuffixCacheKey","expand::CaptureRef","exec::MatchNfaType","re_unicode::SubCaptureMatches","compile::MaybeInst","prog::InstChar","std::clone::impls::<impl std::clone::Clone for &T>","dfa::Transitions","re_set::unicode::RegexSet","re_unicode::CaptureLocations","prog::InstSave","re_set::bytes::SetMatches","compile::InstHole","literal::imp::LiteralSearcher","sparse::SparseSet","prog::Inst","re_unicode::NoExpand","re_set::bytes::RegexSet","re_bytes::Match","backtrack::Cache","re_unicode::Match","literal::imp::Memmem","input::Char","re_bytes::NoExpand","dfa::EmptyFlags","re_builder::RegexOptions","prog::InstEmptyLook","re_set::unicode::SetMatchesIter","re_trait::SubCapturesPosIter","prog::InstRanges","literal::imp::Matcher","input::InputAt","dfa::Result","pikevm::Cache","exec::Exec","prog::InstBytes","re_set::unicode::SetMatches","re_unicode::Regex","dfa::Byte","literal::imp::SingleByteSet"]},"dfa::Result":{"T":["re_bytes::NoExpand","re_unicode::NoExpand","exec::MatchNfaType","exec::Exec","prog::InstSplit","dfa::Byte","input::Char","re_bytes::CaptureNames","re_trait::SubCapturesPosIter","re_bytes::Match","compile::InstHole","pikevm::Threads","sparse::SparseSet","prog::Inst","re_set::bytes::SetMatches","dfa::Transitions","re_unicode::CaptureNames","input::ByteInput","dfa::Result","compile::SuffixCacheKey","re_bytes::SubCaptureMatches","re_bytes::Regex","re_set::bytes::SetMatchesIter","input::CharInput","literal::imp::SingleByteSet","exec::MatchLiteralType","exec::MatchType","re_set::unicode::SetMatchesIter","prog::InstChar","backtrack::Job","prog::Program","dfa::EmptyFlags","dfa::State","prog::InstEmptyLook","re_unicode::Match","re_set::unicode::SetMatches","re_set::bytes::RegexSet","re_builder::RegexOptions","std::clone::impls::<impl std::clone::Clone for *mut T>","literal::imp::Memmem","pikevm::Cache","prog::InstRanges","expand::CaptureRef","prog::EmptyLook","re_unicode::SubCaptureMatches","prog::InstBytes","compile::SuffixCacheEntry","error::Error","re_set::unicode::RegexSet","re_trait::Locations","prog::InstSave","literal::imp::Matcher","dfa::StateFlags","compile::MaybeInst","re_unicode::CaptureLocations","expand::Ref","re_unicode::Regex","re_bytes::CaptureLocations","input::InputAt","pikevm::FollowEpsilon","backtrack::Cache","literal::imp::LiteralSearcher"]},"re_bytes::Replacer::no_expansion":{"Self":["std::vec::Vec","re_bytes::NoExpand","std::borrow::Cow","<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>","re_bytes::ReplacerRef"]},"std::borrow::Cow":{"B":["std::ffi::OsStr","std::path::Path","std::ffi::CStr","<T as std::borrow::ToOwned>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.no_expansion();
+re_bytes::Replacer::no_expansion(p0);
+crate::re_bytes::Replacer::no_expansion(p0);
+crate::re_bytes::Replacer::no_expansion(p0);
-----------------
src/re_bytes.rs re_bytes::Replacer::by_ref
deps:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"re_bytes::Replacer::by_ref":{"Self":["re_bytes::Replacer"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::alloc::Allocator","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::borrow::ToOwned>":{"T":["literal::imp::SingleByteSet","input::InputAt","prog::InstBytes","re_unicode::Match","prog::InstSplit","re_set::unicode::SetMatches","re_set::unicode::RegexSet","expand::Ref","re_trait::SubCapturesPosIter","pikevm::Threads","dfa::Result","re_set::bytes::RegexSet","std::clone::impls::<impl std::clone::Clone for *const T>","literal::imp::Memmem","dfa::StateFlags","prog::Program","sparse::SparseSet","literal::imp::LiteralSearcher","exec::MatchLiteralType","re_unicode::Regex","dfa::Transitions","compile::SuffixCacheKey","re_set::bytes::SetMatches","error::Error","re_builder::RegexOptions","dfa::Byte","re_bytes::CaptureLocations","compile::SuffixCacheEntry","backtrack::Job","re_bytes::NoExpand","re_unicode::CaptureNames","input::Char","re_bytes::CaptureNames","input::ByteInput","prog::InstEmptyLook","literal::imp::Matcher","re_set::bytes::SetMatchesIter","backtrack::Cache","re_bytes::Match","re_trait::Locations","dfa::EmptyFlags","re_bytes::Regex","pikevm::FollowEpsilon","dfa::State","re_set::unicode::SetMatchesIter","exec::MatchType","prog::InstChar","input::CharInput","exec::Exec","re_unicode::CaptureLocations","prog::InstRanges","exec::MatchNfaType","prog::InstSave","prog::EmptyLook","prog::Inst","re_bytes::SubCaptureMatches","re_unicode::SubCaptureMatches","re_unicode::NoExpand","expand::CaptureRef","compile::InstHole","pikevm::Cache","compile::MaybeInst"]},"dfa::Result":{"T":["input::Char","re_set::bytes::SetMatchesIter","re_unicode::Regex","re_bytes::NoExpand","dfa::Byte","pikevm::Threads","prog::Inst","dfa::StateFlags","compile::InstHole","input::CharInput","dfa::State","prog::EmptyLook","exec::MatchNfaType","re_set::unicode::RegexSet","exec::MatchLiteralType","prog::InstSave","re_unicode::SubCaptureMatches","re_set::bytes::SetMatches","compile::SuffixCacheKey","input::ByteInput","pikevm::Cache","re_builder::RegexOptions","exec::Exec","dfa::Result","re_bytes::Regex","expand::Ref","prog::Program","re_trait::Locations","error::Error","literal::imp::Matcher","backtrack::Job","literal::imp::LiteralSearcher","exec::MatchType","compile::SuffixCacheEntry","prog::InstSplit","re_bytes::CaptureLocations","prog::InstRanges","prog::InstEmptyLook","dfa::EmptyFlags","prog::InstChar","re_trait::SubCapturesPosIter","re_set::unicode::SetMatchesIter","prog::InstBytes","pikevm::FollowEpsilon","sparse::SparseSet","re_unicode::CaptureLocations","input::InputAt","re_bytes::SubCaptureMatches","re_set::unicode::SetMatches","re_unicode::NoExpand","literal::imp::SingleByteSet","expand::CaptureRef","<&T as std::fmt::Debug>","backtrack::Cache","literal::imp::Memmem","dfa::Transitions","re_set::bytes::RegexSet","compile::MaybeInst","re_bytes::Match","re_bytes::CaptureNames","re_unicode::CaptureNames","re_unicode::Match"]},"re_bytes::Replacer::by_ref":{"Self":["<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>","std::vec::Vec","re_bytes::ReplacerRef","re_bytes::NoExpand","std::borrow::Cow"]},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::path::Path","std::ffi::CStr","std::ffi::OsStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.by_ref();
+re_bytes::Replacer::by_ref(p0);
+crate::re_bytes::Replacer::by_ref(p0);
+crate::re_bytes::Replacer::by_ref(p0);
-----------------
src/re_trait.rs re_trait::RegularExpression::slots_len
deps:{"re_trait::RegularExpression::slots_len":{"Self":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]}}
candidates:{"re_trait::RegularExpression::slots_len":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.slots_len();
+re_trait::RegularExpression::slots_len(p0);
+crate::re_trait::RegularExpression::slots_len(p0);
+crate::re_trait::RegularExpression::slots_len(p0);
-----------------
src/re_trait.rs re_trait::RegularExpression::locations
deps:{"re_trait::RegularExpression::locations":{"Self":["std::fmt::Debug","re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"re_trait::RegularExpression::locations":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.locations();
+re_trait::RegularExpression::locations(p0);
+crate::re_trait::RegularExpression::locations(p0);
+crate::re_trait::RegularExpression::locations(p0);
-----------------
src/re_trait.rs re_trait::RegularExpression::next_after_empty
deps:{"re_trait::RegularExpression::next_after_empty":{"Self":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"re_trait::RegularExpression::next_after_empty":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p2 = 0usize; // None+usize
+p0.next_after_empty(p1, p2);
+re_trait::RegularExpression::next_after_empty(p0, p1, p2);
+crate::re_trait::RegularExpression::next_after_empty(p0, p1, p2);
+crate::re_trait::RegularExpression::next_after_empty(p0, p1, p2);
-----------------
src/re_trait.rs re_trait::RegularExpression::shortest_match_at
deps:{"re_trait::RegularExpression::shortest_match_at":{"Self":["std::fmt::Debug","re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"re_trait::RegularExpression::shortest_match_at":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(p1, p2);
+re_trait::RegularExpression::shortest_match_at(p0, p1, p2);
+crate::re_trait::RegularExpression::shortest_match_at(p0, p1, p2);
+crate::re_trait::RegularExpression::shortest_match_at(p0, p1, p2);
-----------------
src/re_trait.rs re_trait::RegularExpression::is_match_at
deps:{"re_trait::RegularExpression::is_match_at":{"Self":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]}}
candidates:{"re_trait::RegularExpression::is_match_at":{"Self":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p2 = 0usize; // None+usize
+p0.is_match_at(p1, p2);
+re_trait::RegularExpression::is_match_at(p0, p1, p2);
+crate::re_trait::RegularExpression::is_match_at(p0, p1, p2);
+crate::re_trait::RegularExpression::is_match_at(p0, p1, p2);
-----------------
src/re_trait.rs re_trait::RegularExpression::find_at
deps:{"re_trait::RegularExpression::find_at":{"Self":["std::fmt::Debug","re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"re_trait::RegularExpression::find_at":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p2 = 0usize; // None+usize
+p0.find_at(p1, p2);
+re_trait::RegularExpression::find_at(p0, p1, p2);
+crate::re_trait::RegularExpression::find_at(p0, p1, p2);
+crate::re_trait::RegularExpression::find_at(p0, p1, p2);
-----------------
src/re_trait.rs re_trait::RegularExpression::captures_read_at
deps:{"re_trait::RegularExpression::captures_read_at":{"Self":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]}}
candidates:{"re_trait::RegularExpression::captures_read_at":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p2 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, p2, p3);
+re_trait::RegularExpression::captures_read_at(p0, p1, p2, p3);
+crate::re_trait::RegularExpression::captures_read_at(p0, p1, p2, p3);
+crate::re_trait::RegularExpression::captures_read_at(p0, p1, p2, p3);
-----------------
src/re_trait.rs re_trait::RegularExpression::find_iter
deps:{"re_trait::RegularExpression::find_iter":{"Self":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]}}
candidates:{"re_trait::RegularExpression::find_iter":{"Self":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
+p0.find_iter(p1);
+re_trait::RegularExpression::find_iter(p0, p1);
+crate::re_trait::RegularExpression::find_iter(p0, p1);
+crate::re_trait::RegularExpression::find_iter(p0, p1);
-----------------
src/re_trait.rs re_trait::RegularExpression::captures_iter
deps:{"re_trait::RegularExpression::captures_iter":{"Self":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"re_trait::RegularExpression::captures_iter":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
+p0.captures_iter(p1);
+re_trait::RegularExpression::captures_iter(p0, p1);
+crate::re_trait::RegularExpression::captures_iter(p0, p1);
+crate::re_trait::RegularExpression::captures_iter(p0, p1);
-----------------
src/re_unicode.rs re_unicode::Replacer::replace_append
deps:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"re_unicode::Replacer::replace_append":{"Self":["re_unicode::Replacer"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::borrow::ToOwned>":{"T":["prog::InstEmptyLook","prog::InstChar","expand::Ref","re_set::bytes::SetMatches","re_unicode::CaptureLocations","pikevm::Cache","prog::Inst","re_trait::Locations","literal::imp::SingleByteSet","re_set::unicode::RegexSet","re_bytes::CaptureNames","backtrack::Job","dfa::Result","re_set::bytes::RegexSet","literal::imp::LiteralSearcher","compile::MaybeInst","prog::InstSplit","re_set::unicode::SetMatches","prog::InstBytes","pikevm::FollowEpsilon","re_unicode::Regex","exec::Exec","dfa::StateFlags","dfa::State","dfa::Byte","re_trait::SubCapturesPosIter","re_bytes::NoExpand","re_unicode::NoExpand","dfa::Transitions","compile::InstHole","re_unicode::SubCaptureMatches","pikevm::Threads","exec::MatchNfaType","re_builder::RegexOptions","input::CharInput","sparse::SparseSet","prog::Program","backtrack::Cache","compile::SuffixCacheKey","re_bytes::CaptureLocations","prog::InstRanges","re_unicode::Match","prog::EmptyLook","error::Error","re_unicode::CaptureNames","literal::imp::Memmem","input::InputAt","prog::InstSave","re_set::unicode::SetMatchesIter","dfa::EmptyFlags","expand::CaptureRef","literal::imp::Matcher","exec::MatchType","input::ByteInput","exec::MatchLiteralType","re_bytes::Regex","re_bytes::Match","compile::SuffixCacheEntry","input::Char","re_set::bytes::SetMatchesIter","std::clone::impls::<impl std::clone::Clone for *mut T>","re_bytes::SubCaptureMatches"]},"dfa::Result":{"T":["prog::Program","re_unicode::Match","re_bytes::CaptureNames","expand::CaptureRef","re_unicode::CaptureLocations","input::Char","dfa::EmptyFlags","prog::Inst","dfa::State","literal::imp::LiteralSearcher","pikevm::FollowEpsilon","compile::SuffixCacheEntry","re_set::unicode::RegexSet","re_builder::RegexOptions","input::InputAt","dfa::Byte","prog::InstEmptyLook","sparse::SparseSet","exec::MatchLiteralType","pikevm::Threads","prog::InstBytes","re_bytes::SubCaptureMatches","<&T as std::fmt::Debug>","backtrack::Cache","expand::Ref","re_set::unicode::SetMatchesIter","re_trait::SubCapturesPosIter","re_unicode::Regex","exec::Exec","re_trait::Locations","dfa::Transitions","re_bytes::NoExpand","pikevm::Cache","prog::InstChar","exec::MatchNfaType","re_set::bytes::SetMatches","re_unicode::NoExpand","exec::MatchType","re_set::unicode::SetMatches","backtrack::Job","literal::imp::Memmem","dfa::StateFlags","re_unicode::CaptureNames","input::CharInput","re_unicode::SubCaptureMatches","prog::InstSave","prog::EmptyLook","re_set::bytes::RegexSet","prog::InstRanges","error::Error","literal::imp::SingleByteSet","compile::MaybeInst","literal::imp::Matcher","re_bytes::Match","compile::InstHole","input::ByteInput","compile::SuffixCacheKey","re_set::bytes::SetMatchesIter","re_bytes::CaptureLocations","prog::InstSplit","re_bytes::Regex","dfa::Result"]},"re_unicode::Replacer::replace_append":{"Self":["std::string::String","<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>","re_unicode::ReplacerRef","re_unicode::NoExpand","std::borrow::Cow"]},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::path::Path","std::ffi::CStr","std::ffi::OsStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+re_unicode::Replacer::replace_append(p0, p1, p2);
+crate::re_unicode::Replacer::replace_append(p0, p1, p2);
+crate::re_unicode::Replacer::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs re_unicode::Replacer::no_expansion
deps:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"re_unicode::Replacer::no_expansion":{"Self":["re_unicode::Replacer"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::IsWhitespace"]},"<T as std::borrow::ToOwned>":{"T":["pikevm::FollowEpsilon","prog::InstBytes","exec::MatchLiteralType","dfa::Byte","literal::imp::Memmem","re_builder::RegexOptions","compile::SuffixCacheEntry","compile::InstHole","prog::InstSplit","exec::Exec","re_bytes::Regex","re_trait::Locations","re_unicode::CaptureLocations","error::Error","prog::Inst","std::clone::impls::<impl std::clone::Clone for &mut T>","compile::SuffixCacheKey","sparse::SparseSet","input::InputAt","input::ByteInput","backtrack::Job","literal::imp::LiteralSearcher","re_unicode::SubCaptureMatches","exec::MatchType","dfa::Transitions","prog::Program","re_trait::SubCapturesPosIter","expand::Ref","prog::EmptyLook","prog::InstSave","re_set::bytes::SetMatches","re_set::bytes::SetMatchesIter","prog::InstChar","pikevm::Threads","dfa::EmptyFlags","re_bytes::NoExpand","compile::MaybeInst","expand::CaptureRef","re_bytes::CaptureNames","re_set::bytes::RegexSet","dfa::StateFlags","literal::imp::Matcher","exec::MatchNfaType","re_set::unicode::SetMatchesIter","input::Char","re_bytes::SubCaptureMatches","re_bytes::CaptureLocations","literal::imp::SingleByteSet","dfa::Result","re_unicode::Match","re_unicode::NoExpand","pikevm::Cache","re_bytes::Match","re_unicode::CaptureNames","re_set::unicode::SetMatches","re_unicode::Regex","prog::InstEmptyLook","re_set::unicode::RegexSet","backtrack::Cache","dfa::State","input::CharInput","prog::InstRanges"]},"dfa::Result":{"T":["re_set::unicode::SetMatches","re_bytes::CaptureLocations","dfa::State","pikevm::FollowEpsilon","input::ByteInput","re_set::bytes::SetMatchesIter","exec::MatchNfaType","dfa::Byte","prog::InstSave","prog::InstBytes","dfa::Transitions","re_unicode::SubCaptureMatches","re_unicode::CaptureNames","re_builder::RegexOptions","re_trait::Locations","dfa::Result","literal::imp::LiteralSearcher","re_bytes::Regex","sparse::SparseSet","input::CharInput","compile::SuffixCacheEntry","re_unicode::CaptureLocations","compile::MaybeInst","re_unicode::Regex","compile::InstHole","re_bytes::SubCaptureMatches","re_set::unicode::SetMatchesIter","re_unicode::Match","literal::imp::SingleByteSet","prog::EmptyLook","re_trait::SubCapturesPosIter","prog::InstRanges","dfa::StateFlags","<*mut T as std::fmt::Debug>","re_bytes::NoExpand","literal::imp::Memmem","exec::Exec","literal::imp::Matcher","prog::Inst","prog::InstSplit","re_set::unicode::RegexSet","re_set::bytes::RegexSet","input::InputAt","prog::Program","prog::InstChar","re_set::bytes::SetMatches","error::Error","re_bytes::Match","compile::SuffixCacheKey","pikevm::Cache","exec::MatchType","dfa::EmptyFlags","expand::Ref","backtrack::Job","re_unicode::NoExpand","backtrack::Cache","expand::CaptureRef","prog::InstEmptyLook","input::Char","pikevm::Threads","re_bytes::CaptureNames","exec::MatchLiteralType"]},"re_unicode::Replacer::no_expansion":{"Self":["std::string::String","<F as re_unicode::Replacer>","re_unicode::NoExpand","std::borrow::Cow","re_unicode::ReplacerRef"]},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::path::Path","std::ffi::CStr","std::ffi::OsStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.no_expansion();
+re_unicode::Replacer::no_expansion(p0);
+crate::re_unicode::Replacer::no_expansion(p0);
+crate::re_unicode::Replacer::no_expansion(p0);
-----------------
src/re_unicode.rs re_unicode::Replacer::by_ref
deps:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"re_unicode::Replacer::by_ref":{"Self":["re_unicode::Replacer"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::borrow::ToOwned>":{"T":["prog::InstRanges","backtrack::Job","re_builder::RegexOptions","dfa::EmptyFlags","compile::InstHole","re_bytes::SubCaptureMatches","re_unicode::NoExpand","dfa::Byte","exec::MatchType","re_set::bytes::SetMatchesIter","exec::Exec","pikevm::FollowEpsilon","prog::InstEmptyLook","re_set::unicode::SetMatches","std::clone::impls::<impl std::clone::Clone for &mut T>","literal::imp::Matcher","input::Char","prog::Inst","literal::imp::LiteralSearcher","compile::MaybeInst","compile::SuffixCacheEntry","dfa::Transitions","dfa::Result","exec::MatchNfaType","re_bytes::NoExpand","re_trait::Locations","prog::InstSplit","re_trait::SubCapturesPosIter","dfa::StateFlags","input::CharInput","re_set::bytes::SetMatches","re_unicode::SubCaptureMatches","prog::Program","re_set::unicode::SetMatchesIter","backtrack::Cache","prog::InstSave","re_unicode::CaptureLocations","re_unicode::Match","re_bytes::CaptureNames","input::InputAt","pikevm::Threads","expand::CaptureRef","compile::SuffixCacheKey","error::Error","sparse::SparseSet","literal::imp::Memmem","re_set::bytes::RegexSet","re_bytes::Regex","exec::MatchLiteralType","re_set::unicode::RegexSet","dfa::State","prog::InstChar","re_bytes::CaptureLocations","input::ByteInput","literal::imp::SingleByteSet","expand::Ref","re_unicode::Regex","re_bytes::Match","re_unicode::CaptureNames","prog::InstBytes","pikevm::Cache","prog::EmptyLook"]},"dfa::Result":{"T":["re_bytes::CaptureLocations","dfa::EmptyFlags","prog::EmptyLook","literal::imp::Matcher","dfa::StateFlags","re_bytes::CaptureNames","literal::imp::SingleByteSet","re_bytes::Regex","re_set::unicode::SetMatches","input::CharInput","re_bytes::Match","re_trait::Locations","dfa::Transitions","exec::MatchNfaType","expand::Ref","prog::InstEmptyLook","prog::InstChar","re_trait::SubCapturesPosIter","re_set::bytes::RegexSet","prog::InstSave","backtrack::Job","exec::MatchType","dfa::Byte","pikevm::Cache","compile::InstHole","backtrack::Cache","re_set::bytes::SetMatches","compile::SuffixCacheKey","re_builder::RegexOptions","compile::MaybeInst","re_unicode::CaptureLocations","literal::imp::LiteralSearcher","dfa::State","re_set::bytes::SetMatchesIter","prog::Program","re_unicode::Match","<&mut T as std::fmt::Debug>","input::ByteInput","prog::Inst","input::Char","pikevm::Threads","re_unicode::NoExpand","re_bytes::SubCaptureMatches","re_unicode::Regex","re_unicode::SubCaptureMatches","exec::MatchLiteralType","error::Error","re_set::unicode::RegexSet","literal::imp::Memmem","sparse::SparseSet","expand::CaptureRef","exec::Exec","prog::InstSplit","prog::InstBytes","re_bytes::NoExpand","re_set::unicode::SetMatchesIter","compile::SuffixCacheEntry","re_unicode::CaptureNames","input::InputAt","dfa::Result","prog::InstRanges","pikevm::FollowEpsilon"]},"re_unicode::Replacer::by_ref":{"Self":["<F as re_unicode::Replacer>","re_unicode::ReplacerRef","std::string::String","std::borrow::Cow","re_unicode::NoExpand"]},"std::borrow::Cow":{"B":["std::ffi::CStr","std::path::Path","std::ffi::OsStr","<T as std::borrow::ToOwned>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.by_ref();
+re_unicode::Replacer::by_ref(p0);
+crate::re_unicode::Replacer::by_ref(p0);
+crate::re_unicode::Replacer::by_ref(p0);
-----------------
src/backtrack.rs <backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt
'a,'m,'r,'s
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"backtrack::Bounded":{"I":["input::Input","std::marker::Sized","std::fmt::Debug"]},"dfa::Result":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"pikevm::Fsm":{"I":["std::marker::Sized","input::Input","std::fmt::Debug"]},"pool::Pool":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"pool::PoolGuard":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]},"re_trait::Matches":{"R":["std::fmt::Debug","re_trait::RegularExpression","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt":{"I":["prog::InstEmptyLook","dfa::StateFlags","prog::InstSave","dfa::State","re_set::bytes::SetMatchesIntoIter","re_bytes::SubCaptureMatches","compile::SuffixCacheEntry","re_builder::unicode::RegexBuilder","input::CharInput","re_set::unicode::SetMatchesIter","compile::InstHole","re_unicode::Match","exec::MatchType","<*const T as std::fmt::Debug>","compile::SuffixCache","re_unicode::CaptureMatches","prog::Inst","re_set::unicode::SetMatches","re_set::bytes::SetMatchesIter","re_bytes::Regex","re_bytes::SplitN","pool::PoolGuard","exec::Exec","dfa::EmptyFlags","expand::Ref","error::Error","literal::imp::LiteralIter","re_set::bytes::SetMatches","re_builder::set_unicode::RegexSetBuilder","re_bytes::Matches","compile::Patch","re_unicode::Regex","prog::InstBytes","re_bytes::CapturesDebug","re_unicode::Split","input::Char","backtrack::Job","re_unicode::Captures","compile::MaybeInst","dfa::Result","prog::InstSplit","exec::ExecNoSyncStr","literal::imp::Matcher","dfa::TransitionsRow","re_set::bytes::RegexSet","exec::MatchNfaType","pikevm::FollowEpsilon","dfa::Fsm","re_trait::Locations","pikevm::Threads","re_builder::bytes::RegexBuilder","re_bytes::ReplacerRef","literal::imp::LiteralSearcher","exec::ExecReadOnly","exec::ExecNoSync","expand::CaptureRef","pikevm::Cache","re_builder::set_bytes::RegexSetBuilder","compile::ByteClassSet","re_unicode::NoExpand","pikevm::Fsm","compile::SuffixCacheKey","input::InputAt","re_unicode::Matches","re_builder::RegexOptions","dfa::Cache","re_bytes::Captures","prog::Program","prog::EmptyLook","dfa::CacheInner","exec::ProgramCacheInner","re_unicode::CaptureNames","re_trait::SubCapturesPosIter","re_bytes::CaptureMatches","exec::MatchLiteralType","backtrack::Cache","re_bytes::CaptureLocations","literal::imp::SingleByteSet","input::ByteInput","sparse::SparseSet","literal::imp::Memmem","prog::InstRanges","backtrack::Bounded","dfa::StateMap","re_unicode::CaptureLocations","re_trait::CaptureMatches","<&T as std::fmt::Debug>","re_set::unicode::SetMatchesIntoIter","re_bytes::NoExpand","dfa::Byte","re_set::unicode::RegexSet","re_unicode::SplitN","pool::Pool","re_bytes::Split","re_unicode::SubCaptureMatches","prog::InstChar","re_unicode::ReplacerRef","compile::Hole","dfa::Transitions","re_trait::Matches","re_unicode::CapturesDebug","re_bytes::CaptureNames","re_bytes::Match"]},"backtrack::Bounded":{"I":["input::CharInput","input::ByteInput"]},"dfa::Result":{"T":["re_unicode::NoExpand","pikevm::FollowEpsilon","exec::MatchNfaType","re_bytes::Regex","prog::EmptyLook","dfa::Byte","dfa::Transitions","input::ByteInput","pikevm::Threads","re_bytes::CaptureNames","backtrack::Job","compile::SuffixCacheEntry","literal::imp::LiteralSearcher","re_set::unicode::RegexSet","re_set::unicode::SetMatchesIter","re_unicode::CaptureNames","compile::MaybeInst","expand::CaptureRef","literal::imp::Matcher","re_set::bytes::SetMatchesIter","input::CharInput","prog::InstRanges","re_unicode::Regex","re_bytes::CaptureLocations","re_bytes::SubCaptureMatches","prog::Program","sparse::SparseSet","prog::InstChar","literal::imp::Memmem","dfa::StateFlags","<&T as std::fmt::Debug>","exec::Exec","literal::imp::SingleByteSet","re_builder::RegexOptions","input::InputAt","prog::InstSplit","prog::Inst","pikevm::Cache","dfa::Result","prog::InstSave","re_bytes::NoExpand","prog::InstBytes","prog::InstEmptyLook","re_bytes::Match","re_trait::Locations","dfa::EmptyFlags","re_set::unicode::SetMatches","compile::InstHole","re_set::bytes::SetMatches","re_trait::SubCapturesPosIter","compile::SuffixCacheKey","re_unicode::Match","error::Error","re_set::bytes::RegexSet","backtrack::Cache","dfa::State","expand::Ref","exec::MatchLiteralType","re_unicode::CaptureLocations","exec::MatchType","input::Char","re_unicode::SubCaptureMatches"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"pool::Pool":{"T":["std::sync::OnceLock<T>","std::sync::MutexGuard<'_, T>","std::sync::mpsc::Sender<T>","std::sync::RwLockWriteGuard<'_, T>","std::sys::unix::args::Args","std::boxed::ThinBox<T>","std::io::IoSlice<'a>","std::collections::vec_deque::Drain<'_, T, A>","std::env::Args","std::io::IoSliceMut<'a>","std::collections::linked_list::Cursor<'_, T>","std::vec::IntoIter<T, A>","std::sync::atomic::AtomicPtr<T>","std::rc::Rc<T>","std::cell::RefCell<T>","std::rc::Weak<T>","std::future::ResumeTy","std::string::Drain<'_>","std::sync::Weak<T>","std::sync::mpmc::Receiver<T>","std::sync::mpmc::Sender<T>","std::slice::Iter<'_, T>","std::sync::RwLockReadGuard<'_, T>","std::sync::mpsc::Receiver<T>","std::ptr::DynMetadata<Dyn>","std::sync::Mutex<T>","std::io::error::repr_bitpacked::Repr","std::ptr::Unique<T>","std::collections::linked_list::IterMut<'_, T>","std::slice::IterMut<'_, T>","std::thread::JoinHandle<T>","std::ptr::NonNull<T>","std::cell::Cell<T>","std::collections::LinkedList<T>","std::sync::mpsc::SyncSender<T>","std::env::ArgsOs","std::collections::linked_list::Iter<'_, T>","std::collections::linked_list::CursorMut<'_, T>","std::vec::Drain<'_, T, A>","<*const T as std::marker::Send>","std::sync::RwLock<T>","std::task::Waker","std::sync::Arc<T>"]},"pool::PoolGuard":{"T":["std::io::IoSlice<'a>","std::sync::mpsc::Sender<T>","std::sync::mpsc::SyncSender<T>","std::sync::OnceLock<T>","std::ptr::Unique<T>","std::sync::RwLockReadGuard<'_, T>","std::sync::RwLockWriteGuard<'_, T>","std::ptr::NonNull<T>","std::env::ArgsOs","std::string::Drain<'_>","std::collections::linked_list::Iter<'_, T>","std::sync::RwLock<T>","std::ptr::DynMetadata<Dyn>","std::collections::linked_list::IterMut<'_, T>","std::vec::IntoIter<T, A>","std::rc::Weak<T>","std::sync::MutexGuard<'_, T>","std::sync::mpsc::Receiver<T>","std::slice::IterMut<'_, T>","std::sys::unix::args::Args","std::sync::Mutex<T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::Arc<T>","std::collections::LinkedList<T>","std::io::IoSliceMut<'a>","std::cell::Cell<T>","std::thread::JoinHandle<T>","std::collections::vec_deque::Drain<'_, T, A>","<*mut T as std::marker::Send>","std::vec::Drain<'_, T, A>","std::task::Waker","std::sync::Weak<T>","std::sync::atomic::AtomicPtr<T>","std::slice::Iter<'_, T>","std::sync::mpmc::Receiver<T>","std::rc::Rc<T>","std::cell::RefCell<T>","std::sync::mpmc::Sender<T>","std::future::ResumeTy","std::env::Args","std::collections::linked_list::Cursor<'_, T>","std::io::error::repr_bitpacked::Repr","std::boxed::ThinBox<T>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt(p0, p1);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::fmt(p0, p1);
-----------------
src/backtrack.rs <backtrack::Cache as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Cache
+p0.clone();
+<backtrack::Cache as std::clone::Clone>::clone(p0);
+crate::<backtrack::Cache as std::clone::Clone>::clone(p0);
+<backtrack::Cache>::clone(p0);
-----------------
src/backtrack.rs <backtrack::Cache as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Cache
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<backtrack::Cache as std::fmt::Debug>::fmt(p0, p1);
+crate::<backtrack::Cache as std::fmt::Debug>::fmt(p0, p1);
+<backtrack::Cache>::fmt(p0, p1);
-----------------
src/backtrack.rs backtrack::Cache::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+backtrack::Cache::new(p0);
+crate::backtrack::Cache::new(p0);
+<backtrack::Cache>::new(p0);
-----------------
src/backtrack.rs <backtrack::Job as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Job
+p0.clone();
+<backtrack::Job as std::clone::Clone>::clone(p0);
+crate::<backtrack::Job as std::clone::Clone>::clone(p0);
+<backtrack::Job>::clone(p0);
-----------------
src/backtrack.rs <backtrack::Job as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Job
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<backtrack::Job as std::fmt::Debug>::fmt(p0, p1);
+crate::<backtrack::Job as std::fmt::Debug>::fmt(p0, p1);
+<backtrack::Job>::fmt(p0, p1);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec":{"I":["input::ByteInput","input::CharInput","<&'a T as input::Input>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::panic::AssertUnwindSafe<std::cell::RefCell<exec::ProgramCacheInner>>
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p4 = MaybeUninit::uninit().assume_init(); // I
let mut p5 = 0usize; // None+usize
let mut p6 = 0usize; // None+usize
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec(p0, p1, p2, p3, p4, p5, p6);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec(p0, p1, p2, p3, p4, p5, p6);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::exec(p0, p1, p2, p3, p4, p5, p6);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear":{"I":["input::CharInput","<&'a T as input::Input>","input::ByteInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
+p0.clear();
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear(p0);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear(p0);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::clear(p0);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_":{"I":["input::CharInput","<&'a T as input::Input>","input::ByteInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = 0usize; // None+usize
+p0.exec_(p1, p2);
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_(p0, p1, p2);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_(p0, p1, p2);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::exec_(p0, p1, p2);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack":{"I":["input::ByteInput","input::CharInput","<&'a T as input::Input>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.backtrack(p1);
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack(p0, p1);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack(p0, p1);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::backtrack(p0, p1);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::step
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::step":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::step":{"I":["<&'a T as input::Input>","input::CharInput","input::ByteInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.step(p1, p2);
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::step(p0, p1, p2);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::step(p0, p1, p2);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::step(p0, p1, p2);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited":{"I":["input::CharInput","<&'a T as input::Input>","input::ByteInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.has_visited(p1, p2);
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited(p0, p1, p2);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited(p0, p1, p2);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::has_visited(p0, p1, p2);
-----------------
src/compile.rs <compile::Patch as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::Patch
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::Patch as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::Patch as std::fmt::Debug>::fmt(p0, p1);
+<compile::Patch>::fmt(p0, p1);
-----------------
src/compile.rs compile::Compiler::new
deps:{}
candidates:{}
+compile::Compiler::new();
+crate::compile::Compiler::new();
+<compile::Compiler>::new();
-----------------
src/compile.rs compile::Compiler::size_limit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+compile::Compiler::size_limit(p0, p1);
+crate::compile::Compiler::size_limit(p0, p1);
+<compile::Compiler>::size_limit(p0, p1);
-----------------
src/compile.rs compile::Compiler::bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = true; // None+bool
+p0.bytes(p1);
+compile::Compiler::bytes(p0, p1);
+crate::compile::Compiler::bytes(p0, p1);
+<compile::Compiler>::bytes(p0, p1);
-----------------
src/compile.rs compile::Compiler::only_utf8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = true; // None+bool
+p0.only_utf8(p1);
+compile::Compiler::only_utf8(p0, p1);
+crate::compile::Compiler::only_utf8(p0, p1);
+<compile::Compiler>::only_utf8(p0, p1);
-----------------
src/compile.rs compile::Compiler::dfa
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = true; // None+bool
+p0.dfa(p1);
+compile::Compiler::dfa(p0, p1);
+crate::compile::Compiler::dfa(p0, p1);
+<compile::Compiler>::dfa(p0, p1);
-----------------
src/compile.rs compile::Compiler::reverse
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = true; // None+bool
+p0.reverse(p1);
+compile::Compiler::reverse(p0, p1);
+crate::compile::Compiler::reverse(p0, p1);
+<compile::Compiler>::reverse(p0, p1);
-----------------
src/compile.rs compile::Compiler::compile
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [regex_syntax::hir::Hir]
+p0.compile(p1);
+compile::Compiler::compile(p0, p1);
+crate::compile::Compiler::compile(p0, p1);
+<compile::Compiler>::compile(p0, p1);
-----------------
src/compile.rs compile::Compiler::compile_one
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
+p0.compile_one(p1);
+compile::Compiler::compile_one(p0, p1);
+crate::compile::Compiler::compile_one(p0, p1);
+<compile::Compiler>::compile_one(p0, p1);
-----------------
src/compile.rs compile::Compiler::compile_many
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [regex_syntax::hir::Hir]
+p0.compile_many(p1);
+compile::Compiler::compile_many(p0, p1);
+crate::compile::Compiler::compile_many(p0, p1);
+<compile::Compiler>::compile_many(p0, p1);
-----------------
src/compile.rs compile::Compiler::compile_finish
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.compile_finish();
+compile::Compiler::compile_finish(p0);
+crate::compile::Compiler::compile_finish(p0);
+<compile::Compiler>::compile_finish(p0);
-----------------
src/compile.rs compile::Compiler::c
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
+p0.c(p1);
+compile::Compiler::c(p0, p1);
+crate::compile::Compiler::c(p0, p1);
+<compile::Compiler>::c(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_empty
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.c_empty();
+compile::Compiler::c_empty(p0);
+crate::compile::Compiler::c_empty(p0);
+<compile::Compiler>::c_empty(p0);
-----------------
src/compile.rs compile::Compiler::c_capture
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = 0usize; // None+usize
let mut p2 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
+p0.c_capture(p1, p2);
+compile::Compiler::c_capture(p0, p1, p2);
+crate::compile::Compiler::c_capture(p0, p1, p2);
+<compile::Compiler>::c_capture(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::c_dotstar
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.c_dotstar();
+compile::Compiler::c_dotstar(p0);
+crate::compile::Compiler::c_dotstar(p0);
+<compile::Compiler>::c_dotstar(p0);
-----------------
src/compile.rs compile::Compiler::c_char
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = 'a'; // None+char
+p0.c_char(p1);
+compile::Compiler::c_char(p0, p1);
+crate::compile::Compiler::c_char(p0, p1);
+<compile::Compiler>::c_char(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [regex_syntax::hir::ClassUnicodeRange]
+p0.c_class(p1);
+compile::Compiler::c_class(p0, p1);
+crate::compile::Compiler::c_class(p0, p1);
+<compile::Compiler>::c_class(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_byte
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = 0u8; // None+u8
+p0.c_byte(p1);
+compile::Compiler::c_byte(p0, p1);
+crate::compile::Compiler::c_byte(p0, p1);
+<compile::Compiler>::c_byte(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_class_bytes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [regex_syntax::hir::ClassBytesRange]
+p0.c_class_bytes(p1);
+compile::Compiler::c_class_bytes(p0, p1);
+crate::compile::Compiler::c_class_bytes(p0, p1);
+<compile::Compiler>::c_class_bytes(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_empty_look
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // prog::EmptyLook
+p0.c_empty_look(p1);
+compile::Compiler::c_empty_look(p0, p1);
+crate::compile::Compiler::c_empty_look(p0, p1);
+<compile::Compiler>::c_empty_look(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_literal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.c_literal(p1);
+compile::Compiler::c_literal(p0, p1);
+crate::compile::Compiler::c_literal(p0, p1);
+<compile::Compiler>::c_literal(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_concat
'a
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"compile::Compiler::c_concat":{"I":["std::marker::Sized","std::iter::IntoIterator"]},"re_trait::CaptureMatches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["re_set::unicode::SetMatchesIntoIter","re_bytes::CaptureMatches","re_unicode::SplitN","re_set::bytes::SetMatchesIntoIter","literal::imp::LiteralIter","re_unicode::Split","<&mut I as std::iter::Iterator>","re_bytes::SplitN","re_unicode::CaptureNames","re_bytes::Split","re_bytes::CaptureNames","re_trait::Matches","re_unicode::CaptureMatches","re_set::bytes::SetMatchesIter","re_bytes::SubCaptureMatches","re_unicode::SubCaptureMatches","re_bytes::Matches","dfa::InstPtrs","re_trait::CaptureMatches","re_unicode::Matches","re_trait::SubCapturesPosIter","re_set::unicode::SetMatchesIter"]},"compile::Compiler::c_concat":{"I":["re_set::unicode::SetMatches","re_set::bytes::SetMatches","<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>","<I as std::iter::IntoIterator>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.c_concat(p1);
+compile::Compiler::c_concat(p0, p1);
+crate::compile::Compiler::c_concat(p0, p1);
+<compile::Compiler>::c_concat(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_alternate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [regex_syntax::hir::Hir]
+p0.c_alternate(p1);
+compile::Compiler::c_alternate(p0, p1);
+crate::compile::Compiler::c_alternate(p0, p1);
+<compile::Compiler>::c_alternate(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_repeat
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Repetition
+p0.c_repeat(p1);
+compile::Compiler::c_repeat(p0, p1);
+crate::compile::Compiler::c_repeat(p0, p1);
+<compile::Compiler>::c_repeat(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_repeat_zero_or_one
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
let mut p2 = true; // None+bool
+p0.c_repeat_zero_or_one(p1, p2);
+compile::Compiler::c_repeat_zero_or_one(p0, p1, p2);
+crate::compile::Compiler::c_repeat_zero_or_one(p0, p1, p2);
+<compile::Compiler>::c_repeat_zero_or_one(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::c_repeat_zero_or_more
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
let mut p2 = true; // None+bool
+p0.c_repeat_zero_or_more(p1, p2);
+compile::Compiler::c_repeat_zero_or_more(p0, p1, p2);
+crate::compile::Compiler::c_repeat_zero_or_more(p0, p1, p2);
+<compile::Compiler>::c_repeat_zero_or_more(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::c_repeat_one_or_more
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
let mut p2 = true; // None+bool
+p0.c_repeat_one_or_more(p1, p2);
+compile::Compiler::c_repeat_one_or_more(p0, p1, p2);
+crate::compile::Compiler::c_repeat_one_or_more(p0, p1, p2);
+<compile::Compiler>::c_repeat_one_or_more(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::c_repeat_range_min_or_more
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
let mut p2 = true; // None+bool
let mut p3 = 0u32; // None+u32
+p0.c_repeat_range_min_or_more(p1, p2, p3);
+compile::Compiler::c_repeat_range_min_or_more(p0, p1, p2, p3);
+crate::compile::Compiler::c_repeat_range_min_or_more(p0, p1, p2, p3);
+<compile::Compiler>::c_repeat_range_min_or_more(p0, p1, p2, p3);
-----------------
src/compile.rs compile::Compiler::c_repeat_range
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::Hir
let mut p2 = true; // None+bool
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.c_repeat_range(p1, p2, p3, p4);
+compile::Compiler::c_repeat_range(p0, p1, p2, p3, p4);
+crate::compile::Compiler::c_repeat_range(p0, p1, p2, p3, p4);
+<compile::Compiler>::c_repeat_range(p0, p1, p2, p3, p4);
-----------------
src/compile.rs compile::Compiler::next_inst
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.next_inst();
+compile::Compiler::next_inst(p0);
+crate::compile::Compiler::next_inst(p0);
+<compile::Compiler>::next_inst(p0);
-----------------
src/compile.rs compile::Compiler::fill
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::Hole
let mut p2 = 0usize; // None+usize
+p0.fill(p1, p2);
+compile::Compiler::fill(p0, p1, p2);
+crate::compile::Compiler::fill(p0, p1, p2);
+<compile::Compiler>::fill(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::fill_to_next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::Hole
+p0.fill_to_next(p1);
+compile::Compiler::fill_to_next(p0, p1);
+crate::compile::Compiler::fill_to_next(p0, p1);
+<compile::Compiler>::fill_to_next(p0, p1);
-----------------
src/compile.rs compile::Compiler::fill_split
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::Hole
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
let mut p3 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.fill_split(p1, p2, p3);
+compile::Compiler::fill_split(p0, p1, p2, p3);
+crate::compile::Compiler::fill_split(p0, p1, p2, p3);
+<compile::Compiler>::fill_split(p0, p1, p2, p3);
-----------------
src/compile.rs compile::Compiler::push_compiled
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // prog::Inst
+p0.push_compiled(p1);
+compile::Compiler::push_compiled(p0, p1);
+crate::compile::Compiler::push_compiled(p0, p1);
+<compile::Compiler>::push_compiled(p0, p1);
-----------------
src/compile.rs compile::Compiler::push_hole
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::InstHole
+p0.push_hole(p1);
+compile::Compiler::push_hole(p0, p1);
+crate::compile::Compiler::push_hole(p0, p1);
+<compile::Compiler>::push_hole(p0, p1);
-----------------
src/compile.rs compile::Compiler::push_split_hole
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.push_split_hole();
+compile::Compiler::push_split_hole(p0);
+crate::compile::Compiler::push_split_hole(p0);
+<compile::Compiler>::push_split_hole(p0);
-----------------
src/compile.rs compile::Compiler::pop_split_hole
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.pop_split_hole();
+compile::Compiler::pop_split_hole(p0);
+crate::compile::Compiler::pop_split_hole(p0);
+<compile::Compiler>::pop_split_hole(p0);
-----------------
src/compile.rs compile::Compiler::check_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.check_size();
+compile::Compiler::check_size(p0);
+crate::compile::Compiler::check_size(p0);
+<compile::Compiler>::check_size(p0);
-----------------
src/compile.rs <compile::Hole as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::Hole
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::Hole as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::Hole as std::fmt::Debug>::fmt(p0, p1);
+<compile::Hole>::fmt(p0, p1);
-----------------
src/compile.rs compile::Hole::dup_one
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Hole
+p0.dup_one();
+compile::Hole::dup_one(p0);
+crate::compile::Hole::dup_one(p0);
+<compile::Hole>::dup_one(p0);
-----------------
src/compile.rs <compile::MaybeInst as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::MaybeInst
+p0.clone();
+<compile::MaybeInst as std::clone::Clone>::clone(p0);
+crate::<compile::MaybeInst as std::clone::Clone>::clone(p0);
+<compile::MaybeInst>::clone(p0);
-----------------
src/compile.rs <compile::MaybeInst as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::MaybeInst as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::MaybeInst as std::fmt::Debug>::fmt(p0, p1);
+<compile::MaybeInst>::fmt(p0, p1);
-----------------
src/compile.rs compile::MaybeInst::fill
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = 0usize; // None+usize
+p0.fill(p1);
+compile::MaybeInst::fill(p0, p1);
+crate::compile::MaybeInst::fill(p0, p1);
+<compile::MaybeInst>::fill(p0, p1);
-----------------
src/compile.rs compile::MaybeInst::fill_split
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.fill_split(p1, p2);
+compile::MaybeInst::fill_split(p0, p1, p2);
+crate::compile::MaybeInst::fill_split(p0, p1, p2);
+<compile::MaybeInst>::fill_split(p0, p1, p2);
-----------------
src/compile.rs compile::MaybeInst::half_fill_split_goto1
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = 0usize; // None+usize
+p0.half_fill_split_goto1(p1);
+compile::MaybeInst::half_fill_split_goto1(p0, p1);
+crate::compile::MaybeInst::half_fill_split_goto1(p0, p1);
+<compile::MaybeInst>::half_fill_split_goto1(p0, p1);
-----------------
src/compile.rs compile::MaybeInst::half_fill_split_goto2
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = 0usize; // None+usize
+p0.half_fill_split_goto2(p1);
+compile::MaybeInst::half_fill_split_goto2(p0, p1);
+crate::compile::MaybeInst::half_fill_split_goto2(p0, p1);
+<compile::MaybeInst>::half_fill_split_goto2(p0, p1);
-----------------
src/compile.rs compile::MaybeInst::unwrap
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::MaybeInst
+p0.unwrap();
+compile::MaybeInst::unwrap(p0);
+crate::compile::MaybeInst::unwrap(p0);
+<compile::MaybeInst>::unwrap(p0);
-----------------
src/compile.rs <compile::InstHole as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::InstHole
+p0.clone();
+<compile::InstHole as std::clone::Clone>::clone(p0);
+crate::<compile::InstHole as std::clone::Clone>::clone(p0);
+<compile::InstHole>::clone(p0);
-----------------
src/compile.rs <compile::InstHole as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::InstHole
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::InstHole as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::InstHole as std::fmt::Debug>::fmt(p0, p1);
+<compile::InstHole>::fmt(p0, p1);
-----------------
src/compile.rs compile::InstHole::fill
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::InstHole
let mut p1 = 0usize; // None+usize
+p0.fill(p1);
+compile::InstHole::fill(p0, p1);
+crate::compile::InstHole::fill(p0, p1);
+<compile::InstHole>::fill(p0, p1);
-----------------
src/compile.rs compile::CompileClass::<'a, 'b>::compile
'a,'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::CompileClass<'a, 'b>
+p0.compile();
+compile::CompileClass::<'a, 'b>::compile(p0);
+crate::compile::CompileClass::<'a, 'b>::compile(p0);
+<compile::CompileClass<'a, 'b>>::compile(p0);
-----------------
src/compile.rs compile::CompileClass::<'a, 'b>::c_utf8_seq
'a,'b
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::CompileClass<'a, 'b>
let mut p1 = & MaybeUninit::uninit().assume_init(); // regex_syntax::utf8::Utf8Sequence
+p0.c_utf8_seq(p1);
+compile::CompileClass::<'a, 'b>::c_utf8_seq(p0, p1);
+crate::compile::CompileClass::<'a, 'b>::c_utf8_seq(p0, p1);
+<compile::CompileClass<'a, 'b>>::c_utf8_seq(p0, p1);
-----------------
src/compile.rs compile::CompileClass::<'a, 'b>::c_utf8_seq_
'a,'b,'r
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"compile::CompileClass::<'a, 'b>::c_utf8_seq_":{"I":["std::marker::Sized","std::iter::IntoIterator"]},"re_trait::CaptureMatches":{"R":["std::fmt::Debug","re_trait::RegularExpression","std::marker::Sized"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["re_bytes::CaptureNames","re_unicode::Split","re_unicode::CaptureNames","re_bytes::Split","re_unicode::SubCaptureMatches","literal::imp::LiteralIter","dfa::InstPtrs","re_set::unicode::SetMatchesIntoIter","re_trait::SubCapturesPosIter","re_bytes::Matches","re_trait::Matches","re_unicode::CaptureMatches","re_trait::CaptureMatches","<&mut I as std::iter::Iterator>","re_bytes::CaptureMatches","re_set::bytes::SetMatchesIntoIter","re_bytes::SubCaptureMatches","re_unicode::SplitN","re_unicode::Matches","re_set::unicode::SetMatchesIter","re_set::bytes::SetMatchesIter","re_bytes::SplitN"]},"compile::CompileClass::<'a, 'b>::c_utf8_seq_":{"I":["re_set::unicode::SetMatches","<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>","re_set::bytes::SetMatches"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::CompileClass<'a, 'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.c_utf8_seq_(p1);
+compile::CompileClass::<'a, 'b>::c_utf8_seq_(p0, p1);
+crate::compile::CompileClass::<'a, 'b>::c_utf8_seq_(p0, p1);
+<compile::CompileClass<'a, 'b>>::c_utf8_seq_(p0, p1);
-----------------
src/compile.rs <compile::SuffixCache as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCache
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::SuffixCache as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::SuffixCache as std::fmt::Debug>::fmt(p0, p1);
+<compile::SuffixCache>::fmt(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
+p0.clone();
+<compile::SuffixCacheEntry as std::clone::Clone>::clone(p0);
+crate::<compile::SuffixCacheEntry as std::clone::Clone>::clone(p0);
+<compile::SuffixCacheEntry>::clone(p0);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::SuffixCacheEntry as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::SuffixCacheEntry as std::fmt::Debug>::fmt(p0, p1);
+<compile::SuffixCacheEntry>::fmt(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::default::Default>::default
deps:{}
candidates:{}
+<compile::SuffixCacheEntry as std::default::Default>::default();
+crate::<compile::SuffixCacheEntry as std::default::Default>::default();
+<compile::SuffixCacheEntry>::default();
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
+p0.assert_receiver_is_total_eq();
+<compile::SuffixCacheEntry as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<compile::SuffixCacheEntry as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<compile::SuffixCacheEntry>::assert_receiver_is_total_eq(p0);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<compile::SuffixCacheEntry as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<compile::SuffixCacheEntry as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::hash::SipHasher","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<compile::SuffixCacheEntry as std::hash::Hash>::hash(p0, p1);
+crate::<compile::SuffixCacheEntry as std::hash::Hash>::hash(p0, p1);
+<compile::SuffixCacheEntry>::hash(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
let mut p1 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
+p0.eq(p1);
+<compile::SuffixCacheEntry as std::cmp::PartialEq>::eq(p0, p1);
+crate::<compile::SuffixCacheEntry as std::cmp::PartialEq>::eq(p0, p1);
+<compile::SuffixCacheEntry>::eq(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
+p0.clone();
+<compile::SuffixCacheKey as std::clone::Clone>::clone(p0);
+crate::<compile::SuffixCacheKey as std::clone::Clone>::clone(p0);
+<compile::SuffixCacheKey>::clone(p0);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::SuffixCacheKey as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::SuffixCacheKey as std::fmt::Debug>::fmt(p0, p1);
+<compile::SuffixCacheKey>::fmt(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::default::Default>::default
deps:{}
candidates:{}
+<compile::SuffixCacheKey as std::default::Default>::default();
+crate::<compile::SuffixCacheKey as std::default::Default>::default();
+<compile::SuffixCacheKey>::default();
-----------------
src/compile.rs <compile::SuffixCacheKey as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
+p0.assert_receiver_is_total_eq();
+<compile::SuffixCacheKey as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<compile::SuffixCacheKey as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<compile::SuffixCacheKey>::assert_receiver_is_total_eq(p0);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<compile::SuffixCacheKey as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<compile::SuffixCacheKey as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::hash::SipHasher","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<compile::SuffixCacheKey as std::hash::Hash>::hash(p0, p1);
+crate::<compile::SuffixCacheKey as std::hash::Hash>::hash(p0, p1);
+<compile::SuffixCacheKey>::hash(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
let mut p1 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
+p0.eq(p1);
+<compile::SuffixCacheKey as std::cmp::PartialEq>::eq(p0, p1);
+crate::<compile::SuffixCacheKey as std::cmp::PartialEq>::eq(p0, p1);
+<compile::SuffixCacheKey>::eq(p0, p1);
-----------------
src/compile.rs compile::SuffixCache::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+compile::SuffixCache::new(p0);
+crate::compile::SuffixCache::new(p0);
+<compile::SuffixCache>::new(p0);
-----------------
src/compile.rs compile::SuffixCache::get
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::SuffixCache
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
let mut p2 = 0usize; // None+usize
+p0.get(p1, p2);
+compile::SuffixCache::get(p0, p1, p2);
+crate::compile::SuffixCache::get(p0, p1, p2);
+<compile::SuffixCache>::get(p0, p1, p2);
-----------------
src/compile.rs compile::SuffixCache::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::SuffixCache
+p0.clear();
+compile::SuffixCache::clear(p0);
+crate::compile::SuffixCache::clear(p0);
+<compile::SuffixCache>::clear(p0);
-----------------
src/compile.rs compile::SuffixCache::hash
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCache
let mut p1 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
+p0.hash(p1);
+compile::SuffixCache::hash(p0, p1);
+crate::compile::SuffixCache::hash(p0, p1);
+<compile::SuffixCache>::hash(p0, p1);
-----------------
src/compile.rs compile::ByteClassSet::new
deps:{}
candidates:{}
+compile::ByteClassSet::new();
+crate::compile::ByteClassSet::new();
+<compile::ByteClassSet>::new();
-----------------
src/compile.rs compile::ByteClassSet::set_range
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::ByteClassSet
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
+p0.set_range(p1, p2);
+compile::ByteClassSet::set_range(p0, p1, p2);
+crate::compile::ByteClassSet::set_range(p0, p1, p2);
+<compile::ByteClassSet>::set_range(p0, p1, p2);
-----------------
src/compile.rs compile::ByteClassSet::set_word_boundary
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::ByteClassSet
+p0.set_word_boundary();
+compile::ByteClassSet::set_word_boundary(p0);
+crate::compile::ByteClassSet::set_word_boundary(p0);
+<compile::ByteClassSet>::set_word_boundary(p0);
-----------------
src/compile.rs compile::ByteClassSet::byte_classes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::ByteClassSet
+p0.byte_classes();
+compile::ByteClassSet::byte_classes(p0);
+crate::compile::ByteClassSet::byte_classes(p0);
+<compile::ByteClassSet>::byte_classes(p0);
-----------------
src/compile.rs <compile::ByteClassSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::ByteClassSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::ByteClassSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::ByteClassSet as std::fmt::Debug>::fmt(p0, p1);
+<compile::ByteClassSet>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::Cache as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Cache
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Cache as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Cache as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Cache>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::CacheInner as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::CacheInner
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::CacheInner as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::CacheInner as std::fmt::Debug>::fmt(p0, p1);
+<dfa::CacheInner>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::Transitions as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.clone();
+<dfa::Transitions as std::clone::Clone>::clone(p0);
+crate::<dfa::Transitions as std::clone::Clone>::clone(p0);
+<dfa::Transitions>::clone(p0);
-----------------
src/dfa.rs <dfa::Fsm<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Fsm<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Fsm<'a> as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Fsm<'a>>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::Result<T> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<dfa::Result<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<dfa::Result<T> as std::clone::Clone>::clone":{"T":["re_set::bytes::RegexSet","re_builder::RegexOptions","re_set::unicode::SetMatches","prog::Program","compile::InstHole","pikevm::Threads","re_set::unicode::RegexSet","re_set::bytes::SetMatches","re_bytes::NoExpand","prog::EmptyLook","exec::MatchType","re_bytes::Regex","error::Error","re_unicode::CaptureNames","re_unicode::SubCaptureMatches","prog::InstChar","re_bytes::CaptureLocations","re_unicode::CaptureLocations","pikevm::FollowEpsilon","re_trait::Locations","dfa::StateFlags","re_bytes::CaptureNames","prog::InstSave","prog::InstEmptyLook","prog::InstRanges","expand::Ref","re_unicode::NoExpand","expand::CaptureRef","sparse::SparseSet","dfa::Result","dfa::Transitions","exec::Exec","re_trait::SubCapturesPosIter","std::clone::impls::<impl std::clone::Clone for &mut T>","compile::SuffixCacheEntry","re_unicode::Match","input::Char","backtrack::Job","input::CharInput","re_bytes::SubCaptureMatches","backtrack::Cache","re_set::bytes::SetMatchesIter","input::InputAt","dfa::EmptyFlags","re_unicode::Regex","compile::SuffixCacheKey","literal::imp::SingleByteSet","literal::imp::LiteralSearcher","re_set::unicode::SetMatchesIter","literal::imp::Matcher","prog::Inst","prog::InstBytes","compile::MaybeInst","std::clone::impls::<impl std::clone::Clone for &T>","re_bytes::Match","literal::imp::Memmem","exec::MatchNfaType","dfa::State","input::ByteInput","pikevm::Cache","exec::MatchLiteralType","dfa::Byte","prog::InstSplit"]},"dfa::Result":{"T":["exec::MatchNfaType","exec::MatchLiteralType","prog::EmptyLook","compile::SuffixCacheKey","prog::Inst","input::Char","input::CharInput","dfa::Result","<&T as std::fmt::Debug>","re_trait::Locations","input::InputAt","re_unicode::Regex","prog::InstRanges","re_bytes::SubCaptureMatches","literal::imp::Memmem","compile::InstHole","re_set::bytes::SetMatches","re_unicode::CaptureNames","prog::InstChar","dfa::Byte","prog::InstSave","prog::InstBytes","re_set::unicode::SetMatches","backtrack::Cache","literal::imp::Matcher","literal::imp::LiteralSearcher","re_bytes::CaptureNames","input::ByteInput","re_set::unicode::SetMatchesIter","dfa::EmptyFlags","compile::MaybeInst","re_set::bytes::SetMatchesIter","dfa::State","compile::SuffixCacheEntry","pikevm::Threads","dfa::StateFlags","pikevm::FollowEpsilon","prog::InstEmptyLook","re_bytes::CaptureLocations","re_unicode::NoExpand","re_bytes::Match","sparse::SparseSet","re_unicode::CaptureLocations","expand::Ref","re_set::unicode::RegexSet","backtrack::Job","expand::CaptureRef","re_trait::SubCapturesPosIter","re_unicode::SubCaptureMatches","error::Error","prog::Program","literal::imp::SingleByteSet","prog::InstSplit","pikevm::Cache","exec::MatchType","dfa::Transitions","re_set::bytes::RegexSet","re_bytes::Regex","re_bytes::NoExpand","re_unicode::Match","re_builder::RegexOptions","exec::Exec"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Result<T>
+p0.clone();
+<dfa::Result<T> as std::clone::Clone>::clone(p0);
+crate::<dfa::Result<T> as std::clone::Clone>::clone(p0);
+<dfa::Result<T>>::clone(p0);
-----------------
src/dfa.rs <dfa::Result<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<dfa::Result<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"backtrack::Bounded":{"I":["std::fmt::Debug","input::Input","std::marker::Sized"]},"dfa::Result":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"pikevm::Fsm":{"I":["std::fmt::Debug","std::marker::Sized","input::Input"]},"pool::Pool":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"pool::PoolGuard":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<dfa::Result<T> as std::fmt::Debug>::fmt":{"T":["error::Error","<&mut T as std::fmt::Debug>","dfa::Transitions","re_unicode::SplitN","pikevm::Fsm","backtrack::Bounded","re_bytes::Captures","re_bytes::NoExpand","dfa::TransitionsRow","re_builder::bytes::RegexBuilder","input::Char","expand::Ref","re_unicode::Regex","dfa::State","pool::PoolGuard","backtrack::Cache","re_trait::Locations","re_set::unicode::SetMatchesIntoIter","re_set::unicode::SetMatchesIter","prog::InstEmptyLook","literal::imp::Matcher","re_bytes::ReplacerRef","re_bytes::Split","dfa::EmptyFlags","exec::MatchNfaType","re_unicode::ReplacerRef","re_bytes::CaptureNames","compile::Hole","exec::ExecReadOnly","prog::EmptyLook","compile::MaybeInst","re_set::bytes::RegexSet","re_builder::unicode::RegexBuilder","pikevm::Cache","re_unicode::Matches","input::ByteInput","re_bytes::CaptureLocations","literal::imp::LiteralSearcher","re_bytes::Regex","input::InputAt","dfa::CacheInner","compile::Patch","re_unicode::NoExpand","pool::Pool","compile::ByteClassSet","prog::InstSave","compile::SuffixCacheKey","re_unicode::CapturesDebug","compile::SuffixCacheEntry","<&T as std::fmt::Debug>","re_bytes::CaptureMatches","re_builder::set_bytes::RegexSetBuilder","exec::Exec","pikevm::FollowEpsilon","re_set::unicode::RegexSet","re_set::unicode::SetMatches","dfa::StateMap","re_bytes::Match","literal::imp::Memmem","re_builder::set_unicode::RegexSetBuilder","re_unicode::CaptureMatches","re_unicode::Match","prog::Program","exec::MatchType","re_unicode::SubCaptureMatches","re_trait::Matches","re_unicode::Split","prog::InstSplit","re_bytes::CapturesDebug","re_unicode::CaptureNames","prog::InstChar","exec::ProgramCacheInner","prog::Inst","expand::CaptureRef","compile::SuffixCache","re_unicode::CaptureLocations","backtrack::Job","literal::imp::SingleByteSet","re_bytes::SubCaptureMatches","prog::InstRanges","re_set::bytes::SetMatchesIter","compile::InstHole","re_trait::CaptureMatches","re_set::bytes::SetMatches","exec::MatchLiteralType","exec::ExecNoSyncStr","dfa::Byte","dfa::Result","re_bytes::Matches","prog::InstBytes","dfa::Fsm","dfa::Cache","re_set::bytes::SetMatchesIntoIter","dfa::StateFlags","re_trait::SubCapturesPosIter","sparse::SparseSet","re_builder::RegexOptions","exec::ExecNoSync","input::CharInput","literal::imp::LiteralIter","re_unicode::Captures","re_bytes::SplitN","pikevm::Threads"]},"backtrack::Bounded":{"I":["input::ByteInput","input::CharInput"]},"dfa::Result":{"T":["dfa::StateFlags","literal::imp::Memmem","prog::InstRanges","re_set::bytes::SetMatches","literal::imp::SingleByteSet","prog::InstEmptyLook","re_bytes::SubCaptureMatches","exec::MatchType","re_unicode::Regex","prog::Inst","re_trait::Locations","compile::MaybeInst","dfa::Transitions","re_unicode::CaptureNames","re_builder::RegexOptions","re_set::bytes::SetMatchesIter","prog::InstSplit","<&mut T as std::fmt::Debug>","prog::InstBytes","prog::EmptyLook","re_set::unicode::SetMatchesIter","re_unicode::Match","re_set::unicode::RegexSet","re_bytes::NoExpand","error::Error","expand::CaptureRef","literal::imp::Matcher","expand::Ref","exec::MatchNfaType","input::ByteInput","re_unicode::CaptureLocations","compile::SuffixCacheEntry","exec::Exec","pikevm::Threads","prog::Program","re_bytes::Regex","input::Char","exec::MatchLiteralType","re_set::unicode::SetMatches","re_bytes::Match","input::InputAt","dfa::Byte","prog::InstSave","re_set::bytes::RegexSet","dfa::Result","pikevm::FollowEpsilon","input::CharInput","compile::InstHole","backtrack::Job","re_bytes::CaptureLocations","sparse::SparseSet","literal::imp::LiteralSearcher","backtrack::Cache","dfa::State","pikevm::Cache","compile::SuffixCacheKey","re_unicode::SubCaptureMatches","re_bytes::CaptureNames","re_unicode::NoExpand","dfa::EmptyFlags","prog::InstChar","re_trait::SubCapturesPosIter"]},"pikevm::Fsm":{"I":["input::ByteInput","input::CharInput"]},"pool::Pool":{"T":["std::sync::RwLockWriteGuard<'_, T>","std::boxed::ThinBox<T>","std::io::IoSlice<'a>","std::collections::linked_list::Cursor<'_, T>","std::string::Drain<'_>","std::sys::unix::args::Args","std::collections::linked_list::Iter<'_, T>","std::sync::mpmc::Sender<T>","std::rc::Weak<T>","std::sync::Arc<T>","std::slice::IterMut<'_, T>","std::slice::Iter<'_, T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::Weak<T>","std::cell::RefCell<T>","std::sync::atomic::AtomicPtr<T>","std::sync::Mutex<T>","std::ptr::Unique<T>","std::sync::mpmc::Receiver<T>","std::future::ResumeTy","std::sync::mpsc::SyncSender<T>","std::cell::Cell<T>","std::task::Waker","std::sync::mpsc::Sender<T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::MutexGuard<'_, T>","std::vec::IntoIter<T, A>","std::sync::OnceLock<T>","std::vec::Drain<'_, T, A>","std::thread::JoinHandle<T>","std::ptr::DynMetadata<Dyn>","std::sync::RwLockReadGuard<'_, T>","std::collections::LinkedList<T>","std::rc::Rc<T>","std::ptr::NonNull<T>","std::env::ArgsOs","std::sync::RwLock<T>","<*mut T as std::fmt::Debug>","std::collections::linked_list::IterMut<'_, T>","std::io::error::repr_bitpacked::Repr","std::env::Args","std::io::IoSliceMut<'a>","std::sync::mpsc::Receiver<T>"]},"pool::PoolGuard":{"T":["std::collections::linked_list::IterMut<'_, T>","std::cell::Cell<T>","std::sync::MutexGuard<'_, T>","std::io::IoSliceMut<'a>","std::io::error::repr_bitpacked::Repr","std::future::ResumeTy","std::slice::Iter<'_, T>","std::ptr::Unique<T>","std::collections::linked_list::Iter<'_, T>","std::sync::RwLockReadGuard<'_, T>","<*mut T as std::marker::Send>","std::sync::mpmc::Receiver<T>","std::sync::atomic::AtomicPtr<T>","std::sync::Mutex<T>","std::boxed::ThinBox<T>","std::collections::vec_deque::Drain<'_, T, A>","std::vec::Drain<'_, T, A>","std::ptr::DynMetadata<Dyn>","std::sync::Arc<T>","std::collections::LinkedList<T>","std::sync::OnceLock<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::mpmc::Sender<T>","std::sync::Weak<T>","std::ptr::NonNull<T>","std::sync::RwLock<T>","<*const T as std::marker::Send>","std::cell::RefCell<T>","std::sync::RwLockWriteGuard<'_, T>","std::rc::Weak<T>","std::io::IoSlice<'a>","std::env::ArgsOs","std::collections::linked_list::CursorMut<'_, T>","std::sync::mpsc::Sender<T>","std::vec::IntoIter<T, A>","std::task::Waker","std::env::Args","std::sync::mpsc::Receiver<T>","std::rc::Rc<T>","std::slice::IterMut<'_, T>","std::thread::JoinHandle<T>","std::string::Drain<'_>","std::sync::mpsc::SyncSender<T>","std::sys::unix::args::Args"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Result<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Result<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Result<T> as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Result<T>>::fmt(p0, p1);
-----------------
src/dfa.rs dfa::Result::<T>::is_match
deps:{"dfa::Result::<T>::is_match":{"T":["std::marker::Sized"]}}
candidates:{"dfa::Result::<T>::is_match":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Result<T>
+p0.is_match();
+dfa::Result::<T>::is_match(p0);
+crate::dfa::Result::<T>::is_match(p0);
+<dfa::Result<T>>::is_match(p0);
-----------------
src/dfa.rs dfa::Result::<T>::map
deps:{"dfa::Result::<T>::map":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"dfa::Result::<T>::map":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // dfa::Result<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+dfa::Result::<T>::map(p0, p1);
+crate::dfa::Result::<T>::map(p0, p1);
+<dfa::Result<T>>::map(p0, p1);
-----------------
src/dfa.rs dfa::Result::<T>::set_non_match
deps:{"dfa::Result::<T>::set_non_match":{"T":["std::marker::Sized"]}}
candidates:{"dfa::Result::<T>::set_non_match":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // dfa::Result<T>
let mut p1 = 0usize; // None+usize
+p0.set_non_match(p1);
+dfa::Result::<T>::set_non_match(p0, p1);
+crate::dfa::Result::<T>::set_non_match(p0, p1);
+<dfa::Result<T>>::set_non_match(p0, p1);
-----------------
src/dfa.rs <dfa::State as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.clone();
+<dfa::State as std::clone::Clone>::clone(p0);
+crate::<dfa::State as std::clone::Clone>::clone(p0);
+<dfa::State>::clone(p0);
-----------------
src/dfa.rs <dfa::State as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.assert_receiver_is_total_eq();
+<dfa::State as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<dfa::State as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<dfa::State>::assert_receiver_is_total_eq(p0);
-----------------
src/dfa.rs <dfa::State as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<dfa::State as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<dfa::State as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<dfa::State as std::hash::Hash>::hash(p0, p1);
+crate::<dfa::State as std::hash::Hash>::hash(p0, p1);
+<dfa::State>::hash(p0, p1);
-----------------
src/dfa.rs <dfa::State as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
let mut p1 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.eq(p1);
+<dfa::State as std::cmp::PartialEq>::eq(p0, p1);
+crate::<dfa::State as std::cmp::PartialEq>::eq(p0, p1);
+<dfa::State>::eq(p0, p1);
-----------------
src/dfa.rs <dfa::InstPtrs<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::InstPtrs<'a>
+p0.next();
+<dfa::InstPtrs<'a> as std::iter::Iterator>::next(p0);
+crate::<dfa::InstPtrs<'a> as std::iter::Iterator>::next(p0);
+<dfa::InstPtrs<'a>>::next(p0);
-----------------
src/dfa.rs dfa::State::flags
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.flags();
+dfa::State::flags(p0);
+crate::dfa::State::flags(p0);
+<dfa::State>::flags(p0);
-----------------
src/dfa.rs dfa::State::inst_ptrs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.inst_ptrs();
+dfa::State::inst_ptrs(p0);
+crate::dfa::State::inst_ptrs(p0);
+<dfa::State>::inst_ptrs(p0);
-----------------
src/dfa.rs <dfa::Byte as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.clone();
+<dfa::Byte as std::clone::Clone>::clone(p0);
+crate::<dfa::Byte as std::clone::Clone>::clone(p0);
+<dfa::Byte>::clone(p0);
-----------------
src/dfa.rs <dfa::Byte as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Byte as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Byte as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Byte>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
+p0.clone();
+<dfa::EmptyFlags as std::clone::Clone>::clone(p0);
+crate::<dfa::EmptyFlags as std::clone::Clone>::clone(p0);
+<dfa::EmptyFlags>::clone(p0);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
+p0.assert_receiver_is_total_eq();
+<dfa::EmptyFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<dfa::EmptyFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<dfa::EmptyFlags>::assert_receiver_is_total_eq(p0);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::EmptyFlags as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::EmptyFlags as std::fmt::Debug>::fmt(p0, p1);
+<dfa::EmptyFlags>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::default::Default>::default
deps:{}
candidates:{}
+<dfa::EmptyFlags as std::default::Default>::default();
+crate::<dfa::EmptyFlags as std::default::Default>::default();
+<dfa::EmptyFlags>::default();
-----------------
src/dfa.rs <dfa::EmptyFlags as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<dfa::EmptyFlags as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<dfa::EmptyFlags as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<dfa::EmptyFlags as std::hash::Hash>::hash(p0, p1);
+crate::<dfa::EmptyFlags as std::hash::Hash>::hash(p0, p1);
+<dfa::EmptyFlags>::hash(p0, p1);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
let mut p1 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
+p0.eq(p1);
+<dfa::EmptyFlags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<dfa::EmptyFlags as std::cmp::PartialEq>::eq(p0, p1);
+<dfa::EmptyFlags>::eq(p0, p1);
-----------------
src/dfa.rs <dfa::StateFlags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.clone();
+<dfa::StateFlags as std::clone::Clone>::clone(p0);
+crate::<dfa::StateFlags as std::clone::Clone>::clone(p0);
+<dfa::StateFlags>::clone(p0);
-----------------
src/dfa.rs <dfa::StateFlags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.assert_receiver_is_total_eq();
+<dfa::StateFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<dfa::StateFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<dfa::StateFlags>::assert_receiver_is_total_eq(p0);
-----------------
src/dfa.rs <dfa::StateFlags as std::default::Default>::default
deps:{}
candidates:{}
+<dfa::StateFlags as std::default::Default>::default();
+crate::<dfa::StateFlags as std::default::Default>::default();
+<dfa::StateFlags>::default();
-----------------
src/dfa.rs <dfa::StateFlags as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<dfa::StateFlags as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<dfa::StateFlags as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<dfa::StateFlags as std::hash::Hash>::hash(p0, p1);
+crate::<dfa::StateFlags as std::hash::Hash>::hash(p0, p1);
+<dfa::StateFlags>::hash(p0, p1);
-----------------
src/dfa.rs <dfa::StateFlags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
let mut p1 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.eq(p1);
+<dfa::StateFlags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<dfa::StateFlags as std::cmp::PartialEq>::eq(p0, p1);
+<dfa::StateFlags>::eq(p0, p1);
-----------------
src/dfa.rs dfa::Cache::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+dfa::Cache::new(p0);
+crate::dfa::Cache::new(p0);
+<dfa::Cache>::new(p0);
-----------------
src/dfa.rs dfa::CacheInner::reset_size
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::CacheInner
+p0.reset_size();
+dfa::CacheInner::reset_size(p0);
+crate::dfa::CacheInner::reset_size(p0);
+<dfa::CacheInner>::reset_size(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::forward
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::panic::AssertUnwindSafe<std::cell::RefCell<exec::ProgramCacheInner>>
let mut p2 = true; // None+bool
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
+dfa::Fsm::<'a>::forward(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::forward(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::forward(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::reverse
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::panic::AssertUnwindSafe<std::cell::RefCell<exec::ProgramCacheInner>>
let mut p2 = true; // None+bool
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
+dfa::Fsm::<'a>::reverse(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::reverse(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::reverse(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::forward_many
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::panic::AssertUnwindSafe<std::cell::RefCell<exec::ProgramCacheInner>>
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
+dfa::Fsm::<'a>::forward_many(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::forward_many(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::forward_many(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::exec_at
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.exec_at(p1, p2, p3);
+dfa::Fsm::<'a>::exec_at(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::exec_at(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::exec_at(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::exec_at_reverse
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.exec_at_reverse(p1, p2, p3);
+dfa::Fsm::<'a>::exec_at_reverse(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::exec_at_reverse(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::exec_at_reverse(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::next_si
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u32; // None+u32
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.next_si(p1, p2, p3);
+dfa::Fsm::<'a>::next_si(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::next_si(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::next_si(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::exec_byte
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = 0u32; // None+u32
let mut p4 = MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.exec_byte(p1, p2, p3, p4);
+dfa::Fsm::<'a>::exec_byte(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::exec_byte(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::exec_byte(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::follow_epsilons
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u32; // None+u32
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
+p0.follow_epsilons(p1, p2, p3);
+dfa::Fsm::<'a>::follow_epsilons(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::follow_epsilons(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::follow_epsilons(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::cached_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = MaybeUninit::uninit().assume_init(); // dfa::StateFlags
let mut p3 = MaybeUninit::uninit().assume_init(); // std::option::Option<&mut u32>
+p0.cached_state(p1, p2, p3);
+dfa::Fsm::<'a>::cached_state(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::cached_state(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::cached_state(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::cached_state_key
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.cached_state_key(p1, p2);
+dfa::Fsm::<'a>::cached_state_key(p0, p1, p2);
+crate::dfa::Fsm::<'a>::cached_state_key(p0, p1, p2);
+<dfa::Fsm<'a>>::cached_state_key(p0, p1, p2);
-----------------
src/dfa.rs dfa::Fsm::<'a>::clear_cache_and_save
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&mut u32>
+p0.clear_cache_and_save(p1);
+dfa::Fsm::<'a>::clear_cache_and_save(p0, p1);
+crate::dfa::Fsm::<'a>::clear_cache_and_save(p0, p1);
+<dfa::Fsm<'a>>::clear_cache_and_save(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::clear_cache
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.clear_cache();
+dfa::Fsm::<'a>::clear_cache(p0);
+crate::dfa::Fsm::<'a>::clear_cache(p0);
+<dfa::Fsm<'a>>::clear_cache(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::restore_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // dfa::State
+p0.restore_state(p1);
+dfa::Fsm::<'a>::restore_state(p0, p1);
+crate::dfa::Fsm::<'a>::restore_state(p0, p1);
+<dfa::Fsm<'a>>::restore_state(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::next_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = 0u32; // None+u32
let mut p4 = MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.next_state(p1, p2, p3, p4);
+dfa::Fsm::<'a>::next_state(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::next_state(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::next_state(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::start_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
let mut p3 = MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.start_state(p1, p2, p3);
+dfa::Fsm::<'a>::start_state(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::start_state(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::start_state(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::start_flags
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.start_flags(p1, p2);
+dfa::Fsm::<'a>::start_flags(p0, p1, p2);
+crate::dfa::Fsm::<'a>::start_flags(p0, p1, p2);
+<dfa::Fsm<'a>>::start_flags(p0, p1, p2);
-----------------
src/dfa.rs dfa::Fsm::<'a>::start_flags_reverse
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.start_flags_reverse(p1, p2);
+dfa::Fsm::<'a>::start_flags_reverse(p0, p1, p2);
+crate::dfa::Fsm::<'a>::start_flags_reverse(p0, p1, p2);
+<dfa::Fsm<'a>>::start_flags_reverse(p0, p1, p2);
-----------------
src/dfa.rs dfa::Fsm::<'a>::state
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u32; // None+u32
+p0.state(p1);
+dfa::Fsm::<'a>::state(p0, p1);
+crate::dfa::Fsm::<'a>::state(p0, p1);
+<dfa::Fsm<'a>>::state(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::add_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // dfa::State
+p0.add_state(p1);
+dfa::Fsm::<'a>::add_state(p0, p1);
+crate::dfa::Fsm::<'a>::add_state(p0, p1);
+<dfa::Fsm<'a>>::add_state(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::prefix_at
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.prefix_at(p1, p2);
+dfa::Fsm::<'a>::prefix_at(p0, p1, p2);
+crate::dfa::Fsm::<'a>::prefix_at(p0, p1, p2);
+<dfa::Fsm<'a>>::prefix_at(p0, p1, p2);
-----------------
src/dfa.rs dfa::Fsm::<'a>::num_byte_classes
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.num_byte_classes();
+dfa::Fsm::<'a>::num_byte_classes(p0);
+crate::dfa::Fsm::<'a>::num_byte_classes(p0);
+<dfa::Fsm<'a>>::num_byte_classes(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::byte_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.byte_class(p1);
+dfa::Fsm::<'a>::byte_class(p0, p1);
+crate::dfa::Fsm::<'a>::byte_class(p0, p1);
+<dfa::Fsm<'a>>::byte_class(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::u8_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u8; // None+u8
+p0.u8_class(p1);
+dfa::Fsm::<'a>::u8_class(p0, p1);
+crate::dfa::Fsm::<'a>::u8_class(p0, p1);
+<dfa::Fsm<'a>>::u8_class(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::continue_past_first_match
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.continue_past_first_match();
+dfa::Fsm::<'a>::continue_past_first_match(p0);
+crate::dfa::Fsm::<'a>::continue_past_first_match(p0);
+<dfa::Fsm<'a>>::continue_past_first_match(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::has_prefix
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.has_prefix();
+dfa::Fsm::<'a>::has_prefix(p0);
+crate::dfa::Fsm::<'a>::has_prefix(p0);
+<dfa::Fsm<'a>>::has_prefix(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::start_ptr
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u32; // None+u32
+p0.start_ptr(p1);
+dfa::Fsm::<'a>::start_ptr(p0, p1);
+crate::dfa::Fsm::<'a>::start_ptr(p0, p1);
+<dfa::Fsm<'a>>::start_ptr(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::approximate_size
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.approximate_size();
+dfa::Fsm::<'a>::approximate_size(p0);
+crate::dfa::Fsm::<'a>::approximate_size(p0);
+<dfa::Fsm<'a>>::approximate_size(p0);
-----------------
src/dfa.rs <dfa::StateMap as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::StateMap as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::StateMap as std::fmt::Debug>::fmt(p0, p1);
+<dfa::StateMap>::fmt(p0, p1);
-----------------
src/dfa.rs dfa::StateMap::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+dfa::StateMap::new(p0);
+crate::dfa::StateMap::new(p0);
+<dfa::StateMap>::new(p0);
-----------------
src/dfa.rs dfa::StateMap::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
+p0.len();
+dfa::StateMap::len(p0);
+crate::dfa::StateMap::len(p0);
+<dfa::StateMap>::len(p0);
-----------------
src/dfa.rs dfa::StateMap::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
+p0.is_empty();
+dfa::StateMap::is_empty(p0);
+crate::dfa::StateMap::is_empty(p0);
+<dfa::StateMap>::is_empty(p0);
-----------------
src/dfa.rs dfa::StateMap::get_ptr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.get_ptr(p1);
+dfa::StateMap::get_ptr(p0, p1);
+crate::dfa::StateMap::get_ptr(p0, p1);
+<dfa::StateMap>::get_ptr(p0, p1);
-----------------
src/dfa.rs dfa::StateMap::get_state
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
let mut p1 = 0u32; // None+u32
+p0.get_state(p1);
+dfa::StateMap::get_state(p0, p1);
+crate::dfa::StateMap::get_state(p0, p1);
+<dfa::StateMap>::get_state(p0, p1);
-----------------
src/dfa.rs dfa::StateMap::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateMap
let mut p1 = MaybeUninit::uninit().assume_init(); // dfa::State
let mut p2 = 0u32; // None+u32
+p0.insert(p1, p2);
+dfa::StateMap::insert(p0, p1, p2);
+crate::dfa::StateMap::insert(p0, p1, p2);
+<dfa::StateMap>::insert(p0, p1, p2);
-----------------
src/dfa.rs dfa::StateMap::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateMap
+p0.clear();
+dfa::StateMap::clear(p0);
+crate::dfa::StateMap::clear(p0);
+<dfa::StateMap>::clear(p0);
-----------------
src/dfa.rs dfa::Transitions::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+dfa::Transitions::new(p0);
+crate::dfa::Transitions::new(p0);
+<dfa::Transitions>::new(p0);
-----------------
src/dfa.rs dfa::Transitions::num_states
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.num_states();
+dfa::Transitions::num_states(p0);
+crate::dfa::Transitions::num_states(p0);
+<dfa::Transitions>::num_states(p0);
-----------------
src/dfa.rs dfa::Transitions::add
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.add();
+dfa::Transitions::add(p0);
+crate::dfa::Transitions::add(p0);
+<dfa::Transitions>::add(p0);
-----------------
src/dfa.rs dfa::Transitions::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.clear();
+dfa::Transitions::clear(p0);
+crate::dfa::Transitions::clear(p0);
+<dfa::Transitions>::clear(p0);
-----------------
src/dfa.rs dfa::Transitions::set_next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Transitions
let mut p1 = 0u32; // None+u32
let mut p2 = 0usize; // None+usize
let mut p3 = 0u32; // None+u32
+p0.set_next(p1, p2, p3);
+dfa::Transitions::set_next(p0, p1, p2, p3);
+crate::dfa::Transitions::set_next(p0, p1, p2, p3);
+<dfa::Transitions>::set_next(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Transitions::next
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
let mut p1 = 0u32; // None+u32
let mut p2 = 0usize; // None+usize
+p0.next(p1, p2);
+dfa::Transitions::next(p0, p1, p2);
+crate::dfa::Transitions::next(p0, p1, p2);
+<dfa::Transitions>::next(p0, p1, p2);
-----------------
src/dfa.rs dfa::Transitions::state_heap_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.state_heap_size();
+dfa::Transitions::state_heap_size(p0);
+crate::dfa::Transitions::state_heap_size(p0);
+<dfa::Transitions>::state_heap_size(p0);
-----------------
src/dfa.rs dfa::Transitions::next_unchecked
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
let mut p1 = 0u32; // None+u32
let mut p2 = 0usize; // None+usize
+p0.next_unchecked(p1, p2);
+dfa::Transitions::next_unchecked(p0, p1, p2);
+crate::dfa::Transitions::next_unchecked(p0, p1, p2);
+<dfa::Transitions>::next_unchecked(p0, p1, p2);
-----------------
src/dfa.rs dfa::StateFlags::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.is_match();
+dfa::StateFlags::is_match(p0);
+crate::dfa::StateFlags::is_match(p0);
+<dfa::StateFlags>::is_match(p0);
-----------------
src/dfa.rs dfa::StateFlags::set_match
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.set_match();
+dfa::StateFlags::set_match(p0);
+crate::dfa::StateFlags::set_match(p0);
+<dfa::StateFlags>::set_match(p0);
-----------------
src/dfa.rs dfa::StateFlags::is_word
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.is_word();
+dfa::StateFlags::is_word(p0);
+crate::dfa::StateFlags::is_word(p0);
+<dfa::StateFlags>::is_word(p0);
-----------------
src/dfa.rs dfa::StateFlags::set_word
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.set_word();
+dfa::StateFlags::set_word(p0);
+crate::dfa::StateFlags::set_word(p0);
+<dfa::StateFlags>::set_word(p0);
-----------------
src/dfa.rs dfa::StateFlags::has_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.has_empty();
+dfa::StateFlags::has_empty(p0);
+crate::dfa::StateFlags::has_empty(p0);
+<dfa::StateFlags>::has_empty(p0);
-----------------
src/dfa.rs dfa::StateFlags::set_empty
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.set_empty();
+dfa::StateFlags::set_empty(p0);
+crate::dfa::StateFlags::set_empty(p0);
+<dfa::StateFlags>::set_empty(p0);
-----------------
src/dfa.rs dfa::Byte::byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+dfa::Byte::byte(p0);
+crate::dfa::Byte::byte(p0);
+<dfa::Byte>::byte(p0);
-----------------
src/dfa.rs dfa::Byte::eof
deps:{}
candidates:{}
+dfa::Byte::eof();
+crate::dfa::Byte::eof();
+<dfa::Byte>::eof();
-----------------
src/dfa.rs dfa::Byte::is_eof
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.is_eof();
+dfa::Byte::is_eof(p0);
+crate::dfa::Byte::is_eof(p0);
+<dfa::Byte>::is_eof(p0);
-----------------
src/dfa.rs dfa::Byte::is_ascii_word
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.is_ascii_word();
+dfa::Byte::is_ascii_word(p0);
+crate::dfa::Byte::is_ascii_word(p0);
+<dfa::Byte>::is_ascii_word(p0);
-----------------
src/dfa.rs dfa::Byte::as_byte
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.as_byte();
+dfa::Byte::as_byte(p0);
+crate::dfa::Byte::as_byte(p0);
+<dfa::Byte>::as_byte(p0);
-----------------
src/dfa.rs <dfa::State as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::State as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::State as std::fmt::Debug>::fmt(p0, p1);
+<dfa::State>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::Transitions as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Transitions as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Transitions as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Transitions>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::TransitionsRow<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::TransitionsRow<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::TransitionsRow<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::TransitionsRow<'a> as std::fmt::Debug>::fmt(p0, p1);
+<dfa::TransitionsRow<'a>>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::StateFlags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::StateFlags as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::StateFlags as std::fmt::Debug>::fmt(p0, p1);
+<dfa::StateFlags>::fmt(p0, p1);
-----------------
src/error.rs <error::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.clone();
+<error::Error as std::clone::Clone>::clone(p0);
+crate::<error::Error as std::clone::Clone>::clone(p0);
+<error::Error>::clone(p0);
-----------------
src/error.rs <error::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.eq(p1);
+<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+<error::Error>::eq(p0, p1);
-----------------
src/error.rs <error::Error as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.description();
+<error::Error as std::error::Error>::description(p0);
+crate::<error::Error as std::error::Error>::description(p0);
+<error::Error>::description(p0);
-----------------
src/error.rs <error::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Display>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error.rs <error::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Debug>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/exec.rs <exec::Exec as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::Exec as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::Exec as std::fmt::Debug>::fmt(p0, p1);
+<exec::Exec>::fmt(p0, p1);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as std::fmt::Debug>::fmt
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::ExecNoSync<'c> as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::ExecNoSync<'c> as std::fmt::Debug>::fmt(p0, p1);
+<exec::ExecNoSync<'c>>::fmt(p0, p1);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as std::fmt::Debug>::fmt
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::ExecNoSyncStr<'c> as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::ExecNoSyncStr<'c> as std::fmt::Debug>::fmt(p0, p1);
+<exec::ExecNoSyncStr<'c>>::fmt(p0, p1);
-----------------
src/exec.rs <exec::ExecReadOnly as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::ExecReadOnly as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::ExecReadOnly as std::fmt::Debug>::fmt(p0, p1);
+<exec::ExecReadOnly>::fmt(p0, p1);
-----------------
src/exec.rs exec::ExecBuilder::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+exec::ExecBuilder::new(&p0);
+crate::exec::ExecBuilder::new(&p0);
+<exec::ExecBuilder>::new(&p0);
-----------------
src/exec.rs exec::ExecBuilder::new_many
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"exec::ExecBuilder::new_many":{"I":["std::iter::IntoIterator","std::marker::Sized"],"S":["std::convert::AsRef","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["re_unicode::CaptureMatches","re_bytes::Matches","re_set::unicode::SetMatchesIntoIter","re_trait::Matches","re_set::bytes::SetMatchesIntoIter","re_bytes::SubCaptureMatches","re_bytes::SplitN","re_set::bytes::SetMatchesIter","re_bytes::CaptureMatches","re_unicode::Split","re_unicode::Matches","<&mut I as std::iter::Iterator>","literal::imp::LiteralIter","re_unicode::SubCaptureMatches","re_bytes::Split","re_bytes::CaptureNames","re_unicode::CaptureNames","dfa::InstPtrs","re_trait::CaptureMatches","re_set::unicode::SetMatchesIter","re_unicode::SplitN","re_trait::SubCapturesPosIter"]},"exec::ExecBuilder::new_many":{"I":["<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>","re_set::unicode::SetMatches","re_set::bytes::SetMatches","<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>"],"S":["std::boxed::Box<T, A>","<&T as std::convert::AsRef<U>>","std::slice::IterMut<'_, T>","std::sync::Arc<T>","std::slice::Iter<'_, T>","std::borrow::Cow<'_, std::ffi::OsStr>","std::borrow::Cow<'_, T>","<&mut T as std::convert::AsRef<U>>","std::rc::Rc<T>","std::vec::IntoIter<T, A>","core::num::dec2flt::common::AsciiStr<'a>","std::ffi::CStr","std::ffi::CString","std::vec::Drain<'a, T, A>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+exec::ExecBuilder::new_many(p0);
+crate::exec::ExecBuilder::new_many(p0);
+<exec::ExecBuilder>::new_many(p0);
-----------------
src/exec.rs exec::ExecBuilder::new_options
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_builder::RegexOptions
+exec::ExecBuilder::new_options(p0);
+crate::exec::ExecBuilder::new_options(p0);
+<exec::ExecBuilder>::new_options(p0);
-----------------
src/exec.rs exec::ExecBuilder::automatic
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.automatic();
+exec::ExecBuilder::automatic(p0);
+crate::exec::ExecBuilder::automatic(p0);
+<exec::ExecBuilder>::automatic(p0);
-----------------
src/exec.rs exec::ExecBuilder::nfa
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.nfa();
+exec::ExecBuilder::nfa(p0);
+crate::exec::ExecBuilder::nfa(p0);
+<exec::ExecBuilder>::nfa(p0);
-----------------
src/exec.rs exec::ExecBuilder::bounded_backtracking
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.bounded_backtracking();
+exec::ExecBuilder::bounded_backtracking(p0);
+crate::exec::ExecBuilder::bounded_backtracking(p0);
+<exec::ExecBuilder>::bounded_backtracking(p0);
-----------------
src/exec.rs exec::ExecBuilder::bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
let mut p1 = true; // None+bool
+p0.bytes(p1);
+exec::ExecBuilder::bytes(p0, p1);
+crate::exec::ExecBuilder::bytes(p0, p1);
+<exec::ExecBuilder>::bytes(p0, p1);
-----------------
src/exec.rs exec::ExecBuilder::only_utf8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
let mut p1 = true; // None+bool
+p0.only_utf8(p1);
+exec::ExecBuilder::only_utf8(p0, p1);
+crate::exec::ExecBuilder::only_utf8(p0, p1);
+<exec::ExecBuilder>::only_utf8(p0, p1);
-----------------
src/exec.rs exec::ExecBuilder::unicode
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+exec::ExecBuilder::unicode(p0, p1);
+crate::exec::ExecBuilder::unicode(p0, p1);
+<exec::ExecBuilder>::unicode(p0, p1);
-----------------
src/exec.rs exec::ExecBuilder::parse
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.parse();
+exec::ExecBuilder::parse(p0);
+crate::exec::ExecBuilder::parse(p0);
+<exec::ExecBuilder>::parse(p0);
-----------------
src/exec.rs exec::ExecBuilder::build
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.build();
+exec::ExecBuilder::build(p0);
+crate::exec::ExecBuilder::build(p0);
+<exec::ExecBuilder>::build(p0);
-----------------
src/exec.rs exec::ExecBuilder::build_aho_corasick
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
let mut p1 = & MaybeUninit::uninit().assume_init(); // exec::Parsed
+p0.build_aho_corasick(p1);
+exec::ExecBuilder::build_aho_corasick(p0, p1);
+crate::exec::ExecBuilder::build_aho_corasick(p0, p1);
+<exec::ExecBuilder>::build_aho_corasick(p0, p1);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::slots_len
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
+p0.slots_len();
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::slots_len(p0);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::slots_len(p0);
+<exec::ExecNoSyncStr<'c>>::slots_len(p0);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::next_after_empty
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.next_after_empty(&p1, p2);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::next_after_empty(p0, &p1, p2);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::next_after_empty(p0, &p1, p2);
+<exec::ExecNoSyncStr<'c>>::next_after_empty(p0, &p1, p2);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::shortest_match_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(&p1, p2);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::shortest_match_at(p0, &p1, p2);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::shortest_match_at(p0, &p1, p2);
+<exec::ExecNoSyncStr<'c>>::shortest_match_at(p0, &p1, p2);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::is_match_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.is_match_at(&p1, p2);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::is_match_at(p0, &p1, p2);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::is_match_at(p0, &p1, p2);
+<exec::ExecNoSyncStr<'c>>::is_match_at(p0, &p1, p2);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::find_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.find_at(&p1, p2);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::find_at(p0, &p1, p2);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::find_at(p0, &p1, p2);
+<exec::ExecNoSyncStr<'c>>::find_at(p0, &p1, p2);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::captures_read_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p2 = "sample"; // None+&str
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, &p2, p3);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::captures_read_at(p0, p1, &p2, p3);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::captures_read_at(p0, p1, &p2, p3);
+<exec::ExecNoSyncStr<'c>>::captures_read_at(p0, p1, &p2, p3);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::slots_len
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
+p0.slots_len();
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::slots_len(p0);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::slots_len(p0);
+<exec::ExecNoSync<'c>>::slots_len(p0);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::next_after_empty
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.next_after_empty(p1, p2);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::next_after_empty(p0, p1, p2);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::next_after_empty(p0, p1, p2);
+<exec::ExecNoSync<'c>>::next_after_empty(p0, p1, p2);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::shortest_match_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(p1, p2);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::shortest_match_at(p0, p1, p2);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::shortest_match_at(p0, p1, p2);
+<exec::ExecNoSync<'c>>::shortest_match_at(p0, p1, p2);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.is_match_at(p1, p2);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at(p0, p1, p2);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at(p0, p1, p2);
+<exec::ExecNoSync<'c>>::is_match_at(p0, p1, p2);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::find_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_at(p1, p2);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::find_at(p0, p1, p2);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::find_at(p0, p1, p2);
+<exec::ExecNoSync<'c>>::find_at(p0, p1, p2);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::captures_read_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, p2, p3);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::captures_read_at(p0, p1, p2, p3);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::captures_read_at(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::captures_read_at(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_literals
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchLiteralType
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.find_literals(p1, p2, p3);
+exec::ExecNoSync::<'c>::find_literals(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::find_literals(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::find_literals(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_dfa_forward
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_dfa_forward(p1, p2);
+exec::ExecNoSync::<'c>::find_dfa_forward(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::find_dfa_forward(p0, p1, p2);
+<exec::ExecNoSync<'c>>::find_dfa_forward(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_dfa_anchored_reverse
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_dfa_anchored_reverse(p1, p2);
+exec::ExecNoSync::<'c>::find_dfa_anchored_reverse(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::find_dfa_anchored_reverse(p0, p1, p2);
+<exec::ExecNoSync<'c>>::find_dfa_anchored_reverse(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::shortest_dfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_dfa(p1, p2);
+exec::ExecNoSync::<'c>::shortest_dfa(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::shortest_dfa(p0, p1, p2);
+<exec::ExecNoSync<'c>>::shortest_dfa(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::shortest_dfa_reverse_suffix
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_dfa_reverse_suffix(p1, p2);
+exec::ExecNoSync::<'c>::shortest_dfa_reverse_suffix(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::shortest_dfa_reverse_suffix(p0, p1, p2);
+<exec::ExecNoSync<'c>>::shortest_dfa_reverse_suffix(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::exec_dfa_reverse_suffix
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.exec_dfa_reverse_suffix(p1, p2);
+exec::ExecNoSync::<'c>::exec_dfa_reverse_suffix(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::exec_dfa_reverse_suffix(p0, p1, p2);
+<exec::ExecNoSync<'c>>::exec_dfa_reverse_suffix(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_dfa_reverse_suffix
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_dfa_reverse_suffix(p1, p2);
+exec::ExecNoSync::<'c>::find_dfa_reverse_suffix(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::find_dfa_reverse_suffix(p0, p1, p2);
+<exec::ExecNoSync<'c>>::find_dfa_reverse_suffix(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::match_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.match_nfa(p1, p2);
+exec::ExecNoSync::<'c>::match_nfa(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::match_nfa(p0, p1, p2);
+<exec::ExecNoSync<'c>>::match_nfa(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::match_nfa_type
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.match_nfa_type(p1, p2, p3);
+exec::ExecNoSync::<'c>::match_nfa_type(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::match_nfa_type(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::match_nfa_type(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::shortest_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_nfa(p1, p2);
+exec::ExecNoSync::<'c>::shortest_nfa(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::shortest_nfa(p0, p1, p2);
+<exec::ExecNoSync<'c>>::shortest_nfa(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::shortest_nfa_type
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.shortest_nfa_type(p1, p2, p3);
+exec::ExecNoSync::<'c>::shortest_nfa_type(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::shortest_nfa_type(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::shortest_nfa_type(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.find_nfa(p1, p2, p3);
+exec::ExecNoSync::<'c>::find_nfa(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::find_nfa(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::find_nfa(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::captures_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.captures_nfa(p1, p2, p3);
+exec::ExecNoSync::<'c>::captures_nfa(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::captures_nfa(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::captures_nfa(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::captures_nfa_type
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
let mut p5 = 0usize; // None+usize
+p0.captures_nfa_type(p1, p2, p3, p4, p5);
+exec::ExecNoSync::<'c>::captures_nfa_type(p0, p1, p2, p3, p4, p5);
+crate::exec::ExecNoSync::<'c>::captures_nfa_type(p0, p1, p2, p3, p4, p5);
+<exec::ExecNoSync<'c>>::captures_nfa_type(p0, p1, p2, p3, p4, p5);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::exec_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p4 = true; // None+bool
let mut p5 = true; // None+bool
let mut p6 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p7 = 0usize; // None+usize
let mut p8 = 0usize; // None+usize
+p0.exec_nfa(p1, p2, p3, p4, p5, p6, p7, p8);
+exec::ExecNoSync::<'c>::exec_nfa(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+crate::exec::ExecNoSync::<'c>::exec_nfa(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+<exec::ExecNoSync<'c>>::exec_nfa(p0, p1, p2, p3, p4, p5, p6, p7, p8);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::exec_pikevm
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = true; // None+bool
let mut p4 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p5 = 0usize; // None+usize
let mut p6 = 0usize; // None+usize
+p0.exec_pikevm(p1, p2, p3, p4, p5, p6);
+exec::ExecNoSync::<'c>::exec_pikevm(p0, p1, p2, p3, p4, p5, p6);
+crate::exec::ExecNoSync::<'c>::exec_pikevm(p0, p1, p2, p3, p4, p5, p6);
+<exec::ExecNoSync<'c>>::exec_pikevm(p0, p1, p2, p3, p4, p5, p6);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::exec_backtrack
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
let mut p5 = 0usize; // None+usize
+p0.exec_backtrack(p1, p2, p3, p4, p5);
+exec::ExecNoSync::<'c>::exec_backtrack(p0, p1, p2, p3, p4, p5);
+crate::exec::ExecNoSync::<'c>::exec_backtrack(p0, p1, p2, p3, p4, p5);
+<exec::ExecNoSync<'c>>::exec_backtrack(p0, p1, p2, p3, p4, p5);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::many_matches_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.many_matches_at(p1, p2, p3);
+exec::ExecNoSync::<'c>::many_matches_at(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::many_matches_at(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::many_matches_at(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::is_anchor_end_match
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.is_anchor_end_match(p1);
+exec::ExecNoSync::<'c>::is_anchor_end_match(p0, p1);
+crate::exec::ExecNoSync::<'c>::is_anchor_end_match(p0, p1);
+<exec::ExecNoSync<'c>>::is_anchor_end_match(p0, p1);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::capture_name_idx
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
+p0.capture_name_idx();
+exec::ExecNoSync::<'c>::capture_name_idx(p0);
+crate::exec::ExecNoSync::<'c>::capture_name_idx(p0);
+<exec::ExecNoSync<'c>>::capture_name_idx(p0);
-----------------
src/exec.rs exec::ExecNoSyncStr::<'c>::capture_name_idx
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
+p0.capture_name_idx();
+exec::ExecNoSyncStr::<'c>::capture_name_idx(p0);
+crate::exec::ExecNoSyncStr::<'c>::capture_name_idx(p0);
+<exec::ExecNoSyncStr<'c>>::capture_name_idx(p0);
-----------------
src/exec.rs exec::Exec::searcher
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.searcher();
+exec::Exec::searcher(p0);
+crate::exec::Exec::searcher(p0);
+<exec::Exec>::searcher(p0);
-----------------
src/exec.rs exec::Exec::searcher_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.searcher_str();
+exec::Exec::searcher_str(p0);
+crate::exec::Exec::searcher_str(p0);
+<exec::Exec>::searcher_str(p0);
-----------------
src/exec.rs exec::Exec::into_regex
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.into_regex();
+exec::Exec::into_regex(p0);
+crate::exec::Exec::into_regex(p0);
+<exec::Exec>::into_regex(p0);
-----------------
src/exec.rs exec::Exec::into_regex_set
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.into_regex_set();
+exec::Exec::into_regex_set(p0);
+crate::exec::Exec::into_regex_set(p0);
+<exec::Exec>::into_regex_set(p0);
-----------------
src/exec.rs exec::Exec::into_byte_regex
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.into_byte_regex();
+exec::Exec::into_byte_regex(p0);
+crate::exec::Exec::into_byte_regex(p0);
+<exec::Exec>::into_byte_regex(p0);
-----------------
src/exec.rs exec::Exec::into_byte_regex_set
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.into_byte_regex_set();
+exec::Exec::into_byte_regex_set(p0);
+crate::exec::Exec::into_byte_regex_set(p0);
+<exec::Exec>::into_byte_regex_set(p0);
-----------------
src/exec.rs exec::Exec::regex_strings
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.regex_strings();
+exec::Exec::regex_strings(p0);
+crate::exec::Exec::regex_strings(p0);
+<exec::Exec>::regex_strings(p0);
-----------------
src/exec.rs exec::Exec::capture_names
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.capture_names();
+exec::Exec::capture_names(p0);
+crate::exec::Exec::capture_names(p0);
+<exec::Exec>::capture_names(p0);
-----------------
src/exec.rs exec::Exec::capture_name_idx
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.capture_name_idx();
+exec::Exec::capture_name_idx(p0);
+crate::exec::Exec::capture_name_idx(p0);
+<exec::Exec>::capture_name_idx(p0);
-----------------
src/exec.rs exec::Exec::static_captures_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.static_captures_len();
+exec::Exec::static_captures_len(p0);
+crate::exec::Exec::static_captures_len(p0);
+<exec::Exec>::static_captures_len(p0);
-----------------
src/exec.rs <exec::Exec as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.clone();
+<exec::Exec as std::clone::Clone>::clone(p0);
+crate::<exec::Exec as std::clone::Clone>::clone(p0);
+<exec::Exec>::clone(p0);
-----------------
src/exec.rs exec::ExecReadOnly::choose_match_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<exec::MatchType>
+p0.choose_match_type(p1);
+exec::ExecReadOnly::choose_match_type(p0, p1);
+crate::exec::ExecReadOnly::choose_match_type(p0, p1);
+<exec::ExecReadOnly>::choose_match_type(p0, p1);
-----------------
src/exec.rs exec::ExecReadOnly::choose_literal_match_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+p0.choose_literal_match_type();
+exec::ExecReadOnly::choose_literal_match_type(p0);
+crate::exec::ExecReadOnly::choose_literal_match_type(p0);
+<exec::ExecReadOnly>::choose_literal_match_type(p0);
-----------------
src/exec.rs exec::ExecReadOnly::choose_dfa_match_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+p0.choose_dfa_match_type();
+exec::ExecReadOnly::choose_dfa_match_type(p0);
+crate::exec::ExecReadOnly::choose_dfa_match_type(p0);
+<exec::ExecReadOnly>::choose_dfa_match_type(p0);
-----------------
src/exec.rs exec::ExecReadOnly::should_suffix_scan
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+p0.should_suffix_scan();
+exec::ExecReadOnly::should_suffix_scan(p0);
+crate::exec::ExecReadOnly::should_suffix_scan(p0);
+<exec::ExecReadOnly>::should_suffix_scan(p0);
-----------------
src/exec.rs exec::ExecReadOnly::new_pool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::Arc<exec::ExecReadOnly>
+exec::ExecReadOnly::new_pool(p0);
+crate::exec::ExecReadOnly::new_pool(p0);
+<exec::ExecReadOnly>::new_pool(p0);
-----------------
src/exec.rs <exec::MatchType as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchType
+p0.clone();
+<exec::MatchType as std::clone::Clone>::clone(p0);
+crate::<exec::MatchType as std::clone::Clone>::clone(p0);
+<exec::MatchType>::clone(p0);
-----------------
src/exec.rs <exec::MatchType as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::MatchType as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::MatchType as std::fmt::Debug>::fmt(p0, p1);
+<exec::MatchType>::fmt(p0, p1);
-----------------
src/exec.rs <exec::MatchLiteralType as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchLiteralType
+p0.clone();
+<exec::MatchLiteralType as std::clone::Clone>::clone(p0);
+crate::<exec::MatchLiteralType as std::clone::Clone>::clone(p0);
+<exec::MatchLiteralType>::clone(p0);
-----------------
src/exec.rs <exec::MatchLiteralType as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchLiteralType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::MatchLiteralType as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::MatchLiteralType as std::fmt::Debug>::fmt(p0, p1);
+<exec::MatchLiteralType>::fmt(p0, p1);
-----------------
src/exec.rs <exec::MatchNfaType as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
+p0.clone();
+<exec::MatchNfaType as std::clone::Clone>::clone(p0);
+crate::<exec::MatchNfaType as std::clone::Clone>::clone(p0);
+<exec::MatchNfaType>::clone(p0);
-----------------
src/exec.rs <exec::MatchNfaType as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::MatchNfaType as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::MatchNfaType as std::fmt::Debug>::fmt(p0, p1);
+<exec::MatchNfaType>::fmt(p0, p1);
-----------------
src/exec.rs <exec::MatchNfaType as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
+p0.assert_receiver_is_total_eq();
+<exec::MatchNfaType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<exec::MatchNfaType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<exec::MatchNfaType>::assert_receiver_is_total_eq(p0);
-----------------
src/exec.rs <exec::MatchNfaType as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p1 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
+p0.eq(p1);
+<exec::MatchNfaType as std::cmp::PartialEq>::eq(p0, p1);
+crate::<exec::MatchNfaType as std::cmp::PartialEq>::eq(p0, p1);
+<exec::MatchNfaType>::eq(p0, p1);
-----------------
src/exec.rs <exec::ProgramCacheInner as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ProgramCacheInner
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::ProgramCacheInner as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::ProgramCacheInner as std::fmt::Debug>::fmt(p0, p1);
+<exec::ProgramCacheInner>::fmt(p0, p1);
-----------------
src/exec.rs exec::ProgramCacheInner::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+exec::ProgramCacheInner::new(p0);
+crate::exec::ProgramCacheInner::new(p0);
+<exec::ProgramCacheInner>::new(p0);
-----------------
src/expand.rs <expand::CaptureRef<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
+p0.clone();
+<expand::CaptureRef<'a> as std::clone::Clone>::clone(p0);
+crate::<expand::CaptureRef<'a> as std::clone::Clone>::clone(p0);
+<expand::CaptureRef<'a>>::clone(p0);
-----------------
src/expand.rs <expand::CaptureRef<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<expand::CaptureRef<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<expand::CaptureRef<'a> as std::fmt::Debug>::fmt(p0, p1);
+<expand::CaptureRef<'a>>::fmt(p0, p1);
-----------------
src/expand.rs <expand::CaptureRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
+p0.assert_receiver_is_total_eq();
+<expand::CaptureRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<expand::CaptureRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<expand::CaptureRef<'a>>::assert_receiver_is_total_eq(p0);
-----------------
src/expand.rs <expand::CaptureRef<'a> as std::cmp::PartialEq>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
+p0.eq(p1);
+<expand::CaptureRef<'a> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<expand::CaptureRef<'a> as std::cmp::PartialEq>::eq(p0, p1);
+<expand::CaptureRef<'a>>::eq(p0, p1);
-----------------
src/expand.rs <expand::Ref<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
+p0.clone();
+<expand::Ref<'a> as std::clone::Clone>::clone(p0);
+crate::<expand::Ref<'a> as std::clone::Clone>::clone(p0);
+<expand::Ref<'a>>::clone(p0);
-----------------
src/expand.rs <expand::Ref<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<expand::Ref<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<expand::Ref<'a> as std::fmt::Debug>::fmt(p0, p1);
+<expand::Ref<'a>>::fmt(p0, p1);
-----------------
src/expand.rs <expand::Ref<'a> as std::cmp::Eq>::assert_receiver_is_total_eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
+p0.assert_receiver_is_total_eq();
+<expand::Ref<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<expand::Ref<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<expand::Ref<'a>>::assert_receiver_is_total_eq(p0);
-----------------
src/expand.rs <expand::Ref<'a> as std::cmp::PartialEq>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
+p0.eq(p1);
+<expand::Ref<'a> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<expand::Ref<'a> as std::cmp::PartialEq>::eq(p0, p1);
+<expand::Ref<'a>>::eq(p0, p1);
-----------------
src/expand.rs <expand::Ref<'a> as std::convert::From<&'a str>>::from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<expand::Ref<'a> as std::convert::From<&'a str>>::from(&p0);
+crate::<expand::Ref<'a> as std::convert::From<&'a str>>::from(&p0);
+<expand::Ref<'a>>::from(&p0);
-----------------
src/expand.rs <expand::Ref<'static> as std::convert::From<usize>>::from
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<expand::Ref<'static> as std::convert::From<usize>>::from(p0);
+crate::<expand::Ref<'static> as std::convert::From<usize>>::from(p0);
+<expand::Ref<'static>>::from(p0);
-----------------
src/input.rs <input::InputAt as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.clone();
+<input::InputAt as std::clone::Clone>::clone(p0);
+crate::<input::InputAt as std::clone::Clone>::clone(p0);
+<input::InputAt>::clone(p0);
-----------------
src/input.rs <input::InputAt as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<input::InputAt as std::fmt::Debug>::fmt(p0, p1);
+crate::<input::InputAt as std::fmt::Debug>::fmt(p0, p1);
+<input::InputAt>::fmt(p0, p1);
-----------------
src/input.rs input::InputAt::is_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.is_start();
+input::InputAt::is_start(p0);
+crate::input::InputAt::is_start(p0);
+<input::InputAt>::is_start(p0);
-----------------
src/input.rs input::InputAt::is_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.is_end();
+input::InputAt::is_end(p0);
+crate::input::InputAt::is_end(p0);
+<input::InputAt>::is_end(p0);
-----------------
src/input.rs input::InputAt::char
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.char();
+input::InputAt::char(p0);
+crate::input::InputAt::char(p0);
+<input::InputAt>::char(p0);
-----------------
src/input.rs input::InputAt::byte
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.byte();
+input::InputAt::byte(p0);
+crate::input::InputAt::byte(p0);
+<input::InputAt>::byte(p0);
-----------------
src/input.rs input::InputAt::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.len();
+input::InputAt::len(p0);
+crate::input::InputAt::len(p0);
+<input::InputAt>::len(p0);
-----------------
src/input.rs input::InputAt::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.is_empty();
+input::InputAt::is_empty(p0);
+crate::input::InputAt::is_empty(p0);
+<input::InputAt>::is_empty(p0);
-----------------
src/input.rs input::InputAt::pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.pos();
+input::InputAt::pos(p0);
+crate::input::InputAt::pos(p0);
+<input::InputAt>::pos(p0);
-----------------
src/input.rs input::InputAt::next_pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_pos();
+input::InputAt::next_pos(p0);
+crate::input::InputAt::next_pos(p0);
+<input::InputAt>::next_pos(p0);
-----------------
src/input.rs <&'a T as input::Input>::at
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::at":{"T":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::at":{"T":["<&'a T as input::Input>","input::ByteInput","input::CharInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+p0.at(p1);
+<&'a T as input::Input>::at(p0, p1);
+crate::<&'a T as input::Input>::at(p0, p1);
+<&'a T>::at(p0, p1);
-----------------
src/input.rs <&'a T as input::Input>::next_char
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::next_char":{"T":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::next_char":{"T":["input::CharInput","<&'a T as input::Input>","input::ByteInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_char(p1);
+<&'a T as input::Input>::next_char(p0, p1);
+crate::<&'a T as input::Input>::next_char(p0, p1);
+<&'a T>::next_char(p0, p1);
-----------------
src/input.rs <&'a T as input::Input>::previous_char
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::previous_char":{"T":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::previous_char":{"T":["<&'a T as input::Input>","input::CharInput","input::ByteInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.previous_char(p1);
+<&'a T as input::Input>::previous_char(p0, p1);
+crate::<&'a T as input::Input>::previous_char(p0, p1);
+<&'a T>::previous_char(p0, p1);
-----------------
src/input.rs <&'a T as input::Input>::is_empty_match
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::is_empty_match":{"T":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::is_empty_match":{"T":["<&'a T as input::Input>","input::CharInput","input::ByteInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.is_empty_match(p1, p2);
+<&'a T as input::Input>::is_empty_match(p0, p1, p2);
+crate::<&'a T as input::Input>::is_empty_match(p0, p1, p2);
+<&'a T>::is_empty_match(p0, p1, p2);
-----------------
src/input.rs <&'a T as input::Input>::prefix_at
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::prefix_at":{"T":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::prefix_at":{"T":["input::ByteInput","input::CharInput","<&'a T as input::Input>"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.prefix_at(p1, p2);
+<&'a T as input::Input>::prefix_at(p0, p1, p2);
+crate::<&'a T as input::Input>::prefix_at(p0, p1, p2);
+<&'a T>::prefix_at(p0, p1, p2);
-----------------
src/input.rs <&'a T as input::Input>::len
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::len":{"T":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::len":{"T":["input::ByteInput","input::CharInput","<&'a T as input::Input>"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
+p0.len();
+<&'a T as input::Input>::len(p0);
+crate::<&'a T as input::Input>::len(p0);
+<&'a T>::len(p0);
-----------------
src/input.rs <&'a T as input::Input>::as_bytes
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::as_bytes":{"T":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::as_bytes":{"T":["input::ByteInput","input::CharInput","<&'a T as input::Input>"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
+p0.as_bytes();
+<&'a T as input::Input>::as_bytes(p0);
+crate::<&'a T as input::Input>::as_bytes(p0);
+<&'a T>::as_bytes(p0);
-----------------
src/input.rs <input::CharInput<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
+p0.clone();
+<input::CharInput<'t> as std::clone::Clone>::clone(p0);
+crate::<input::CharInput<'t> as std::clone::Clone>::clone(p0);
+<input::CharInput<'t>>::clone(p0);
-----------------
src/input.rs <input::CharInput<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<input::CharInput<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<input::CharInput<'t> as std::fmt::Debug>::fmt(p0, p1);
+<input::CharInput<'t>>::fmt(p0, p1);
-----------------
src/input.rs input::CharInput::<'t>::new
't
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+input::CharInput::<'t>::new(p0);
+crate::input::CharInput::<'t>::new(p0);
+<input::CharInput<'t>>::new(p0);
-----------------
src/input.rs <input::CharInput<'t> as std::ops::Deref>::deref
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
+p0.deref();
+<input::CharInput<'t> as std::ops::Deref>::deref(p0);
+crate::<input::CharInput<'t> as std::ops::Deref>::deref(p0);
+<input::CharInput<'t>>::deref(p0);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::at
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = 0usize; // None+usize
+p0.at(p1);
+<input::CharInput<'t> as input::Input>::at(p0, p1);
+crate::<input::CharInput<'t> as input::Input>::at(p0, p1);
+<input::CharInput<'t>>::at(p0, p1);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::next_char
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_char(p1);
+<input::CharInput<'t> as input::Input>::next_char(p0, p1);
+crate::<input::CharInput<'t> as input::Input>::next_char(p0, p1);
+<input::CharInput<'t>>::next_char(p0, p1);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::previous_char
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.previous_char(p1);
+<input::CharInput<'t> as input::Input>::previous_char(p0, p1);
+crate::<input::CharInput<'t> as input::Input>::previous_char(p0, p1);
+<input::CharInput<'t>>::previous_char(p0, p1);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::is_empty_match
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.is_empty_match(p1, p2);
+<input::CharInput<'t> as input::Input>::is_empty_match(p0, p1, p2);
+crate::<input::CharInput<'t> as input::Input>::is_empty_match(p0, p1, p2);
+<input::CharInput<'t>>::is_empty_match(p0, p1, p2);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::prefix_at
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.prefix_at(p1, p2);
+<input::CharInput<'t> as input::Input>::prefix_at(p0, p1, p2);
+crate::<input::CharInput<'t> as input::Input>::prefix_at(p0, p1, p2);
+<input::CharInput<'t>>::prefix_at(p0, p1, p2);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
+p0.len();
+<input::CharInput<'t> as input::Input>::len(p0);
+crate::<input::CharInput<'t> as input::Input>::len(p0);
+<input::CharInput<'t>>::len(p0);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::as_bytes
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
+p0.as_bytes();
+<input::CharInput<'t> as input::Input>::as_bytes(p0);
+crate::<input::CharInput<'t> as input::Input>::as_bytes(p0);
+<input::CharInput<'t>>::as_bytes(p0);
-----------------
src/input.rs <input::ByteInput<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
+p0.clone();
+<input::ByteInput<'t> as std::clone::Clone>::clone(p0);
+crate::<input::ByteInput<'t> as std::clone::Clone>::clone(p0);
+<input::ByteInput<'t>>::clone(p0);
-----------------
src/input.rs <input::ByteInput<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<input::ByteInput<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<input::ByteInput<'t> as std::fmt::Debug>::fmt(p0, p1);
+<input::ByteInput<'t>>::fmt(p0, p1);
-----------------
src/input.rs input::ByteInput::<'t>::new
't
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = true; // None+bool
+input::ByteInput::<'t>::new(p0, p1);
+crate::input::ByteInput::<'t>::new(p0, p1);
+<input::ByteInput<'t>>::new(p0, p1);
-----------------
src/input.rs <input::ByteInput<'t> as std::ops::Deref>::deref
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
+p0.deref();
+<input::ByteInput<'t> as std::ops::Deref>::deref(p0);
+crate::<input::ByteInput<'t> as std::ops::Deref>::deref(p0);
+<input::ByteInput<'t>>::deref(p0);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::at
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = 0usize; // None+usize
+p0.at(p1);
+<input::ByteInput<'t> as input::Input>::at(p0, p1);
+crate::<input::ByteInput<'t> as input::Input>::at(p0, p1);
+<input::ByteInput<'t>>::at(p0, p1);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::next_char
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_char(p1);
+<input::ByteInput<'t> as input::Input>::next_char(p0, p1);
+crate::<input::ByteInput<'t> as input::Input>::next_char(p0, p1);
+<input::ByteInput<'t>>::next_char(p0, p1);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::previous_char
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.previous_char(p1);
+<input::ByteInput<'t> as input::Input>::previous_char(p0, p1);
+crate::<input::ByteInput<'t> as input::Input>::previous_char(p0, p1);
+<input::ByteInput<'t>>::previous_char(p0, p1);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::is_empty_match
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.is_empty_match(p1, p2);
+<input::ByteInput<'t> as input::Input>::is_empty_match(p0, p1, p2);
+crate::<input::ByteInput<'t> as input::Input>::is_empty_match(p0, p1, p2);
+<input::ByteInput<'t>>::is_empty_match(p0, p1, p2);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::prefix_at
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.prefix_at(p1, p2);
+<input::ByteInput<'t> as input::Input>::prefix_at(p0, p1, p2);
+crate::<input::ByteInput<'t> as input::Input>::prefix_at(p0, p1, p2);
+<input::ByteInput<'t>>::prefix_at(p0, p1, p2);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
+p0.len();
+<input::ByteInput<'t> as input::Input>::len(p0);
+crate::<input::ByteInput<'t> as input::Input>::len(p0);
+<input::ByteInput<'t>>::len(p0);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::as_bytes
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
+p0.as_bytes();
+<input::ByteInput<'t> as input::Input>::as_bytes(p0);
+crate::<input::ByteInput<'t> as input::Input>::as_bytes(p0);
+<input::ByteInput<'t>>::as_bytes(p0);
-----------------
src/input.rs <input::Char as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.clone();
+<input::Char as std::clone::Clone>::clone(p0);
+crate::<input::Char as std::clone::Clone>::clone(p0);
+<input::Char>::clone(p0);
-----------------
src/input.rs <input::Char as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<input::Char as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<input::Char as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","std::hash::SipHasher","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<input::Char as std::hash::Hash>::hash(p0, p1);
+crate::<input::Char as std::hash::Hash>::hash(p0, p1);
+<input::Char>::hash(p0, p1);
-----------------
src/input.rs <input::Char as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.eq(p1);
+<input::Char as std::cmp::PartialEq>::eq(p0, p1);
+crate::<input::Char as std::cmp::PartialEq>::eq(p0, p1);
+<input::Char>::eq(p0, p1);
-----------------
src/input.rs <input::Char as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.assert_receiver_is_total_eq();
+<input::Char as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<input::Char as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<input::Char>::assert_receiver_is_total_eq(p0);
-----------------
src/input.rs <input::Char as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.partial_cmp(p1);
+<input::Char as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<input::Char as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<input::Char>::partial_cmp(p0, p1);
-----------------
src/input.rs <input::Char as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.cmp(p1);
+<input::Char as std::cmp::Ord>::cmp(p0, p1);
+crate::<input::Char as std::cmp::Ord>::cmp(p0, p1);
+<input::Char>::cmp(p0, p1);
-----------------
src/input.rs <input::Char as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<input::Char as std::fmt::Debug>::fmt(p0, p1);
+crate::<input::Char as std::fmt::Debug>::fmt(p0, p1);
+<input::Char>::fmt(p0, p1);
-----------------
src/input.rs input::Char::is_none
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.is_none();
+input::Char::is_none(p0);
+crate::input::Char::is_none(p0);
+<input::Char>::is_none(p0);
-----------------
src/input.rs input::Char::len_utf8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.len_utf8();
+input::Char::len_utf8(p0);
+crate::input::Char::len_utf8(p0);
+<input::Char>::len_utf8(p0);
-----------------
src/input.rs input::Char::is_word_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.is_word_char();
+input::Char::is_word_char(p0);
+crate::input::Char::is_word_char(p0);
+<input::Char>::is_word_char(p0);
-----------------
src/input.rs input::Char::is_word_byte
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.is_word_byte();
+input::Char::is_word_byte(p0);
+crate::input::Char::is_word_byte(p0);
+<input::Char>::is_word_byte(p0);
-----------------
src/input.rs <input::Char as std::convert::From<char>>::from
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+<input::Char as std::convert::From<char>>::from(p0);
+crate::<input::Char as std::convert::From<char>>::from(p0);
+<input::Char>::from(p0);
-----------------
src/input.rs <input::Char as std::convert::From<std::option::Option<char>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<char>
+<input::Char as std::convert::From<std::option::Option<char>>>::from(p0);
+crate::<input::Char as std::convert::From<std::option::Option<char>>>::from(p0);
+<input::Char>::from(p0);
-----------------
src/input.rs <input::Char as std::cmp::PartialEq<char>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & 'a'; // None+char
+p0.eq(p1);
+<input::Char as std::cmp::PartialEq<char>>::eq(p0, p1);
+crate::<input::Char as std::cmp::PartialEq<char>>::eq(p0, p1);
+<input::Char>::eq(p0, p1);
-----------------
src/input.rs input::<impl std::cmp::PartialEq<input::Char> for char>::eq
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.eq(p1);
+input::<impl std::cmp::PartialEq<input::Char> for char>::eq(p0, p1);
+crate::input::<impl std::cmp::PartialEq<input::Char> for char>::eq(p0, p1);
+<char>::eq(p0, p1);
-----------------
src/input.rs <input::Char as std::cmp::PartialOrd<char>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & 'a'; // None+char
+p0.partial_cmp(p1);
+<input::Char as std::cmp::PartialOrd<char>>::partial_cmp(p0, p1);
+crate::<input::Char as std::cmp::PartialOrd<char>>::partial_cmp(p0, p1);
+<input::Char>::partial_cmp(p0, p1);
-----------------
src/input.rs input::<impl std::cmp::PartialOrd<input::Char> for char>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.partial_cmp(p1);
+input::<impl std::cmp::PartialOrd<input::Char> for char>::partial_cmp(p0, p1);
+crate::input::<impl std::cmp::PartialOrd<input::Char> for char>::partial_cmp(p0, p1);
+<char>::partial_cmp(p0, p1);
-----------------
src/literal/imp.rs <literal::imp::LiteralSearcher as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.clone();
+<literal::imp::LiteralSearcher as std::clone::Clone>::clone(p0);
+crate::<literal::imp::LiteralSearcher as std::clone::Clone>::clone(p0);
+<literal::imp::LiteralSearcher>::clone(p0);
-----------------
src/literal/imp.rs <literal::imp::LiteralSearcher as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::LiteralSearcher as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::LiteralSearcher as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::LiteralSearcher>::fmt(p0, p1);
-----------------
src/literal/imp.rs <literal::imp::Matcher as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Matcher
+p0.clone();
+<literal::imp::Matcher as std::clone::Clone>::clone(p0);
+crate::<literal::imp::Matcher as std::clone::Clone>::clone(p0);
+<literal::imp::Matcher>::clone(p0);
-----------------
src/literal/imp.rs <literal::imp::Matcher as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Matcher
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::Matcher as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::Matcher as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::Matcher>::fmt(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::empty
deps:{}
candidates:{}
+literal::imp::LiteralSearcher::empty();
+crate::literal::imp::LiteralSearcher::empty();
+<literal::imp::LiteralSearcher>::empty();
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::prefixes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // regex_syntax::hir::literal::Seq
+literal::imp::LiteralSearcher::prefixes(p0);
+crate::literal::imp::LiteralSearcher::prefixes(p0);
+<literal::imp::LiteralSearcher>::prefixes(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::suffixes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // regex_syntax::hir::literal::Seq
+literal::imp::LiteralSearcher::suffixes(p0);
+crate::literal::imp::LiteralSearcher::suffixes(p0);
+<literal::imp::LiteralSearcher>::suffixes(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // regex_syntax::hir::literal::Seq
let mut p1 = MaybeUninit::uninit().assume_init(); // literal::imp::Matcher
+literal::imp::LiteralSearcher::new(p0, p1);
+crate::literal::imp::LiteralSearcher::new(p0, p1);
+<literal::imp::LiteralSearcher>::new(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::complete
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.complete();
+literal::imp::LiteralSearcher::complete(p0);
+crate::literal::imp::LiteralSearcher::complete(p0);
+<literal::imp::LiteralSearcher>::complete(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find(p1);
+literal::imp::LiteralSearcher::find(p0, p1);
+crate::literal::imp::LiteralSearcher::find(p0, p1);
+<literal::imp::LiteralSearcher>::find(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::find_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find_start(p1);
+literal::imp::LiteralSearcher::find_start(p0, p1);
+crate::literal::imp::LiteralSearcher::find_start(p0, p1);
+<literal::imp::LiteralSearcher>::find_start(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::find_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find_end(p1);
+literal::imp::LiteralSearcher::find_end(p0, p1);
+crate::literal::imp::LiteralSearcher::find_end(p0, p1);
+<literal::imp::LiteralSearcher>::find_end(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.iter();
+literal::imp::LiteralSearcher::iter(p0);
+crate::literal::imp::LiteralSearcher::iter(p0);
+<literal::imp::LiteralSearcher>::iter(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::lcp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.lcp();
+literal::imp::LiteralSearcher::lcp(p0);
+crate::literal::imp::LiteralSearcher::lcp(p0);
+<literal::imp::LiteralSearcher>::lcp(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::lcs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.lcs();
+literal::imp::LiteralSearcher::lcs(p0);
+crate::literal::imp::LiteralSearcher::lcs(p0);
+<literal::imp::LiteralSearcher>::lcs(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.is_empty();
+literal::imp::LiteralSearcher::is_empty(p0);
+crate::literal::imp::LiteralSearcher::is_empty(p0);
+<literal::imp::LiteralSearcher>::is_empty(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.len();
+literal::imp::LiteralSearcher::len(p0);
+crate::literal::imp::LiteralSearcher::len(p0);
+<literal::imp::LiteralSearcher>::len(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::approximate_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.approximate_size();
+literal::imp::LiteralSearcher::approximate_size(p0);
+crate::literal::imp::LiteralSearcher::approximate_size(p0);
+<literal::imp::LiteralSearcher>::approximate_size(p0);
-----------------
src/literal/imp.rs literal::imp::Matcher::prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::literal::Seq
+literal::imp::Matcher::prefixes(p0);
+crate::literal::imp::Matcher::prefixes(p0);
+<literal::imp::Matcher>::prefixes(p0);
-----------------
src/literal/imp.rs literal::imp::Matcher::suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::literal::Seq
+literal::imp::Matcher::suffixes(p0);
+crate::literal::imp::Matcher::suffixes(p0);
+<literal::imp::Matcher>::suffixes(p0);
-----------------
src/literal/imp.rs literal::imp::Matcher::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::literal::Seq
let mut p1 = MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
+literal::imp::Matcher::new(p0, p1);
+crate::literal::imp::Matcher::new(p0, p1);
+<literal::imp::Matcher>::new(p0, p1);
-----------------
src/literal/imp.rs <literal::imp::LiteralIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::LiteralIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::LiteralIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::LiteralIter<'a>>::fmt(p0, p1);
-----------------
src/literal/imp.rs <literal::imp::LiteralIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // literal::imp::LiteralIter<'a>
+p0.next();
+<literal::imp::LiteralIter<'a> as std::iter::Iterator>::next(p0);
+crate::<literal::imp::LiteralIter<'a> as std::iter::Iterator>::next(p0);
+<literal::imp::LiteralIter<'a>>::next(p0);
-----------------
src/literal/imp.rs <literal::imp::SingleByteSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
+p0.clone();
+<literal::imp::SingleByteSet as std::clone::Clone>::clone(p0);
+crate::<literal::imp::SingleByteSet as std::clone::Clone>::clone(p0);
+<literal::imp::SingleByteSet>::clone(p0);
-----------------
src/literal/imp.rs <literal::imp::SingleByteSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::SingleByteSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::SingleByteSet as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::SingleByteSet>::fmt(p0, p1);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::new
deps:{}
candidates:{}
+literal::imp::SingleByteSet::new();
+crate::literal::imp::SingleByteSet::new();
+<literal::imp::SingleByteSet>::new();
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::literal::Seq
+literal::imp::SingleByteSet::prefixes(p0);
+crate::literal::imp::SingleByteSet::prefixes(p0);
+<literal::imp::SingleByteSet>::prefixes(p0);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // regex_syntax::hir::literal::Seq
+literal::imp::SingleByteSet::suffixes(p0);
+crate::literal::imp::SingleByteSet::suffixes(p0);
+<literal::imp::SingleByteSet>::suffixes(p0);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find(p1);
+literal::imp::SingleByteSet::find(p0, p1);
+crate::literal::imp::SingleByteSet::find(p0, p1);
+<literal::imp::SingleByteSet>::find(p0, p1);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::_find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0._find(p1);
+literal::imp::SingleByteSet::_find(p0, p1);
+crate::literal::imp::SingleByteSet::_find(p0, p1);
+<literal::imp::SingleByteSet>::_find(p0, p1);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::approximate_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
+p0.approximate_size();
+literal::imp::SingleByteSet::approximate_size(p0);
+crate::literal::imp::SingleByteSet::approximate_size(p0);
+<literal::imp::SingleByteSet>::approximate_size(p0);
-----------------
src/literal/imp.rs <literal::imp::Memmem as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Memmem
+p0.clone();
+<literal::imp::Memmem as std::clone::Clone>::clone(p0);
+crate::<literal::imp::Memmem as std::clone::Clone>::clone(p0);
+<literal::imp::Memmem>::clone(p0);
-----------------
src/literal/imp.rs <literal::imp::Memmem as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Memmem
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::Memmem as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::Memmem as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::Memmem>::fmt(p0, p1);
-----------------
src/literal/imp.rs literal::imp::Memmem::new
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+literal::imp::Memmem::new(p0);
+crate::literal::imp::Memmem::new(p0);
+<literal::imp::Memmem>::new(p0);
-----------------
src/literal/imp.rs literal::imp::Memmem::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Memmem
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find(p1);
+literal::imp::Memmem::find(p0, p1);
+crate::literal::imp::Memmem::find(p0, p1);
+<literal::imp::Memmem>::find(p0, p1);
-----------------
src/literal/imp.rs literal::imp::Memmem::is_suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Memmem
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.is_suffix(p1);
+literal::imp::Memmem::is_suffix(p0, p1);
+crate::literal::imp::Memmem::is_suffix(p0, p1);
+<literal::imp::Memmem>::is_suffix(p0, p1);
-----------------
src/literal/imp.rs literal::imp::Memmem::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Memmem
+p0.len();
+literal::imp::Memmem::len(p0);
+crate::literal::imp::Memmem::len(p0);
+<literal::imp::Memmem>::len(p0);
-----------------
src/literal/imp.rs literal::imp::Memmem::char_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Memmem
+p0.char_len();
+literal::imp::Memmem::char_len(p0);
+crate::literal::imp::Memmem::char_len(p0);
+<literal::imp::Memmem>::char_len(p0);
-----------------
src/literal/imp.rs literal::imp::Memmem::approximate_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Memmem
+p0.approximate_size();
+literal::imp::Memmem::approximate_size(p0);
+crate::literal::imp::Memmem::approximate_size(p0);
+<literal::imp::Memmem>::approximate_size(p0);
-----------------
src/pikevm.rs <pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt
'r
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"backtrack::Bounded":{"I":["input::Input","std::marker::Sized","std::fmt::Debug"]},"dfa::Result":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"pikevm::Fsm":{"I":["std::fmt::Debug","input::Input","std::marker::Sized"]},"pool::Pool":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"pool::PoolGuard":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"re_trait::Matches":{"R":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt":{"I":["re_set::bytes::SetMatches","input::Char","compile::MaybeInst","pool::Pool","re_bytes::SubCaptureMatches","input::ByteInput","re_set::bytes::SetMatchesIntoIter","pikevm::Threads","re_bytes::CaptureLocations","dfa::StateMap","exec::Exec","prog::Program","literal::imp::Memmem","re_bytes::SplitN","re_unicode::Regex","prog::InstRanges","literal::imp::LiteralIter","input::InputAt","pikevm::Fsm","re_bytes::Captures","re_builder::set_bytes::RegexSetBuilder","prog::InstSplit","dfa::Transitions","re_set::unicode::SetMatchesIntoIter","re_builder::unicode::RegexBuilder","re_bytes::Match","prog::InstSave","re_set::bytes::RegexSet","re_trait::Locations","re_unicode::ReplacerRef","re_unicode::Matches","dfa::EmptyFlags","re_builder::bytes::RegexBuilder","exec::ExecReadOnly","compile::ByteClassSet","re_bytes::CaptureNames","exec::ProgramCacheInner","expand::CaptureRef","pikevm::FollowEpsilon","compile::Patch","prog::InstBytes","re_set::unicode::SetMatches","re_unicode::CaptureMatches","compile::SuffixCacheKey","re_builder::RegexOptions","backtrack::Bounded","dfa::StateFlags","re_unicode::Match","dfa::State","input::CharInput","backtrack::Job","dfa::Cache","dfa::Result","prog::EmptyLook","re_unicode::CaptureLocations","pikevm::Cache","re_trait::CaptureMatches","re_unicode::Split","re_bytes::CapturesDebug","<&T as std::fmt::Debug>","backtrack::Cache","re_bytes::ReplacerRef","re_bytes::NoExpand","exec::MatchLiteralType","re_trait::SubCapturesPosIter","exec::ExecNoSync","re_set::unicode::RegexSet","exec::MatchNfaType","dfa::TransitionsRow","re_unicode::NoExpand","compile::SuffixCache","re_bytes::Regex","compile::InstHole","dfa::Fsm","re_builder::set_unicode::RegexSetBuilder","dfa::Byte","compile::Hole","prog::InstEmptyLook","prog::Inst","error::Error","re_unicode::CapturesDebug","re_trait::Matches","sparse::SparseSet","<*const T as std::fmt::Debug>","re_bytes::Split","compile::SuffixCacheEntry","re_set::unicode::SetMatchesIter","re_unicode::Captures","literal::imp::Matcher","re_unicode::SubCaptureMatches","prog::InstChar","re_unicode::SplitN","expand::Ref","literal::imp::LiteralSearcher","re_unicode::CaptureNames","dfa::CacheInner","re_bytes::CaptureMatches","exec::ExecNoSyncStr","re_bytes::Matches","re_set::bytes::SetMatchesIter","exec::MatchType","literal::imp::SingleByteSet","pool::PoolGuard"]},"backtrack::Bounded":{"I":["input::ByteInput","input::CharInput"]},"dfa::Result":{"T":["backtrack::Job","prog::Program","prog::EmptyLook","re_unicode::CaptureNames","input::CharInput","dfa::StateFlags","re_unicode::SubCaptureMatches","re_unicode::NoExpand","re_set::bytes::RegexSet","literal::imp::Matcher","re_unicode::Match","error::Error","literal::imp::Memmem","dfa::State","exec::Exec","std::clone::impls::<impl std::clone::Clone for *const T>","exec::MatchType","re_bytes::Regex","compile::InstHole","input::Char","re_unicode::Regex","compile::SuffixCacheKey","pikevm::Cache","prog::InstSave","re_set::bytes::SetMatches","re_unicode::CaptureLocations","prog::InstChar","re_trait::Locations","re_trait::SubCapturesPosIter","prog::InstEmptyLook","re_bytes::CaptureNames","re_bytes::Match","dfa::Transitions","prog::InstSplit","prog::InstRanges","re_set::unicode::RegexSet","re_bytes::NoExpand","expand::Ref","expand::CaptureRef","input::InputAt","re_set::unicode::SetMatches","re_set::unicode::SetMatchesIter","literal::imp::LiteralSearcher","backtrack::Cache","pikevm::FollowEpsilon","re_bytes::SubCaptureMatches","prog::InstBytes","re_bytes::CaptureLocations","compile::MaybeInst","exec::MatchNfaType","exec::MatchLiteralType","dfa::Byte","re_set::bytes::SetMatchesIter","sparse::SparseSet","re_builder::RegexOptions","pikevm::Threads","input::ByteInput","literal::imp::SingleByteSet","compile::SuffixCacheEntry","dfa::EmptyFlags","dfa::Result","prog::Inst"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"pool::Pool":{"T":["std::io::error::repr_bitpacked::Repr","std::slice::Iter<'_, T>","std::sync::MutexGuard<'_, T>","std::cell::Cell<T>","std::sync::mpsc::Sender<T>","std::vec::IntoIter<T, A>","std::boxed::ThinBox<T>","std::sync::RwLockReadGuard<'_, T>","std::sys::unix::args::Args","std::collections::LinkedList<T>","std::cell::RefCell<T>","std::io::IoSlice<'a>","std::rc::Rc<T>","std::sync::mpmc::Receiver<T>","std::collections::linked_list::CursorMut<'_, T>","std::ptr::DynMetadata<Dyn>","<&T as std::marker::Send>","std::string::Drain<'_>","std::slice::IterMut<'_, T>","std::sync::mpmc::Sender<T>","std::env::Args","std::thread::JoinHandle<T>","std::task::Waker","std::collections::linked_list::IterMut<'_, T>","std::sync::atomic::AtomicPtr<T>","std::sync::mpsc::SyncSender<T>","std::sync::Arc<T>","std::sync::Weak<T>","std::collections::linked_list::Cursor<'_, T>","std::collections::linked_list::Iter<'_, T>","std::future::ResumeTy","std::collections::vec_deque::Drain<'_, T, A>","std::sync::Mutex<T>","std::sync::mpsc::Receiver<T>","std::sync::OnceLock<T>","std::ptr::NonNull<T>","std::sync::RwLockWriteGuard<'_, T>","std::ptr::Unique<T>","std::io::IoSliceMut<'a>","std::rc::Weak<T>","std::vec::Drain<'_, T, A>","std::env::ArgsOs","std::sync::RwLock<T>"]},"pool::PoolGuard":{"T":["std::slice::IterMut<'_, T>","std::env::Args","std::sync::Arc<T>","<*const T as std::marker::Send>","std::vec::IntoIter<T, A>","std::sync::mpmc::Sender<T>","std::collections::linked_list::IterMut<'_, T>","std::rc::Rc<T>","std::sync::MutexGuard<'_, T>","std::string::Drain<'_>","std::env::ArgsOs","std::sync::atomic::AtomicPtr<T>","std::collections::linked_list::Cursor<'_, T>","std::io::error::repr_bitpacked::Repr","std::future::ResumeTy","std::sync::Weak<T>","std::collections::linked_list::Iter<'_, T>","std::thread::JoinHandle<T>","std::rc::Weak<T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::mpsc::Receiver<T>","std::sync::mpsc::Sender<T>","std::collections::LinkedList<T>","std::sync::mpmc::Receiver<T>","std::sync::Mutex<T>","std::sync::RwLockWriteGuard<'_, T>","std::task::Waker","std::sync::RwLockReadGuard<'_, T>","std::ptr::Unique<T>","std::vec::Drain<'_, T, A>","std::collections::vec_deque::Drain<'_, T, A>","std::ptr::DynMetadata<Dyn>","std::sys::unix::args::Args","std::sync::mpsc::SyncSender<T>","std::boxed::ThinBox<T>","std::sync::OnceLock<T>","std::sync::RwLock<T>","std::cell::RefCell<T>","std::ptr::NonNull<T>","std::io::IoSliceMut<'a>","std::cell::Cell<T>","std::slice::Iter<'_, T>","std::io::IoSlice<'a>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt(p0, p1);
+<pikevm::Fsm<'r, I>>::fmt(p0, p1);
-----------------
src/pikevm.rs <pikevm::Cache as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Cache
+p0.clone();
+<pikevm::Cache as std::clone::Clone>::clone(p0);
+crate::<pikevm::Cache as std::clone::Clone>::clone(p0);
+<pikevm::Cache>::clone(p0);
-----------------
src/pikevm.rs <pikevm::Cache as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Cache
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pikevm::Cache as std::fmt::Debug>::fmt(p0, p1);
+crate::<pikevm::Cache as std::fmt::Debug>::fmt(p0, p1);
+<pikevm::Cache>::fmt(p0, p1);
-----------------
src/pikevm.rs <pikevm::Threads as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Threads
+p0.clone();
+<pikevm::Threads as std::clone::Clone>::clone(p0);
+crate::<pikevm::Threads as std::clone::Clone>::clone(p0);
+<pikevm::Threads>::clone(p0);
-----------------
src/pikevm.rs <pikevm::Threads as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pikevm::Threads as std::fmt::Debug>::fmt(p0, p1);
+crate::<pikevm::Threads as std::fmt::Debug>::fmt(p0, p1);
+<pikevm::Threads>::fmt(p0, p1);
-----------------
src/pikevm.rs <pikevm::FollowEpsilon as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::FollowEpsilon
+p0.clone();
+<pikevm::FollowEpsilon as std::clone::Clone>::clone(p0);
+crate::<pikevm::FollowEpsilon as std::clone::Clone>::clone(p0);
+<pikevm::FollowEpsilon>::clone(p0);
-----------------
src/pikevm.rs <pikevm::FollowEpsilon as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::FollowEpsilon
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pikevm::FollowEpsilon as std::fmt::Debug>::fmt(p0, p1);
+crate::<pikevm::FollowEpsilon as std::fmt::Debug>::fmt(p0, p1);
+<pikevm::FollowEpsilon>::fmt(p0, p1);
-----------------
src/pikevm.rs pikevm::Cache::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+pikevm::Cache::new(p0);
+crate::pikevm::Cache::new(p0);
+<pikevm::Cache>::new(p0);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::exec
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::exec":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::exec":{"I":["input::ByteInput","input::CharInput","<&'a T as input::Input>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::panic::AssertUnwindSafe<std::cell::RefCell<exec::ProgramCacheInner>>
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p4 = true; // None+bool
let mut p5 = MaybeUninit::uninit().assume_init(); // I
let mut p6 = 0usize; // None+usize
let mut p7 = 0usize; // None+usize
+pikevm::Fsm::<'r, I>::exec(p0, p1, p2, p3, p4, p5, p6, p7);
+crate::pikevm::Fsm::<'r, I>::exec(p0, p1, p2, p3, p4, p5, p6, p7);
+<pikevm::Fsm<'r, I>>::exec(p0, p1, p2, p3, p4, p5, p6, p7);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::exec_
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::exec_":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::exec_":{"I":["<&'a T as input::Input>","input::ByteInput","input::CharInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p3 = &mut [true].as_mut_slice(); // None+[bool]
let mut p4 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p5 = true; // None+bool
let mut p6 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p7 = 0usize; // None+usize
+p0.exec_(p1, p2, p3, p4, p5, p6, p7);
+pikevm::Fsm::<'r, I>::exec_(p0, p1, p2, p3, p4, p5, p6, p7);
+crate::pikevm::Fsm::<'r, I>::exec_(p0, p1, p2, p3, p4, p5, p6, p7);
+<pikevm::Fsm<'r, I>>::exec_(p0, p1, p2, p3, p4, p5, p6, p7);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::step
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::step":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::step":{"I":["input::CharInput","<&'a T as input::Input>","input::ByteInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p4 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p5 = 0usize; // None+usize
let mut p6 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p7 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.step(p1, p2, p3, p4, p5, p6, p7);
+pikevm::Fsm::<'r, I>::step(p0, p1, p2, p3, p4, p5, p6, p7);
+crate::pikevm::Fsm::<'r, I>::step(p0, p1, p2, p3, p4, p5, p6, p7);
+<pikevm::Fsm<'r, I>>::step(p0, p1, p2, p3, p4, p5, p6, p7);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::add
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::add":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::add":{"I":["input::CharInput","input::ByteInput","<&'a T as input::Input>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = 0usize; // None+usize
let mut p4 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.add(p1, p2, p3, p4);
+pikevm::Fsm::<'r, I>::add(p0, p1, p2, p3, p4);
+crate::pikevm::Fsm::<'r, I>::add(p0, p1, p2, p3, p4);
+<pikevm::Fsm<'r, I>>::add(p0, p1, p2, p3, p4);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::add_step
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::add_step":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::add_step":{"I":["<&'a T as input::Input>","input::CharInput","input::ByteInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = 0usize; // None+usize
let mut p4 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.add_step(p1, p2, p3, p4);
+pikevm::Fsm::<'r, I>::add_step(p0, p1, p2, p3, p4);
+crate::pikevm::Fsm::<'r, I>::add_step(p0, p1, p2, p3, p4);
+<pikevm::Fsm<'r, I>>::add_step(p0, p1, p2, p3, p4);
-----------------
src/pikevm.rs pikevm::Threads::new
deps:{}
candidates:{}
+pikevm::Threads::new();
+crate::pikevm::Threads::new();
+<pikevm::Threads>::new();
-----------------
src/pikevm.rs pikevm::Threads::resize
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.resize(p1, p2);
+pikevm::Threads::resize(p0, p1, p2);
+crate::pikevm::Threads::resize(p0, p1, p2);
+<pikevm::Threads>::resize(p0, p1, p2);
-----------------
src/pikevm.rs pikevm::Threads::caps
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p1 = 0usize; // None+usize
+p0.caps(p1);
+pikevm::Threads::caps(p0, p1);
+crate::pikevm::Threads::caps(p0, p1);
+<pikevm::Threads>::caps(p0, p1);
-----------------
src/pool.rs <pool::Pool<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<pool::Pool<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"backtrack::Bounded":{"I":["std::marker::Sized","std::fmt::Debug","input::Input"]},"dfa::Result":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"pikevm::Fsm":{"I":["std::marker::Sized","std::fmt::Debug","input::Input"]},"pool::Pool":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"pool::PoolGuard":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<pool::Pool<T> as std::fmt::Debug>::fmt":{"T":["exec::ExecReadOnly","re_set::unicode::RegexSet","re_unicode::SplitN","expand::Ref","re_bytes::Matches","compile::SuffixCacheEntry","pool::PoolGuard","compile::InstHole","re_bytes::Match","compile::SuffixCache","re_builder::set_bytes::RegexSetBuilder","re_trait::Matches","backtrack::Bounded","dfa::StateFlags","compile::Patch","dfa::EmptyFlags","backtrack::Cache","prog::InstSave","re_set::bytes::SetMatches","dfa::Cache","re_unicode::Captures","re_bytes::Split","re_unicode::NoExpand","prog::InstBytes","re_bytes::CaptureMatches","pikevm::Fsm","re_bytes::Captures","re_unicode::CapturesDebug","re_builder::bytes::RegexBuilder","exec::ProgramCacheInner","re_unicode::SubCaptureMatches","literal::imp::LiteralIter","literal::imp::Memmem","re_bytes::SubCaptureMatches","error::Error","dfa::CacheInner","dfa::Result","dfa::Transitions","re_unicode::ReplacerRef","<&mut T as std::fmt::Debug>","re_unicode::Regex","input::CharInput","re_bytes::CapturesDebug","re_set::unicode::SetMatches","sparse::SparseSet","re_bytes::NoExpand","re_bytes::CaptureNames","compile::Hole","literal::imp::Matcher","prog::InstRanges","re_unicode::Matches","compile::ByteClassSet","exec::Exec","prog::InstEmptyLook","re_set::bytes::SetMatchesIter","input::Char","re_unicode::CaptureMatches","re_bytes::CaptureLocations","exec::ExecNoSync","exec::MatchNfaType","expand::CaptureRef","re_bytes::ReplacerRef","prog::Program","pikevm::Cache","input::ByteInput","pikevm::Threads","re_set::unicode::SetMatchesIntoIter","re_bytes::SplitN","dfa::StateMap","re_builder::unicode::RegexBuilder","compile::SuffixCacheKey","<*const T as std::fmt::Debug>","prog::InstChar","dfa::Byte","dfa::TransitionsRow","dfa::State","re_unicode::CaptureNames","re_set::bytes::RegexSet","dfa::Fsm","re_trait::CaptureMatches","re_builder::set_unicode::RegexSetBuilder","re_bytes::Regex","re_builder::RegexOptions","re_trait::SubCapturesPosIter","exec::ExecNoSyncStr","literal::imp::SingleByteSet","re_unicode::CaptureLocations","input::InputAt","pool::Pool","pikevm::FollowEpsilon","prog::EmptyLook","exec::MatchLiteralType","backtrack::Job","re_set::unicode::SetMatchesIter","re_set::bytes::SetMatchesIntoIter","re_unicode::Match","re_trait::Locations","compile::MaybeInst","prog::InstSplit","literal::imp::LiteralSearcher","exec::MatchType","prog::Inst","re_unicode::Split"]},"backtrack::Bounded":{"I":["input::CharInput","input::ByteInput"]},"dfa::Result":{"T":["compile::InstHole","re_set::unicode::SetMatchesIter","dfa::State","re_unicode::CaptureLocations","exec::Exec","expand::Ref","dfa::Transitions","prog::InstSplit","exec::MatchType","re_unicode::Match","re_set::unicode::SetMatches","dfa::Byte","dfa::EmptyFlags","re_bytes::CaptureNames","backtrack::Cache","re_trait::SubCapturesPosIter","prog::InstEmptyLook","prog::InstBytes","re_unicode::CaptureNames","compile::SuffixCacheEntry","prog::Inst","pikevm::Threads","re_unicode::Regex","re_bytes::CaptureLocations","exec::MatchNfaType","re_unicode::NoExpand","<*const T as std::fmt::Debug>","compile::SuffixCacheKey","input::ByteInput","prog::Program","literal::imp::SingleByteSet","re_trait::Locations","re_set::bytes::RegexSet","re_bytes::SubCaptureMatches","re_builder::RegexOptions","pikevm::Cache","dfa::StateFlags","re_set::unicode::RegexSet","pikevm::FollowEpsilon","compile::MaybeInst","input::CharInput","literal::imp::Memmem","re_unicode::SubCaptureMatches","backtrack::Job","literal::imp::Matcher","literal::imp::LiteralSearcher","exec::MatchLiteralType","error::Error","expand::CaptureRef","re_bytes::Match","prog::EmptyLook","input::Char","re_bytes::NoExpand","input::InputAt","re_bytes::Regex","re_set::bytes::SetMatches","sparse::SparseSet","prog::InstChar","prog::InstRanges","dfa::Result","re_set::bytes::SetMatchesIter","prog::InstSave"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"pool::Pool":{"T":["std::collections::linked_list::CursorMut<'_, T>","std::boxed::ThinBox<T>","std::env::ArgsOs","std::cell::RefCell<T>","std::collections::linked_list::Iter<'_, T>","std::vec::Drain<'_, T, A>","std::ptr::Unique<T>","std::slice::IterMut<'_, T>","std::io::IoSlice<'a>","std::sync::mpsc::Sender<T>","std::sync::Arc<T>","std::rc::Rc<T>","std::sync::RwLockReadGuard<'_, T>","std::sys::unix::args::Args","std::sync::mpsc::SyncSender<T>","std::sync::OnceLock<T>","std::collections::linked_list::IterMut<'_, T>","std::io::IoSliceMut<'a>","std::task::Waker","std::io::error::repr_bitpacked::Repr","std::sync::Weak<T>","std::cell::Cell<T>","std::slice::Iter<'_, T>","std::sync::atomic::AtomicPtr<T>","std::sync::mpmc::Receiver<T>","std::collections::linked_list::Cursor<'_, T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::mpmc::Sender<T>","std::rc::Weak<T>","std::vec::IntoIter<T, A>","std::string::Drain<'_>","std::sync::RwLock<T>","std::ptr::DynMetadata<Dyn>","std::sync::Mutex<T>","std::env::Args","std::ptr::NonNull<T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::MutexGuard<'_, T>","<*const T as std::fmt::Debug>","std::thread::JoinHandle<T>","std::collections::LinkedList<T>","std::future::ResumeTy","std::sync::mpsc::Receiver<T>"]},"pool::PoolGuard":{"T":["std::sync::RwLock<T>","std::sys::unix::args::Args","std::io::IoSliceMut<'a>","<*const T as std::fmt::Debug>","std::future::ResumeTy","std::sync::mpsc::Receiver<T>","std::cell::RefCell<T>","std::sync::mpsc::Sender<T>","std::ptr::DynMetadata<Dyn>","std::env::ArgsOs","std::ptr::NonNull<T>","std::sync::RwLockWriteGuard<'_, T>","std::string::Drain<'_>","std::task::Waker","std::collections::linked_list::IterMut<'_, T>","std::rc::Weak<T>","std::ptr::Unique<T>","std::sync::Arc<T>","std::sync::Mutex<T>","std::sync::atomic::AtomicPtr<T>","std::sync::OnceLock<T>","<*mut T as std::marker::Send>","std::sync::mpsc::SyncSender<T>","std::io::IoSlice<'a>","std::vec::Drain<'_, T, A>","std::thread::JoinHandle<T>","std::sync::RwLockReadGuard<'_, T>","std::rc::Rc<T>","std::sync::Weak<T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::MutexGuard<'_, T>","std::env::Args","std::collections::LinkedList<T>","std::collections::linked_list::CursorMut<'_, T>","std::slice::IterMut<'_, T>","std::cell::Cell<T>","std::io::error::repr_bitpacked::Repr","std::sync::mpmc::Sender<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::mpmc::Receiver<T>","std::vec::IntoIter<T, A>","std::boxed::ThinBox<T>","std::slice::Iter<'_, T>","std::collections::linked_list::Iter<'_, T>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pool::Pool<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pool::Pool<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<pool::Pool<T> as std::fmt::Debug>::fmt(p0, p1);
+<pool::Pool<T>>::fmt(p0, p1);
-----------------
src/pool.rs <pool::PoolGuard<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<pool::PoolGuard<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<pool::PoolGuard<'a, T> as std::fmt::Debug>::fmt":{"T":["std::collections::LinkedList<T>","std::sys::unix::args::Args","std::sync::mpsc::SyncSender<T>","std::sync::OnceLock<T>","std::env::Args","std::boxed::ThinBox<T>","std::collections::linked_list::Iter<'_, T>","std::slice::Iter<'_, T>","std::sync::mpsc::Sender<T>","std::sync::mpmc::Sender<T>","std::collections::linked_list::CursorMut<'_, T>","std::io::IoSlice<'a>","std::ptr::NonNull<T>","std::env::ArgsOs","std::sync::RwLockReadGuard<'_, T>","std::rc::Weak<T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::RwLock<T>","std::future::ResumeTy","std::ptr::DynMetadata<Dyn>","<*mut T as std::fmt::Debug>","std::sync::Arc<T>","std::rc::Rc<T>","std::task::Waker","std::sync::Mutex<T>","std::cell::RefCell<T>","std::io::IoSliceMut<'a>","std::collections::linked_list::IterMut<'_, T>","std::sync::Weak<T>","std::thread::JoinHandle<T>","std::sync::MutexGuard<'_, T>","std::vec::Drain<'_, T, A>","std::ptr::Unique<T>","std::io::error::repr_bitpacked::Repr","std::string::Drain<'_>","<*const T as std::marker::Send>","std::sync::atomic::AtomicPtr<T>","std::slice::IterMut<'_, T>","std::cell::Cell<T>","<*const T as std::fmt::Debug>","std::sync::mpsc::Receiver<T>","std::collections::linked_list::Cursor<'_, T>","std::vec::IntoIter<T, A>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::mpmc::Receiver<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pool::PoolGuard<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pool::PoolGuard<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<pool::PoolGuard<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<pool::PoolGuard<'a, T>>::fmt(p0, p1);
-----------------
src/pool.rs pool::Pool::<T>::new
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::new":{"T":["std::marker::Sized","std::marker::Send"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::new":{"T":["std::sync::RwLockReadGuard<'_, T>","std::slice::IterMut<'_, T>","std::env::ArgsOs","std::collections::vec_deque::Drain<'_, T, A>","std::vec::IntoIter<T, A>","std::rc::Rc<T>","std::sys::unix::thread::Thread","std::collections::linked_list::CursorMut<'_, T>","std::sync::mpsc::SyncSender<T>","std::task::Waker","std::cell::Cell<T>","std::collections::linked_list::Iter<'_, T>","std::vec::Drain<'_, T, A>","std::collections::LinkedList<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::mpmc::Receiver<T>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::collections::linked_list::IterMut<'_, T>","std::sync::mpsc::Sender<T>","std::sys_common::net::LookupHost","std::sync::RwLockWriteGuard<'_, T>","std::ptr::NonNull<T>","std::rc::Weak<T>","std::string::Drain<'_>","std::sys_common::remutex::ReentrantMutex<T>","std::slice::RChunksMut<'_, T>","std::sys::unix::fs::Dir","<*mut T as std::marker::Send>","std::io::error::repr_bitpacked::Repr","std::sync::Mutex<T>","std::sync::MutexGuard<'_, T>","std::sys::unix::args::Args","std::io::IoSlice<'a>","std::sys::unix::os::Env","std::sync::RwLock<T>","std::thread::JoinHandle<T>","std::slice::ChunksMut<'_, T>","std::env::Args","std::sys::unix::process::process_common::Argv","std::slice::ChunksExactMut<'_, T>","std::io::IoSliceMut<'a>","std::future::ResumeTy","std::sync::Weak<T>","<*const T as std::marker::Send>","std::backtrace_rs::backtrace::libunwind::Frame","std::slice::Iter<'_, T>","std::boxed::ThinBox<T>","std::ptr::Unique<T>","std::slice::RChunksExactMut<'_, T>","std::sync::mpsc::Receiver<T>","std::sync::OnceLock<T>","std::sync::mpmc::Sender<T>","std::sync::Arc<T>","std::ptr::DynMetadata<Dyn>","std::sync::atomic::AtomicPtr<T>","std::cell::RefCell<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::boxed::Box<(dyn std::ops::Fn() -> T + std::marker::Send + std::marker::Sync + std::panic::RefUnwindSafe + std::panic::UnwindSafe + 'static)>
+pool::Pool::<T>::new(p0);
+crate::pool::Pool::<T>::new(p0);
+<pool::Pool<T>>::new(p0);
-----------------
src/pool.rs pool::Pool::<T>::get
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::get":{"T":["std::marker::Send","std::marker::Sized"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::get":{"T":["std::task::Waker","std::string::Drain<'_>","<*mut T as std::marker::Send>","std::sync::RwLockWriteGuard<'_, T>","std::thread::JoinHandle<T>","<*const T as std::marker::Send>","std::ptr::DynMetadata<Dyn>","std::slice::RChunksExactMut<'_, T>","std::sync::Mutex<T>","std::collections::linked_list::Iter<'_, T>","std::rc::Weak<T>","std::sys_common::remutex::ReentrantMutex<T>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::slice::ChunksExactMut<'_, T>","std::env::Args","std::sync::mpmc::Sender<T>","std::sync::Arc<T>","std::sync::mpmc::Receiver<T>","std::sync::OnceLock<T>","std::sys::unix::thread::Thread","std::backtrace_rs::backtrace::libunwind::Frame","std::vec::IntoIter<T, A>","std::io::error::repr_bitpacked::Repr","std::vec::Drain<'_, T, A>","std::sys::unix::process::process_common::Argv","std::sync::mpsc::Sender<T>","std::ptr::Unique<T>","std::slice::IterMut<'_, T>","std::slice::RChunksMut<'_, T>","std::sync::MutexGuard<'_, T>","std::cell::Cell<T>","std::cell::RefCell<T>","std::sys::unix::os::Env","std::sync::mpsc::Receiver<T>","std::sys::unix::fs::Dir","std::env::ArgsOs","std::future::ResumeTy","std::io::IoSlice<'a>","std::sync::RwLock<T>","std::collections::linked_list::IterMut<'_, T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::atomic::AtomicPtr<T>","std::collections::linked_list::Cursor<'_, T>","std::rc::Rc<T>","std::sync::mpsc::SyncSender<T>","std::sys::unix::args::Args","std::collections::vec_deque::Drain<'_, T, A>","std::io::IoSliceMut<'a>","std::sys_common::net::LookupHost","std::slice::Iter<'_, T>","std::sync::Weak<T>","std::slice::ChunksMut<'_, T>","std::collections::LinkedList<T>","std::boxed::ThinBox<T>","std::sync::RwLockReadGuard<'_, T>","std::ptr::NonNull<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pool::Pool<T>
+p0.get();
+pool::Pool::<T>::get(p0);
+crate::pool::Pool::<T>::get(p0);
+<pool::Pool<T>>::get(p0);
-----------------
src/pool.rs pool::Pool::<T>::get_slow
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::get_slow":{"T":["std::marker::Send","std::marker::Sized"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::get_slow":{"T":["std::rc::Weak<T>","std::io::IoSliceMut<'a>","std::collections::vec_deque::Drain<'_, T, A>","std::slice::IterMut<'_, T>","std::vec::IntoIter<T, A>","std::ptr::NonNull<T>","std::sys::unix::thread::Thread","std::collections::linked_list::Cursor<'_, T>","std::sync::mpmc::Sender<T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::mpmc::Receiver<T>","std::sync::RwLock<T>","std::task::Waker","std::sys::unix::fs::Dir","std::sys_common::remutex::ReentrantMutex<T>","std::slice::ChunksExactMut<'_, T>","std::sys::unix::os::Env","<*const T as std::marker::Send>","std::sync::MutexGuard<'_, T>","std::slice::RChunksMut<'_, T>","std::env::Args","std::sys_common::net::LookupHost","std::sync::atomic::AtomicPtr<T>","std::sync::RwLockReadGuard<'_, T>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","<*mut T as std::marker::Send>","std::collections::LinkedList<T>","std::ptr::Unique<T>","std::thread::JoinHandle<T>","std::sync::mpsc::SyncSender<T>","std::ptr::DynMetadata<Dyn>","std::io::IoSlice<'a>","std::collections::linked_list::IterMut<'_, T>","std::cell::RefCell<T>","std::sync::mpsc::Receiver<T>","std::boxed::ThinBox<T>","std::sys::unix::process::process_common::Argv","std::rc::Rc<T>","std::env::ArgsOs","std::slice::Iter<'_, T>","std::slice::RChunksExactMut<'_, T>","std::collections::linked_list::CursorMut<'_, T>","std::io::error::repr_bitpacked::Repr","std::sync::Weak<T>","std::sys::unix::args::Args","std::sync::Mutex<T>","std::backtrace_rs::backtrace::libunwind::Frame","std::vec::Drain<'_, T, A>","std::sync::Arc<T>","std::string::Drain<'_>","std::cell::Cell<T>","std::slice::ChunksMut<'_, T>","std::collections::linked_list::Iter<'_, T>","std::future::ResumeTy","std::sync::OnceLock<T>","std::sync::mpsc::Sender<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pool::Pool<T>
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.get_slow(p1, p2);
+pool::Pool::<T>::get_slow(p0, p1, p2);
+crate::pool::Pool::<T>::get_slow(p0, p1, p2);
+<pool::Pool<T>>::get_slow(p0, p1, p2);
-----------------
src/pool.rs pool::Pool::<T>::put
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::put":{"T":["std::marker::Sized","std::marker::Send"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::put":{"T":["std::rc::Rc<T>","std::env::Args","std::sys::unix::process::process_common::Argv","std::sys::unix::thread::Thread","std::slice::ChunksExactMut<'_, T>","std::sync::mpmc::Sender<T>","std::rc::Weak<T>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::collections::vec_deque::Drain<'_, T, A>","std::slice::RChunksMut<'_, T>","std::slice::Iter<'_, T>","std::cell::RefCell<T>","std::sync::RwLock<T>","std::sync::Arc<T>","std::sys::unix::fs::Dir","std::sync::mpsc::Sender<T>","std::sys_common::net::LookupHost","std::boxed::ThinBox<T>","std::sys_common::remutex::ReentrantMutex<T>","std::future::ResumeTy","std::sync::mpmc::Receiver<T>","std::sync::Weak<T>","std::collections::linked_list::Iter<'_, T>","<*mut T as std::marker::Send>","std::slice::IterMut<'_, T>","std::ptr::NonNull<T>","std::ptr::DynMetadata<Dyn>","std::sys::unix::os::Env","std::slice::RChunksExactMut<'_, T>","std::string::Drain<'_>","std::collections::linked_list::CursorMut<'_, T>","std::thread::JoinHandle<T>","<&T as std::marker::Send>","std::collections::LinkedList<T>","std::io::IoSlice<'a>","std::io::error::repr_bitpacked::Repr","std::sync::RwLockReadGuard<'_, T>","std::sync::OnceLock<T>","std::collections::linked_list::IterMut<'_, T>","std::sync::mpsc::Receiver<T>","std::backtrace_rs::backtrace::libunwind::Frame","std::sync::MutexGuard<'_, T>","std::sys::unix::args::Args","std::env::ArgsOs","std::sync::RwLockWriteGuard<'_, T>","std::ptr::Unique<T>","std::cell::Cell<T>","std::io::IoSliceMut<'a>","std::vec::IntoIter<T, A>","std::slice::ChunksMut<'_, T>","std::sync::mpsc::SyncSender<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::atomic::AtomicPtr<T>","std::vec::Drain<'_, T, A>","std::sync::Mutex<T>","std::task::Waker"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pool::Pool<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::boxed::Box<T>
+p0.put(p1);
+pool::Pool::<T>::put(p0, p1);
+crate::pool::Pool::<T>::put(p0, p1);
+<pool::Pool<T>>::put(p0, p1);
-----------------
src/pool.rs pool::Pool::<T>::guard_owned
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::guard_owned":{"T":["std::marker::Sized","std::marker::Send"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::guard_owned":{"T":["std::io::error::repr_bitpacked::Repr","std::sync::mpsc::SyncSender<T>","std::slice::RChunksExactMut<'_, T>","std::cell::RefCell<T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::OnceLock<T>","std::backtrace_rs::backtrace::libunwind::Frame","std::slice::ChunksExactMut<'_, T>","<*const T as std::marker::Send>","std::slice::Iter<'_, T>","std::sync::mpsc::Sender<T>","std::cell::Cell<T>","std::sys::unix::args::Args","std::thread::JoinHandle<T>","std::sys::unix::process::process_common::Argv","std::collections::vec_deque::Drain<'_, T, A>","std::ptr::NonNull<T>","std::env::Args","std::ptr::DynMetadata<Dyn>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::sync::atomic::AtomicPtr<T>","std::slice::ChunksMut<'_, T>","std::sync::Mutex<T>","std::sync::Arc<T>","std::sync::mpmc::Sender<T>","std::sys_common::remutex::ReentrantMutex<T>","std::ptr::Unique<T>","std::sys_common::net::LookupHost","std::rc::Rc<T>","std::sys::unix::fs::Dir","std::io::IoSlice<'a>","std::collections::LinkedList<T>","std::sys::unix::thread::Thread","std::sync::Weak<T>","std::sync::RwLockReadGuard<'_, T>","std::sys::unix::os::Env","std::sync::RwLock<T>","std::slice::RChunksMut<'_, T>","std::collections::linked_list::IterMut<'_, T>","std::collections::linked_list::CursorMut<'_, T>","std::vec::Drain<'_, T, A>","std::io::IoSliceMut<'a>","std::sync::mpmc::Receiver<T>","std::env::ArgsOs","<*mut T as std::marker::Send>","std::sync::mpsc::Receiver<T>","std::future::ResumeTy","std::collections::linked_list::Cursor<'_, T>","std::collections::linked_list::Iter<'_, T>","std::string::Drain<'_>","std::task::Waker","std::boxed::ThinBox<T>","std::vec::IntoIter<T, A>","std::slice::IterMut<'_, T>","std::rc::Weak<T>","std::sync::MutexGuard<'_, T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pool::Pool<T>
+p0.guard_owned();
+pool::Pool::<T>::guard_owned(p0);
+crate::pool::Pool::<T>::guard_owned(p0);
+<pool::Pool<T>>::guard_owned(p0);
-----------------
src/pool.rs pool::Pool::<T>::guard_stack
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::guard_stack":{"T":["std::marker::Sized","std::marker::Send"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::Pool::<T>::guard_stack":{"T":["std::cell::Cell<T>","std::sync::mpmc::Sender<T>","std::env::ArgsOs","std::backtrace_rs::backtrace::libunwind::Frame","std::sync::RwLockReadGuard<'_, T>","std::collections::LinkedList<T>","std::collections::vec_deque::Drain<'_, T, A>","std::slice::ChunksMut<'_, T>","std::string::Drain<'_>","std::slice::Iter<'_, T>","std::env::Args","std::sync::mpsc::Sender<T>","std::boxed::ThinBox<T>","std::sys::unix::thread::Thread","std::future::ResumeTy","std::ptr::Unique<T>","std::sys::unix::os::Env","std::thread::JoinHandle<T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::OnceLock<T>","std::sync::Mutex<T>","std::sync::MutexGuard<'_, T>","std::sys::unix::args::Args","std::ptr::NonNull<T>","std::collections::linked_list::Iter<'_, T>","std::task::Waker","std::sync::Weak<T>","std::rc::Rc<T>","std::cell::RefCell<T>","std::sync::atomic::AtomicPtr<T>","std::slice::ChunksExactMut<'_, T>","std::sync::Arc<T>","std::sync::mpmc::Receiver<T>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","<*const T as std::marker::Send>","std::slice::RChunksMut<'_, T>","std::io::IoSlice<'a>","std::collections::linked_list::Cursor<'_, T>","std::slice::RChunksExactMut<'_, T>","std::ptr::DynMetadata<Dyn>","std::slice::IterMut<'_, T>","std::sys::unix::process::process_common::Argv","std::sync::RwLock<T>","std::collections::linked_list::CursorMut<'_, T>","std::sys::unix::fs::Dir","<&T as std::marker::Send>","std::vec::IntoIter<T, A>","std::rc::Weak<T>","std::vec::Drain<'_, T, A>","std::io::IoSliceMut<'a>","std::sync::mpsc::SyncSender<T>","std::io::error::repr_bitpacked::Repr","std::sys_common::net::LookupHost","std::sync::mpsc::Receiver<T>","std::collections::linked_list::IterMut<'_, T>","std::sys_common::remutex::ReentrantMutex<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pool::Pool<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::boxed::Box<T>
+p0.guard_stack(p1);
+pool::Pool::<T>::guard_stack(p0, p1);
+crate::pool::Pool::<T>::guard_stack(p0, p1);
+<pool::Pool<T>>::guard_stack(p0, p1);
-----------------
src/pool.rs pool::PoolGuard::<'a, T>::value
'a
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::PoolGuard::<'a, T>::value":{"T":["std::marker::Sized","std::marker::Send"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"pool::PoolGuard::<'a, T>::value":{"T":["std::slice::RChunksMut<'_, T>","std::vec::Drain<'_, T, A>","<*mut T as std::marker::Send>","std::sync::Mutex<T>","std::io::IoSlice<'a>","std::task::Waker","std::future::ResumeTy","std::sys::unix::args::Args","std::sys_common::remutex::ReentrantMutex<T>","std::io::error::repr_bitpacked::Repr","std::sys::unix::thread::Thread","std::sync::mpsc::Sender<T>","std::ptr::Unique<T>","std::slice::IterMut<'_, T>","std::ptr::DynMetadata<Dyn>","std::ptr::NonNull<T>","std::slice::ChunksMut<'_, T>","std::collections::linked_list::Cursor<'_, T>","std::sync::mpsc::Receiver<T>","std::sync::Arc<T>","std::collections::linked_list::IterMut<'_, T>","std::collections::linked_list::Iter<'_, T>","std::thread::JoinHandle<T>","std::sync::RwLockReadGuard<'_, T>","std::env::ArgsOs","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::sync::Weak<T>","<&T as std::marker::Send>","std::slice::ChunksExactMut<'_, T>","std::rc::Rc<T>","std::sync::RwLock<T>","std::sync::mpsc::SyncSender<T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::RwLockWriteGuard<'_, T>","std::sync::mpmc::Sender<T>","std::string::Drain<'_>","std::sync::atomic::AtomicPtr<T>","std::slice::RChunksExactMut<'_, T>","std::io::IoSliceMut<'a>","std::sys::unix::os::Env","std::cell::Cell<T>","std::collections::LinkedList<T>","std::cell::RefCell<T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::MutexGuard<'_, T>","std::backtrace_rs::backtrace::libunwind::Frame","std::vec::IntoIter<T, A>","std::boxed::ThinBox<T>","std::sys::unix::fs::Dir","std::sync::OnceLock<T>","std::slice::Iter<'_, T>","std::sys_common::net::LookupHost","std::env::Args","std::rc::Weak<T>","std::sync::mpmc::Receiver<T>","std::sys::unix::process::process_common::Argv"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pool::PoolGuard<'a, T>
+p0.value();
+pool::PoolGuard::<'a, T>::value(p0);
+crate::pool::PoolGuard::<'a, T>::value(p0);
+<pool::PoolGuard<'a, T>>::value(p0);
-----------------
src/pool.rs <pool::PoolGuard<'a, T> as std::ops::Drop>::drop
'a
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<pool::PoolGuard<'a, T> as std::ops::Drop>::drop":{"T":["std::marker::Sized","std::marker::Send"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"<pool::PoolGuard<'a, T> as std::ops::Drop>::drop":{"T":["std::sys::unix::thread::Thread","std::ptr::DynMetadata<Dyn>","std::sync::Arc<T>","std::sync::MutexGuard<'_, T>","std::vec::IntoIter<T, A>","std::future::ResumeTy","std::io::IoSliceMut<'a>","std::slice::ChunksExactMut<'_, T>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::boxed::ThinBox<T>","std::sync::mpsc::Sender<T>","std::rc::Weak<T>","std::sync::mpsc::SyncSender<T>","std::collections::vec_deque::Drain<'_, T, A>","std::backtrace_rs::backtrace::libunwind::Frame","std::collections::linked_list::Cursor<'_, T>","std::collections::linked_list::Iter<'_, T>","std::io::IoSlice<'a>","std::collections::linked_list::IterMut<'_, T>","std::sys_common::net::LookupHost","std::collections::linked_list::CursorMut<'_, T>","std::vec::Drain<'_, T, A>","std::sys::unix::process::process_common::Argv","std::slice::ChunksMut<'_, T>","std::slice::RChunksExactMut<'_, T>","std::sys::unix::os::Env","std::sync::mpmc::Sender<T>","std::sync::Weak<T>","std::string::Drain<'_>","std::sys::unix::fs::Dir","std::slice::Iter<'_, T>","std::ptr::Unique<T>","std::ptr::NonNull<T>","std::env::Args","std::sync::OnceLock<T>","std::sys::unix::args::Args","std::io::error::repr_bitpacked::Repr","<*mut T as std::marker::Send>","std::sync::RwLock<T>","std::slice::RChunksMut<'_, T>","std::slice::IterMut<'_, T>","std::cell::Cell<T>","std::thread::JoinHandle<T>","std::sync::RwLockReadGuard<'_, T>","std::sync::atomic::AtomicPtr<T>","std::sync::mpmc::Receiver<T>","std::rc::Rc<T>","std::task::Waker","std::sync::Mutex<T>","std::env::ArgsOs","std::sync::RwLockWriteGuard<'_, T>","std::collections::LinkedList<T>","std::sync::mpsc::Receiver<T>","<*const T as std::marker::Send>","std::cell::RefCell<T>","std::sys_common::remutex::ReentrantMutex<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pool::PoolGuard<'a, T>
+p0.drop();
+<pool::PoolGuard<'a, T> as std::ops::Drop>::drop(p0);
+crate::<pool::PoolGuard<'a, T> as std::ops::Drop>::drop(p0);
+<pool::PoolGuard<'a, T>>::drop(p0);
-----------------
src/prog.rs <prog::Program as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.clone();
+<prog::Program as std::clone::Clone>::clone(p0);
+crate::<prog::Program as std::clone::Clone>::clone(p0);
+<prog::Program>::clone(p0);
-----------------
src/prog.rs prog::Program::new
deps:{}
candidates:{}
+prog::Program::new();
+crate::prog::Program::new();
+<prog::Program>::new();
-----------------
src/prog.rs prog::Program::skip
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = 0usize; // None+usize
+p0.skip(p1);
+prog::Program::skip(p0, p1);
+crate::prog::Program::skip(p0, p1);
+<prog::Program>::skip(p0, p1);
-----------------
src/prog.rs prog::Program::leads_to_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = 0usize; // None+usize
+p0.leads_to_match(p1);
+prog::Program::leads_to_match(p0, p1);
+crate::prog::Program::leads_to_match(p0, p1);
+<prog::Program>::leads_to_match(p0, p1);
-----------------
src/prog.rs prog::Program::needs_dotstar
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.needs_dotstar();
+prog::Program::needs_dotstar(p0);
+crate::prog::Program::needs_dotstar(p0);
+<prog::Program>::needs_dotstar(p0);
-----------------
src/prog.rs prog::Program::uses_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.uses_bytes();
+prog::Program::uses_bytes(p0);
+crate::prog::Program::uses_bytes(p0);
+<prog::Program>::uses_bytes(p0);
-----------------
src/prog.rs prog::Program::only_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.only_utf8();
+prog::Program::only_utf8(p0);
+crate::prog::Program::only_utf8(p0);
+<prog::Program>::only_utf8(p0);
-----------------
src/prog.rs prog::Program::approximate_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.approximate_size();
+prog::Program::approximate_size(p0);
+crate::prog::Program::approximate_size(p0);
+<prog::Program>::approximate_size(p0);
-----------------
src/prog.rs <prog::Program as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.deref();
+<prog::Program as std::ops::Deref>::deref(p0);
+crate::<prog::Program as std::ops::Deref>::deref(p0);
+<prog::Program>::deref(p0);
-----------------
src/prog.rs <prog::Program as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::Program as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::Program as std::fmt::Debug>::fmt(p0, p1);
+<prog::Program>::fmt(p0, p1);
-----------------
src/prog.rs <&'a prog::Program as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.into_iter();
+<&'a prog::Program as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a prog::Program as std::iter::IntoIterator>::into_iter(p0);
+<&'a prog::Program>::into_iter(p0);
-----------------
src/prog.rs <prog::Inst as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Inst
+p0.clone();
+<prog::Inst as std::clone::Clone>::clone(p0);
+crate::<prog::Inst as std::clone::Clone>::clone(p0);
+<prog::Inst>::clone(p0);
-----------------
src/prog.rs <prog::Inst as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Inst
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::Inst as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::Inst as std::fmt::Debug>::fmt(p0, p1);
+<prog::Inst>::fmt(p0, p1);
-----------------
src/prog.rs prog::Inst::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Inst
+p0.is_match();
+prog::Inst::is_match(p0);
+crate::prog::Inst::is_match(p0);
+<prog::Inst>::is_match(p0);
-----------------
src/prog.rs <prog::InstSave as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstSave
+p0.clone();
+<prog::InstSave as std::clone::Clone>::clone(p0);
+crate::<prog::InstSave as std::clone::Clone>::clone(p0);
+<prog::InstSave>::clone(p0);
-----------------
src/prog.rs <prog::InstSave as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstSave
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstSave as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstSave as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstSave>::fmt(p0, p1);
-----------------
src/prog.rs <prog::InstSplit as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstSplit
+p0.clone();
+<prog::InstSplit as std::clone::Clone>::clone(p0);
+crate::<prog::InstSplit as std::clone::Clone>::clone(p0);
+<prog::InstSplit>::clone(p0);
-----------------
src/prog.rs <prog::InstSplit as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstSplit
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstSplit as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstSplit as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstSplit>::fmt(p0, p1);
-----------------
src/prog.rs <prog::InstEmptyLook as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.clone();
+<prog::InstEmptyLook as std::clone::Clone>::clone(p0);
+crate::<prog::InstEmptyLook as std::clone::Clone>::clone(p0);
+<prog::InstEmptyLook>::clone(p0);
-----------------
src/prog.rs <prog::InstEmptyLook as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstEmptyLook as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstEmptyLook as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstEmptyLook>::fmt(p0, p1);
-----------------
src/prog.rs <prog::EmptyLook as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
+p0.clone();
+<prog::EmptyLook as std::clone::Clone>::clone(p0);
+crate::<prog::EmptyLook as std::clone::Clone>::clone(p0);
+<prog::EmptyLook>::clone(p0);
-----------------
src/prog.rs <prog::EmptyLook as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::EmptyLook as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::EmptyLook as std::fmt::Debug>::fmt(p0, p1);
+<prog::EmptyLook>::fmt(p0, p1);
-----------------
src/prog.rs <prog::EmptyLook as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
let mut p1 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
+p0.eq(p1);
+<prog::EmptyLook as std::cmp::PartialEq>::eq(p0, p1);
+crate::<prog::EmptyLook as std::cmp::PartialEq>::eq(p0, p1);
+<prog::EmptyLook>::eq(p0, p1);
-----------------
src/prog.rs <prog::EmptyLook as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
+p0.assert_receiver_is_total_eq();
+<prog::EmptyLook as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<prog::EmptyLook as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<prog::EmptyLook>::assert_receiver_is_total_eq(p0);
-----------------
src/prog.rs <prog::InstChar as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstChar
+p0.clone();
+<prog::InstChar as std::clone::Clone>::clone(p0);
+crate::<prog::InstChar as std::clone::Clone>::clone(p0);
+<prog::InstChar>::clone(p0);
-----------------
src/prog.rs <prog::InstChar as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstChar
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstChar as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstChar as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstChar>::fmt(p0, p1);
-----------------
src/prog.rs <prog::InstRanges as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstRanges
+p0.clone();
+<prog::InstRanges as std::clone::Clone>::clone(p0);
+crate::<prog::InstRanges as std::clone::Clone>::clone(p0);
+<prog::InstRanges>::clone(p0);
-----------------
src/prog.rs <prog::InstRanges as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstRanges
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstRanges as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstRanges as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstRanges>::fmt(p0, p1);
-----------------
src/prog.rs prog::InstRanges::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstRanges
let mut p1 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.matches(p1);
+prog::InstRanges::matches(p0, p1);
+crate::prog::InstRanges::matches(p0, p1);
+<prog::InstRanges>::matches(p0, p1);
-----------------
src/prog.rs prog::InstRanges::num_chars
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstRanges
+p0.num_chars();
+prog::InstRanges::num_chars(p0);
+crate::prog::InstRanges::num_chars(p0);
+<prog::InstRanges>::num_chars(p0);
-----------------
src/prog.rs <prog::InstBytes as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstBytes
+p0.clone();
+<prog::InstBytes as std::clone::Clone>::clone(p0);
+crate::<prog::InstBytes as std::clone::Clone>::clone(p0);
+<prog::InstBytes>::clone(p0);
-----------------
src/prog.rs <prog::InstBytes as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstBytes
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstBytes as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstBytes as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstBytes>::fmt(p0, p1);
-----------------
src/prog.rs prog::InstBytes::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstBytes
let mut p1 = 0u8; // None+u8
+p0.matches(p1);
+prog::InstBytes::matches(p0, p1);
+crate::prog::InstBytes::matches(p0, p1);
+<prog::InstBytes>::matches(p0, p1);
-----------------
src/re_builder.rs <re_builder::RegexOptions as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::RegexOptions
+p0.clone();
+<re_builder::RegexOptions as std::clone::Clone>::clone(p0);
+crate::<re_builder::RegexOptions as std::clone::Clone>::clone(p0);
+<re_builder::RegexOptions>::clone(p0);
-----------------
src/re_builder.rs <re_builder::RegexOptions as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::RegexOptions
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::RegexOptions as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::RegexOptions as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::RegexOptions>::fmt(p0, p1);
-----------------
src/re_builder.rs <re_builder::RegexOptions as std::default::Default>::default
deps:{}
candidates:{}
+<re_builder::RegexOptions as std::default::Default>::default();
+crate::<re_builder::RegexOptions as std::default::Default>::default();
+<re_builder::RegexOptions>::default();
-----------------
src/re_builder.rs <re_builder::bytes::RegexBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::bytes::RegexBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::bytes::RegexBuilder as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::bytes::RegexBuilder>::fmt(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_builder::bytes::RegexBuilder::new(&p0);
+crate::re_builder::bytes::RegexBuilder::new(&p0);
+<re_builder::bytes::RegexBuilder>::new(&p0);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
+p0.build();
+re_builder::bytes::RegexBuilder::build(p0);
+crate::re_builder::bytes::RegexBuilder::build(p0);
+<re_builder::bytes::RegexBuilder>::build(p0);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+re_builder::bytes::RegexBuilder::case_insensitive(p0, p1);
+crate::re_builder::bytes::RegexBuilder::case_insensitive(p0, p1);
+<re_builder::bytes::RegexBuilder>::case_insensitive(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+re_builder::bytes::RegexBuilder::multi_line(p0, p1);
+crate::re_builder::bytes::RegexBuilder::multi_line(p0, p1);
+<re_builder::bytes::RegexBuilder>::multi_line(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+re_builder::bytes::RegexBuilder::dot_matches_new_line(p0, p1);
+crate::re_builder::bytes::RegexBuilder::dot_matches_new_line(p0, p1);
+<re_builder::bytes::RegexBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+re_builder::bytes::RegexBuilder::swap_greed(p0, p1);
+crate::re_builder::bytes::RegexBuilder::swap_greed(p0, p1);
+<re_builder::bytes::RegexBuilder>::swap_greed(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+re_builder::bytes::RegexBuilder::ignore_whitespace(p0, p1);
+crate::re_builder::bytes::RegexBuilder::ignore_whitespace(p0, p1);
+<re_builder::bytes::RegexBuilder>::ignore_whitespace(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+re_builder::bytes::RegexBuilder::unicode(p0, p1);
+crate::re_builder::bytes::RegexBuilder::unicode(p0, p1);
+<re_builder::bytes::RegexBuilder>::unicode(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+re_builder::bytes::RegexBuilder::octal(p0, p1);
+crate::re_builder::bytes::RegexBuilder::octal(p0, p1);
+<re_builder::bytes::RegexBuilder>::octal(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+re_builder::bytes::RegexBuilder::size_limit(p0, p1);
+crate::re_builder::bytes::RegexBuilder::size_limit(p0, p1);
+<re_builder::bytes::RegexBuilder>::size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::dfa_size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = 0usize; // None+usize
+p0.dfa_size_limit(p1);
+re_builder::bytes::RegexBuilder::dfa_size_limit(p0, p1);
+crate::re_builder::bytes::RegexBuilder::dfa_size_limit(p0, p1);
+<re_builder::bytes::RegexBuilder>::dfa_size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+re_builder::bytes::RegexBuilder::nest_limit(p0, p1);
+crate::re_builder::bytes::RegexBuilder::nest_limit(p0, p1);
+<re_builder::bytes::RegexBuilder>::nest_limit(p0, p1);
-----------------
src/re_builder.rs <re_builder::unicode::RegexBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::unicode::RegexBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::unicode::RegexBuilder as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::unicode::RegexBuilder>::fmt(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_builder::unicode::RegexBuilder::new(&p0);
+crate::re_builder::unicode::RegexBuilder::new(&p0);
+<re_builder::unicode::RegexBuilder>::new(&p0);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
+p0.build();
+re_builder::unicode::RegexBuilder::build(p0);
+crate::re_builder::unicode::RegexBuilder::build(p0);
+<re_builder::unicode::RegexBuilder>::build(p0);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+re_builder::unicode::RegexBuilder::case_insensitive(p0, p1);
+crate::re_builder::unicode::RegexBuilder::case_insensitive(p0, p1);
+<re_builder::unicode::RegexBuilder>::case_insensitive(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+re_builder::unicode::RegexBuilder::multi_line(p0, p1);
+crate::re_builder::unicode::RegexBuilder::multi_line(p0, p1);
+<re_builder::unicode::RegexBuilder>::multi_line(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+re_builder::unicode::RegexBuilder::dot_matches_new_line(p0, p1);
+crate::re_builder::unicode::RegexBuilder::dot_matches_new_line(p0, p1);
+<re_builder::unicode::RegexBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+re_builder::unicode::RegexBuilder::swap_greed(p0, p1);
+crate::re_builder::unicode::RegexBuilder::swap_greed(p0, p1);
+<re_builder::unicode::RegexBuilder>::swap_greed(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+re_builder::unicode::RegexBuilder::ignore_whitespace(p0, p1);
+crate::re_builder::unicode::RegexBuilder::ignore_whitespace(p0, p1);
+<re_builder::unicode::RegexBuilder>::ignore_whitespace(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+re_builder::unicode::RegexBuilder::unicode(p0, p1);
+crate::re_builder::unicode::RegexBuilder::unicode(p0, p1);
+<re_builder::unicode::RegexBuilder>::unicode(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+re_builder::unicode::RegexBuilder::octal(p0, p1);
+crate::re_builder::unicode::RegexBuilder::octal(p0, p1);
+<re_builder::unicode::RegexBuilder>::octal(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+re_builder::unicode::RegexBuilder::size_limit(p0, p1);
+crate::re_builder::unicode::RegexBuilder::size_limit(p0, p1);
+<re_builder::unicode::RegexBuilder>::size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::dfa_size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = 0usize; // None+usize
+p0.dfa_size_limit(p1);
+re_builder::unicode::RegexBuilder::dfa_size_limit(p0, p1);
+crate::re_builder::unicode::RegexBuilder::dfa_size_limit(p0, p1);
+<re_builder::unicode::RegexBuilder>::dfa_size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+re_builder::unicode::RegexBuilder::nest_limit(p0, p1);
+crate::re_builder::unicode::RegexBuilder::nest_limit(p0, p1);
+<re_builder::unicode::RegexBuilder>::nest_limit(p0, p1);
-----------------
src/re_builder.rs <re_builder::set_bytes::RegexSetBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::set_bytes::RegexSetBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::set_bytes::RegexSetBuilder as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::fmt(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"re_builder::set_bytes::RegexSetBuilder::new":{"I":["std::marker::Sized","std::iter::IntoIterator"],"S":["std::convert::AsRef","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]},"re_trait::Matches":{"R":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["re_bytes::Split","re_set::bytes::SetMatchesIter","re_unicode::CaptureMatches","re_trait::CaptureMatches","<&mut I as std::iter::Iterator>","re_set::bytes::SetMatchesIntoIter","re_bytes::SplitN","re_trait::SubCapturesPosIter","re_set::unicode::SetMatchesIntoIter","re_bytes::CaptureMatches","re_trait::Matches","re_bytes::Matches","re_unicode::SplitN","re_unicode::CaptureNames","re_bytes::SubCaptureMatches","literal::imp::LiteralIter","re_unicode::SubCaptureMatches","dfa::InstPtrs","re_unicode::Split","re_unicode::Matches","re_set::unicode::SetMatchesIter","re_bytes::CaptureNames"]},"re_builder::set_bytes::RegexSetBuilder::new":{"I":["re_set::unicode::SetMatches","<&'a std::result::Result<T, E> as std::iter::IntoIterator>","<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>","re_set::bytes::SetMatches"],"S":["std::boxed::Box<T, A>","std::vec::IntoIter<T, A>","std::slice::Iter<'_, T>","std::vec::Drain<'a, T, A>","std::slice::IterMut<'_, T>","std::ffi::CStr","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, T>","std::ffi::CString","<&mut T as std::convert::AsRef<U>>","std::rc::Rc<T>","std::borrow::Cow<'_, std::ffi::OsStr>","std::sync::Arc<T>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+re_builder::set_bytes::RegexSetBuilder::new(p0);
+crate::re_builder::set_bytes::RegexSetBuilder::new(p0);
+<re_builder::set_bytes::RegexSetBuilder>::new(p0);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
+p0.build();
+re_builder::set_bytes::RegexSetBuilder::build(p0);
+crate::re_builder::set_bytes::RegexSetBuilder::build(p0);
+<re_builder::set_bytes::RegexSetBuilder>::build(p0);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+re_builder::set_bytes::RegexSetBuilder::case_insensitive(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::case_insensitive(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::case_insensitive(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+re_builder::set_bytes::RegexSetBuilder::multi_line(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::multi_line(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::multi_line(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+re_builder::set_bytes::RegexSetBuilder::dot_matches_new_line(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::dot_matches_new_line(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+re_builder::set_bytes::RegexSetBuilder::swap_greed(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::swap_greed(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::swap_greed(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+re_builder::set_bytes::RegexSetBuilder::ignore_whitespace(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::ignore_whitespace(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::ignore_whitespace(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+re_builder::set_bytes::RegexSetBuilder::unicode(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::unicode(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::unicode(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+re_builder::set_bytes::RegexSetBuilder::octal(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::octal(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::octal(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+re_builder::set_bytes::RegexSetBuilder::size_limit(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::size_limit(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::dfa_size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = 0usize; // None+usize
+p0.dfa_size_limit(p1);
+re_builder::set_bytes::RegexSetBuilder::dfa_size_limit(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::dfa_size_limit(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::dfa_size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+re_builder::set_bytes::RegexSetBuilder::nest_limit(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::nest_limit(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::nest_limit(p0, p1);
-----------------
src/re_builder.rs <re_builder::set_unicode::RegexSetBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::set_unicode::RegexSetBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::set_unicode::RegexSetBuilder as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::fmt(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"re_builder::set_unicode::RegexSetBuilder::new":{"I":["std::marker::Sized","std::iter::IntoIterator"],"S":["std::marker::Sized","std::convert::AsRef"]},"re_trait::CaptureMatches":{"R":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["re_unicode::SplitN","re_unicode::Split","re_unicode::SubCaptureMatches","re_unicode::CaptureNames","re_bytes::SubCaptureMatches","<&mut I as std::iter::Iterator>","literal::imp::LiteralIter","re_set::unicode::SetMatchesIntoIter","re_trait::Matches","re_unicode::Matches","re_trait::SubCapturesPosIter","re_set::unicode::SetMatchesIter","re_set::bytes::SetMatchesIter","re_bytes::Matches","re_bytes::SplitN","dfa::InstPtrs","re_bytes::CaptureNames","re_bytes::Split","re_set::bytes::SetMatchesIntoIter","re_unicode::CaptureMatches","re_trait::CaptureMatches","re_bytes::CaptureMatches"]},"re_builder::set_unicode::RegexSetBuilder::new":{"I":["<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","re_set::unicode::SetMatches","<&'a mut std::option::Option<T> as std::iter::IntoIterator>","re_set::bytes::SetMatches"],"S":["std::boxed::Box<T, A>","std::rc::Rc<T>","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, T>","std::sync::Arc<T>","std::slice::Iter<'_, T>","<&T as std::convert::AsRef<U>>","std::borrow::Cow<'_, std::ffi::OsStr>","std::ffi::CString","std::ffi::CStr","<&mut T as std::convert::AsRef<U>>","std::vec::IntoIter<T, A>","std::slice::IterMut<'_, T>","std::vec::Drain<'a, T, A>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+re_builder::set_unicode::RegexSetBuilder::new(p0);
+crate::re_builder::set_unicode::RegexSetBuilder::new(p0);
+<re_builder::set_unicode::RegexSetBuilder>::new(p0);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
+p0.build();
+re_builder::set_unicode::RegexSetBuilder::build(p0);
+crate::re_builder::set_unicode::RegexSetBuilder::build(p0);
+<re_builder::set_unicode::RegexSetBuilder>::build(p0);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+re_builder::set_unicode::RegexSetBuilder::case_insensitive(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::case_insensitive(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::case_insensitive(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+re_builder::set_unicode::RegexSetBuilder::multi_line(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::multi_line(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::multi_line(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+re_builder::set_unicode::RegexSetBuilder::dot_matches_new_line(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::dot_matches_new_line(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+re_builder::set_unicode::RegexSetBuilder::swap_greed(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::swap_greed(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::swap_greed(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+re_builder::set_unicode::RegexSetBuilder::ignore_whitespace(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::ignore_whitespace(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::ignore_whitespace(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+re_builder::set_unicode::RegexSetBuilder::unicode(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::unicode(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::unicode(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+re_builder::set_unicode::RegexSetBuilder::octal(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::octal(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::octal(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+re_builder::set_unicode::RegexSetBuilder::size_limit(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::size_limit(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::dfa_size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = 0usize; // None+usize
+p0.dfa_size_limit(p1);
+re_builder::set_unicode::RegexSetBuilder::dfa_size_limit(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::dfa_size_limit(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::dfa_size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+re_builder::set_unicode::RegexSetBuilder::nest_limit(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::nest_limit(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::nest_limit(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Match<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.clone();
+<re_bytes::Match<'t> as std::clone::Clone>::clone(p0);
+crate::<re_bytes::Match<'t> as std::clone::Clone>::clone(p0);
+<re_bytes::Match<'t>>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.assert_receiver_is_total_eq();
+<re_bytes::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<re_bytes::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<re_bytes::Match<'t>>::assert_receiver_is_total_eq(p0);
-----------------
src/re_bytes.rs <re_bytes::Match<'t> as std::cmp::PartialEq>::eq
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.eq(p1);
+<re_bytes::Match<'t> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<re_bytes::Match<'t> as std::cmp::PartialEq>::eq(p0, p1);
+<re_bytes::Match<'t>>::eq(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::start
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.start();
+re_bytes::Match::<'t>::start(p0);
+crate::re_bytes::Match::<'t>::start(p0);
+<re_bytes::Match<'t>>::start(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::end
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.end();
+re_bytes::Match::<'t>::end(p0);
+crate::re_bytes::Match::<'t>::end(p0);
+<re_bytes::Match<'t>>::end(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::is_empty
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.is_empty();
+re_bytes::Match::<'t>::is_empty(p0);
+crate::re_bytes::Match::<'t>::is_empty(p0);
+<re_bytes::Match<'t>>::is_empty(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.len();
+re_bytes::Match::<'t>::len(p0);
+crate::re_bytes::Match::<'t>::len(p0);
+<re_bytes::Match<'t>>::len(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::range
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.range();
+re_bytes::Match::<'t>::range(p0);
+crate::re_bytes::Match::<'t>::range(p0);
+<re_bytes::Match<'t>>::range(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::as_bytes
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.as_bytes();
+re_bytes::Match::<'t>::as_bytes(p0);
+crate::re_bytes::Match::<'t>::as_bytes(p0);
+<re_bytes::Match<'t>>::as_bytes(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::new
't
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+re_bytes::Match::<'t>::new(p0, p1, p2);
+crate::re_bytes::Match::<'t>::new(p0, p1, p2);
+<re_bytes::Match<'t>>::new(p0, p1, p2);
-----------------
src/re_bytes.rs <re_bytes::Match<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Match<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Match<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Match<'t>>::fmt(p0, p1);
-----------------
src/re_bytes.rs re_bytes::<impl std::convert::From<re_bytes::Match<'t>> for std::ops::Range<usize>>::from
't
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+re_bytes::<impl std::convert::From<re_bytes::Match<'t>> for std::ops::Range<usize>>::from(p0);
+crate::re_bytes::<impl std::convert::From<re_bytes::Match<'t>> for std::ops::Range<usize>>::from(p0);
+<std::ops::Range<usize>>::from(p0);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.clone();
+<re_bytes::Regex as std::clone::Clone>::clone(p0);
+crate::<re_bytes::Regex as std::clone::Clone>::clone(p0);
+<re_bytes::Regex>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<re_bytes::Regex as std::fmt::Display>::fmt(p0, p1);
+crate::<re_bytes::Regex as std::fmt::Display>::fmt(p0, p1);
+<re_bytes::Regex>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Regex as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Regex as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Regex>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::convert::From<exec::Exec>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+<re_bytes::Regex as std::convert::From<exec::Exec>>::from(p0);
+crate::<re_bytes::Regex as std::convert::From<exec::Exec>>::from(p0);
+<re_bytes::Regex>::from(p0);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<re_bytes::Regex as std::str::FromStr>::from_str(&p0);
+crate::<re_bytes::Regex as std::str::FromStr>::from_str(&p0);
+<re_bytes::Regex>::from_str(&p0);
-----------------
src/re_bytes.rs re_bytes::Regex::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_bytes::Regex::new(&p0);
+crate::re_bytes::Regex::new(&p0);
+<re_bytes::Regex>::new(&p0);
-----------------
src/re_bytes.rs re_bytes::Regex::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.is_match(p1);
+re_bytes::Regex::is_match(p0, p1);
+crate::re_bytes::Regex::is_match(p0, p1);
+<re_bytes::Regex>::is_match(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find(p1);
+re_bytes::Regex::find(p0, p1);
+crate::re_bytes::Regex::find(p0, p1);
+<re_bytes::Regex>::find(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::find_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find_iter(p1);
+re_bytes::Regex::find_iter(p0, p1);
+crate::re_bytes::Regex::find_iter(p0, p1);
+<re_bytes::Regex>::find_iter(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::captures
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.captures(p1);
+re_bytes::Regex::captures(p0, p1);
+crate::re_bytes::Regex::captures(p0, p1);
+<re_bytes::Regex>::captures(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::captures_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.captures_iter(p1);
+re_bytes::Regex::captures_iter(p0, p1);
+crate::re_bytes::Regex::captures_iter(p0, p1);
+<re_bytes::Regex>::captures_iter(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::split
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.split(p1);
+re_bytes::Regex::split(p0, p1);
+crate::re_bytes::Regex::split(p0, p1);
+<re_bytes::Regex>::split(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::splitn
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.splitn(p1, p2);
+re_bytes::Regex::splitn(p0, p1, p2);
+crate::re_bytes::Regex::splitn(p0, p1, p2);
+<re_bytes::Regex>::splitn(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::replace
deps:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"re_bytes::Regex::replace":{"R":["re_bytes::Replacer","std::marker::Sized"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::alloc::Allocator","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr"]},"<T as std::borrow::ToOwned>":{"T":["prog::InstSave","re_set::unicode::SetMatchesIter","re_trait::SubCapturesPosIter","dfa::Result","re_unicode::CaptureNames","literal::imp::Matcher","prog::Program","re_bytes::Regex","prog::InstBytes","literal::imp::SingleByteSet","sparse::SparseSet","re_set::bytes::SetMatchesIter","re_bytes::SubCaptureMatches","literal::imp::LiteralSearcher","input::InputAt","prog::InstRanges","exec::MatchType","re_set::unicode::RegexSet","prog::InstSplit","re_unicode::SubCaptureMatches","input::ByteInput","re_unicode::NoExpand","re_set::bytes::RegexSet","dfa::EmptyFlags","re_bytes::CaptureLocations","re_set::unicode::SetMatches","compile::SuffixCacheEntry","dfa::Byte","pikevm::FollowEpsilon","compile::MaybeInst","compile::InstHole","re_bytes::NoExpand","literal::imp::Memmem","re_unicode::Match","re_unicode::Regex","re_builder::RegexOptions","exec::MatchNfaType","dfa::StateFlags","re_bytes::Match","re_bytes::CaptureNames","exec::MatchLiteralType","re_unicode::CaptureLocations","std::clone::impls::<impl std::clone::Clone for &mut T>","re_trait::Locations","expand::Ref","pikevm::Cache","prog::Inst","error::Error","expand::CaptureRef","input::Char","backtrack::Job","compile::SuffixCacheKey","input::CharInput","prog::EmptyLook","pikevm::Threads","dfa::Transitions","re_set::bytes::SetMatches","backtrack::Cache","exec::Exec","prog::InstEmptyLook","prog::InstChar","dfa::State"]},"dfa::Result":{"T":["dfa::Byte","re_builder::RegexOptions","re_bytes::Regex","dfa::Result","re_set::unicode::RegexSet","sparse::SparseSet","literal::imp::Matcher","dfa::Transitions","backtrack::Job","backtrack::Cache","compile::InstHole","re_bytes::CaptureNames","re_unicode::CaptureNames","re_trait::SubCapturesPosIter","input::CharInput","pikevm::Threads","exec::MatchLiteralType","re_bytes::SubCaptureMatches","input::InputAt","re_trait::Locations","prog::InstSplit","expand::CaptureRef","prog::InstSave","pikevm::Cache","compile::MaybeInst","dfa::EmptyFlags","std::clone::impls::<impl std::clone::Clone for &mut T>","re_unicode::SubCaptureMatches","re_set::bytes::RegexSet","prog::InstEmptyLook","re_bytes::CaptureLocations","re_bytes::Match","literal::imp::Memmem","dfa::StateFlags","re_set::unicode::SetMatches","re_unicode::CaptureLocations","prog::InstBytes","re_bytes::NoExpand","re_unicode::Match","pikevm::FollowEpsilon","prog::Program","prog::EmptyLook","compile::SuffixCacheKey","re_set::bytes::SetMatchesIter","literal::imp::LiteralSearcher","exec::MatchNfaType","re_set::unicode::SetMatchesIter","prog::InstChar","prog::Inst","prog::InstRanges","expand::Ref","re_unicode::Regex","exec::MatchType","exec::Exec","input::ByteInput","literal::imp::SingleByteSet","re_unicode::NoExpand","re_set::bytes::SetMatches","error::Error","input::Char","dfa::State","compile::SuffixCacheEntry"]},"re_bytes::Regex::replace":{"R":["<F as re_bytes::Replacer>","re_bytes::NoExpand","std::borrow::Cow","std::vec::Vec","re_bytes::ReplacerRef"]},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::ffi::CStr","std::path::Path","std::ffi::OsStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = MaybeUninit::uninit().assume_init(); // R
+p0.replace(p1, p2);
+re_bytes::Regex::replace(p0, p1, p2);
+crate::re_bytes::Regex::replace(p0, p1, p2);
+<re_bytes::Regex>::replace(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::replace_all
deps:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"re_bytes::Regex::replace_all":{"R":["re_bytes::Replacer","std::marker::Sized"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::BytesIsNotEmpty"]},"<T as std::borrow::ToOwned>":{"T":["re_set::unicode::SetMatches","backtrack::Job","prog::InstEmptyLook","re_bytes::NoExpand","prog::Program","re_set::unicode::RegexSet","input::ByteInput","re_bytes::CaptureNames","exec::Exec","compile::MaybeInst","re_unicode::Match","std::clone::impls::<impl std::clone::Clone for &mut T>","re_bytes::Regex","dfa::Transitions","backtrack::Cache","exec::MatchLiteralType","expand::CaptureRef","exec::MatchType","input::InputAt","input::CharInput","input::Char","re_unicode::NoExpand","prog::InstSplit","re_builder::RegexOptions","exec::MatchNfaType","re_bytes::CaptureLocations","re_unicode::Regex","re_trait::SubCapturesPosIter","literal::imp::Memmem","re_set::unicode::SetMatchesIter","prog::Inst","re_bytes::SubCaptureMatches","pikevm::Threads","sparse::SparseSet","error::Error","re_set::bytes::RegexSet","compile::SuffixCacheEntry","pikevm::Cache","re_unicode::CaptureNames","re_unicode::SubCaptureMatches","dfa::State","prog::InstRanges","re_set::bytes::SetMatchesIter","prog::InstBytes","prog::InstChar","compile::SuffixCacheKey","re_bytes::Match","dfa::StateFlags","re_set::bytes::SetMatches","dfa::Result","prog::InstSave","re_trait::Locations","literal::imp::SingleByteSet","pikevm::FollowEpsilon","prog::EmptyLook","dfa::Byte","re_unicode::CaptureLocations","compile::InstHole","literal::imp::Matcher","expand::Ref","dfa::EmptyFlags","literal::imp::LiteralSearcher"]},"dfa::Result":{"T":["dfa::Byte","re_unicode::SubCaptureMatches","input::ByteInput","exec::MatchType","re_bytes::Regex","re_unicode::Match","std::clone::impls::<impl std::clone::Clone for &T>","prog::Inst","prog::InstSplit","pikevm::Threads","prog::Program","re_set::bytes::RegexSet","re_trait::Locations","dfa::StateFlags","re_bytes::CaptureLocations","re_set::unicode::SetMatchesIter","re_unicode::CaptureLocations","exec::Exec","compile::SuffixCacheEntry","compile::MaybeInst","dfa::State","input::CharInput","input::InputAt","pikevm::Cache","prog::InstRanges","re_unicode::CaptureNames","prog::EmptyLook","re_set::bytes::SetMatches","sparse::SparseSet","backtrack::Cache","dfa::EmptyFlags","expand::Ref","re_bytes::NoExpand","re_set::unicode::SetMatches","re_bytes::SubCaptureMatches","re_set::bytes::SetMatchesIter","re_set::unicode::RegexSet","dfa::Transitions","dfa::Result","compile::SuffixCacheKey","re_trait::SubCapturesPosIter","re_bytes::CaptureNames","compile::InstHole","prog::InstEmptyLook","re_builder::RegexOptions","error::Error","re_unicode::NoExpand","pikevm::FollowEpsilon","expand::CaptureRef","backtrack::Job","literal::imp::Matcher","re_bytes::Match","prog::InstChar","prog::InstSave","re_unicode::Regex","exec::MatchNfaType","literal::imp::SingleByteSet","exec::MatchLiteralType","literal::imp::LiteralSearcher","prog::InstBytes","input::Char","literal::imp::Memmem"]},"re_bytes::Regex::replace_all":{"R":["<&'a std::vec::Vec<u8> as re_bytes::Replacer>","re_bytes::NoExpand","re_bytes::ReplacerRef","std::borrow::Cow","std::vec::Vec"]},"std::borrow::Cow":{"B":["std::ffi::CStr","std::ffi::OsStr","<T as std::borrow::ToOwned>","std::path::Path"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = MaybeUninit::uninit().assume_init(); // R
+p0.replace_all(p1, p2);
+re_bytes::Regex::replace_all(p0, p1, p2);
+crate::re_bytes::Regex::replace_all(p0, p1, p2);
+<re_bytes::Regex>::replace_all(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::replacen
deps:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"re_bytes::Regex::replacen":{"R":["std::marker::Sized","re_bytes::Replacer"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::alloc::Allocator","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::borrow::ToOwned>":{"T":["re_bytes::Regex","input::InputAt","exec::MatchType","pikevm::Cache","dfa::Transitions","prog::InstSave","exec::MatchNfaType","re_unicode::Match","re_trait::Locations","re_set::unicode::RegexSet","dfa::Result","literal::imp::LiteralSearcher","re_set::bytes::SetMatchesIter","prog::EmptyLook","re_bytes::Match","re_set::bytes::SetMatches","input::ByteInput","re_unicode::CaptureNames","dfa::EmptyFlags","pikevm::Threads","dfa::Byte","re_bytes::CaptureLocations","backtrack::Cache","input::CharInput","expand::Ref","pikevm::FollowEpsilon","literal::imp::Matcher","std::clone::impls::<impl std::clone::Clone for *mut T>","prog::InstSplit","prog::InstBytes","compile::SuffixCacheEntry","re_set::unicode::SetMatchesIter","dfa::State","re_unicode::SubCaptureMatches","literal::imp::SingleByteSet","prog::InstRanges","compile::SuffixCacheKey","expand::CaptureRef","re_set::bytes::RegexSet","prog::Program","literal::imp::Memmem","re_trait::SubCapturesPosIter","re_unicode::Regex","dfa::StateFlags","re_bytes::CaptureNames","exec::MatchLiteralType","re_set::unicode::SetMatches","compile::MaybeInst","re_bytes::NoExpand","re_unicode::NoExpand","re_builder::RegexOptions","error::Error","re_unicode::CaptureLocations","prog::InstEmptyLook","input::Char","re_bytes::SubCaptureMatches","compile::InstHole","prog::InstChar","sparse::SparseSet","backtrack::Job","prog::Inst","exec::Exec"]},"dfa::Result":{"T":["input::Char","literal::imp::Matcher","re_set::bytes::RegexSet","prog::Program","re_trait::Locations","error::Error","exec::MatchLiteralType","literal::imp::SingleByteSet","prog::InstSave","literal::imp::Memmem","re_set::unicode::SetMatchesIter","re_builder::RegexOptions","prog::InstSplit","prog::InstChar","re_set::unicode::SetMatches","<*mut T as std::fmt::Debug>","re_unicode::Match","literal::imp::LiteralSearcher","prog::Inst","re_bytes::SubCaptureMatches","exec::Exec","compile::SuffixCacheKey","re_set::bytes::SetMatchesIter","expand::CaptureRef","dfa::Transitions","re_unicode::SubCaptureMatches","compile::InstHole","input::ByteInput","re_bytes::NoExpand","re_unicode::Regex","re_bytes::Regex","sparse::SparseSet","prog::InstEmptyLook","dfa::EmptyFlags","compile::SuffixCacheEntry","pikevm::FollowEpsilon","re_bytes::CaptureLocations","pikevm::Cache","dfa::State","re_unicode::NoExpand","dfa::Byte","backtrack::Cache","dfa::Result","re_unicode::CaptureLocations","compile::MaybeInst","re_bytes::Match","re_set::bytes::SetMatches","re_trait::SubCapturesPosIter","prog::InstBytes","re_unicode::CaptureNames","exec::MatchNfaType","expand::Ref","pikevm::Threads","prog::InstRanges","backtrack::Job","re_set::unicode::RegexSet","re_bytes::CaptureNames","dfa::StateFlags","input::InputAt","prog::EmptyLook","exec::MatchType","input::CharInput"]},"re_bytes::Regex::replacen":{"R":["std::vec::Vec","<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>","<F as re_bytes::Replacer>","re_bytes::ReplacerRef","std::borrow::Cow","re_bytes::NoExpand"]},"std::borrow::Cow":{"B":["std::ffi::OsStr","std::ffi::CStr","<T as std::borrow::ToOwned>","std::path::Path"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // R
+p0.replacen(p1, p2, p3);
+re_bytes::Regex::replacen(p0, p1, p2, p3);
+crate::re_bytes::Regex::replacen(p0, p1, p2, p3);
+<re_bytes::Regex>::replacen(p0, p1, p2, p3);
-----------------
src/re_bytes.rs re_bytes::Regex::shortest_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.shortest_match(p1);
+re_bytes::Regex::shortest_match(p0, p1);
+crate::re_bytes::Regex::shortest_match(p0, p1);
+<re_bytes::Regex>::shortest_match(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::shortest_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(p1, p2);
+re_bytes::Regex::shortest_match_at(p0, p1, p2);
+crate::re_bytes::Regex::shortest_match_at(p0, p1, p2);
+<re_bytes::Regex>::shortest_match_at(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::is_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.is_match_at(p1, p2);
+re_bytes::Regex::is_match_at(p0, p1, p2);
+crate::re_bytes::Regex::is_match_at(p0, p1, p2);
+<re_bytes::Regex>::is_match_at(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::find_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_at(p1, p2);
+re_bytes::Regex::find_at(p0, p1, p2);
+crate::re_bytes::Regex::find_at(p0, p1, p2);
+<re_bytes::Regex>::find_at(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::captures_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.captures_at(p1, p2);
+re_bytes::Regex::captures_at(p0, p1, p2);
+crate::re_bytes::Regex::captures_at(p0, p1, p2);
+<re_bytes::Regex>::captures_at(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::captures_read
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.captures_read(p1, p2);
+re_bytes::Regex::captures_read(p0, p1, p2);
+crate::re_bytes::Regex::captures_read(p0, p1, p2);
+<re_bytes::Regex>::captures_read(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::captures_read_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, p2, p3);
+re_bytes::Regex::captures_read_at(p0, p1, p2, p3);
+crate::re_bytes::Regex::captures_read_at(p0, p1, p2, p3);
+<re_bytes::Regex>::captures_read_at(p0, p1, p2, p3);
-----------------
src/re_bytes.rs re_bytes::Regex::read_captures_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.read_captures_at(p1, p2, p3);
+re_bytes::Regex::read_captures_at(p0, p1, p2, p3);
+crate::re_bytes::Regex::read_captures_at(p0, p1, p2, p3);
+<re_bytes::Regex>::read_captures_at(p0, p1, p2, p3);
-----------------
src/re_bytes.rs re_bytes::Regex::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.as_str();
+re_bytes::Regex::as_str(p0);
+crate::re_bytes::Regex::as_str(p0);
+<re_bytes::Regex>::as_str(p0);
-----------------
src/re_bytes.rs re_bytes::Regex::capture_names
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.capture_names();
+re_bytes::Regex::capture_names(p0);
+crate::re_bytes::Regex::capture_names(p0);
+<re_bytes::Regex>::capture_names(p0);
-----------------
src/re_bytes.rs re_bytes::Regex::captures_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.captures_len();
+re_bytes::Regex::captures_len(p0);
+crate::re_bytes::Regex::captures_len(p0);
+<re_bytes::Regex>::captures_len(p0);
-----------------
src/re_bytes.rs re_bytes::Regex::static_captures_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.static_captures_len();
+re_bytes::Regex::static_captures_len(p0);
+crate::re_bytes::Regex::static_captures_len(p0);
+<re_bytes::Regex>::static_captures_len(p0);
-----------------
src/re_bytes.rs re_bytes::Regex::capture_locations
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.capture_locations();
+re_bytes::Regex::capture_locations(p0);
+crate::re_bytes::Regex::capture_locations(p0);
+<re_bytes::Regex>::capture_locations(p0);
-----------------
src/re_bytes.rs re_bytes::Regex::locations
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.locations();
+re_bytes::Regex::locations(p0);
+crate::re_bytes::Regex::locations(p0);
+<re_bytes::Regex>::locations(p0);
-----------------
src/re_bytes.rs <re_bytes::Matches<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Matches<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Matches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Matches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Matches<'r, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Matches<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::Matches<'r, 't>
+p0.next();
+<re_bytes::Matches<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::Matches<'r, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::Matches<'r, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureMatches<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::CaptureMatches<'r, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::CaptureMatches<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureMatches<'r, 't>
+p0.next();
+<re_bytes::CaptureMatches<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::CaptureMatches<'r, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::CaptureMatches<'r, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::Split<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Split<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Split<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Split<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Split<'r, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Split<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::Split<'r, 't>
+p0.next();
+<re_bytes::Split<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::Split<'r, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::Split<'r, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::SplitN<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::SplitN<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::SplitN<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::SplitN<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::SplitN<'r, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::SplitN<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::SplitN<'r, 't>
+p0.next();
+<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::SplitN<'r, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::SplitN<'r, 't> as std::iter::Iterator>::size_hint
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::SplitN<'r, 't>
+p0.size_hint();
+<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::size_hint(p0);
+crate::<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::size_hint(p0);
+<re_bytes::SplitN<'r, 't>>::size_hint(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::clone::Clone>::clone
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
+p0.clone();
+<re_bytes::CaptureNames<'r> as std::clone::Clone>::clone(p0);
+crate::<re_bytes::CaptureNames<'r> as std::clone::Clone>::clone(p0);
+<re_bytes::CaptureNames<'r>>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::fmt::Debug>::fmt
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::CaptureNames<'r> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::CaptureNames<'r> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::CaptureNames<'r>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::iter::Iterator>::next
'r
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
+p0.next();
+<re_bytes::CaptureNames<'r> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::CaptureNames<'r> as std::iter::Iterator>::next(p0);
+<re_bytes::CaptureNames<'r>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::iter::Iterator>::size_hint
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
+p0.size_hint();
+<re_bytes::CaptureNames<'r> as std::iter::Iterator>::size_hint(p0);
+crate::<re_bytes::CaptureNames<'r> as std::iter::Iterator>::size_hint(p0);
+<re_bytes::CaptureNames<'r>>::size_hint(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::iter::Iterator>::count
'r
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
+p0.count();
+<re_bytes::CaptureNames<'r> as std::iter::Iterator>::count(p0);
+crate::<re_bytes::CaptureNames<'r> as std::iter::Iterator>::count(p0);
+<re_bytes::CaptureNames<'r>>::count(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureLocations as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
+p0.clone();
+<re_bytes::CaptureLocations as std::clone::Clone>::clone(p0);
+crate::<re_bytes::CaptureLocations as std::clone::Clone>::clone(p0);
+<re_bytes::CaptureLocations>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureLocations as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::CaptureLocations as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::CaptureLocations as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::CaptureLocations>::fmt(p0, p1);
-----------------
src/re_bytes.rs re_bytes::CaptureLocations::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+re_bytes::CaptureLocations::get(p0, p1);
+crate::re_bytes::CaptureLocations::get(p0, p1);
+<re_bytes::CaptureLocations>::get(p0, p1);
-----------------
src/re_bytes.rs re_bytes::CaptureLocations::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
+p0.len();
+re_bytes::CaptureLocations::len(p0);
+crate::re_bytes::CaptureLocations::len(p0);
+<re_bytes::CaptureLocations>::len(p0);
-----------------
src/re_bytes.rs re_bytes::CaptureLocations::pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p1 = 0usize; // None+usize
+p0.pos(p1);
+re_bytes::CaptureLocations::pos(p0, p1);
+crate::re_bytes::CaptureLocations::pos(p0, p1);
+<re_bytes::CaptureLocations>::pos(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::get
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+re_bytes::Captures::<'t>::get(p0, p1);
+crate::re_bytes::Captures::<'t>::get(p0, p1);
+<re_bytes::Captures<'t>>::get(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::name
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = "sample"; // None+&str
+p0.name(&p1);
+re_bytes::Captures::<'t>::name(p0, &p1);
+crate::re_bytes::Captures::<'t>::name(p0, &p1);
+<re_bytes::Captures<'t>>::name(p0, &p1);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::iter
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
+p0.iter();
+re_bytes::Captures::<'t>::iter(p0);
+crate::re_bytes::Captures::<'t>::iter(p0);
+<re_bytes::Captures<'t>>::iter(p0);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::expand
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.expand(p1, p2);
+re_bytes::Captures::<'t>::expand(p0, p1, p2);
+crate::re_bytes::Captures::<'t>::expand(p0, p1, p2);
+<re_bytes::Captures<'t>>::expand(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
+p0.len();
+re_bytes::Captures::<'t>::len(p0);
+crate::re_bytes::Captures::<'t>::len(p0);
+<re_bytes::Captures<'t>>::len(p0);
-----------------
src/re_bytes.rs <re_bytes::Captures<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Captures<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Captures<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Captures<'t>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CapturesDebug<'c, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::CapturesDebug<'c, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Captures<'t> as std::ops::Index<usize>>::index
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = 0usize; // None+usize
+p0.index(p1);
+<re_bytes::Captures<'t> as std::ops::Index<usize>>::index(p0, p1);
+crate::<re_bytes::Captures<'t> as std::ops::Index<usize>>::index(p0, p1);
+<re_bytes::Captures<'t>>::index(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Captures<'t> as std::ops::Index<&'i str>>::index
't,'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+<re_bytes::Captures<'t> as std::ops::Index<&'i str>>::index(p0, &p1);
+crate::<re_bytes::Captures<'t> as std::ops::Index<&'i str>>::index(p0, &p1);
+<re_bytes::Captures<'t>>::index(p0, &p1);
-----------------
src/re_bytes.rs <re_bytes::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::SubCaptureMatches<'c, 't>
+p0.clone();
+<re_bytes::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone(p0);
+crate::<re_bytes::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone(p0);
+<re_bytes::SubCaptureMatches<'c, 't>>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::SubCaptureMatches<'c, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::SubCaptureMatches<'c, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next
'c,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::SubCaptureMatches<'c, 't>
+p0.next();
+<re_bytes::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::SubCaptureMatches<'c, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":{"R":["std::fmt::Debug"]},"backtrack::Bounded":{"I":["std::fmt::Debug","std::marker::Sized","input::Input"]},"dfa::Result":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"pikevm::Fsm":{"I":["std::marker::Sized","std::fmt::Debug","input::Input"]},"pool::Pool":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"pool::PoolGuard":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"re_trait::CaptureMatches":{"R":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]},"re_trait::Matches":{"R":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":{"R":["re_set::unicode::SetMatchesIter","re_set::unicode::SetMatches","prog::Inst","exec::ExecReadOnly","sparse::SparseSet","re_bytes::CaptureNames","prog::InstBytes","input::Char","input::CharInput","re_unicode::Split","compile::SuffixCache","re_set::bytes::SetMatchesIter","re_unicode::CaptureLocations","re_set::unicode::RegexSet","pool::PoolGuard","re_bytes::SplitN","re_unicode::SplitN","literal::imp::SingleByteSet","literal::imp::Memmem","re_bytes::Matches","exec::MatchType","re_builder::set_unicode::RegexSetBuilder","re_unicode::Regex","prog::InstChar","pikevm::Threads","re_bytes::SubCaptureMatches","re_unicode::Match","dfa::Byte","expand::Ref","re_set::bytes::SetMatchesIntoIter","pikevm::FollowEpsilon","re_bytes::CaptureLocations","compile::Hole","re_builder::set_bytes::RegexSetBuilder","dfa::StateFlags","re_unicode::CaptureNames","backtrack::Job","dfa::CacheInner","input::ByteInput","prog::InstSplit","dfa::Fsm","re_bytes::Regex","backtrack::Bounded","prog::InstEmptyLook","literal::imp::LiteralIter","compile::SuffixCacheEntry","dfa::Transitions","prog::EmptyLook","re_bytes::Match","dfa::StateMap","dfa::EmptyFlags","re_builder::unicode::RegexBuilder","pikevm::Cache","compile::SuffixCacheKey","backtrack::Cache","error::Error","re_unicode::Matches","compile::MaybeInst","re_bytes::CapturesDebug","exec::ExecNoSyncStr","re_trait::Locations","pikevm::Fsm","re_unicode::ReplacerRef","pool::Pool","re_unicode::SubCaptureMatches","exec::MatchNfaType","prog::Program","dfa::Result","expand::CaptureRef","re_unicode::CaptureMatches","dfa::TransitionsRow","compile::Patch","exec::MatchLiteralType","re_set::unicode::SetMatchesIntoIter","compile::InstHole","dfa::Cache","re_unicode::Captures","dfa::State","input::InputAt","re_unicode::CapturesDebug","re_bytes::Split","re_unicode::NoExpand","re_bytes::ReplacerRef","exec::ProgramCacheInner","prog::InstSave","re_trait::Matches","compile::ByteClassSet","re_builder::bytes::RegexBuilder","re_bytes::Captures","re_set::bytes::RegexSet","re_set::bytes::SetMatches","literal::imp::Matcher","literal::imp::LiteralSearcher","re_bytes::NoExpand","prog::InstRanges","re_trait::CaptureMatches","exec::ExecNoSync","re_bytes::CaptureMatches","re_trait::SubCapturesPosIter","<&mut T as std::fmt::Debug>","exec::Exec","re_builder::RegexOptions"]},"backtrack::Bounded":{"I":["input::ByteInput","input::CharInput"]},"dfa::Result":{"T":["dfa::EmptyFlags","prog::InstSplit","re_unicode::Match","re_unicode::CaptureNames","compile::SuffixCacheEntry","re_bytes::CaptureNames","prog::InstBytes","dfa::Byte","prog::Program","prog::InstSave","re_unicode::Regex","re_set::bytes::SetMatches","error::Error","re_unicode::CaptureLocations","re_set::unicode::RegexSet","re_set::unicode::SetMatches","expand::CaptureRef","compile::MaybeInst","compile::SuffixCacheKey","re_bytes::NoExpand","backtrack::Cache","exec::MatchLiteralType","re_set::bytes::SetMatchesIter","backtrack::Job","expand::Ref","prog::InstEmptyLook","literal::imp::Memmem","dfa::State","sparse::SparseSet","exec::MatchNfaType","re_builder::RegexOptions","prog::EmptyLook","exec::MatchType","pikevm::FollowEpsilon","exec::Exec","re_bytes::SubCaptureMatches","re_bytes::Regex","input::InputAt","pikevm::Cache","re_set::bytes::RegexSet","dfa::StateFlags","re_trait::Locations","literal::imp::Matcher","re_trait::SubCapturesPosIter","re_set::unicode::SetMatchesIter","prog::Inst","compile::InstHole","std::clone::impls::<impl std::clone::Clone for *mut T>","dfa::Transitions","pikevm::Threads","prog::InstChar","literal::imp::SingleByteSet","re_bytes::Match","dfa::Result","re_unicode::NoExpand","re_unicode::SubCaptureMatches","input::ByteInput","input::Char","prog::InstRanges","input::CharInput","re_bytes::CaptureLocations","literal::imp::LiteralSearcher"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"pool::Pool":{"T":["std::vec::Drain<'_, T, A>","std::sys::unix::args::Args","<*const T as std::fmt::Debug>","std::sync::Mutex<T>","std::task::Waker","std::future::ResumeTy","std::collections::linked_list::Iter<'_, T>","std::sync::mpsc::SyncSender<T>","std::sync::mpsc::Sender<T>","std::thread::JoinHandle<T>","std::sync::mpsc::Receiver<T>","std::sync::Arc<T>","std::sync::atomic::AtomicPtr<T>","std::string::Drain<'_>","std::collections::linked_list::IterMut<'_, T>","std::rc::Weak<T>","std::collections::linked_list::Cursor<'_, T>","std::cell::Cell<T>","std::boxed::ThinBox<T>","std::slice::Iter<'_, T>","std::slice::IterMut<'_, T>","std::sync::mpmc::Receiver<T>","std::sync::MutexGuard<'_, T>","std::ptr::Unique<T>","std::sync::RwLockWriteGuard<'_, T>","std::collections::LinkedList<T>","std::env::Args","std::sync::Weak<T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::mpmc::Sender<T>","std::collections::linked_list::CursorMut<'_, T>","std::ptr::DynMetadata<Dyn>","std::rc::Rc<T>","std::sync::OnceLock<T>","std::env::ArgsOs","std::io::error::repr_bitpacked::Repr","std::io::IoSlice<'a>","std::sync::RwLockReadGuard<'_, T>","std::io::IoSliceMut<'a>","std::vec::IntoIter<T, A>","std::ptr::NonNull<T>","std::sync::RwLock<T>","std::cell::RefCell<T>"]},"pool::PoolGuard":{"T":["std::io::error::repr_bitpacked::Repr","std::sync::mpsc::Receiver<T>","std::env::ArgsOs","std::env::Args","std::future::ResumeTy","std::sync::RwLock<T>","std::ptr::Unique<T>","std::vec::IntoIter<T, A>","std::sys::unix::args::Args","std::cell::Cell<T>","<*const T as std::marker::Send>","std::collections::LinkedList<T>","std::sync::OnceLock<T>","std::task::Waker","std::string::Drain<'_>","std::collections::linked_list::Cursor<'_, T>","std::collections::linked_list::Iter<'_, T>","<*mut T as std::fmt::Debug>","std::sync::Weak<T>","std::sync::mpmc::Receiver<T>","std::thread::JoinHandle<T>","std::io::IoSlice<'a>","std::ptr::NonNull<T>","std::sync::Mutex<T>","std::ptr::DynMetadata<Dyn>","std::collections::vec_deque::Drain<'_, T, A>","std::collections::linked_list::CursorMut<'_, T>","std::cell::RefCell<T>","std::rc::Weak<T>","std::io::IoSliceMut<'a>","std::sync::mpsc::Sender<T>","std::sync::RwLockReadGuard<'_, T>","std::collections::linked_list::IterMut<'_, T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::Arc<T>","std::rc::Rc<T>","std::sync::mpmc::Sender<T>","std::sync::MutexGuard<'_, T>","std::boxed::ThinBox<T>","std::slice::IterMut<'_, T>","std::slice::Iter<'_, T>","std::sync::atomic::AtomicPtr<T>","std::vec::Drain<'_, T, A>","std::sync::mpsc::SyncSender<T>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::ReplacerRef<'a, R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::ReplacerRef<'a, R>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append
'a
deps:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append":{"R":["re_bytes::Replacer"]},"dfa::Result":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"]},"<T as std::borrow::ToOwned>":{"T":["prog::EmptyLook","literal::imp::Matcher","re_set::bytes::SetMatches","re_unicode::NoExpand","expand::CaptureRef","re_unicode::CaptureNames","prog::InstSplit","std::clone::impls::<impl std::clone::Clone for *const T>","pikevm::FollowEpsilon","re_bytes::Match","backtrack::Cache","re_unicode::CaptureLocations","re_bytes::Regex","dfa::EmptyFlags","re_bytes::CaptureLocations","exec::Exec","re_set::unicode::RegexSet","exec::MatchType","compile::SuffixCacheEntry","prog::InstSave","prog::Inst","compile::MaybeInst","re_trait::Locations","literal::imp::LiteralSearcher","prog::InstRanges","re_set::unicode::SetMatchesIter","re_unicode::Regex","input::ByteInput","input::Char","re_set::bytes::RegexSet","input::CharInput","dfa::Result","re_bytes::CaptureNames","re_bytes::NoExpand","re_bytes::SubCaptureMatches","expand::Ref","literal::imp::Memmem","pikevm::Threads","exec::MatchNfaType","re_set::unicode::SetMatches","dfa::State","dfa::StateFlags","re_set::bytes::SetMatchesIter","dfa::Byte","sparse::SparseSet","prog::InstChar","literal::imp::SingleByteSet","prog::InstBytes","error::Error","backtrack::Job","re_trait::SubCapturesPosIter","dfa::Transitions","re_unicode::SubCaptureMatches","re_unicode::Match","prog::InstEmptyLook","prog::Program","input::InputAt","compile::InstHole","pikevm::Cache","compile::SuffixCacheKey","re_builder::RegexOptions","exec::MatchLiteralType"]},"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append":{"R":["std::vec::Vec","re_bytes::NoExpand","re_bytes::ReplacerRef","std::borrow::Cow","<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>"]},"dfa::Result":{"T":["re_unicode::Match","sparse::SparseSet","re_unicode::SubCaptureMatches","compile::MaybeInst","expand::Ref","prog::InstSplit","compile::InstHole","input::Char","prog::InstEmptyLook","re_set::bytes::SetMatchesIter","literal::imp::Memmem","prog::EmptyLook","re_trait::Locations","dfa::State","re_bytes::SubCaptureMatches","re_set::unicode::SetMatches","prog::InstChar","re_bytes::Regex","literal::imp::LiteralSearcher","prog::InstRanges","literal::imp::Matcher","pikevm::Threads","compile::SuffixCacheEntry","prog::Program","dfa::Byte","dfa::EmptyFlags","exec::MatchNfaType","backtrack::Cache","re_unicode::Regex","literal::imp::SingleByteSet","prog::Inst","expand::CaptureRef","exec::MatchLiteralType","re_set::unicode::RegexSet","prog::InstBytes","exec::Exec","re_trait::SubCapturesPosIter","re_bytes::CaptureLocations","re_set::bytes::SetMatches","dfa::StateFlags","re_bytes::NoExpand","pikevm::Cache","re_bytes::Match","input::ByteInput","exec::MatchType","input::CharInput","input::InputAt","compile::SuffixCacheKey","re_unicode::CaptureLocations","prog::InstSave","re_builder::RegexOptions","re_set::bytes::RegexSet","re_bytes::CaptureNames","backtrack::Job","re_unicode::CaptureNames","re_set::unicode::SetMatchesIter","pikevm::FollowEpsilon","dfa::Result","error::Error","re_unicode::NoExpand","std::clone::impls::<impl std::clone::Clone for &T>","dfa::Transitions"]},"std::borrow::Cow":{"B":["std::path::Path","std::ffi::OsStr","std::ffi::CStr","<T as std::borrow::ToOwned>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::ReplacerRef<'a, R>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<re_bytes::ReplacerRef<'a, R>>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion
'a
deps:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::borrow::ToOwned>":{"T":["std::clone::Clone","std::marker::Sized"]},"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion":{"R":["re_bytes::Replacer"]},"dfa::Result":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["std::marker::Sized","std::alloc::Allocator"],"T":["std::marker::Sized"]}}
candidates:{"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>":{},"<&'a std::vec::Vec<u8> as re_bytes::Replacer>":{},"<&A as std::alloc::Allocator>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_bytes::Replacer>":{"F":["core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"<T as std::borrow::ToOwned>":{"T":["re_bytes::NoExpand","literal::imp::Memmem","exec::MatchLiteralType","pikevm::Threads","expand::CaptureRef","prog::InstChar","re_set::bytes::SetMatches","expand::Ref","prog::InstBytes","re_set::unicode::SetMatchesIter","re_set::unicode::SetMatches","backtrack::Job","dfa::StateFlags","prog::InstEmptyLook","compile::InstHole","re_unicode::Match","pikevm::Cache","exec::MatchNfaType","dfa::State","re_unicode::CaptureLocations","re_set::unicode::RegexSet","literal::imp::SingleByteSet","literal::imp::LiteralSearcher","re_bytes::SubCaptureMatches","re_trait::Locations","pikevm::FollowEpsilon","re_set::bytes::SetMatchesIter","re_bytes::Match","prog::InstRanges","error::Error","re_unicode::Regex","re_trait::SubCapturesPosIter","compile::MaybeInst","re_set::bytes::RegexSet","input::ByteInput","exec::Exec","re_builder::RegexOptions","exec::MatchType","sparse::SparseSet","prog::Program","input::CharInput","re_unicode::NoExpand","dfa::Byte","prog::InstSave","backtrack::Cache","re_unicode::CaptureNames","dfa::Transitions","re_bytes::CaptureNames","literal::imp::Matcher","compile::SuffixCacheKey","input::InputAt","prog::Inst","re_bytes::CaptureLocations","std::clone::impls::<impl std::clone::Clone for *mut T>","dfa::EmptyFlags","prog::EmptyLook","compile::SuffixCacheEntry","input::Char","re_bytes::Regex","prog::InstSplit","dfa::Result","re_unicode::SubCaptureMatches"]},"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion":{"R":["<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>","std::vec::Vec","re_bytes::ReplacerRef","re_bytes::NoExpand","std::borrow::Cow"]},"dfa::Result":{"T":["re_trait::Locations","re_unicode::NoExpand","re_bytes::CaptureNames","literal::imp::SingleByteSet","re_set::unicode::SetMatchesIter","backtrack::Cache","re_bytes::Match","exec::MatchType","re_set::unicode::SetMatches","literal::imp::Matcher","re_unicode::SubCaptureMatches","re_set::unicode::RegexSet","re_unicode::Regex","compile::InstHole","prog::InstRanges","compile::SuffixCacheKey","prog::Program","expand::CaptureRef","pikevm::Cache","re_bytes::SubCaptureMatches","dfa::Result","prog::EmptyLook","pikevm::FollowEpsilon","prog::InstEmptyLook","input::Char","re_unicode::CaptureLocations","compile::MaybeInst","re_bytes::Regex","dfa::State","dfa::EmptyFlags","dfa::StateFlags","re_set::bytes::RegexSet","exec::Exec","prog::InstSave","exec::MatchLiteralType","input::ByteInput","re_trait::SubCapturesPosIter","re_unicode::Match","expand::Ref","re_set::bytes::SetMatchesIter","re_builder::RegexOptions","prog::InstChar","error::Error","prog::InstSplit","literal::imp::LiteralSearcher","input::CharInput","prog::Inst","sparse::SparseSet","input::InputAt","re_unicode::CaptureNames","literal::imp::Memmem","compile::SuffixCacheEntry","re_bytes::NoExpand","dfa::Transitions","pikevm::Threads","exec::MatchNfaType","prog::InstBytes","backtrack::Job","<*const T as std::fmt::Debug>","re_set::bytes::SetMatches","re_bytes::CaptureLocations","dfa::Byte"]},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::ffi::OsStr","std::ffi::CStr","std::path::Path"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::vec::Vec":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::ReplacerRef<'a, R>
+p0.no_expansion();
+<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion(p0);
+crate::<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion(p0);
+<re_bytes::ReplacerRef<'a, R>>::no_expansion(p0);
-----------------
src/re_bytes.rs <&'a [u8] as re_bytes::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<&'a [u8] as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<&'a [u8] as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<&'a [u8]>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <&'a [u8] as re_bytes::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut [0u8].as_mut_slice(); // None+&'a [u8]
+p0.no_expansion();
+<&'a [u8] as re_bytes::Replacer>::no_expansion(p0);
+crate::<&'a [u8] as re_bytes::Replacer>::no_expansion(p0);
+<&'a [u8]>::no_expansion(p0);
-----------------
src/re_bytes.rs <&'a std::vec::Vec<u8> as re_bytes::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<&'a std::vec::Vec<u8> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<&'a std::vec::Vec<u8> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<&'a std::vec::Vec<u8>>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <&'a std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.no_expansion();
+<&'a std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion(p0);
+crate::<&'a std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion(p0);
+<&'a std::vec::Vec<u8>>::no_expansion(p0);
-----------------
src/re_bytes.rs <std::vec::Vec<u8> as re_bytes::Replacer>::replace_append
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<std::vec::Vec<u8> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<std::vec::Vec<u8> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<std::vec::Vec<u8>>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.no_expansion();
+<std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion(p0);
+crate::<std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion(p0);
+<std::vec::Vec<u8>>::no_expansion(p0);
-----------------
src/re_bytes.rs <std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, [u8]>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<std::borrow::Cow<'a, [u8]>>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, [u8]>
+p0.no_expansion();
+<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion(p0);
+crate::<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion(p0);
+<std::borrow::Cow<'a, [u8]>>::no_expansion(p0);
-----------------
src/re_bytes.rs <&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, [u8]>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<&'a std::borrow::Cow<'a, [u8]>>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, [u8]>
+p0.no_expansion();
+<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion(p0);
+crate::<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion(p0);
+<&'a std::borrow::Cow<'a, [u8]>>::no_expansion(p0);
-----------------
src/re_bytes.rs <F as re_bytes::Replacer>::replace_append
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<F as re_bytes::Replacer>::replace_append":{"F":["std::ops::FnMut","std::marker::Sized"],"T":["std::marker::Sized","std::convert::AsRef"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<F as re_bytes::Replacer>::replace_append":{"F":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap"],"T":["std::vec::Drain<'a, T, A>","std::borrow::Cow<'_, T>","std::rc::Rc<T>","<&T as std::convert::AsRef<U>>","std::slice::Iter<'_, T>","std::borrow::Cow<'_, std::ffi::OsStr>","std::ffi::CString","std::boxed::Box<T, A>","std::ffi::CStr","core::num::dec2flt::common::AsciiStr<'a>","std::sync::Arc<T>","std::slice::IterMut<'_, T>","std::vec::IntoIter<T, A>","<&mut T as std::convert::AsRef<U>>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // F
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<F as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<F as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<F>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <re_bytes::NoExpand<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::NoExpand<'t>
+p0.clone();
+<re_bytes::NoExpand<'t> as std::clone::Clone>::clone(p0);
+crate::<re_bytes::NoExpand<'t> as std::clone::Clone>::clone(p0);
+<re_bytes::NoExpand<'t>>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::NoExpand<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::NoExpand<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::NoExpand<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::NoExpand<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::NoExpand<'t>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::NoExpand<'t> as re_bytes::Replacer>::replace_append
't
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::NoExpand<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<re_bytes::NoExpand<'t> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<re_bytes::NoExpand<'t> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<re_bytes::NoExpand<'t>>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <re_bytes::NoExpand<'t> as re_bytes::Replacer>::no_expansion
't
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::NoExpand<'t>
+p0.no_expansion();
+<re_bytes::NoExpand<'t> as re_bytes::Replacer>::no_expansion(p0);
+crate::<re_bytes::NoExpand<'t> as re_bytes::Replacer>::no_expansion(p0);
+<re_bytes::NoExpand<'t>>::no_expansion(p0);
-----------------
src/re_set.rs <re_set::unicode::RegexSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
+p0.clone();
+<re_set::unicode::RegexSet as std::clone::Clone>::clone(p0);
+crate::<re_set::unicode::RegexSet as std::clone::Clone>::clone(p0);
+<re_set::unicode::RegexSet>::clone(p0);
-----------------
src/re_set.rs re_set::unicode::RegexSet::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"re_set::unicode::RegexSet::new":{"I":["std::iter::IntoIterator","std::marker::Sized"],"S":["std::marker::Sized","std::convert::AsRef"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["dfa::InstPtrs","re_unicode::CaptureMatches","re_unicode::Split","re_unicode::CaptureNames","re_set::unicode::SetMatchesIter","re_bytes::CaptureMatches","re_trait::SubCapturesPosIter","re_set::unicode::SetMatchesIntoIter","re_bytes::SplitN","re_bytes::Matches","re_bytes::Split","re_trait::Matches","re_set::bytes::SetMatchesIntoIter","re_set::bytes::SetMatchesIter","re_unicode::SubCaptureMatches","re_bytes::CaptureNames","<&mut I as std::iter::Iterator>","re_unicode::Matches","re_trait::CaptureMatches","re_bytes::SubCaptureMatches","literal::imp::LiteralIter","re_unicode::SplitN"]},"re_set::unicode::RegexSet::new":{"I":["<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>","re_set::bytes::SetMatches","re_set::unicode::SetMatches","<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>"],"S":["std::borrow::Cow<'_, std::ffi::OsStr>","std::vec::Drain<'a, T, A>","std::borrow::Cow<'_, T>","<&mut T as std::convert::AsRef<U>>","std::rc::Rc<T>","core::num::dec2flt::common::AsciiStr<'a>","std::ffi::CString","std::boxed::Box<T, A>","std::vec::IntoIter<T, A>","std::ffi::CStr","<&T as std::convert::AsRef<U>>","std::slice::Iter<'_, T>","std::sync::Arc<T>","std::slice::IterMut<'_, T>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+re_set::unicode::RegexSet::new(p0);
+crate::re_set::unicode::RegexSet::new(p0);
+<re_set::unicode::RegexSet>::new(p0);
-----------------
src/re_set.rs re_set::unicode::RegexSet::empty
deps:{}
candidates:{}
+re_set::unicode::RegexSet::empty();
+crate::re_set::unicode::RegexSet::empty();
+<re_set::unicode::RegexSet>::empty();
-----------------
src/re_set.rs re_set::unicode::RegexSet::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = "sample"; // None+&str
+p0.is_match(&p1);
+re_set::unicode::RegexSet::is_match(p0, &p1);
+crate::re_set::unicode::RegexSet::is_match(p0, &p1);
+<re_set::unicode::RegexSet>::is_match(p0, &p1);
-----------------
src/re_set.rs re_set::unicode::RegexSet::is_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.is_match_at(&p1, p2);
+re_set::unicode::RegexSet::is_match_at(p0, &p1, p2);
+crate::re_set::unicode::RegexSet::is_match_at(p0, &p1, p2);
+<re_set::unicode::RegexSet>::is_match_at(p0, &p1, p2);
-----------------
src/re_set.rs re_set::unicode::RegexSet::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = "sample"; // None+&str
+p0.matches(&p1);
+re_set::unicode::RegexSet::matches(p0, &p1);
+crate::re_set::unicode::RegexSet::matches(p0, &p1);
+<re_set::unicode::RegexSet>::matches(p0, &p1);
-----------------
src/re_set.rs re_set::unicode::RegexSet::read_matches_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = "sample"; // None+&str
let mut p3 = 0usize; // None+usize
+p0.read_matches_at(p1, &p2, p3);
+re_set::unicode::RegexSet::read_matches_at(p0, p1, &p2, p3);
+crate::re_set::unicode::RegexSet::read_matches_at(p0, p1, &p2, p3);
+<re_set::unicode::RegexSet>::read_matches_at(p0, p1, &p2, p3);
-----------------
src/re_set.rs re_set::unicode::RegexSet::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
+p0.len();
+re_set::unicode::RegexSet::len(p0);
+crate::re_set::unicode::RegexSet::len(p0);
+<re_set::unicode::RegexSet>::len(p0);
-----------------
src/re_set.rs re_set::unicode::RegexSet::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
+p0.is_empty();
+re_set::unicode::RegexSet::is_empty(p0);
+crate::re_set::unicode::RegexSet::is_empty(p0);
+<re_set::unicode::RegexSet>::is_empty(p0);
-----------------
src/re_set.rs re_set::unicode::RegexSet::patterns
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
+p0.patterns();
+re_set::unicode::RegexSet::patterns(p0);
+crate::re_set::unicode::RegexSet::patterns(p0);
+<re_set::unicode::RegexSet>::patterns(p0);
-----------------
src/re_set.rs <re_set::unicode::RegexSet as std::default::Default>::default
deps:{}
candidates:{}
+<re_set::unicode::RegexSet as std::default::Default>::default();
+crate::<re_set::unicode::RegexSet as std::default::Default>::default();
+<re_set::unicode::RegexSet>::default();
-----------------
src/re_set.rs <re_set::unicode::SetMatches as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.clone();
+<re_set::unicode::SetMatches as std::clone::Clone>::clone(p0);
+crate::<re_set::unicode::SetMatches as std::clone::Clone>::clone(p0);
+<re_set::unicode::SetMatches>::clone(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatches as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::unicode::SetMatches as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::unicode::SetMatches as std::fmt::Debug>::fmt(p0, p1);
+<re_set::unicode::SetMatches>::fmt(p0, p1);
-----------------
src/re_set.rs re_set::unicode::SetMatches::matched_any
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.matched_any();
+re_set::unicode::SetMatches::matched_any(p0);
+crate::re_set::unicode::SetMatches::matched_any(p0);
+<re_set::unicode::SetMatches>::matched_any(p0);
-----------------
src/re_set.rs re_set::unicode::SetMatches::matched
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
let mut p1 = 0usize; // None+usize
+p0.matched(p1);
+re_set::unicode::SetMatches::matched(p0, p1);
+crate::re_set::unicode::SetMatches::matched(p0, p1);
+<re_set::unicode::SetMatches>::matched(p0, p1);
-----------------
src/re_set.rs re_set::unicode::SetMatches::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.len();
+re_set::unicode::SetMatches::len(p0);
+crate::re_set::unicode::SetMatches::len(p0);
+<re_set::unicode::SetMatches>::len(p0);
-----------------
src/re_set.rs re_set::unicode::SetMatches::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.iter();
+re_set::unicode::SetMatches::iter(p0);
+crate::re_set::unicode::SetMatches::iter(p0);
+<re_set::unicode::SetMatches>::iter(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.into_iter();
+<re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+crate::<re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+<re_set::unicode::SetMatches>::into_iter(p0);
-----------------
src/re_set.rs <&'a re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.into_iter();
+<&'a re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+<&'a re_set::unicode::SetMatches>::into_iter(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIntoIter as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIntoIter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::unicode::SetMatchesIntoIter as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::unicode::SetMatchesIntoIter as std::fmt::Debug>::fmt(p0, p1);
+<re_set::unicode::SetMatchesIntoIter>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIntoIter
+p0.next();
+<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::next(p0);
+crate::<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::next(p0);
+<re_set::unicode::SetMatchesIntoIter>::next(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::size_hint
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIntoIter
+p0.size_hint();
+<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::size_hint(p0);
+crate::<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::size_hint(p0);
+<re_set::unicode::SetMatchesIntoIter>::size_hint(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIntoIter
+p0.next_back();
+<re_set::unicode::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<re_set::unicode::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+<re_set::unicode::SetMatchesIntoIter>::next_back(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
+p0.clone();
+<re_set::unicode::SetMatchesIter<'a> as std::clone::Clone>::clone(p0);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::clone::Clone>::clone(p0);
+<re_set::unicode::SetMatchesIter<'a>>::clone(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::unicode::SetMatchesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<re_set::unicode::SetMatchesIter<'a>>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
+p0.next();
+<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::next(p0);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::next(p0);
+<re_set::unicode::SetMatchesIter<'a>>::next(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
+p0.size_hint();
+<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::size_hint(p0);
+<re_set::unicode::SetMatchesIter<'a>>::size_hint(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
+p0.next_back();
+<re_set::unicode::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<re_set::unicode::SetMatchesIter<'a>>::next_back(p0);
-----------------
src/re_set.rs <re_set::unicode::RegexSet as std::convert::From<exec::Exec>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+<re_set::unicode::RegexSet as std::convert::From<exec::Exec>>::from(p0);
+crate::<re_set::unicode::RegexSet as std::convert::From<exec::Exec>>::from(p0);
+<re_set::unicode::RegexSet>::from(p0);
-----------------
src/re_set.rs <re_set::unicode::RegexSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::unicode::RegexSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::unicode::RegexSet as std::fmt::Debug>::fmt(p0, p1);
+<re_set::unicode::RegexSet>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::bytes::RegexSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
+p0.clone();
+<re_set::bytes::RegexSet as std::clone::Clone>::clone(p0);
+crate::<re_set::bytes::RegexSet as std::clone::Clone>::clone(p0);
+<re_set::bytes::RegexSet>::clone(p0);
-----------------
src/re_set.rs re_set::bytes::RegexSet::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"re_set::bytes::RegexSet::new":{"I":["std::iter::IntoIterator","std::marker::Sized"],"S":["std::marker::Sized","std::convert::AsRef"]},"re_trait::CaptureMatches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::fmt::Debug","re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["re_bytes::Matches","re_bytes::CaptureMatches","re_trait::SubCapturesPosIter","re_unicode::Matches","re_bytes::SubCaptureMatches","re_set::unicode::SetMatchesIter","re_set::unicode::SetMatchesIntoIter","dfa::InstPtrs","literal::imp::LiteralIter","re_bytes::Split","re_unicode::SplitN","re_set::bytes::SetMatchesIntoIter","re_set::bytes::SetMatchesIter","<&mut I as std::iter::Iterator>","re_unicode::CaptureMatches","re_unicode::SubCaptureMatches","re_unicode::Split","re_bytes::CaptureNames","re_trait::CaptureMatches","re_unicode::CaptureNames","re_trait::Matches","re_bytes::SplitN"]},"re_set::bytes::RegexSet::new":{"I":["re_set::unicode::SetMatches","re_set::bytes::SetMatches","<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>","<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>"],"S":["std::vec::IntoIter<T, A>","std::rc::Rc<T>","std::vec::Drain<'a, T, A>","<&T as std::convert::AsRef<U>>","std::ffi::CStr","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, std::ffi::OsStr>","std::boxed::Box<T, A>","std::ffi::CString","std::borrow::Cow<'_, T>","std::slice::IterMut<'_, T>","<&mut T as std::convert::AsRef<U>>","std::sync::Arc<T>","std::slice::Iter<'_, T>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+re_set::bytes::RegexSet::new(p0);
+crate::re_set::bytes::RegexSet::new(p0);
+<re_set::bytes::RegexSet>::new(p0);
-----------------
src/re_set.rs re_set::bytes::RegexSet::empty
deps:{}
candidates:{}
+re_set::bytes::RegexSet::empty();
+crate::re_set::bytes::RegexSet::empty();
+<re_set::bytes::RegexSet>::empty();
-----------------
src/re_set.rs re_set::bytes::RegexSet::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.is_match(p1);
+re_set::bytes::RegexSet::is_match(p0, p1);
+crate::re_set::bytes::RegexSet::is_match(p0, p1);
+<re_set::bytes::RegexSet>::is_match(p0, p1);
-----------------
src/re_set.rs re_set::bytes::RegexSet::is_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.is_match_at(p1, p2);
+re_set::bytes::RegexSet::is_match_at(p0, p1, p2);
+crate::re_set::bytes::RegexSet::is_match_at(p0, p1, p2);
+<re_set::bytes::RegexSet>::is_match_at(p0, p1, p2);
-----------------
src/re_set.rs re_set::bytes::RegexSet::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.matches(p1);
+re_set::bytes::RegexSet::matches(p0, p1);
+crate::re_set::bytes::RegexSet::matches(p0, p1);
+<re_set::bytes::RegexSet>::matches(p0, p1);
-----------------
src/re_set.rs re_set::bytes::RegexSet::read_matches_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.read_matches_at(p1, p2, p3);
+re_set::bytes::RegexSet::read_matches_at(p0, p1, p2, p3);
+crate::re_set::bytes::RegexSet::read_matches_at(p0, p1, p2, p3);
+<re_set::bytes::RegexSet>::read_matches_at(p0, p1, p2, p3);
-----------------
src/re_set.rs re_set::bytes::RegexSet::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
+p0.len();
+re_set::bytes::RegexSet::len(p0);
+crate::re_set::bytes::RegexSet::len(p0);
+<re_set::bytes::RegexSet>::len(p0);
-----------------
src/re_set.rs re_set::bytes::RegexSet::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
+p0.is_empty();
+re_set::bytes::RegexSet::is_empty(p0);
+crate::re_set::bytes::RegexSet::is_empty(p0);
+<re_set::bytes::RegexSet>::is_empty(p0);
-----------------
src/re_set.rs re_set::bytes::RegexSet::patterns
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
+p0.patterns();
+re_set::bytes::RegexSet::patterns(p0);
+crate::re_set::bytes::RegexSet::patterns(p0);
+<re_set::bytes::RegexSet>::patterns(p0);
-----------------
src/re_set.rs <re_set::bytes::RegexSet as std::default::Default>::default
deps:{}
candidates:{}
+<re_set::bytes::RegexSet as std::default::Default>::default();
+crate::<re_set::bytes::RegexSet as std::default::Default>::default();
+<re_set::bytes::RegexSet>::default();
-----------------
src/re_set.rs <re_set::bytes::SetMatches as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.clone();
+<re_set::bytes::SetMatches as std::clone::Clone>::clone(p0);
+crate::<re_set::bytes::SetMatches as std::clone::Clone>::clone(p0);
+<re_set::bytes::SetMatches>::clone(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatches as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::bytes::SetMatches as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::bytes::SetMatches as std::fmt::Debug>::fmt(p0, p1);
+<re_set::bytes::SetMatches>::fmt(p0, p1);
-----------------
src/re_set.rs re_set::bytes::SetMatches::matched_any
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.matched_any();
+re_set::bytes::SetMatches::matched_any(p0);
+crate::re_set::bytes::SetMatches::matched_any(p0);
+<re_set::bytes::SetMatches>::matched_any(p0);
-----------------
src/re_set.rs re_set::bytes::SetMatches::matched
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
let mut p1 = 0usize; // None+usize
+p0.matched(p1);
+re_set::bytes::SetMatches::matched(p0, p1);
+crate::re_set::bytes::SetMatches::matched(p0, p1);
+<re_set::bytes::SetMatches>::matched(p0, p1);
-----------------
src/re_set.rs re_set::bytes::SetMatches::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.len();
+re_set::bytes::SetMatches::len(p0);
+crate::re_set::bytes::SetMatches::len(p0);
+<re_set::bytes::SetMatches>::len(p0);
-----------------
src/re_set.rs re_set::bytes::SetMatches::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.iter();
+re_set::bytes::SetMatches::iter(p0);
+crate::re_set::bytes::SetMatches::iter(p0);
+<re_set::bytes::SetMatches>::iter(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.into_iter();
+<re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+crate::<re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+<re_set::bytes::SetMatches>::into_iter(p0);
-----------------
src/re_set.rs <&'a re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.into_iter();
+<&'a re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+<&'a re_set::bytes::SetMatches>::into_iter(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIntoIter as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIntoIter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::bytes::SetMatchesIntoIter as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::bytes::SetMatchesIntoIter as std::fmt::Debug>::fmt(p0, p1);
+<re_set::bytes::SetMatchesIntoIter>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIntoIter
+p0.next();
+<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::next(p0);
+crate::<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::next(p0);
+<re_set::bytes::SetMatchesIntoIter>::next(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::size_hint
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIntoIter
+p0.size_hint();
+<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::size_hint(p0);
+crate::<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::size_hint(p0);
+<re_set::bytes::SetMatchesIntoIter>::size_hint(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIntoIter
+p0.next_back();
+<re_set::bytes::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<re_set::bytes::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+<re_set::bytes::SetMatchesIntoIter>::next_back(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
+p0.clone();
+<re_set::bytes::SetMatchesIter<'a> as std::clone::Clone>::clone(p0);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::clone::Clone>::clone(p0);
+<re_set::bytes::SetMatchesIter<'a>>::clone(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::bytes::SetMatchesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<re_set::bytes::SetMatchesIter<'a>>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
+p0.next();
+<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::next(p0);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::next(p0);
+<re_set::bytes::SetMatchesIter<'a>>::next(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
+p0.size_hint();
+<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::size_hint(p0);
+<re_set::bytes::SetMatchesIter<'a>>::size_hint(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
+p0.next_back();
+<re_set::bytes::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<re_set::bytes::SetMatchesIter<'a>>::next_back(p0);
-----------------
src/re_set.rs <re_set::bytes::RegexSet as std::convert::From<exec::Exec>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+<re_set::bytes::RegexSet as std::convert::From<exec::Exec>>::from(p0);
+crate::<re_set::bytes::RegexSet as std::convert::From<exec::Exec>>::from(p0);
+<re_set::bytes::RegexSet>::from(p0);
-----------------
src/re_set.rs <re_set::bytes::RegexSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::bytes::RegexSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::bytes::RegexSet as std::fmt::Debug>::fmt(p0, p1);
+<re_set::bytes::RegexSet>::fmt(p0, p1);
-----------------
src/re_trait.rs <re_trait::Locations as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
+p0.clone();
+<re_trait::Locations as std::clone::Clone>::clone(p0);
+crate::<re_trait::Locations as std::clone::Clone>::clone(p0);
+<re_trait::Locations>::clone(p0);
-----------------
src/re_trait.rs <re_trait::Locations as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_trait::Locations as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_trait::Locations as std::fmt::Debug>::fmt(p0, p1);
+<re_trait::Locations>::fmt(p0, p1);
-----------------
src/re_trait.rs re_trait::Locations::pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p1 = 0usize; // None+usize
+p0.pos(p1);
+re_trait::Locations::pos(p0, p1);
+crate::re_trait::Locations::pos(p0, p1);
+<re_trait::Locations>::pos(p0, p1);
-----------------
src/re_trait.rs re_trait::Locations::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
+p0.iter();
+re_trait::Locations::iter(p0);
+crate::re_trait::Locations::iter(p0);
+<re_trait::Locations>::iter(p0);
-----------------
src/re_trait.rs re_trait::Locations::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
+p0.len();
+re_trait::Locations::len(p0);
+crate::re_trait::Locations::len(p0);
+<re_trait::Locations>::len(p0);
-----------------
src/re_trait.rs re_trait::Locations::as_slots
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Locations
+p0.as_slots();
+re_trait::Locations::as_slots(p0);
+crate::re_trait::Locations::as_slots(p0);
+<re_trait::Locations>::as_slots(p0);
-----------------
src/re_trait.rs <re_trait::SubCapturesPosIter<'c> as std::clone::Clone>::clone
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::SubCapturesPosIter<'c>
+p0.clone();
+<re_trait::SubCapturesPosIter<'c> as std::clone::Clone>::clone(p0);
+crate::<re_trait::SubCapturesPosIter<'c> as std::clone::Clone>::clone(p0);
+<re_trait::SubCapturesPosIter<'c>>::clone(p0);
-----------------
src/re_trait.rs <re_trait::SubCapturesPosIter<'c> as std::fmt::Debug>::fmt
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::SubCapturesPosIter<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_trait::SubCapturesPosIter<'c> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_trait::SubCapturesPosIter<'c> as std::fmt::Debug>::fmt(p0, p1);
+<re_trait::SubCapturesPosIter<'c>>::fmt(p0, p1);
-----------------
src/re_trait.rs <re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::next
'c
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::SubCapturesPosIter<'c>
+p0.next();
+<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::next(p0);
+crate::<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::next(p0);
+<re_trait::SubCapturesPosIter<'c>>::next(p0);
-----------------
src/re_trait.rs <re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::size_hint
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::SubCapturesPosIter<'c>
+p0.size_hint();
+<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::size_hint(p0);
+crate::<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::size_hint(p0);
+<re_trait::SubCapturesPosIter<'c>>::size_hint(p0);
-----------------
src/re_trait.rs <re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::count
'c
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_trait::SubCapturesPosIter<'c>
+p0.count();
+<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::count(p0);
+crate::<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::count(p0);
+<re_trait::SubCapturesPosIter<'c>>::count(p0);
-----------------
src/re_trait.rs <re_trait::Matches<'t, R> as std::fmt::Debug>::fmt
't
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_trait::Matches<'t, R> as std::fmt::Debug>::fmt":{"<R as re_trait::RegularExpression>::Text":["std::fmt::Debug"],"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"backtrack::Bounded":{"I":["std::fmt::Debug","input::Input","std::marker::Sized"]},"dfa::Result":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"pikevm::Fsm":{"I":["std::marker::Sized","input::Input","std::fmt::Debug"]},"pool::Pool":{"T":["std::marker::Send","std::marker::Sized","std::fmt::Debug"]},"pool::PoolGuard":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_trait::Matches<'t, R> as std::fmt::Debug>::fmt":{"<R as re_trait::RegularExpression>::Text":["re_set::unicode::SetMatchesIntoIter","expand::CaptureRef","exec::Exec","prog::InstChar","re_bytes::SubCaptureMatches","re_bytes::NoExpand","re_trait::CaptureMatches","sparse::SparseSet","re_bytes::CapturesDebug","re_builder::bytes::RegexBuilder","prog::InstBytes","literal::imp::Matcher","pool::PoolGuard","literal::imp::LiteralIter","exec::MatchNfaType","exec::ExecNoSyncStr","exec::MatchType","re_unicode::Match","prog::Inst","re_set::unicode::SetMatchesIter","re_builder::set_bytes::RegexSetBuilder","dfa::Transitions","error::Error","re_unicode::NoExpand","re_set::unicode::SetMatches","re_unicode::SubCaptureMatches","compile::Hole","re_bytes::CaptureMatches","expand::Ref","input::CharInput","re_set::bytes::SetMatchesIntoIter","re_unicode::CaptureMatches","dfa::StateMap","pool::Pool","pikevm::Threads","input::Char","re_bytes::Regex","dfa::Cache","re_bytes::CaptureLocations","re_unicode::Captures","prog::InstSave","re_trait::Locations","compile::InstHole","re_unicode::Matches","re_set::bytes::RegexSet","re_bytes::Match","prog::EmptyLook","re_unicode::SplitN","pikevm::Cache","compile::SuffixCacheEntry","dfa::State","re_unicode::CaptureNames","re_unicode::Split","prog::InstSplit","dfa::StateFlags","compile::SuffixCache","re_set::unicode::RegexSet","dfa::Byte","prog::InstEmptyLook","dfa::EmptyFlags","re_unicode::Regex","backtrack::Cache","re_set::bytes::SetMatchesIter","pikevm::FollowEpsilon","prog::Program","exec::ProgramCacheInner","re_bytes::Captures","literal::imp::SingleByteSet","literal::imp::LiteralSearcher","exec::MatchLiteralType","compile::MaybeInst","re_bytes::SplitN","re_unicode::CapturesDebug","re_bytes::CaptureNames","exec::ExecReadOnly","input::ByteInput","re_trait::SubCapturesPosIter","backtrack::Job","backtrack::Bounded","dfa::Fsm","prog::InstRanges","re_bytes::Matches","pikevm::Fsm","re_builder::unicode::RegexBuilder","re_builder::RegexOptions","dfa::CacheInner","re_set::bytes::SetMatches","compile::SuffixCacheKey","input::InputAt","re_unicode::ReplacerRef","dfa::TransitionsRow","re_bytes::ReplacerRef","dfa::Result","re_trait::Matches","compile::Patch","re_builder::set_unicode::RegexSetBuilder","exec::ExecNoSync","compile::ByteClassSet","re_bytes::Split","literal::imp::Memmem","<*mut T as std::fmt::Debug>","re_unicode::CaptureLocations"],"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"backtrack::Bounded":{"I":["input::ByteInput","input::CharInput"]},"dfa::Result":{"T":["re_trait::Locations","re_bytes::CaptureNames","pikevm::FollowEpsilon","compile::MaybeInst","re_unicode::Regex","prog::InstBytes","dfa::StateFlags","input::InputAt","re_bytes::CaptureLocations","re_unicode::NoExpand","exec::Exec","re_builder::RegexOptions","input::ByteInput","prog::InstRanges","re_set::unicode::SetMatchesIter","re_set::unicode::RegexSet","error::Error","<*mut T as std::fmt::Debug>","input::Char","dfa::State","literal::imp::LiteralSearcher","re_unicode::CaptureLocations","exec::MatchLiteralType","re_unicode::SubCaptureMatches","re_set::unicode::SetMatches","exec::MatchType","re_trait::SubCapturesPosIter","input::CharInput","re_bytes::SubCaptureMatches","pikevm::Threads","prog::InstEmptyLook","expand::CaptureRef","re_set::bytes::RegexSet","dfa::Transitions","backtrack::Cache","re_unicode::Match","prog::InstSave","prog::Program","pikevm::Cache","prog::Inst","compile::InstHole","re_bytes::Regex","dfa::Result","re_bytes::Match","prog::InstChar","re_set::bytes::SetMatches","re_unicode::CaptureNames","literal::imp::Matcher","prog::InstSplit","literal::imp::Memmem","compile::SuffixCacheKey","sparse::SparseSet","expand::Ref","dfa::Byte","compile::SuffixCacheEntry","dfa::EmptyFlags","re_bytes::NoExpand","exec::MatchNfaType","literal::imp::SingleByteSet","re_set::bytes::SetMatchesIter","backtrack::Job","prog::EmptyLook"]},"pikevm::Fsm":{"I":["input::ByteInput","input::CharInput"]},"pool::Pool":{"T":["std::collections::linked_list::Cursor<'_, T>","std::sync::atomic::AtomicPtr<T>","std::string::Drain<'_>","std::task::Waker","std::io::IoSliceMut<'a>","std::cell::Cell<T>","std::boxed::ThinBox<T>","std::env::ArgsOs","std::collections::LinkedList<T>","std::ptr::DynMetadata<Dyn>","std::rc::Rc<T>","std::env::Args","std::vec::IntoIter<T, A>","std::io::IoSlice<'a>","std::ptr::Unique<T>","std::collections::vec_deque::Drain<'_, T, A>","std::rc::Weak<T>","std::sync::mpmc::Receiver<T>","std::slice::IterMut<'_, T>","std::sync::Mutex<T>","std::thread::JoinHandle<T>","std::sync::RwLock<T>","std::io::error::repr_bitpacked::Repr","std::future::ResumeTy","std::sync::OnceLock<T>","std::sync::mpmc::Sender<T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::mpsc::Sender<T>","std::sync::RwLockReadGuard<'_, T>","std::sync::Weak<T>","std::sync::mpsc::Receiver<T>","std::collections::linked_list::Iter<'_, T>","<*const T as std::marker::Send>","std::ptr::NonNull<T>","std::cell::RefCell<T>","std::sys::unix::args::Args","std::collections::linked_list::IterMut<'_, T>","std::sync::Arc<T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::mpsc::SyncSender<T>","std::sync::MutexGuard<'_, T>","std::slice::Iter<'_, T>","std::vec::Drain<'_, T, A>"]},"pool::PoolGuard":{"T":["std::collections::LinkedList<T>","std::sync::RwLock<T>","std::boxed::ThinBox<T>","std::ptr::Unique<T>","std::sync::MutexGuard<'_, T>","std::collections::linked_list::CursorMut<'_, T>","std::slice::Iter<'_, T>","std::sync::mpsc::Receiver<T>","<*mut T as std::marker::Send>","std::sync::Mutex<T>","std::io::IoSlice<'a>","std::cell::RefCell<T>","std::collections::vec_deque::Drain<'_, T, A>","std::future::ResumeTy","std::sys::unix::args::Args","std::collections::linked_list::Iter<'_, T>","std::sync::mpsc::Sender<T>","std::sync::OnceLock<T>","std::sync::mpsc::SyncSender<T>","std::sync::Arc<T>","std::thread::JoinHandle<T>","std::io::error::repr_bitpacked::Repr","std::ptr::DynMetadata<Dyn>","<*mut T as std::fmt::Debug>","std::sync::mpmc::Receiver<T>","std::slice::IterMut<'_, T>","std::cell::Cell<T>","std::sync::Weak<T>","std::collections::linked_list::IterMut<'_, T>","std::rc::Rc<T>","std::sync::RwLockWriteGuard<'_, T>","std::task::Waker","std::vec::IntoIter<T, A>","std::vec::Drain<'_, T, A>","std::sync::RwLockReadGuard<'_, T>","std::io::IoSliceMut<'a>","std::ptr::NonNull<T>","std::collections::linked_list::Cursor<'_, T>","std::env::Args","std::sync::atomic::AtomicPtr<T>","std::env::ArgsOs","std::string::Drain<'_>","std::rc::Weak<T>","std::sync::mpmc::Sender<T>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Matches<'t, R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_trait::Matches<'t, R> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_trait::Matches<'t, R> as std::fmt::Debug>::fmt(p0, p1);
+<re_trait::Matches<'t, R>>::fmt(p0, p1);
-----------------
src/re_trait.rs re_trait::Matches::<'t, R>::text
't
deps:{"re_trait::Matches::<'t, R>::text":{"R":["re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"re_trait::Matches::<'t, R>::text":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Matches<'t, R>
+p0.text();
+re_trait::Matches::<'t, R>::text(p0);
+crate::re_trait::Matches::<'t, R>::text(p0);
+<re_trait::Matches<'t, R>>::text(p0);
-----------------
src/re_trait.rs re_trait::Matches::<'t, R>::regex
't
deps:{"re_trait::Matches::<'t, R>::regex":{"R":["std::marker::Sized","re_trait::RegularExpression"]}}
candidates:{"re_trait::Matches::<'t, R>::regex":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Matches<'t, R>
+p0.regex();
+re_trait::Matches::<'t, R>::regex(p0);
+crate::re_trait::Matches::<'t, R>::regex(p0);
+<re_trait::Matches<'t, R>>::regex(p0);
-----------------
src/re_trait.rs <re_trait::Matches<'t, R> as std::iter::Iterator>::next
't
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<re_trait::Matches<'t, R> as std::iter::Iterator>::next":{"<R as re_trait::RegularExpression>::Text":["std::convert::AsRef"],"R":["re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<re_trait::Matches<'t, R> as std::iter::Iterator>::next":{"<R as re_trait::RegularExpression>::Text":["std::ffi::CString","std::vec::Drain<'a, T, A>","<&T as std::convert::AsRef<U>>","std::vec::IntoIter<T, A>","std::borrow::Cow<'_, std::ffi::OsStr>","std::boxed::Box<T, A>","core::num::dec2flt::common::AsciiStr<'a>","std::rc::Rc<T>","std::sync::Arc<T>","std::slice::Iter<'_, T>","std::borrow::Cow<'_, T>","std::slice::IterMut<'_, T>","std::ffi::CStr"],"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Matches<'t, R>
+p0.next();
+<re_trait::Matches<'t, R> as std::iter::Iterator>::next(p0);
+crate::<re_trait::Matches<'t, R> as std::iter::Iterator>::next(p0);
+<re_trait::Matches<'t, R>>::next(p0);
-----------------
src/re_trait.rs <re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt
't
deps:{"<re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt":{"R":["std::fmt::Debug","re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"<re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::CaptureMatches<'t, R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt(p0, p1);
+<re_trait::CaptureMatches<'t, R>>::fmt(p0, p1);
-----------------
src/re_trait.rs re_trait::CaptureMatches::<'t, R>::text
't
deps:{"re_trait::CaptureMatches::<'t, R>::text":{"R":["re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"re_trait::CaptureMatches::<'t, R>::text":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::CaptureMatches<'t, R>
+p0.text();
+re_trait::CaptureMatches::<'t, R>::text(p0);
+crate::re_trait::CaptureMatches::<'t, R>::text(p0);
+<re_trait::CaptureMatches<'t, R>>::text(p0);
-----------------
src/re_trait.rs re_trait::CaptureMatches::<'t, R>::regex
't
deps:{"re_trait::CaptureMatches::<'t, R>::regex":{"R":["std::marker::Sized","re_trait::RegularExpression"]}}
candidates:{"re_trait::CaptureMatches::<'t, R>::regex":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::CaptureMatches<'t, R>
+p0.regex();
+re_trait::CaptureMatches::<'t, R>::regex(p0);
+crate::re_trait::CaptureMatches::<'t, R>::regex(p0);
+<re_trait::CaptureMatches<'t, R>>::regex(p0);
-----------------
src/re_trait.rs <re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next
't
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next":{"<R as re_trait::RegularExpression>::Text":["std::convert::AsRef"],"R":["re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next":{"<R as re_trait::RegularExpression>::Text":["std::sync::Arc<T>","std::vec::IntoIter<T, A>","std::ffi::CString","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, std::ffi::OsStr>","std::rc::Rc<T>","std::slice::IterMut<'_, T>","std::ffi::CStr","std::boxed::Box<T, A>","std::borrow::Cow<'_, T>","<&T as std::convert::AsRef<U>>","std::slice::Iter<'_, T>","std::vec::Drain<'a, T, A>"],"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::CaptureMatches<'t, R>
+p0.next();
+<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next(p0);
+crate::<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next(p0);
+<re_trait::CaptureMatches<'t, R>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::Match<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.clone();
+<re_unicode::Match<'t> as std::clone::Clone>::clone(p0);
+crate::<re_unicode::Match<'t> as std::clone::Clone>::clone(p0);
+<re_unicode::Match<'t>>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.assert_receiver_is_total_eq();
+<re_unicode::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<re_unicode::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<re_unicode::Match<'t>>::assert_receiver_is_total_eq(p0);
-----------------
src/re_unicode.rs <re_unicode::Match<'t> as std::cmp::PartialEq>::eq
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.eq(p1);
+<re_unicode::Match<'t> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<re_unicode::Match<'t> as std::cmp::PartialEq>::eq(p0, p1);
+<re_unicode::Match<'t>>::eq(p0, p1);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::start
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.start();
+re_unicode::Match::<'t>::start(p0);
+crate::re_unicode::Match::<'t>::start(p0);
+<re_unicode::Match<'t>>::start(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::end
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.end();
+re_unicode::Match::<'t>::end(p0);
+crate::re_unicode::Match::<'t>::end(p0);
+<re_unicode::Match<'t>>::end(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::is_empty
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.is_empty();
+re_unicode::Match::<'t>::is_empty(p0);
+crate::re_unicode::Match::<'t>::is_empty(p0);
+<re_unicode::Match<'t>>::is_empty(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.len();
+re_unicode::Match::<'t>::len(p0);
+crate::re_unicode::Match::<'t>::len(p0);
+<re_unicode::Match<'t>>::len(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::range
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.range();
+re_unicode::Match::<'t>::range(p0);
+crate::re_unicode::Match::<'t>::range(p0);
+<re_unicode::Match<'t>>::range(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::as_str
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.as_str();
+re_unicode::Match::<'t>::as_str(p0);
+crate::re_unicode::Match::<'t>::as_str(p0);
+<re_unicode::Match<'t>>::as_str(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::new
't
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+re_unicode::Match::<'t>::new(&p0, p1, p2);
+crate::re_unicode::Match::<'t>::new(&p0, p1, p2);
+<re_unicode::Match<'t>>::new(&p0, p1, p2);
-----------------
src/re_unicode.rs <re_unicode::Match<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Match<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Match<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Match<'t>>::fmt(p0, p1);
-----------------
src/re_unicode.rs re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for &'t str>::from
't
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for &'t str>::from(p0);
+crate::re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for &'t str>::from(p0);
+<&'t str>::from(p0);
-----------------
src/re_unicode.rs re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for std::ops::Range<usize>>::from
't
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for std::ops::Range<usize>>::from(p0);
+crate::re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for std::ops::Range<usize>>::from(p0);
+<std::ops::Range<usize>>::from(p0);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.clone();
+<re_unicode::Regex as std::clone::Clone>::clone(p0);
+crate::<re_unicode::Regex as std::clone::Clone>::clone(p0);
+<re_unicode::Regex>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<re_unicode::Regex as std::fmt::Display>::fmt(p0, p1);
+crate::<re_unicode::Regex as std::fmt::Display>::fmt(p0, p1);
+<re_unicode::Regex>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Regex as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Regex as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Regex>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::convert::From<exec::Exec>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+<re_unicode::Regex as std::convert::From<exec::Exec>>::from(p0);
+crate::<re_unicode::Regex as std::convert::From<exec::Exec>>::from(p0);
+<re_unicode::Regex>::from(p0);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<re_unicode::Regex as std::str::FromStr>::from_str(&p0);
+crate::<re_unicode::Regex as std::str::FromStr>::from_str(&p0);
+<re_unicode::Regex>::from_str(&p0);
-----------------
src/re_unicode.rs re_unicode::Regex::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_unicode::Regex::new(&p0);
+crate::re_unicode::Regex::new(&p0);
+<re_unicode::Regex>::new(&p0);
-----------------
src/re_unicode.rs re_unicode::Regex::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.is_match(&p1);
+re_unicode::Regex::is_match(p0, &p1);
+crate::re_unicode::Regex::is_match(p0, &p1);
+<re_unicode::Regex>::is_match(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.find(&p1);
+re_unicode::Regex::find(p0, &p1);
+crate::re_unicode::Regex::find(p0, &p1);
+<re_unicode::Regex>::find(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::find_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.find_iter(&p1);
+re_unicode::Regex::find_iter(p0, &p1);
+crate::re_unicode::Regex::find_iter(p0, &p1);
+<re_unicode::Regex>::find_iter(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::captures
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.captures(&p1);
+re_unicode::Regex::captures(p0, &p1);
+crate::re_unicode::Regex::captures(p0, &p1);
+<re_unicode::Regex>::captures(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::captures_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.captures_iter(&p1);
+re_unicode::Regex::captures_iter(p0, &p1);
+crate::re_unicode::Regex::captures_iter(p0, &p1);
+<re_unicode::Regex>::captures_iter(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::split
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.split(&p1);
+re_unicode::Regex::split(p0, &p1);
+crate::re_unicode::Regex::split(p0, &p1);
+<re_unicode::Regex>::split(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::splitn
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.splitn(&p1, p2);
+re_unicode::Regex::splitn(p0, &p1, p2);
+crate::re_unicode::Regex::splitn(p0, &p1, p2);
+<re_unicode::Regex>::splitn(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::replace
deps:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::borrow::ToOwned>":{"T":["std::clone::Clone","std::marker::Sized"]},"dfa::Result":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"re_unicode::Regex::replace":{"R":["re_unicode::Replacer","std::marker::Sized"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::borrow::ToOwned>":{"T":["re_set::unicode::RegexSet","input::CharInput","prog::InstEmptyLook","re_unicode::CaptureLocations","compile::SuffixCacheKey","input::Char","dfa::EmptyFlags","prog::Inst","error::Error","prog::InstSplit","compile::InstHole","compile::SuffixCacheEntry","re_bytes::NoExpand","exec::MatchLiteralType","dfa::Result","pikevm::Cache","re_set::bytes::SetMatchesIter","literal::imp::SingleByteSet","prog::InstBytes","re_unicode::Regex","backtrack::Job","prog::EmptyLook","re_bytes::Regex","literal::imp::Matcher","re_bytes::CaptureNames","re_set::unicode::SetMatches","re_set::bytes::RegexSet","re_builder::RegexOptions","re_bytes::CaptureLocations","prog::InstChar","std::clone::impls::<impl std::clone::Clone for *const T>","dfa::StateFlags","re_bytes::SubCaptureMatches","re_trait::SubCapturesPosIter","dfa::State","prog::Program","input::ByteInput","pikevm::FollowEpsilon","literal::imp::LiteralSearcher","exec::MatchType","compile::MaybeInst","expand::Ref","backtrack::Cache","re_bytes::Match","re_unicode::CaptureNames","prog::InstRanges","dfa::Byte","re_unicode::NoExpand","re_set::unicode::SetMatchesIter","re_unicode::Match","dfa::Transitions","expand::CaptureRef","prog::InstSave","re_unicode::SubCaptureMatches","re_trait::Locations","literal::imp::Memmem","exec::Exec","sparse::SparseSet","input::InputAt","pikevm::Threads","re_set::bytes::SetMatches","exec::MatchNfaType"]},"dfa::Result":{"T":["pikevm::FollowEpsilon","input::ByteInput","prog::Inst","re_unicode::NoExpand","backtrack::Cache","error::Error","exec::Exec","literal::imp::LiteralSearcher","re_unicode::Regex","dfa::EmptyFlags","re_set::bytes::SetMatchesIter","pikevm::Cache","re_bytes::SubCaptureMatches","prog::InstChar","re_set::unicode::RegexSet","re_builder::RegexOptions","dfa::Transitions","re_set::unicode::SetMatches","prog::InstRanges","prog::InstSave","re_unicode::Match","exec::MatchLiteralType","input::InputAt","sparse::SparseSet","re_set::bytes::RegexSet","prog::InstEmptyLook","re_unicode::SubCaptureMatches","pikevm::Threads","re_unicode::CaptureNames","literal::imp::Memmem","backtrack::Job","re_bytes::CaptureNames","exec::MatchNfaType","dfa::Byte","literal::imp::SingleByteSet","input::CharInput","prog::Program","prog::EmptyLook","re_bytes::NoExpand","re_set::unicode::SetMatchesIter","std::clone::impls::<impl std::clone::Clone for &mut T>","literal::imp::Matcher","exec::MatchType","input::Char","compile::MaybeInst","re_trait::SubCapturesPosIter","re_bytes::CaptureLocations","dfa::StateFlags","compile::SuffixCacheKey","re_set::bytes::SetMatches","re_trait::Locations","compile::InstHole","expand::Ref","dfa::State","compile::SuffixCacheEntry","re_bytes::Match","re_unicode::CaptureLocations","dfa::Result","prog::InstBytes","prog::InstSplit","expand::CaptureRef","re_bytes::Regex"]},"re_unicode::Regex::replace":{"R":["re_unicode::NoExpand","std::string::String","re_unicode::ReplacerRef","<F as re_unicode::Replacer>","std::borrow::Cow"]},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::path::Path","std::ffi::OsStr","std::ffi::CStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // R
+p0.replace(&p1, p2);
+re_unicode::Regex::replace(p0, &p1, p2);
+crate::re_unicode::Regex::replace(p0, &p1, p2);
+<re_unicode::Regex>::replace(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::replace_all
deps:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::ToOwned>":{"T":["std::clone::Clone","std::marker::Sized"]},"dfa::Result":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"re_unicode::Regex::replace_all":{"R":["std::marker::Sized","re_unicode::Replacer"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"]},"<T as std::borrow::ToOwned>":{"T":["re_trait::SubCapturesPosIter","input::InputAt","sparse::SparseSet","pikevm::Cache","re_set::bytes::RegexSet","std::clone::impls::<impl std::clone::Clone for &mut T>","backtrack::Cache","compile::SuffixCacheKey","prog::EmptyLook","literal::imp::LiteralSearcher","prog::InstSave","expand::CaptureRef","re_bytes::NoExpand","pikevm::Threads","prog::InstRanges","exec::Exec","re_trait::Locations","prog::InstSplit","compile::MaybeInst","re_unicode::Regex","dfa::Result","re_unicode::CaptureLocations","re_unicode::CaptureNames","dfa::StateFlags","prog::InstBytes","re_set::unicode::RegexSet","re_bytes::CaptureLocations","error::Error","backtrack::Job","re_unicode::SubCaptureMatches","input::ByteInput","expand::Ref","prog::Inst","dfa::EmptyFlags","prog::InstEmptyLook","compile::SuffixCacheEntry","literal::imp::Matcher","compile::InstHole","dfa::State","dfa::Transitions","input::CharInput","dfa::Byte","re_set::unicode::SetMatchesIter","re_unicode::NoExpand","literal::imp::SingleByteSet","re_bytes::Match","exec::MatchLiteralType","prog::Program","re_set::unicode::SetMatches","exec::MatchType","re_set::bytes::SetMatchesIter","input::Char","re_bytes::SubCaptureMatches","re_bytes::Regex","pikevm::FollowEpsilon","re_bytes::CaptureNames","literal::imp::Memmem","re_unicode::Match","re_set::bytes::SetMatches","exec::MatchNfaType","prog::InstChar","re_builder::RegexOptions"]},"dfa::Result":{"T":["re_trait::SubCapturesPosIter","expand::CaptureRef","re_unicode::CaptureLocations","exec::MatchType","prog::InstSplit","dfa::Byte","re_set::unicode::SetMatches","compile::InstHole","compile::SuffixCacheKey","prog::InstBytes","backtrack::Cache","dfa::StateFlags","re_set::unicode::SetMatchesIter","re_set::bytes::RegexSet","error::Error","dfa::Result","re_bytes::NoExpand","literal::imp::Memmem","re_set::bytes::SetMatchesIter","pikevm::Cache","exec::MatchLiteralType","exec::Exec","re_set::bytes::SetMatches","sparse::SparseSet","re_bytes::Match","dfa::Transitions","compile::SuffixCacheEntry","pikevm::FollowEpsilon","input::Char","dfa::EmptyFlags","prog::InstChar","re_unicode::Match","re_bytes::SubCaptureMatches","input::ByteInput","re_unicode::Regex","re_set::unicode::RegexSet","input::CharInput","re_trait::Locations","prog::Inst","re_unicode::SubCaptureMatches","prog::InstSave","compile::MaybeInst","re_bytes::CaptureLocations","backtrack::Job","re_bytes::Regex","literal::imp::LiteralSearcher","literal::imp::SingleByteSet","re_builder::RegexOptions","prog::EmptyLook","dfa::State","input::InputAt","re_unicode::NoExpand","re_bytes::CaptureNames","prog::InstRanges","expand::Ref","std::clone::impls::<impl std::clone::Clone for &mut T>","re_unicode::CaptureNames","literal::imp::Matcher","pikevm::Threads","prog::InstEmptyLook","prog::Program","exec::MatchNfaType"]},"re_unicode::Regex::replace_all":{"R":["std::string::String","<F as re_unicode::Replacer>","<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>","re_unicode::ReplacerRef","std::borrow::Cow","re_unicode::NoExpand"]},"std::borrow::Cow":{"B":["std::path::Path","<T as std::borrow::ToOwned>","std::ffi::CStr","std::ffi::OsStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // R
+p0.replace_all(&p1, p2);
+re_unicode::Regex::replace_all(p0, &p1, p2);
+crate::re_unicode::Regex::replace_all(p0, &p1, p2);
+<re_unicode::Regex>::replace_all(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::replacen
deps:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"dfa::Result":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"re_unicode::Regex::replacen":{"R":["re_unicode::Replacer","std::marker::Sized"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<F as re_unicode::Replacer>":{"F":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode"]},"<T as std::borrow::ToOwned>":{"T":["re_unicode::NoExpand","pikevm::FollowEpsilon","expand::Ref","pikevm::Threads","expand::CaptureRef","dfa::StateFlags","dfa::Byte","re_bytes::CaptureLocations","re_bytes::Match","pikevm::Cache","compile::InstHole","literal::imp::SingleByteSet","prog::InstEmptyLook","re_unicode::CaptureNames","input::InputAt","re_bytes::CaptureNames","re_set::unicode::RegexSet","prog::EmptyLook","compile::MaybeInst","compile::SuffixCacheKey","re_unicode::Regex","exec::MatchNfaType","input::Char","re_bytes::NoExpand","re_unicode::SubCaptureMatches","std::clone::impls::<impl std::clone::Clone for &mut T>","backtrack::Job","prog::InstRanges","re_set::bytes::SetMatchesIter","re_bytes::Regex","prog::Program","re_unicode::Match","re_set::unicode::SetMatches","re_unicode::CaptureLocations","prog::InstChar","prog::InstBytes","prog::InstSplit","compile::SuffixCacheEntry","literal::imp::Matcher","re_trait::Locations","sparse::SparseSet","re_set::bytes::SetMatches","backtrack::Cache","literal::imp::LiteralSearcher","re_bytes::SubCaptureMatches","dfa::State","error::Error","re_set::unicode::SetMatchesIter","exec::MatchLiteralType","prog::InstSave","dfa::Result","prog::Inst","re_set::bytes::RegexSet","input::ByteInput","exec::MatchType","dfa::Transitions","literal::imp::Memmem","re_builder::RegexOptions","input::CharInput","exec::Exec","re_trait::SubCapturesPosIter","dfa::EmptyFlags"]},"dfa::Result":{"T":["compile::MaybeInst","re_unicode::Match","pikevm::FollowEpsilon","exec::Exec","re_trait::SubCapturesPosIter","input::InputAt","compile::SuffixCacheEntry","pikevm::Cache","literal::imp::SingleByteSet","prog::EmptyLook","prog::InstBytes","re_bytes::Match","dfa::State","std::clone::impls::<impl std::clone::Clone for &T>","re_bytes::SubCaptureMatches","re_bytes::Regex","re_unicode::CaptureLocations","prog::InstSplit","re_unicode::Regex","dfa::Result","prog::InstEmptyLook","input::CharInput","re_bytes::CaptureNames","dfa::EmptyFlags","prog::InstRanges","re_set::unicode::RegexSet","literal::imp::Matcher","exec::MatchType","re_builder::RegexOptions","prog::Program","input::ByteInput","backtrack::Cache","re_bytes::CaptureLocations","re_set::bytes::RegexSet","prog::Inst","pikevm::Threads","expand::Ref","expand::CaptureRef","dfa::Byte","re_trait::Locations","re_unicode::SubCaptureMatches","compile::SuffixCacheKey","re_set::bytes::SetMatches","sparse::SparseSet","exec::MatchLiteralType","compile::InstHole","re_set::bytes::SetMatchesIter","re_bytes::NoExpand","exec::MatchNfaType","dfa::Transitions","error::Error","re_set::unicode::SetMatches","re_unicode::CaptureNames","literal::imp::Memmem","prog::InstChar","prog::InstSave","re_set::unicode::SetMatchesIter","re_unicode::NoExpand","literal::imp::LiteralSearcher","dfa::StateFlags","input::Char","backtrack::Job"]},"re_unicode::Regex::replacen":{"R":["<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>","std::borrow::Cow","re_unicode::NoExpand","std::string::String","re_unicode::ReplacerRef"]},"std::borrow::Cow":{"B":["std::ffi::CStr","std::path::Path","<T as std::borrow::ToOwned>","std::ffi::OsStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // R
+p0.replacen(&p1, p2, p3);
+re_unicode::Regex::replacen(p0, &p1, p2, p3);
+crate::re_unicode::Regex::replacen(p0, &p1, p2, p3);
+<re_unicode::Regex>::replacen(p0, &p1, p2, p3);
-----------------
src/re_unicode.rs re_unicode::Regex::shortest_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.shortest_match(&p1);
+re_unicode::Regex::shortest_match(p0, &p1);
+crate::re_unicode::Regex::shortest_match(p0, &p1);
+<re_unicode::Regex>::shortest_match(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::shortest_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(&p1, p2);
+re_unicode::Regex::shortest_match_at(p0, &p1, p2);
+crate::re_unicode::Regex::shortest_match_at(p0, &p1, p2);
+<re_unicode::Regex>::shortest_match_at(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::is_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.is_match_at(&p1, p2);
+re_unicode::Regex::is_match_at(p0, &p1, p2);
+crate::re_unicode::Regex::is_match_at(p0, &p1, p2);
+<re_unicode::Regex>::is_match_at(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::find_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.find_at(&p1, p2);
+re_unicode::Regex::find_at(p0, &p1, p2);
+crate::re_unicode::Regex::find_at(p0, &p1, p2);
+<re_unicode::Regex>::find_at(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::captures_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.captures_at(&p1, p2);
+re_unicode::Regex::captures_at(p0, &p1, p2);
+crate::re_unicode::Regex::captures_at(p0, &p1, p2);
+<re_unicode::Regex>::captures_at(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::captures_read
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p2 = "sample"; // None+&str
+p0.captures_read(p1, &p2);
+re_unicode::Regex::captures_read(p0, p1, &p2);
+crate::re_unicode::Regex::captures_read(p0, p1, &p2);
+<re_unicode::Regex>::captures_read(p0, p1, &p2);
-----------------
src/re_unicode.rs re_unicode::Regex::captures_read_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p2 = "sample"; // None+&str
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, &p2, p3);
+re_unicode::Regex::captures_read_at(p0, p1, &p2, p3);
+crate::re_unicode::Regex::captures_read_at(p0, p1, &p2, p3);
+<re_unicode::Regex>::captures_read_at(p0, p1, &p2, p3);
-----------------
src/re_unicode.rs re_unicode::Regex::read_captures_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p2 = "sample"; // None+&str
let mut p3 = 0usize; // None+usize
+p0.read_captures_at(p1, &p2, p3);
+re_unicode::Regex::read_captures_at(p0, p1, &p2, p3);
+crate::re_unicode::Regex::read_captures_at(p0, p1, &p2, p3);
+<re_unicode::Regex>::read_captures_at(p0, p1, &p2, p3);
-----------------
src/re_unicode.rs re_unicode::Regex::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.as_str();
+re_unicode::Regex::as_str(p0);
+crate::re_unicode::Regex::as_str(p0);
+<re_unicode::Regex>::as_str(p0);
-----------------
src/re_unicode.rs re_unicode::Regex::capture_names
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.capture_names();
+re_unicode::Regex::capture_names(p0);
+crate::re_unicode::Regex::capture_names(p0);
+<re_unicode::Regex>::capture_names(p0);
-----------------
src/re_unicode.rs re_unicode::Regex::captures_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.captures_len();
+re_unicode::Regex::captures_len(p0);
+crate::re_unicode::Regex::captures_len(p0);
+<re_unicode::Regex>::captures_len(p0);
-----------------
src/re_unicode.rs re_unicode::Regex::static_captures_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.static_captures_len();
+re_unicode::Regex::static_captures_len(p0);
+crate::re_unicode::Regex::static_captures_len(p0);
+<re_unicode::Regex>::static_captures_len(p0);
-----------------
src/re_unicode.rs re_unicode::Regex::capture_locations
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.capture_locations();
+re_unicode::Regex::capture_locations(p0);
+crate::re_unicode::Regex::capture_locations(p0);
+<re_unicode::Regex>::capture_locations(p0);
-----------------
src/re_unicode.rs re_unicode::Regex::locations
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.locations();
+re_unicode::Regex::locations(p0);
+crate::re_unicode::Regex::locations(p0);
+<re_unicode::Regex>::locations(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::clone::Clone>::clone
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
+p0.clone();
+<re_unicode::CaptureNames<'r> as std::clone::Clone>::clone(p0);
+crate::<re_unicode::CaptureNames<'r> as std::clone::Clone>::clone(p0);
+<re_unicode::CaptureNames<'r>>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::fmt::Debug>::fmt
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::CaptureNames<'r> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::CaptureNames<'r> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::CaptureNames<'r>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::iter::Iterator>::next
'r
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
+p0.next();
+<re_unicode::CaptureNames<'r> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::CaptureNames<'r> as std::iter::Iterator>::next(p0);
+<re_unicode::CaptureNames<'r>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::iter::Iterator>::size_hint
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
+p0.size_hint();
+<re_unicode::CaptureNames<'r> as std::iter::Iterator>::size_hint(p0);
+crate::<re_unicode::CaptureNames<'r> as std::iter::Iterator>::size_hint(p0);
+<re_unicode::CaptureNames<'r>>::size_hint(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::iter::Iterator>::count
'r
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
+p0.count();
+<re_unicode::CaptureNames<'r> as std::iter::Iterator>::count(p0);
+crate::<re_unicode::CaptureNames<'r> as std::iter::Iterator>::count(p0);
+<re_unicode::CaptureNames<'r>>::count(p0);
-----------------
src/re_unicode.rs <re_unicode::Split<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Split<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Split<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Split<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Split<'r, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Split<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::Split<'r, 't>
+p0.next();
+<re_unicode::Split<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::Split<'r, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::Split<'r, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::SplitN<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::SplitN<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::SplitN<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::SplitN<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::SplitN<'r, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::SplitN<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::SplitN<'r, 't>
+p0.next();
+<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::SplitN<'r, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::SplitN<'r, 't> as std::iter::Iterator>::size_hint
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::SplitN<'r, 't>
+p0.size_hint();
+<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::size_hint(p0);
+crate::<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::size_hint(p0);
+<re_unicode::SplitN<'r, 't>>::size_hint(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureLocations as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
+p0.clone();
+<re_unicode::CaptureLocations as std::clone::Clone>::clone(p0);
+crate::<re_unicode::CaptureLocations as std::clone::Clone>::clone(p0);
+<re_unicode::CaptureLocations>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureLocations as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::CaptureLocations as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::CaptureLocations as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::CaptureLocations>::fmt(p0, p1);
-----------------
src/re_unicode.rs re_unicode::CaptureLocations::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+re_unicode::CaptureLocations::get(p0, p1);
+crate::re_unicode::CaptureLocations::get(p0, p1);
+<re_unicode::CaptureLocations>::get(p0, p1);
-----------------
src/re_unicode.rs re_unicode::CaptureLocations::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
+p0.len();
+re_unicode::CaptureLocations::len(p0);
+crate::re_unicode::CaptureLocations::len(p0);
+<re_unicode::CaptureLocations>::len(p0);
-----------------
src/re_unicode.rs re_unicode::CaptureLocations::pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p1 = 0usize; // None+usize
+p0.pos(p1);
+re_unicode::CaptureLocations::pos(p0, p1);
+crate::re_unicode::CaptureLocations::pos(p0, p1);
+<re_unicode::CaptureLocations>::pos(p0, p1);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::get
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+re_unicode::Captures::<'t>::get(p0, p1);
+crate::re_unicode::Captures::<'t>::get(p0, p1);
+<re_unicode::Captures<'t>>::get(p0, p1);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::name
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = "sample"; // None+&str
+p0.name(&p1);
+re_unicode::Captures::<'t>::name(p0, &p1);
+crate::re_unicode::Captures::<'t>::name(p0, &p1);
+<re_unicode::Captures<'t>>::name(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::iter
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
+p0.iter();
+re_unicode::Captures::<'t>::iter(p0);
+crate::re_unicode::Captures::<'t>::iter(p0);
+<re_unicode::Captures<'t>>::iter(p0);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::expand
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = "sample"; // None+&str
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.expand(&p1, p2);
+re_unicode::Captures::<'t>::expand(p0, &p1, p2);
+crate::re_unicode::Captures::<'t>::expand(p0, &p1, p2);
+<re_unicode::Captures<'t>>::expand(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
+p0.len();
+re_unicode::Captures::<'t>::len(p0);
+crate::re_unicode::Captures::<'t>::len(p0);
+<re_unicode::Captures<'t>>::len(p0);
-----------------
src/re_unicode.rs <re_unicode::Captures<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Captures<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Captures<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Captures<'t>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CapturesDebug<'c, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::CapturesDebug<'c, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Captures<'t> as std::ops::Index<usize>>::index
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = 0usize; // None+usize
+p0.index(p1);
+<re_unicode::Captures<'t> as std::ops::Index<usize>>::index(p0, p1);
+crate::<re_unicode::Captures<'t> as std::ops::Index<usize>>::index(p0, p1);
+<re_unicode::Captures<'t>>::index(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Captures<'t> as std::ops::Index<&'i str>>::index
't,'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+<re_unicode::Captures<'t> as std::ops::Index<&'i str>>::index(p0, &p1);
+crate::<re_unicode::Captures<'t> as std::ops::Index<&'i str>>::index(p0, &p1);
+<re_unicode::Captures<'t>>::index(p0, &p1);
-----------------
src/re_unicode.rs <re_unicode::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::SubCaptureMatches<'c, 't>
+p0.clone();
+<re_unicode::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone(p0);
+crate::<re_unicode::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone(p0);
+<re_unicode::SubCaptureMatches<'c, 't>>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::SubCaptureMatches<'c, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::SubCaptureMatches<'c, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next
'c,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::SubCaptureMatches<'c, 't>
+p0.next();
+<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::SubCaptureMatches<'c, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::size_hint
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::SubCaptureMatches<'c, 't>
+p0.size_hint();
+<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::size_hint(p0);
+crate::<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::size_hint(p0);
+<re_unicode::SubCaptureMatches<'c, 't>>::size_hint(p0);
-----------------
src/re_unicode.rs <re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::count
'c,'t
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_unicode::SubCaptureMatches<'c, 't>
+p0.count();
+<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::count(p0);
+crate::<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::count(p0);
+<re_unicode::SubCaptureMatches<'c, 't>>::count(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureMatches<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::CaptureMatches<'r, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::CaptureMatches<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureMatches<'r, 't>
+p0.next();
+<re_unicode::CaptureMatches<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::CaptureMatches<'r, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::CaptureMatches<'r, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::Matches<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Matches<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Matches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Matches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Matches<'r, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Matches<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::Matches<'r, 't>
+p0.next();
+<re_unicode::Matches<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::Matches<'r, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::Matches<'r, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":{"R":["std::fmt::Debug"]},"backtrack::Bounded":{"I":["std::marker::Sized","std::fmt::Debug","input::Input"]},"dfa::Result":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"pikevm::Fsm":{"I":["std::fmt::Debug","std::marker::Sized","input::Input"]},"pool::Pool":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"pool::PoolGuard":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"re_trait::Matches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":{"R":["re_set::bytes::SetMatchesIter","re_bytes::SplitN","prog::InstSave","literal::imp::Matcher","compile::MaybeInst","re_builder::unicode::RegexBuilder","re_builder::RegexOptions","dfa::EmptyFlags","re_set::unicode::SetMatchesIntoIter","exec::ExecNoSyncStr","re_unicode::Matches","dfa::Byte","prog::InstEmptyLook","re_builder::bytes::RegexBuilder","re_unicode::Captures","compile::Hole","input::InputAt","re_bytes::Regex","dfa::CacheInner","re_bytes::CapturesDebug","prog::Inst","re_bytes::Matches","re_bytes::SubCaptureMatches","exec::ExecReadOnly","<&T as std::fmt::Debug>","re_trait::Matches","literal::imp::LiteralIter","compile::SuffixCacheKey","pool::PoolGuard","re_bytes::CaptureMatches","prog::InstSplit","re_unicode::CaptureMatches","re_set::bytes::SetMatches","backtrack::Bounded","re_unicode::CaptureLocations","prog::InstBytes","dfa::Result","dfa::State","re_builder::set_unicode::RegexSetBuilder","re_bytes::Captures","compile::InstHole","re_trait::CaptureMatches","re_unicode::NoExpand","compile::Patch","prog::EmptyLook","compile::ByteClassSet","expand::Ref","re_unicode::Match","pikevm::Cache","re_unicode::CaptureNames","compile::SuffixCacheEntry","re_set::unicode::RegexSet","re_unicode::Split","prog::InstRanges","input::CharInput","backtrack::Job","input::Char","pikevm::Threads","prog::InstChar","dfa::Cache","re_set::unicode::SetMatchesIter","re_bytes::Split","re_unicode::CapturesDebug","re_builder::set_bytes::RegexSetBuilder","re_set::bytes::SetMatchesIntoIter","expand::CaptureRef","re_bytes::CaptureLocations","backtrack::Cache","literal::imp::LiteralSearcher","exec::ProgramCacheInner","dfa::StateFlags","error::Error","pikevm::Fsm","exec::MatchType","re_bytes::ReplacerRef","dfa::Transitions","re_bytes::NoExpand","re_set::bytes::RegexSet","pool::Pool","exec::MatchNfaType","prog::Program","compile::SuffixCache","dfa::TransitionsRow","dfa::StateMap","input::ByteInput","pikevm::FollowEpsilon","literal::imp::Memmem","re_unicode::Regex","dfa::Fsm","exec::ExecNoSync","exec::Exec","sparse::SparseSet","re_unicode::SplitN","re_bytes::Match","re_trait::Locations","literal::imp::SingleByteSet","re_unicode::SubCaptureMatches","exec::MatchLiteralType","re_trait::SubCapturesPosIter","re_bytes::CaptureNames","re_unicode::ReplacerRef","re_set::unicode::SetMatches"]},"backtrack::Bounded":{"I":["input::ByteInput","input::CharInput"]},"dfa::Result":{"T":["compile::SuffixCacheKey","prog::InstSplit","expand::Ref","pikevm::FollowEpsilon","pikevm::Threads","pikevm::Cache","re_trait::SubCapturesPosIter","literal::imp::Matcher","compile::SuffixCacheEntry","re_unicode::CaptureLocations","error::Error","re_set::unicode::SetMatchesIter","backtrack::Job","exec::MatchLiteralType","input::InputAt","re_set::unicode::SetMatches","prog::Inst","re_bytes::CaptureNames","std::clone::impls::<impl std::clone::Clone for *mut T>","re_trait::Locations","input::ByteInput","re_set::bytes::RegexSet","backtrack::Cache","re_set::bytes::SetMatches","sparse::SparseSet","prog::EmptyLook","re_unicode::Match","re_unicode::CaptureNames","literal::imp::LiteralSearcher","re_set::bytes::SetMatchesIter","input::Char","re_unicode::Regex","re_bytes::NoExpand","exec::Exec","dfa::Transitions","prog::InstEmptyLook","compile::InstHole","prog::InstChar","exec::MatchType","dfa::Byte","dfa::State","re_unicode::NoExpand","prog::InstSave","dfa::EmptyFlags","literal::imp::SingleByteSet","re_set::unicode::RegexSet","re_builder::RegexOptions","re_bytes::Regex","expand::CaptureRef","literal::imp::Memmem","dfa::StateFlags","prog::InstRanges","re_bytes::SubCaptureMatches","prog::Program","exec::MatchNfaType","compile::MaybeInst","input::CharInput","re_bytes::Match","re_unicode::SubCaptureMatches","dfa::Result","re_bytes::CaptureLocations","prog::InstBytes"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"pool::Pool":{"T":["std::sync::OnceLock<T>","std::sync::atomic::AtomicPtr<T>","std::io::error::repr_bitpacked::Repr","std::slice::IterMut<'_, T>","std::rc::Rc<T>","<*const T as std::fmt::Debug>","std::sync::Arc<T>","std::cell::RefCell<T>","std::slice::Iter<'_, T>","std::collections::linked_list::IterMut<'_, T>","std::sync::MutexGuard<'_, T>","std::sync::mpmc::Sender<T>","std::sync::RwLockWriteGuard<'_, T>","std::io::IoSlice<'a>","std::boxed::ThinBox<T>","std::env::ArgsOs","std::collections::vec_deque::Drain<'_, T, A>","std::sync::mpsc::SyncSender<T>","std::future::ResumeTy","std::sync::RwLock<T>","std::vec::IntoIter<T, A>","std::collections::linked_list::Cursor<'_, T>","std::collections::linked_list::Iter<'_, T>","std::task::Waker","std::rc::Weak<T>","std::env::Args","std::string::Drain<'_>","std::sync::mpsc::Sender<T>","std::sync::mpsc::Receiver<T>","std::collections::linked_list::CursorMut<'_, T>","std::ptr::NonNull<T>","std::sys::unix::args::Args","std::collections::LinkedList<T>","std::ptr::Unique<T>","std::sync::Weak<T>","std::sync::Mutex<T>","std::vec::Drain<'_, T, A>","std::io::IoSliceMut<'a>","std::sync::RwLockReadGuard<'_, T>","std::ptr::DynMetadata<Dyn>","std::thread::JoinHandle<T>","std::cell::Cell<T>","std::sync::mpmc::Receiver<T>"]},"pool::PoolGuard":{"T":["std::rc::Rc<T>","std::sync::atomic::AtomicPtr<T>","std::slice::IterMut<'_, T>","std::future::ResumeTy","std::env::Args","std::sync::OnceLock<T>","std::sync::Weak<T>","std::env::ArgsOs","std::sync::mpsc::Sender<T>","std::sync::Mutex<T>","std::sync::Arc<T>","std::vec::Drain<'_, T, A>","std::cell::Cell<T>","std::sync::mpmc::Receiver<T>","<&T as std::fmt::Debug>","std::collections::linked_list::Cursor<'_, T>","std::collections::vec_deque::Drain<'_, T, A>","std::cell::RefCell<T>","std::sync::MutexGuard<'_, T>","std::collections::LinkedList<T>","std::boxed::ThinBox<T>","std::collections::linked_list::CursorMut<'_, T>","std::sys::unix::args::Args","std::io::IoSliceMut<'a>","std::ptr::DynMetadata<Dyn>","std::sync::mpsc::Receiver<T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::mpsc::SyncSender<T>","std::task::Waker","std::rc::Weak<T>","std::ptr::NonNull<T>","std::sync::RwLock<T>","std::vec::IntoIter<T, A>","std::slice::Iter<'_, T>","std::sync::mpmc::Sender<T>","<&T as std::marker::Send>","std::ptr::Unique<T>","std::thread::JoinHandle<T>","std::collections::linked_list::Iter<'_, T>","std::io::error::repr_bitpacked::Repr","std::collections::linked_list::IterMut<'_, T>","std::io::IoSlice<'a>","std::sync::RwLockReadGuard<'_, T>","std::string::Drain<'_>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::ReplacerRef<'a, R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::ReplacerRef<'a, R>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append
'a
deps:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append":{"R":["re_unicode::Replacer"]},"dfa::Result":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::borrow::ToOwned>":{"T":["exec::Exec","std::clone::impls::<impl std::clone::Clone for *const T>","dfa::Result","re_trait::Locations","prog::InstEmptyLook","literal::imp::Memmem","dfa::EmptyFlags","prog::InstChar","dfa::StateFlags","re_trait::SubCapturesPosIter","compile::InstHole","re_unicode::NoExpand","compile::SuffixCacheKey","re_set::unicode::SetMatchesIter","compile::MaybeInst","re_set::unicode::RegexSet","literal::imp::Matcher","expand::CaptureRef","pikevm::FollowEpsilon","expand::Ref","input::CharInput","backtrack::Cache","backtrack::Job","input::Char","re_bytes::SubCaptureMatches","prog::EmptyLook","re_unicode::SubCaptureMatches","re_set::bytes::SetMatches","re_bytes::Regex","re_unicode::CaptureNames","exec::MatchType","dfa::Byte","prog::InstSave","exec::MatchLiteralType","compile::SuffixCacheEntry","re_unicode::Match","re_set::bytes::SetMatchesIter","re_set::bytes::RegexSet","prog::Program","re_set::unicode::SetMatches","input::ByteInput","pikevm::Threads","dfa::Transitions","re_bytes::CaptureLocations","literal::imp::SingleByteSet","re_bytes::Match","re_bytes::NoExpand","error::Error","prog::Inst","input::InputAt","exec::MatchNfaType","prog::InstBytes","re_unicode::Regex","dfa::State","re_unicode::CaptureLocations","re_builder::RegexOptions","re_bytes::CaptureNames","sparse::SparseSet","literal::imp::LiteralSearcher","prog::InstRanges","prog::InstSplit","pikevm::Cache"]},"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append":{"R":["re_unicode::NoExpand","re_unicode::ReplacerRef","std::borrow::Cow","<F as re_unicode::Replacer>","std::string::String"]},"dfa::Result":{"T":["exec::Exec","backtrack::Cache","re_set::bytes::SetMatches","sparse::SparseSet","re_set::unicode::SetMatches","re_bytes::NoExpand","literal::imp::Matcher","exec::MatchType","re_unicode::NoExpand","backtrack::Job","dfa::State","compile::MaybeInst","prog::InstSplit","expand::CaptureRef","compile::InstHole","input::ByteInput","re_set::bytes::SetMatchesIter","prog::Inst","error::Error","dfa::Result","re_unicode::Match","exec::MatchNfaType","re_trait::SubCapturesPosIter","prog::InstSave","compile::SuffixCacheKey","pikevm::Cache","re_bytes::Match","prog::InstBytes","input::Char","literal::imp::SingleByteSet","compile::SuffixCacheEntry","re_bytes::Regex","re_unicode::CaptureLocations","re_set::unicode::SetMatchesIter","pikevm::Threads","pikevm::FollowEpsilon","re_bytes::CaptureLocations","re_unicode::Regex","re_builder::RegexOptions","input::InputAt","std::clone::impls::<impl std::clone::Clone for &mut T>","re_bytes::CaptureNames","prog::InstEmptyLook","prog::InstRanges","re_set::bytes::RegexSet","prog::InstChar","re_set::unicode::RegexSet","dfa::Byte","literal::imp::Memmem","re_unicode::CaptureNames","expand::Ref","dfa::EmptyFlags","literal::imp::LiteralSearcher","exec::MatchLiteralType","dfa::Transitions","input::CharInput","dfa::StateFlags","re_trait::Locations","prog::EmptyLook","prog::Program","re_bytes::SubCaptureMatches","re_unicode::SubCaptureMatches"]},"std::borrow::Cow":{"B":["std::ffi::CStr","<T as std::borrow::ToOwned>","std::path::Path","std::ffi::OsStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::ReplacerRef<'a, R>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<re_unicode::ReplacerRef<'a, R>>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion
'a
deps:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::borrow::ToOwned>":{"T":["std::marker::Sized","std::clone::Clone"]},"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion":{"R":["re_unicode::Replacer"]},"dfa::Result":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"std::borrow::Cow":{"B":["std::borrow::ToOwned"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as re_unicode::Replacer>":{"F":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::borrow::ToOwned>":{"T":["compile::MaybeInst","prog::EmptyLook","re_set::bytes::SetMatchesIter","re_bytes::Match","prog::InstRanges","dfa::Byte","literal::imp::Matcher","re_bytes::CaptureNames","compile::SuffixCacheKey","prog::InstChar","exec::Exec","input::InputAt","pikevm::Threads","error::Error","literal::imp::LiteralSearcher","std::clone::impls::<impl std::clone::Clone for *const T>","prog::Program","pikevm::FollowEpsilon","re_unicode::NoExpand","compile::InstHole","re_trait::Locations","input::ByteInput","re_set::unicode::SetMatches","re_builder::RegexOptions","dfa::Result","dfa::State","re_unicode::SubCaptureMatches","dfa::Transitions","re_set::unicode::SetMatchesIter","literal::imp::Memmem","prog::InstEmptyLook","expand::CaptureRef","pikevm::Cache","prog::InstBytes","backtrack::Cache","re_unicode::Regex","re_trait::SubCapturesPosIter","re_unicode::Match","dfa::EmptyFlags","exec::MatchNfaType","re_set::bytes::SetMatches","re_unicode::CaptureLocations","exec::MatchType","prog::InstSplit","re_unicode::CaptureNames","input::CharInput","input::Char","re_bytes::Regex","re_bytes::SubCaptureMatches","dfa::StateFlags","prog::InstSave","exec::MatchLiteralType","sparse::SparseSet","backtrack::Job","literal::imp::SingleByteSet","re_set::bytes::RegexSet","re_set::unicode::RegexSet","compile::SuffixCacheEntry","expand::Ref","prog::Inst","re_bytes::NoExpand","re_bytes::CaptureLocations"]},"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion":{"R":["std::string::String","re_unicode::ReplacerRef","std::borrow::Cow","<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>","re_unicode::NoExpand"]},"dfa::Result":{"T":["literal::imp::Memmem","expand::Ref","re_bytes::Match","error::Error","prog::Program","<*const T as std::fmt::Debug>","literal::imp::Matcher","input::CharInput","dfa::Result","prog::InstSplit","literal::imp::LiteralSearcher","re_bytes::Regex","prog::InstRanges","prog::InstBytes","re_unicode::NoExpand","sparse::SparseSet","pikevm::FollowEpsilon","exec::MatchNfaType","re_bytes::SubCaptureMatches","input::ByteInput","exec::Exec","backtrack::Job","input::InputAt","prog::EmptyLook","re_trait::Locations","compile::MaybeInst","re_unicode::CaptureNames","re_unicode::Match","prog::InstSave","dfa::EmptyFlags","prog::Inst","re_set::bytes::SetMatchesIter","re_bytes::CaptureNames","literal::imp::SingleByteSet","re_set::bytes::RegexSet","re_bytes::NoExpand","prog::InstChar","exec::MatchType","dfa::Byte","compile::InstHole","re_trait::SubCapturesPosIter","pikevm::Cache","compile::SuffixCacheEntry","re_builder::RegexOptions","re_set::bytes::SetMatches","re_unicode::CaptureLocations","pikevm::Threads","re_set::unicode::SetMatchesIter","dfa::Transitions","dfa::StateFlags","re_unicode::SubCaptureMatches","re_bytes::CaptureLocations","compile::SuffixCacheKey","re_unicode::Regex","expand::CaptureRef","exec::MatchLiteralType","prog::InstEmptyLook","input::Char","re_set::unicode::SetMatches","backtrack::Cache","re_set::unicode::RegexSet","dfa::State"]},"std::borrow::Cow":{"B":["<T as std::borrow::ToOwned>","std::path::Path","std::ffi::OsStr","std::ffi::CStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::ReplacerRef<'a, R>
+p0.no_expansion();
+<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion(p0);
+crate::<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion(p0);
+<re_unicode::ReplacerRef<'a, R>>::no_expansion(p0);
-----------------
src/re_unicode.rs <&'a str as re_unicode::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<&'a str as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<&'a str as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<&'a str>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <&'a str as re_unicode::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut "a"; // None+&'a str
+p0.no_expansion();
+<&'a str as re_unicode::Replacer>::no_expansion(p0);
+crate::<&'a str as re_unicode::Replacer>::no_expansion(p0);
+<&'a str>::no_expansion(p0);
-----------------
src/re_unicode.rs <&'a std::string::String as re_unicode::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+&'a std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<&'a std::string::String as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<&'a std::string::String as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<&'a std::string::String>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <&'a std::string::String as re_unicode::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+&'a std::string::String
+p0.no_expansion();
+<&'a std::string::String as re_unicode::Replacer>::no_expansion(p0);
+crate::<&'a std::string::String as re_unicode::Replacer>::no_expansion(p0);
+<&'a std::string::String>::no_expansion(p0);
-----------------
src/re_unicode.rs <std::string::String as re_unicode::Replacer>::replace_append
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<std::string::String as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<std::string::String as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<std::string::String>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <std::string::String as re_unicode::Replacer>::no_expansion
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
+p0.no_expansion();
+<std::string::String as re_unicode::Replacer>::no_expansion(p0);
+crate::<std::string::String as re_unicode::Replacer>::no_expansion(p0);
+<std::string::String>::no_expansion(p0);
-----------------
src/re_unicode.rs <std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, str>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<std::borrow::Cow<'a, str>>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, str>
+p0.no_expansion();
+<std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion(p0);
+crate::<std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion(p0);
+<std::borrow::Cow<'a, str>>::no_expansion(p0);
-----------------
src/re_unicode.rs <&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, str>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<&'a std::borrow::Cow<'a, str>>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, str>
+p0.no_expansion();
+<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion(p0);
+crate::<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion(p0);
+<&'a std::borrow::Cow<'a, str>>::no_expansion(p0);
-----------------
src/re_unicode.rs <F as re_unicode::Replacer>::replace_append
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<F as re_unicode::Replacer>::replace_append":{"F":["std::marker::Sized","std::ops::FnMut"],"T":["std::convert::AsRef","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<F as re_unicode::Replacer>::replace_append":{"F":["core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty"],"T":["std::rc::Rc<T>","std::borrow::Cow<'_, std::ffi::OsStr>","std::boxed::Box<T, A>","core::num::dec2flt::common::AsciiStr<'a>","std::ffi::CString","std::ffi::CStr","<&T as std::convert::AsRef<U>>","std::sync::Arc<T>","std::slice::Iter<'_, T>","std::vec::IntoIter<T, A>","std::borrow::Cow<'_, T>","std::slice::IterMut<'_, T>","std::vec::Drain<'a, T, A>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // F
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<F as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<F as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<F>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <re_unicode::NoExpand<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::NoExpand<'t>
+p0.clone();
+<re_unicode::NoExpand<'t> as std::clone::Clone>::clone(p0);
+crate::<re_unicode::NoExpand<'t> as std::clone::Clone>::clone(p0);
+<re_unicode::NoExpand<'t>>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::NoExpand<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::NoExpand<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::NoExpand<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::NoExpand<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::NoExpand<'t>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::NoExpand<'t> as re_unicode::Replacer>::replace_append
't
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::NoExpand<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<re_unicode::NoExpand<'t> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<re_unicode::NoExpand<'t> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<re_unicode::NoExpand<'t>>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <re_unicode::NoExpand<'t> as re_unicode::Replacer>::no_expansion
't
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::NoExpand<'t>
+p0.no_expansion();
+<re_unicode::NoExpand<'t> as re_unicode::Replacer>::no_expansion(p0);
+crate::<re_unicode::NoExpand<'t> as re_unicode::Replacer>::no_expansion(p0);
+<re_unicode::NoExpand<'t>>::no_expansion(p0);
-----------------
src/sparse.rs <sparse::SparseSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.clone();
+<sparse::SparseSet as std::clone::Clone>::clone(p0);
+crate::<sparse::SparseSet as std::clone::Clone>::clone(p0);
+<sparse::SparseSet>::clone(p0);
-----------------
src/sparse.rs sparse::SparseSet::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+sparse::SparseSet::new(p0);
+crate::sparse::SparseSet::new(p0);
+<sparse::SparseSet>::new(p0);
-----------------
src/sparse.rs sparse::SparseSet::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.len();
+sparse::SparseSet::len(p0);
+crate::sparse::SparseSet::len(p0);
+<sparse::SparseSet>::len(p0);
-----------------
src/sparse.rs sparse::SparseSet::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.is_empty();
+sparse::SparseSet::is_empty(p0);
+crate::sparse::SparseSet::is_empty(p0);
+<sparse::SparseSet>::is_empty(p0);
-----------------
src/sparse.rs sparse::SparseSet::capacity
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.capacity();
+sparse::SparseSet::capacity(p0);
+crate::sparse::SparseSet::capacity(p0);
+<sparse::SparseSet>::capacity(p0);
-----------------
src/sparse.rs sparse::SparseSet::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p1 = 0usize; // None+usize
+p0.insert(p1);
+sparse::SparseSet::insert(p0, p1);
+crate::sparse::SparseSet::insert(p0, p1);
+<sparse::SparseSet>::insert(p0, p1);
-----------------
src/sparse.rs sparse::SparseSet::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p1 = 0usize; // None+usize
+p0.contains(p1);
+sparse::SparseSet::contains(p0, p1);
+crate::sparse::SparseSet::contains(p0, p1);
+<sparse::SparseSet>::contains(p0, p1);
-----------------
src/sparse.rs sparse::SparseSet::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.clear();
+sparse::SparseSet::clear(p0);
+crate::sparse::SparseSet::clear(p0);
+<sparse::SparseSet>::clear(p0);
-----------------
src/sparse.rs <sparse::SparseSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<sparse::SparseSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<sparse::SparseSet as std::fmt::Debug>::fmt(p0, p1);
+<sparse::SparseSet>::fmt(p0, p1);
-----------------
src/sparse.rs <sparse::SparseSet as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.deref();
+<sparse::SparseSet as std::ops::Deref>::deref(p0);
+crate::<sparse::SparseSet as std::ops::Deref>::deref(p0);
+<sparse::SparseSet>::deref(p0);
-----------------
src/sparse.rs <&'a sparse::SparseSet as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.into_iter();
+<&'a sparse::SparseSet as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a sparse::SparseSet as std::iter::IntoIterator>::into_iter(p0);
+<&'a sparse::SparseSet>::into_iter(p0);