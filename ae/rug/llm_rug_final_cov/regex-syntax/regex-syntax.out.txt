-----------------
src/ast/parse.rs ast::parse::is_hex
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+ast::parse::is_hex(p0);
+crate::ast::parse::is_hex(p0);
+crate::ast::parse::is_hex(p0);
-----------------
src/ast/parse.rs ast::parse::is_capture_char
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = true; // None+bool
+ast::parse::is_capture_char(p0, p1);
+crate::ast::parse::is_capture_char(p0, p1);
+crate::ast::parse::is_capture_char(p0, p1);
-----------------
src/ast/parse.rs ast::parse::specialize_err
deps:{"ast::parse::specialize_err":{"T":["std::marker::Sized"]}}
candidates:{"ast::parse::specialize_err":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<T, ast::Error>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+ast::parse::specialize_err(p0, p1, p2);
+crate::ast::parse::specialize_err(p0, p1, p2);
+crate::ast::parse::specialize_err(p0, p1, p2);
-----------------
src/ast/visitor.rs ast::visitor::visit
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"ast::visitor::visit":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::string::String","std::ffi::CString","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::path::PathBuf","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::visit":{"V":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+ast::visitor::visit(p0, p1);
+crate::ast::visitor::visit(p0, p1);
+crate::ast::visitor::visit(p0, p1);
-----------------
src/debug.rs debug::utf8_decode
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+debug::utf8_decode(p0);
+crate::debug::utf8_decode(p0);
+crate::debug::utf8_decode(p0);
-----------------
src/debug.rs debug::utf8_decode::len
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+debug::utf8_decode::len(p0);
+crate::debug::utf8_decode::len(p0);
+crate::debug::utf8_decode::len(p0);
-----------------
src/error.rs error::repeat_char
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 0usize; // None+usize
+error::repeat_char(p0, p1);
+crate::error::repeat_char(p0, p1);
+crate::error::repeat_char(p0, p1);
-----------------
src/hir/literal.rs hir::literal::rank
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+hir::literal::rank(p0);
+crate::hir::literal::rank(p0);
+crate::hir::literal::rank(p0);
-----------------
src/hir/translate.rs hir::translate::hir_ascii_class_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+hir::translate::hir_ascii_class_bytes(p0);
+crate::hir::translate::hir_ascii_class_bytes(p0);
+crate::hir::translate::hir_ascii_class_bytes(p0);
-----------------
src/hir/translate.rs hir::translate::ascii_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+hir::translate::ascii_class(p0);
+crate::hir::translate::ascii_class(p0);
+crate::hir::translate::ascii_class(p0);
-----------------
src/hir/translate.rs hir::translate::ascii_class_as_chars
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+hir::translate::ascii_class_as_chars(p0);
+crate::hir::translate::ascii_class_as_chars(p0);
+crate::hir::translate::ascii_class_as_chars(p0);
-----------------
src/hir/visitor.rs hir::visitor::visit
deps:{"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"hir::visitor::visit":{"V":["std::marker::Sized","hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"hir::visitor::visit":{"V":["hir::print::Writer"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+hir::visitor::visit(p0, p1);
+crate::hir::visitor::visit(p0, p1);
+crate::hir::visitor::visit(p0, p1);
-----------------
src/hir/mod.rs hir::class_chars
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [hir::Hir]
+hir::class_chars(p0);
+crate::hir::class_chars(p0);
+crate::hir::class_chars(p0);
-----------------
src/hir/mod.rs hir::class_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [hir::Hir]
+hir::class_bytes(p0);
+crate::hir::class_bytes(p0);
+crate::hir::class_bytes(p0);
-----------------
src/hir/mod.rs hir::singleton_chars
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [hir::Hir]
+hir::singleton_chars(p0);
+crate::hir::singleton_chars(p0);
+crate::hir::singleton_chars(p0);
-----------------
src/hir/mod.rs hir::singleton_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [hir::Hir]
+hir::singleton_bytes(p0);
+crate::hir::singleton_bytes(p0);
+crate::hir::singleton_bytes(p0);
-----------------
src/hir/mod.rs hir::lift_common_prefix
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::Hir>
+hir::lift_common_prefix(p0);
+crate::hir::lift_common_prefix(p0);
+crate::hir::lift_common_prefix(p0);
-----------------
src/parser.rs parser::parse
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+parser::parse(&p0);
+crate::parser::parse(&p0);
+crate::parser::parse(&p0);
-----------------
src/unicode.rs unicode::class
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'_>
+unicode::class(p0);
+crate::unicode::class(p0);
+crate::unicode::class(p0);
-----------------
src/unicode.rs unicode::perl_word
deps:{}
candidates:{}
+unicode::perl_word();
+crate::unicode::perl_word();
+crate::unicode::perl_word();
-----------------
src/unicode.rs unicode::perl_word::imp
deps:{}
candidates:{}
+unicode::perl_word::imp();
+crate::unicode::perl_word::imp();
+crate::unicode::perl_word::imp();
-----------------
src/unicode.rs unicode::perl_space
deps:{}
candidates:{}
+unicode::perl_space();
+crate::unicode::perl_space();
+crate::unicode::perl_space();
-----------------
src/unicode.rs unicode::perl_space::imp
deps:{}
candidates:{}
+unicode::perl_space::imp();
+crate::unicode::perl_space::imp();
+crate::unicode::perl_space::imp();
-----------------
src/unicode.rs unicode::perl_digit
deps:{}
candidates:{}
+unicode::perl_digit();
+crate::unicode::perl_digit();
+crate::unicode::perl_digit();
-----------------
src/unicode.rs unicode::perl_digit::imp
deps:{}
candidates:{}
+unicode::perl_digit::imp();
+crate::unicode::perl_digit::imp();
+crate::unicode::perl_digit::imp();
-----------------
src/unicode.rs unicode::hir_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(char, char)]
+unicode::hir_class(p0);
+crate::unicode::hir_class(p0);
+crate::unicode::hir_class(p0);
-----------------
src/unicode.rs unicode::is_word_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::is_word_character(p0);
+crate::unicode::is_word_character(p0);
+crate::unicode::is_word_character(p0);
-----------------
src/unicode.rs unicode::is_word_character::imp
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::is_word_character::imp(p0);
+crate::unicode::is_word_character::imp(p0);
+crate::unicode::is_word_character::imp(p0);
-----------------
src/unicode.rs unicode::canonical_gencat
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_gencat(&p0);
+crate::unicode::canonical_gencat(&p0);
+crate::unicode::canonical_gencat(&p0);
-----------------
src/unicode.rs unicode::canonical_script
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_script(&p0);
+crate::unicode::canonical_script(&p0);
+crate::unicode::canonical_script(&p0);
-----------------
src/unicode.rs unicode::canonical_prop
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_prop(&p0);
+crate::unicode::canonical_prop(&p0);
+crate::unicode::canonical_prop(&p0);
-----------------
src/unicode.rs unicode::canonical_prop::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_prop::imp(&p0);
+crate::unicode::canonical_prop::imp(&p0);
+crate::unicode::canonical_prop::imp(&p0);
-----------------
src/unicode.rs unicode::canonical_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(&'static str, &'static str)]
let mut p1 = "sample"; // None+&str
+unicode::canonical_value(p0, &p1);
+crate::unicode::canonical_value(p0, &p1);
+crate::unicode::canonical_value(p0, &p1);
-----------------
src/unicode.rs unicode::property_values
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::property_values(&p0);
+crate::unicode::property_values(&p0);
+crate::unicode::property_values(&p0);
-----------------
src/unicode.rs unicode::property_values::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::property_values::imp(&p0);
+crate::unicode::property_values::imp(&p0);
+crate::unicode::property_values::imp(&p0);
-----------------
src/unicode.rs unicode::property_set
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(&'static str, &'static [(char, char)])]
let mut p1 = "sample"; // None+&str
+unicode::property_set(p0, &p1);
+crate::unicode::property_set(p0, &p1);
+crate::unicode::property_set(p0, &p1);
-----------------
src/unicode.rs unicode::ages
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::ages(&p0);
+crate::unicode::ages(&p0);
+crate::unicode::ages(&p0);
-----------------
src/unicode.rs unicode::ages::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::ages::imp(&p0);
+crate::unicode::ages::imp(&p0);
+crate::unicode::ages::imp(&p0);
-----------------
src/unicode.rs unicode::gencat
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gencat(&p0);
+crate::unicode::gencat(&p0);
+crate::unicode::gencat(&p0);
-----------------
src/unicode.rs unicode::gencat::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gencat::imp(&p0);
+crate::unicode::gencat::imp(&p0);
+crate::unicode::gencat::imp(&p0);
-----------------
src/unicode.rs unicode::script
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script(&p0);
+crate::unicode::script(&p0);
+crate::unicode::script(&p0);
-----------------
src/unicode.rs unicode::script::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script::imp(&p0);
+crate::unicode::script::imp(&p0);
+crate::unicode::script::imp(&p0);
-----------------
src/unicode.rs unicode::script_extension
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script_extension(&p0);
+crate::unicode::script_extension(&p0);
+crate::unicode::script_extension(&p0);
-----------------
src/unicode.rs unicode::script_extension::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script_extension::imp(&p0);
+crate::unicode::script_extension::imp(&p0);
+crate::unicode::script_extension::imp(&p0);
-----------------
src/unicode.rs unicode::bool_property
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::bool_property(&p0);
+crate::unicode::bool_property(&p0);
+crate::unicode::bool_property(&p0);
-----------------
src/unicode.rs unicode::bool_property::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::bool_property::imp(&p0);
+crate::unicode::bool_property::imp(&p0);
+crate::unicode::bool_property::imp(&p0);
-----------------
src/unicode.rs unicode::gcb
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gcb(&p0);
+crate::unicode::gcb(&p0);
+crate::unicode::gcb(&p0);
-----------------
src/unicode.rs unicode::gcb::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gcb::imp(&p0);
+crate::unicode::gcb::imp(&p0);
+crate::unicode::gcb::imp(&p0);
-----------------
src/unicode.rs unicode::wb
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::wb(&p0);
+crate::unicode::wb(&p0);
+crate::unicode::wb(&p0);
-----------------
src/unicode.rs unicode::wb::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::wb::imp(&p0);
+crate::unicode::wb::imp(&p0);
+crate::unicode::wb::imp(&p0);
-----------------
src/unicode.rs unicode::sb
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::sb(&p0);
+crate::unicode::sb(&p0);
+crate::unicode::sb(&p0);
-----------------
src/unicode.rs unicode::sb::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::sb::imp(&p0);
+crate::unicode::sb::imp(&p0);
+crate::unicode::sb::imp(&p0);
-----------------
src/unicode.rs unicode::symbolic_name_normalize
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::symbolic_name_normalize(&p0);
+crate::unicode::symbolic_name_normalize(&p0);
+crate::unicode::symbolic_name_normalize(&p0);
-----------------
src/unicode.rs unicode::symbolic_name_normalize_bytes
deps:{}
candidates:{}
let mut p0 = &mut [0u8].as_mut_slice(); // None+[u8]
+unicode::symbolic_name_normalize_bytes(p0);
+crate::unicode::symbolic_name_normalize_bytes(p0);
+crate::unicode::symbolic_name_normalize_bytes(p0);
-----------------
src/utf8.rs utf8::max_scalar_value
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+utf8::max_scalar_value(p0);
+crate::utf8::max_scalar_value(p0);
+crate::utf8::max_scalar_value(p0);
-----------------
src/lib.rs escape
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+escape(&p0);
+crate::escape(&p0);
+crate::escape(&p0);
-----------------
src/lib.rs escape_into
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+escape_into(&p0, p1);
+crate::escape_into(&p0, p1);
+crate::escape_into(&p0, p1);
-----------------
src/lib.rs is_meta_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+is_meta_character(p0);
+crate::is_meta_character(p0);
+crate::is_meta_character(p0);
-----------------
src/lib.rs is_escapeable_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+is_escapeable_character(p0);
+crate::is_escapeable_character(p0);
+crate::is_escapeable_character(p0);
-----------------
src/lib.rs is_word_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+is_word_character(p0);
+crate::is_word_character(p0);
+crate::is_word_character(p0);
-----------------
src/lib.rs try_is_word_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+try_is_word_character(p0);
+crate::try_is_word_character(p0);
+crate::try_is_word_character(p0);
-----------------
src/lib.rs is_word_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+is_word_byte(p0);
+crate::is_word_byte(p0);
+crate::is_word_byte(p0);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::finish
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"ast::visitor::Visitor::finish":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::string::String","std::rc::Rc<T>","std::ffi::CString","<&mut T as std::fmt::Debug>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::OsString","std::path::PathBuf","std::boxed::Box<T, A>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::finish":{"Self":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.finish();
+ast::visitor::Visitor::finish(p0);
+crate::ast::visitor::Visitor::finish(p0);
+crate::ast::visitor::Visitor::finish(p0);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::start
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::Visitor::start":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::string::String","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","std::path::PathBuf","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::start":{"Self":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.start();
+ast::visitor::Visitor::start(p0);
+crate::ast::visitor::Visitor::start(p0);
+crate::ast::visitor::Visitor::start(p0);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::visit_pre
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"ast::visitor::Visitor::visit_pre":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::vec::Vec<T, A>","std::sync::Arc<T>","std::boxed::Box<T, A>","<&T as std::fmt::Debug>","std::ffi::CString","std::string::String","std::ffi::OsString","std::path::PathBuf","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_pre":{"Self":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+ast::visitor::Visitor::visit_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_pre(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::visit_post
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::Visitor::visit_post":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","<&T as std::fmt::Debug>","std::sync::Arc<T>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::ffi::OsString","std::ffi::CString","std::boxed::Box<T, A>","std::string::String"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_post":{"Self":["ast::print::Writer","hir::translate::TranslatorI","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+ast::visitor::Visitor::visit_post(p0, p1);
+crate::ast::visitor::Visitor::visit_post(p0, p1);
+crate::ast::visitor::Visitor::visit_post(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::visit_alternation_in
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"ast::visitor::Visitor::visit_alternation_in":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::string::String","std::boxed::Box<T, A>","std::sync::Arc<T>","std::ffi::CString","std::ffi::OsString","std::vec::Vec<T, A>","<&mut T as std::fmt::Debug>","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::visit_alternation_in":{"Self":["ast::print::Writer","hir::translate::TranslatorI","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.visit_alternation_in();
+ast::visitor::Visitor::visit_alternation_in(p0);
+crate::ast::visitor::Visitor::visit_alternation_in(p0);
+crate::ast::visitor::Visitor::visit_alternation_in(p0);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_item_pre
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"ast::visitor::Visitor::visit_class_set_item_pre":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::rc::Rc<T>","std::string::String","std::boxed::Box<T, A>","std::ffi::OsString","std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_item_pre":{"Self":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+ast::visitor::Visitor::visit_class_set_item_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_pre(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_item_post
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::Visitor::visit_class_set_item_post":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String","std::ffi::OsString","std::vec::Vec<T, A>","std::ffi::CString","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::visit_class_set_item_post":{"Self":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+ast::visitor::Visitor::visit_class_set_item_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_post(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_binary_op_pre
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::Visitor::visit_class_set_binary_op_pre":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::boxed::Box<T, A>","<&mut T as std::fmt::Debug>","std::string::String","std::ffi::OsString","std::vec::Vec<T, A>","std::rc::Rc<T>","std::sync::Arc<T>","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_binary_op_pre":{"Self":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_pre(p1);
+ast::visitor::Visitor::visit_class_set_binary_op_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_pre(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_binary_op_post
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::Visitor::visit_class_set_binary_op_post":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["<&mut T as std::borrow::Borrow<T>>","std::string::String","std::vec::Vec<T, A>","std::path::PathBuf","std::rc::Rc<T>","std::ffi::OsString","std::boxed::Box<T, A>","std::ffi::CString","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_binary_op_post":{"Self":["hir::translate::TranslatorI","ast::print::Writer","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_post(p1);
+ast::visitor::Visitor::visit_class_set_binary_op_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_post(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_binary_op_in
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::Visitor::visit_class_set_binary_op_in":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::ffi::CString","std::sync::Arc<T>","std::ffi::OsString","std::rc::Rc<T>","<&T as std::fmt::Debug>","std::path::PathBuf","std::vec::Vec<T, A>","std::string::String","std::boxed::Box<T, A>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_binary_op_in":{"Self":["hir::translate::TranslatorI","ast::parse::NestLimiter","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_in(p1);
+ast::visitor::Visitor::visit_class_set_binary_op_in(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_in(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_in(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::lower
deps:{"hir::interval::Interval::lower":{"Self":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Eq","std::marker::Copy","std::clone::Clone","std::default::Default","std::cmp::Ord","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::lower":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.lower();
+hir::interval::Interval::lower(p0);
+crate::hir::interval::Interval::lower(p0);
+crate::hir::interval::Interval::lower(p0);
-----------------
src/hir/interval.rs hir::interval::Interval::upper
deps:{"hir::interval::Interval::upper":{"Self":["std::cmp::PartialOrd","std::marker::Copy","std::fmt::Debug","std::default::Default","std::cmp::PartialEq","std::cmp::Ord","std::clone::Clone","std::cmp::Eq","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::upper":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.upper();
+hir::interval::Interval::upper(p0);
+crate::hir::interval::Interval::upper(p0);
+crate::hir::interval::Interval::upper(p0);
-----------------
src/hir/interval.rs hir::interval::Interval::set_lower
deps:{"hir::interval::Interval::set_lower":{"Self":["std::cmp::Eq","std::marker::Copy","hir::interval::Interval","std::cmp::Ord","std::clone::Clone","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug"]}}
candidates:{"hir::interval::Interval::set_lower":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
+p0.set_lower(p1);
+hir::interval::Interval::set_lower(p0, p1);
+crate::hir::interval::Interval::set_lower(p0, p1);
+crate::hir::interval::Interval::set_lower(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::set_upper
deps:{"hir::interval::Interval::set_upper":{"Self":["std::clone::Clone","std::marker::Copy","std::cmp::Eq","std::default::Default","std::cmp::Ord","hir::interval::Interval","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug"]}}
candidates:{"hir::interval::Interval::set_upper":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
+p0.set_upper(p1);
+hir::interval::Interval::set_upper(p0, p1);
+crate::hir::interval::Interval::set_upper(p0, p1);
+crate::hir::interval::Interval::set_upper(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::case_fold_simple
deps:{"hir::interval::Interval::case_fold_simple":{"Self":["std::cmp::PartialEq","std::cmp::Ord","std::fmt::Debug","std::clone::Clone","hir::interval::Interval","std::cmp::PartialOrd","std::marker::Copy","std::default::Default","std::cmp::Eq"]}}
candidates:{"hir::interval::Interval::case_fold_simple":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<Self>
+p0.case_fold_simple(p1);
+hir::interval::Interval::case_fold_simple(p0, p1);
+crate::hir::interval::Interval::case_fold_simple(p0, p1);
+crate::hir::interval::Interval::case_fold_simple(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::create
deps:{"hir::interval::Interval::create":{"Self":["std::cmp::PartialOrd","std::cmp::PartialEq","std::cmp::Eq","std::default::Default","std::fmt::Debug","std::clone::Clone","std::cmp::Ord","hir::interval::Interval","std::marker::Copy"]}}
candidates:{"hir::interval::Interval::create":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
let mut p1 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
+hir::interval::Interval::create(p0, p1);
+crate::hir::interval::Interval::create(p0, p1);
+crate::hir::interval::Interval::create(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::union
deps:{"hir::interval::Interval::union":{"Self":["std::default::Default","std::marker::Copy","std::cmp::PartialOrd","std::cmp::PartialEq","std::clone::Clone","std::cmp::Ord","std::cmp::Eq","std::fmt::Debug","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::union":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.union(p1);
+hir::interval::Interval::union(p0, p1);
+crate::hir::interval::Interval::union(p0, p1);
+crate::hir::interval::Interval::union(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::intersect
deps:{"hir::interval::Interval::intersect":{"Self":["std::cmp::PartialOrd","hir::interval::Interval","std::marker::Copy","std::clone::Clone","std::default::Default","std::cmp::PartialEq","std::cmp::Eq","std::cmp::Ord","std::fmt::Debug"]}}
candidates:{"hir::interval::Interval::intersect":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.intersect(p1);
+hir::interval::Interval::intersect(p0, p1);
+crate::hir::interval::Interval::intersect(p0, p1);
+crate::hir::interval::Interval::intersect(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::difference
deps:{"hir::interval::Interval::difference":{"Self":["std::fmt::Debug","std::default::Default","std::cmp::PartialEq","std::marker::Copy","std::cmp::PartialOrd","hir::interval::Interval","std::clone::Clone","std::cmp::Eq","std::cmp::Ord"]}}
candidates:{"hir::interval::Interval::difference":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.difference(p1);
+hir::interval::Interval::difference(p0, p1);
+crate::hir::interval::Interval::difference(p0, p1);
+crate::hir::interval::Interval::difference(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::symmetric_difference
deps:{"hir::interval::Interval::symmetric_difference":{"Self":["std::clone::Clone","std::cmp::Ord","std::marker::Copy","std::cmp::Eq","std::cmp::PartialEq","hir::interval::Interval","std::fmt::Debug","std::cmp::PartialOrd","std::default::Default"]}}
candidates:{"hir::interval::Interval::symmetric_difference":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.symmetric_difference(p1);
+hir::interval::Interval::symmetric_difference(p0, p1);
+crate::hir::interval::Interval::symmetric_difference(p0, p1);
+crate::hir::interval::Interval::symmetric_difference(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::is_contiguous
deps:{"hir::interval::Interval::is_contiguous":{"Self":["hir::interval::Interval","std::default::Default","std::clone::Clone","std::cmp::Eq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::cmp::Ord","std::cmp::PartialEq"]}}
candidates:{"hir::interval::Interval::is_contiguous":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_contiguous(p1);
+hir::interval::Interval::is_contiguous(p0, p1);
+crate::hir::interval::Interval::is_contiguous(p0, p1);
+crate::hir::interval::Interval::is_contiguous(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::is_intersection_empty
deps:{"hir::interval::Interval::is_intersection_empty":{"Self":["hir::interval::Interval","std::cmp::PartialOrd","std::cmp::Eq","std::fmt::Debug","std::default::Default","std::clone::Clone","std::marker::Copy","std::cmp::Ord","std::cmp::PartialEq"]}}
candidates:{"hir::interval::Interval::is_intersection_empty":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_intersection_empty(p1);
+hir::interval::Interval::is_intersection_empty(p0, p1);
+crate::hir::interval::Interval::is_intersection_empty(p0, p1);
+crate::hir::interval::Interval::is_intersection_empty(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Interval::is_subset
deps:{"hir::interval::Interval::is_subset":{"Self":["std::marker::Copy","hir::interval::Interval","std::fmt::Debug","std::clone::Clone","std::cmp::Ord","std::cmp::PartialOrd","std::default::Default","std::cmp::PartialEq","std::cmp::Eq"]}}
candidates:{"hir::interval::Interval::is_subset":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_subset(p1);
+hir::interval::Interval::is_subset(p0, p1);
+crate::hir::interval::Interval::is_subset(p0, p1);
+crate::hir::interval::Interval::is_subset(p0, p1);
-----------------
src/hir/interval.rs hir::interval::Bound::min_value
deps:{"hir::interval::Bound::min_value":{"Self":["std::cmp::PartialOrd","std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::cmp::Ord","hir::interval::Bound"]}}
candidates:{"hir::interval::Bound::min_value":{"Self":["char","u8"]}}
+hir::interval::Bound::min_value();
+crate::hir::interval::Bound::min_value();
+crate::hir::interval::Bound::min_value();
-----------------
src/hir/interval.rs hir::interval::Bound::max_value
deps:{"hir::interval::Bound::max_value":{"Self":["hir::interval::Bound","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Eq","std::marker::Copy","std::clone::Clone","std::cmp::PartialEq","std::cmp::Ord"]}}
candidates:{"hir::interval::Bound::max_value":{"Self":["u8","char"]}}
+hir::interval::Bound::max_value();
+crate::hir::interval::Bound::max_value();
+crate::hir::interval::Bound::max_value();
-----------------
src/hir/interval.rs hir::interval::Bound::as_u32
deps:{"hir::interval::Bound::as_u32":{"Self":["std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::clone::Clone","std::fmt::Debug","std::marker::Copy","std::cmp::Eq","hir::interval::Bound"]}}
candidates:{"hir::interval::Bound::as_u32":{"Self":["u8","char"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.as_u32();
+hir::interval::Bound::as_u32(p0);
+crate::hir::interval::Bound::as_u32(p0);
+crate::hir::interval::Bound::as_u32(p0);
-----------------
src/hir/interval.rs hir::interval::Bound::increment
deps:{"hir::interval::Bound::increment":{"Self":["std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::Ord","hir::interval::Bound","std::fmt::Debug","std::clone::Clone","std::marker::Copy"]}}
candidates:{"hir::interval::Bound::increment":{"Self":["u8","char"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.increment();
+hir::interval::Bound::increment(p0);
+crate::hir::interval::Bound::increment(p0);
+crate::hir::interval::Bound::increment(p0);
-----------------
src/hir/interval.rs hir::interval::Bound::decrement
deps:{"hir::interval::Bound::decrement":{"Self":["std::marker::Copy","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::Ord","hir::interval::Bound","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]}}
candidates:{"hir::interval::Bound::decrement":{"Self":["char","u8"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.decrement();
+hir::interval::Bound::decrement(p0);
+crate::hir::interval::Bound::decrement(p0);
+crate::hir::interval::Bound::decrement(p0);
-----------------
src/hir/visitor.rs hir::visitor::Visitor::finish
deps:{"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"hir::visitor::Visitor::finish":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::finish":{"Self":["hir::print::Writer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.finish();
+hir::visitor::Visitor::finish(p0);
+crate::hir::visitor::Visitor::finish(p0);
+crate::hir::visitor::Visitor::finish(p0);
-----------------
src/hir/visitor.rs hir::visitor::Visitor::start
deps:{"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"hir::visitor::Visitor::start":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::start":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.start();
+hir::visitor::Visitor::start(p0);
+crate::hir::visitor::Visitor::start(p0);
+crate::hir::visitor::Visitor::start(p0);
-----------------
src/hir/visitor.rs hir::visitor::Visitor::visit_pre
deps:{"hir::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"hir::visitor::Visitor::visit_pre":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::visit_pre":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_pre(p1);
+hir::visitor::Visitor::visit_pre(p0, p1);
+crate::hir::visitor::Visitor::visit_pre(p0, p1);
+crate::hir::visitor::Visitor::visit_pre(p0, p1);
-----------------
src/hir/visitor.rs hir::visitor::Visitor::visit_post
deps:{"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"hir::visitor::Visitor::visit_post":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"hir::visitor::Visitor::visit_post":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_post(p1);
+hir::visitor::Visitor::visit_post(p0, p1);
+crate::hir::visitor::Visitor::visit_post(p0, p1);
+crate::hir::visitor::Visitor::visit_post(p0, p1);
-----------------
src/hir/visitor.rs hir::visitor::Visitor::visit_alternation_in
deps:{"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"hir::visitor::Visitor::visit_alternation_in":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"hir::visitor::Visitor::visit_alternation_in":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.visit_alternation_in();
+hir::visitor::Visitor::visit_alternation_in(p0);
+crate::hir::visitor::Visitor::visit_alternation_in(p0);
+crate::hir::visitor::Visitor::visit_alternation_in(p0);
-----------------
src/ast/parse.rs <ast::parse::Primitive as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.clone();
+<ast::parse::Primitive as std::clone::Clone>::clone(p0);
+crate::<ast::parse::Primitive as std::clone::Clone>::clone(p0);
+<ast::parse::Primitive>::clone(p0);
-----------------
src/ast/parse.rs <ast::parse::Primitive as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::Primitive as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::Primitive as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::Primitive>::fmt(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.assert_receiver_is_total_eq();
+<ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::parse::Primitive>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/parse.rs <ast::parse::Primitive as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.eq(p1);
+<ast::parse::Primitive as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::parse::Primitive as std::cmp::PartialEq>::eq(p0, p1);
+<ast::parse::Primitive>::eq(p0, p1);
-----------------
src/ast/parse.rs ast::parse::Primitive::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.span();
+ast::parse::Primitive::span(p0);
+crate::ast::parse::Primitive::span(p0);
+<ast::parse::Primitive>::span(p0);
-----------------
src/ast/parse.rs ast::parse::Primitive::into_ast
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.into_ast();
+ast::parse::Primitive::into_ast(p0);
+crate::ast::parse::Primitive::into_ast(p0);
+<ast::parse::Primitive>::into_ast(p0);
-----------------
src/ast/parse.rs ast::parse::Primitive::into_class_set_item
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_set_item":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_set_item":{"P":["std::vec::Vec<T, A>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::path::PathBuf","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::ffi::CString","std::sync::Arc<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'_, P>
+p0.into_class_set_item(p1);
+ast::parse::Primitive::into_class_set_item(p0, p1);
+crate::ast::parse::Primitive::into_class_set_item(p0, p1);
+<ast::parse::Primitive>::into_class_set_item(p0, p1);
-----------------
src/ast/parse.rs ast::parse::Primitive::into_class_literal
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_literal":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_literal":{"P":["std::sync::Arc<T>","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::string::String","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::path::PathBuf","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'_, P>
+p0.into_class_literal(p1);
+ast::parse::Primitive::into_class_literal(p0, p1);
+crate::ast::parse::Primitive::into_class_literal(p0, p1);
+<ast::parse::Primitive>::into_class_literal(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::ParserBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
+p0.clone();
+<ast::parse::ParserBuilder as std::clone::Clone>::clone(p0);
+crate::<ast::parse::ParserBuilder as std::clone::Clone>::clone(p0);
+<ast::parse::ParserBuilder>::clone(p0);
-----------------
src/ast/parse.rs <ast::parse::ParserBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::ParserBuilder>::fmt(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::ParserBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<ast::parse::ParserBuilder as std::default::Default>::default();
+crate::<ast::parse::ParserBuilder as std::default::Default>::default();
+<ast::parse::ParserBuilder>::default();
-----------------
src/ast/parse.rs ast::parse::ParserBuilder::new
deps:{}
candidates:{}
+ast::parse::ParserBuilder::new();
+crate::ast::parse::ParserBuilder::new();
+<ast::parse::ParserBuilder>::new();
-----------------
src/ast/parse.rs ast::parse::ParserBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
+p0.build();
+ast::parse::ParserBuilder::build(p0);
+crate::ast::parse::ParserBuilder::build(p0);
+<ast::parse::ParserBuilder>::build(p0);
-----------------
src/ast/parse.rs ast::parse::ParserBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+ast::parse::ParserBuilder::nest_limit(p0, p1);
+crate::ast::parse::ParserBuilder::nest_limit(p0, p1);
+<ast::parse::ParserBuilder>::nest_limit(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+ast::parse::ParserBuilder::octal(p0, p1);
+crate::ast::parse::ParserBuilder::octal(p0, p1);
+<ast::parse::ParserBuilder>::octal(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+ast::parse::ParserBuilder::ignore_whitespace(p0, p1);
+crate::ast::parse::ParserBuilder::ignore_whitespace(p0, p1);
+<ast::parse::ParserBuilder>::ignore_whitespace(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::Parser as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Parser
+p0.clone();
+<ast::parse::Parser as std::clone::Clone>::clone(p0);
+crate::<ast::parse::Parser as std::clone::Clone>::clone(p0);
+<ast::parse::Parser>::clone(p0);
-----------------
src/ast/parse.rs <ast::parse::Parser as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Parser
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::Parser as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::Parser as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::Parser>::fmt(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::ParserI<'s, P> as std::clone::Clone>::clone
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone":{"P":["std::marker::Sized","std::clone::Clone"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"either::Either":{"Left":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"],"Right":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","hir::interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone":{"P":["ast::RepetitionRange","parser::Parser","ast::HexLiteralKind","ast::Error","hir::Capture","hir::HirKind","ast::ClassUnicodeOpKind","ast::Class","ast::Alternation","ast::ErrorKind","ast::Literal","ast::Group","ast::LiteralKind","ast::FlagsItem","utf8::Utf8Range","hir::Repetition","hir::LookSet","ast::Comment","hir::ClassUnicodeRange","ast::parse::ParserBuilder","hir::Hir","ast::Span","hir::Class","ast::ClassSet","hir::translate::TranslatorBuilder","ast::SetFlags","ast::Ast","ast::Position","ast::Assertion","ast::Flags","ast::ClassSetUnion","hir::Error","ast::parse::Primitive","hir::print::PrinterBuilder","hir::Literal","hir::ErrorKind","ast::FlagsItemKind","ast::parse::GroupState","either::Either","ast::ClassUnicodeKind","ast::print::PrinterBuilder","ast::parse::ClassState","hir::literal::ExtractKind","hir::ClassUnicode","ast::parse::ParserI","hir::interval::IntervalSet","ast::GroupKind","ast::CaptureName","ast::Concat","ast::ClassSetRange","hir::translate::HirFrame","ast::ClassSetBinaryOp","hir::Dot","hir::PropertiesI","hir::ClassBytesRange","hir::literal::Extractor","ast::Repetition","ast::Flag","ast::ClassAscii","ast::ClassUnicode","ast::ClassBracketed","ast::ClassPerlKind","std::clone::impls::<impl std::clone::Clone for *const T>","hir::literal::Seq","ast::RepetitionOp","hir::Look","hir::translate::Flags","ast::SpecialLiteralKind","ast::ClassSetItem","hir::translate::Translator","parser::ParserBuilder","ast::RepetitionKind","utf8::Utf8Sequence","ast::ClassPerl","ast::parse::Parser","ast::WithComments","ast::AssertionKind","hir::ClassBytes","hir::literal::Literal","hir::LookSetIter","ast::ClassAsciiKind","hir::translate::TranslatorI","hir::Properties","ast::ClassSetBinaryOpKind","error::Error"]},"ast::parse::ParserI":{"P":["std::string::String","std::ffi::OsString","std::vec::Vec<T, A>","std::rc::Rc<T>","std::path::PathBuf","<&mut T as std::fmt::Debug>","std::ffi::CString","std::sync::Arc<T>","std::boxed::Box<T, A>"]},"either::Either":{"Left":["ast::Position","ast::HexLiteralKind","ast::parse::Primitive","hir::Hir","ast::ClassUnicodeOpKind","ast::Class","ast::Repetition","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","hir::ErrorKind","hir::HirKind","hir::Class","hir::ClassUnicodeRange","hir::Look","ast::Error","ast::ClassSetBinaryOp","ast::ClassPerl","error::Error","ast::RepetitionKind","ast::ClassPerlKind","ast::FlagsItemKind","hir::ClassBytes","ast::ClassSet","ast::Group","ast::ClassSetBinaryOpKind","hir::ClassBytesRange","ast::SpecialLiteralKind","ast::Alternation","utf8::Utf8Sequence","ast::ClassUnicode","ast::Ast","ast::FlagsItem","ast::GroupKind","hir::Properties","ast::Concat","ast::RepetitionRange","either::Either","ast::LiteralKind","ast::ClassUnicodeKind","hir::literal::Seq","ast::AssertionKind","hir::Dot","ast::Comment","hir::ClassUnicode","hir::LookSet","ast::ClassSetItem","ast::Literal","ast::WithComments","ast::ClassSetUnion","ast::ClassAsciiKind","ast::Flags","hir::literal::Literal","hir::interval::IntervalSet","ast::SetFlags","utf8::Utf8Range","ast::CaptureName","ast::RepetitionOp","hir::PropertiesI","hir::Repetition","ast::ClassBracketed","hir::Capture","hir::Error","hir::Literal","ast::ClassAscii","ast::Assertion","ast::Span","ast::ClassSetRange","ast::ErrorKind","ast::Flag"],"Right":["error::Error","hir::PropertiesI","hir::Capture","hir::Hir","hir::Class","ast::ClassAscii","ast::Repetition","ast::ClassBracketed","hir::Error","ast::GroupKind","ast::Alternation","ast::Position","utf8::Utf8Range","ast::RepetitionRange","hir::literal::Literal","ast::ClassSetUnion","ast::RepetitionOp","ast::Flag","ast::FlagsItem","ast::ClassSet","ast::SpecialLiteralKind","ast::Error","ast::Class","ast::ClassSetBinaryOp","ast::RepetitionKind","ast::ClassUnicodeKind","ast::parse::Primitive","ast::ClassPerl","ast::ErrorKind","hir::interval::IntervalSet","ast::Ast","ast::ClassPerlKind","ast::CaptureName","ast::SetFlags","<*const T as std::fmt::Debug>","ast::Concat","hir::Literal","hir::Repetition","hir::Dot","utf8::Utf8Sequence","hir::Properties","ast::HexLiteralKind","hir::ClassUnicode","ast::WithComments","hir::ClassUnicodeRange","ast::Span","ast::AssertionKind","hir::ClassBytesRange","ast::ClassAsciiKind","ast::Flags","ast::Literal","hir::ErrorKind","ast::ClassUnicode","hir::ClassBytes","ast::ClassSetBinaryOpKind","ast::LiteralKind","hir::HirKind","either::Either","ast::FlagsItemKind","hir::literal::Seq","ast::Assertion","ast::Group","ast::Comment","ast::ClassSetRange","hir::Look","hir::LookSet","ast::ClassSetItem","ast::ClassUnicodeOpKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.clone();
+<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone(p0);
+crate::<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone(p0);
+<ast::parse::ParserI<'s, P>>::clone(p0);
-----------------
src/ast/parse.rs <ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt":{"P":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"],"Right":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::fmt::Debug","std::clone::Clone","hir::interval::Interval","std::marker::Sized"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt":{"P":["debug::Bytes","hir::LookSetIter","ast::ClassSetUnion","ast::parse::Parser","ast::Assertion","error::Error","hir::ErrorKind","ast::parse::GroupState","hir::ClassBytesIter","error::Formatter","utf8::ScalarRange","ast::ClassPerlKind","ast::parse::ClassState","hir::interval::IntervalSetIter","hir::Class","ast::GroupKind","ast::parse::Primitive","unicode::CaseFoldError","ast::HexLiteralKind","ast::ClassAscii","ast::Span","either::Either","ast::parse::NestLimiter","ast::WithComments","ast::print::Writer","ast::RepetitionOp","<*const T as std::fmt::Debug>","ast::Flags","ast::ClassUnicodeOpKind","ast::ClassUnicodeKind","hir::translate::Flags","hir::HirKind","ast::ClassPerl","ast::Ast","ast::SetFlags","parser::Parser","unicode::ClassQuery","ast::ClassSetItem","hir::Dot","ast::ClassSetBinaryOp","ast::ClassUnicode","hir::print::PrinterBuilder","ast::Class","utf8::Utf8Sequence","ast::Alternation","hir::Hir","ast::RepetitionKind","hir::ClassUnicodeRange","ast::CaptureName","ast::ClassBracketed","ast::Group","hir::translate::TranslatorI","ast::ClassSetRange","debug::Byte","hir::literal::Extractor","ast::RepetitionRange","hir::ClassBytesRange","ast::ClassAsciiKind","hir::Repetition","hir::Capture","hir::literal::State","hir::literal::Literal","ast::SpecialLiteralKind","ast::ClassSet","utf8::Utf8Sequences","ast::Concat","hir::print::Printer","hir::ClassBytes","hir::literal::PreferenceTrie","hir::print::Writer","ast::parse::ParserBuilder","ast::Literal","ast::ClassSetBinaryOpKind","hir::translate::HirFrame","ast::parse::ParserI","ast::Position","hir::translate::Translator","ast::ErrorKind","unicode::SimpleCaseFolder","hir::interval::IntervalSet","hir::ClassUnicodeIter","ast::Repetition","ast::visitor::ClassFrame","ast::Comment","unicode::Error","ast::Flag","ast::print::PrinterBuilder","hir::LookSet","ast::AssertionKind","hir::Look","hir::Properties","unicode::UnicodeWordError","ast::LiteralKind","ast::FlagsItem","ast::FlagsItemKind","utf8::Utf8Range","unicode::CanonicalClassQuery","hir::literal::ExtractKind","ast::visitor::ClassInduct","hir::Error","hir::ClassUnicode","hir::PropertiesI","hir::translate::TranslatorBuilder","parser::ParserBuilder","hir::literal::Seq","hir::Literal","ast::print::Printer","<&mut T as std::fmt::Debug>","ast::Error"]},"ast::parse::NestLimiter":{"P":["std::vec::Vec<T, A>","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::ffi::OsString","std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf"]},"ast::parse::ParserI":{"P":["std::string::String","std::rc::Rc<T>","std::clone::impls::<impl std::clone::Clone for &mut T>","std::sync::Arc<T>","std::ffi::CString","std::ffi::OsString","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::Flag","hir::ClassBytes","ast::CaptureName","either::Either","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::RepetitionKind","hir::Class","ast::ClassAsciiKind","hir::literal::Literal","ast::Comment","hir::Hir","hir::Error","hir::ClassUnicode","ast::Class","hir::HirKind","ast::ClassSetBinaryOp","ast::parse::Primitive","hir::literal::Seq","hir::PropertiesI","hir::ErrorKind","ast::Concat","hir::interval::IntervalSet","ast::SpecialLiteralKind","hir::ClassUnicodeRange","ast::LiteralKind","ast::Span","ast::ClassSetBinaryOpKind","hir::Dot","hir::Look","ast::ClassSetItem","ast::ClassSetUnion","ast::AssertionKind","ast::ClassUnicode","ast::ErrorKind","utf8::Utf8Range","ast::Repetition","ast::FlagsItem","ast::Flags","ast::HexLiteralKind","ast::ClassSet","ast::Group","ast::RepetitionOp","hir::Properties","ast::RepetitionRange","ast::Alternation","ast::Assertion","ast::WithComments","ast::FlagsItemKind","ast::ClassUnicodeOpKind","ast::ClassPerl","error::Error","hir::Literal","ast::GroupKind","ast::ClassPerlKind","utf8::Utf8Sequence","hir::Repetition","ast::ClassBracketed","hir::ClassBytesRange","ast::ClassUnicodeKind","ast::Error","ast::SetFlags","ast::ClassSetRange","ast::Literal","ast::ClassAscii","hir::Capture","hir::LookSet","ast::Ast","ast::Position"],"Right":["ast::ClassBracketed","hir::Look","hir::literal::Literal","utf8::Utf8Sequence","ast::SetFlags","ast::GroupKind","ast::AssertionKind","ast::ClassSetUnion","error::Error","ast::Assertion","ast::Group","hir::Literal","hir::literal::Seq","ast::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::Span","hir::ClassUnicode","ast::Alternation","ast::Flags","ast::Class","ast::Literal","hir::LookSet","hir::Hir","hir::HirKind","hir::Dot","ast::ClassUnicode","ast::Ast","ast::ClassUnicodeKind","ast::ClassSet","ast::parse::Primitive","ast::HexLiteralKind","ast::ClassUnicodeOpKind","ast::FlagsItemKind","ast::CaptureName","utf8::Utf8Range","hir::Class","ast::RepetitionRange","hir::ClassBytes","ast::ClassSetItem","ast::Comment","ast::ClassSetRange","ast::Concat","ast::FlagsItem","ast::SpecialLiteralKind","ast::WithComments","ast::Repetition","hir::ErrorKind","ast::Error","hir::ClassUnicodeRange","hir::ClassBytesRange","ast::ClassSetBinaryOpKind","ast::Flag","hir::Repetition","ast::RepetitionKind","hir::Properties","ast::ClassSetBinaryOp","ast::RepetitionOp","hir::Error","ast::ClassPerl","ast::ClassAscii","hir::Capture","hir::interval::IntervalSet","ast::ClassPerlKind","ast::ClassAsciiKind","ast::Position","either::Either","ast::LiteralKind","hir::PropertiesI"]},"error::Formatter":{"E":["hir::Hir","error::Error","<&T as std::fmt::Display>","error::Formatter","ast::Ast","unicode::CaseFoldError","unicode::UnicodeWordError","hir::Error","hir::ErrorKind","ast::Error","ast::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["unicode::SimpleCaseFolder","hir::literal::Extractor","ast::Position","ast::ClassPerlKind","utf8::Utf8Sequence","ast::ClassAscii","hir::LookSet","unicode::CaseFoldError","ast::SetFlags","utf8::Utf8Sequences","hir::Repetition","ast::parse::ClassState","hir::literal::State","ast::RepetitionRange","ast::print::Printer","hir::ClassUnicodeIter","debug::Bytes","hir::print::Printer","ast::parse::ParserBuilder","ast::Flags","hir::Hir","hir::Dot","ast::ClassSet","hir::Literal","ast::AssertionKind","ast::Group","ast::Repetition","hir::ClassUnicode","hir::ClassBytesIter","unicode::CanonicalClassQuery","ast::CaptureName","ast::Comment","ast::ClassPerl","hir::literal::PreferenceTrie","ast::parse::GroupState","error::Error","hir::HirKind","ast::parse::NestLimiter","hir::translate::Flags","either::Either","ast::RepetitionOp","ast::ClassSetBinaryOp","ast::Alternation","hir::ClassBytesRange","unicode::ClassQuery","ast::ErrorKind","ast::Ast","ast::visitor::ClassFrame","hir::translate::HirFrame","hir::ClassBytes","ast::parse::ParserI","hir::LookSetIter","ast::LiteralKind","ast::parse::Parser","hir::print::PrinterBuilder","ast::Assertion","unicode::Error","hir::interval::IntervalSetIter","ast::GroupKind","hir::Look","ast::Literal","hir::Capture","ast::visitor::ClassInduct","hir::Class","ast::WithComments","hir::translate::Translator","ast::parse::Primitive","ast::ClassAsciiKind","hir::PropertiesI","ast::Flag","parser::ParserBuilder","hir::Error","ast::Span","hir::translate::TranslatorI","hir::translate::TranslatorBuilder","hir::ErrorKind","debug::Byte","ast::ClassSetBinaryOpKind","hir::literal::ExtractKind","unicode::UnicodeWordError","ast::RepetitionKind","ast::ClassUnicode","ast::Concat","ast::Class","hir::ClassUnicodeRange","hir::literal::Seq","utf8::Utf8Range","ast::ClassUnicodeKind","utf8::ScalarRange","ast::Error","ast::FlagsItemKind","hir::Properties","<*mut T as std::fmt::Debug>","ast::FlagsItem","ast::HexLiteralKind","ast::ClassSetItem","ast::SpecialLiteralKind","hir::interval::IntervalSet","ast::print::Writer","hir::literal::Literal","ast::print::PrinterBuilder","ast::ClassBracketed","error::Formatter","ast::ClassUnicodeOpKind","ast::ClassSetRange","hir::print::Writer","ast::ClassSetUnion","parser::Parser"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::ParserI<'s, P>>::fmt(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::GroupState as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::GroupState
+p0.clone();
+<ast::parse::GroupState as std::clone::Clone>::clone(p0);
+crate::<ast::parse::GroupState as std::clone::Clone>::clone(p0);
+<ast::parse::GroupState>::clone(p0);
-----------------
src/ast/parse.rs <ast::parse::GroupState as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::GroupState
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::GroupState as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::GroupState as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::GroupState>::fmt(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::ClassState as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ClassState
+p0.clone();
+<ast::parse::ClassState as std::clone::Clone>::clone(p0);
+crate::<ast::parse::ClassState as std::clone::Clone>::clone(p0);
+<ast::parse::ClassState>::clone(p0);
-----------------
src/ast/parse.rs <ast::parse::ClassState as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ClassState
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::ClassState as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::ClassState as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::ClassState>::fmt(p0, p1);
-----------------
src/ast/parse.rs ast::parse::Parser::new
deps:{}
candidates:{}
+ast::parse::Parser::new();
+crate::ast::parse::Parser::new();
+<ast::parse::Parser>::new();
-----------------
src/ast/parse.rs ast::parse::Parser::parse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::Parser
let mut p1 = "sample"; // None+&str
+p0.parse(&p1);
+ast::parse::Parser::parse(p0, &p1);
+crate::ast::parse::Parser::parse(p0, &p1);
+<ast::parse::Parser>::parse(p0, &p1);
-----------------
src/ast/parse.rs ast::parse::Parser::parse_with_comments
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::Parser
let mut p1 = "sample"; // None+&str
+p0.parse_with_comments(&p1);
+ast::parse::Parser::parse_with_comments(p0, &p1);
+crate::ast::parse::Parser::parse_with_comments(p0, &p1);
+<ast::parse::Parser>::parse_with_comments(p0, &p1);
-----------------
src/ast/parse.rs ast::parse::Parser::reset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Parser
+p0.reset();
+ast::parse::Parser::reset(p0);
+crate::ast::parse::Parser::reset(p0);
+<ast::parse::Parser>::reset(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::new
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::new":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::new":{"P":["std::sync::Arc<T>","std::ffi::CString","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::string::String","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::vec::Vec<T, A>","std::path::PathBuf"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // P
let mut p1 = "sample"; // None+&str
+ast::parse::ParserI::<'s, P>::new(p0, &p1);
+crate::ast::parse::ParserI::<'s, P>::new(p0, &p1);
+<ast::parse::ParserI<'s, P>>::new(p0, &p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parser
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parser":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parser":{"P":["std::ffi::OsString","std::path::PathBuf","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::CString","std::string::String","std::sync::Arc<T>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parser();
+ast::parse::ParserI::<'s, P>::parser(p0);
+crate::ast::parse::ParserI::<'s, P>::parser(p0);
+<ast::parse::ParserI<'s, P>>::parser(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::pattern
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pattern":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pattern":{"P":["std::ffi::CString","std::path::PathBuf","std::rc::Rc<T>","std::borrow::Cow<'a, B>","<&mut T as std::borrow::Borrow<T>>","std::string::String","<T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::ffi::OsString","std::vec::Vec<T, A>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.pattern();
+ast::parse::ParserI::<'s, P>::pattern(p0);
+crate::ast::parse::ParserI::<'s, P>::pattern(p0);
+<ast::parse::ParserI<'s, P>>::pattern(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::error
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::error":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::error":{"P":["std::path::PathBuf","std::borrow::Cow<'a, B>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::boxed::Box<T, A>","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.error(p1, p2);
+ast::parse::ParserI::<'s, P>::error(p0, p1, p2);
+crate::ast::parse::ParserI::<'s, P>::error(p0, p1, p2);
+<ast::parse::ParserI<'s, P>>::error(p0, p1, p2);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::offset
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::offset":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::offset":{"P":["std::ffi::CString","std::rc::Rc<T>","std::path::PathBuf","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::string::String","<T as std::borrow::Borrow<T>>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.offset();
+ast::parse::ParserI::<'s, P>::offset(p0);
+crate::ast::parse::ParserI::<'s, P>::offset(p0);
+<ast::parse::ParserI<'s, P>>::offset(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::line
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::line":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::line":{"P":["std::sync::Arc<T>","std::ffi::OsString","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::rc::Rc<T>","std::ffi::CString","std::string::String","<&T as std::borrow::Borrow<T>>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.line();
+ast::parse::ParserI::<'s, P>::line(p0);
+crate::ast::parse::ParserI::<'s, P>::line(p0);
+<ast::parse::ParserI<'s, P>>::line(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::column
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::column":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::column":{"P":["std::path::PathBuf","std::string::String","std::sync::Arc<T>","std::ffi::OsString","std::ffi::CString","std::rc::Rc<T>","std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.column();
+ast::parse::ParserI::<'s, P>::column(p0);
+crate::ast::parse::ParserI::<'s, P>::column(p0);
+<ast::parse::ParserI<'s, P>>::column(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::next_capture_index
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::next_capture_index":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::next_capture_index":{"P":["<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::ffi::CString","std::ffi::OsString","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::string::String","std::vec::Vec<T, A>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
+p0.next_capture_index(p1);
+ast::parse::ParserI::<'s, P>::next_capture_index(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::next_capture_index(p0, p1);
+<ast::parse::ParserI<'s, P>>::next_capture_index(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::add_capture_name
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::add_capture_name":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::add_capture_name":{"P":["std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::boxed::Box<T, A>","std::ffi::OsString","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.add_capture_name(p1);
+ast::parse::ParserI::<'s, P>::add_capture_name(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::add_capture_name(p0, p1);
+<ast::parse::ParserI<'s, P>>::add_capture_name(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::ignore_whitespace
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::ignore_whitespace":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::ignore_whitespace":{"P":["std::boxed::Box<T, A>","std::string::String","std::vec::Vec<T, A>","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf","std::borrow::Cow<'a, B>","<&T as std::borrow::Borrow<T>>","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.ignore_whitespace();
+ast::parse::ParserI::<'s, P>::ignore_whitespace(p0);
+crate::ast::parse::ParserI::<'s, P>::ignore_whitespace(p0);
+<ast::parse::ParserI<'s, P>>::ignore_whitespace(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::char
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char":{"P":["<&mut T as std::borrow::Borrow<T>>","std::string::String","std::ffi::OsString","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::path::PathBuf","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.char();
+ast::parse::ParserI::<'s, P>::char(p0);
+crate::ast::parse::ParserI::<'s, P>::char(p0);
+<ast::parse::ParserI<'s, P>>::char(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::char_at
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char_at":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char_at":{"P":["<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::CString","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::path::PathBuf","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = 0usize; // None+usize
+p0.char_at(p1);
+ast::parse::ParserI::<'s, P>::char_at(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::char_at(p0, p1);
+<ast::parse::ParserI<'s, P>>::char_at(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump":{"P":["std::ffi::CString","std::string::String","std::path::PathBuf","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::boxed::Box<T, A>","std::sync::Arc<T>","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.bump();
+ast::parse::ParserI::<'s, P>::bump(p0);
+crate::ast::parse::ParserI::<'s, P>::bump(p0);
+<ast::parse::ParserI<'s, P>>::bump(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump_if
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_if":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_if":{"P":["std::borrow::Cow<'a, B>","std::path::PathBuf","std::ffi::CString","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::string::String","std::ffi::OsString","std::sync::Arc<T>","std::rc::Rc<T>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = "sample"; // None+&str
+p0.bump_if(&p1);
+ast::parse::ParserI::<'s, P>::bump_if(p0, &p1);
+crate::ast::parse::ParserI::<'s, P>::bump_if(p0, &p1);
+<ast::parse::ParserI<'s, P>>::bump_if(p0, &p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::is_lookaround_prefix
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":{"P":["std::ffi::OsString","std::ffi::CString","std::path::PathBuf","std::string::String","std::vec::Vec<T, A>","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.is_lookaround_prefix();
+ast::parse::ParserI::<'s, P>::is_lookaround_prefix(p0);
+crate::ast::parse::ParserI::<'s, P>::is_lookaround_prefix(p0);
+<ast::parse::ParserI<'s, P>>::is_lookaround_prefix(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump_and_bump_space
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_and_bump_space":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_and_bump_space":{"P":["std::vec::Vec<T, A>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::boxed::Box<T, A>","std::string::String","std::ffi::CString","std::ffi::OsString","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.bump_and_bump_space();
+ast::parse::ParserI::<'s, P>::bump_and_bump_space(p0);
+crate::ast::parse::ParserI::<'s, P>::bump_and_bump_space(p0);
+<ast::parse::ParserI<'s, P>>::bump_and_bump_space(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump_space
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_space":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_space":{"P":["std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::sync::Arc<T>","std::string::String","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::path::PathBuf","std::ffi::CString","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.bump_space();
+ast::parse::ParserI::<'s, P>::bump_space(p0);
+crate::ast::parse::ParserI::<'s, P>::bump_space(p0);
+<ast::parse::ParserI<'s, P>>::bump_space(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::peek
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek":{"P":["std::borrow::Cow<'a, B>","std::ffi::CString","std::vec::Vec<T, A>","std::path::PathBuf","std::ffi::OsString","std::sync::Arc<T>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::string::String","<&T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.peek();
+ast::parse::ParserI::<'s, P>::peek(p0);
+crate::ast::parse::ParserI::<'s, P>::peek(p0);
+<ast::parse::ParserI<'s, P>>::peek(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::peek_space
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek_space":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek_space":{"P":["std::string::String","std::ffi::CString","std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::ffi::OsString","<T as std::borrow::Borrow<T>>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.peek_space();
+ast::parse::ParserI::<'s, P>::peek_space(p0);
+crate::ast::parse::ParserI::<'s, P>::peek_space(p0);
+<ast::parse::ParserI<'s, P>>::peek_space(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::is_eof
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_eof":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_eof":{"P":["std::borrow::Cow<'a, B>","<&T as std::borrow::Borrow<T>>","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::rc::Rc<T>","std::string::String","std::path::PathBuf","std::ffi::CString","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.is_eof();
+ast::parse::ParserI::<'s, P>::is_eof(p0);
+crate::ast::parse::ParserI::<'s, P>::is_eof(p0);
+<ast::parse::ParserI<'s, P>>::is_eof(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::pos
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pos":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pos":{"P":["<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::CString","std::ffi::OsString","std::vec::Vec<T, A>","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::string::String","std::rc::Rc<T>","std::sync::Arc<T>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.pos();
+ast::parse::ParserI::<'s, P>::pos(p0);
+crate::ast::parse::ParserI::<'s, P>::pos(p0);
+<ast::parse::ParserI<'s, P>>::pos(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::span
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span":{"P":["std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::vec::Vec<T, A>","std::rc::Rc<T>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::string::String","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.span();
+ast::parse::ParserI::<'s, P>::span(p0);
+crate::ast::parse::ParserI::<'s, P>::span(p0);
+<ast::parse::ParserI<'s, P>>::span(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::span_char
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span_char":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span_char":{"P":["<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","std::string::String","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::OsString","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.span_char();
+ast::parse::ParserI::<'s, P>::span_char(p0);
+crate::ast::parse::ParserI::<'s, P>::span_char(p0);
+<ast::parse::ParserI<'s, P>>::span_char(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_alternate
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_alternate":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_alternate":{"P":["<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.push_alternate(p1);
+ast::parse::ParserI::<'s, P>::push_alternate(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_alternate(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_alternate(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_or_add_alternation
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_or_add_alternation":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_or_add_alternation":{"P":["std::string::String","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::path::PathBuf","std::ffi::OsString","std::ffi::CString","std::boxed::Box<T, A>","std::sync::Arc<T>","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.push_or_add_alternation(p1);
+ast::parse::ParserI::<'s, P>::push_or_add_alternation(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_or_add_alternation(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_or_add_alternation(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_group
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_group":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_group":{"P":["std::vec::Vec<T, A>","std::string::String","std::path::PathBuf","std::ffi::CString","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.push_group(p1);
+ast::parse::ParserI::<'s, P>::push_group(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_group(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_group(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_group
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group":{"P":["std::ffi::OsString","std::path::PathBuf","std::vec::Vec<T, A>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::string::String","std::ffi::CString","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.pop_group(p1);
+ast::parse::ParserI::<'s, P>::pop_group(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_group(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_group(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_group_end
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group_end":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group_end":{"P":["<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::ffi::CString","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.pop_group_end(p1);
+ast::parse::ParserI::<'s, P>::pop_group_end(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_group_end(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_group_end(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_class_open
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_open":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_open":{"P":["std::path::PathBuf","std::rc::Rc<T>","std::ffi::CString","std::ffi::OsString","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::string::String","<&T as std::borrow::Borrow<T>>","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.push_class_open(p1);
+ast::parse::ParserI::<'s, P>::push_class_open(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_class_open(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_class_open(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class":{"P":["std::ffi::CString","std::sync::Arc<T>","std::ffi::OsString","std::path::PathBuf","std::borrow::Cow<'a, B>","std::string::String","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.pop_class(p1);
+ast::parse::ParserI::<'s, P>::pop_class(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_class(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_class(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::unclosed_class_error
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::unclosed_class_error":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::unclosed_class_error":{"P":["std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::string::String","std::rc::Rc<T>","std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.unclosed_class_error();
+ast::parse::ParserI::<'s, P>::unclosed_class_error(p0);
+crate::ast::parse::ParserI::<'s, P>::unclosed_class_error(p0);
+<ast::parse::ParserI<'s, P>>::unclosed_class_error(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_class_op
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_op":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_op":{"P":["<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::CString","std::vec::Vec<T, A>","std::rc::Rc<T>","std::sync::Arc<T>","std::ffi::OsString","std::borrow::Cow<'a, B>","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.push_class_op(p1, p2);
+ast::parse::ParserI::<'s, P>::push_class_op(p0, p1, p2);
+crate::ast::parse::ParserI::<'s, P>::push_class_op(p0, p1, p2);
+<ast::parse::ParserI<'s, P>>::push_class_op(p0, p1, p2);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_class_op
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class_op":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class_op":{"P":["std::rc::Rc<T>","std::boxed::Box<T, A>","std::string::String","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::path::PathBuf","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.pop_class_op(p1);
+ast::parse::ParserI::<'s, P>::pop_class_op(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_class_op(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_class_op(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse":{"P":["std::ffi::OsString","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::boxed::Box<T, A>","std::string::String","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::ffi::CString","std::sync::Arc<T>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse();
+ast::parse::ParserI::<'s, P>::parse(p0);
+crate::ast::parse::ParserI::<'s, P>::parse(p0);
+<ast::parse::ParserI<'s, P>>::parse(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_with_comments
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_with_comments":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_with_comments":{"P":["<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::path::PathBuf","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::OsString","std::rc::Rc<T>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_with_comments();
+ast::parse::ParserI::<'s, P>::parse_with_comments(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_with_comments(p0);
+<ast::parse::ParserI<'s, P>>::parse_with_comments(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_uncounted_repetition
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":{"P":["std::rc::Rc<T>","std::string::String","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::ffi::CString","std::path::PathBuf","std::ffi::OsString","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.parse_uncounted_repetition(p1, p2);
+ast::parse::ParserI::<'s, P>::parse_uncounted_repetition(p0, p1, p2);
+crate::ast::parse::ParserI::<'s, P>::parse_uncounted_repetition(p0, p1, p2);
+<ast::parse::ParserI<'s, P>>::parse_uncounted_repetition(p0, p1, p2);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_counted_repetition
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_counted_repetition":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_counted_repetition":{"P":["std::string::String","std::ffi::OsString","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.parse_counted_repetition(p1);
+ast::parse::ParserI::<'s, P>::parse_counted_repetition(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_counted_repetition(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_counted_repetition(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_group
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_group":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_group":{"P":["std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::sync::Arc<T>","std::vec::Vec<T, A>","std::rc::Rc<T>","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_group();
+ast::parse::ParserI::<'s, P>::parse_group(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_group(p0);
+<ast::parse::ParserI<'s, P>>::parse_group(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_capture_name
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_capture_name":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_capture_name":{"P":["<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::path::PathBuf","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::string::String","std::ffi::OsString","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = 0u32; // None+u32
+p0.parse_capture_name(p1);
+ast::parse::ParserI::<'s, P>::parse_capture_name(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_capture_name(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_capture_name(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_flags
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flags":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flags":{"P":["std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::sync::Arc<T>","std::string::String","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_flags();
+ast::parse::ParserI::<'s, P>::parse_flags(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_flags(p0);
+<ast::parse::ParserI<'s, P>>::parse_flags(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_flag
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flag":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flag":{"P":["std::vec::Vec<T, A>","std::ffi::OsString","std::string::String","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::ffi::CString","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_flag();
+ast::parse::ParserI::<'s, P>::parse_flag(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_flag(p0);
+<ast::parse::ParserI<'s, P>>::parse_flag(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_primitive
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_primitive":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_primitive":{"P":["<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::CString","std::string::String","std::ffi::OsString","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_primitive();
+ast::parse::ParserI::<'s, P>::parse_primitive(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_primitive(p0);
+<ast::parse::ParserI<'s, P>>::parse_primitive(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_escape
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_escape":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_escape":{"P":["std::boxed::Box<T, A>","std::ffi::CString","std::sync::Arc<T>","std::rc::Rc<T>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::path::PathBuf","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_escape();
+ast::parse::ParserI::<'s, P>::parse_escape(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_escape(p0);
+<ast::parse::ParserI<'s, P>>::parse_escape(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_octal
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_octal":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_octal":{"P":["<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::ffi::OsString","std::path::PathBuf","std::string::String","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_octal();
+ast::parse::ParserI::<'s, P>::parse_octal(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_octal(p0);
+<ast::parse::ParserI<'s, P>>::parse_octal(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_hex
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex":{"P":["std::ffi::OsString","std::vec::Vec<T, A>","std::ffi::CString","std::sync::Arc<T>","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::string::String","std::rc::Rc<T>","std::path::PathBuf","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_hex();
+ast::parse::ParserI::<'s, P>::parse_hex(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_hex(p0);
+<ast::parse::ParserI<'s, P>>::parse_hex(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_hex_digits
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_digits":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_digits":{"P":["std::string::String","std::ffi::OsString","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::ffi::CString","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.parse_hex_digits(p1);
+ast::parse::ParserI::<'s, P>::parse_hex_digits(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_hex_digits(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_hex_digits(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_hex_brace
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_brace":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_brace":{"P":["std::string::String","std::ffi::CString","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::ffi::OsString","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.parse_hex_brace(p1);
+ast::parse::ParserI::<'s, P>::parse_hex_brace(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_hex_brace(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_hex_brace(p0, p1);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_decimal
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_decimal":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_decimal":{"P":["std::string::String","std::ffi::CString","std::ffi::OsString","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_decimal();
+ast::parse::ParserI::<'s, P>::parse_decimal(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_decimal(p0);
+<ast::parse::ParserI<'s, P>>::parse_decimal(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class":{"P":["std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","std::string::String","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class();
+ast::parse::ParserI::<'s, P>::parse_set_class(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class_range
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_range":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_range":{"P":["std::vec::Vec<T, A>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::OsString","std::string::String","std::ffi::CString","std::borrow::Cow<'a, B>","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class_range();
+ast::parse::ParserI::<'s, P>::parse_set_class_range(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class_range(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class_range(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class_item
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_item":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_item":{"P":["std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::rc::Rc<T>","std::string::String","std::ffi::CString","std::boxed::Box<T, A>","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class_item();
+ast::parse::ParserI::<'s, P>::parse_set_class_item(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class_item(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class_item(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class_open
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_open":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_open":{"P":["std::vec::Vec<T, A>","std::ffi::CString","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::boxed::Box<T, A>","std::path::PathBuf","std::rc::Rc<T>","std::sync::Arc<T>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class_open();
+ast::parse::ParserI::<'s, P>::parse_set_class_open(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class_open(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class_open(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":{"P":["std::path::PathBuf","std::ffi::CString","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.maybe_parse_ascii_class();
+ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class(p0);
+crate::ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class(p0);
+<ast::parse::ParserI<'s, P>>::maybe_parse_ascii_class(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_unicode_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_unicode_class":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_unicode_class":{"P":["std::ffi::CString","std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_unicode_class();
+ast::parse::ParserI::<'s, P>::parse_unicode_class(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_unicode_class(p0);
+<ast::parse::ParserI<'s, P>>::parse_unicode_class(p0);
-----------------
src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_perl_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_perl_class":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_perl_class":{"P":["std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","<&T as std::borrow::Borrow<T>>","std::string::String","std::sync::Arc<T>","std::ffi::OsString","std::vec::Vec<T, A>","std::ffi::CString","std::boxed::Box<T, A>","std::rc::Rc<T>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_perl_class();
+ast::parse::ParserI::<'s, P>::parse_perl_class(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_perl_class(p0);
+<ast::parse::ParserI<'s, P>>::parse_perl_class(p0);
-----------------
src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt":{"P":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"either::Either":{"Left":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"],"Right":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"error::Formatter":{"E":["std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt":{"P":["ast::ClassSet","ast::ClassAsciiKind","ast::ClassSetBinaryOpKind","hir::LookSet","unicode::SimpleCaseFolder","hir::ClassBytesIter","ast::Repetition","ast::ClassPerl","ast::ClassUnicodeKind","ast::SetFlags","debug::Bytes","ast::visitor::ClassFrame","hir::ClassBytesRange","hir::Look","unicode::CaseFoldError","ast::WithComments","ast::ClassBracketed","ast::Flags","ast::parse::Parser","hir::translate::TranslatorBuilder","ast::parse::GroupState","either::Either","error::Error","ast::ClassAscii","hir::Literal","hir::ClassUnicodeIter","ast::Alternation","hir::interval::IntervalSet","hir::translate::TranslatorI","hir::translate::Translator","ast::Literal","ast::print::Printer","hir::translate::Flags","ast::visitor::ClassInduct","hir::ClassUnicodeRange","ast::parse::ClassState","ast::CaptureName","<&T as std::fmt::Debug>","ast::ClassUnicode","hir::ClassUnicode","ast::Class","hir::print::PrinterBuilder","unicode::UnicodeWordError","unicode::CanonicalClassQuery","ast::SpecialLiteralKind","utf8::ScalarRange","ast::FlagsItem","hir::Repetition","hir::ClassBytes","<&mut T as std::fmt::Debug>","hir::translate::HirFrame","ast::Span","ast::Comment","ast::FlagsItemKind","hir::Error","hir::ErrorKind","ast::HexLiteralKind","ast::ClassSetRange","ast::Concat","hir::Dot","hir::literal::ExtractKind","hir::PropertiesI","hir::LookSetIter","hir::literal::Extractor","ast::parse::Primitive","utf8::Utf8Sequence","hir::Properties","parser::Parser","ast::ClassUnicodeOpKind","hir::literal::PreferenceTrie","hir::Class","debug::Byte","hir::print::Printer","hir::literal::State","ast::LiteralKind","ast::Ast","ast::RepetitionOp","ast::Flag","hir::HirKind","utf8::Utf8Sequences","error::Formatter","ast::parse::NestLimiter","ast::Error","hir::Capture","hir::literal::Literal","hir::print::Writer","ast::AssertionKind","ast::parse::ParserBuilder","ast::GroupKind","hir::Hir","utf8::Utf8Range","ast::print::Writer","ast::Assertion","ast::ClassSetUnion","ast::print::PrinterBuilder","ast::parse::ParserI","hir::interval::IntervalSetIter","ast::Position","ast::ClassSetBinaryOp","unicode::ClassQuery","unicode::Error","ast::ClassSetItem","ast::RepetitionKind","hir::literal::Seq","parser::ParserBuilder","ast::ClassPerlKind","ast::ErrorKind","ast::Group","ast::RepetitionRange"]},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","std::sync::Arc<T>","std::ffi::CString","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","std::vec::Vec<T, A>","std::path::PathBuf","std::string::String"]},"ast::parse::ParserI":{"P":["std::clone::impls::<impl std::clone::Clone for &mut T>","std::sync::Arc<T>","std::rc::Rc<T>","std::boxed::Box<T, A>","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::CString","std::string::String","std::ffi::OsString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["hir::Literal","ast::Group","ast::Comment","ast::ClassUnicodeOpKind","ast::Ast","hir::Look","hir::ClassUnicodeRange","utf8::Utf8Sequence","ast::Concat","ast::Span","hir::Capture","utf8::Utf8Range","ast::ClassSet","ast::parse::Primitive","ast::FlagsItem","hir::Hir","ast::ClassSetRange","ast::WithComments","ast::ClassSetBinaryOpKind","ast::CaptureName","ast::ClassAscii","hir::Properties","hir::Repetition","ast::ClassBracketed","ast::SpecialLiteralKind","ast::ClassSetBinaryOp","hir::Error","ast::ClassUnicode","ast::ClassSetItem","ast::ErrorKind","ast::Position","ast::AssertionKind","ast::Literal","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","hir::PropertiesI","ast::RepetitionKind","ast::Flag","hir::interval::IntervalSet","ast::Repetition","ast::FlagsItemKind","hir::LookSet","hir::Class","error::Error","ast::RepetitionOp","ast::ClassUnicodeKind","ast::ClassPerlKind","ast::Alternation","ast::HexLiteralKind","ast::RepetitionRange","ast::ClassAsciiKind","hir::Dot","hir::literal::Literal","hir::HirKind","hir::literal::Seq","ast::LiteralKind","hir::ErrorKind","ast::Assertion","ast::Flags","ast::ClassSetUnion","ast::GroupKind","ast::SetFlags","either::Either","ast::Error","hir::ClassUnicode","ast::Class","hir::ClassBytesRange","hir::ClassBytes","ast::ClassPerl"],"Right":["hir::ClassBytes","ast::ClassPerlKind","hir::Literal","hir::ClassUnicodeRange","hir::Repetition","ast::SetFlags","ast::ClassUnicodeOpKind","utf8::Utf8Range","hir::ErrorKind","ast::Error","hir::literal::Seq","hir::Properties","hir::Class","ast::Span","hir::Error","hir::Hir","ast::RepetitionRange","ast::Flag","ast::FlagsItem","ast::ClassBracketed","ast::RepetitionKind","ast::ClassSetRange","hir::Look","hir::ClassUnicode","ast::ClassSetItem","ast::RepetitionOp","hir::Dot","hir::HirKind","ast::ClassAscii","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::Ast","ast::Comment","ast::LiteralKind","hir::Capture","ast::Class","utf8::Utf8Sequence","ast::ClassAsciiKind","hir::interval::IntervalSet","ast::ClassUnicodeKind","hir::ClassBytesRange","ast::AssertionKind","ast::ClassUnicode","ast::GroupKind","error::Error","ast::Group","ast::Literal","ast::ErrorKind","ast::Flags","ast::ClassSetUnion","ast::CaptureName","ast::Repetition","ast::ClassSetBinaryOp","ast::FlagsItemKind","ast::Alternation","hir::LookSet","ast::parse::Primitive","ast::ClassPerl","ast::HexLiteralKind","ast::ClassSet","ast::Assertion","ast::WithComments","ast::ClassSetBinaryOpKind","ast::Position","either::Either","ast::Concat","hir::literal::Literal","ast::SpecialLiteralKind","hir::PropertiesI"]},"error::Formatter":{"E":["ast::Ast","unicode::CaseFoldError","hir::ErrorKind","hir::Hir","unicode::UnicodeWordError","<&T as std::fmt::Display>","hir::Error","ast::Error","error::Formatter","error::Error","ast::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["hir::literal::PreferenceTrie","hir::ClassBytes","hir::Dot","parser::Parser","ast::parse::Parser","ast::RepetitionOp","ast::Alternation","ast::parse::NestLimiter","hir::print::Printer","ast::print::Printer","ast::ClassPerlKind","ast::RepetitionKind","ast::Literal","hir::Error","hir::PropertiesI","hir::HirKind","ast::RepetitionRange","hir::literal::Seq","ast::print::PrinterBuilder","ast::Assertion","debug::Byte","ast::ClassUnicodeOpKind","unicode::Error","hir::Hir","ast::visitor::ClassInduct","unicode::CaseFoldError","hir::LookSet","hir::print::PrinterBuilder","hir::literal::Extractor","ast::Flags","hir::interval::IntervalSetIter","hir::ClassUnicodeIter","ast::ClassAsciiKind","debug::Bytes","ast::AssertionKind","hir::translate::Translator","ast::ClassSetRange","ast::ClassSetUnion","hir::ClassUnicode","hir::LookSetIter","ast::ClassSet","ast::CaptureName","error::Error","hir::Repetition","hir::ClassUnicodeRange","unicode::ClassQuery","parser::ParserBuilder","ast::LiteralKind","ast::ClassUnicode","unicode::SimpleCaseFolder","ast::FlagsItemKind","hir::ClassBytesIter","hir::ClassBytesRange","hir::Look","ast::HexLiteralKind","ast::WithComments","ast::parse::ParserI","utf8::Utf8Sequences","ast::Error","unicode::UnicodeWordError","ast::ErrorKind","hir::literal::Literal","ast::ClassSetBinaryOpKind","ast::Class","utf8::Utf8Sequence","ast::Span","ast::Flag","ast::ClassBracketed","hir::interval::IntervalSet","hir::Class","hir::Properties","ast::Concat","ast::ClassSetItem","ast::GroupKind","hir::Capture","hir::translate::HirFrame","ast::ClassPerl","hir::Literal","ast::parse::ParserBuilder","ast::ClassSetBinaryOp","hir::literal::ExtractKind","hir::translate::TranslatorBuilder","either::Either","ast::Ast","ast::ClassAscii","unicode::CanonicalClassQuery","ast::visitor::ClassFrame","hir::translate::TranslatorI","utf8::Utf8Range","ast::ClassUnicodeKind","hir::print::Writer","hir::ErrorKind","ast::Group","ast::Repetition","ast::print::Writer","<&T as std::fmt::Debug>","hir::literal::State","ast::FlagsItem","utf8::ScalarRange","ast::parse::Primitive","error::Formatter","ast::parse::ClassState","ast::parse::GroupState","ast::SetFlags","ast::SpecialLiteralKind","ast::Comment","hir::translate::Flags","ast::Position"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::fmt(p0, p1);
-----------------
src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::new
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::new":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::new":{"P":["std::path::PathBuf","std::borrow::Cow<'a, B>","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::ffi::CString","std::vec::Vec<T, A>","std::string::String","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+ast::parse::NestLimiter::<'p, 's, P>::new(p0);
+crate::ast::parse::NestLimiter::<'p, 's, P>::new(p0);
+<ast::parse::NestLimiter<'p, 's, P>>::new(p0);
-----------------
src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::check
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::check":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::check":{"P":["std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::OsString","std::borrow::Cow<'a, B>","std::string::String","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::path::PathBuf","std::boxed::Box<T, A>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.check(p1);
+ast::parse::NestLimiter::<'p, 's, P>::check(p0, p1);
+crate::ast::parse::NestLimiter::<'p, 's, P>::check(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::check(p0, p1);
-----------------
src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::increment_depth
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":{"P":["std::ffi::OsString","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::vec::Vec<T, A>","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::path::PathBuf"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.increment_depth(p1);
+ast::parse::NestLimiter::<'p, 's, P>::increment_depth(p0, p1);
+crate::ast::parse::NestLimiter::<'p, 's, P>::increment_depth(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::increment_depth(p0, p1);
-----------------
src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::decrement_depth
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":{"P":["std::ffi::CString","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::path::PathBuf","std::borrow::Cow<'a, B>","std::ffi::OsString","std::boxed::Box<T, A>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
+p0.decrement_depth();
+ast::parse::NestLimiter::<'p, 's, P>::decrement_depth(p0);
+crate::ast::parse::NestLimiter::<'p, 's, P>::decrement_depth(p0);
+<ast::parse::NestLimiter<'p, 's, P>>::decrement_depth(p0);
-----------------
src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":{"P":["std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::ffi::OsString","std::rc::Rc<T>","std::string::String","std::path::PathBuf","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
+p0.finish();
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish(p0);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish(p0);
+<ast::parse::NestLimiter<'p, 's, P>>::finish(p0);
-----------------
src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":{"P":["<T as std::borrow::Borrow<T>>","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::rc::Rc<T>","std::path::PathBuf","std::ffi::OsString","std::string::String","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::ffi::CString","std::borrow::Cow<'a, B>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_pre(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":{"P":["<&mut T as std::borrow::Borrow<T>>","<T as std::borrow::Borrow<T>>","std::string::String","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::ffi::OsString","std::borrow::Cow<'a, B>","std::path::PathBuf","std::sync::Arc<T>","std::rc::Rc<T>","std::ffi::CString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_post(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":{"P":["std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::rc::Rc<T>","std::ffi::CString","std::vec::Vec<T, A>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_item_pre(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":{"P":["<&mut T as std::borrow::Borrow<T>>","std::string::String","std::ffi::CString","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::path::PathBuf"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_item_post(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":{"P":["std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::CString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::OsString","std::string::String","std::boxed::Box<T, A>","std::path::PathBuf","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_pre(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_binary_op_pre(p0, p1);
-----------------
src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":{"P":["<&mut T as std::borrow::Borrow<T>>","std::string::String","std::vec::Vec<T, A>","std::path::PathBuf","std::ffi::OsString","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::ffi::CString","std::sync::Arc<T>","std::rc::Rc<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_post(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_binary_op_post(p0, p1);
-----------------
src/ast/print.rs <ast::print::PrinterBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::PrinterBuilder
+p0.clone();
+<ast::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+crate::<ast::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+<ast::print::PrinterBuilder>::clone(p0);
-----------------
src/ast/print.rs <ast::print::PrinterBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::PrinterBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+<ast::print::PrinterBuilder>::fmt(p0, p1);
-----------------
src/ast/print.rs <ast::print::PrinterBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<ast::print::PrinterBuilder as std::default::Default>::default();
+crate::<ast::print::PrinterBuilder as std::default::Default>::default();
+<ast::print::PrinterBuilder>::default();
-----------------
src/ast/print.rs ast::print::PrinterBuilder::new
deps:{}
candidates:{}
+ast::print::PrinterBuilder::new();
+crate::ast::print::PrinterBuilder::new();
+<ast::print::PrinterBuilder>::new();
-----------------
src/ast/print.rs ast::print::PrinterBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::PrinterBuilder
+p0.build();
+ast::print::PrinterBuilder::build(p0);
+crate::ast::print::PrinterBuilder::build(p0);
+<ast::print::PrinterBuilder>::build(p0);
-----------------
src/ast/print.rs <ast::print::Printer as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::Printer
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+<ast::print::Printer>::fmt(p0, p1);
-----------------
src/ast/print.rs ast::print::Printer::new
deps:{}
candidates:{}
+ast::print::Printer::new();
+crate::ast::print::Printer::new();
+<ast::print::Printer>::new();
-----------------
src/ast/print.rs ast::print::Printer::print
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Printer::print":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Printer::print":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>","std::ffi::OsString","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Printer
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p2 = MaybeUninit::uninit().assume_init(); // W
+p0.print(p1, p2);
+ast::print::Printer::print(p0, p1, p2);
+crate::ast::print::Printer::print(p0, p1, p2);
+<ast::print::Printer>::print(p0, p1, p2);
-----------------
src/ast/print.rs <ast::print::Writer<W> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::print::Writer<W> as std::fmt::Debug>::fmt":{"W":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"either::Either":{"Left":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"],"Right":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::fmt::Debug","hir::interval::Interval","std::clone::Clone","std::marker::Sized"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::print::Writer<W> as std::fmt::Debug>::fmt":{"W":["utf8::Utf8Sequences","unicode::Error","hir::Literal","ast::Class","ast::Concat","ast::Comment","ast::parse::ClassState","ast::Literal","<*mut T as std::fmt::Debug>","hir::translate::HirFrame","unicode::ClassQuery","hir::literal::Literal","ast::ClassUnicodeKind","ast::ClassSetRange","hir::print::Writer","ast::visitor::ClassInduct","hir::literal::Seq","hir::ClassUnicodeRange","hir::print::Printer","hir::literal::ExtractKind","hir::ClassBytes","ast::Span","error::Formatter","ast::ClassAsciiKind","hir::ErrorKind","hir::print::PrinterBuilder","hir::translate::Translator","hir::PropertiesI","ast::Error","hir::interval::IntervalSetIter","utf8::ScalarRange","ast::WithComments","unicode::CaseFoldError","<*const T as std::fmt::Debug>","hir::interval::IntervalSet","hir::ClassBytesRange","ast::ClassSetUnion","hir::Properties","error::Error","hir::Hir","ast::print::Writer","debug::Byte","ast::ClassPerlKind","ast::Group","ast::parse::GroupState","ast::Ast","ast::print::PrinterBuilder","debug::Bytes","ast::Assertion","ast::ClassSetItem","parser::ParserBuilder","hir::Look","ast::ErrorKind","ast::FlagsItem","ast::ClassSet","hir::Class","ast::Alternation","unicode::UnicodeWordError","hir::ClassBytesIter","hir::ClassUnicodeIter","ast::AssertionKind","ast::parse::ParserBuilder","ast::ClassUnicode","ast::parse::Parser","ast::Flag","unicode::SimpleCaseFolder","hir::LookSet","ast::FlagsItemKind","ast::GroupKind","ast::visitor::ClassFrame","ast::print::Printer","ast::ClassUnicodeOpKind","ast::ClassAscii","ast::ClassSetBinaryOpKind","ast::parse::ParserI","ast::Repetition","unicode::CanonicalClassQuery","ast::HexLiteralKind","either::Either","utf8::Utf8Sequence","ast::LiteralKind","hir::translate::Flags","ast::CaptureName","hir::translate::TranslatorBuilder","hir::literal::PreferenceTrie","ast::Flags","hir::translate::TranslatorI","hir::LookSetIter","hir::Repetition","ast::ClassBracketed","hir::literal::State","ast::ClassSetBinaryOp","ast::Position","hir::literal::Extractor","ast::SpecialLiteralKind","utf8::Utf8Range","ast::RepetitionRange","ast::parse::NestLimiter","ast::RepetitionKind","ast::ClassPerl","hir::Capture","ast::SetFlags","ast::RepetitionOp","hir::Dot","ast::parse::Primitive","hir::Error","parser::Parser","hir::ClassUnicode","hir::HirKind"]},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::string::String","std::boxed::Box<T, A>","std::ffi::CString","std::sync::Arc<T>","std::rc::Rc<T>","std::path::PathBuf","<&T as std::fmt::Debug>","std::vec::Vec<T, A>"]},"ast::parse::ParserI":{"P":["std::ffi::CString","std::sync::Arc<T>","std::boxed::Box<T, A>","std::clone::impls::<impl std::clone::Clone for &T>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::string::String","std::ffi::OsString","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["hir::ClassBytesRange","hir::interval::IntervalSet","hir::literal::Literal","ast::ClassSetBinaryOpKind","error::Error","hir::ErrorKind","ast::Comment","ast::Error","ast::FlagsItemKind","ast::ClassUnicodeKind","ast::Ast","hir::HirKind","ast::ClassPerl","ast::HexLiteralKind","hir::Class","hir::Hir","ast::ClassAsciiKind","ast::ClassSetRange","ast::Alternation","ast::RepetitionRange","hir::ClassBytes","ast::FlagsItem","hir::LookSet","ast::ClassBracketed","ast::SetFlags","ast::ClassSetItem","ast::Flag","hir::Repetition","ast::ClassUnicode","hir::Literal","ast::Group","ast::ClassUnicodeOpKind","hir::literal::Seq","ast::Assertion","ast::Concat","either::Either","ast::parse::Primitive","hir::Look","ast::Span","ast::Repetition","ast::Literal","ast::LiteralKind","utf8::Utf8Sequence","hir::Capture","hir::Properties","ast::ClassAscii","ast::Class","ast::CaptureName","hir::ClassUnicodeRange","hir::Dot","ast::Position","ast::ClassPerlKind","utf8::Utf8Range","ast::Flags","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","hir::Error","ast::WithComments","hir::PropertiesI","ast::RepetitionKind","ast::RepetitionOp","ast::AssertionKind","ast::GroupKind","ast::ClassSet","ast::ClassSetUnion","ast::SpecialLiteralKind","ast::ErrorKind","hir::ClassUnicode","ast::ClassSetBinaryOp"],"Right":["hir::HirKind","hir::Properties","hir::ErrorKind","hir::ClassBytesRange","ast::ClassSetBinaryOpKind","hir::literal::Literal","hir::Error","ast::RepetitionOp","hir::Class","ast::ClassUnicode","ast::Literal","hir::Repetition","ast::ClassBracketed","ast::ClassSetBinaryOp","ast::Repetition","ast::LiteralKind","utf8::Utf8Sequence","ast::ClassSetItem","either::Either","ast::SetFlags","ast::SpecialLiteralKind","ast::ClassSetUnion","ast::AssertionKind","hir::PropertiesI","ast::ClassAscii","ast::Class","ast::ClassPerlKind","ast::Span","hir::Hir","ast::Flag","std::clone::impls::<impl std::clone::Clone for *const T>","hir::ClassUnicodeRange","ast::ClassUnicodeOpKind","hir::Literal","hir::ClassUnicode","hir::ClassBytes","ast::parse::Primitive","ast::HexLiteralKind","ast::Concat","error::Error","ast::Group","hir::interval::IntervalSet","hir::literal::Seq","ast::ClassSetRange","ast::Position","ast::ClassAsciiKind","hir::LookSet","hir::Capture","ast::RepetitionRange","ast::CaptureName","ast::ClassPerl","ast::Ast","ast::Alternation","ast::ClassSet","ast::Flags","ast::ErrorKind","ast::RepetitionKind","utf8::Utf8Range","hir::Dot","ast::GroupKind","ast::Comment","hir::Look","ast::FlagsItem","ast::FlagsItemKind","ast::Error","ast::ClassUnicodeKind","ast::Assertion","ast::WithComments"]},"error::Formatter":{"E":["ast::Error","hir::Hir","hir::ErrorKind","unicode::UnicodeWordError","<&mut T as std::fmt::Display>","error::Error","unicode::CaseFoldError","error::Formatter","hir::Error","ast::Ast","ast::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::parse::Parser","ast::ClassPerlKind","ast::ErrorKind","ast::parse::GroupState","ast::Error","ast::Class","unicode::UnicodeWordError","ast::CaptureName","debug::Byte","hir::translate::Translator","ast::ClassBracketed","ast::Ast","ast::FlagsItem","hir::literal::State","ast::ClassSetUnion","hir::PropertiesI","ast::ClassSetItem","ast::parse::ClassState","ast::LiteralKind","hir::literal::PreferenceTrie","hir::translate::TranslatorBuilder","hir::ClassBytesRange","hir::LookSetIter","ast::parse::ParserI","ast::Repetition","ast::Literal","ast::SetFlags","hir::interval::IntervalSetIter","ast::FlagsItemKind","hir::print::Writer","hir::translate::Flags","parser::ParserBuilder","parser::Parser","ast::visitor::ClassInduct","unicode::Error","hir::literal::Extractor","hir::Properties","hir::Look","ast::HexLiteralKind","ast::Concat","ast::parse::Primitive","ast::print::Printer","utf8::ScalarRange","ast::ClassSet","ast::RepetitionOp","hir::ClassUnicodeRange","ast::print::Writer","ast::ClassUnicodeOpKind","debug::Bytes","utf8::Utf8Range","unicode::ClassQuery","ast::RepetitionKind","ast::AssertionKind","unicode::SimpleCaseFolder","ast::SpecialLiteralKind","ast::ClassUnicodeKind","hir::literal::Literal","hir::HirKind","unicode::CanonicalClassQuery","hir::Capture","ast::WithComments","ast::ClassSetBinaryOpKind","hir::print::Printer","hir::translate::TranslatorI","ast::visitor::ClassFrame","ast::ClassUnicode","hir::interval::IntervalSet","hir::literal::Seq","hir::LookSet","ast::parse::ParserBuilder","ast::Flag","hir::ClassUnicode","hir::Repetition","hir::Class","hir::ErrorKind","hir::Dot","hir::Error","ast::Span","utf8::Utf8Sequence","hir::ClassBytesIter","ast::ClassAscii","error::Error","ast::print::PrinterBuilder","either::Either","ast::ClassPerl","hir::ClassUnicodeIter","ast::Comment","ast::GroupKind","hir::literal::ExtractKind","ast::Assertion","ast::Flags","unicode::CaseFoldError","ast::RepetitionRange","ast::ClassAsciiKind","ast::parse::NestLimiter","ast::Group","ast::Alternation","ast::ClassSetBinaryOp","hir::Hir","hir::Literal","utf8::Utf8Sequences","ast::ClassSetRange","hir::ClassBytes","ast::Position","error::Formatter","hir::translate::HirFrame","hir::print::PrinterBuilder","<&mut T as std::fmt::Debug>"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::print::Writer<W> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::print::Writer<W> as std::fmt::Debug>::fmt(p0, p1);
+<ast::print::Writer<W>>::fmt(p0, p1);
-----------------
src/ast/print.rs <ast::print::Writer<W> as ast::visitor::Visitor>::finish
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::finish":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::finish":{"W":["std::error::Indented<'_, T>","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::string::String","<&mut W as std::fmt::Write>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
+p0.finish();
+<ast::print::Writer<W> as ast::visitor::Visitor>::finish(p0);
+crate::<ast::print::Writer<W> as ast::visitor::Visitor>::finish(p0);
+<ast::print::Writer<W>>::finish(p0);
-----------------
src/ast/print.rs <ast::print::Writer<W> as ast::visitor::Visitor>::visit_pre
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_pre":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_pre":{"W":["<&mut W as std::fmt::Write>","std::string::String","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+<ast::print::Writer<W> as ast::visitor::Visitor>::visit_pre(p0, p1);
+crate::<ast::print::Writer<W> as ast::visitor::Visitor>::visit_pre(p0, p1);
+<ast::print::Writer<W>>::visit_pre(p0, p1);
-----------------
src/ast/print.rs <ast::print::Writer<W> as ast::visitor::Visitor>::visit_post
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_post":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_post":{"W":["std::ffi::OsString","std::string::String","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+<ast::print::Writer<W> as ast::visitor::Visitor>::visit_post(p0, p1);
+crate::<ast::print::Writer<W> as ast::visitor::Visitor>::visit_post(p0, p1);
+<ast::print::Writer<W>>::visit_post(p0, p1);
-----------------
src/ast/print.rs <ast::print::Writer<W> as ast::visitor::Visitor>::visit_alternation_in
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_alternation_in":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_alternation_in":{"W":["std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","std::ffi::OsString","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
+p0.visit_alternation_in();
+<ast::print::Writer<W> as ast::visitor::Visitor>::visit_alternation_in(p0);
+crate::<ast::print::Writer<W> as ast::visitor::Visitor>::visit_alternation_in(p0);
+<ast::print::Writer<W>>::visit_alternation_in(p0);
-----------------
src/ast/print.rs <ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_pre
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_pre":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_pre":{"W":["<&mut W as std::fmt::Write>","std::ffi::OsString","std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+crate::<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+<ast::print::Writer<W>>::visit_class_set_item_pre(p0, p1);
-----------------
src/ast/print.rs <ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_post
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_post":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_post":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>","std::string::String","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::error::Indented<'_, T>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+crate::<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+<ast::print::Writer<W>>::visit_class_set_item_post(p0, p1);
-----------------
src/ast/print.rs <ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_binary_op_in
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":{"W":["core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","std::string::String","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_in(p1);
+<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+crate::<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+<ast::print::Writer<W>>::visit_class_set_binary_op_in(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_group_pre
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_group_pre":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_group_pre":{"W":["<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>","std::error::Indented<'_, T>","std::string::String","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.fmt_group_pre(p1);
+ast::print::Writer::<W>::fmt_group_pre(p0, p1);
+crate::ast::print::Writer::<W>::fmt_group_pre(p0, p1);
+<ast::print::Writer<W>>::fmt_group_pre(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_group_post
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_group_post":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_group_post":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::error::Indented<'_, T>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.fmt_group_post(p1);
+ast::print::Writer::<W>::fmt_group_post(p0, p1);
+crate::ast::print::Writer::<W>::fmt_group_post(p0, p1);
+<ast::print::Writer<W>>::fmt_group_post(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_repetition
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_repetition":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_repetition":{"W":["std::string::String","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::ffi::OsString","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.fmt_repetition(p1);
+ast::print::Writer::<W>::fmt_repetition(p0, p1);
+crate::ast::print::Writer::<W>::fmt_repetition(p0, p1);
+<ast::print::Writer<W>>::fmt_repetition(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_repetition_range
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_repetition_range":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_repetition_range":{"W":["std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.fmt_repetition_range(p1);
+ast::print::Writer::<W>::fmt_repetition_range(p0, p1);
+crate::ast::print::Writer::<W>::fmt_repetition_range(p0, p1);
+<ast::print::Writer<W>>::fmt_repetition_range(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_literal
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_literal":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_literal":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>","std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.fmt_literal(p1);
+ast::print::Writer::<W>::fmt_literal(p0, p1);
+crate::ast::print::Writer::<W>::fmt_literal(p0, p1);
+<ast::print::Writer<W>>::fmt_literal(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_assertion
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_assertion":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_assertion":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.fmt_assertion(p1);
+ast::print::Writer::<W>::fmt_assertion(p0, p1);
+crate::ast::print::Writer::<W>::fmt_assertion(p0, p1);
+<ast::print::Writer<W>>::fmt_assertion(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_set_flags
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_set_flags":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_set_flags":{"W":["std::ffi::OsString","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.fmt_set_flags(p1);
+ast::print::Writer::<W>::fmt_set_flags(p0, p1);
+crate::ast::print::Writer::<W>::fmt_set_flags(p0, p1);
+<ast::print::Writer<W>>::fmt_set_flags(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_flags
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_flags":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_flags":{"W":["std::ffi::OsString","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.fmt_flags(p1);
+ast::print::Writer::<W>::fmt_flags(p0, p1);
+crate::ast::print::Writer::<W>::fmt_flags(p0, p1);
+<ast::print::Writer<W>>::fmt_flags(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_class_bracketed_pre
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_bracketed_pre":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_bracketed_pre":{"W":["core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::fmt::Formatter<'_>","std::ffi::OsString","std::string::String","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.fmt_class_bracketed_pre(p1);
+ast::print::Writer::<W>::fmt_class_bracketed_pre(p0, p1);
+crate::ast::print::Writer::<W>::fmt_class_bracketed_pre(p0, p1);
+<ast::print::Writer<W>>::fmt_class_bracketed_pre(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_class_bracketed_post
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_bracketed_post":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_bracketed_post":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.fmt_class_bracketed_post(p1);
+ast::print::Writer::<W>::fmt_class_bracketed_post(p0, p1);
+crate::ast::print::Writer::<W>::fmt_class_bracketed_post(p0, p1);
+<ast::print::Writer<W>>::fmt_class_bracketed_post(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_class_set_binary_op_kind
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_set_binary_op_kind":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_set_binary_op_kind":{"W":["std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.fmt_class_set_binary_op_kind(p1);
+ast::print::Writer::<W>::fmt_class_set_binary_op_kind(p0, p1);
+crate::ast::print::Writer::<W>::fmt_class_set_binary_op_kind(p0, p1);
+<ast::print::Writer<W>>::fmt_class_set_binary_op_kind(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_class_perl
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_perl":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_perl":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::string::String","std::error::Indented<'_, T>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.fmt_class_perl(p1);
+ast::print::Writer::<W>::fmt_class_perl(p0, p1);
+crate::ast::print::Writer::<W>::fmt_class_perl(p0, p1);
+<ast::print::Writer<W>>::fmt_class_perl(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_class_ascii
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_ascii":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_ascii":{"W":["core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.fmt_class_ascii(p1);
+ast::print::Writer::<W>::fmt_class_ascii(p0, p1);
+crate::ast::print::Writer::<W>::fmt_class_ascii(p0, p1);
+<ast::print::Writer<W>>::fmt_class_ascii(p0, p1);
-----------------
src/ast/print.rs ast::print::Writer::<W>::fmt_class_unicode
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_unicode":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<W>::fmt_class_unicode":{"W":["<&mut W as std::fmt::Write>","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.fmt_class_unicode(p1);
+ast::print::Writer::<W>::fmt_class_unicode(p0, p1);
+crate::ast::print::Writer::<W>::fmt_class_unicode(p0, p1);
+<ast::print::Writer<W>>::fmt_class_unicode(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::new
'a
deps:{}
candidates:{}
+ast::visitor::HeapVisitor::<'a>::new();
+crate::ast::visitor::HeapVisitor::<'a>::new();
+<ast::visitor::HeapVisitor<'a>>::new();
-----------------
src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::HeapVisitor::<'a>::visit":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::OsString","std::vec::Vec<T, A>","std::rc::Rc<T>","std::ffi::CString","<&T as std::fmt::Debug>","std::string::String"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::HeapVisitor::<'a>::visit":{"V":["hir::translate::TranslatorI","ast::print::Writer","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.visit(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit(p0, p1, p2);
-----------------
src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::induct
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::HeapVisitor::<'a>::induct":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::rc::Rc<T>","std::ffi::OsString","std::boxed::Box<T, A>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::string::String","std::sync::Arc<T>","std::ffi::CString","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::HeapVisitor::<'a>::induct":{"V":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.induct(p1, p2);
+ast::visitor::HeapVisitor::<'a>::induct(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::induct(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::induct(p0, p1, p2);
-----------------
src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::pop
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::visitor::Frame<'a>
+p0.pop(p1);
+ast::visitor::HeapVisitor::<'a>::pop(p0, p1);
+crate::ast::visitor::HeapVisitor::<'a>::pop(p0, p1);
+<ast::visitor::HeapVisitor<'a>>::pop(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit_class
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::HeapVisitor::<'a>::visit_class":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::rc::Rc<T>","std::boxed::Box<T, A>","std::ffi::CString","<&T as std::fmt::Debug>","std::string::String","std::vec::Vec<T, A>","std::ffi::OsString","std::sync::Arc<T>","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::HeapVisitor::<'a>::visit_class":{"V":["hir::translate::TranslatorI","ast::parse::NestLimiter","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.visit_class(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit_class(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit_class(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit_class(p0, p1, p2);
-----------------
src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit_class_pre
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::HeapVisitor::<'a>::visit_class_pre":{"V":["ast::visitor::Visitor","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::sync::Arc<T>","std::vec::Vec<T, A>","std::path::PathBuf","std::ffi::OsString","std::rc::Rc<T>","std::boxed::Box<T, A>","<&T as std::fmt::Debug>","std::string::String","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::HeapVisitor::<'a>::visit_class_pre":{"V":["hir::translate::TranslatorI","ast::print::Writer","ast::parse::NestLimiter"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.visit_class_pre(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit_class_pre(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit_class_pre(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit_class_pre(p0, p1, p2);
-----------------
src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit_class_post
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::HeapVisitor::<'a>::visit_class_post":{"V":["ast::visitor::Visitor","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::sync::Arc<T>","std::string::String","std::vec::Vec<T, A>","std::rc::Rc<T>","std::ffi::OsString","std::boxed::Box<T, A>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::HeapVisitor::<'a>::visit_class_post":{"V":["ast::parse::NestLimiter","ast::print::Writer","hir::translate::TranslatorI"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.visit_class_post(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit_class_post(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit_class_post(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit_class_post(p0, p1, p2);
-----------------
src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::induct_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
+p0.induct_class(p1);
+ast::visitor::HeapVisitor::<'a>::induct_class(p0, p1);
+crate::ast::visitor::HeapVisitor::<'a>::induct_class(p0, p1);
+<ast::visitor::HeapVisitor<'a>>::induct_class(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::pop_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::visitor::ClassFrame<'a>
+p0.pop_class(p1);
+ast::visitor::HeapVisitor::<'a>::pop_class(p0, p1);
+crate::ast::visitor::HeapVisitor::<'a>::pop_class(p0, p1);
+<ast::visitor::HeapVisitor<'a>>::pop_class(p0, p1);
-----------------
src/ast/visitor.rs ast::visitor::Frame::<'a>::child
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::Frame<'a>
+p0.child();
+ast::visitor::Frame::<'a>::child(p0);
+crate::ast::visitor::Frame::<'a>::child(p0);
+<ast::visitor::Frame<'a>>::child(p0);
-----------------
src/ast/visitor.rs ast::visitor::ClassFrame::<'a>::child
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassFrame<'a>
+p0.child();
+ast::visitor::ClassFrame::<'a>::child(p0);
+crate::ast::visitor::ClassFrame::<'a>::child(p0);
+<ast::visitor::ClassFrame<'a>>::child(p0);
-----------------
src/ast/visitor.rs ast::visitor::ClassInduct::<'a>::from_bracketed
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+ast::visitor::ClassInduct::<'a>::from_bracketed(p0);
+crate::ast::visitor::ClassInduct::<'a>::from_bracketed(p0);
+<ast::visitor::ClassInduct<'a>>::from_bracketed(p0);
-----------------
src/ast/visitor.rs ast::visitor::ClassInduct::<'a>::from_set
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+ast::visitor::ClassInduct::<'a>::from_set(p0);
+crate::ast::visitor::ClassInduct::<'a>::from_set(p0);
+<ast::visitor::ClassInduct<'a>>::from_set(p0);
-----------------
src/ast/visitor.rs <ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassFrame<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt(p0, p1);
+<ast::visitor::ClassFrame<'a>>::fmt(p0, p1);
-----------------
src/ast/visitor.rs <ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt(p0, p1);
+<ast::visitor::ClassInduct<'a>>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.clone();
+<ast::Error as std::clone::Clone>::clone(p0);
+crate::<ast::Error as std::clone::Clone>::clone(p0);
+<ast::Error>::clone(p0);
-----------------
src/ast/mod.rs <ast::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Error as std::fmt::Debug>::fmt(p0, p1);
+<ast::Error>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.assert_receiver_is_total_eq();
+<ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Error>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.eq(p1);
+<ast::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Error as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Error>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::Error::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.kind();
+ast::Error::kind(p0);
+crate::ast::Error::kind(p0);
+<ast::Error>::kind(p0);
-----------------
src/ast/mod.rs ast::Error::pattern
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.pattern();
+ast::Error::pattern(p0);
+crate::ast::Error::pattern(p0);
+<ast::Error>::pattern(p0);
-----------------
src/ast/mod.rs ast::Error::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.span();
+ast::Error::span(p0);
+crate::ast::Error::span(p0);
+<ast::Error>::span(p0);
-----------------
src/ast/mod.rs ast::Error::auxiliary_span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.auxiliary_span();
+ast::Error::auxiliary_span(p0);
+crate::ast::Error::auxiliary_span(p0);
+<ast::Error>::auxiliary_span(p0);
-----------------
src/ast/mod.rs <ast::ErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.clone();
+<ast::ErrorKind as std::clone::Clone>::clone(p0);
+crate::<ast::ErrorKind as std::clone::Clone>::clone(p0);
+<ast::ErrorKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::ErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ErrorKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.assert_receiver_is_total_eq();
+<ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.eq(p1);
+<ast::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ErrorKind>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ast::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<ast::Error as std::fmt::Display>::fmt(p0, p1);
+<ast::Error>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ErrorKind as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ast::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+crate::<ast::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+<ast::ErrorKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Span as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.clone();
+<ast::Span as std::clone::Clone>::clone(p0);
+crate::<ast::Span as std::clone::Clone>::clone(p0);
+<ast::Span>::clone(p0);
-----------------
src/ast/mod.rs <ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.assert_receiver_is_total_eq();
+<ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Span>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Span as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.eq(p1);
+<ast::Span as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Span as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Span>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::Span as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Span as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Span as std::fmt::Debug>::fmt(p0, p1);
+<ast::Span>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Span as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.cmp(p1);
+<ast::Span as std::cmp::Ord>::cmp(p0, p1);
+crate::<ast::Span as std::cmp::Ord>::cmp(p0, p1);
+<ast::Span>::cmp(p0, p1);
-----------------
src/ast/mod.rs <ast::Span as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.partial_cmp(p1);
+<ast::Span as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<ast::Span as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<ast::Span>::partial_cmp(p0, p1);
-----------------
src/ast/mod.rs <ast::Position as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.clone();
+<ast::Position as std::clone::Clone>::clone(p0);
+crate::<ast::Position as std::clone::Clone>::clone(p0);
+<ast::Position>::clone(p0);
-----------------
src/ast/mod.rs <ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.assert_receiver_is_total_eq();
+<ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Position>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Position as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.eq(p1);
+<ast::Position as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Position as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Position>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::Position as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Position as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Position as std::fmt::Debug>::fmt(p0, p1);
+<ast::Position>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Position as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.cmp(p1);
+<ast::Position as std::cmp::Ord>::cmp(p0, p1);
+crate::<ast::Position as std::cmp::Ord>::cmp(p0, p1);
+<ast::Position>::cmp(p0, p1);
-----------------
src/ast/mod.rs <ast::Position as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.partial_cmp(p1);
+<ast::Position as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<ast::Position as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<ast::Position>::partial_cmp(p0, p1);
-----------------
src/ast/mod.rs ast::Span::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Position
+ast::Span::new(p0, p1);
+crate::ast::Span::new(p0, p1);
+<ast::Span>::new(p0, p1);
-----------------
src/ast/mod.rs ast::Span::splat
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Position
+ast::Span::splat(p0);
+crate::ast::Span::splat(p0);
+<ast::Span>::splat(p0);
-----------------
src/ast/mod.rs ast::Span::with_start
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Position
+p0.with_start(p1);
+ast::Span::with_start(p0, p1);
+crate::ast::Span::with_start(p0, p1);
+<ast::Span>::with_start(p0, p1);
-----------------
src/ast/mod.rs ast::Span::with_end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Position
+p0.with_end(p1);
+ast::Span::with_end(p0, p1);
+crate::ast::Span::with_end(p0, p1);
+<ast::Span>::with_end(p0, p1);
-----------------
src/ast/mod.rs ast::Span::is_one_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.is_one_line();
+ast::Span::is_one_line(p0);
+crate::ast::Span::is_one_line(p0);
+<ast::Span>::is_one_line(p0);
-----------------
src/ast/mod.rs ast::Span::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.is_empty();
+ast::Span::is_empty(p0);
+crate::ast::Span::is_empty(p0);
+<ast::Span>::is_empty(p0);
-----------------
src/ast/mod.rs ast::Position::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+ast::Position::new(p0, p1, p2);
+crate::ast::Position::new(p0, p1, p2);
+<ast::Position>::new(p0, p1, p2);
-----------------
src/ast/mod.rs <ast::WithComments as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
+p0.clone();
+<ast::WithComments as std::clone::Clone>::clone(p0);
+crate::<ast::WithComments as std::clone::Clone>::clone(p0);
+<ast::WithComments>::clone(p0);
-----------------
src/ast/mod.rs <ast::WithComments as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::WithComments as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::WithComments as std::fmt::Debug>::fmt(p0, p1);
+<ast::WithComments>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
+p0.assert_receiver_is_total_eq();
+<ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::WithComments>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::WithComments as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
+p0.eq(p1);
+<ast::WithComments as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::WithComments as std::cmp::PartialEq>::eq(p0, p1);
+<ast::WithComments>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::Comment as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
+p0.clone();
+<ast::Comment as std::clone::Clone>::clone(p0);
+crate::<ast::Comment as std::clone::Clone>::clone(p0);
+<ast::Comment>::clone(p0);
-----------------
src/ast/mod.rs <ast::Comment as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Comment as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Comment as std::fmt::Debug>::fmt(p0, p1);
+<ast::Comment>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
+p0.assert_receiver_is_total_eq();
+<ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Comment>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Comment as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Comment
+p0.eq(p1);
+<ast::Comment as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Comment as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Comment>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::Ast as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.clone();
+<ast::Ast as std::clone::Clone>::clone(p0);
+crate::<ast::Ast as std::clone::Clone>::clone(p0);
+<ast::Ast>::clone(p0);
-----------------
src/ast/mod.rs <ast::Ast as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Ast as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Ast as std::fmt::Debug>::fmt(p0, p1);
+<ast::Ast>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.assert_receiver_is_total_eq();
+<ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Ast>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Ast as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.eq(p1);
+<ast::Ast as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Ast as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Ast>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::Ast::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.span();
+ast::Ast::span(p0);
+crate::ast::Ast::span(p0);
+<ast::Ast>::span(p0);
-----------------
src/ast/mod.rs ast::Ast::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.is_empty();
+ast::Ast::is_empty(p0);
+crate::ast::Ast::is_empty(p0);
+<ast::Ast>::is_empty(p0);
-----------------
src/ast/mod.rs ast::Ast::has_subexprs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.has_subexprs();
+ast::Ast::has_subexprs(p0);
+crate::ast::Ast::has_subexprs(p0);
+<ast::Ast>::has_subexprs(p0);
-----------------
src/ast/mod.rs <ast::Ast as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ast::Ast as std::fmt::Display>::fmt(p0, p1);
+crate::<ast::Ast as std::fmt::Display>::fmt(p0, p1);
+<ast::Ast>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Alternation as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.clone();
+<ast::Alternation as std::clone::Clone>::clone(p0);
+crate::<ast::Alternation as std::clone::Clone>::clone(p0);
+<ast::Alternation>::clone(p0);
-----------------
src/ast/mod.rs <ast::Alternation as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Alternation as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Alternation as std::fmt::Debug>::fmt(p0, p1);
+<ast::Alternation>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.assert_receiver_is_total_eq();
+<ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Alternation>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Alternation as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.eq(p1);
+<ast::Alternation as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Alternation as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Alternation>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::Alternation::into_ast
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.into_ast();
+ast::Alternation::into_ast(p0);
+crate::ast::Alternation::into_ast(p0);
+<ast::Alternation>::into_ast(p0);
-----------------
src/ast/mod.rs <ast::Concat as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.clone();
+<ast::Concat as std::clone::Clone>::clone(p0);
+crate::<ast::Concat as std::clone::Clone>::clone(p0);
+<ast::Concat>::clone(p0);
-----------------
src/ast/mod.rs <ast::Concat as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Concat as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Concat as std::fmt::Debug>::fmt(p0, p1);
+<ast::Concat>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.assert_receiver_is_total_eq();
+<ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Concat>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Concat as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.eq(p1);
+<ast::Concat as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Concat as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Concat>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::Concat::into_ast
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.into_ast();
+ast::Concat::into_ast(p0);
+crate::ast::Concat::into_ast(p0);
+<ast::Concat>::into_ast(p0);
-----------------
src/ast/mod.rs <ast::Literal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.clone();
+<ast::Literal as std::clone::Clone>::clone(p0);
+crate::<ast::Literal as std::clone::Clone>::clone(p0);
+<ast::Literal>::clone(p0);
-----------------
src/ast/mod.rs <ast::Literal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Literal as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Literal as std::fmt::Debug>::fmt(p0, p1);
+<ast::Literal>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.assert_receiver_is_total_eq();
+<ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Literal>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Literal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.eq(p1);
+<ast::Literal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Literal as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Literal>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::Literal::byte
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.byte();
+ast::Literal::byte(p0);
+crate::ast::Literal::byte(p0);
+<ast::Literal>::byte(p0);
-----------------
src/ast/mod.rs <ast::LiteralKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
+p0.clone();
+<ast::LiteralKind as std::clone::Clone>::clone(p0);
+crate::<ast::LiteralKind as std::clone::Clone>::clone(p0);
+<ast::LiteralKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::LiteralKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::LiteralKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::LiteralKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::LiteralKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
+p0.assert_receiver_is_total_eq();
+<ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::LiteralKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::LiteralKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
+p0.eq(p1);
+<ast::LiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::LiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::LiteralKind>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::SpecialLiteralKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
+p0.clone();
+<ast::SpecialLiteralKind as std::clone::Clone>::clone(p0);
+crate::<ast::SpecialLiteralKind as std::clone::Clone>::clone(p0);
+<ast::SpecialLiteralKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::SpecialLiteralKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::SpecialLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::SpecialLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::SpecialLiteralKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
+p0.assert_receiver_is_total_eq();
+<ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::SpecialLiteralKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::SpecialLiteralKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
+p0.eq(p1);
+<ast::SpecialLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::SpecialLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::SpecialLiteralKind>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::HexLiteralKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.clone();
+<ast::HexLiteralKind as std::clone::Clone>::clone(p0);
+crate::<ast::HexLiteralKind as std::clone::Clone>::clone(p0);
+<ast::HexLiteralKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::HexLiteralKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::HexLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::HexLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::HexLiteralKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.assert_receiver_is_total_eq();
+<ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::HexLiteralKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::HexLiteralKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.eq(p1);
+<ast::HexLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::HexLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::HexLiteralKind>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::HexLiteralKind::digits
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.digits();
+ast::HexLiteralKind::digits(p0);
+crate::ast::HexLiteralKind::digits(p0);
+<ast::HexLiteralKind>::digits(p0);
-----------------
src/ast/mod.rs <ast::Class as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.clone();
+<ast::Class as std::clone::Clone>::clone(p0);
+crate::<ast::Class as std::clone::Clone>::clone(p0);
+<ast::Class>::clone(p0);
-----------------
src/ast/mod.rs <ast::Class as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Class as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Class as std::fmt::Debug>::fmt(p0, p1);
+<ast::Class>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.assert_receiver_is_total_eq();
+<ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Class>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Class as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.eq(p1);
+<ast::Class as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Class as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Class>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::Class::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.span();
+ast::Class::span(p0);
+crate::ast::Class::span(p0);
+<ast::Class>::span(p0);
-----------------
src/ast/mod.rs <ast::ClassPerl as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.clone();
+<ast::ClassPerl as std::clone::Clone>::clone(p0);
+crate::<ast::ClassPerl as std::clone::Clone>::clone(p0);
+<ast::ClassPerl>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassPerl as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassPerl as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassPerl as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassPerl>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.assert_receiver_is_total_eq();
+<ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassPerl>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassPerl as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.eq(p1);
+<ast::ClassPerl as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassPerl as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassPerl>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassPerlKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
+p0.clone();
+<ast::ClassPerlKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassPerlKind as std::clone::Clone>::clone(p0);
+<ast::ClassPerlKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassPerlKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassPerlKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassPerlKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassPerlKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassPerlKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassPerlKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
+p0.eq(p1);
+<ast::ClassPerlKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassPerlKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassPerlKind>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassAscii as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.clone();
+<ast::ClassAscii as std::clone::Clone>::clone(p0);
+crate::<ast::ClassAscii as std::clone::Clone>::clone(p0);
+<ast::ClassAscii>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassAscii as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassAscii as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassAscii as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassAscii>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.assert_receiver_is_total_eq();
+<ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassAscii>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassAscii as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.eq(p1);
+<ast::ClassAscii as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassAscii as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassAscii>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassAsciiKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+p0.clone();
+<ast::ClassAsciiKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassAsciiKind as std::clone::Clone>::clone(p0);
+<ast::ClassAsciiKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassAsciiKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassAsciiKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassAsciiKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassAsciiKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassAsciiKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassAsciiKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+p0.eq(p1);
+<ast::ClassAsciiKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassAsciiKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassAsciiKind>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::ClassAsciiKind::from_name
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+ast::ClassAsciiKind::from_name(&p0);
+crate::ast::ClassAsciiKind::from_name(&p0);
+<ast::ClassAsciiKind>::from_name(&p0);
-----------------
src/ast/mod.rs <ast::ClassUnicode as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.clone();
+<ast::ClassUnicode as std::clone::Clone>::clone(p0);
+crate::<ast::ClassUnicode as std::clone::Clone>::clone(p0);
+<ast::ClassUnicode>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassUnicode as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassUnicode>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.assert_receiver_is_total_eq();
+<ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassUnicode>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassUnicode as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.eq(p1);
+<ast::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassUnicode>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::ClassUnicode::is_negated
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.is_negated();
+ast::ClassUnicode::is_negated(p0);
+crate::ast::ClassUnicode::is_negated(p0);
+<ast::ClassUnicode>::is_negated(p0);
-----------------
src/ast/mod.rs <ast::ClassUnicodeKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
+p0.clone();
+<ast::ClassUnicodeKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassUnicodeKind as std::clone::Clone>::clone(p0);
+<ast::ClassUnicodeKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassUnicodeKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassUnicodeKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassUnicodeKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassUnicodeKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassUnicodeKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassUnicodeKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
+p0.eq(p1);
+<ast::ClassUnicodeKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassUnicodeKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassUnicodeKind>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassUnicodeOpKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.clone();
+<ast::ClassUnicodeOpKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassUnicodeOpKind as std::clone::Clone>::clone(p0);
+<ast::ClassUnicodeOpKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassUnicodeOpKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassUnicodeOpKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.eq(p1);
+<ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassUnicodeOpKind>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::ClassUnicodeOpKind::is_equal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.is_equal();
+ast::ClassUnicodeOpKind::is_equal(p0);
+crate::ast::ClassUnicodeOpKind::is_equal(p0);
+<ast::ClassUnicodeOpKind>::is_equal(p0);
-----------------
src/ast/mod.rs <ast::ClassBracketed as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.clone();
+<ast::ClassBracketed as std::clone::Clone>::clone(p0);
+crate::<ast::ClassBracketed as std::clone::Clone>::clone(p0);
+<ast::ClassBracketed>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassBracketed as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassBracketed as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassBracketed as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassBracketed>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.assert_receiver_is_total_eq();
+<ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassBracketed>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassBracketed as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.eq(p1);
+<ast::ClassBracketed as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassBracketed as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassBracketed>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.clone();
+<ast::ClassSet as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSet as std::clone::Clone>::clone(p0);
+<ast::ClassSet>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSet as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSet>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.assert_receiver_is_total_eq();
+<ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSet>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassSet as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.eq(p1);
+<ast::ClassSet as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSet as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSet>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::ClassSet::union
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+ast::ClassSet::union(p0);
+crate::ast::ClassSet::union(p0);
+<ast::ClassSet>::union(p0);
-----------------
src/ast/mod.rs ast::ClassSet::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.span();
+ast::ClassSet::span(p0);
+crate::ast::ClassSet::span(p0);
+<ast::ClassSet>::span(p0);
-----------------
src/ast/mod.rs ast::ClassSet::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.is_empty();
+ast::ClassSet::is_empty(p0);
+crate::ast::ClassSet::is_empty(p0);
+<ast::ClassSet>::is_empty(p0);
-----------------
src/ast/mod.rs <ast::ClassSetItem as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.clone();
+<ast::ClassSetItem as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetItem as std::clone::Clone>::clone(p0);
+<ast::ClassSetItem>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassSetItem as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetItem as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetItem as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetItem>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetItem>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassSetItem as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.eq(p1);
+<ast::ClassSetItem as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetItem as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetItem>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::ClassSetItem::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.span();
+ast::ClassSetItem::span(p0);
+crate::ast::ClassSetItem::span(p0);
+<ast::ClassSetItem>::span(p0);
-----------------
src/ast/mod.rs <ast::ClassSetRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.clone();
+<ast::ClassSetRange as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetRange as std::clone::Clone>::clone(p0);
+<ast::ClassSetRange>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassSetRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetRange as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetRange>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetRange>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassSetRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.eq(p1);
+<ast::ClassSetRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetRange as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetRange>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::ClassSetRange::is_valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.is_valid();
+ast::ClassSetRange::is_valid(p0);
+crate::ast::ClassSetRange::is_valid(p0);
+<ast::ClassSetRange>::is_valid(p0);
-----------------
src/ast/mod.rs <ast::ClassSetUnion as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.clone();
+<ast::ClassSetUnion as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetUnion as std::clone::Clone>::clone(p0);
+<ast::ClassSetUnion>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassSetUnion as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetUnion as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetUnion as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetUnion>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetUnion>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassSetUnion as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.eq(p1);
+<ast::ClassSetUnion as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetUnion as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetUnion>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::ClassSetUnion::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.push(p1);
+ast::ClassSetUnion::push(p0, p1);
+crate::ast::ClassSetUnion::push(p0, p1);
+<ast::ClassSetUnion>::push(p0, p1);
-----------------
src/ast/mod.rs ast::ClassSetUnion::into_item
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.into_item();
+ast::ClassSetUnion::into_item(p0);
+crate::ast::ClassSetUnion::into_item(p0);
+<ast::ClassSetUnion>::into_item(p0);
-----------------
src/ast/mod.rs <ast::ClassSetBinaryOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.clone();
+<ast::ClassSetBinaryOp as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetBinaryOp as std::clone::Clone>::clone(p0);
+<ast::ClassSetBinaryOp>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassSetBinaryOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetBinaryOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetBinaryOp as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetBinaryOp>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetBinaryOp>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.eq(p1);
+<ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetBinaryOp>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.clone();
+<ast::ClassSetBinaryOpKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetBinaryOpKind as std::clone::Clone>::clone(p0);
+<ast::ClassSetBinaryOpKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetBinaryOpKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetBinaryOpKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.eq(p1);
+<ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetBinaryOpKind>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::Assertion as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.clone();
+<ast::Assertion as std::clone::Clone>::clone(p0);
+crate::<ast::Assertion as std::clone::Clone>::clone(p0);
+<ast::Assertion>::clone(p0);
-----------------
src/ast/mod.rs <ast::Assertion as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Assertion as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Assertion as std::fmt::Debug>::fmt(p0, p1);
+<ast::Assertion>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.assert_receiver_is_total_eq();
+<ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Assertion>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Assertion as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.eq(p1);
+<ast::Assertion as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Assertion as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Assertion>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::AssertionKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
+p0.clone();
+<ast::AssertionKind as std::clone::Clone>::clone(p0);
+crate::<ast::AssertionKind as std::clone::Clone>::clone(p0);
+<ast::AssertionKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::AssertionKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::AssertionKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::AssertionKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::AssertionKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
+p0.assert_receiver_is_total_eq();
+<ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::AssertionKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::AssertionKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
+p0.eq(p1);
+<ast::AssertionKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::AssertionKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::AssertionKind>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::Repetition as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.clone();
+<ast::Repetition as std::clone::Clone>::clone(p0);
+crate::<ast::Repetition as std::clone::Clone>::clone(p0);
+<ast::Repetition>::clone(p0);
-----------------
src/ast/mod.rs <ast::Repetition as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Repetition as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Repetition as std::fmt::Debug>::fmt(p0, p1);
+<ast::Repetition>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.assert_receiver_is_total_eq();
+<ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Repetition>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Repetition as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.eq(p1);
+<ast::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Repetition>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::RepetitionOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
+p0.clone();
+<ast::RepetitionOp as std::clone::Clone>::clone(p0);
+crate::<ast::RepetitionOp as std::clone::Clone>::clone(p0);
+<ast::RepetitionOp>::clone(p0);
-----------------
src/ast/mod.rs <ast::RepetitionOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::RepetitionOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::RepetitionOp as std::fmt::Debug>::fmt(p0, p1);
+<ast::RepetitionOp>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
+p0.assert_receiver_is_total_eq();
+<ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::RepetitionOp>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::RepetitionOp as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
+p0.eq(p1);
+<ast::RepetitionOp as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::RepetitionOp as std::cmp::PartialEq>::eq(p0, p1);
+<ast::RepetitionOp>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::RepetitionKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.clone();
+<ast::RepetitionKind as std::clone::Clone>::clone(p0);
+crate::<ast::RepetitionKind as std::clone::Clone>::clone(p0);
+<ast::RepetitionKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::RepetitionKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::RepetitionKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.assert_receiver_is_total_eq();
+<ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::RepetitionKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::RepetitionKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.eq(p1);
+<ast::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::RepetitionKind>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::RepetitionRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.clone();
+<ast::RepetitionRange as std::clone::Clone>::clone(p0);
+crate::<ast::RepetitionRange as std::clone::Clone>::clone(p0);
+<ast::RepetitionRange>::clone(p0);
-----------------
src/ast/mod.rs <ast::RepetitionRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+<ast::RepetitionRange>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.assert_receiver_is_total_eq();
+<ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::RepetitionRange>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::RepetitionRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.eq(p1);
+<ast::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+<ast::RepetitionRange>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::RepetitionRange::is_valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.is_valid();
+ast::RepetitionRange::is_valid(p0);
+crate::ast::RepetitionRange::is_valid(p0);
+<ast::RepetitionRange>::is_valid(p0);
-----------------
src/ast/mod.rs <ast::Group as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.clone();
+<ast::Group as std::clone::Clone>::clone(p0);
+crate::<ast::Group as std::clone::Clone>::clone(p0);
+<ast::Group>::clone(p0);
-----------------
src/ast/mod.rs <ast::Group as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Group as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Group as std::fmt::Debug>::fmt(p0, p1);
+<ast::Group>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.assert_receiver_is_total_eq();
+<ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Group>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Group as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.eq(p1);
+<ast::Group as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Group as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Group>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::Group::flags
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.flags();
+ast::Group::flags(p0);
+crate::ast::Group::flags(p0);
+<ast::Group>::flags(p0);
-----------------
src/ast/mod.rs ast::Group::is_capturing
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.is_capturing();
+ast::Group::is_capturing(p0);
+crate::ast::Group::is_capturing(p0);
+<ast::Group>::is_capturing(p0);
-----------------
src/ast/mod.rs ast::Group::capture_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.capture_index();
+ast::Group::capture_index(p0);
+crate::ast::Group::capture_index(p0);
+<ast::Group>::capture_index(p0);
-----------------
src/ast/mod.rs <ast::GroupKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
+p0.clone();
+<ast::GroupKind as std::clone::Clone>::clone(p0);
+crate::<ast::GroupKind as std::clone::Clone>::clone(p0);
+<ast::GroupKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::GroupKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::GroupKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
+p0.assert_receiver_is_total_eq();
+<ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::GroupKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::GroupKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
+p0.eq(p1);
+<ast::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::GroupKind>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::CaptureName as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.clone();
+<ast::CaptureName as std::clone::Clone>::clone(p0);
+crate::<ast::CaptureName as std::clone::Clone>::clone(p0);
+<ast::CaptureName>::clone(p0);
-----------------
src/ast/mod.rs <ast::CaptureName as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::CaptureName as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::CaptureName as std::fmt::Debug>::fmt(p0, p1);
+<ast::CaptureName>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.assert_receiver_is_total_eq();
+<ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::CaptureName>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::CaptureName as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.eq(p1);
+<ast::CaptureName as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::CaptureName as std::cmp::PartialEq>::eq(p0, p1);
+<ast::CaptureName>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::SetFlags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.clone();
+<ast::SetFlags as std::clone::Clone>::clone(p0);
+crate::<ast::SetFlags as std::clone::Clone>::clone(p0);
+<ast::SetFlags>::clone(p0);
-----------------
src/ast/mod.rs <ast::SetFlags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::SetFlags as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::SetFlags as std::fmt::Debug>::fmt(p0, p1);
+<ast::SetFlags>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.assert_receiver_is_total_eq();
+<ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::SetFlags>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::SetFlags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.eq(p1);
+<ast::SetFlags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::SetFlags as std::cmp::PartialEq>::eq(p0, p1);
+<ast::SetFlags>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::Flags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.clone();
+<ast::Flags as std::clone::Clone>::clone(p0);
+crate::<ast::Flags as std::clone::Clone>::clone(p0);
+<ast::Flags>::clone(p0);
-----------------
src/ast/mod.rs <ast::Flags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Flags as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Flags as std::fmt::Debug>::fmt(p0, p1);
+<ast::Flags>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.assert_receiver_is_total_eq();
+<ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Flags>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Flags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.eq(p1);
+<ast::Flags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Flags as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Flags>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::Flags::add_item
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.add_item(p1);
+ast::Flags::add_item(p0, p1);
+crate::ast::Flags::add_item(p0, p1);
+<ast::Flags>::add_item(p0, p1);
-----------------
src/ast/mod.rs ast::Flags::flag_state
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.flag_state(p1);
+ast::Flags::flag_state(p0, p1);
+crate::ast::Flags::flag_state(p0, p1);
+<ast::Flags>::flag_state(p0, p1);
-----------------
src/ast/mod.rs <ast::FlagsItem as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.clone();
+<ast::FlagsItem as std::clone::Clone>::clone(p0);
+crate::<ast::FlagsItem as std::clone::Clone>::clone(p0);
+<ast::FlagsItem>::clone(p0);
-----------------
src/ast/mod.rs <ast::FlagsItem as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::FlagsItem as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::FlagsItem as std::fmt::Debug>::fmt(p0, p1);
+<ast::FlagsItem>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.assert_receiver_is_total_eq();
+<ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::FlagsItem>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::FlagsItem as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.eq(p1);
+<ast::FlagsItem as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::FlagsItem as std::cmp::PartialEq>::eq(p0, p1);
+<ast::FlagsItem>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::FlagsItemKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.clone();
+<ast::FlagsItemKind as std::clone::Clone>::clone(p0);
+crate::<ast::FlagsItemKind as std::clone::Clone>::clone(p0);
+<ast::FlagsItemKind>::clone(p0);
-----------------
src/ast/mod.rs <ast::FlagsItemKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::FlagsItemKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::FlagsItemKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::FlagsItemKind>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.assert_receiver_is_total_eq();
+<ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::FlagsItemKind>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::FlagsItemKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.eq(p1);
+<ast::FlagsItemKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::FlagsItemKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::FlagsItemKind>::eq(p0, p1);
-----------------
src/ast/mod.rs ast::FlagsItemKind::is_negation
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.is_negation();
+ast::FlagsItemKind::is_negation(p0);
+crate::ast::FlagsItemKind::is_negation(p0);
+<ast::FlagsItemKind>::is_negation(p0);
-----------------
src/ast/mod.rs <ast::Flag as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.clone();
+<ast::Flag as std::clone::Clone>::clone(p0);
+crate::<ast::Flag as std::clone::Clone>::clone(p0);
+<ast::Flag>::clone(p0);
-----------------
src/ast/mod.rs <ast::Flag as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Flag as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Flag as std::fmt::Debug>::fmt(p0, p1);
+<ast::Flag>::fmt(p0, p1);
-----------------
src/ast/mod.rs <ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.assert_receiver_is_total_eq();
+<ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Flag>::assert_receiver_is_total_eq(p0);
-----------------
src/ast/mod.rs <ast::Flag as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.eq(p1);
+<ast::Flag as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Flag as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Flag>::eq(p0, p1);
-----------------
src/ast/mod.rs <ast::Ast as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.drop();
+<ast::Ast as std::ops::Drop>::drop(p0);
+crate::<ast::Ast as std::ops::Drop>::drop(p0);
+<ast::Ast>::drop(p0);
-----------------
src/ast/mod.rs <ast::ClassSet as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.drop();
+<ast::ClassSet as std::ops::Drop>::drop(p0);
+crate::<ast::ClassSet as std::ops::Drop>::drop(p0);
+<ast::ClassSet>::drop(p0);
-----------------
src/debug.rs <debug::Byte as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // debug::Byte
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<debug::Byte as std::fmt::Debug>::fmt(p0, p1);
+crate::<debug::Byte as std::fmt::Debug>::fmt(p0, p1);
+<debug::Byte>::fmt(p0, p1);
-----------------
src/debug.rs <debug::Bytes<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // debug::Bytes<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<debug::Bytes<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<debug::Bytes<'a> as std::fmt::Debug>::fmt(p0, p1);
+<debug::Bytes<'a>>::fmt(p0, p1);
-----------------
src/either.rs <either::Either<Left, Right> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::clone::Clone>::clone":{"Left":["std::clone::Clone","std::marker::Sized"],"Right":["std::marker::Sized","std::clone::Clone"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::borrow::Borrow"]},"either::Either":{"Left":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized"],"Right":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","hir::interval::Interval","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::clone::Clone>::clone":{"Left":["hir::literal::ExtractKind","ast::ErrorKind","ast::ClassPerl","hir::ClassBytesRange","ast::FlagsItem","ast::ClassUnicode","ast::FlagsItemKind","ast::ClassBracketed","ast::RepetitionOp","ast::parse::ClassState","hir::LookSetIter","ast::RepetitionKind","parser::Parser","ast::LiteralKind","ast::Assertion","either::Either","ast::parse::ParserI","hir::Literal","hir::ClassUnicode","ast::Group","ast::SpecialLiteralKind","hir::translate::Translator","ast::Comment","hir::print::PrinterBuilder","std::clone::impls::<impl std::clone::Clone for &mut T>","ast::RepetitionRange","ast::ClassSet","ast::Concat","ast::Repetition","hir::literal::Literal","ast::ClassSetRange","ast::Position","ast::WithComments","ast::Ast","ast::ClassSetBinaryOp","ast::HexLiteralKind","hir::Error","ast::ClassUnicodeKind","parser::ParserBuilder","utf8::Utf8Range","hir::translate::HirFrame","hir::interval::IntervalSet","hir::ErrorKind","ast::Error","ast::Flag","hir::translate::Flags","hir::Dot","hir::HirKind","hir::literal::Extractor","ast::parse::Parser","error::Error","ast::AssertionKind","utf8::Utf8Sequence","hir::Look","hir::translate::TranslatorI","hir::Properties","hir::PropertiesI","ast::ClassPerlKind","ast::ClassUnicodeOpKind","hir::ClassBytes","ast::ClassSetBinaryOpKind","ast::SetFlags","hir::Repetition","hir::Hir","ast::GroupKind","hir::Capture","hir::translate::TranslatorBuilder","ast::Class","ast::ClassAscii","ast::ClassSetUnion","hir::Class","ast::Literal","ast::print::PrinterBuilder","ast::parse::Primitive","hir::LookSet","ast::ClassAsciiKind","ast::Flags","ast::parse::ParserBuilder","hir::literal::Seq","hir::ClassUnicodeRange","ast::Span","ast::CaptureName","ast::parse::GroupState","ast::ClassSetItem","ast::Alternation"],"Right":["hir::Class","ast::ClassUnicode","hir::ClassBytesRange","ast::Ast","ast::ClassSetBinaryOp","hir::translate::Translator","ast::Span","ast::ClassSet","ast::ClassPerl","ast::parse::ParserI","ast::SetFlags","hir::interval::IntervalSet","hir::Repetition","ast::ErrorKind","hir::literal::Extractor","ast::Group","hir::Literal","ast::RepetitionRange","ast::Position","ast::FlagsItemKind","parser::ParserBuilder","ast::Alternation","hir::Properties","ast::WithComments","ast::parse::Primitive","ast::ClassSetUnion","ast::Flag","ast::ClassSetBinaryOpKind","ast::AssertionKind","hir::literal::Seq","ast::GroupKind","hir::Capture","hir::PropertiesI","ast::LiteralKind","hir::Dot","ast::ClassUnicodeOpKind","ast::Class","ast::ClassSetItem","hir::ClassUnicode","hir::translate::HirFrame","hir::Error","either::Either","ast::RepetitionOp","hir::print::PrinterBuilder","hir::literal::ExtractKind","hir::ClassUnicodeRange","ast::parse::Parser","ast::Literal","ast::print::PrinterBuilder","ast::Comment","ast::RepetitionKind","hir::translate::TranslatorI","hir::translate::TranslatorBuilder","ast::Concat","ast::parse::ParserBuilder","hir::translate::Flags","ast::ClassBracketed","utf8::Utf8Sequence","ast::Error","ast::ClassAsciiKind","hir::ErrorKind","hir::HirKind","hir::LookSetIter","ast::ClassAscii","parser::Parser","ast::ClassPerlKind","std::clone::impls::<impl std::clone::Clone for &mut T>","ast::ClassSetRange","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::parse::ClassState","hir::Look","hir::LookSet","hir::ClassBytes","ast::Repetition","ast::parse::GroupState","ast::HexLiteralKind","ast::CaptureName","ast::ClassUnicodeKind","ast::FlagsItem","hir::literal::Literal","hir::Hir","ast::SpecialLiteralKind","error::Error","ast::Flags","utf8::Utf8Range","ast::Assertion"]},"ast::parse::ParserI":{"P":["std::clone::impls::<impl std::clone::Clone for &mut T>","std::ffi::OsString","std::path::PathBuf","std::string::String","std::sync::Arc<T>","std::vec::Vec<T, A>","std::rc::Rc<T>","std::ffi::CString","std::boxed::Box<T, A>"]},"either::Either":{"Left":["ast::ClassUnicode","ast::FlagsItem","ast::Assertion","utf8::Utf8Range","ast::SpecialLiteralKind","ast::Class","ast::ClassSetBinaryOpKind","ast::Group","ast::AssertionKind","ast::Position","ast::ClassSet","hir::literal::Seq","ast::ClassSetRange","hir::Class","hir::ClassUnicode","ast::Concat","ast::SetFlags","hir::ClassBytesRange","ast::ErrorKind","hir::interval::IntervalSet","ast::Flags","hir::Capture","hir::LookSet","either::Either","ast::RepetitionKind","ast::Error","ast::ClassSetUnion","hir::HirKind","ast::Alternation","hir::Dot","ast::HexLiteralKind","ast::Repetition","ast::ClassAscii","ast::Comment","ast::CaptureName","hir::Look","ast::RepetitionRange","<*const T as std::fmt::Debug>","ast::Span","ast::FlagsItemKind","hir::PropertiesI","ast::Flag","hir::literal::Literal","hir::ErrorKind","ast::ClassBracketed","error::Error","ast::ClassPerl","hir::ClassUnicodeRange","utf8::Utf8Sequence","ast::WithComments","ast::ClassUnicodeOpKind","hir::Literal","ast::parse::Primitive","ast::ClassUnicodeKind","hir::Properties","ast::ClassSetItem","hir::Error","ast::RepetitionOp","ast::ClassAsciiKind","hir::Hir","ast::LiteralKind","ast::Literal","ast::ClassPerlKind","ast::ClassSetBinaryOp","hir::ClassBytes","ast::Ast","ast::GroupKind","hir::Repetition"],"Right":["hir::ClassBytesRange","ast::AssertionKind","hir::Look","ast::WithComments","hir::ClassUnicodeRange","ast::Alternation","hir::LookSet","hir::Hir","ast::ClassPerl","ast::ClassUnicodeOpKind","hir::HirKind","ast::SetFlags","ast::RepetitionRange","hir::Literal","ast::ClassAsciiKind","ast::ClassBracketed","ast::Comment","hir::Class","hir::ClassBytes","hir::ErrorKind","ast::HexLiteralKind","utf8::Utf8Sequence","ast::Ast","ast::ClassUnicodeKind","ast::Class","hir::Properties","ast::ErrorKind","ast::ClassPerlKind","hir::Capture","ast::ClassSetBinaryOpKind","ast::RepetitionOp","ast::parse::Primitive","ast::Literal","ast::Repetition","either::Either","ast::Span","hir::Error","hir::Repetition","hir::interval::IntervalSet","ast::Flags","ast::ClassAscii","ast::SpecialLiteralKind","ast::ClassSet","ast::FlagsItemKind","ast::ClassSetRange","ast::Position","ast::GroupKind","ast::Concat","ast::Flag","ast::ClassSetItem","ast::ClassSetUnion","ast::ClassUnicode","ast::LiteralKind","ast::Group","hir::Dot","ast::FlagsItem","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::RepetitionKind","ast::Error","ast::Assertion","hir::PropertiesI","hir::literal::Seq","utf8::Utf8Range","ast::CaptureName","ast::ClassSetBinaryOp","hir::ClassUnicode","hir::literal::Literal","error::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
+p0.clone();
+<either::Either<Left, Right> as std::clone::Clone>::clone(p0);
+crate::<either::Either<Left, Right> as std::clone::Clone>::clone(p0);
+<either::Either<Left, Right>>::clone(p0);
-----------------
src/either.rs <either::Either<Left, Right> as std::fmt::Debug>::fmt
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::fmt::Debug>::fmt":{"Left":["std::fmt::Debug","std::marker::Sized"],"Right":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"],"Right":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"error::Formatter":{"E":["std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::fmt::Debug>::fmt":{"Left":["ast::ClassUnicodeOpKind","hir::LookSetIter","hir::interval::IntervalSet","hir::Literal","ast::SetFlags","ast::ErrorKind","ast::Literal","ast::RepetitionOp","ast::RepetitionRange","ast::Flags","ast::ClassSetRange","ast::Comment","ast::GroupKind","hir::print::PrinterBuilder","ast::parse::Primitive","ast::parse::GroupState","ast::visitor::ClassFrame","ast::Concat","parser::ParserBuilder","hir::translate::TranslatorBuilder","ast::ClassPerl","hir::ClassUnicodeIter","ast::Group","unicode::UnicodeWordError","hir::HirKind","ast::Error","ast::ClassBracketed","hir::ClassUnicodeRange","ast::SpecialLiteralKind","debug::Byte","hir::translate::HirFrame","ast::ClassAscii","ast::LiteralKind","hir::literal::Seq","ast::Flag","hir::literal::PreferenceTrie","unicode::ClassQuery","hir::translate::Translator","hir::literal::ExtractKind","ast::parse::ParserI","hir::print::Printer","ast::CaptureName","utf8::Utf8Sequences","hir::literal::Extractor","hir::print::Writer","ast::FlagsItem","hir::ClassBytes","hir::Look","hir::Repetition","hir::literal::Literal","hir::PropertiesI","error::Formatter","hir::Hir","utf8::ScalarRange","ast::Position","hir::ClassBytesRange","ast::ClassSetItem","ast::parse::Parser","ast::ClassSet","unicode::CaseFoldError","utf8::Utf8Range","hir::translate::TranslatorI","hir::ClassUnicode","hir::Capture","ast::ClassUnicodeKind","ast::Alternation","hir::literal::State","ast::AssertionKind","ast::ClassSetBinaryOp","ast::print::Writer","error::Error","ast::WithComments","hir::LookSet","parser::Parser","utf8::Utf8Sequence","hir::ClassBytesIter","unicode::SimpleCaseFolder","ast::ClassPerlKind","ast::RepetitionKind","ast::ClassSetBinaryOpKind","ast::Ast","ast::Span","<&T as std::fmt::Debug>","hir::interval::IntervalSetIter","either::Either","hir::Dot","debug::Bytes","hir::Properties","ast::parse::ClassState","ast::parse::ParserBuilder","unicode::Error","ast::print::PrinterBuilder","ast::FlagsItemKind","ast::parse::NestLimiter","hir::Class","ast::HexLiteralKind","ast::ClassUnicode","ast::ClassSetUnion","ast::visitor::ClassInduct","hir::Error","unicode::CanonicalClassQuery","ast::Assertion","ast::print::Printer","ast::Class","hir::translate::Flags","ast::Repetition","hir::ErrorKind","<*const T as std::fmt::Debug>","ast::ClassAsciiKind"],"Right":["ast::Alternation","ast::ClassAscii","ast::Class","ast::LiteralKind","hir::PropertiesI","debug::Bytes","hir::literal::Seq","ast::Literal","utf8::ScalarRange","hir::ClassBytesIter","error::Formatter","ast::WithComments","ast::ClassSetBinaryOp","ast::print::Printer","debug::Byte","ast::parse::ClassState","ast::RepetitionOp","ast::Ast","hir::Repetition","hir::ErrorKind","hir::literal::Extractor","ast::Error","ast::RepetitionRange","ast::ClassUnicodeKind","ast::parse::ParserBuilder","ast::RepetitionKind","ast::ClassUnicode","unicode::Error","ast::ClassSet","parser::ParserBuilder","unicode::CanonicalClassQuery","hir::literal::ExtractKind","hir::Literal","error::Error","hir::literal::Literal","hir::ClassBytesRange","ast::ClassPerlKind","ast::visitor::ClassInduct","hir::Dot","hir::interval::IntervalSetIter","unicode::CaseFoldError","hir::LookSet","ast::Flags","ast::Position","ast::ClassAsciiKind","hir::ClassBytes","unicode::UnicodeWordError","ast::Assertion","ast::parse::GroupState","unicode::ClassQuery","hir::ClassUnicode","ast::Span","ast::ClassBracketed","hir::interval::IntervalSet","ast::ClassPerl","ast::SetFlags","ast::Concat","hir::HirKind","parser::Parser","hir::translate::Translator","hir::print::PrinterBuilder","ast::HexLiteralKind","utf8::Utf8Sequence","ast::Flag","hir::translate::HirFrame","hir::print::Printer","hir::Capture","ast::FlagsItem","hir::ClassUnicodeIter","hir::Properties","hir::translate::TranslatorBuilder","ast::FlagsItemKind","ast::ErrorKind","hir::translate::TranslatorI","ast::parse::Primitive","hir::print::Writer","hir::ClassUnicodeRange","hir::literal::State","utf8::Utf8Range","ast::ClassSetRange","ast::ClassSetUnion","hir::Class","ast::print::Writer","ast::Comment","ast::parse::NestLimiter","hir::Look","ast::GroupKind","ast::parse::ParserI","hir::LookSetIter","ast::AssertionKind","utf8::Utf8Sequences","ast::visitor::ClassFrame","either::Either","hir::literal::PreferenceTrie","ast::Group","unicode::SimpleCaseFolder","ast::ClassSetItem","ast::ClassUnicodeOpKind","hir::translate::Flags","hir::Error","hir::Hir","ast::SpecialLiteralKind","ast::print::PrinterBuilder","ast::CaptureName","ast::Repetition","ast::parse::Parser","ast::ClassSetBinaryOpKind","<*const T as std::fmt::Debug>"]},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::rc::Rc<T>","std::vec::Vec<T, A>","std::sync::Arc<T>","<&mut T as std::fmt::Debug>","std::boxed::Box<T, A>","std::ffi::CString","std::path::PathBuf","std::string::String"]},"ast::parse::ParserI":{"P":["std::sync::Arc<T>","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::boxed::Box<T, A>","std::ffi::CString","std::rc::Rc<T>","std::path::PathBuf","std::ffi::OsString","std::vec::Vec<T, A>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::RepetitionKind","ast::Literal","hir::literal::Literal","hir::Hir","ast::ClassAsciiKind","hir::ClassUnicodeRange","ast::Comment","ast::Concat","hir::ErrorKind","ast::SetFlags","ast::Span","ast::ClassPerl","ast::ClassUnicodeOpKind","hir::Dot","ast::ClassPerlKind","ast::Error","ast::ClassSetItem","ast::Alternation","ast::LiteralKind","hir::Literal","hir::Repetition","ast::ClassSetUnion","ast::ClassSetRange","ast::HexLiteralKind","hir::ClassBytesRange","ast::Group","ast::FlagsItem","ast::GroupKind","ast::SpecialLiteralKind","ast::Position","hir::ClassBytes","hir::Class","ast::RepetitionOp","ast::RepetitionRange","ast::ErrorKind","ast::WithComments","ast::Class","ast::Repetition","ast::ClassSet","ast::ClassSetBinaryOpKind","hir::ClassUnicode","utf8::Utf8Sequence","hir::PropertiesI","ast::Assertion","either::Either","hir::literal::Seq","hir::interval::IntervalSet","ast::ClassAscii","hir::LookSet","ast::CaptureName","ast::AssertionKind","hir::Look","ast::parse::Primitive","ast::ClassUnicodeKind","ast::ClassSetBinaryOp","ast::Ast","utf8::Utf8Range","hir::Error","ast::Flag","hir::Properties","hir::Capture","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","hir::HirKind","ast::ClassUnicode","error::Error","ast::ClassBracketed","ast::FlagsItemKind","ast::Flags"],"Right":["ast::FlagsItemKind","ast::ClassUnicode","ast::SpecialLiteralKind","hir::ClassBytesRange","hir::HirKind","ast::FlagsItem","ast::Assertion","error::Error","hir::literal::Seq","utf8::Utf8Range","ast::ErrorKind","hir::PropertiesI","hir::Hir","ast::Alternation","hir::ClassUnicode","ast::LiteralKind","ast::AssertionKind","ast::ClassSetUnion","ast::Flag","hir::ErrorKind","ast::ClassSetBinaryOp","ast::ClassSet","ast::RepetitionOp","hir::Properties","hir::Literal","hir::LookSet","hir::Class","ast::RepetitionKind","either::Either","hir::Error","ast::ClassAscii","ast::Group","hir::Capture","ast::ClassPerl","hir::interval::IntervalSet","ast::parse::Primitive","ast::Concat","hir::Repetition","ast::ClassPerlKind","ast::Class","hir::ClassBytes","ast::ClassBracketed","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::Repetition","ast::WithComments","ast::ClassUnicodeKind","ast::Comment","ast::Error","ast::Span","ast::GroupKind","ast::RepetitionRange","hir::ClassUnicodeRange","ast::ClassAsciiKind","ast::Ast","ast::ClassUnicodeOpKind","hir::Look","ast::SetFlags","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::HexLiteralKind","hir::literal::Literal","ast::CaptureName","hir::Dot","ast::Position","ast::ClassSetRange","utf8::Utf8Sequence","ast::Literal","ast::Flags"]},"error::Formatter":{"E":["unicode::UnicodeWordError","<&mut T as std::fmt::Display>","error::Formatter","unicode::CaseFoldError","ast::Ast","ast::ErrorKind","error::Error","hir::Error","hir::ErrorKind","hir::Hir","ast::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["hir::interval::IntervalSet","ast::ClassSetBinaryOp","hir::translate::Flags","utf8::Utf8Sequences","ast::print::PrinterBuilder","ast::RepetitionOp","ast::Alternation","ast::visitor::ClassFrame","ast::FlagsItemKind","ast::Concat","hir::translate::Translator","parser::Parser","ast::ClassUnicode","hir::literal::ExtractKind","hir::literal::State","ast::WithComments","ast::ClassSetItem","error::Formatter","ast::print::Writer","ast::ClassUnicodeOpKind","ast::FlagsItem","ast::parse::ParserBuilder","utf8::Utf8Range","ast::ErrorKind","ast::Position","debug::Bytes","ast::Class","ast::LiteralKind","ast::CaptureName","ast::Repetition","hir::ClassUnicodeRange","hir::Repetition","hir::LookSet","ast::parse::Parser","utf8::ScalarRange","hir::Capture","hir::Dot","unicode::SimpleCaseFolder","ast::RepetitionKind","ast::parse::GroupState","hir::translate::HirFrame","either::Either","hir::ErrorKind","ast::Literal","unicode::CaseFoldError","hir::LookSetIter","hir::interval::IntervalSetIter","unicode::Error","hir::ClassBytesRange","<*mut T as std::fmt::Debug>","ast::ClassBracketed","hir::translate::TranslatorBuilder","ast::Group","ast::print::Printer","ast::Flag","hir::literal::PreferenceTrie","ast::visitor::ClassInduct","ast::ClassUnicodeKind","ast::Assertion","ast::ClassSet","unicode::UnicodeWordError","hir::ClassBytesIter","hir::ClassUnicode","ast::ClassAscii","ast::Flags","hir::translate::TranslatorI","hir::ClassBytes","ast::Error","hir::Hir","ast::ClassPerlKind","ast::parse::ClassState","ast::parse::ParserI","error::Error","ast::ClassSetRange","hir::print::Printer","hir::PropertiesI","hir::HirKind","ast::ClassSetUnion","ast::Span","ast::RepetitionRange","hir::Error","ast::parse::NestLimiter","hir::ClassUnicodeIter","parser::ParserBuilder","hir::print::PrinterBuilder","hir::literal::Literal","ast::GroupKind","hir::Class","hir::literal::Extractor","ast::SpecialLiteralKind","hir::Look","ast::Comment","hir::literal::Seq","hir::Literal","hir::Properties","ast::ClassPerl","ast::AssertionKind","ast::ClassSetBinaryOpKind","debug::Byte","unicode::CanonicalClassQuery","ast::parse::Primitive","ast::HexLiteralKind","utf8::Utf8Sequence","hir::print::Writer","ast::ClassAsciiKind","ast::SetFlags","ast::Ast","unicode::ClassQuery"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<either::Either<Left, Right> as std::fmt::Debug>::fmt(p0, p1);
+crate::<either::Either<Left, Right> as std::fmt::Debug>::fmt(p0, p1);
+<either::Either<Left, Right>>::fmt(p0, p1);
-----------------
src/either.rs <either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq":{"Left":["std::cmp::Eq","std::marker::Sized"],"Right":["std::marker::Sized","std::cmp::Eq"]},"either::Either":{"Left":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"],"Right":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"hir::interval::IntervalSet":{"I":["std::clone::Clone","std::marker::Sized","hir::interval::Interval","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq":{"Left":["ast::ClassBracketed","hir::ClassUnicode","ast::ClassSetRange","ast::Position","ast::ClassSetItem","ast::ClassPerl","hir::HirKind","hir::Look","utf8::Utf8Range","ast::ClassAsciiKind","ast::SpecialLiteralKind","ast::FlagsItemKind","hir::PropertiesI","ast::RepetitionOp","ast::Comment","ast::Alternation","ast::SetFlags","hir::Hir","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","ast::Group","ast::HexLiteralKind","ast::RepetitionRange","ast::Class","ast::Repetition","ast::Error","ast::parse::Primitive","ast::GroupKind","ast::ClassAscii","ast::CaptureName","std::cmp::impls::<impl std::cmp::Eq for &mut A>","ast::Flags","hir::interval::IntervalSet","hir::Capture","utf8::Utf8Sequence","hir::Properties","ast::ClassSet","hir::ClassUnicodeRange","ast::ClassSetUnion","ast::FlagsItem","ast::AssertionKind","ast::ClassSetBinaryOpKind","hir::ClassBytes","ast::ClassSetBinaryOp","error::Error","ast::Assertion","hir::Class","ast::WithComments","ast::Span","hir::Error","ast::LiteralKind","ast::Flag","hir::LookSet","hir::literal::Seq","either::Either","ast::RepetitionKind","ast::ErrorKind","unicode::CanonicalClassQuery","hir::literal::Literal","hir::Dot","hir::ErrorKind","hir::Literal","hir::Repetition","ast::Concat","ast::ClassUnicodeKind","ast::ClassUnicode","hir::ClassBytesRange","ast::Ast","ast::Literal","ast::ClassPerlKind","ast::ClassUnicodeOpKind"],"Right":["ast::Comment","ast::parse::Primitive","ast::ClassSetUnion","ast::CaptureName","error::Error","ast::Flag","ast::Concat","ast::AssertionKind","ast::Repetition","ast::ClassSetBinaryOpKind","ast::Literal","hir::ErrorKind","hir::ClassUnicodeRange","hir::Capture","ast::LiteralKind","ast::ClassUnicodeOpKind","hir::literal::Literal","hir::Hir","utf8::Utf8Range","hir::Repetition","ast::ClassBracketed","hir::HirKind","hir::Literal","ast::ClassAscii","hir::ClassUnicode","hir::PropertiesI","ast::GroupKind","ast::Assertion","ast::Class","ast::FlagsItemKind","ast::ClassSet","ast::HexLiteralKind","ast::WithComments","std::cmp::impls::<impl std::cmp::Eq for &A>","hir::ClassBytes","hir::LookSet","ast::Group","ast::ClassSetItem","unicode::CanonicalClassQuery","hir::Dot","ast::ClassSetRange","ast::Error","hir::Look","hir::ClassBytesRange","ast::Position","ast::ClassSetBinaryOp","std::cmp::impls::<impl std::cmp::Eq for &mut A>","ast::FlagsItem","ast::Alternation","hir::interval::IntervalSet","ast::Span","utf8::Utf8Sequence","ast::RepetitionKind","ast::Flags","ast::RepetitionRange","ast::ClassPerlKind","ast::ErrorKind","ast::SetFlags","hir::Error","ast::SpecialLiteralKind","ast::Ast","ast::ClassUnicode","hir::Properties","ast::RepetitionOp","ast::ClassAsciiKind","ast::ClassPerl","hir::literal::Seq","ast::ClassUnicodeKind","either::Either","hir::Class"]},"either::Either":{"Left":["ast::ClassSetBinaryOp","ast::RepetitionRange","hir::ErrorKind","ast::Ast","ast::ClassAsciiKind","error::Error","ast::ClassUnicodeOpKind","hir::literal::Seq","hir::PropertiesI","ast::Alternation","ast::Repetition","ast::Flags","ast::WithComments","ast::AssertionKind","hir::Hir","ast::Class","hir::HirKind","ast::FlagsItem","hir::Dot","hir::ClassUnicode","utf8::Utf8Range","hir::literal::Literal","ast::LiteralKind","ast::SetFlags","ast::ClassSetBinaryOpKind","ast::RepetitionKind","ast::GroupKind","ast::ClassAscii","ast::HexLiteralKind","ast::ClassPerl","ast::Group","ast::Span","ast::Concat","ast::ClassSet","hir::Repetition","hir::Properties","ast::parse::Primitive","ast::ErrorKind","ast::ClassSetItem","utf8::Utf8Sequence","hir::ClassBytes","ast::ClassBracketed","hir::interval::IntervalSet","ast::RepetitionOp","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","hir::ClassBytesRange","either::Either","ast::ClassUnicode","ast::Error","hir::ClassUnicodeRange","ast::Position","ast::ClassSetRange","ast::Literal","ast::ClassPerlKind","hir::Class","ast::ClassSetUnion","ast::SpecialLiteralKind","hir::Literal","ast::CaptureName","ast::Assertion","hir::LookSet","ast::ClassUnicodeKind","hir::Error","ast::Flag","hir::Look","ast::FlagsItemKind","hir::Capture","ast::Comment"],"Right":["ast::CaptureName","ast::HexLiteralKind","hir::Dot","utf8::Utf8Sequence","ast::SetFlags","hir::interval::IntervalSet","ast::ClassSetUnion","ast::ClassPerlKind","ast::LiteralKind","hir::ErrorKind","hir::Repetition","hir::literal::Literal","ast::GroupKind","hir::ClassBytesRange","hir::HirKind","ast::WithComments","ast::ClassUnicodeKind","either::Either","ast::Flags","ast::Comment","ast::Repetition","ast::Concat","ast::AssertionKind","ast::FlagsItemKind","ast::RepetitionKind","ast::Error","ast::Class","hir::ClassBytes","ast::Alternation","ast::ClassUnicode","hir::LookSet","ast::ClassSetBinaryOpKind","ast::Assertion","ast::Flag","hir::Error","hir::Class","ast::ClassAsciiKind","ast::SpecialLiteralKind","ast::ErrorKind","hir::ClassUnicode","hir::Capture","ast::Group","hir::Hir","ast::Literal","ast::Ast","ast::ClassSetBinaryOp","ast::ClassSet","ast::FlagsItem","ast::ClassPerl","ast::ClassAscii","ast::ClassBracketed","hir::Properties","ast::Span","hir::literal::Seq","hir::ClassUnicodeRange","error::Error","ast::RepetitionOp","ast::ClassSetRange","hir::PropertiesI","ast::RepetitionRange","<*const T as std::fmt::Debug>","ast::ClassUnicodeOpKind","utf8::Utf8Range","ast::Position","ast::parse::Primitive","hir::Look","hir::Literal","ast::ClassSetItem"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
+p0.assert_receiver_is_total_eq();
+<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<either::Either<Left, Right>>::assert_receiver_is_total_eq(p0);
-----------------
src/either.rs <either::Either<Left, Right> as std::cmp::PartialEq>::eq
deps:{"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::PartialEq>::eq":{"Left":["std::cmp::PartialEq","std::marker::Sized"],"Right":["std::marker::Sized","std::cmp::PartialEq"]},"either::Either":{"Left":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"],"Right":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"hir::interval::IntervalSet":{"I":["hir::interval::Interval","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::PartialEq>::eq":{"Left":["hir::Repetition","ast::Literal","hir::literal::Literal","ast::Comment","ast::ClassSetRange","ast::Error","hir::Capture","hir::ClassUnicodeRange","ast::ClassSetItem","ast::Flags","ast::Class","ast::parse::Primitive","hir::Look","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::HexLiteralKind","ast::Group","ast::RepetitionOp","hir::ErrorKind","ast::GroupKind","ast::CaptureName","ast::ClassSetBinaryOp","hir::HirKind","hir::ClassUnicode","hir::Literal","ast::ClassAsciiKind","ast::ClassAscii","ast::FlagsItemKind","ast::Concat","ast::SetFlags","ast::Alternation","ast::ClassUnicode","hir::Class","ast::WithComments","hir::PropertiesI","hir::ClassBytesRange","ast::FlagsItem","utf8::Utf8Range","ast::Flag","ast::RepetitionKind","hir::LookSet","ast::ClassSet","ast::ClassPerl","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","hir::literal::Seq","ast::ClassPerlKind","ast::Assertion","ast::ClassSetBinaryOpKind","ast::AssertionKind","error::Error","ast::ClassSetUnion","ast::RepetitionRange","ast::Ast","ast::ErrorKind","ast::Repetition","hir::interval::IntervalSet","ast::ClassUnicodeKind","either::Either","ast::ClassUnicodeOpKind","hir::Dot","hir::Properties","hir::Error","utf8::Utf8Sequence","unicode::CanonicalClassQuery","hir::ClassBytes","ast::Span","ast::ClassBracketed","ast::Position","ast::LiteralKind","ast::SpecialLiteralKind","hir::Hir"],"Right":["ast::Ast","ast::ClassSetItem","hir::Hir","ast::ClassUnicode","ast::SpecialLiteralKind","ast::ClassSetBinaryOpKind","ast::Repetition","hir::Repetition","hir::Dot","ast::ClassPerlKind","error::Error","hir::ClassBytes","hir::PropertiesI","ast::ClassUnicodeKind","ast::RepetitionKind","ast::Comment","hir::LookSet","hir::Properties","ast::Error","hir::ClassUnicodeRange","ast::ClassAsciiKind","ast::ClassAscii","ast::Alternation","ast::AssertionKind","ast::Group","ast::ClassSetBinaryOp","ast::ErrorKind","ast::RepetitionOp","ast::GroupKind","ast::Assertion","ast::ClassSetUnion","unicode::CanonicalClassQuery","hir::Literal","ast::Literal","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","hir::ClassBytesRange","ast::Concat","utf8::Utf8Sequence","ast::CaptureName","ast::FlagsItem","ast::ClassSetRange","ast::ClassPerl","ast::Position","ast::RepetitionRange","ast::Span","ast::parse::Primitive","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","either::Either","ast::LiteralKind","ast::ClassBracketed","hir::literal::Seq","hir::Error","hir::ErrorKind","ast::WithComments","ast::SetFlags","hir::Look","ast::Flag","hir::ClassUnicode","hir::HirKind","ast::ClassUnicodeOpKind","ast::Class","ast::Flags","hir::Capture","hir::interval::IntervalSet","hir::literal::Literal","ast::HexLiteralKind","ast::FlagsItemKind","ast::ClassSet","hir::Class","utf8::Utf8Range"]},"either::Either":{"Left":["hir::ErrorKind","ast::ClassSetItem","ast::Flag","ast::LiteralKind","ast::ClassPerl","hir::Error","ast::WithComments","ast::ClassUnicode","ast::RepetitionKind","ast::Assertion","ast::GroupKind","utf8::Utf8Sequence","ast::Literal","hir::Properties","ast::HexLiteralKind","hir::ClassBytes","<*const T as std::fmt::Debug>","ast::ClassSetRange","ast::ClassUnicodeOpKind","ast::Group","ast::ClassSetBinaryOpKind","ast::ClassUnicodeKind","ast::Class","ast::Repetition","hir::Hir","hir::ClassBytesRange","ast::ClassAsciiKind","ast::RepetitionRange","ast::SpecialLiteralKind","ast::ClassSetBinaryOp","ast::Ast","hir::Capture","ast::parse::Primitive","ast::SetFlags","hir::HirKind","ast::ClassSet","hir::Class","ast::Comment","ast::CaptureName","hir::Repetition","ast::Position","hir::literal::Seq","hir::ClassUnicode","hir::Dot","ast::FlagsItem","ast::FlagsItemKind","hir::Look","ast::RepetitionOp","hir::Literal","ast::Concat","ast::ClassPerlKind","hir::LookSet","hir::interval::IntervalSet","ast::ClassBracketed","error::Error","ast::Span","ast::Alternation","ast::ErrorKind","ast::ClassSetUnion","hir::literal::Literal","either::Either","hir::ClassUnicodeRange","hir::PropertiesI","utf8::Utf8Range","ast::Error","ast::Flags","ast::AssertionKind","ast::ClassAscii"],"Right":["ast::ClassUnicodeOpKind","hir::Class","hir::HirKind","hir::Properties","ast::Comment","ast::Class","ast::Error","ast::RepetitionOp","hir::ErrorKind","ast::ClassSetUnion","error::Error","ast::RepetitionKind","hir::Look","hir::ClassUnicodeRange","ast::Literal","ast::Assertion","ast::Position","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::ClassBracketed","hir::interval::IntervalSet","hir::literal::Literal","ast::ClassSetBinaryOp","hir::ClassBytes","ast::LiteralKind","ast::ClassPerl","ast::HexLiteralKind","hir::Hir","utf8::Utf8Range","hir::Error","hir::Literal","ast::SetFlags","ast::SpecialLiteralKind","either::Either","ast::WithComments","ast::ClassAsciiKind","hir::literal::Seq","ast::CaptureName","ast::ClassSetItem","ast::GroupKind","ast::parse::Primitive","hir::Repetition","hir::ClassUnicode","ast::Ast","ast::Group","ast::ClassSetBinaryOpKind","ast::ClassAscii","ast::Span","ast::ClassSet","ast::Flags","utf8::Utf8Sequence","ast::Alternation","ast::Flag","ast::ClassUnicodeKind","ast::Repetition","hir::PropertiesI","hir::Capture","ast::RepetitionRange","ast::ErrorKind","ast::ClassPerlKind","ast::Concat","ast::FlagsItem","ast::ClassUnicode","ast::FlagsItemKind","ast::AssertionKind","ast::ClassSetRange","hir::LookSet","hir::ClassBytesRange","hir::Dot"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
let mut p1 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
+p0.eq(p1);
+<either::Either<Left, Right> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<either::Either<Left, Right> as std::cmp::PartialEq>::eq(p0, p1);
+<either::Either<Left, Right>>::eq(p0, p1);
-----------------
src/error.rs <error::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.clone();
+<error::Error as std::clone::Clone>::clone(p0);
+crate::<error::Error as std::clone::Clone>::clone(p0);
+<error::Error>::clone(p0);
-----------------
src/error.rs <error::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Debug>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error.rs <error::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.assert_receiver_is_total_eq();
+<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::Error>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs <error::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.eq(p1);
+<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+<error::Error>::eq(p0, p1);
-----------------
src/error.rs <error::Error as std::convert::From<ast::Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Error
+<error::Error as std::convert::From<ast::Error>>::from(p0);
+crate::<error::Error as std::convert::From<ast::Error>>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error.rs <error::Error as std::convert::From<hir::Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Error
+<error::Error as std::convert::From<hir::Error>>::from(p0);
+crate::<error::Error as std::convert::From<hir::Error>>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error.rs <error::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Display>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error.rs <error::Formatter<'e, E> as std::fmt::Debug>::fmt
'e
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Formatter<'e, E> as std::fmt::Debug>::fmt":{"E":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::clone::Clone","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"],"Right":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"error::Formatter":{"E":["std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::fmt::Debug","hir::interval::Interval","std::marker::Sized","std::clone::Clone"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Formatter<'e, E> as std::fmt::Debug>::fmt":{"E":["ast::ClassSetUnion","ast::Position","hir::ClassBytesRange","<&T as std::fmt::Debug>","hir::Capture","ast::ClassSetItem","ast::Class","ast::ClassBracketed","error::Formatter","ast::HexLiteralKind","hir::Dot","hir::translate::Flags","ast::ClassUnicodeOpKind","ast::Alternation","hir::Look","ast::visitor::ClassFrame","unicode::Error","ast::ClassPerl","hir::literal::PreferenceTrie","ast::Comment","unicode::ClassQuery","ast::ClassSetBinaryOpKind","hir::Repetition","hir::ClassUnicodeRange","ast::Literal","ast::ClassSet","hir::ClassUnicodeIter","ast::WithComments","ast::parse::ParserBuilder","ast::ClassSetRange","ast::ClassAsciiKind","hir::ClassUnicode","ast::parse::ClassState","debug::Bytes","unicode::CanonicalClassQuery","hir::translate::HirFrame","ast::RepetitionKind","either::Either","ast::Error","hir::ClassBytesIter","unicode::SimpleCaseFolder","hir::LookSetIter","hir::print::Printer","ast::GroupKind","ast::print::Printer","ast::RepetitionRange","ast::LiteralKind","ast::Span","hir::literal::State","ast::ClassUnicodeKind","unicode::CaseFoldError","ast::Group","ast::FlagsItem","hir::interval::IntervalSet","ast::CaptureName","hir::translate::TranslatorBuilder","utf8::ScalarRange","hir::Class","ast::print::PrinterBuilder","utf8::Utf8Sequence","unicode::UnicodeWordError","ast::parse::Primitive","utf8::Utf8Sequences","hir::literal::Literal","hir::LookSet","parser::Parser","ast::Concat","hir::HirKind","ast::ErrorKind","ast::SetFlags","hir::translate::TranslatorI","debug::Byte","hir::translate::Translator","<*mut T as std::fmt::Debug>","ast::FlagsItemKind","ast::AssertionKind","ast::Flag","hir::ErrorKind","ast::Ast","ast::ClassAscii","error::Error","ast::ClassSetBinaryOp","hir::literal::ExtractKind","hir::print::PrinterBuilder","hir::literal::Extractor","ast::ClassUnicode","utf8::Utf8Range","ast::parse::ParserI","ast::parse::GroupState","ast::ClassPerlKind","hir::Properties","hir::Literal","hir::PropertiesI","ast::print::Writer","hir::interval::IntervalSetIter","ast::Flags","ast::SpecialLiteralKind","hir::literal::Seq","ast::parse::Parser","hir::ClassBytes","hir::print::Writer","ast::Repetition","ast::Assertion","ast::visitor::ClassInduct","hir::Error","hir::Hir","parser::ParserBuilder","ast::parse::NestLimiter","ast::RepetitionOp"]},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::boxed::Box<T, A>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::string::String","std::rc::Rc<T>","std::ffi::CString","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>"]},"ast::parse::ParserI":{"P":["<&T as std::fmt::Debug>","std::path::PathBuf","std::rc::Rc<T>","std::vec::Vec<T, A>","std::ffi::CString","std::ffi::OsString","std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::Error","ast::FlagsItem","ast::Literal","ast::Ast","hir::Look","ast::ClassSetRange","ast::Flags","utf8::Utf8Sequence","ast::Group","ast::Assertion","hir::Properties","ast::ClassUnicodeKind","ast::ClassSetItem","ast::RepetitionKind","ast::Comment","ast::ClassUnicode","ast::ClassSet","hir::Dot","hir::literal::Seq","ast::CaptureName","hir::Hir","hir::HirKind","hir::interval::IntervalSet","hir::ClassBytesRange","ast::AssertionKind","hir::Capture","ast::ClassUnicodeOpKind","utf8::Utf8Range","ast::Concat","ast::ErrorKind","hir::Class","either::Either","ast::ClassPerl","ast::ClassBracketed","ast::SetFlags","ast::ClassSetBinaryOpKind","hir::ClassUnicodeRange","hir::literal::Literal","hir::ClassUnicode","ast::RepetitionOp","ast::SpecialLiteralKind","error::Error","ast::Repetition","ast::RepetitionRange","ast::parse::Primitive","hir::ErrorKind","ast::Position","hir::LookSet","hir::Literal","hir::Error","ast::ClassAscii","ast::LiteralKind","hir::PropertiesI","ast::FlagsItemKind","ast::Span","ast::ClassAsciiKind","hir::ClassBytes","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::WithComments","ast::ClassSetUnion","hir::Repetition","ast::Flag","ast::GroupKind","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::Class","ast::Alternation","ast::HexLiteralKind"],"Right":["ast::SetFlags","ast::ClassSetBinaryOpKind","ast::Literal","ast::SpecialLiteralKind","hir::LookSet","ast::RepetitionOp","hir::Class","ast::Group","ast::ClassUnicodeKind","hir::Capture","utf8::Utf8Range","hir::HirKind","ast::Alternation","ast::Position","ast::ClassSet","hir::ClassUnicodeRange","ast::ClassBracketed","hir::Properties","hir::Hir","ast::Assertion","hir::ClassBytes","ast::ErrorKind","either::Either","ast::FlagsItemKind","ast::Error","ast::Flags","utf8::Utf8Sequence","ast::CaptureName","hir::literal::Seq","ast::Comment","hir::PropertiesI","ast::ClassSetRange","ast::HexLiteralKind","ast::Repetition","hir::Repetition","ast::AssertionKind","ast::Concat","ast::RepetitionKind","ast::ClassSetItem","ast::ClassAsciiKind","ast::Class","ast::ClassUnicode","ast::Span","hir::Literal","hir::ClassBytesRange","error::Error","ast::Flag","ast::Ast","hir::Dot","ast::ClassSetBinaryOp","ast::ClassAscii","ast::RepetitionRange","ast::parse::Primitive","ast::ClassPerlKind","ast::GroupKind","ast::ClassUnicodeOpKind","std::clone::impls::<impl std::clone::Clone for *const T>","ast::ClassSetUnion","hir::literal::Literal","ast::LiteralKind","hir::Look","ast::WithComments","ast::ClassPerl","hir::Error","hir::ClassUnicode","ast::FlagsItem","hir::ErrorKind","hir::interval::IntervalSet"]},"error::Formatter":{"E":["hir::Hir","ast::ErrorKind","unicode::UnicodeWordError","<&T as std::fmt::Display>","error::Formatter","hir::ErrorKind","ast::Ast","ast::Error","error::Error","unicode::CaseFoldError","hir::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["debug::Byte","ast::LiteralKind","ast::print::PrinterBuilder","hir::PropertiesI","ast::Group","ast::SetFlags","hir::translate::Flags","parser::Parser","parser::ParserBuilder","hir::translate::HirFrame","ast::print::Writer","ast::RepetitionKind","ast::ClassUnicodeKind","hir::literal::Seq","ast::parse::ParserBuilder","hir::ClassBytes","error::Error","unicode::CaseFoldError","hir::ClassUnicodeRange","hir::ClassBytesRange","ast::HexLiteralKind","hir::print::Printer","utf8::Utf8Sequences","ast::print::Printer","unicode::ClassQuery","ast::parse::Parser","ast::Repetition","hir::ErrorKind","ast::Span","ast::parse::NestLimiter","hir::literal::Extractor","ast::CaptureName","hir::ClassBytesIter","ast::parse::ClassState","ast::ClassPerlKind","ast::ClassSetBinaryOpKind","ast::parse::Primitive","ast::ClassSetBinaryOp","ast::Position","hir::Repetition","hir::Properties","hir::literal::State","hir::Capture","utf8::Utf8Sequence","ast::RepetitionOp","hir::print::Writer","hir::literal::ExtractKind","hir::interval::IntervalSet","hir::Class","unicode::Error","hir::HirKind","hir::literal::PreferenceTrie","hir::print::PrinterBuilder","ast::ClassBracketed","ast::ClassSetRange","hir::LookSetIter","ast::FlagsItem","hir::ClassUnicode","hir::Dot","debug::Bytes","ast::Class","ast::Flag","unicode::SimpleCaseFolder","ast::Ast","hir::ClassUnicodeIter","ast::WithComments","ast::ClassAscii","hir::Hir","ast::visitor::ClassFrame","ast::ClassAsciiKind","ast::Comment","ast::parse::GroupState","hir::interval::IntervalSetIter","ast::SpecialLiteralKind","hir::LookSet","ast::ClassSet","<*const T as std::fmt::Debug>","ast::Assertion","ast::ClassUnicode","ast::ClassPerl","ast::FlagsItemKind","ast::Concat","ast::Flags","unicode::CanonicalClassQuery","hir::translate::TranslatorI","hir::Look","ast::ClassSetUnion","ast::GroupKind","ast::Literal","error::Formatter","ast::Error","ast::ClassUnicodeOpKind","ast::AssertionKind","ast::RepetitionRange","hir::Error","either::Either","unicode::UnicodeWordError","hir::Literal","utf8::ScalarRange","ast::ClassSetItem","ast::parse::ParserI","ast::Alternation","ast::ErrorKind","hir::translate::TranslatorBuilder","ast::visitor::ClassInduct","utf8::Utf8Range","hir::literal::Literal","hir::translate::Translator"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Formatter<'e, E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Formatter<'e, E> as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Formatter<'e, E> as std::fmt::Debug>::fmt(p0, p1);
+<error::Formatter<'e, E>>::fmt(p0, p1);
-----------------
src/error.rs <error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from
'e
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from(p0);
+crate::<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from(p0);
+<error::Formatter<'e, ast::ErrorKind>>::from(p0);
-----------------
src/error.rs <error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from
'e
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from(p0);
+crate::<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from(p0);
+<error::Formatter<'e, hir::ErrorKind>>::from(p0);
-----------------
src/error.rs <error::Formatter<'e, E> as std::fmt::Display>::fmt
'e
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<error::Formatter<'e, E> as std::fmt::Display>::fmt":{"E":["std::fmt::Display","std::marker::Sized"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<error::Formatter<'e, E> as std::fmt::Display>::fmt":{"E":["error::Formatter","ast::ErrorKind","error::Error","ast::Error","hir::Error","unicode::UnicodeWordError","unicode::CaseFoldError","hir::ErrorKind","hir::Hir","<&mut T as std::fmt::Display>","ast::Ast"]},"error::Formatter":{"E":["ast::Error","unicode::CaseFoldError","hir::ErrorKind","ast::Ast","hir::Hir","unicode::UnicodeWordError","error::Error","ast::ErrorKind","error::Formatter","<&T as std::fmt::Display>","hir::Error"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Formatter<'e, E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Formatter<'e, E> as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Formatter<'e, E> as std::fmt::Display>::fmt(p0, p1);
+<error::Formatter<'e, E>>::fmt(p0, p1);
-----------------
src/error.rs error::Spans::<'p>::from_formatter
'p
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"error::Formatter":{"E":["std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::Spans::<'p>::from_formatter":{"E":["std::marker::Sized","std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"error::Formatter":{"E":["ast::Error","hir::Hir","<&T as std::fmt::Display>","hir::Error","ast::Ast","error::Error","hir::ErrorKind","error::Formatter","unicode::UnicodeWordError","unicode::CaseFoldError","ast::ErrorKind"]},"error::Spans::<'p>::from_formatter":{"E":["error::Formatter","hir::Hir","error::Error","ast::ErrorKind","unicode::UnicodeWordError","ast::Ast","<&mut T as std::fmt::Display>","unicode::CaseFoldError","ast::Error","hir::ErrorKind","<&T as std::fmt::Display>","hir::Error"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Formatter<'e, E>
+error::Spans::<'p>::from_formatter(p0);
+crate::error::Spans::<'p>::from_formatter(p0);
+<error::Spans<'p>>::from_formatter(p0);
-----------------
src/error.rs error::Spans::<'p>::add
'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // error::Spans<'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
+p0.add(p1);
+error::Spans::<'p>::add(p0, p1);
+crate::error::Spans::<'p>::add(p0, p1);
+<error::Spans<'p>>::add(p0, p1);
-----------------
src/error.rs error::Spans::<'p>::notate
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
+p0.notate();
+error::Spans::<'p>::notate(p0);
+crate::error::Spans::<'p>::notate(p0);
+<error::Spans<'p>>::notate(p0);
-----------------
src/error.rs error::Spans::<'p>::notate_line
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
let mut p1 = 0usize; // None+usize
+p0.notate_line(p1);
+error::Spans::<'p>::notate_line(p0, p1);
+crate::error::Spans::<'p>::notate_line(p0, p1);
+<error::Spans<'p>>::notate_line(p0, p1);
-----------------
src/error.rs error::Spans::<'p>::left_pad_line_number
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
let mut p1 = 0usize; // None+usize
+p0.left_pad_line_number(p1);
+error::Spans::<'p>::left_pad_line_number(p0, p1);
+crate::error::Spans::<'p>::left_pad_line_number(p0, p1);
+<error::Spans<'p>>::left_pad_line_number(p0, p1);
-----------------
src/error.rs error::Spans::<'p>::line_number_padding
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
+p0.line_number_padding();
+error::Spans::<'p>::line_number_padding(p0);
+crate::error::Spans::<'p>::line_number_padding(p0);
+<error::Spans<'p>>::line_number_padding(p0);
-----------------
src/hir/interval.rs <hir::interval::IntervalSet<I> as std::clone::Clone>::clone
deps:{"<hir::interval::IntervalSet<I> as std::clone::Clone>::clone":{"I":["std::marker::Sized","std::clone::Clone"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"either::Either":{"Left":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"],"Right":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::fmt::Debug","hir::interval::Interval","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<hir::interval::IntervalSet<I> as std::clone::Clone>::clone":{"I":["ast::parse::ParserI","parser::ParserBuilder","hir::Properties","hir::Repetition","ast::RepetitionRange","hir::translate::HirFrame","ast::CaptureName","ast::ClassSetRange","ast::Literal","ast::parse::Parser","ast::Flag","hir::Look","std::clone::impls::<impl std::clone::Clone for *const T>","ast::parse::GroupState","ast::Group","ast::ErrorKind","hir::ClassBytesRange","ast::ClassPerl","hir::translate::TranslatorBuilder","hir::LookSet","hir::ErrorKind","ast::Alternation","ast::Span","ast::Assertion","hir::PropertiesI","hir::print::PrinterBuilder","ast::FlagsItem","ast::Flags","ast::AssertionKind","ast::parse::Primitive","ast::ClassSet","ast::Ast","hir::LookSetIter","ast::parse::ParserBuilder","ast::Error","ast::FlagsItemKind","ast::ClassSetBinaryOp","ast::SpecialLiteralKind","ast::print::PrinterBuilder","error::Error","ast::Position","hir::Hir","hir::ClassUnicode","ast::Class","ast::ClassAsciiKind","ast::ClassSetUnion","hir::translate::Translator","ast::HexLiteralKind","ast::ClassSetBinaryOpKind","ast::GroupKind","hir::literal::Seq","hir::Dot","hir::literal::Literal","hir::HirKind","utf8::Utf8Sequence","hir::literal::Extractor","hir::literal::ExtractKind","hir::Literal","ast::Repetition","parser::Parser","ast::ClassUnicodeOpKind","ast::ClassPerlKind","ast::RepetitionOp","std::clone::impls::<impl std::clone::Clone for &mut T>","hir::Capture","ast::Comment","ast::WithComments","hir::translate::TranslatorI","ast::LiteralKind","hir::ClassUnicodeRange","hir::interval::IntervalSet","hir::ClassBytes","ast::Concat","ast::ClassUnicode","ast::ClassUnicodeKind","ast::RepetitionKind","ast::ClassSetItem","hir::translate::Flags","hir::Error","ast::parse::ClassState","utf8::Utf8Range","hir::Class","either::Either","ast::ClassBracketed","ast::ClassAscii","ast::SetFlags"]},"ast::parse::ParserI":{"P":["std::rc::Rc<T>","std::path::PathBuf","std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::CString","std::vec::Vec<T, A>","std::string::String","std::ffi::OsString","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"either::Either":{"Left":["ast::ErrorKind","ast::HexLiteralKind","error::Error","ast::Flags","hir::Hir","ast::ClassSet","hir::LookSet","hir::interval::IntervalSet","hir::Dot","hir::HirKind","ast::ClassSetBinaryOpKind","ast::Assertion","ast::WithComments","ast::Concat","ast::GroupKind","utf8::Utf8Range","ast::CaptureName","ast::Flag","ast::Span","ast::Ast","hir::ErrorKind","ast::Group","ast::Repetition","hir::Capture","ast::RepetitionOp","ast::SetFlags","ast::ClassPerl","ast::ClassSetUnion","hir::ClassBytesRange","ast::AssertionKind","hir::Properties","ast::ClassAscii","hir::Class","ast::FlagsItem","hir::Literal","ast::ClassSetItem","std::clone::impls::<impl std::clone::Clone for *const T>","hir::Repetition","ast::Literal","hir::Look","ast::parse::Primitive","ast::Comment","hir::literal::Seq","hir::Error","ast::Error","ast::SpecialLiteralKind","ast::ClassPerlKind","ast::ClassSetBinaryOp","hir::ClassUnicodeRange","ast::RepetitionRange","ast::ClassUnicode","hir::literal::Literal","ast::Position","utf8::Utf8Sequence","ast::ClassAsciiKind","ast::RepetitionKind","either::Either","ast::LiteralKind","ast::Class","hir::PropertiesI","ast::ClassUnicodeOpKind","ast::Alternation","hir::ClassBytes","hir::ClassUnicode","ast::FlagsItemKind","ast::ClassBracketed","ast::ClassSetRange","ast::ClassUnicodeKind"],"Right":["hir::HirKind","ast::RepetitionRange","ast::WithComments","hir::literal::Seq","hir::literal::Literal","ast::Class","ast::ClassAscii","ast::Span","ast::ClassSetUnion","utf8::Utf8Range","ast::ClassSetBinaryOp","hir::Hir","ast::Group","ast::parse::Primitive","ast::LiteralKind","ast::Error","hir::Properties","ast::FlagsItemKind","hir::LookSet","ast::FlagsItem","ast::RepetitionOp","ast::ClassPerl","ast::HexLiteralKind","ast::ClassPerlKind","ast::Flags","ast::GroupKind","ast::Position","ast::ClassUnicodeOpKind","error::Error","ast::Repetition","either::Either","ast::ClassSetItem","hir::Literal","ast::SetFlags","utf8::Utf8Sequence","ast::ClassUnicode","std::clone::impls::<impl std::clone::Clone for *const T>","hir::Repetition","ast::ClassBracketed","hir::ErrorKind","ast::RepetitionKind","ast::Concat","hir::interval::IntervalSet","hir::Class","ast::ClassSet","ast::Literal","ast::Comment","hir::ClassBytesRange","ast::ClassAsciiKind","ast::AssertionKind","ast::Assertion","ast::Alternation","ast::SpecialLiteralKind","ast::Ast","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Look","hir::PropertiesI","hir::Error","ast::ClassUnicodeKind","ast::CaptureName","hir::Capture","ast::ClassSetBinaryOpKind","ast::ErrorKind","hir::Dot","hir::ClassBytes","ast::Flag","ast::ClassSetRange"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.clone();
+<hir::interval::IntervalSet<I> as std::clone::Clone>::clone(p0);
+crate::<hir::interval::IntervalSet<I> as std::clone::Clone>::clone(p0);
+<hir::interval::IntervalSet<I>>::clone(p0);
-----------------
src/hir/interval.rs <hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"either::Either":{"Left":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"],"Right":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"error::Formatter":{"E":["std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::clone::Clone","hir::interval::Interval","std::fmt::Debug"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt":{"I":["hir::Look","ast::CaptureName","hir::PropertiesI","ast::RepetitionRange","error::Error","ast::Comment","hir::literal::Seq","parser::Parser","hir::literal::State","ast::ClassUnicodeOpKind","unicode::ClassQuery","ast::ClassSetBinaryOpKind","either::Either","hir::literal::Extractor","hir::LookSetIter","ast::print::Writer","hir::translate::Translator","ast::Flag","hir::translate::TranslatorI","ast::RepetitionKind","hir::literal::PreferenceTrie","hir::Capture","ast::ClassBracketed","ast::parse::Parser","hir::Class","ast::ClassSetBinaryOp","ast::Error","hir::interval::IntervalSetIter","ast::ClassUnicodeKind","ast::ClassAsciiKind","hir::interval::IntervalSet","ast::ErrorKind","hir::translate::HirFrame","hir::ClassUnicodeRange","ast::ClassSetUnion","ast::HexLiteralKind","utf8::Utf8Range","ast::ClassSetItem","unicode::SimpleCaseFolder","hir::translate::TranslatorBuilder","ast::print::PrinterBuilder","hir::Hir","ast::visitor::ClassFrame","hir::ClassUnicode","hir::ErrorKind","ast::RepetitionOp","ast::parse::ParserBuilder","ast::Alternation","ast::parse::Primitive","ast::ClassSet","ast::Ast","parser::ParserBuilder","debug::Byte","ast::Concat","hir::translate::Flags","hir::print::Printer","ast::ClassUnicode","hir::Literal","unicode::CaseFoldError","ast::Class","ast::SpecialLiteralKind","hir::literal::Literal","<*mut T as std::fmt::Debug>","hir::print::Writer","ast::Literal","ast::Position","ast::ClassSetRange","ast::Flags","hir::Dot","ast::FlagsItemKind","ast::parse::ClassState","ast::ClassPerlKind","ast::Span","ast::LiteralKind","unicode::UnicodeWordError","debug::Bytes","hir::HirKind","ast::ClassAscii","hir::Error","hir::Repetition","ast::FlagsItem","ast::Group","hir::ClassBytes","hir::literal::ExtractKind","hir::LookSet","ast::print::Printer","unicode::Error","ast::SetFlags","hir::ClassUnicodeIter","ast::parse::ParserI","ast::GroupKind","ast::WithComments","utf8::ScalarRange","utf8::Utf8Sequence","ast::parse::NestLimiter","utf8::Utf8Sequences","ast::ClassPerl","ast::Assertion","hir::print::PrinterBuilder","ast::AssertionKind","ast::parse::GroupState","hir::ClassBytesRange","unicode::CanonicalClassQuery","error::Formatter","ast::visitor::ClassInduct","hir::Properties","ast::Repetition","hir::ClassBytesIter","<*const T as std::fmt::Debug>"]},"ast::parse::NestLimiter":{"P":["std::sync::Arc<T>","<&T as std::fmt::Debug>","std::rc::Rc<T>","std::string::String","std::path::PathBuf","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::ffi::CString","std::ffi::OsString"]},"ast::parse::ParserI":{"P":["std::sync::Arc<T>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::ffi::CString","std::string::String","std::clone::impls::<impl std::clone::Clone for &T>","std::ffi::OsString","std::rc::Rc<T>","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["either::Either","ast::ErrorKind","hir::PropertiesI","hir::Literal","ast::ClassUnicode","ast::RepetitionRange","ast::ClassSetItem","hir::ClassUnicode","ast::Comment","ast::RepetitionKind","ast::Assertion","hir::ClassUnicodeRange","ast::Literal","ast::GroupKind","ast::FlagsItemKind","ast::FlagsItem","hir::Repetition","hir::interval::IntervalSet","ast::ClassUnicodeKind","ast::Concat","ast::Position","ast::Repetition","hir::ErrorKind","utf8::Utf8Range","ast::ClassSetUnion","ast::Alternation","hir::LookSet","hir::Hir","ast::Class","ast::ClassSetBinaryOp","ast::Error","ast::ClassAscii","utf8::Utf8Sequence","hir::literal::Seq","hir::literal::Literal","ast::HexLiteralKind","ast::AssertionKind","ast::LiteralKind","ast::Ast","hir::HirKind","hir::Error","<*const T as std::fmt::Debug>","ast::ClassSetBinaryOpKind","hir::Capture","hir::Look","hir::ClassBytes","hir::Class","ast::ClassUnicodeOpKind","ast::Flags","ast::WithComments","ast::ClassPerlKind","ast::Group","ast::parse::Primitive","ast::SetFlags","ast::ClassPerl","ast::Flag","ast::Span","ast::ClassSetRange","ast::ClassBracketed","ast::CaptureName","hir::Dot","hir::ClassBytesRange","ast::ClassAsciiKind","ast::SpecialLiteralKind","error::Error","ast::ClassSet","ast::RepetitionOp","hir::Properties"],"Right":["ast::Repetition","hir::interval::IntervalSet","ast::Alternation","ast::Literal","ast::FlagsItemKind","ast::Comment","ast::ClassSetRange","hir::Properties","ast::Group","ast::Assertion","ast::SpecialLiteralKind","ast::ErrorKind","ast::ClassAscii","hir::HirKind","hir::Capture","ast::Class","hir::Look","ast::SetFlags","hir::Repetition","hir::PropertiesI","ast::ClassPerl","ast::ClassSetUnion","ast::Flags","ast::GroupKind","ast::CaptureName","utf8::Utf8Sequence","hir::ClassBytesRange","hir::Literal","hir::literal::Seq","ast::Error","ast::ClassSet","ast::HexLiteralKind","ast::ClassAsciiKind","ast::ClassUnicode","ast::Ast","utf8::Utf8Range","ast::Span","error::Error","ast::RepetitionKind","hir::ClassBytes","ast::Concat","ast::WithComments","hir::Class","hir::Error","hir::ClassUnicode","hir::ClassUnicodeRange","ast::RepetitionRange","ast::ClassSetBinaryOp","hir::Hir","ast::RepetitionOp","ast::Flag","hir::ErrorKind","either::Either","ast::ClassUnicodeKind","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::ClassBracketed","ast::ClassUnicodeOpKind","hir::literal::Literal","hir::Dot","ast::parse::Primitive","ast::LiteralKind","ast::AssertionKind","ast::ClassSetBinaryOpKind","ast::FlagsItem","ast::ClassSetItem","hir::LookSet","ast::ClassPerlKind","ast::Position"]},"error::Formatter":{"E":["hir::ErrorKind","error::Error","hir::Error","error::Formatter","<&T as std::fmt::Display>","unicode::UnicodeWordError","ast::Error","ast::Ast","ast::ErrorKind","unicode::CaseFoldError","hir::Hir"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["utf8::Utf8Range","hir::Look","ast::parse::Parser","ast::visitor::ClassFrame","hir::ClassUnicodeRange","ast::FlagsItem","hir::literal::Literal","hir::print::Printer","hir::literal::State","debug::Byte","<*mut T as std::fmt::Debug>","ast::ClassUnicodeKind","ast::ClassAscii","ast::Concat","ast::Literal","ast::RepetitionOp","ast::FlagsItemKind","error::Error","unicode::CaseFoldError","hir::ClassBytes","hir::ClassUnicodeIter","parser::Parser","ast::Ast","ast::Comment","ast::Group","hir::print::PrinterBuilder","hir::translate::TranslatorBuilder","hir::translate::Translator","ast::parse::Primitive","ast::HexLiteralKind","either::Either","unicode::UnicodeWordError","ast::Flags","ast::ClassPerlKind","parser::ParserBuilder","hir::LookSetIter","ast::SetFlags","hir::Dot","ast::ClassAsciiKind","hir::Literal","hir::print::Writer","hir::interval::IntervalSetIter","ast::ClassSetBinaryOpKind","hir::Hir","ast::Repetition","hir::literal::PreferenceTrie","ast::ClassUnicode","ast::CaptureName","ast::Flag","ast::ClassSetBinaryOp","ast::parse::ParserBuilder","ast::Alternation","unicode::CanonicalClassQuery","ast::ClassPerl","hir::Error","ast::LiteralKind","ast::Assertion","hir::Properties","hir::literal::Extractor","ast::ClassUnicodeOpKind","unicode::ClassQuery","hir::LookSet","hir::PropertiesI","ast::Error","utf8::Utf8Sequence","hir::ClassBytesRange","hir::Class","hir::ClassBytesIter","ast::parse::NestLimiter","ast::ClassSetItem","utf8::ScalarRange","hir::interval::IntervalSet","ast::Span","unicode::Error","hir::literal::Seq","ast::parse::ParserI","ast::parse::ClassState","ast::AssertionKind","ast::RepetitionKind","hir::literal::ExtractKind","hir::ErrorKind","hir::Capture","ast::WithComments","hir::ClassUnicode","hir::Repetition","ast::print::PrinterBuilder","ast::GroupKind","ast::SpecialLiteralKind","hir::translate::TranslatorI","ast::ClassSetRange","ast::visitor::ClassInduct","ast::Class","debug::Bytes","error::Formatter","unicode::SimpleCaseFolder","ast::ClassSet","ast::print::Writer","utf8::Utf8Sequences","ast::ClassSetUnion","ast::print::Printer","ast::Position","hir::translate::Flags","ast::parse::GroupState","hir::translate::HirFrame","ast::ErrorKind","ast::ClassBracketed","ast::RepetitionRange","hir::HirKind"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt(p0, p1);
+<hir::interval::IntervalSet<I>>::fmt(p0, p1);
-----------------
src/hir/interval.rs <hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq
deps:{"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.eq(p1);
+<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq(p0, p1);
+<hir::interval::IntervalSet<I>>::eq(p0, p1);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized","std::clone::Clone"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"either::Either":{"Left":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"],"Right":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","hir::interval::Interval","std::clone::Clone","std::fmt::Debug"]},"hir::interval::IntervalSet::<I>::new":{"I":["hir::interval::Interval","std::marker::Sized"],"T":["std::iter::IntoIterator","std::marker::Sized"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["hir::ClassUnicodeIter","hir::ClassBytesIter","utf8::Utf8Sequences","hir::interval::IntervalSetIter","<&mut I as std::iter::Iterator>","hir::LookSetIter"]},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::string::String","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::ffi::CString","std::path::PathBuf","std::rc::Rc<T>","std::vec::Vec<T, A>","std::sync::Arc<T>"]},"ast::parse::ParserI":{"P":["<&T as std::fmt::Debug>","std::ffi::OsString","std::string::String","std::rc::Rc<T>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::path::PathBuf","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::ClassSetRange","ast::Ast","hir::interval::IntervalSet","hir::ClassUnicode","hir::Repetition","ast::Error","ast::ClassAscii","ast::Span","error::Error","ast::Position","ast::ClassUnicodeOpKind","ast::parse::Primitive","ast::Flags","<*mut T as std::fmt::Debug>","ast::LiteralKind","hir::Class","ast::FlagsItemKind","ast::ClassSetUnion","hir::literal::Literal","ast::ClassBracketed","ast::AssertionKind","utf8::Utf8Sequence","hir::Literal","ast::Concat","either::Either","hir::ClassBytesRange","hir::Dot","utf8::Utf8Range","ast::Group","ast::ClassPerl","ast::CaptureName","ast::SpecialLiteralKind","ast::Assertion","ast::ClassAsciiKind","ast::Class","ast::Flag","hir::Hir","ast::RepetitionKind","ast::ErrorKind","hir::HirKind","hir::ErrorKind","ast::Literal","hir::Properties","ast::ClassUnicode","hir::Error","hir::ClassUnicodeRange","ast::ClassSetItem","ast::SetFlags","ast::Repetition","ast::Alternation","ast::ClassPerlKind","ast::WithComments","hir::literal::Seq","ast::RepetitionRange","ast::RepetitionOp","hir::LookSet","hir::Capture","ast::FlagsItem","ast::HexLiteralKind","ast::ClassUnicodeKind","ast::ClassSetBinaryOp","hir::Look","ast::ClassSet","ast::Comment","hir::PropertiesI","hir::ClassBytes","ast::ClassSetBinaryOpKind","ast::GroupKind"],"Right":["ast::RepetitionRange","hir::literal::Literal","ast::ClassSetBinaryOp","ast::Flag","ast::ClassSetUnion","ast::Assertion","hir::Capture","hir::Literal","ast::FlagsItemKind","hir::ErrorKind","ast::ClassAscii","ast::ClassUnicodeKind","ast::Position","hir::ClassBytesRange","ast::Group","ast::RepetitionKind","ast::ClassSetBinaryOpKind","ast::ClassPerl","hir::Error","hir::ClassUnicodeRange","ast::CaptureName","hir::ClassUnicode","error::Error","ast::SetFlags","ast::FlagsItem","ast::ClassSetRange","hir::ClassBytes","ast::Concat","hir::PropertiesI","ast::parse::Primitive","ast::ClassAsciiKind","hir::LookSet","hir::Properties","hir::Look","hir::Class","ast::LiteralKind","hir::Dot","ast::Error","ast::HexLiteralKind","utf8::Utf8Sequence","ast::ClassUnicode","hir::Hir","ast::Repetition","hir::Repetition","ast::ClassSet","ast::RepetitionOp","ast::ErrorKind","ast::ClassPerlKind","ast::Span","hir::literal::Seq","ast::ClassSetItem","hir::HirKind","ast::ClassUnicodeOpKind","ast::ClassBracketed","ast::AssertionKind","ast::Ast","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::GroupKind","ast::SpecialLiteralKind","ast::Literal","ast::WithComments","ast::Flags","utf8::Utf8Range","ast::Comment","hir::interval::IntervalSet","either::Either","ast::Alternation","ast::Class"]},"error::Formatter":{"E":["<&T as std::fmt::Display>","hir::Error","hir::Hir","ast::Error","ast::ErrorKind","unicode::UnicodeWordError","ast::Ast","error::Error","unicode::CaseFoldError","hir::ErrorKind","error::Formatter"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSet::<I>::new":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"],"T":["<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>"]},"hir::interval::IntervalSetIter":{"I":["ast::parse::ParserBuilder","hir::translate::HirFrame","hir::PropertiesI","hir::literal::ExtractKind","hir::literal::State","hir::LookSet","ast::ClassSetBinaryOp","ast::FlagsItem","ast::RepetitionOp","ast::parse::Parser","hir::translate::TranslatorI","utf8::Utf8Range","unicode::CaseFoldError","hir::ClassBytesIter","ast::CaptureName","hir::Look","ast::ClassSetBinaryOpKind","ast::parse::Primitive","hir::translate::Flags","utf8::Utf8Sequences","ast::Ast","ast::ClassAscii","ast::Flag","ast::LiteralKind","ast::Comment","hir::ClassBytes","ast::FlagsItemKind","ast::ClassUnicodeOpKind","parser::Parser","ast::WithComments","debug::Byte","ast::RepetitionKind","ast::parse::ClassState","hir::print::Writer","ast::Position","ast::parse::GroupState","unicode::UnicodeWordError","ast::ErrorKind","ast::ClassPerlKind","hir::ClassUnicode","hir::interval::IntervalSetIter","ast::HexLiteralKind","unicode::CanonicalClassQuery","hir::translate::Translator","hir::literal::Literal","ast::SetFlags","ast::ClassBracketed","hir::HirKind","ast::Assertion","debug::Bytes","hir::Repetition","ast::ClassSetItem","hir::ErrorKind","ast::AssertionKind","hir::Error","ast::parse::NestLimiter","hir::Capture","hir::literal::PreferenceTrie","utf8::ScalarRange","hir::Hir","hir::ClassUnicodeRange","<&T as std::fmt::Debug>","ast::RepetitionRange","hir::ClassUnicodeIter","hir::Properties","ast::Literal","unicode::ClassQuery","error::Formatter","unicode::SimpleCaseFolder","ast::ClassSet","hir::Dot","hir::literal::Extractor","ast::Group","ast::Error","ast::Repetition","ast::Flags","ast::print::Writer","unicode::Error","ast::Class","ast::print::PrinterBuilder","ast::Span","hir::interval::IntervalSet","ast::Alternation","hir::literal::Seq","hir::translate::TranslatorBuilder","ast::SpecialLiteralKind","ast::print::Printer","error::Error","ast::ClassAsciiKind","ast::visitor::ClassInduct","either::Either","hir::LookSetIter","hir::print::Printer","parser::ParserBuilder","ast::ClassPerl","ast::visitor::ClassFrame","ast::Concat","ast::parse::ParserI","ast::ClassUnicode","hir::ClassBytesRange","ast::GroupKind","utf8::Utf8Sequence","ast::ClassSetRange","hir::Literal","ast::ClassSetUnion","ast::ClassUnicodeKind","hir::print::PrinterBuilder","hir::Class"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+hir::interval::IntervalSet::<I>::new(p0);
+crate::hir::interval::IntervalSet::<I>::new(p0);
+<hir::interval::IntervalSet<I>>::new(p0);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::push
deps:{"hir::interval::IntervalSet::<I>::push":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::push":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.push(p1);
+hir::interval::IntervalSet::<I>::push(p0, p1);
+crate::hir::interval::IntervalSet::<I>::push(p0, p1);
+<hir::interval::IntervalSet<I>>::push(p0, p1);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::iter
deps:{"hir::interval::IntervalSet::<I>::iter":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::iter":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.iter();
+hir::interval::IntervalSet::<I>::iter(p0);
+crate::hir::interval::IntervalSet::<I>::iter(p0);
+<hir::interval::IntervalSet<I>>::iter(p0);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::intervals
deps:{"hir::interval::IntervalSet::<I>::intervals":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::intervals":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.intervals();
+hir::interval::IntervalSet::<I>::intervals(p0);
+crate::hir::interval::IntervalSet::<I>::intervals(p0);
+<hir::interval::IntervalSet<I>>::intervals(p0);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::case_fold_simple
deps:{"hir::interval::IntervalSet::<I>::case_fold_simple":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::case_fold_simple":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.case_fold_simple();
+hir::interval::IntervalSet::<I>::case_fold_simple(p0);
+crate::hir::interval::IntervalSet::<I>::case_fold_simple(p0);
+<hir::interval::IntervalSet<I>>::case_fold_simple(p0);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::union
deps:{"hir::interval::IntervalSet::<I>::union":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::union":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.union(p1);
+hir::interval::IntervalSet::<I>::union(p0, p1);
+crate::hir::interval::IntervalSet::<I>::union(p0, p1);
+<hir::interval::IntervalSet<I>>::union(p0, p1);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::intersect
deps:{"hir::interval::IntervalSet::<I>::intersect":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::intersect":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.intersect(p1);
+hir::interval::IntervalSet::<I>::intersect(p0, p1);
+crate::hir::interval::IntervalSet::<I>::intersect(p0, p1);
+<hir::interval::IntervalSet<I>>::intersect(p0, p1);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::difference
deps:{"hir::interval::IntervalSet::<I>::difference":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::difference":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.difference(p1);
+hir::interval::IntervalSet::<I>::difference(p0, p1);
+crate::hir::interval::IntervalSet::<I>::difference(p0, p1);
+<hir::interval::IntervalSet<I>>::difference(p0, p1);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::symmetric_difference
deps:{"hir::interval::IntervalSet::<I>::symmetric_difference":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::symmetric_difference":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.symmetric_difference(p1);
+hir::interval::IntervalSet::<I>::symmetric_difference(p0, p1);
+crate::hir::interval::IntervalSet::<I>::symmetric_difference(p0, p1);
+<hir::interval::IntervalSet<I>>::symmetric_difference(p0, p1);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::negate
deps:{"hir::interval::IntervalSet::<I>::negate":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::negate":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.negate();
+hir::interval::IntervalSet::<I>::negate(p0);
+crate::hir::interval::IntervalSet::<I>::negate(p0);
+<hir::interval::IntervalSet<I>>::negate(p0);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::canonicalize
deps:{"hir::interval::IntervalSet::<I>::canonicalize":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::canonicalize":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.canonicalize();
+hir::interval::IntervalSet::<I>::canonicalize(p0);
+crate::hir::interval::IntervalSet::<I>::canonicalize(p0);
+<hir::interval::IntervalSet<I>>::canonicalize(p0);
-----------------
src/hir/interval.rs hir::interval::IntervalSet::<I>::is_canonical
deps:{"hir::interval::IntervalSet::<I>::is_canonical":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::is_canonical":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.is_canonical();
+hir::interval::IntervalSet::<I>::is_canonical(p0);
+crate::hir::interval::IntervalSet::<I>::is_canonical(p0);
+<hir::interval::IntervalSet<I>>::is_canonical(p0);
-----------------
src/hir/interval.rs <hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt":{"I":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"either::Either":{"Left":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"],"Right":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["hir::interval::Interval","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt":{"I":["unicode::ClassQuery","parser::Parser","ast::ClassSetRange","ast::ClassSet","ast::Error","hir::Dot","ast::parse::Parser","ast::ClassBracketed","ast::ClassSetItem","ast::parse::ParserBuilder","ast::ClassUnicode","ast::ClassPerl","unicode::SimpleCaseFolder","hir::Capture","either::Either","ast::visitor::ClassFrame","hir::print::PrinterBuilder","ast::Concat","hir::ClassBytesRange","utf8::ScalarRange","ast::ClassSetUnion","hir::literal::Seq","ast::Literal","ast::print::Writer","hir::literal::PreferenceTrie","ast::Class","hir::ClassBytesIter","ast::WithComments","hir::Literal","ast::ClassUnicodeKind","unicode::UnicodeWordError","ast::ErrorKind","hir::translate::Translator","unicode::CanonicalClassQuery","ast::visitor::ClassInduct","ast::FlagsItem","<*mut T as std::fmt::Debug>","hir::literal::ExtractKind","hir::ClassUnicodeRange","error::Formatter","ast::ClassPerlKind","ast::HexLiteralKind","ast::ClassAscii","ast::Assertion","ast::ClassSetBinaryOp","ast::GroupKind","ast::parse::ClassState","ast::RepetitionKind","ast::print::PrinterBuilder","debug::Bytes","hir::translate::Flags","ast::Flag","ast::Span","hir::Class","ast::Ast","ast::ClassAsciiKind","ast::print::Printer","ast::Position","hir::ClassUnicode","error::Error","ast::SetFlags","ast::RepetitionRange","ast::parse::NestLimiter","hir::print::Writer","hir::Properties","hir::Error","utf8::Utf8Sequence","hir::PropertiesI","hir::literal::Extractor","hir::HirKind","hir::translate::TranslatorBuilder","ast::AssertionKind","ast::Repetition","hir::ClassUnicodeIter","hir::Hir","ast::Comment","hir::literal::State","unicode::Error","<&T as std::fmt::Debug>","hir::Repetition","utf8::Utf8Range","ast::parse::Primitive","hir::interval::IntervalSetIter","ast::SpecialLiteralKind","hir::LookSetIter","hir::ClassBytes","hir::translate::TranslatorI","ast::Flags","hir::Look","hir::translate::HirFrame","ast::ClassSetBinaryOpKind","ast::LiteralKind","ast::ClassUnicodeOpKind","debug::Byte","ast::Alternation","parser::ParserBuilder","ast::CaptureName","hir::LookSet","hir::print::Printer","hir::literal::Literal","utf8::Utf8Sequences","unicode::CaseFoldError","ast::FlagsItemKind","hir::ErrorKind","ast::Group","ast::parse::GroupState","hir::interval::IntervalSet","ast::RepetitionOp","ast::parse::ParserI"]},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::path::PathBuf","std::rc::Rc<T>","std::string::String","std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::CString","<&T as std::fmt::Debug>","std::boxed::Box<T, A>"]},"ast::parse::ParserI":{"P":["std::rc::Rc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::path::PathBuf","<&mut T as std::fmt::Debug>","std::ffi::CString","std::ffi::OsString","std::sync::Arc<T>","std::string::String"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["hir::LookSet","ast::RepetitionOp","hir::Look","ast::Position","ast::Concat","hir::ClassUnicode","ast::ClassSet","hir::Capture","hir::Error","ast::ClassSetBinaryOp","ast::ClassSetRange","ast::RepetitionKind","hir::ErrorKind","ast::Alternation","ast::FlagsItem","hir::HirKind","ast::Error","ast::ClassBracketed","ast::ErrorKind","ast::CaptureName","utf8::Utf8Sequence","hir::ClassBytesRange","ast::Flags","ast::Repetition","ast::parse::Primitive","ast::ClassSetBinaryOpKind","ast::SpecialLiteralKind","ast::ClassPerl","hir::Class","ast::AssertionKind","ast::GroupKind","ast::WithComments","hir::ClassBytes","ast::Group","hir::Properties","ast::Flag","ast::HexLiteralKind","std::clone::impls::<impl std::clone::Clone for *const T>","hir::Hir","ast::ClassSetItem","utf8::Utf8Range","ast::ClassSetUnion","ast::ClassAsciiKind","ast::Span","ast::SetFlags","ast::LiteralKind","ast::FlagsItemKind","error::Error","ast::Comment","ast::ClassPerlKind","hir::Literal","hir::ClassUnicodeRange","either::Either","hir::Dot","ast::Class","hir::interval::IntervalSet","hir::literal::Literal","ast::ClassUnicode","ast::Assertion","hir::literal::Seq","hir::PropertiesI","ast::Literal","ast::RepetitionRange","hir::Repetition","ast::ClassUnicodeKind","ast::Ast","ast::ClassAscii","ast::ClassUnicodeOpKind"],"Right":["hir::ClassBytes","ast::SetFlags","ast::Literal","ast::SpecialLiteralKind","hir::Repetition","hir::Error","hir::Literal","ast::ClassSetBinaryOpKind","hir::ClassUnicode","hir::Class","ast::Flags","ast::ClassUnicodeKind","hir::Dot","ast::RepetitionKind","ast::Repetition","ast::ClassAsciiKind","hir::ClassUnicodeRange","ast::Comment","ast::ClassAscii","ast::Group","ast::Ast","hir::literal::Literal","ast::parse::Primitive","ast::HexLiteralKind","ast::Span","ast::ClassSetItem","ast::Concat","ast::FlagsItem","hir::Hir","ast::Error","error::Error","hir::ErrorKind","ast::ClassSet","ast::RepetitionOp","hir::ClassBytesRange","ast::ClassSetRange","utf8::Utf8Sequence","ast::GroupKind","hir::Properties","ast::CaptureName","ast::Class","hir::interval::IntervalSet","hir::HirKind","ast::Alternation","hir::Capture","ast::ClassBracketed","ast::Position","ast::ClassPerl","ast::ClassSetUnion","ast::RepetitionRange","hir::literal::Seq","hir::LookSet","utf8::Utf8Range","either::Either","ast::FlagsItemKind","ast::AssertionKind","hir::Look","ast::ErrorKind","ast::Flag","ast::LiteralKind","ast::Assertion","<*mut T as std::fmt::Debug>","ast::ClassUnicodeOpKind","ast::WithComments","ast::ClassSetBinaryOp","hir::PropertiesI","ast::ClassUnicode","ast::ClassPerlKind"]},"error::Formatter":{"E":["<&mut T as std::fmt::Display>","unicode::CaseFoldError","hir::Hir","error::Formatter","ast::Ast","unicode::UnicodeWordError","ast::ErrorKind","hir::Error","error::Error","hir::ErrorKind","ast::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::visitor::ClassInduct","hir::Properties","unicode::CanonicalClassQuery","hir::print::Printer","utf8::Utf8Sequences","ast::parse::NestLimiter","hir::interval::IntervalSetIter","ast::Ast","ast::Span","ast::ClassSetBinaryOp","hir::ClassBytesRange","hir::Repetition","hir::literal::ExtractKind","hir::ClassUnicodeRange","ast::parse::Parser","hir::Look","hir::ClassUnicode","hir::ClassBytesIter","either::Either","ast::print::Printer","unicode::Error","hir::Literal","hir::LookSetIter","ast::Error","ast::CaptureName","ast::Repetition","hir::ErrorKind","ast::ClassUnicode","ast::ClassSet","hir::translate::Translator","hir::ClassBytes","utf8::ScalarRange","ast::ClassSetUnion","ast::Flags","ast::ClassSetItem","ast::HexLiteralKind","ast::parse::Primitive","ast::Class","ast::WithComments","parser::Parser","ast::parse::GroupState","ast::AssertionKind","<&mut T as std::fmt::Debug>","hir::LookSet","ast::Assertion","debug::Bytes","ast::ClassUnicodeOpKind","ast::ClassAsciiKind","ast::ClassBracketed","hir::translate::Flags","ast::Group","ast::SpecialLiteralKind","ast::print::Writer","hir::Class","error::Formatter","ast::RepetitionKind","ast::ClassSetBinaryOpKind","ast::SetFlags","ast::Concat","hir::Capture","ast::ClassPerlKind","hir::translate::HirFrame","hir::literal::Literal","hir::Dot","utf8::Utf8Sequence","ast::visitor::ClassFrame","hir::ClassUnicodeIter","ast::RepetitionOp","ast::ClassUnicodeKind","ast::LiteralKind","ast::RepetitionRange","ast::ErrorKind","hir::literal::State","unicode::ClassQuery","ast::print::PrinterBuilder","ast::Literal","hir::translate::TranslatorI","ast::parse::ClassState","ast::FlagsItemKind","hir::print::Writer","ast::FlagsItem","hir::translate::TranslatorBuilder","hir::literal::Extractor","unicode::CaseFoldError","utf8::Utf8Range","hir::Hir","hir::print::PrinterBuilder","ast::Flag","hir::Error","error::Error","hir::literal::PreferenceTrie","ast::ClassSetRange","unicode::UnicodeWordError","ast::parse::ParserI","ast::ClassAscii","hir::PropertiesI","parser::ParserBuilder","unicode::SimpleCaseFolder","debug::Byte","ast::Comment","hir::HirKind","ast::ClassPerl","hir::interval::IntervalSet","ast::Position","hir::literal::Seq","ast::GroupKind","ast::parse::ParserBuilder","ast::Alternation"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSetIter<'a, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt(p0, p1);
+<hir::interval::IntervalSetIter<'a, I>>::fmt(p0, p1);
-----------------
src/hir/interval.rs <hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next
'a
deps:{"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":{"I":["std::marker::Sized"]}}
candidates:{"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":{"I":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSetIter<'a, I>
+p0.next();
+<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next(p0);
+crate::<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next(p0);
+<hir::interval::IntervalSetIter<'a, I>>::next(p0);
-----------------
src/hir/interval.rs <u8 as hir::interval::Bound>::min_value
deps:{}
candidates:{}
+<u8 as hir::interval::Bound>::min_value();
+crate::<u8 as hir::interval::Bound>::min_value();
+<u8>::min_value();
-----------------
src/hir/interval.rs <u8 as hir::interval::Bound>::max_value
deps:{}
candidates:{}
+<u8 as hir::interval::Bound>::max_value();
+crate::<u8 as hir::interval::Bound>::max_value();
+<u8>::max_value();
-----------------
src/hir/interval.rs <u8 as hir::interval::Bound>::as_u32
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_u32();
+<u8 as hir::interval::Bound>::as_u32(p0);
+crate::<u8 as hir::interval::Bound>::as_u32(p0);
+<u8>::as_u32(p0);
-----------------
src/hir/interval.rs <u8 as hir::interval::Bound>::increment
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.increment();
+<u8 as hir::interval::Bound>::increment(p0);
+crate::<u8 as hir::interval::Bound>::increment(p0);
+<u8>::increment(p0);
-----------------
src/hir/interval.rs <u8 as hir::interval::Bound>::decrement
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.decrement();
+<u8 as hir::interval::Bound>::decrement(p0);
+crate::<u8 as hir::interval::Bound>::decrement(p0);
+<u8>::decrement(p0);
-----------------
src/hir/interval.rs <char as hir::interval::Bound>::min_value
deps:{}
candidates:{}
+<char as hir::interval::Bound>::min_value();
+crate::<char as hir::interval::Bound>::min_value();
+<char>::min_value();
-----------------
src/hir/interval.rs <char as hir::interval::Bound>::max_value
deps:{}
candidates:{}
+<char as hir::interval::Bound>::max_value();
+crate::<char as hir::interval::Bound>::max_value();
+<char>::max_value();
-----------------
src/hir/interval.rs <char as hir::interval::Bound>::as_u32
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_u32();
+<char as hir::interval::Bound>::as_u32(p0);
+crate::<char as hir::interval::Bound>::as_u32(p0);
+<char>::as_u32(p0);
-----------------
src/hir/interval.rs <char as hir::interval::Bound>::increment
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.increment();
+<char as hir::interval::Bound>::increment(p0);
+crate::<char as hir::interval::Bound>::increment(p0);
+<char>::increment(p0);
-----------------
src/hir/interval.rs <char as hir::interval::Bound>::decrement
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.decrement();
+<char as hir::interval::Bound>::decrement(p0);
+crate::<char as hir::interval::Bound>::decrement(p0);
+<char>::decrement(p0);
-----------------
src/hir/literal.rs <hir::literal::Extractor as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
+p0.clone();
+<hir::literal::Extractor as std::clone::Clone>::clone(p0);
+crate::<hir::literal::Extractor as std::clone::Clone>::clone(p0);
+<hir::literal::Extractor>::clone(p0);
-----------------
src/hir/literal.rs <hir::literal::Extractor as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::Extractor as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::Extractor as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::Extractor>::fmt(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::new
deps:{}
candidates:{}
+hir::literal::Extractor::new();
+crate::hir::literal::Extractor::new();
+<hir::literal::Extractor>::new();
-----------------
src/hir/literal.rs hir::literal::Extractor::extract
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.extract(p1);
+hir::literal::Extractor::extract(p0, p1);
+crate::hir::literal::Extractor::extract(p0, p1);
+<hir::literal::Extractor>::extract(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::kind
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::literal::ExtractKind
+p0.kind(p1);
+hir::literal::Extractor::kind(p0, p1);
+crate::hir::literal::Extractor::kind(p0, p1);
+<hir::literal::Extractor>::kind(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::limit_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = 0usize; // None+usize
+p0.limit_class(p1);
+hir::literal::Extractor::limit_class(p0, p1);
+crate::hir::literal::Extractor::limit_class(p0, p1);
+<hir::literal::Extractor>::limit_class(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::limit_repeat
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = 0usize; // None+usize
+p0.limit_repeat(p1);
+hir::literal::Extractor::limit_repeat(p0, p1);
+crate::hir::literal::Extractor::limit_repeat(p0, p1);
+<hir::literal::Extractor>::limit_repeat(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::limit_literal_len
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = 0usize; // None+usize
+p0.limit_literal_len(p1);
+hir::literal::Extractor::limit_literal_len(p0, p1);
+crate::hir::literal::Extractor::limit_literal_len(p0, p1);
+<hir::literal::Extractor>::limit_literal_len(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::limit_total
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = 0usize; // None+usize
+p0.limit_total(p1);
+hir::literal::Extractor::limit_total(p0, p1);
+crate::hir::literal::Extractor::limit_total(p0, p1);
+<hir::literal::Extractor>::limit_total(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::extract_concat
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"either::Either":{"Left":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"],"Right":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::clone::Clone","hir::interval::Interval","std::fmt::Debug"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::literal::Extractor::extract_concat":{"I":["std::marker::Sized","std::iter::Iterator"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::ffi::CString","std::rc::Rc<T>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::string::String","std::path::PathBuf"]},"ast::parse::ParserI":{"P":["std::ffi::OsString","std::boxed::Box<T, A>","std::path::PathBuf","std::ffi::CString","std::string::String","std::vec::Vec<T, A>","std::clone::impls::<impl std::clone::Clone for &mut T>","std::sync::Arc<T>","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","hir::Properties","ast::Ast","ast::SetFlags","ast::Concat","ast::Error","ast::ClassSetRange","ast::AssertionKind","ast::Class","ast::ErrorKind","ast::ClassSetBinaryOp","ast::ClassUnicode","ast::HexLiteralKind","ast::SpecialLiteralKind","hir::Error","ast::ClassPerl","hir::interval::IntervalSet","hir::LookSet","hir::ClassBytesRange","hir::Look","hir::Repetition","ast::ClassUnicodeKind","hir::literal::Seq","hir::Capture","ast::RepetitionKind","ast::Position","ast::Literal","ast::FlagsItem","ast::Comment","hir::Class","hir::PropertiesI","ast::ClassSetBinaryOpKind","ast::LiteralKind","ast::ClassPerlKind","hir::Dot","ast::ClassAscii","ast::Repetition","ast::ClassSetItem","ast::Flag","ast::ClassSet","hir::Literal","utf8::Utf8Sequence","ast::ClassAsciiKind","ast::CaptureName","either::Either","ast::ClassBracketed","ast::FlagsItemKind","ast::GroupKind","ast::parse::Primitive","ast::Span","hir::literal::Literal","hir::Hir","utf8::Utf8Range","hir::HirKind","ast::Group","ast::RepetitionOp","ast::Assertion","ast::RepetitionRange","error::Error","ast::ClassSetUnion","ast::Alternation","hir::ClassUnicodeRange","ast::WithComments","ast::ClassUnicodeOpKind","ast::Flags","hir::ClassUnicode","hir::ErrorKind","hir::ClassBytes"],"Right":["ast::ClassSetBinaryOp","hir::LookSet","<*mut T as std::fmt::Debug>","ast::SetFlags","ast::ClassPerl","hir::PropertiesI","hir::ErrorKind","ast::Repetition","hir::Look","ast::Comment","ast::RepetitionOp","hir::Hir","ast::Position","ast::ClassSetUnion","ast::LiteralKind","ast::Flag","ast::FlagsItem","ast::ClassUnicodeKind","hir::literal::Literal","ast::Class","ast::AssertionKind","either::Either","hir::ClassUnicode","ast::RepetitionKind","ast::Span","ast::RepetitionRange","hir::Repetition","ast::HexLiteralKind","ast::ClassPerlKind","ast::Literal","ast::Concat","hir::Class","ast::Flags","ast::parse::Primitive","ast::SpecialLiteralKind","ast::CaptureName","ast::ClassAsciiKind","ast::ClassAscii","error::Error","ast::FlagsItemKind","ast::Group","ast::Error","hir::interval::IntervalSet","hir::ClassBytes","hir::Properties","ast::ClassSetRange","hir::HirKind","ast::WithComments","ast::ClassSetItem","ast::Ast","hir::Error","hir::Capture","utf8::Utf8Sequence","hir::ClassUnicodeRange","utf8::Utf8Range","hir::literal::Seq","ast::ClassUnicodeOpKind","ast::ClassUnicode","hir::Literal","ast::Assertion","ast::Alternation","ast::ErrorKind","ast::ClassBracketed","ast::ClassSetBinaryOpKind","hir::ClassBytesRange","hir::Dot","ast::GroupKind","ast::ClassSet"]},"error::Formatter":{"E":["error::Error","error::Formatter","hir::Hir","<&T as std::fmt::Display>","unicode::CaseFoldError","unicode::UnicodeWordError","hir::Error","ast::Error","ast::Ast","ast::ErrorKind","hir::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::ClassAsciiKind","unicode::Error","hir::Error","ast::print::Printer","ast::ClassPerl","ast::AssertionKind","hir::translate::Flags","hir::translate::TranslatorBuilder","ast::HexLiteralKind","ast::Flags","hir::Capture","ast::Comment","ast::visitor::ClassFrame","unicode::UnicodeWordError","utf8::Utf8Range","ast::ClassPerlKind","ast::CaptureName","<&T as std::fmt::Debug>","unicode::SimpleCaseFolder","parser::ParserBuilder","hir::ClassBytesRange","hir::ClassBytes","ast::Alternation","hir::ClassBytesIter","ast::FlagsItemKind","ast::RepetitionRange","unicode::ClassQuery","hir::literal::ExtractKind","ast::parse::ParserBuilder","hir::LookSet","ast::parse::GroupState","ast::Concat","hir::PropertiesI","ast::SetFlags","ast::Flag","hir::ClassUnicodeRange","hir::ClassUnicode","hir::ClassUnicodeIter","ast::parse::ClassState","ast::parse::ParserI","ast::ErrorKind","hir::HirKind","ast::ClassUnicodeKind","ast::Error","ast::RepetitionKind","error::Error","ast::WithComments","hir::literal::Extractor","debug::Bytes","ast::SpecialLiteralKind","utf8::ScalarRange","ast::GroupKind","ast::RepetitionOp","hir::Dot","hir::literal::Seq","hir::Look","hir::literal::Literal","hir::interval::IntervalSetIter","ast::FlagsItem","hir::translate::HirFrame","ast::Group","hir::literal::PreferenceTrie","ast::parse::Parser","hir::Properties","ast::parse::Primitive","hir::literal::State","unicode::CaseFoldError","ast::ClassUnicode","ast::ClassBracketed","ast::ClassUnicodeOpKind","hir::LookSetIter","ast::LiteralKind","ast::ClassSetRange","hir::ErrorKind","hir::Literal","hir::interval::IntervalSet","ast::ClassAscii","ast::Literal","ast::Span","ast::Ast","hir::print::Writer","debug::Byte","ast::Class","hir::translate::TranslatorI","ast::ClassSetUnion","ast::Position","hir::translate::Translator","utf8::Utf8Sequence","ast::print::Writer","either::Either","ast::ClassSetBinaryOpKind","utf8::Utf8Sequences","error::Formatter","hir::print::PrinterBuilder","ast::Assertion","ast::Repetition","hir::print::Printer","hir::Hir","ast::ClassSetBinaryOp","ast::print::PrinterBuilder","ast::ClassSet","hir::Repetition","hir::Class","unicode::CanonicalClassQuery","parser::Parser","ast::visitor::ClassInduct","ast::ClassSetItem","ast::parse::NestLimiter"]},"hir::literal::Extractor::extract_concat":{"I":["utf8::Utf8Sequences","hir::LookSetIter","hir::ClassBytesIter","hir::interval::IntervalSetIter","<&mut I as std::iter::Iterator>","hir::ClassUnicodeIter"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extract_concat(p1);
+hir::literal::Extractor::extract_concat(p0, p1);
+crate::hir::literal::Extractor::extract_concat(p0, p1);
+<hir::literal::Extractor>::extract_concat(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::extract_alternation
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"either::Either":{"Left":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"],"Right":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"error::Formatter":{"E":["std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::literal::Extractor::extract_alternation":{"I":["std::marker::Sized","std::iter::Iterator"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::CString","std::sync::Arc<T>","std::vec::Vec<T, A>","<&mut T as std::fmt::Debug>","std::rc::Rc<T>","std::string::String","std::ffi::OsString"]},"ast::parse::ParserI":{"P":["<&mut T as std::borrow::Borrow<T>>","std::string::String","std::vec::Vec<T, A>","std::ffi::CString","std::ffi::OsString","std::rc::Rc<T>","std::path::PathBuf","std::boxed::Box<T, A>","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::ClassSetRange","error::Error","ast::Group","ast::RepetitionOp","ast::RepetitionKind","ast::Span","ast::FlagsItemKind","hir::Literal","hir::ClassUnicodeRange","hir::ClassBytes","hir::Dot","ast::ClassSetUnion","hir::ClassBytesRange","ast::Ast","ast::Concat","ast::GroupKind","hir::ClassUnicode","ast::HexLiteralKind","ast::Flags","ast::Error","hir::Look","hir::Repetition","hir::Error","utf8::Utf8Sequence","hir::HirKind","hir::Hir","either::Either","ast::SetFlags","hir::literal::Literal","hir::literal::Seq","ast::Alternation","ast::FlagsItem","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Repetition","ast::LiteralKind","ast::CaptureName","hir::Class","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::WithComments","hir::Capture","ast::Literal","ast::AssertionKind","ast::Assertion","hir::ErrorKind","ast::ClassPerl","ast::ClassSetItem","ast::ErrorKind","ast::ClassUnicodeOpKind","ast::ClassPerlKind","hir::LookSet","ast::ClassUnicode","ast::ClassUnicodeKind","hir::Properties","ast::ClassSet","ast::Flag","ast::Position","ast::ClassAscii","ast::Comment","hir::interval::IntervalSet","ast::ClassAsciiKind","hir::PropertiesI","ast::RepetitionRange","ast::parse::Primitive","ast::Class","ast::ClassBracketed","ast::SpecialLiteralKind","utf8::Utf8Range"],"Right":["ast::ClassSetBinaryOp","ast::RepetitionRange","ast::CaptureName","ast::ClassBracketed","ast::parse::Primitive","ast::ClassSetRange","ast::Assertion","hir::LookSet","utf8::Utf8Range","hir::ClassUnicode","error::Error","hir::PropertiesI","ast::Error","hir::Look","hir::Dot","hir::literal::Literal","ast::ClassUnicodeKind","hir::Error","ast::ClassPerlKind","ast::ClassUnicodeOpKind","ast::ClassAscii","utf8::Utf8Sequence","hir::Class","ast::ClassSetUnion","ast::ClassAsciiKind","ast::FlagsItem","ast::Literal","hir::Capture","ast::SetFlags","ast::Flag","ast::RepetitionOp","hir::ClassBytesRange","ast::Ast","hir::interval::IntervalSet","hir::HirKind","hir::Hir","ast::Group","hir::Properties","hir::ErrorKind","ast::FlagsItemKind","ast::ClassSetItem","ast::RepetitionKind","hir::ClassBytes","ast::SpecialLiteralKind","either::Either","ast::ClassSet","ast::Class","ast::GroupKind","ast::Comment","ast::Position","hir::literal::Seq","ast::Repetition","hir::Literal","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::Flags","ast::ErrorKind","hir::ClassUnicodeRange","ast::ClassPerl","ast::Concat","hir::Repetition","ast::AssertionKind","ast::HexLiteralKind","ast::ClassSetBinaryOpKind","ast::Alternation","ast::WithComments","ast::ClassUnicode","ast::LiteralKind","ast::Span"]},"error::Formatter":{"E":["ast::ErrorKind","ast::Ast","error::Formatter","unicode::CaseFoldError","hir::Hir","hir::Error","hir::ErrorKind","ast::Error","error::Error","unicode::UnicodeWordError","<&mut T as std::fmt::Debug>"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["<*mut T as std::fmt::Debug>","ast::parse::ParserI","ast::Group","ast::SetFlags","ast::RepetitionKind","hir::literal::ExtractKind","ast::FlagsItem","ast::parse::NestLimiter","ast::visitor::ClassInduct","hir::Look","hir::literal::Extractor","ast::ClassSetBinaryOpKind","ast::ClassSetUnion","ast::Flag","parser::ParserBuilder","hir::Class","hir::translate::Flags","unicode::SimpleCaseFolder","utf8::Utf8Sequences","ast::AssertionKind","hir::PropertiesI","ast::RepetitionRange","hir::interval::IntervalSet","utf8::Utf8Range","unicode::ClassQuery","utf8::ScalarRange","unicode::CanonicalClassQuery","parser::Parser","ast::print::Printer","ast::Concat","unicode::CaseFoldError","ast::CaptureName","ast::ClassPerl","hir::translate::Translator","debug::Byte","hir::ClassUnicodeIter","ast::Assertion","ast::Error","hir::translate::HirFrame","hir::literal::PreferenceTrie","hir::ClassUnicode","hir::interval::IntervalSetIter","ast::Position","ast::Alternation","error::Formatter","utf8::Utf8Sequence","unicode::Error","ast::print::PrinterBuilder","hir::LookSetIter","ast::ClassUnicodeOpKind","ast::ClassSet","hir::ErrorKind","ast::parse::ClassState","ast::Span","ast::ClassSetBinaryOp","ast::Class","ast::parse::GroupState","hir::print::Writer","hir::translate::TranslatorI","ast::SpecialLiteralKind","ast::WithComments","hir::print::Printer","ast::RepetitionOp","hir::Literal","ast::ErrorKind","hir::literal::State","ast::ClassPerlKind","hir::Dot","ast::HexLiteralKind","ast::Ast","hir::translate::TranslatorBuilder","ast::parse::ParserBuilder","ast::FlagsItemKind","ast::ClassSetItem","debug::Bytes","either::Either","ast::ClassUnicode","hir::LookSet","ast::ClassSetRange","ast::visitor::ClassFrame","hir::ClassBytesRange","ast::parse::Primitive","hir::ClassBytesIter","hir::HirKind","ast::Repetition","hir::ClassUnicodeRange","ast::ClassUnicodeKind","ast::Flags","ast::ClassAsciiKind","hir::Error","ast::Literal","hir::Hir","hir::print::PrinterBuilder","ast::print::Writer","ast::ClassAscii","hir::ClassBytes","hir::literal::Literal","ast::ClassBracketed","ast::GroupKind","error::Error","ast::LiteralKind","ast::Comment","hir::Repetition","ast::parse::Parser","unicode::UnicodeWordError","hir::Capture","hir::literal::Seq","hir::Properties"]},"hir::literal::Extractor::extract_alternation":{"I":["hir::ClassUnicodeIter","utf8::Utf8Sequences","hir::interval::IntervalSetIter","hir::LookSetIter","hir::ClassBytesIter","<&mut I as std::iter::Iterator>"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extract_alternation(p1);
+hir::literal::Extractor::extract_alternation(p0, p1);
+crate::hir::literal::Extractor::extract_alternation(p0, p1);
+<hir::literal::Extractor>::extract_alternation(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::extract_repetition
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.extract_repetition(p1);
+hir::literal::Extractor::extract_repetition(p0, p1);
+crate::hir::literal::Extractor::extract_repetition(p0, p1);
+<hir::literal::Extractor>::extract_repetition(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::extract_class_unicode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.extract_class_unicode(p1);
+hir::literal::Extractor::extract_class_unicode(p0, p1);
+crate::hir::literal::Extractor::extract_class_unicode(p0, p1);
+<hir::literal::Extractor>::extract_class_unicode(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::extract_class_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.extract_class_bytes(p1);
+hir::literal::Extractor::extract_class_bytes(p0, p1);
+crate::hir::literal::Extractor::extract_class_bytes(p0, p1);
+<hir::literal::Extractor>::extract_class_bytes(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::class_over_limit_unicode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.class_over_limit_unicode(p1);
+hir::literal::Extractor::class_over_limit_unicode(p0, p1);
+crate::hir::literal::Extractor::class_over_limit_unicode(p0, p1);
+<hir::literal::Extractor>::class_over_limit_unicode(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::class_over_limit_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.class_over_limit_bytes(p1);
+hir::literal::Extractor::class_over_limit_bytes(p0, p1);
+crate::hir::literal::Extractor::class_over_limit_bytes(p0, p1);
+<hir::literal::Extractor>::class_over_limit_bytes(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Extractor::cross
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.cross(p1, p2);
+hir::literal::Extractor::cross(p0, p1, p2);
+crate::hir::literal::Extractor::cross(p0, p1, p2);
+<hir::literal::Extractor>::cross(p0, p1, p2);
-----------------
src/hir/literal.rs hir::literal::Extractor::union
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.union(p1, p2);
+hir::literal::Extractor::union(p0, p1, p2);
+crate::hir::literal::Extractor::union(p0, p1, p2);
+<hir::literal::Extractor>::union(p0, p1, p2);
-----------------
src/hir/literal.rs hir::literal::Extractor::enforce_literal_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Extractor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.enforce_literal_len(p1);
+hir::literal::Extractor::enforce_literal_len(p0, p1);
+crate::hir::literal::Extractor::enforce_literal_len(p0, p1);
+<hir::literal::Extractor>::enforce_literal_len(p0, p1);
-----------------
src/hir/literal.rs <hir::literal::Extractor as std::default::Default>::default
deps:{}
candidates:{}
+<hir::literal::Extractor as std::default::Default>::default();
+crate::<hir::literal::Extractor as std::default::Default>::default();
+<hir::literal::Extractor>::default();
-----------------
src/hir/literal.rs <hir::literal::ExtractKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::ExtractKind
+p0.clone();
+<hir::literal::ExtractKind as std::clone::Clone>::clone(p0);
+crate::<hir::literal::ExtractKind as std::clone::Clone>::clone(p0);
+<hir::literal::ExtractKind>::clone(p0);
-----------------
src/hir/literal.rs <hir::literal::ExtractKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::ExtractKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::ExtractKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::ExtractKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::ExtractKind>::fmt(p0, p1);
-----------------
src/hir/literal.rs hir::literal::ExtractKind::is_prefix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::ExtractKind
+p0.is_prefix();
+hir::literal::ExtractKind::is_prefix(p0);
+crate::hir::literal::ExtractKind::is_prefix(p0);
+<hir::literal::ExtractKind>::is_prefix(p0);
-----------------
src/hir/literal.rs hir::literal::ExtractKind::is_suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::ExtractKind
+p0.is_suffix();
+hir::literal::ExtractKind::is_suffix(p0);
+crate::hir::literal::ExtractKind::is_suffix(p0);
+<hir::literal::ExtractKind>::is_suffix(p0);
-----------------
src/hir/literal.rs <hir::literal::ExtractKind as std::default::Default>::default
deps:{}
candidates:{}
+<hir::literal::ExtractKind as std::default::Default>::default();
+crate::<hir::literal::ExtractKind as std::default::Default>::default();
+<hir::literal::ExtractKind>::default();
-----------------
src/hir/literal.rs <hir::literal::Seq as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.clone();
+<hir::literal::Seq as std::clone::Clone>::clone(p0);
+crate::<hir::literal::Seq as std::clone::Clone>::clone(p0);
+<hir::literal::Seq>::clone(p0);
-----------------
src/hir/literal.rs <hir::literal::Seq as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.assert_receiver_is_total_eq();
+<hir::literal::Seq as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::literal::Seq as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::literal::Seq>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/literal.rs <hir::literal::Seq as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.eq(p1);
+<hir::literal::Seq as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::literal::Seq as std::cmp::PartialEq>::eq(p0, p1);
+<hir::literal::Seq>::eq(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::empty
deps:{}
candidates:{}
+hir::literal::Seq::empty();
+crate::hir::literal::Seq::empty();
+<hir::literal::Seq>::empty();
-----------------
src/hir/literal.rs hir::literal::Seq::infinite
deps:{}
candidates:{}
+hir::literal::Seq::infinite();
+crate::hir::literal::Seq::infinite();
+<hir::literal::Seq>::infinite();
-----------------
src/hir/literal.rs hir::literal::Seq::singleton
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+hir::literal::Seq::singleton(p0);
+crate::hir::literal::Seq::singleton(p0);
+<hir::literal::Seq>::singleton(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug","std::clone::Clone"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"either::Either":{"Left":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"],"Right":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::literal::Seq::new":{"B":["std::marker::Sized","std::convert::AsRef"],"I":["std::marker::Sized","std::iter::IntoIterator"]},"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["hir::interval::IntervalSetIter","<&mut I as std::iter::Iterator>","hir::LookSetIter","hir::ClassBytesIter","hir::ClassUnicodeIter","utf8::Utf8Sequences"]},"ast::parse::NestLimiter":{"P":["std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::OsString","std::vec::Vec<T, A>","std::rc::Rc<T>","<&mut T as std::fmt::Debug>","std::ffi::CString","std::path::PathBuf","std::string::String"]},"ast::parse::ParserI":{"P":["std::string::String","std::clone::impls::<impl std::clone::Clone for &mut T>","std::ffi::OsString","std::ffi::CString","std::boxed::Box<T, A>","std::sync::Arc<T>","std::path::PathBuf","std::rc::Rc<T>","std::vec::Vec<T, A>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["utf8::Utf8Range","hir::ClassUnicode","ast::GroupKind","ast::ClassAscii","ast::WithComments","ast::ClassBracketed","hir::Hir","hir::literal::Seq","hir::interval::IntervalSet","ast::SpecialLiteralKind","hir::Capture","ast::Error","ast::FlagsItemKind","ast::ErrorKind","hir::Class","ast::ClassUnicode","ast::parse::Primitive","ast::RepetitionKind","ast::RepetitionOp","ast::CaptureName","ast::Position","ast::ClassPerl","ast::AssertionKind","hir::HirKind","ast::ClassSetBinaryOpKind","ast::ClassUnicodeKind","ast::RepetitionRange","ast::Group","ast::Ast","ast::Literal","ast::FlagsItem","hir::PropertiesI","hir::ClassUnicodeRange","ast::LiteralKind","ast::Class","hir::ErrorKind","error::Error","ast::ClassSetRange","ast::Flag","hir::Repetition","hir::literal::Literal","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::ClassSetBinaryOp","ast::ClassSetUnion","hir::ClassBytes","ast::Alternation","ast::Concat","ast::HexLiteralKind","ast::Assertion","ast::Comment","ast::Flags","hir::Dot","either::Either","hir::Properties","hir::Literal","ast::ClassAsciiKind","hir::LookSet","hir::ClassBytesRange","utf8::Utf8Sequence","ast::ClassPerlKind","ast::ClassSetItem","ast::Span","ast::SetFlags","ast::ClassSet","hir::Look","ast::Repetition","ast::ClassUnicodeOpKind","hir::Error"],"Right":["ast::RepetitionRange","hir::HirKind","ast::Comment","ast::SpecialLiteralKind","error::Error","ast::ClassSetRange","ast::ClassAsciiKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","hir::Properties","ast::LiteralKind","hir::ClassBytes","ast::ClassUnicodeOpKind","hir::ClassUnicodeRange","ast::ClassSet","ast::ClassUnicodeKind","ast::CaptureName","ast::SetFlags","ast::Position","hir::ErrorKind","ast::ClassPerl","ast::ErrorKind","ast::parse::Primitive","ast::WithComments","ast::Group","hir::Literal","ast::Assertion","ast::GroupKind","hir::Capture","hir::Class","ast::ClassAscii","hir::Dot","ast::ClassSetUnion","hir::Look","hir::ClassBytesRange","<*const T as std::fmt::Debug>","hir::PropertiesI","ast::Concat","ast::ClassBracketed","ast::Ast","ast::Literal","ast::Repetition","either::Either","utf8::Utf8Range","ast::HexLiteralKind","hir::Repetition","hir::Hir","hir::LookSet","ast::FlagsItemKind","ast::Flags","ast::AssertionKind","ast::Flag","ast::RepetitionKind","ast::ClassPerlKind","hir::Error","ast::FlagsItem","ast::ClassUnicode","ast::Class","ast::ClassSetItem","utf8::Utf8Sequence","hir::ClassUnicode","hir::literal::Seq","ast::Span","hir::interval::IntervalSet","ast::RepetitionOp","ast::Error","ast::Alternation","hir::literal::Literal"]},"error::Formatter":{"E":["hir::Error","unicode::CaseFoldError","ast::ErrorKind","<&mut T as std::fmt::Debug>","error::Formatter","error::Error","hir::ErrorKind","hir::Hir","unicode::UnicodeWordError","ast::Error","ast::Ast"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::ClassUnicodeKind","hir::ClassUnicode","hir::Capture","ast::Ast","ast::Assertion","either::Either","ast::ClassPerlKind","ast::ClassSetUnion","error::Formatter","debug::Bytes","hir::HirKind","hir::ClassUnicodeRange","parser::Parser","ast::ClassSet","ast::parse::Parser","ast::Repetition","ast::Error","hir::Hir","ast::Alternation","hir::print::PrinterBuilder","unicode::CanonicalClassQuery","ast::ClassSetItem","unicode::ClassQuery","ast::RepetitionKind","hir::translate::TranslatorBuilder","ast::ClassAsciiKind","hir::interval::IntervalSet","ast::SpecialLiteralKind","ast::visitor::ClassInduct","hir::print::Printer","ast::SetFlags","ast::parse::ParserI","ast::ClassPerl","utf8::Utf8Sequence","ast::parse::GroupState","hir::ErrorKind","hir::Literal","hir::Look","ast::parse::ParserBuilder","hir::literal::Seq","utf8::ScalarRange","ast::print::PrinterBuilder","unicode::UnicodeWordError","debug::Byte","hir::ClassBytesRange","parser::ParserBuilder","ast::LiteralKind","hir::translate::TranslatorI","ast::Comment","utf8::Utf8Range","ast::ClassSetBinaryOp","ast::ClassSetRange","ast::Flags","hir::Properties","ast::ClassSetBinaryOpKind","hir::translate::Translator","ast::parse::ClassState","ast::RepetitionOp","ast::Concat","ast::ClassUnicode","<*const T as std::fmt::Debug>","hir::LookSet","ast::print::Writer","ast::FlagsItem","ast::Flag","hir::LookSetIter","hir::PropertiesI","hir::Dot","hir::Class","hir::ClassBytes","hir::literal::ExtractKind","hir::ClassUnicodeIter","ast::Span","ast::parse::NestLimiter","hir::literal::Extractor","error::Error","hir::literal::PreferenceTrie","ast::ClassBracketed","ast::FlagsItemKind","ast::CaptureName","ast::Class","hir::translate::Flags","hir::literal::Literal","hir::Error","hir::literal::State","hir::translate::HirFrame","ast::Group","hir::print::Writer","ast::Literal","utf8::Utf8Sequences","ast::HexLiteralKind","ast::ErrorKind","unicode::CaseFoldError","ast::Position","ast::WithComments","unicode::SimpleCaseFolder","ast::GroupKind","ast::RepetitionRange","unicode::Error","ast::ClassAscii","ast::ClassUnicodeOpKind","ast::visitor::ClassFrame","hir::interval::IntervalSetIter","hir::ClassBytesIter","ast::AssertionKind","ast::parse::Primitive","ast::print::Printer","hir::Repetition"]},"hir::literal::Seq::new":{"B":["<&T as std::convert::AsRef<U>>","hir::literal::Literal","<&mut T as std::convert::AsRef<U>>"],"I":["<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>","<&'a mut std::option::Option<T> as std::iter::IntoIterator>"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+hir::literal::Seq::new(p0);
+crate::hir::literal::Seq::new(p0);
+<hir::literal::Seq>::new(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::literals
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.literals();
+hir::literal::Seq::literals(p0);
+crate::hir::literal::Seq::literals(p0);
+<hir::literal::Seq>::literals(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.push(p1);
+hir::literal::Seq::push(p0, p1);
+crate::hir::literal::Seq::push(p0, p1);
+<hir::literal::Seq>::push(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::make_inexact
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.make_inexact();
+hir::literal::Seq::make_inexact(p0);
+crate::hir::literal::Seq::make_inexact(p0);
+<hir::literal::Seq>::make_inexact(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::make_infinite
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.make_infinite();
+hir::literal::Seq::make_infinite(p0);
+crate::hir::literal::Seq::make_infinite(p0);
+<hir::literal::Seq>::make_infinite(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::cross_forward
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.cross_forward(p1);
+hir::literal::Seq::cross_forward(p0, p1);
+crate::hir::literal::Seq::cross_forward(p0, p1);
+<hir::literal::Seq>::cross_forward(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::cross_reverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.cross_reverse(p1);
+hir::literal::Seq::cross_reverse(p0, p1);
+crate::hir::literal::Seq::cross_reverse(p0, p1);
+<hir::literal::Seq>::cross_reverse(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::cross_preamble
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.cross_preamble(p1);
+hir::literal::Seq::cross_preamble(p0, p1);
+crate::hir::literal::Seq::cross_preamble(p0, p1);
+<hir::literal::Seq>::cross_preamble(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.union(p1);
+hir::literal::Seq::union(p0, p1);
+crate::hir::literal::Seq::union(p0, p1);
+<hir::literal::Seq>::union(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::union_into_empty
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.union_into_empty(p1);
+hir::literal::Seq::union_into_empty(p0, p1);
+crate::hir::literal::Seq::union_into_empty(p0, p1);
+<hir::literal::Seq>::union_into_empty(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::dedup
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.dedup();
+hir::literal::Seq::dedup(p0);
+crate::hir::literal::Seq::dedup(p0);
+<hir::literal::Seq>::dedup(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::sort
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.sort();
+hir::literal::Seq::sort(p0);
+crate::hir::literal::Seq::sort(p0);
+<hir::literal::Seq>::sort(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::reverse_literals
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.reverse_literals();
+hir::literal::Seq::reverse_literals(p0);
+crate::hir::literal::Seq::reverse_literals(p0);
+<hir::literal::Seq>::reverse_literals(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::minimize_by_preference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.minimize_by_preference();
+hir::literal::Seq::minimize_by_preference(p0);
+crate::hir::literal::Seq::minimize_by_preference(p0);
+<hir::literal::Seq>::minimize_by_preference(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::keep_first_bytes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = 0usize; // None+usize
+p0.keep_first_bytes(p1);
+hir::literal::Seq::keep_first_bytes(p0, p1);
+crate::hir::literal::Seq::keep_first_bytes(p0, p1);
+<hir::literal::Seq>::keep_first_bytes(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::keep_last_bytes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = 0usize; // None+usize
+p0.keep_last_bytes(p1);
+hir::literal::Seq::keep_last_bytes(p0, p1);
+crate::hir::literal::Seq::keep_last_bytes(p0, p1);
+<hir::literal::Seq>::keep_last_bytes(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::is_finite
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.is_finite();
+hir::literal::Seq::is_finite(p0);
+crate::hir::literal::Seq::is_finite(p0);
+<hir::literal::Seq>::is_finite(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.is_empty();
+hir::literal::Seq::is_empty(p0);
+crate::hir::literal::Seq::is_empty(p0);
+<hir::literal::Seq>::is_empty(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.len();
+hir::literal::Seq::len(p0);
+crate::hir::literal::Seq::len(p0);
+<hir::literal::Seq>::len(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::is_exact
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.is_exact();
+hir::literal::Seq::is_exact(p0);
+crate::hir::literal::Seq::is_exact(p0);
+<hir::literal::Seq>::is_exact(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::is_inexact
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.is_inexact();
+hir::literal::Seq::is_inexact(p0);
+crate::hir::literal::Seq::is_inexact(p0);
+<hir::literal::Seq>::is_inexact(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::max_union_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.max_union_len(p1);
+hir::literal::Seq::max_union_len(p0, p1);
+crate::hir::literal::Seq::max_union_len(p0, p1);
+<hir::literal::Seq>::max_union_len(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::max_cross_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.max_cross_len(p1);
+hir::literal::Seq::max_cross_len(p0, p1);
+crate::hir::literal::Seq::max_cross_len(p0, p1);
+<hir::literal::Seq>::max_cross_len(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Seq::min_literal_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.min_literal_len();
+hir::literal::Seq::min_literal_len(p0);
+crate::hir::literal::Seq::min_literal_len(p0);
+<hir::literal::Seq>::min_literal_len(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::max_literal_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.max_literal_len();
+hir::literal::Seq::max_literal_len(p0);
+crate::hir::literal::Seq::max_literal_len(p0);
+<hir::literal::Seq>::max_literal_len(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::longest_common_prefix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.longest_common_prefix();
+hir::literal::Seq::longest_common_prefix(p0);
+crate::hir::literal::Seq::longest_common_prefix(p0);
+<hir::literal::Seq>::longest_common_prefix(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::longest_common_suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.longest_common_suffix();
+hir::literal::Seq::longest_common_suffix(p0);
+crate::hir::literal::Seq::longest_common_suffix(p0);
+<hir::literal::Seq>::longest_common_suffix(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::optimize_for_prefix_by_preference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.optimize_for_prefix_by_preference();
+hir::literal::Seq::optimize_for_prefix_by_preference(p0);
+crate::hir::literal::Seq::optimize_for_prefix_by_preference(p0);
+<hir::literal::Seq>::optimize_for_prefix_by_preference(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::optimize_for_suffix_by_preference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
+p0.optimize_for_suffix_by_preference();
+hir::literal::Seq::optimize_for_suffix_by_preference(p0);
+crate::hir::literal::Seq::optimize_for_suffix_by_preference(p0);
+<hir::literal::Seq>::optimize_for_suffix_by_preference(p0);
-----------------
src/hir/literal.rs hir::literal::Seq::optimize_by_preference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = true; // None+bool
+p0.optimize_by_preference(p1);
+hir::literal::Seq::optimize_by_preference(p0, p1);
+crate::hir::literal::Seq::optimize_by_preference(p0, p1);
+<hir::literal::Seq>::optimize_by_preference(p0, p1);
-----------------
src/hir/literal.rs <hir::literal::Seq as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Seq
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::Seq as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::Seq as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::Seq>::fmt(p0, p1);
-----------------
src/hir/literal.rs <hir::literal::Seq as std::iter::FromIterator<hir::literal::Literal>>::from_iter
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<hir::literal::Seq as std::iter::FromIterator<hir::literal::Literal>>::from_iter":{"T":["std::iter::IntoIterator","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::clone::Clone","std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"either::Either":{"Left":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"],"Right":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","hir::interval::Interval","std::clone::Clone","std::fmt::Debug"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["utf8::Utf8Sequences","hir::ClassUnicodeIter","<&mut I as std::iter::Iterator>","hir::ClassBytesIter","hir::interval::IntervalSetIter","hir::LookSetIter"]},"<hir::literal::Seq as std::iter::FromIterator<hir::literal::Literal>>::from_iter":{"T":["<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>","<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>"]},"ast::parse::NestLimiter":{"P":["std::ffi::CString","std::ffi::OsString","std::string::String","std::boxed::Box<T, A>","<&mut T as std::fmt::Debug>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","std::path::PathBuf"]},"ast::parse::ParserI":{"P":["std::ffi::CString","std::rc::Rc<T>","std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","std::path::PathBuf","std::sync::Arc<T>","std::clone::impls::<impl std::clone::Clone for &T>","std::vec::Vec<T, A>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::Class","ast::ClassAsciiKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::Flag","hir::LookSet","ast::HexLiteralKind","ast::ErrorKind","ast::Literal","hir::Look","ast::ClassSetBinaryOpKind","hir::Hir","ast::ClassPerlKind","hir::interval::IntervalSet","ast::Span","ast::RepetitionRange","hir::Capture","hir::HirKind","ast::SetFlags","ast::FlagsItemKind","ast::Alternation","either::Either","ast::ClassSet","ast::ClassUnicodeOpKind","hir::ClassUnicodeRange","ast::ClassBracketed","hir::Literal","ast::GroupKind","ast::ClassAscii","ast::SpecialLiteralKind","ast::ClassUnicode","hir::PropertiesI","ast::FlagsItem","hir::Dot","hir::ClassBytes","hir::Error","hir::ErrorKind","hir::literal::Seq","ast::RepetitionKind","hir::Properties","ast::ClassSetItem","hir::Repetition","ast::ClassPerl","hir::Class","utf8::Utf8Sequence","ast::Ast","ast::ClassUnicodeKind","ast::Flags","utf8::Utf8Range","ast::ClassSetUnion","ast::Concat","ast::Assertion","ast::Repetition","ast::LiteralKind","ast::Error","ast::AssertionKind","ast::parse::Primitive","ast::Comment","hir::ClassUnicode","hir::ClassBytesRange","hir::literal::Literal","error::Error","ast::Position","ast::CaptureName","ast::ClassSetBinaryOp","ast::RepetitionOp","ast::Group","ast::ClassSetRange","ast::WithComments"],"Right":["ast::parse::Primitive","ast::FlagsItemKind","ast::ClassAscii","hir::Capture","ast::Class","ast::ClassUnicodeOpKind","hir::PropertiesI","ast::ClassSetBinaryOpKind","ast::Error","ast::ClassBracketed","ast::Comment","hir::interval::IntervalSet","ast::Alternation","hir::Repetition","ast::Concat","hir::Error","hir::ClassUnicodeRange","hir::literal::Literal","ast::WithComments","hir::Properties","ast::Literal","ast::Assertion","ast::ClassSetBinaryOp","ast::Flags","hir::Look","ast::SpecialLiteralKind","ast::CaptureName","ast::ClassPerlKind","ast::Position","ast::RepetitionKind","hir::ClassUnicode","hir::ErrorKind","ast::RepetitionOp","hir::Dot","hir::Literal","ast::ClassAsciiKind","ast::ClassSetItem","hir::literal::Seq","ast::Flag","ast::ClassSet","ast::FlagsItem","ast::ClassUnicodeKind","ast::ClassUnicode","hir::HirKind","hir::LookSet","hir::Hir","ast::ClassSetRange","either::Either","ast::LiteralKind","utf8::Utf8Range","ast::ErrorKind","ast::SetFlags","ast::RepetitionRange","utf8::Utf8Sequence","hir::Class","ast::HexLiteralKind","ast::ClassPerl","ast::Repetition","hir::ClassBytes","ast::AssertionKind","ast::Span","hir::ClassBytesRange","ast::Group","error::Error","ast::Ast","ast::GroupKind","ast::ClassSetUnion","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"error::Formatter":{"E":["hir::Hir","hir::Error","<&mut T as std::fmt::Debug>","ast::ErrorKind","ast::Error","ast::Ast","hir::ErrorKind","error::Error","unicode::UnicodeWordError","error::Formatter","unicode::CaseFoldError"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["hir::print::PrinterBuilder","ast::print::Writer","ast::print::PrinterBuilder","ast::ClassPerlKind","hir::Literal","ast::ClassUnicodeOpKind","hir::ClassBytesRange","ast::Repetition","ast::parse::GroupState","utf8::Utf8Sequence","ast::HexLiteralKind","ast::parse::Primitive","ast::ErrorKind","debug::Byte","ast::Literal","ast::Error","hir::Properties","ast::Flag","ast::Span","unicode::ClassQuery","ast::GroupKind","ast::Flags","error::Formatter","hir::Class","hir::literal::ExtractKind","ast::SetFlags","hir::ErrorKind","hir::print::Writer","hir::ClassUnicodeIter","ast::Concat","ast::visitor::ClassInduct","unicode::UnicodeWordError","either::Either","hir::Look","hir::literal::PreferenceTrie","hir::translate::TranslatorBuilder","ast::ClassUnicodeKind","hir::LookSet","ast::SpecialLiteralKind","hir::translate::TranslatorI","hir::LookSetIter","unicode::Error","ast::ClassPerl","utf8::ScalarRange","hir::ClassBytes","ast::parse::Parser","ast::ClassBracketed","ast::RepetitionKind","error::Error","ast::LiteralKind","hir::ClassUnicode","ast::ClassSetBinaryOpKind","hir::literal::Extractor","<*const T as std::fmt::Debug>","ast::visitor::ClassFrame","hir::Error","ast::ClassSetUnion","hir::interval::IntervalSet","hir::literal::Seq","ast::ClassAscii","hir::translate::Flags","ast::ClassAsciiKind","ast::Position","hir::HirKind","ast::Comment","ast::FlagsItem","ast::WithComments","hir::translate::Translator","ast::Ast","ast::ClassSet","hir::Dot","ast::CaptureName","hir::Repetition","utf8::Utf8Sequences","ast::ClassSetItem","ast::parse::ParserI","hir::ClassUnicodeRange","hir::Capture","utf8::Utf8Range","ast::parse::ParserBuilder","hir::PropertiesI","ast::Group","unicode::CaseFoldError","ast::AssertionKind","ast::RepetitionOp","parser::ParserBuilder","ast::parse::NestLimiter","ast::Class","unicode::SimpleCaseFolder","ast::RepetitionRange","hir::print::Printer","hir::ClassBytesIter","hir::translate::HirFrame","ast::Assertion","hir::interval::IntervalSetIter","debug::Bytes","parser::Parser","hir::literal::Literal","ast::ClassUnicode","ast::FlagsItemKind","hir::Hir","ast::print::Printer","ast::parse::ClassState","ast::ClassSetRange","unicode::CanonicalClassQuery","ast::ClassSetBinaryOp","ast::Alternation","hir::literal::State"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<hir::literal::Seq as std::iter::FromIterator<hir::literal::Literal>>::from_iter(p0);
+crate::<hir::literal::Seq as std::iter::FromIterator<hir::literal::Literal>>::from_iter(p0);
+<hir::literal::Seq>::from_iter(p0);
-----------------
src/hir/literal.rs <hir::literal::Literal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.clone();
+<hir::literal::Literal as std::clone::Clone>::clone(p0);
+crate::<hir::literal::Literal as std::clone::Clone>::clone(p0);
+<hir::literal::Literal>::clone(p0);
-----------------
src/hir/literal.rs <hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.assert_receiver_is_total_eq();
+<hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::literal::Literal>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/literal.rs <hir::literal::Literal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.eq(p1);
+<hir::literal::Literal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::literal::Literal as std::cmp::PartialEq>::eq(p0, p1);
+<hir::literal::Literal>::eq(p0, p1);
-----------------
src/hir/literal.rs <hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.partial_cmp(p1);
+<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<hir::literal::Literal>::partial_cmp(p0, p1);
-----------------
src/hir/literal.rs <hir::literal::Literal as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.cmp(p1);
+<hir::literal::Literal as std::cmp::Ord>::cmp(p0, p1);
+crate::<hir::literal::Literal as std::cmp::Ord>::cmp(p0, p1);
+<hir::literal::Literal>::cmp(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Literal::exact
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"hir::literal::Literal::exact":{"B":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"hir::literal::Literal::exact":{"B":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // B
+hir::literal::Literal::exact(p0);
+crate::hir::literal::Literal::exact(p0);
+<hir::literal::Literal>::exact(p0);
-----------------
src/hir/literal.rs hir::literal::Literal::inexact
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"hir::literal::Literal::inexact":{"B":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"hir::literal::Literal::inexact":{"B":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // B
+hir::literal::Literal::inexact(p0);
+crate::hir::literal::Literal::inexact(p0);
+<hir::literal::Literal>::inexact(p0);
-----------------
src/hir/literal.rs hir::literal::Literal::as_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.as_bytes();
+hir::literal::Literal::as_bytes(p0);
+crate::hir::literal::Literal::as_bytes(p0);
+<hir::literal::Literal>::as_bytes(p0);
-----------------
src/hir/literal.rs hir::literal::Literal::into_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.into_bytes();
+hir::literal::Literal::into_bytes(p0);
+crate::hir::literal::Literal::into_bytes(p0);
+<hir::literal::Literal>::into_bytes(p0);
-----------------
src/hir/literal.rs hir::literal::Literal::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.len();
+hir::literal::Literal::len(p0);
+crate::hir::literal::Literal::len(p0);
+<hir::literal::Literal>::len(p0);
-----------------
src/hir/literal.rs hir::literal::Literal::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.is_empty();
+hir::literal::Literal::is_empty(p0);
+crate::hir::literal::Literal::is_empty(p0);
+<hir::literal::Literal>::is_empty(p0);
-----------------
src/hir/literal.rs hir::literal::Literal::is_exact
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.is_exact();
+hir::literal::Literal::is_exact(p0);
+crate::hir::literal::Literal::is_exact(p0);
+<hir::literal::Literal>::is_exact(p0);
-----------------
src/hir/literal.rs hir::literal::Literal::make_inexact
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.make_inexact();
+hir::literal::Literal::make_inexact(p0);
+crate::hir::literal::Literal::make_inexact(p0);
+<hir::literal::Literal>::make_inexact(p0);
-----------------
src/hir/literal.rs hir::literal::Literal::reverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.reverse();
+hir::literal::Literal::reverse(p0);
+crate::hir::literal::Literal::reverse(p0);
+<hir::literal::Literal>::reverse(p0);
-----------------
src/hir/literal.rs hir::literal::Literal::extend
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.extend(p1);
+hir::literal::Literal::extend(p0, p1);
+crate::hir::literal::Literal::extend(p0, p1);
+<hir::literal::Literal>::extend(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Literal::keep_first_bytes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = 0usize; // None+usize
+p0.keep_first_bytes(p1);
+hir::literal::Literal::keep_first_bytes(p0, p1);
+crate::hir::literal::Literal::keep_first_bytes(p0, p1);
+<hir::literal::Literal>::keep_first_bytes(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Literal::keep_last_bytes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = 0usize; // None+usize
+p0.keep_last_bytes(p1);
+hir::literal::Literal::keep_last_bytes(p0, p1);
+crate::hir::literal::Literal::keep_last_bytes(p0, p1);
+<hir::literal::Literal>::keep_last_bytes(p0, p1);
-----------------
src/hir/literal.rs hir::literal::Literal::is_poisonous
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.is_poisonous();
+hir::literal::Literal::is_poisonous(p0);
+crate::hir::literal::Literal::is_poisonous(p0);
+<hir::literal::Literal>::is_poisonous(p0);
-----------------
src/hir/literal.rs <hir::literal::Literal as std::convert::From<u8>>::from
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<hir::literal::Literal as std::convert::From<u8>>::from(p0);
+crate::<hir::literal::Literal as std::convert::From<u8>>::from(p0);
+<hir::literal::Literal>::from(p0);
-----------------
src/hir/literal.rs <hir::literal::Literal as std::convert::From<char>>::from
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+<hir::literal::Literal as std::convert::From<char>>::from(p0);
+crate::<hir::literal::Literal as std::convert::From<char>>::from(p0);
+<hir::literal::Literal>::from(p0);
-----------------
src/hir/literal.rs <hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.as_ref();
+<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref(p0);
+crate::<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref(p0);
+<hir::literal::Literal>::as_ref(p0);
-----------------
src/hir/literal.rs <hir::literal::Literal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::Literal as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::Literal as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::Literal>::fmt(p0, p1);
-----------------
src/hir/literal.rs <hir::literal::PreferenceTrie as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::PreferenceTrie
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::PreferenceTrie as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::PreferenceTrie as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::PreferenceTrie>::fmt(p0, p1);
-----------------
src/hir/literal.rs <hir::literal::PreferenceTrie as std::default::Default>::default
deps:{}
candidates:{}
+<hir::literal::PreferenceTrie as std::default::Default>::default();
+crate::<hir::literal::PreferenceTrie as std::default::Default>::default();
+<hir::literal::PreferenceTrie>::default();
-----------------
src/hir/literal.rs <hir::literal::State as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::State
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::State as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::State as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::State>::fmt(p0, p1);
-----------------
src/hir/literal.rs <hir::literal::State as std::default::Default>::default
deps:{}
candidates:{}
+<hir::literal::State as std::default::Default>::default();
+crate::<hir::literal::State as std::default::Default>::default();
+<hir::literal::State>::default();
-----------------
src/hir/literal.rs hir::literal::PreferenceTrie::minimize
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::literal::Literal>
let mut p1 = true; // None+bool
+hir::literal::PreferenceTrie::minimize(p0, p1);
+crate::hir::literal::PreferenceTrie::minimize(p0, p1);
+<hir::literal::PreferenceTrie>::minimize(p0, p1);
-----------------
src/hir/literal.rs hir::literal::PreferenceTrie::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::PreferenceTrie
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.insert(p1);
+hir::literal::PreferenceTrie::insert(p0, p1);
+crate::hir::literal::PreferenceTrie::insert(p0, p1);
+<hir::literal::PreferenceTrie>::insert(p0, p1);
-----------------
src/hir/literal.rs hir::literal::PreferenceTrie::root
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::PreferenceTrie
+p0.root();
+hir::literal::PreferenceTrie::root(p0);
+crate::hir::literal::PreferenceTrie::root(p0);
+<hir::literal::PreferenceTrie>::root(p0);
-----------------
src/hir/literal.rs hir::literal::PreferenceTrie::create_state
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::PreferenceTrie
+p0.create_state();
+hir::literal::PreferenceTrie::create_state(p0);
+crate::hir::literal::PreferenceTrie::create_state(p0);
+<hir::literal::PreferenceTrie>::create_state(p0);
-----------------
src/hir/print.rs <hir::print::PrinterBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::PrinterBuilder
+p0.clone();
+<hir::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+crate::<hir::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+<hir::print::PrinterBuilder>::clone(p0);
-----------------
src/hir/print.rs <hir::print::PrinterBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::PrinterBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+<hir::print::PrinterBuilder>::fmt(p0, p1);
-----------------
src/hir/print.rs <hir::print::PrinterBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<hir::print::PrinterBuilder as std::default::Default>::default();
+crate::<hir::print::PrinterBuilder as std::default::Default>::default();
+<hir::print::PrinterBuilder>::default();
-----------------
src/hir/print.rs hir::print::PrinterBuilder::new
deps:{}
candidates:{}
+hir::print::PrinterBuilder::new();
+crate::hir::print::PrinterBuilder::new();
+<hir::print::PrinterBuilder>::new();
-----------------
src/hir/print.rs hir::print::PrinterBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::PrinterBuilder
+p0.build();
+hir::print::PrinterBuilder::build(p0);
+crate::hir::print::PrinterBuilder::build(p0);
+<hir::print::PrinterBuilder>::build(p0);
-----------------
src/hir/print.rs <hir::print::Printer as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::Printer
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+<hir::print::Printer>::fmt(p0, p1);
-----------------
src/hir/print.rs hir::print::Printer::new
deps:{}
candidates:{}
+hir::print::Printer::new();
+crate::hir::print::Printer::new();
+<hir::print::Printer>::new();
-----------------
src/hir/print.rs hir::print::Printer::print
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Printer::print":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Printer::print":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","std::string::String","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Printer
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p2 = MaybeUninit::uninit().assume_init(); // W
+p0.print(p1, p2);
+hir::print::Printer::print(p0, p1, p2);
+crate::hir::print::Printer::print(p0, p1, p2);
+<hir::print::Printer>::print(p0, p1, p2);
-----------------
src/hir/print.rs <hir::print::Writer<W> as std::fmt::Debug>::fmt
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::print::Writer<W> as std::fmt::Debug>::fmt":{"W":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"],"Right":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::print::Writer<W> as std::fmt::Debug>::fmt":{"W":["ast::Error","ast::Class","ast::Ast","unicode::UnicodeWordError","ast::RepetitionOp","hir::ClassUnicodeIter","ast::ClassAsciiKind","hir::print::Writer","parser::Parser","ast::Literal","ast::parse::ParserI","ast::WithComments","ast::parse::ParserBuilder","utf8::Utf8Sequence","hir::literal::ExtractKind","ast::ClassSetItem","hir::Error","hir::Look","hir::Properties","utf8::ScalarRange","ast::visitor::ClassInduct","hir::PropertiesI","hir::print::Printer","hir::Capture","hir::ClassBytesRange","ast::CaptureName","ast::Comment","ast::ClassBracketed","ast::ClassSetRange","unicode::SimpleCaseFolder","hir::ErrorKind","hir::interval::IntervalSetIter","ast::Flags","hir::LookSetIter","ast::print::Printer","ast::ClassSetBinaryOp","hir::literal::State","hir::HirKind","ast::parse::Primitive","ast::ClassUnicodeKind","hir::translate::TranslatorBuilder","ast::ClassPerl","ast::RepetitionKind","hir::Class","ast::ErrorKind","ast::ClassSet","unicode::CaseFoldError","ast::ClassSetBinaryOpKind","ast::print::Writer","ast::HexLiteralKind","hir::ClassUnicode","ast::RepetitionRange","hir::literal::PreferenceTrie","hir::ClassBytes","ast::SetFlags","hir::ClassBytesIter","ast::Flag","utf8::Utf8Range","hir::literal::Seq","ast::ClassUnicodeOpKind","hir::interval::IntervalSet","utf8::Utf8Sequences","hir::translate::Flags","ast::FlagsItemKind","ast::ClassPerlKind","hir::translate::HirFrame","debug::Bytes","ast::parse::GroupState","debug::Byte","ast::Group","ast::Alternation","ast::Span","unicode::Error","unicode::ClassQuery","ast::Concat","hir::translate::TranslatorI","ast::parse::NestLimiter","ast::Position","hir::translate::Translator","hir::LookSet","ast::GroupKind","hir::Dot","hir::Repetition","hir::print::PrinterBuilder","ast::SpecialLiteralKind","ast::LiteralKind","ast::ClassSetUnion","<*mut T as std::fmt::Debug>","ast::visitor::ClassFrame","parser::ParserBuilder","ast::FlagsItem","ast::ClassAscii","ast::ClassUnicode","ast::parse::Parser","either::Either","hir::Literal","ast::Repetition","error::Formatter","ast::AssertionKind","<*const T as std::fmt::Debug>","hir::ClassUnicodeRange","ast::Assertion","unicode::CanonicalClassQuery","hir::literal::Literal","hir::Hir","hir::literal::Extractor","ast::parse::ClassState","error::Error","ast::print::PrinterBuilder"]},"ast::parse::NestLimiter":{"P":["std::rc::Rc<T>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::ffi::OsString","std::vec::Vec<T, A>","std::path::PathBuf","std::string::String","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>"]},"ast::parse::ParserI":{"P":["std::ffi::OsString","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::path::PathBuf","std::string::String","std::ffi::CString","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::ClassSetBinaryOp","ast::FlagsItemKind","hir::literal::Literal","ast::Ast","ast::Flags","hir::Look","<*const T as std::fmt::Debug>","utf8::Utf8Range","ast::Span","ast::FlagsItem","hir::Properties","hir::Class","ast::Group","hir::Literal","ast::GroupKind","ast::Class","ast::ClassSetBinaryOpKind","ast::Error","hir::Dot","ast::RepetitionRange","ast::parse::Primitive","ast::ClassUnicode","ast::ClassUnicodeKind","hir::ClassUnicodeRange","hir::Capture","either::Either","ast::Alternation","ast::HexLiteralKind","ast::ClassSetRange","ast::Flag","ast::ClassPerlKind","ast::ClassBracketed","ast::ErrorKind","ast::Comment","ast::CaptureName","ast::SpecialLiteralKind","hir::Error","ast::ClassPerl","hir::ClassBytes","hir::PropertiesI","ast::RepetitionKind","ast::Literal","ast::ClassSet","error::Error","ast::ClassAscii","hir::LookSet","ast::Repetition","ast::ClassAsciiKind","hir::ErrorKind","ast::ClassSetItem","hir::Repetition","ast::LiteralKind","hir::interval::IntervalSet","ast::Concat","hir::Hir","hir::ClassBytesRange","ast::ClassSetUnion","hir::ClassUnicode","ast::Assertion","ast::AssertionKind","ast::ClassUnicodeOpKind","ast::RepetitionOp","ast::WithComments","hir::HirKind","hir::literal::Seq","ast::Position","utf8::Utf8Sequence","ast::SetFlags"],"Right":["ast::Alternation","hir::Properties","hir::Capture","hir::LookSet","hir::Literal","ast::Repetition","hir::ClassUnicodeRange","utf8::Utf8Sequence","ast::ClassSetBinaryOpKind","ast::RepetitionRange","ast::FlagsItemKind","ast::AssertionKind","error::Error","hir::Error","ast::Concat","ast::Literal","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","ast::ClassPerl","ast::SpecialLiteralKind","ast::SetFlags","ast::Flag","ast::HexLiteralKind","hir::interval::IntervalSet","ast::ClassPerlKind","hir::Dot","ast::ClassSetUnion","ast::RepetitionOp","hir::Class","ast::ClassBracketed","ast::Comment","ast::RepetitionKind","hir::PropertiesI","ast::ClassAscii","either::Either","ast::ClassSet","ast::ClassSetRange","ast::Assertion","ast::WithComments","ast::ClassSetBinaryOp","ast::GroupKind","ast::Flags","ast::Error","ast::ClassUnicode","hir::ClassBytesRange","ast::FlagsItem","ast::Ast","hir::HirKind","ast::Class","ast::Position","ast::ClassAsciiKind","hir::Look","hir::ClassBytes","utf8::Utf8Range","ast::ClassSetItem","hir::literal::Seq","ast::ErrorKind","hir::Hir","ast::Group","ast::parse::Primitive","ast::CaptureName","hir::ErrorKind","ast::LiteralKind","ast::Span","hir::literal::Literal","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","hir::Repetition","hir::ClassUnicode"]},"error::Formatter":{"E":["ast::Ast","hir::ErrorKind","unicode::UnicodeWordError","hir::Hir","error::Formatter","error::Error","ast::Error","ast::ErrorKind","<&T as std::fmt::Debug>","unicode::CaseFoldError","hir::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::Comment","ast::ClassSetBinaryOpKind","unicode::UnicodeWordError","hir::Class","ast::parse::Primitive","ast::parse::GroupState","hir::print::Writer","hir::print::Printer","error::Error","ast::visitor::ClassInduct","hir::LookSet","hir::interval::IntervalSetIter","hir::translate::Flags","ast::WithComments","ast::Group","parser::Parser","ast::Repetition","debug::Byte","ast::ClassPerl","hir::ClassUnicodeIter","ast::Flag","ast::print::Printer","ast::SetFlags","ast::parse::Parser","ast::parse::ClassState","utf8::ScalarRange","hir::ClassBytesRange","hir::ClassUnicodeRange","ast::RepetitionOp","ast::Position","ast::ClassSetUnion","hir::literal::State","hir::Dot","utf8::Utf8Range","hir::literal::Seq","ast::Flags","ast::ClassBracketed","ast::Span","ast::Concat","ast::ClassAsciiKind","ast::ClassSetItem","either::Either","hir::literal::PreferenceTrie","hir::translate::Translator","unicode::CanonicalClassQuery","hir::literal::ExtractKind","ast::Error","ast::LiteralKind","hir::translate::HirFrame","unicode::SimpleCaseFolder","hir::ErrorKind","ast::HexLiteralKind","ast::Assertion","hir::print::PrinterBuilder","ast::print::Writer","hir::translate::TranslatorBuilder","unicode::ClassQuery","hir::Properties","ast::visitor::ClassFrame","ast::Alternation","ast::AssertionKind","ast::ClassUnicodeKind","ast::print::PrinterBuilder","ast::ClassSetRange","hir::LookSetIter","debug::Bytes","hir::translate::TranslatorI","error::Formatter","hir::literal::Literal","ast::ClassSet","hir::HirKind","hir::ClassBytesIter","ast::Literal","hir::literal::Extractor","ast::RepetitionKind","ast::parse::ParserI","hir::ClassUnicode","hir::Capture","unicode::Error","ast::Ast","utf8::Utf8Sequence","utf8::Utf8Sequences","ast::ClassSetBinaryOp","<&mut T as std::fmt::Debug>","hir::Literal","ast::GroupKind","ast::ClassAscii","ast::CaptureName","ast::ClassPerlKind","ast::parse::NestLimiter","hir::Hir","ast::RepetitionRange","ast::ErrorKind","hir::Repetition","ast::Class","parser::ParserBuilder","hir::PropertiesI","ast::ClassUnicodeOpKind","ast::parse::ParserBuilder","hir::Error","ast::SpecialLiteralKind","unicode::CaseFoldError","hir::Look","ast::FlagsItemKind","ast::ClassUnicode","hir::ClassBytes","ast::FlagsItem","hir::interval::IntervalSet"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::Writer<W>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::print::Writer<W> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::print::Writer<W> as std::fmt::Debug>::fmt(p0, p1);
+<hir::print::Writer<W>>::fmt(p0, p1);
-----------------
src/hir/print.rs <hir::print::Writer<W> as hir::visitor::Visitor>::finish
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<W> as hir::visitor::Visitor>::finish":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<W> as hir::visitor::Visitor>::finish":{"W":["core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>","std::string::String","std::ffi::OsString"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::print::Writer<W>
+p0.finish();
+<hir::print::Writer<W> as hir::visitor::Visitor>::finish(p0);
+crate::<hir::print::Writer<W> as hir::visitor::Visitor>::finish(p0);
+<hir::print::Writer<W>>::finish(p0);
-----------------
src/hir/print.rs <hir::print::Writer<W> as hir::visitor::Visitor>::visit_pre
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_pre":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_pre":{"W":["std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::string::String","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_pre(p1);
+<hir::print::Writer<W> as hir::visitor::Visitor>::visit_pre(p0, p1);
+crate::<hir::print::Writer<W> as hir::visitor::Visitor>::visit_pre(p0, p1);
+<hir::print::Writer<W>>::visit_pre(p0, p1);
-----------------
src/hir/print.rs <hir::print::Writer<W> as hir::visitor::Visitor>::visit_post
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_post":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_post":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::string::String","std::fmt::Formatter<'_>","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_post(p1);
+<hir::print::Writer<W> as hir::visitor::Visitor>::visit_post(p0, p1);
+crate::<hir::print::Writer<W> as hir::visitor::Visitor>::visit_post(p0, p1);
+<hir::print::Writer<W>>::visit_post(p0, p1);
-----------------
src/hir/print.rs <hir::print::Writer<W> as hir::visitor::Visitor>::visit_alternation_in
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_alternation_in":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_alternation_in":{"W":["std::string::String","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<W>
+p0.visit_alternation_in();
+<hir::print::Writer<W> as hir::visitor::Visitor>::visit_alternation_in(p0);
+crate::<hir::print::Writer<W> as hir::visitor::Visitor>::visit_alternation_in(p0);
+<hir::print::Writer<W>>::visit_alternation_in(p0);
-----------------
src/hir/print.rs hir::print::Writer::<W>::write_literal_char
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<W>::write_literal_char":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<W>::write_literal_char":{"W":["std::string::String","std::fmt::Formatter<'_>","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<W>
let mut p1 = 'a'; // None+char
+p0.write_literal_char(p1);
+hir::print::Writer::<W>::write_literal_char(p0, p1);
+crate::hir::print::Writer::<W>::write_literal_char(p0, p1);
+<hir::print::Writer<W>>::write_literal_char(p0, p1);
-----------------
src/hir/print.rs hir::print::Writer::<W>::write_literal_byte
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<W>::write_literal_byte":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<W>::write_literal_byte":{"W":["std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::error::Indented<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<W>
let mut p1 = 0u8; // None+u8
+p0.write_literal_byte(p1);
+hir::print::Writer::<W>::write_literal_byte(p0, p1);
+crate::hir::print::Writer::<W>::write_literal_byte(p0, p1);
+<hir::print::Writer<W>>::write_literal_byte(p0, p1);
-----------------
src/hir/print.rs hir::print::Writer::<W>::write_literal_class_byte
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<W>::write_literal_class_byte":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<W>::write_literal_class_byte":{"W":["std::error::Indented<'_, T>","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::string::String","std::net::display_buffer::DisplayBuffer<SIZE>","std::io::Write::write_fmt::Adapter<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<W>
let mut p1 = 0u8; // None+u8
+p0.write_literal_class_byte(p1);
+hir::print::Writer::<W>::write_literal_class_byte(p0, p1);
+crate::hir::print::Writer::<W>::write_literal_class_byte(p0, p1);
+<hir::print::Writer<W>>::write_literal_class_byte(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::TranslatorBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
+p0.clone();
+<hir::translate::TranslatorBuilder as std::clone::Clone>::clone(p0);
+crate::<hir::translate::TranslatorBuilder as std::clone::Clone>::clone(p0);
+<hir::translate::TranslatorBuilder>::clone(p0);
-----------------
src/hir/translate.rs <hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::TranslatorBuilder>::fmt(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::TranslatorBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<hir::translate::TranslatorBuilder as std::default::Default>::default();
+crate::<hir::translate::TranslatorBuilder as std::default::Default>::default();
+<hir::translate::TranslatorBuilder>::default();
-----------------
src/hir/translate.rs hir::translate::TranslatorBuilder::new
deps:{}
candidates:{}
+hir::translate::TranslatorBuilder::new();
+crate::hir::translate::TranslatorBuilder::new();
+<hir::translate::TranslatorBuilder>::new();
-----------------
src/hir/translate.rs hir::translate::TranslatorBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
+p0.build();
+hir::translate::TranslatorBuilder::build(p0);
+crate::hir::translate::TranslatorBuilder::build(p0);
+<hir::translate::TranslatorBuilder>::build(p0);
-----------------
src/hir/translate.rs hir::translate::TranslatorBuilder::utf8
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.utf8(p1);
+hir::translate::TranslatorBuilder::utf8(p0, p1);
+crate::hir::translate::TranslatorBuilder::utf8(p0, p1);
+<hir::translate::TranslatorBuilder>::utf8(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+hir::translate::TranslatorBuilder::case_insensitive(p0, p1);
+crate::hir::translate::TranslatorBuilder::case_insensitive(p0, p1);
+<hir::translate::TranslatorBuilder>::case_insensitive(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+hir::translate::TranslatorBuilder::multi_line(p0, p1);
+crate::hir::translate::TranslatorBuilder::multi_line(p0, p1);
+<hir::translate::TranslatorBuilder>::multi_line(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+hir::translate::TranslatorBuilder::dot_matches_new_line(p0, p1);
+crate::hir::translate::TranslatorBuilder::dot_matches_new_line(p0, p1);
+<hir::translate::TranslatorBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorBuilder::crlf
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.crlf(p1);
+hir::translate::TranslatorBuilder::crlf(p0, p1);
+crate::hir::translate::TranslatorBuilder::crlf(p0, p1);
+<hir::translate::TranslatorBuilder>::crlf(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+hir::translate::TranslatorBuilder::swap_greed(p0, p1);
+crate::hir::translate::TranslatorBuilder::swap_greed(p0, p1);
+<hir::translate::TranslatorBuilder>::swap_greed(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+hir::translate::TranslatorBuilder::unicode(p0, p1);
+crate::hir::translate::TranslatorBuilder::unicode(p0, p1);
+<hir::translate::TranslatorBuilder>::unicode(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::Translator as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Translator
+p0.clone();
+<hir::translate::Translator as std::clone::Clone>::clone(p0);
+crate::<hir::translate::Translator as std::clone::Clone>::clone(p0);
+<hir::translate::Translator>::clone(p0);
-----------------
src/hir/translate.rs <hir::translate::Translator as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Translator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::Translator as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::Translator as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::Translator>::fmt(p0, p1);
-----------------
src/hir/translate.rs hir::translate::Translator::new
deps:{}
candidates:{}
+hir::translate::Translator::new();
+crate::hir::translate::Translator::new();
+<hir::translate::Translator>::new();
-----------------
src/hir/translate.rs hir::translate::Translator::translate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::Translator
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.translate(&p1, p2);
+hir::translate::Translator::translate(p0, &p1, p2);
+crate::hir::translate::Translator::translate(p0, &p1, p2);
+<hir::translate::Translator>::translate(p0, &p1, p2);
-----------------
src/hir/translate.rs <hir::translate::HirFrame as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.clone();
+<hir::translate::HirFrame as std::clone::Clone>::clone(p0);
+crate::<hir::translate::HirFrame as std::clone::Clone>::clone(p0);
+<hir::translate::HirFrame>::clone(p0);
-----------------
src/hir/translate.rs <hir::translate::HirFrame as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::HirFrame as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::HirFrame as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::HirFrame>::fmt(p0, p1);
-----------------
src/hir/translate.rs hir::translate::HirFrame::unwrap_expr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_expr();
+hir::translate::HirFrame::unwrap_expr(p0);
+crate::hir::translate::HirFrame::unwrap_expr(p0);
+<hir::translate::HirFrame>::unwrap_expr(p0);
-----------------
src/hir/translate.rs hir::translate::HirFrame::unwrap_class_unicode
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_class_unicode();
+hir::translate::HirFrame::unwrap_class_unicode(p0);
+crate::hir::translate::HirFrame::unwrap_class_unicode(p0);
+<hir::translate::HirFrame>::unwrap_class_unicode(p0);
-----------------
src/hir/translate.rs hir::translate::HirFrame::unwrap_class_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_class_bytes();
+hir::translate::HirFrame::unwrap_class_bytes(p0);
+crate::hir::translate::HirFrame::unwrap_class_bytes(p0);
+<hir::translate::HirFrame>::unwrap_class_bytes(p0);
-----------------
src/hir/translate.rs hir::translate::HirFrame::unwrap_repetition
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_repetition();
+hir::translate::HirFrame::unwrap_repetition(p0);
+crate::hir::translate::HirFrame::unwrap_repetition(p0);
+<hir::translate::HirFrame>::unwrap_repetition(p0);
-----------------
src/hir/translate.rs hir::translate::HirFrame::unwrap_group
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_group();
+hir::translate::HirFrame::unwrap_group(p0);
+crate::hir::translate::HirFrame::unwrap_group(p0);
+<hir::translate::HirFrame>::unwrap_group(p0);
-----------------
src/hir/translate.rs hir::translate::HirFrame::unwrap_alternation_pipe
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_alternation_pipe();
+hir::translate::HirFrame::unwrap_alternation_pipe(p0);
+crate::hir::translate::HirFrame::unwrap_alternation_pipe(p0);
+<hir::translate::HirFrame>::unwrap_alternation_pipe(p0);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish
't,'p
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.finish();
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish(p0);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish(p0);
+<hir::translate::TranslatorI<'t, 'p>>::finish(p0);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_pre(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_post(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_alternation_in
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.visit_alternation_in();
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_alternation_in(p0);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_alternation_in(p0);
+<hir::translate::TranslatorI<'t, 'p>>::visit_alternation_in(p0);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_item_pre(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_item_post(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_pre(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_binary_op_pre(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_in(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_binary_op_in(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_post(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_binary_op_post(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.clone();
+<hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone(p0);
+crate::<hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone(p0);
+<hir::translate::TranslatorI<'t, 'p>>::clone(p0);
-----------------
src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::fmt(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::new
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Translator
let mut p1 = "sample"; // None+&str
+hir::translate::TranslatorI::<'t, 'p>::new(p0, &p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::new(p0, &p1);
+<hir::translate::TranslatorI<'t, 'p>>::new(p0, &p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::trans
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.trans();
+hir::translate::TranslatorI::<'t, 'p>::trans(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::trans(p0);
+<hir::translate::TranslatorI<'t, 'p>>::trans(p0);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::push
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.push(p1);
+hir::translate::TranslatorI::<'t, 'p>::push(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::push(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::push(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::push_char
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = 'a'; // None+char
+p0.push_char(p1);
+hir::translate::TranslatorI::<'t, 'p>::push_char(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::push_char(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::push_char(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::push_byte
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = 0u8; // None+u8
+p0.push_byte(p1);
+hir::translate::TranslatorI::<'t, 'p>::push_byte(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::push_byte(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::push_byte(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::pop
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.pop();
+hir::translate::TranslatorI::<'t, 'p>::pop(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::pop(p0);
+<hir::translate::TranslatorI<'t, 'p>>::pop(p0);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::pop_concat_expr
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.pop_concat_expr();
+hir::translate::TranslatorI::<'t, 'p>::pop_concat_expr(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::pop_concat_expr(p0);
+<hir::translate::TranslatorI<'t, 'p>>::pop_concat_expr(p0);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::pop_alt_expr
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.pop_alt_expr();
+hir::translate::TranslatorI::<'t, 'p>::pop_alt_expr(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::pop_alt_expr(p0);
+<hir::translate::TranslatorI<'t, 'p>>::pop_alt_expr(p0);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::error
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.error(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::error(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::error(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::error(p0, p1, p2);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::flags
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.flags();
+hir::translate::TranslatorI::<'t, 'p>::flags(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::flags(p0);
+<hir::translate::TranslatorI<'t, 'p>>::flags(p0);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::set_flags
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.set_flags(p1);
+hir::translate::TranslatorI::<'t, 'p>::set_flags(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::set_flags(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::set_flags(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::ast_literal_to_scalar
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.ast_literal_to_scalar(p1);
+hir::translate::TranslatorI::<'t, 'p>::ast_literal_to_scalar(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::ast_literal_to_scalar(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::ast_literal_to_scalar(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::case_fold_char
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = 'a'; // None+char
+p0.case_fold_char(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::case_fold_char(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::case_fold_char(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::case_fold_char(p0, p1, p2);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_dot
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
+p0.hir_dot(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_dot(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_dot(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_dot(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_assertion
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.hir_assertion(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_assertion(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_assertion(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_assertion(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_capture
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
let mut p2 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.hir_capture(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_capture(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_capture(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_capture(p0, p1, p2);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_repetition
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
let mut p2 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.hir_repetition(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_repetition(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_repetition(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_repetition(p0, p1, p2);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.hir_unicode_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_unicode_class(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_ascii_unicode_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.hir_ascii_unicode_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_ascii_unicode_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_ascii_unicode_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_ascii_unicode_class(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_ascii_byte_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.hir_ascii_byte_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_ascii_byte_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_ascii_byte_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_ascii_byte_class(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.hir_perl_unicode_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_perl_unicode_class(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.hir_perl_byte_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_perl_byte_class(p0, p1);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = MaybeUninit::uninit().assume_init(); // std::result::Result<hir::ClassUnicode, unicode::Error>
+p0.convert_unicode_class_error(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::convert_unicode_class_error(p0, p1, p2);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = true; // None+bool
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.unicode_fold_and_negate(p1, p2, p3);
+hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate(p0, p1, p2, p3);
+crate::hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate(p0, p1, p2, p3);
+<hir::translate::TranslatorI<'t, 'p>>::unicode_fold_and_negate(p0, p1, p2, p3);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = true; // None+bool
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.bytes_fold_and_negate(p1, p2, p3);
+hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate(p0, p1, p2, p3);
+crate::hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate(p0, p1, p2, p3);
+<hir::translate::TranslatorI<'t, 'p>>::bytes_fold_and_negate(p0, p1, p2, p3);
-----------------
src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::class_literal_byte
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.class_literal_byte(p1);
+hir::translate::TranslatorI::<'t, 'p>::class_literal_byte(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::class_literal_byte(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::class_literal_byte(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::Flags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.clone();
+<hir::translate::Flags as std::clone::Clone>::clone(p0);
+crate::<hir::translate::Flags as std::clone::Clone>::clone(p0);
+<hir::translate::Flags>::clone(p0);
-----------------
src/hir/translate.rs <hir::translate::Flags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::Flags as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::Flags as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::Flags>::fmt(p0, p1);
-----------------
src/hir/translate.rs <hir::translate::Flags as std::default::Default>::default
deps:{}
candidates:{}
+<hir::translate::Flags as std::default::Default>::default();
+crate::<hir::translate::Flags as std::default::Default>::default();
+<hir::translate::Flags>::default();
-----------------
src/hir/translate.rs hir::translate::Flags::from_ast
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+hir::translate::Flags::from_ast(p0);
+crate::hir::translate::Flags::from_ast(p0);
+<hir::translate::Flags>::from_ast(p0);
-----------------
src/hir/translate.rs hir::translate::Flags::merge
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::Flags
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.merge(p1);
+hir::translate::Flags::merge(p0, p1);
+crate::hir::translate::Flags::merge(p0, p1);
+<hir::translate::Flags>::merge(p0, p1);
-----------------
src/hir/translate.rs hir::translate::Flags::dot
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.dot();
+hir::translate::Flags::dot(p0);
+crate::hir::translate::Flags::dot(p0);
+<hir::translate::Flags>::dot(p0);
-----------------
src/hir/translate.rs hir::translate::Flags::case_insensitive
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.case_insensitive();
+hir::translate::Flags::case_insensitive(p0);
+crate::hir::translate::Flags::case_insensitive(p0);
+<hir::translate::Flags>::case_insensitive(p0);
-----------------
src/hir/translate.rs hir::translate::Flags::multi_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.multi_line();
+hir::translate::Flags::multi_line(p0);
+crate::hir::translate::Flags::multi_line(p0);
+<hir::translate::Flags>::multi_line(p0);
-----------------
src/hir/translate.rs hir::translate::Flags::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.dot_matches_new_line();
+hir::translate::Flags::dot_matches_new_line(p0);
+crate::hir::translate::Flags::dot_matches_new_line(p0);
+<hir::translate::Flags>::dot_matches_new_line(p0);
-----------------
src/hir/translate.rs hir::translate::Flags::swap_greed
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.swap_greed();
+hir::translate::Flags::swap_greed(p0);
+crate::hir::translate::Flags::swap_greed(p0);
+<hir::translate::Flags>::swap_greed(p0);
-----------------
src/hir/translate.rs hir::translate::Flags::unicode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.unicode();
+hir::translate::Flags::unicode(p0);
+crate::hir::translate::Flags::unicode(p0);
+<hir::translate::Flags>::unicode(p0);
-----------------
src/hir/translate.rs hir::translate::Flags::crlf
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.crlf();
+hir::translate::Flags::crlf(p0);
+crate::hir::translate::Flags::crlf(p0);
+<hir::translate::Flags>::crlf(p0);
-----------------
src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::new
'a
deps:{}
candidates:{}
+hir::visitor::HeapVisitor::<'a>::new();
+crate::hir::visitor::HeapVisitor::<'a>::new();
+<hir::visitor::HeapVisitor<'a>>::new();
-----------------
src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::visit
'a
deps:{"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"hir::visitor::HeapVisitor::<'a>::visit":{"V":["std::marker::Sized","hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"hir::visitor::HeapVisitor::<'a>::visit":{"V":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.visit(p1, p2);
+hir::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+crate::hir::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+<hir::visitor::HeapVisitor<'a>>::visit(p0, p1, p2);
-----------------
src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::induct
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.induct(p1);
+hir::visitor::HeapVisitor::<'a>::induct(p0, p1);
+crate::hir::visitor::HeapVisitor::<'a>::induct(p0, p1);
+<hir::visitor::HeapVisitor<'a>>::induct(p0, p1);
-----------------
src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::pop
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::visitor::HeapVisitor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::visitor::Frame<'a>
+p0.pop(p1);
+hir::visitor::HeapVisitor::<'a>::pop(p0, p1);
+crate::hir::visitor::HeapVisitor::<'a>::pop(p0, p1);
+<hir::visitor::HeapVisitor<'a>>::pop(p0, p1);
-----------------
src/hir/visitor.rs hir::visitor::Frame::<'a>::child
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::visitor::Frame<'a>
+p0.child();
+hir::visitor::Frame::<'a>::child(p0);
+crate::hir::visitor::Frame::<'a>::child(p0);
+<hir::visitor::Frame<'a>>::child(p0);
-----------------
src/hir/mod.rs <hir::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.clone();
+<hir::Error as std::clone::Clone>::clone(p0);
+crate::<hir::Error as std::clone::Clone>::clone(p0);
+<hir::Error>::clone(p0);
-----------------
src/hir/mod.rs <hir::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Error as std::fmt::Debug>::fmt(p0, p1);
+<hir::Error>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.assert_receiver_is_total_eq();
+<hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Error>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.eq(p1);
+<hir::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Error as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Error>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::Error::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.kind();
+hir::Error::kind(p0);
+crate::hir::Error::kind(p0);
+<hir::Error>::kind(p0);
-----------------
src/hir/mod.rs hir::Error::pattern
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.pattern();
+hir::Error::pattern(p0);
+crate::hir::Error::pattern(p0);
+<hir::Error>::pattern(p0);
-----------------
src/hir/mod.rs hir::Error::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.span();
+hir::Error::span(p0);
+crate::hir::Error::span(p0);
+<hir::Error>::span(p0);
-----------------
src/hir/mod.rs <hir::ErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.clone();
+<hir::ErrorKind as std::clone::Clone>::clone(p0);
+crate::<hir::ErrorKind as std::clone::Clone>::clone(p0);
+<hir::ErrorKind>::clone(p0);
-----------------
src/hir/mod.rs <hir::ErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::ErrorKind>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.assert_receiver_is_total_eq();
+<hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::ErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.eq(p1);
+<hir::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ErrorKind>::eq(p0, p1);
-----------------
src/hir/mod.rs <hir::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<hir::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<hir::Error as std::fmt::Display>::fmt(p0, p1);
+<hir::Error>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::ErrorKind as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<hir::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+crate::<hir::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+<hir::ErrorKind>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Hir as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.clone();
+<hir::Hir as std::clone::Clone>::clone(p0);
+crate::<hir::Hir as std::clone::Clone>::clone(p0);
+<hir::Hir>::clone(p0);
-----------------
src/hir/mod.rs <hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.assert_receiver_is_total_eq();
+<hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Hir>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::Hir as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.eq(p1);
+<hir::Hir as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Hir as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Hir>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::Hir::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.kind();
+hir::Hir::kind(p0);
+crate::hir::Hir::kind(p0);
+<hir::Hir>::kind(p0);
-----------------
src/hir/mod.rs hir::Hir::into_kind
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.into_kind();
+hir::Hir::into_kind(p0);
+crate::hir::Hir::into_kind(p0);
+<hir::Hir>::into_kind(p0);
-----------------
src/hir/mod.rs hir::Hir::properties
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.properties();
+hir::Hir::properties(p0);
+crate::hir::Hir::properties(p0);
+<hir::Hir>::properties(p0);
-----------------
src/hir/mod.rs hir::Hir::into_parts
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.into_parts();
+hir::Hir::into_parts(p0);
+crate::hir::Hir::into_parts(p0);
+<hir::Hir>::into_parts(p0);
-----------------
src/hir/mod.rs hir::Hir::empty
deps:{}
candidates:{}
+hir::Hir::empty();
+crate::hir::Hir::empty();
+<hir::Hir>::empty();
-----------------
src/hir/mod.rs hir::Hir::fail
deps:{}
candidates:{}
+hir::Hir::fail();
+crate::hir::Hir::fail();
+<hir::Hir>::fail();
-----------------
src/hir/mod.rs hir::Hir::literal
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"hir::Hir::literal":{"B":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"hir::Hir::literal":{"B":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // B
+hir::Hir::literal(p0);
+crate::hir::Hir::literal(p0);
+<hir::Hir>::literal(p0);
-----------------
src/hir/mod.rs hir::Hir::class
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Class
+hir::Hir::class(p0);
+crate::hir::Hir::class(p0);
+<hir::Hir>::class(p0);
-----------------
src/hir/mod.rs hir::Hir::look
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Look
+hir::Hir::look(p0);
+crate::hir::Hir::look(p0);
+<hir::Hir>::look(p0);
-----------------
src/hir/mod.rs hir::Hir::repetition
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Repetition
+hir::Hir::repetition(p0);
+crate::hir::Hir::repetition(p0);
+<hir::Hir>::repetition(p0);
-----------------
src/hir/mod.rs hir::Hir::capture
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Capture
+hir::Hir::capture(p0);
+crate::hir::Hir::capture(p0);
+<hir::Hir>::capture(p0);
-----------------
src/hir/mod.rs hir::Hir::concat
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::Hir>
+hir::Hir::concat(p0);
+crate::hir::Hir::concat(p0);
+<hir::Hir>::concat(p0);
-----------------
src/hir/mod.rs hir::Hir::alternation
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::Hir>
+hir::Hir::alternation(p0);
+crate::hir::Hir::alternation(p0);
+<hir::Hir>::alternation(p0);
-----------------
src/hir/mod.rs hir::Hir::dot
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Dot
+hir::Hir::dot(p0);
+crate::hir::Hir::dot(p0);
+<hir::Hir>::dot(p0);
-----------------
src/hir/mod.rs <hir::HirKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.clone();
+<hir::HirKind as std::clone::Clone>::clone(p0);
+crate::<hir::HirKind as std::clone::Clone>::clone(p0);
+<hir::HirKind>::clone(p0);
-----------------
src/hir/mod.rs <hir::HirKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::HirKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::HirKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::HirKind>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.assert_receiver_is_total_eq();
+<hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::HirKind>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::HirKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.eq(p1);
+<hir::HirKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::HirKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::HirKind>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::HirKind::subs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.subs();
+hir::HirKind::subs(p0);
+crate::hir::HirKind::subs(p0);
+<hir::HirKind>::subs(p0);
-----------------
src/hir/mod.rs <hir::Hir as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Hir as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Hir as std::fmt::Debug>::fmt(p0, p1);
+<hir::Hir>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Hir as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<hir::Hir as std::fmt::Display>::fmt(p0, p1);
+crate::<hir::Hir as std::fmt::Display>::fmt(p0, p1);
+<hir::Hir>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Literal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.clone();
+<hir::Literal as std::clone::Clone>::clone(p0);
+crate::<hir::Literal as std::clone::Clone>::clone(p0);
+<hir::Literal>::clone(p0);
-----------------
src/hir/mod.rs <hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.assert_receiver_is_total_eq();
+<hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Literal>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::Literal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.eq(p1);
+<hir::Literal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Literal as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Literal>::eq(p0, p1);
-----------------
src/hir/mod.rs <hir::Literal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Literal as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Literal as std::fmt::Debug>::fmt(p0, p1);
+<hir::Literal>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Class as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.clone();
+<hir::Class as std::clone::Clone>::clone(p0);
+crate::<hir::Class as std::clone::Clone>::clone(p0);
+<hir::Class>::clone(p0);
-----------------
src/hir/mod.rs <hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.assert_receiver_is_total_eq();
+<hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Class>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::Class as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.eq(p1);
+<hir::Class as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Class as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Class>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::Class::case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Class
+p0.case_fold_simple();
+hir::Class::case_fold_simple(p0);
+crate::hir::Class::case_fold_simple(p0);
+<hir::Class>::case_fold_simple(p0);
-----------------
src/hir/mod.rs hir::Class::try_case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Class
+p0.try_case_fold_simple();
+hir::Class::try_case_fold_simple(p0);
+crate::hir::Class::try_case_fold_simple(p0);
+<hir::Class>::try_case_fold_simple(p0);
-----------------
src/hir/mod.rs hir::Class::negate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Class
+p0.negate();
+hir::Class::negate(p0);
+crate::hir::Class::negate(p0);
+<hir::Class>::negate(p0);
-----------------
src/hir/mod.rs hir::Class::is_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.is_utf8();
+hir::Class::is_utf8(p0);
+crate::hir::Class::is_utf8(p0);
+<hir::Class>::is_utf8(p0);
-----------------
src/hir/mod.rs hir::Class::minimum_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.minimum_len();
+hir::Class::minimum_len(p0);
+crate::hir::Class::minimum_len(p0);
+<hir::Class>::minimum_len(p0);
-----------------
src/hir/mod.rs hir::Class::maximum_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.maximum_len();
+hir::Class::maximum_len(p0);
+crate::hir::Class::maximum_len(p0);
+<hir::Class>::maximum_len(p0);
-----------------
src/hir/mod.rs hir::Class::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.is_empty();
+hir::Class::is_empty(p0);
+crate::hir::Class::is_empty(p0);
+<hir::Class>::is_empty(p0);
-----------------
src/hir/mod.rs hir::Class::literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.literal();
+hir::Class::literal(p0);
+crate::hir::Class::literal(p0);
+<hir::Class>::literal(p0);
-----------------
src/hir/mod.rs <hir::Class as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Class as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Class as std::fmt::Debug>::fmt(p0, p1);
+<hir::Class>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassUnicode as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.clone();
+<hir::ClassUnicode as std::clone::Clone>::clone(p0);
+crate::<hir::ClassUnicode as std::clone::Clone>::clone(p0);
+<hir::ClassUnicode>::clone(p0);
-----------------
src/hir/mod.rs <hir::ClassUnicode as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassUnicode>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.assert_receiver_is_total_eq();
+<hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassUnicode>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::ClassUnicode as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.eq(p1);
+<hir::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassUnicode>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::ClassUnicode::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"either::Either":{"Left":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"],"Right":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::ClassUnicode::new":{"I":["std::marker::Sized","std::iter::IntoIterator"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["hir::ClassBytesIter","<&mut I as std::iter::Iterator>","utf8::Utf8Sequences","hir::interval::IntervalSetIter","hir::LookSetIter","hir::ClassUnicodeIter"]},"ast::parse::NestLimiter":{"P":["std::string::String","std::ffi::CString","std::boxed::Box<T, A>","std::path::PathBuf","std::ffi::OsString","<&T as std::fmt::Debug>","std::rc::Rc<T>","std::sync::Arc<T>","std::vec::Vec<T, A>"]},"ast::parse::ParserI":{"P":["std::ffi::OsString","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::rc::Rc<T>","std::path::PathBuf","<&T as std::fmt::Debug>","std::ffi::CString","std::string::String","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::SetFlags","ast::RepetitionRange","ast::Comment","ast::ClassBracketed","ast::Ast","ast::ClassUnicodeKind","ast::Class","hir::Capture","ast::HexLiteralKind","ast::Position","ast::ClassSetBinaryOpKind","ast::Concat","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","hir::Properties","utf8::Utf8Range","ast::ClassUnicodeOpKind","ast::ErrorKind","either::Either","ast::LiteralKind","hir::ErrorKind","ast::ClassSetRange","hir::ClassBytes","ast::WithComments","ast::Literal","hir::HirKind","ast::Alternation","hir::interval::IntervalSet","ast::ClassSetBinaryOp","hir::Literal","ast::parse::Primitive","ast::FlagsItem","error::Error","ast::RepetitionOp","ast::Assertion","hir::Dot","hir::ClassBytesRange","hir::Look","ast::AssertionKind","utf8::Utf8Sequence","ast::Span","ast::Repetition","hir::literal::Seq","hir::LookSet","ast::ClassAsciiKind","ast::ClassAscii","ast::CaptureName","ast::Error","ast::ClassPerl","ast::Flag","ast::ClassSet","ast::ClassSetItem","ast::Flags","hir::Error","ast::ClassUnicode","ast::FlagsItemKind","hir::ClassUnicodeRange","hir::Hir","hir::ClassUnicode","hir::literal::Literal","ast::ClassPerlKind","hir::PropertiesI","ast::Group","ast::RepetitionKind","ast::SpecialLiteralKind","hir::Class","hir::Repetition","ast::GroupKind","ast::ClassSetUnion"],"Right":["ast::SpecialLiteralKind","ast::ClassBracketed","hir::literal::Literal","ast::ClassSetUnion","utf8::Utf8Range","ast::HexLiteralKind","ast::ClassPerl","error::Error","ast::Literal","ast::Class","ast::Assertion","hir::ClassUnicodeRange","ast::WithComments","ast::ClassUnicodeOpKind","ast::Span","ast::LiteralKind","ast::FlagsItem","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","ast::ClassAsciiKind","ast::CaptureName","ast::parse::Primitive","utf8::Utf8Sequence","ast::SetFlags","ast::ErrorKind","ast::ClassUnicode","ast::ClassSetBinaryOpKind","hir::ErrorKind","ast::GroupKind","hir::Class","ast::Alternation","hir::ClassUnicode","hir::interval::IntervalSet","ast::Comment","hir::Capture","ast::RepetitionRange","hir::LookSet","hir::Dot","ast::ClassSetBinaryOp","ast::Concat","ast::Flag","ast::ClassSet","either::Either","ast::Flags","hir::Repetition","hir::HirKind","hir::Look","ast::AssertionKind","ast::ClassSetRange","ast::Group","ast::FlagsItemKind","ast::Ast","ast::ClassSetItem","ast::Error","hir::Properties","ast::ClassAscii","hir::ClassBytesRange","ast::ClassPerlKind","ast::RepetitionKind","hir::Hir","hir::Literal","hir::Error","hir::PropertiesI","hir::literal::Seq","ast::Position","ast::Repetition","ast::ClassUnicodeKind","hir::ClassBytes","ast::RepetitionOp"]},"error::Formatter":{"E":["hir::Error","error::Error","hir::ErrorKind","ast::Ast","ast::Error","unicode::CaseFoldError","<&mut T as std::fmt::Debug>","hir::Hir","error::Formatter","unicode::UnicodeWordError","ast::ErrorKind"]},"hir::ClassUnicode::new":{"I":["<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>","<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::ClassAsciiKind","ast::visitor::ClassFrame","hir::LookSetIter","ast::CaptureName","ast::parse::ClassState","hir::literal::State","unicode::CanonicalClassQuery","ast::ClassBracketed","hir::ClassBytes","ast::ClassSetUnion","ast::Class","hir::ClassBytesIter","hir::interval::IntervalSet","ast::Flags","hir::translate::Flags","either::Either","hir::Class","hir::Error","ast::Comment","hir::literal::Seq","hir::Hir","unicode::Error","utf8::ScalarRange","unicode::ClassQuery","utf8::Utf8Sequences","ast::ErrorKind","hir::print::Writer","ast::ClassUnicodeOpKind","ast::HexLiteralKind","utf8::Utf8Sequence","hir::literal::PreferenceTrie","ast::Repetition","ast::LiteralKind","ast::parse::NestLimiter","ast::Group","ast::Flag","ast::AssertionKind","hir::literal::Literal","ast::ClassSetBinaryOpKind","error::Formatter","ast::print::PrinterBuilder","ast::Assertion","hir::Properties","hir::PropertiesI","hir::translate::TranslatorI","ast::RepetitionOp","ast::Span","ast::SetFlags","ast::ClassUnicodeKind","ast::parse::Parser","ast::GroupKind","ast::print::Printer","ast::Literal","ast::ClassAscii","hir::print::Printer","ast::ClassPerlKind","hir::translate::TranslatorBuilder","ast::parse::ParserI","hir::Capture","hir::LookSet","hir::ClassUnicodeRange","ast::ClassSetBinaryOp","ast::RepetitionRange","ast::ClassSetItem","hir::ClassBytesRange","hir::Repetition","ast::WithComments","unicode::UnicodeWordError","ast::ClassSetRange","hir::Literal","parser::ParserBuilder","ast::parse::GroupState","ast::visitor::ClassInduct","ast::FlagsItem","ast::ClassPerl","ast::FlagsItemKind","ast::Ast","ast::SpecialLiteralKind","ast::ClassSet","parser::Parser","hir::literal::Extractor","hir::print::PrinterBuilder","ast::ClassUnicode","hir::ClassUnicode","hir::translate::Translator","hir::interval::IntervalSetIter","ast::parse::ParserBuilder","hir::Look","ast::RepetitionKind","debug::Bytes","unicode::CaseFoldError","ast::Concat","unicode::SimpleCaseFolder","ast::Position","hir::ClassUnicodeIter","hir::ErrorKind","ast::Alternation","utf8::Utf8Range","debug::Byte","<*mut T as std::fmt::Debug>","ast::parse::Primitive","hir::literal::ExtractKind","hir::translate::HirFrame","hir::Dot","hir::HirKind","ast::print::Writer","ast::Error","error::Error"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+hir::ClassUnicode::new(p0);
+crate::hir::ClassUnicode::new(p0);
+<hir::ClassUnicode>::new(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::empty
deps:{}
candidates:{}
+hir::ClassUnicode::empty();
+crate::hir::ClassUnicode::empty();
+<hir::ClassUnicode>::empty();
-----------------
src/hir/mod.rs hir::ClassUnicode::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.push(p1);
+hir::ClassUnicode::push(p0, p1);
+crate::hir::ClassUnicode::push(p0, p1);
+<hir::ClassUnicode>::push(p0, p1);
-----------------
src/hir/mod.rs hir::ClassUnicode::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.iter();
+hir::ClassUnicode::iter(p0);
+crate::hir::ClassUnicode::iter(p0);
+<hir::ClassUnicode>::iter(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::ranges
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.ranges();
+hir::ClassUnicode::ranges(p0);
+crate::hir::ClassUnicode::ranges(p0);
+<hir::ClassUnicode>::ranges(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.case_fold_simple();
+hir::ClassUnicode::case_fold_simple(p0);
+crate::hir::ClassUnicode::case_fold_simple(p0);
+<hir::ClassUnicode>::case_fold_simple(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::try_case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.try_case_fold_simple();
+hir::ClassUnicode::try_case_fold_simple(p0);
+crate::hir::ClassUnicode::try_case_fold_simple(p0);
+<hir::ClassUnicode>::try_case_fold_simple(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::negate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.negate();
+hir::ClassUnicode::negate(p0);
+crate::hir::ClassUnicode::negate(p0);
+<hir::ClassUnicode>::negate(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.union(p1);
+hir::ClassUnicode::union(p0, p1);
+crate::hir::ClassUnicode::union(p0, p1);
+<hir::ClassUnicode>::union(p0, p1);
-----------------
src/hir/mod.rs hir::ClassUnicode::intersect
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.intersect(p1);
+hir::ClassUnicode::intersect(p0, p1);
+crate::hir::ClassUnicode::intersect(p0, p1);
+<hir::ClassUnicode>::intersect(p0, p1);
-----------------
src/hir/mod.rs hir::ClassUnicode::difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.difference(p1);
+hir::ClassUnicode::difference(p0, p1);
+crate::hir::ClassUnicode::difference(p0, p1);
+<hir::ClassUnicode>::difference(p0, p1);
-----------------
src/hir/mod.rs hir::ClassUnicode::symmetric_difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.symmetric_difference(p1);
+hir::ClassUnicode::symmetric_difference(p0, p1);
+crate::hir::ClassUnicode::symmetric_difference(p0, p1);
+<hir::ClassUnicode>::symmetric_difference(p0, p1);
-----------------
src/hir/mod.rs hir::ClassUnicode::is_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.is_ascii();
+hir::ClassUnicode::is_ascii(p0);
+crate::hir::ClassUnicode::is_ascii(p0);
+<hir::ClassUnicode>::is_ascii(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::minimum_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.minimum_len();
+hir::ClassUnicode::minimum_len(p0);
+crate::hir::ClassUnicode::minimum_len(p0);
+<hir::ClassUnicode>::minimum_len(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::maximum_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.maximum_len();
+hir::ClassUnicode::maximum_len(p0);
+crate::hir::ClassUnicode::maximum_len(p0);
+<hir::ClassUnicode>::maximum_len(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.literal();
+hir::ClassUnicode::literal(p0);
+crate::hir::ClassUnicode::literal(p0);
+<hir::ClassUnicode>::literal(p0);
-----------------
src/hir/mod.rs hir::ClassUnicode::to_byte_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.to_byte_class();
+hir::ClassUnicode::to_byte_class(p0);
+crate::hir::ClassUnicode::to_byte_class(p0);
+<hir::ClassUnicode>::to_byte_class(p0);
-----------------
src/hir/mod.rs <hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassUnicodeIter<'a>>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeIter<'a>
+p0.next();
+<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next(p0);
+crate::<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next(p0);
+<hir::ClassUnicodeIter<'a>>::next(p0);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.clone();
+<hir::ClassUnicodeRange as std::clone::Clone>::clone(p0);
+crate::<hir::ClassUnicodeRange as std::clone::Clone>::clone(p0);
+<hir::ClassUnicodeRange>::clone(p0);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as std::default::Default>::default
deps:{}
candidates:{}
+<hir::ClassUnicodeRange as std::default::Default>::default();
+crate::<hir::ClassUnicodeRange as std::default::Default>::default();
+<hir::ClassUnicodeRange>::default();
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.assert_receiver_is_total_eq();
+<hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassUnicodeRange>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.eq(p1);
+<hir::ClassUnicodeRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassUnicodeRange as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassUnicodeRange>::eq(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.partial_cmp(p1);
+<hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<hir::ClassUnicodeRange>::partial_cmp(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.cmp(p1);
+<hir::ClassUnicodeRange as std::cmp::Ord>::cmp(p0, p1);
+crate::<hir::ClassUnicodeRange as std::cmp::Ord>::cmp(p0, p1);
+<hir::ClassUnicodeRange>::cmp(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassUnicodeRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassUnicodeRange as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassUnicodeRange>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::lower
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.lower();
+<hir::ClassUnicodeRange as hir::interval::Interval>::lower(p0);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::lower(p0);
+<hir::ClassUnicodeRange>::lower(p0);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::upper
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.upper();
+<hir::ClassUnicodeRange as hir::interval::Interval>::upper(p0);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::upper(p0);
+<hir::ClassUnicodeRange>::upper(p0);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::set_lower
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = 'a'; // None+char
+p0.set_lower(p1);
+<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower(p0, p1);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower(p0, p1);
+<hir::ClassUnicodeRange>::set_lower(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::set_upper
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = 'a'; // None+char
+p0.set_upper(p1);
+<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper(p0, p1);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper(p0, p1);
+<hir::ClassUnicodeRange>::set_upper(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::ClassUnicodeRange>
+p0.case_fold_simple(p1);
+<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+<hir::ClassUnicodeRange>::case_fold_simple(p0, p1);
-----------------
src/hir/mod.rs hir::ClassUnicodeRange::new
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+hir::ClassUnicodeRange::new(p0, p1);
+crate::hir::ClassUnicodeRange::new(p0, p1);
+<hir::ClassUnicodeRange>::new(p0, p1);
-----------------
src/hir/mod.rs hir::ClassUnicodeRange::start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.start();
+hir::ClassUnicodeRange::start(p0);
+crate::hir::ClassUnicodeRange::start(p0);
+<hir::ClassUnicodeRange>::start(p0);
-----------------
src/hir/mod.rs hir::ClassUnicodeRange::end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.end();
+hir::ClassUnicodeRange::end(p0);
+crate::hir::ClassUnicodeRange::end(p0);
+<hir::ClassUnicodeRange>::end(p0);
-----------------
src/hir/mod.rs hir::ClassUnicodeRange::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.len();
+hir::ClassUnicodeRange::len(p0);
+crate::hir::ClassUnicodeRange::len(p0);
+<hir::ClassUnicodeRange>::len(p0);
-----------------
src/hir/mod.rs <hir::ClassBytes as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.clone();
+<hir::ClassBytes as std::clone::Clone>::clone(p0);
+crate::<hir::ClassBytes as std::clone::Clone>::clone(p0);
+<hir::ClassBytes>::clone(p0);
-----------------
src/hir/mod.rs <hir::ClassBytes as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassBytes as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassBytes as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassBytes>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.assert_receiver_is_total_eq();
+<hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassBytes>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::ClassBytes as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.eq(p1);
+<hir::ClassBytes as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassBytes as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassBytes>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::ClassBytes::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::borrow::Borrow","std::clone::Clone","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"],"Right":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::ClassBytes::new":{"I":["std::iter::IntoIterator","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["hir::interval::Interval","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["hir::LookSetIter","utf8::Utf8Sequences","hir::ClassBytesIter","<&mut I as std::iter::Iterator>","hir::ClassUnicodeIter","hir::interval::IntervalSetIter"]},"ast::parse::NestLimiter":{"P":["std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::OsString","std::string::String","<&T as std::fmt::Debug>","std::path::PathBuf","std::rc::Rc<T>","std::boxed::Box<T, A>","std::ffi::CString"]},"ast::parse::ParserI":{"P":["std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::OsString","std::sync::Arc<T>","std::rc::Rc<T>","std::ffi::CString","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::ClassUnicodeKind","ast::Span","hir::HirKind","hir::Dot","ast::Class","ast::Position","utf8::Utf8Sequence","hir::PropertiesI","hir::Look","ast::LiteralKind","ast::Group","ast::SetFlags","hir::literal::Literal","ast::ClassSetBinaryOpKind","hir::ClassBytesRange","ast::RepetitionRange","ast::ClassSetBinaryOp","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","hir::Literal","ast::RepetitionOp","ast::AssertionKind","ast::ClassBracketed","ast::ErrorKind","ast::Flag","ast::Alternation","ast::ClassSetItem","hir::Capture","ast::Repetition","hir::Error","ast::GroupKind","hir::interval::IntervalSet","hir::Repetition","ast::Error","ast::FlagsItem","ast::ClassSetUnion","hir::ClassBytes","hir::ClassUnicode","ast::ClassSetRange","ast::ClassPerl","ast::ClassPerlKind","ast::ClassAsciiKind","hir::Hir","ast::FlagsItemKind","error::Error","ast::ClassAscii","hir::Properties","ast::HexLiteralKind","hir::LookSet","ast::WithComments","ast::Concat","hir::literal::Seq","hir::ClassUnicodeRange","ast::Comment","hir::ErrorKind","ast::RepetitionKind","ast::Flags","ast::ClassUnicodeOpKind","ast::Assertion","hir::Class","ast::ClassUnicode","ast::Ast","ast::SpecialLiteralKind","either::Either","ast::ClassSet","utf8::Utf8Range","ast::CaptureName","ast::Literal","ast::parse::Primitive"],"Right":["hir::ClassUnicodeRange","ast::ErrorKind","ast::ClassSetItem","hir::Class","hir::Hir","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::ClassPerlKind","ast::Comment","hir::ErrorKind","ast::ClassSet","ast::Flags","hir::interval::IntervalSet","ast::GroupKind","hir::literal::Literal","ast::Assertion","hir::ClassBytesRange","either::Either","hir::Literal","ast::HexLiteralKind","hir::Look","ast::LiteralKind","ast::SetFlags","ast::RepetitionOp","ast::ClassSetRange","ast::Class","ast::ClassSetUnion","ast::ClassUnicodeKind","ast::Error","hir::Properties","hir::ClassBytes","hir::HirKind","hir::Repetition","ast::Group","ast::RepetitionKind","hir::Error","hir::literal::Seq","ast::Ast","ast::ClassAsciiKind","utf8::Utf8Range","ast::ClassUnicode","ast::ClassUnicodeOpKind","ast::ClassBracketed","ast::Flag","hir::Dot","ast::ClassAscii","hir::Capture","ast::Repetition","ast::SpecialLiteralKind","hir::ClassUnicode","ast::Alternation","ast::Concat","ast::AssertionKind","ast::ClassSetBinaryOpKind","ast::ClassSetBinaryOp","ast::WithComments","ast::FlagsItemKind","ast::ClassPerl","ast::Literal","ast::Span","hir::PropertiesI","hir::LookSet","ast::FlagsItem","ast::CaptureName","utf8::Utf8Sequence","ast::RepetitionRange","ast::Position","ast::parse::Primitive","error::Error"]},"error::Formatter":{"E":["hir::Hir","unicode::UnicodeWordError","error::Formatter","ast::Error","ast::Ast","error::Error","hir::ErrorKind","unicode::CaseFoldError","hir::Error","<&mut T as std::fmt::Debug>","ast::ErrorKind"]},"hir::ClassBytes::new":{"I":["<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>","<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::parse::ParserI","ast::Ast","ast::Comment","ast::AssertionKind","unicode::Error","hir::translate::TranslatorI","hir::Dot","hir::literal::ExtractKind","ast::SetFlags","hir::Literal","ast::ClassUnicodeKind","hir::HirKind","ast::LiteralKind","ast::ClassAscii","hir::print::PrinterBuilder","ast::ClassBracketed","ast::CaptureName","hir::print::Printer","hir::PropertiesI","hir::literal::Extractor","ast::Position","hir::ClassUnicode","hir::Look","unicode::SimpleCaseFolder","ast::Flag","unicode::ClassQuery","ast::FlagsItemKind","hir::literal::PreferenceTrie","ast::ClassSetUnion","ast::Concat","debug::Byte","hir::translate::Translator","hir::ErrorKind","<*mut T as std::fmt::Debug>","hir::Error","parser::ParserBuilder","hir::literal::Literal","utf8::Utf8Sequence","ast::visitor::ClassFrame","ast::ClassUnicodeOpKind","ast::Group","hir::LookSet","ast::Alternation","ast::Error","ast::print::Printer","ast::parse::Primitive","hir::Capture","hir::literal::Seq","hir::translate::Flags","ast::GroupKind","error::Formatter","ast::WithComments","ast::ClassSetBinaryOp","hir::ClassUnicodeRange","ast::SpecialLiteralKind","ast::ClassAsciiKind","hir::ClassBytes","hir::Class","unicode::CanonicalClassQuery","ast::ClassSetItem","hir::interval::IntervalSetIter","hir::ClassBytesIter","ast::parse::ParserBuilder","error::Error","hir::Properties","hir::ClassBytesRange","ast::Class","ast::FlagsItem","ast::parse::NestLimiter","hir::translate::HirFrame","ast::parse::Parser","utf8::Utf8Range","ast::Literal","ast::ClassSet","ast::print::PrinterBuilder","ast::RepetitionOp","ast::ClassSetRange","hir::Hir","utf8::ScalarRange","ast::HexLiteralKind","hir::ClassUnicodeIter","ast::Flags","ast::ClassPerlKind","ast::ClassSetBinaryOpKind","ast::visitor::ClassInduct","ast::ClassPerl","unicode::CaseFoldError","either::Either","ast::RepetitionKind","ast::print::Writer","parser::Parser","debug::Bytes","hir::LookSetIter","utf8::Utf8Sequences","ast::Span","hir::print::Writer","ast::Assertion","hir::translate::TranslatorBuilder","ast::Repetition","ast::ErrorKind","hir::literal::State","ast::ClassUnicode","ast::RepetitionRange","ast::parse::GroupState","hir::Repetition","unicode::UnicodeWordError","ast::parse::ClassState","hir::interval::IntervalSet"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+hir::ClassBytes::new(p0);
+crate::hir::ClassBytes::new(p0);
+<hir::ClassBytes>::new(p0);
-----------------
src/hir/mod.rs hir::ClassBytes::empty
deps:{}
candidates:{}
+hir::ClassBytes::empty();
+crate::hir::ClassBytes::empty();
+<hir::ClassBytes>::empty();
-----------------
src/hir/mod.rs hir::ClassBytes::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.push(p1);
+hir::ClassBytes::push(p0, p1);
+crate::hir::ClassBytes::push(p0, p1);
+<hir::ClassBytes>::push(p0, p1);
-----------------
src/hir/mod.rs hir::ClassBytes::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.iter();
+hir::ClassBytes::iter(p0);
+crate::hir::ClassBytes::iter(p0);
+<hir::ClassBytes>::iter(p0);
-----------------
src/hir/mod.rs hir::ClassBytes::ranges
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.ranges();
+hir::ClassBytes::ranges(p0);
+crate::hir::ClassBytes::ranges(p0);
+<hir::ClassBytes>::ranges(p0);
-----------------
src/hir/mod.rs hir::ClassBytes::case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.case_fold_simple();
+hir::ClassBytes::case_fold_simple(p0);
+crate::hir::ClassBytes::case_fold_simple(p0);
+<hir::ClassBytes>::case_fold_simple(p0);
-----------------
src/hir/mod.rs hir::ClassBytes::negate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.negate();
+hir::ClassBytes::negate(p0);
+crate::hir::ClassBytes::negate(p0);
+<hir::ClassBytes>::negate(p0);
-----------------
src/hir/mod.rs hir::ClassBytes::union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.union(p1);
+hir::ClassBytes::union(p0, p1);
+crate::hir::ClassBytes::union(p0, p1);
+<hir::ClassBytes>::union(p0, p1);
-----------------
src/hir/mod.rs hir::ClassBytes::intersect
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.intersect(p1);
+hir::ClassBytes::intersect(p0, p1);
+crate::hir::ClassBytes::intersect(p0, p1);
+<hir::ClassBytes>::intersect(p0, p1);
-----------------
src/hir/mod.rs hir::ClassBytes::difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.difference(p1);
+hir::ClassBytes::difference(p0, p1);
+crate::hir::ClassBytes::difference(p0, p1);
+<hir::ClassBytes>::difference(p0, p1);
-----------------
src/hir/mod.rs hir::ClassBytes::symmetric_difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.symmetric_difference(p1);
+hir::ClassBytes::symmetric_difference(p0, p1);
+crate::hir::ClassBytes::symmetric_difference(p0, p1);
+<hir::ClassBytes>::symmetric_difference(p0, p1);
-----------------
src/hir/mod.rs hir::ClassBytes::is_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.is_ascii();
+hir::ClassBytes::is_ascii(p0);
+crate::hir::ClassBytes::is_ascii(p0);
+<hir::ClassBytes>::is_ascii(p0);
-----------------
src/hir/mod.rs hir::ClassBytes::minimum_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.minimum_len();
+hir::ClassBytes::minimum_len(p0);
+crate::hir::ClassBytes::minimum_len(p0);
+<hir::ClassBytes>::minimum_len(p0);
-----------------
src/hir/mod.rs hir::ClassBytes::maximum_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.maximum_len();
+hir::ClassBytes::maximum_len(p0);
+crate::hir::ClassBytes::maximum_len(p0);
+<hir::ClassBytes>::maximum_len(p0);
-----------------
src/hir/mod.rs hir::ClassBytes::literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.literal();
+hir::ClassBytes::literal(p0);
+crate::hir::ClassBytes::literal(p0);
+<hir::ClassBytes>::literal(p0);
-----------------
src/hir/mod.rs hir::ClassBytes::to_unicode_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.to_unicode_class();
+hir::ClassBytes::to_unicode_class(p0);
+crate::hir::ClassBytes::to_unicode_class(p0);
+<hir::ClassBytes>::to_unicode_class(p0);
-----------------
src/hir/mod.rs <hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassBytesIter<'a>>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassBytesIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytesIter<'a>
+p0.next();
+<hir::ClassBytesIter<'a> as std::iter::Iterator>::next(p0);
+crate::<hir::ClassBytesIter<'a> as std::iter::Iterator>::next(p0);
+<hir::ClassBytesIter<'a>>::next(p0);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.clone();
+<hir::ClassBytesRange as std::clone::Clone>::clone(p0);
+crate::<hir::ClassBytesRange as std::clone::Clone>::clone(p0);
+<hir::ClassBytesRange>::clone(p0);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as std::default::Default>::default
deps:{}
candidates:{}
+<hir::ClassBytesRange as std::default::Default>::default();
+crate::<hir::ClassBytesRange as std::default::Default>::default();
+<hir::ClassBytesRange>::default();
-----------------
src/hir/mod.rs <hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.assert_receiver_is_total_eq();
+<hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassBytesRange>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.eq(p1);
+<hir::ClassBytesRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassBytesRange as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassBytesRange>::eq(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.partial_cmp(p1);
+<hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<hir::ClassBytesRange>::partial_cmp(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.cmp(p1);
+<hir::ClassBytesRange as std::cmp::Ord>::cmp(p0, p1);
+crate::<hir::ClassBytesRange as std::cmp::Ord>::cmp(p0, p1);
+<hir::ClassBytesRange>::cmp(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::lower
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.lower();
+<hir::ClassBytesRange as hir::interval::Interval>::lower(p0);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::lower(p0);
+<hir::ClassBytesRange>::lower(p0);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::upper
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.upper();
+<hir::ClassBytesRange as hir::interval::Interval>::upper(p0);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::upper(p0);
+<hir::ClassBytesRange>::upper(p0);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::set_lower
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = 0u8; // None+u8
+p0.set_lower(p1);
+<hir::ClassBytesRange as hir::interval::Interval>::set_lower(p0, p1);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::set_lower(p0, p1);
+<hir::ClassBytesRange>::set_lower(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::set_upper
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = 0u8; // None+u8
+p0.set_upper(p1);
+<hir::ClassBytesRange as hir::interval::Interval>::set_upper(p0, p1);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::set_upper(p0, p1);
+<hir::ClassBytesRange>::set_upper(p0, p1);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::ClassBytesRange>
+p0.case_fold_simple(p1);
+<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+<hir::ClassBytesRange>::case_fold_simple(p0, p1);
-----------------
src/hir/mod.rs hir::ClassBytesRange::new
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+hir::ClassBytesRange::new(p0, p1);
+crate::hir::ClassBytesRange::new(p0, p1);
+<hir::ClassBytesRange>::new(p0, p1);
-----------------
src/hir/mod.rs hir::ClassBytesRange::start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.start();
+hir::ClassBytesRange::start(p0);
+crate::hir::ClassBytesRange::start(p0);
+<hir::ClassBytesRange>::start(p0);
-----------------
src/hir/mod.rs hir::ClassBytesRange::end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.end();
+hir::ClassBytesRange::end(p0);
+crate::hir::ClassBytesRange::end(p0);
+<hir::ClassBytesRange>::end(p0);
-----------------
src/hir/mod.rs hir::ClassBytesRange::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.len();
+hir::ClassBytesRange::len(p0);
+crate::hir::ClassBytesRange::len(p0);
+<hir::ClassBytesRange>::len(p0);
-----------------
src/hir/mod.rs <hir::ClassBytesRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassBytesRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassBytesRange as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassBytesRange>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Look as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Look
+p0.clone();
+<hir::Look as std::clone::Clone>::clone(p0);
+crate::<hir::Look as std::clone::Clone>::clone(p0);
+<hir::Look>::clone(p0);
-----------------
src/hir/mod.rs <hir::Look as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Look
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Look as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Look as std::fmt::Debug>::fmt(p0, p1);
+<hir::Look>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Look as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Look
+p0.assert_receiver_is_total_eq();
+<hir::Look as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Look as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Look>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::Look as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Look
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Look
+p0.eq(p1);
+<hir::Look as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Look as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Look>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::Look::reversed
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Look
+p0.reversed();
+hir::Look::reversed(p0);
+crate::hir::Look::reversed(p0);
+<hir::Look>::reversed(p0);
-----------------
src/hir/mod.rs hir::Look::as_repr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Look
+p0.as_repr();
+hir::Look::as_repr(p0);
+crate::hir::Look::as_repr(p0);
+<hir::Look>::as_repr(p0);
-----------------
src/hir/mod.rs hir::Look::from_repr
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+hir::Look::from_repr(p0);
+crate::hir::Look::from_repr(p0);
+<hir::Look>::from_repr(p0);
-----------------
src/hir/mod.rs hir::Look::as_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Look
+p0.as_char();
+hir::Look::as_char(p0);
+crate::hir::Look::as_char(p0);
+<hir::Look>::as_char(p0);
-----------------
src/hir/mod.rs <hir::Capture as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Capture
+p0.clone();
+<hir::Capture as std::clone::Clone>::clone(p0);
+crate::<hir::Capture as std::clone::Clone>::clone(p0);
+<hir::Capture>::clone(p0);
-----------------
src/hir/mod.rs <hir::Capture as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Capture
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Capture as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Capture as std::fmt::Debug>::fmt(p0, p1);
+<hir::Capture>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Capture as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Capture
+p0.assert_receiver_is_total_eq();
+<hir::Capture as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Capture as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Capture>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::Capture as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Capture
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Capture
+p0.eq(p1);
+<hir::Capture as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Capture as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Capture>::eq(p0, p1);
-----------------
src/hir/mod.rs <hir::Repetition as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.clone();
+<hir::Repetition as std::clone::Clone>::clone(p0);
+crate::<hir::Repetition as std::clone::Clone>::clone(p0);
+<hir::Repetition>::clone(p0);
-----------------
src/hir/mod.rs <hir::Repetition as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Repetition as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Repetition as std::fmt::Debug>::fmt(p0, p1);
+<hir::Repetition>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.assert_receiver_is_total_eq();
+<hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Repetition>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::Repetition as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.eq(p1);
+<hir::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Repetition>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::Repetition::with
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.with(p1);
+hir::Repetition::with(p0, p1);
+crate::hir::Repetition::with(p0, p1);
+<hir::Repetition>::with(p0, p1);
-----------------
src/hir/mod.rs <hir::Dot as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Dot
+p0.clone();
+<hir::Dot as std::clone::Clone>::clone(p0);
+crate::<hir::Dot as std::clone::Clone>::clone(p0);
+<hir::Dot>::clone(p0);
-----------------
src/hir/mod.rs <hir::Dot as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Dot
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Dot as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Dot as std::fmt::Debug>::fmt(p0, p1);
+<hir::Dot>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Dot as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Dot
+p0.assert_receiver_is_total_eq();
+<hir::Dot as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Dot as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Dot>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::Dot as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Dot
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Dot
+p0.eq(p1);
+<hir::Dot as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Dot as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Dot>::eq(p0, p1);
-----------------
src/hir/mod.rs <hir::Hir as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.drop();
+<hir::Hir as std::ops::Drop>::drop(p0);
+crate::<hir::Hir as std::ops::Drop>::drop(p0);
+<hir::Hir>::drop(p0);
-----------------
src/hir/mod.rs <hir::Properties as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.clone();
+<hir::Properties as std::clone::Clone>::clone(p0);
+crate::<hir::Properties as std::clone::Clone>::clone(p0);
+<hir::Properties>::clone(p0);
-----------------
src/hir/mod.rs <hir::Properties as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Properties as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Properties as std::fmt::Debug>::fmt(p0, p1);
+<hir::Properties>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::Properties as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.assert_receiver_is_total_eq();
+<hir::Properties as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Properties as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Properties>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::Properties as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.eq(p1);
+<hir::Properties as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Properties as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Properties>::eq(p0, p1);
-----------------
src/hir/mod.rs <hir::PropertiesI as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::PropertiesI
+p0.clone();
+<hir::PropertiesI as std::clone::Clone>::clone(p0);
+crate::<hir::PropertiesI as std::clone::Clone>::clone(p0);
+<hir::PropertiesI>::clone(p0);
-----------------
src/hir/mod.rs <hir::PropertiesI as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::PropertiesI
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::PropertiesI as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::PropertiesI as std::fmt::Debug>::fmt(p0, p1);
+<hir::PropertiesI>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::PropertiesI as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::PropertiesI
+p0.assert_receiver_is_total_eq();
+<hir::PropertiesI as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::PropertiesI as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::PropertiesI>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::PropertiesI as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::PropertiesI
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::PropertiesI
+p0.eq(p1);
+<hir::PropertiesI as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::PropertiesI as std::cmp::PartialEq>::eq(p0, p1);
+<hir::PropertiesI>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::Properties::minimum_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.minimum_len();
+hir::Properties::minimum_len(p0);
+crate::hir::Properties::minimum_len(p0);
+<hir::Properties>::minimum_len(p0);
-----------------
src/hir/mod.rs hir::Properties::maximum_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.maximum_len();
+hir::Properties::maximum_len(p0);
+crate::hir::Properties::maximum_len(p0);
+<hir::Properties>::maximum_len(p0);
-----------------
src/hir/mod.rs hir::Properties::look_set
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.look_set();
+hir::Properties::look_set(p0);
+crate::hir::Properties::look_set(p0);
+<hir::Properties>::look_set(p0);
-----------------
src/hir/mod.rs hir::Properties::look_set_prefix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.look_set_prefix();
+hir::Properties::look_set_prefix(p0);
+crate::hir::Properties::look_set_prefix(p0);
+<hir::Properties>::look_set_prefix(p0);
-----------------
src/hir/mod.rs hir::Properties::look_set_prefix_any
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.look_set_prefix_any();
+hir::Properties::look_set_prefix_any(p0);
+crate::hir::Properties::look_set_prefix_any(p0);
+<hir::Properties>::look_set_prefix_any(p0);
-----------------
src/hir/mod.rs hir::Properties::look_set_suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.look_set_suffix();
+hir::Properties::look_set_suffix(p0);
+crate::hir::Properties::look_set_suffix(p0);
+<hir::Properties>::look_set_suffix(p0);
-----------------
src/hir/mod.rs hir::Properties::look_set_suffix_any
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.look_set_suffix_any();
+hir::Properties::look_set_suffix_any(p0);
+crate::hir::Properties::look_set_suffix_any(p0);
+<hir::Properties>::look_set_suffix_any(p0);
-----------------
src/hir/mod.rs hir::Properties::is_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.is_utf8();
+hir::Properties::is_utf8(p0);
+crate::hir::Properties::is_utf8(p0);
+<hir::Properties>::is_utf8(p0);
-----------------
src/hir/mod.rs hir::Properties::explicit_captures_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.explicit_captures_len();
+hir::Properties::explicit_captures_len(p0);
+crate::hir::Properties::explicit_captures_len(p0);
+<hir::Properties>::explicit_captures_len(p0);
-----------------
src/hir/mod.rs hir::Properties::static_explicit_captures_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.static_explicit_captures_len();
+hir::Properties::static_explicit_captures_len(p0);
+crate::hir::Properties::static_explicit_captures_len(p0);
+<hir::Properties>::static_explicit_captures_len(p0);
-----------------
src/hir/mod.rs hir::Properties::is_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.is_literal();
+hir::Properties::is_literal(p0);
+crate::hir::Properties::is_literal(p0);
+<hir::Properties>::is_literal(p0);
-----------------
src/hir/mod.rs hir::Properties::is_alternation_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.is_alternation_literal();
+hir::Properties::is_alternation_literal(p0);
+crate::hir::Properties::is_alternation_literal(p0);
+<hir::Properties>::is_alternation_literal(p0);
-----------------
src/hir/mod.rs hir::Properties::memory_usage
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Properties
+p0.memory_usage();
+hir::Properties::memory_usage(p0);
+crate::hir::Properties::memory_usage(p0);
+<hir::Properties>::memory_usage(p0);
-----------------
src/hir/mod.rs hir::Properties::union
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized","std::clone::Clone"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"either::Either":{"Left":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"],"Right":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::Properties::union":{"I":["std::iter::IntoIterator","std::marker::Sized"],"P":["std::borrow::Borrow","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["utf8::Utf8Sequences","<&mut I as std::iter::Iterator>","hir::ClassUnicodeIter","hir::LookSetIter","hir::ClassBytesIter","hir::interval::IntervalSetIter"]},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::string::String","std::boxed::Box<T, A>","std::ffi::OsString","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::path::PathBuf"]},"ast::parse::ParserI":{"P":["std::ffi::CString","std::rc::Rc<T>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::ffi::OsString","std::boxed::Box<T, A>","std::string::String","std::vec::Vec<T, A>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["hir::ErrorKind","utf8::Utf8Range","ast::ClassSetBinaryOpKind","ast::ClassSetRange","ast::CaptureName","ast::RepetitionKind","ast::ClassUnicodeKind","ast::ClassPerl","ast::ClassSet","utf8::Utf8Sequence","ast::Ast","ast::ClassBracketed","ast::Assertion","hir::HirKind","hir::Dot","hir::Error","ast::ClassUnicodeOpKind","ast::Concat","ast::Flag","ast::ClassSetItem","hir::ClassUnicodeRange","ast::SpecialLiteralKind","ast::RepetitionOp","ast::Alternation","ast::Position","ast::AssertionKind","hir::ClassBytesRange","ast::ClassAscii","ast::SetFlags","ast::ClassSetBinaryOp","hir::Look","ast::GroupKind","hir::Capture","ast::ClassSetUnion","ast::ClassAsciiKind","hir::ClassBytes","ast::parse::Primitive","hir::PropertiesI","hir::Literal","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::FlagsItemKind","hir::interval::IntervalSet","ast::LiteralKind","ast::ClassPerlKind","hir::literal::Literal","hir::Hir","ast::RepetitionRange","ast::Comment","hir::Properties","hir::Class","ast::ErrorKind","ast::Literal","ast::Repetition","hir::literal::Seq","either::Either","ast::WithComments","ast::HexLiteralKind","ast::FlagsItem","ast::Group","hir::ClassUnicode","hir::Repetition","error::Error","ast::Class","ast::ClassUnicode","ast::Error","ast::Flags","ast::Span","hir::LookSet"],"Right":["either::Either","hir::Repetition","ast::ClassUnicodeOpKind","error::Error","hir::PropertiesI","ast::ClassAsciiKind","ast::HexLiteralKind","hir::Dot","ast::ClassBracketed","hir::HirKind","hir::ClassBytesRange","ast::SetFlags","ast::parse::Primitive","ast::Flag","utf8::Utf8Range","hir::literal::Seq","ast::Error","ast::ErrorKind","hir::ClassUnicode","ast::Group","ast::Position","hir::Class","ast::WithComments","hir::ErrorKind","hir::Properties","ast::Class","ast::ClassPerl","ast::GroupKind","hir::Error","hir::ClassUnicodeRange","hir::interval::IntervalSet","hir::Look","ast::Repetition","ast::AssertionKind","ast::ClassAscii","utf8::Utf8Sequence","ast::FlagsItem","hir::Hir","hir::Literal","ast::ClassSetRange","ast::Flags","ast::CaptureName","ast::ClassUnicode","ast::FlagsItemKind","ast::Ast","ast::ClassSetUnion","ast::Literal","ast::SpecialLiteralKind","ast::Assertion","ast::RepetitionOp","hir::ClassBytes","ast::RepetitionRange","ast::ClassUnicodeKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::Concat","ast::Span","ast::Comment","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetItem","ast::ClassSetBinaryOp","ast::RepetitionKind","ast::LiteralKind","hir::literal::Literal","hir::LookSet","ast::ClassSetBinaryOpKind","ast::Alternation","hir::Capture"]},"error::Formatter":{"E":["ast::Ast","<&mut T as std::fmt::Display>","error::Error","hir::ErrorKind","error::Formatter","ast::ErrorKind","unicode::UnicodeWordError","hir::Error","ast::Error","unicode::CaseFoldError","hir::Hir"]},"hir::Properties::union":{"I":["<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>","<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>"],"P":["std::vec::Vec<T, A>","std::string::String","std::sync::Arc<T>","std::ffi::CString","std::borrow::Cow<'a, B>","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::rc::Rc<T>","std::boxed::Box<T, A>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::Flags","hir::literal::ExtractKind","ast::ClassBracketed","hir::Look","hir::Class","ast::ClassSetItem","ast::Group","hir::ClassBytesRange","hir::ClassUnicodeRange","ast::Literal","ast::WithComments","hir::translate::Translator","unicode::ClassQuery","ast::Span","utf8::Utf8Sequences","unicode::SimpleCaseFolder","ast::parse::ClassState","ast::SpecialLiteralKind","ast::HexLiteralKind","hir::translate::TranslatorI","ast::ErrorKind","hir::ClassBytes","hir::print::Printer","ast::parse::Parser","unicode::CanonicalClassQuery","unicode::UnicodeWordError","hir::literal::Extractor","hir::translate::TranslatorBuilder","ast::Ast","hir::Error","hir::ClassBytesIter","utf8::ScalarRange","unicode::CaseFoldError","ast::ClassSet","ast::RepetitionOp","ast::FlagsItem","hir::Literal","hir::Dot","ast::ClassSetBinaryOp","hir::literal::Literal","parser::Parser","hir::literal::Seq","ast::print::PrinterBuilder","ast::Class","ast::visitor::ClassInduct","hir::interval::IntervalSet","ast::Concat","utf8::Utf8Sequence","ast::visitor::ClassFrame","ast::Alternation","error::Error","ast::GroupKind","parser::ParserBuilder","ast::RepetitionKind","ast::Error","ast::print::Printer","hir::Capture","ast::parse::ParserBuilder","hir::ClassUnicode","hir::ErrorKind","ast::parse::NestLimiter","utf8::Utf8Range","ast::AssertionKind","error::Formatter","ast::print::Writer","ast::ClassSetBinaryOpKind","hir::LookSet","hir::LookSetIter","hir::Hir","ast::CaptureName","ast::Position","debug::Byte","ast::ClassUnicodeOpKind","ast::ClassPerlKind","either::Either","hir::print::PrinterBuilder","ast::Flag","hir::translate::HirFrame","ast::Assertion","ast::ClassUnicode","ast::parse::ParserI","ast::ClassAscii","ast::ClassUnicodeKind","ast::ClassAsciiKind","hir::literal::State","hir::Repetition","ast::SetFlags","ast::ClassSetRange","<*mut T as std::fmt::Debug>","debug::Bytes","ast::LiteralKind","ast::Repetition","unicode::Error","hir::translate::Flags","hir::Properties","hir::ClassUnicodeIter","ast::parse::Primitive","ast::Comment","ast::parse::GroupState","ast::FlagsItemKind","hir::interval::IntervalSetIter","ast::ClassPerl","ast::ClassSetUnion","hir::HirKind","hir::PropertiesI","hir::print::Writer","hir::literal::PreferenceTrie","ast::RepetitionRange"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+hir::Properties::union(p0);
+crate::hir::Properties::union(p0);
+<hir::Properties>::union(p0);
-----------------
src/hir/mod.rs hir::Properties::empty
deps:{}
candidates:{}
+hir::Properties::empty();
+crate::hir::Properties::empty();
+<hir::Properties>::empty();
-----------------
src/hir/mod.rs hir::Properties::literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+hir::Properties::literal(p0);
+crate::hir::Properties::literal(p0);
+<hir::Properties>::literal(p0);
-----------------
src/hir/mod.rs hir::Properties::class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+hir::Properties::class(p0);
+crate::hir::Properties::class(p0);
+<hir::Properties>::class(p0);
-----------------
src/hir/mod.rs hir::Properties::look
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Look
+hir::Properties::look(p0);
+crate::hir::Properties::look(p0);
+<hir::Properties>::look(p0);
-----------------
src/hir/mod.rs hir::Properties::repetition
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+hir::Properties::repetition(p0);
+crate::hir::Properties::repetition(p0);
+<hir::Properties>::repetition(p0);
-----------------
src/hir/mod.rs hir::Properties::capture
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Capture
+hir::Properties::capture(p0);
+crate::hir::Properties::capture(p0);
+<hir::Properties>::capture(p0);
-----------------
src/hir/mod.rs hir::Properties::concat
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [hir::Hir]
+hir::Properties::concat(p0);
+crate::hir::Properties::concat(p0);
+<hir::Properties>::concat(p0);
-----------------
src/hir/mod.rs hir::Properties::alternation
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [hir::Hir]
+hir::Properties::alternation(p0);
+crate::hir::Properties::alternation(p0);
+<hir::Properties>::alternation(p0);
-----------------
src/hir/mod.rs <hir::LookSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.clone();
+<hir::LookSet as std::clone::Clone>::clone(p0);
+crate::<hir::LookSet as std::clone::Clone>::clone(p0);
+<hir::LookSet>::clone(p0);
-----------------
src/hir/mod.rs <hir::LookSet as std::default::Default>::default
deps:{}
candidates:{}
+<hir::LookSet as std::default::Default>::default();
+crate::<hir::LookSet as std::default::Default>::default();
+<hir::LookSet>::default();
-----------------
src/hir/mod.rs <hir::LookSet as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.assert_receiver_is_total_eq();
+<hir::LookSet as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::LookSet as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::LookSet>::assert_receiver_is_total_eq(p0);
-----------------
src/hir/mod.rs <hir::LookSet as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.eq(p1);
+<hir::LookSet as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::LookSet as std::cmp::PartialEq>::eq(p0, p1);
+<hir::LookSet>::eq(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::empty
deps:{}
candidates:{}
+hir::LookSet::empty();
+crate::hir::LookSet::empty();
+<hir::LookSet>::empty();
-----------------
src/hir/mod.rs hir::LookSet::full
deps:{}
candidates:{}
+hir::LookSet::full();
+crate::hir::LookSet::full();
+<hir::LookSet>::full();
-----------------
src/hir/mod.rs hir::LookSet::singleton
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Look
+hir::LookSet::singleton(p0);
+crate::hir::LookSet::singleton(p0);
+<hir::LookSet>::singleton(p0);
-----------------
src/hir/mod.rs hir::LookSet::len
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.len();
+hir::LookSet::len(p0);
+crate::hir::LookSet::len(p0);
+<hir::LookSet>::len(p0);
-----------------
src/hir/mod.rs hir::LookSet::is_empty
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.is_empty();
+hir::LookSet::is_empty(p0);
+crate::hir::LookSet::is_empty(p0);
+<hir::LookSet>::is_empty(p0);
-----------------
src/hir/mod.rs hir::LookSet::contains
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::Look
+p0.contains(p1);
+hir::LookSet::contains(p0, p1);
+crate::hir::LookSet::contains(p0, p1);
+<hir::LookSet>::contains(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::contains_anchor
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.contains_anchor();
+hir::LookSet::contains_anchor(p0);
+crate::hir::LookSet::contains_anchor(p0);
+<hir::LookSet>::contains_anchor(p0);
-----------------
src/hir/mod.rs hir::LookSet::contains_anchor_haystack
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.contains_anchor_haystack();
+hir::LookSet::contains_anchor_haystack(p0);
+crate::hir::LookSet::contains_anchor_haystack(p0);
+<hir::LookSet>::contains_anchor_haystack(p0);
-----------------
src/hir/mod.rs hir::LookSet::contains_anchor_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.contains_anchor_line();
+hir::LookSet::contains_anchor_line(p0);
+crate::hir::LookSet::contains_anchor_line(p0);
+<hir::LookSet>::contains_anchor_line(p0);
-----------------
src/hir/mod.rs hir::LookSet::contains_anchor_lf
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.contains_anchor_lf();
+hir::LookSet::contains_anchor_lf(p0);
+crate::hir::LookSet::contains_anchor_lf(p0);
+<hir::LookSet>::contains_anchor_lf(p0);
-----------------
src/hir/mod.rs hir::LookSet::contains_anchor_crlf
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.contains_anchor_crlf();
+hir::LookSet::contains_anchor_crlf(p0);
+crate::hir::LookSet::contains_anchor_crlf(p0);
+<hir::LookSet>::contains_anchor_crlf(p0);
-----------------
src/hir/mod.rs hir::LookSet::contains_word
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.contains_word();
+hir::LookSet::contains_word(p0);
+crate::hir::LookSet::contains_word(p0);
+<hir::LookSet>::contains_word(p0);
-----------------
src/hir/mod.rs hir::LookSet::contains_word_unicode
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.contains_word_unicode();
+hir::LookSet::contains_word_unicode(p0);
+crate::hir::LookSet::contains_word_unicode(p0);
+<hir::LookSet>::contains_word_unicode(p0);
-----------------
src/hir/mod.rs hir::LookSet::contains_word_ascii
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.contains_word_ascii();
+hir::LookSet::contains_word_ascii(p0);
+crate::hir::LookSet::contains_word_ascii(p0);
+<hir::LookSet>::contains_word_ascii(p0);
-----------------
src/hir/mod.rs hir::LookSet::iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.iter();
+hir::LookSet::iter(p0);
+crate::hir::LookSet::iter(p0);
+<hir::LookSet>::iter(p0);
-----------------
src/hir/mod.rs hir::LookSet::insert
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::Look
+p0.insert(p1);
+hir::LookSet::insert(p0, p1);
+crate::hir::LookSet::insert(p0, p1);
+<hir::LookSet>::insert(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::set_insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::Look
+p0.set_insert(p1);
+hir::LookSet::set_insert(p0, p1);
+crate::hir::LookSet::set_insert(p0, p1);
+<hir::LookSet>::set_insert(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::remove
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::Look
+p0.remove(p1);
+hir::LookSet::remove(p0, p1);
+crate::hir::LookSet::remove(p0, p1);
+<hir::LookSet>::remove(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::set_remove
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::Look
+p0.set_remove(p1);
+hir::LookSet::set_remove(p0, p1);
+crate::hir::LookSet::set_remove(p0, p1);
+<hir::LookSet>::set_remove(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::subtract
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.subtract(p1);
+hir::LookSet::subtract(p0, p1);
+crate::hir::LookSet::subtract(p0, p1);
+<hir::LookSet>::subtract(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::set_subtract
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.set_subtract(p1);
+hir::LookSet::set_subtract(p0, p1);
+crate::hir::LookSet::set_subtract(p0, p1);
+<hir::LookSet>::set_subtract(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::union
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.union(p1);
+hir::LookSet::union(p0, p1);
+crate::hir::LookSet::union(p0, p1);
+<hir::LookSet>::union(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::set_union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.set_union(p1);
+hir::LookSet::set_union(p0, p1);
+crate::hir::LookSet::set_union(p0, p1);
+<hir::LookSet>::set_union(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::intersect
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.intersect(p1);
+hir::LookSet::intersect(p0, p1);
+crate::hir::LookSet::intersect(p0, p1);
+<hir::LookSet>::intersect(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::set_intersect
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::LookSet
+p0.set_intersect(p1);
+hir::LookSet::set_intersect(p0, p1);
+crate::hir::LookSet::set_intersect(p0, p1);
+<hir::LookSet>::set_intersect(p0, p1);
-----------------
src/hir/mod.rs hir::LookSet::read_repr
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+hir::LookSet::read_repr(p0);
+crate::hir::LookSet::read_repr(p0);
+<hir::LookSet>::read_repr(p0);
-----------------
src/hir/mod.rs hir::LookSet::write_repr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
+p0.write_repr(p1);
+hir::LookSet::write_repr(p0, p1);
+crate::hir::LookSet::write_repr(p0, p1);
+<hir::LookSet>::write_repr(p0, p1);
-----------------
src/hir/mod.rs <hir::LookSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::LookSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::LookSet as std::fmt::Debug>::fmt(p0, p1);
+<hir::LookSet>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::LookSetIter as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSetIter
+p0.clone();
+<hir::LookSetIter as std::clone::Clone>::clone(p0);
+crate::<hir::LookSetIter as std::clone::Clone>::clone(p0);
+<hir::LookSetIter>::clone(p0);
-----------------
src/hir/mod.rs <hir::LookSetIter as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::LookSetIter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::LookSetIter as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::LookSetIter as std::fmt::Debug>::fmt(p0, p1);
+<hir::LookSetIter>::fmt(p0, p1);
-----------------
src/hir/mod.rs <hir::LookSetIter as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::LookSetIter
+p0.next();
+<hir::LookSetIter as std::iter::Iterator>::next(p0);
+crate::<hir::LookSetIter as std::iter::Iterator>::next(p0);
+<hir::LookSetIter>::next(p0);
-----------------
src/parser.rs <parser::ParserBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
+p0.clone();
+<parser::ParserBuilder as std::clone::Clone>::clone(p0);
+crate::<parser::ParserBuilder as std::clone::Clone>::clone(p0);
+<parser::ParserBuilder>::clone(p0);
-----------------
src/parser.rs <parser::ParserBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+<parser::ParserBuilder>::fmt(p0, p1);
-----------------
src/parser.rs <parser::ParserBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<parser::ParserBuilder as std::default::Default>::default();
+crate::<parser::ParserBuilder as std::default::Default>::default();
+<parser::ParserBuilder>::default();
-----------------
src/parser.rs parser::ParserBuilder::new
deps:{}
candidates:{}
+parser::ParserBuilder::new();
+crate::parser::ParserBuilder::new();
+<parser::ParserBuilder>::new();
-----------------
src/parser.rs parser::ParserBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
+p0.build();
+parser::ParserBuilder::build(p0);
+crate::parser::ParserBuilder::build(p0);
+<parser::ParserBuilder>::build(p0);
-----------------
src/parser.rs parser::ParserBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+parser::ParserBuilder::nest_limit(p0, p1);
+crate::parser::ParserBuilder::nest_limit(p0, p1);
+<parser::ParserBuilder>::nest_limit(p0, p1);
-----------------
src/parser.rs parser::ParserBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+parser::ParserBuilder::octal(p0, p1);
+crate::parser::ParserBuilder::octal(p0, p1);
+<parser::ParserBuilder>::octal(p0, p1);
-----------------
src/parser.rs parser::ParserBuilder::utf8
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.utf8(p1);
+parser::ParserBuilder::utf8(p0, p1);
+crate::parser::ParserBuilder::utf8(p0, p1);
+<parser::ParserBuilder>::utf8(p0, p1);
-----------------
src/parser.rs parser::ParserBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+parser::ParserBuilder::ignore_whitespace(p0, p1);
+crate::parser::ParserBuilder::ignore_whitespace(p0, p1);
+<parser::ParserBuilder>::ignore_whitespace(p0, p1);
-----------------
src/parser.rs parser::ParserBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+parser::ParserBuilder::case_insensitive(p0, p1);
+crate::parser::ParserBuilder::case_insensitive(p0, p1);
+<parser::ParserBuilder>::case_insensitive(p0, p1);
-----------------
src/parser.rs parser::ParserBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+parser::ParserBuilder::multi_line(p0, p1);
+crate::parser::ParserBuilder::multi_line(p0, p1);
+<parser::ParserBuilder>::multi_line(p0, p1);
-----------------
src/parser.rs parser::ParserBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+parser::ParserBuilder::dot_matches_new_line(p0, p1);
+crate::parser::ParserBuilder::dot_matches_new_line(p0, p1);
+<parser::ParserBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/parser.rs parser::ParserBuilder::crlf
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.crlf(p1);
+parser::ParserBuilder::crlf(p0, p1);
+crate::parser::ParserBuilder::crlf(p0, p1);
+<parser::ParserBuilder>::crlf(p0, p1);
-----------------
src/parser.rs parser::ParserBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+parser::ParserBuilder::swap_greed(p0, p1);
+crate::parser::ParserBuilder::swap_greed(p0, p1);
+<parser::ParserBuilder>::swap_greed(p0, p1);
-----------------
src/parser.rs parser::ParserBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+parser::ParserBuilder::unicode(p0, p1);
+crate::parser::ParserBuilder::unicode(p0, p1);
+<parser::ParserBuilder>::unicode(p0, p1);
-----------------
src/parser.rs <parser::Parser as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::Parser
+p0.clone();
+<parser::Parser as std::clone::Clone>::clone(p0);
+crate::<parser::Parser as std::clone::Clone>::clone(p0);
+<parser::Parser>::clone(p0);
-----------------
src/parser.rs <parser::Parser as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::Parser
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::Parser as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::Parser as std::fmt::Debug>::fmt(p0, p1);
+<parser::Parser>::fmt(p0, p1);
-----------------
src/parser.rs parser::Parser::new
deps:{}
candidates:{}
+parser::Parser::new();
+crate::parser::Parser::new();
+<parser::Parser>::new();
-----------------
src/parser.rs parser::Parser::parse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::Parser
let mut p1 = "sample"; // None+&str
+p0.parse(&p1);
+parser::Parser::parse(p0, &p1);
+crate::parser::Parser::parse(p0, &p1);
+<parser::Parser>::parse(p0, &p1);
-----------------
src/unicode.rs <unicode::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::Error as std::fmt::Debug>::fmt(p0, p1);
+<unicode::Error>::fmt(p0, p1);
-----------------
src/unicode.rs <unicode::CaseFoldError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CaseFoldError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::CaseFoldError as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::CaseFoldError as std::fmt::Debug>::fmt(p0, p1);
+<unicode::CaseFoldError>::fmt(p0, p1);
-----------------
src/unicode.rs <unicode::CaseFoldError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CaseFoldError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<unicode::CaseFoldError as std::fmt::Display>::fmt(p0, p1);
+crate::<unicode::CaseFoldError as std::fmt::Display>::fmt(p0, p1);
+<unicode::CaseFoldError>::fmt(p0, p1);
-----------------
src/unicode.rs <unicode::UnicodeWordError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::UnicodeWordError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::UnicodeWordError as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::UnicodeWordError as std::fmt::Debug>::fmt(p0, p1);
+<unicode::UnicodeWordError>::fmt(p0, p1);
-----------------
src/unicode.rs <unicode::UnicodeWordError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::UnicodeWordError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<unicode::UnicodeWordError as std::fmt::Display>::fmt(p0, p1);
+crate::<unicode::UnicodeWordError as std::fmt::Display>::fmt(p0, p1);
+<unicode::UnicodeWordError>::fmt(p0, p1);
-----------------
src/unicode.rs <unicode::SimpleCaseFolder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::SimpleCaseFolder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::SimpleCaseFolder as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::SimpleCaseFolder as std::fmt::Debug>::fmt(p0, p1);
+<unicode::SimpleCaseFolder>::fmt(p0, p1);
-----------------
src/unicode.rs unicode::SimpleCaseFolder::new
deps:{}
candidates:{}
+unicode::SimpleCaseFolder::new();
+crate::unicode::SimpleCaseFolder::new();
+<unicode::SimpleCaseFolder>::new();
-----------------
src/unicode.rs unicode::SimpleCaseFolder::mapping
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // unicode::SimpleCaseFolder
let mut p1 = 'a'; // None+char
+p0.mapping(p1);
+unicode::SimpleCaseFolder::mapping(p0, p1);
+crate::unicode::SimpleCaseFolder::mapping(p0, p1);
+<unicode::SimpleCaseFolder>::mapping(p0, p1);
-----------------
src/unicode.rs unicode::SimpleCaseFolder::overlaps
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::SimpleCaseFolder
let mut p1 = 'a'; // None+char
let mut p2 = 'a'; // None+char
+p0.overlaps(p1, p2);
+unicode::SimpleCaseFolder::overlaps(p0, p1, p2);
+crate::unicode::SimpleCaseFolder::overlaps(p0, p1, p2);
+<unicode::SimpleCaseFolder>::overlaps(p0, p1, p2);
-----------------
src/unicode.rs unicode::SimpleCaseFolder::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::SimpleCaseFolder
let mut p1 = 'a'; // None+char
+p0.get(p1);
+unicode::SimpleCaseFolder::get(p0, p1);
+crate::unicode::SimpleCaseFolder::get(p0, p1);
+<unicode::SimpleCaseFolder>::get(p0, p1);
-----------------
src/unicode.rs <unicode::ClassQuery<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::ClassQuery<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::ClassQuery<'a> as std::fmt::Debug>::fmt(p0, p1);
+<unicode::ClassQuery<'a>>::fmt(p0, p1);
-----------------
src/unicode.rs unicode::ClassQuery::<'a>::canonicalize
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'a>
+p0.canonicalize();
+unicode::ClassQuery::<'a>::canonicalize(p0);
+crate::unicode::ClassQuery::<'a>::canonicalize(p0);
+<unicode::ClassQuery<'a>>::canonicalize(p0);
-----------------
src/unicode.rs unicode::ClassQuery::<'a>::canonical_binary
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'a>
let mut p1 = "sample"; // None+&str
+p0.canonical_binary(&p1);
+unicode::ClassQuery::<'a>::canonical_binary(p0, &p1);
+crate::unicode::ClassQuery::<'a>::canonical_binary(p0, &p1);
+<unicode::ClassQuery<'a>>::canonical_binary(p0, &p1);
-----------------
src/unicode.rs <unicode::CanonicalClassQuery as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::CanonicalClassQuery as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::CanonicalClassQuery as std::fmt::Debug>::fmt(p0, p1);
+<unicode::CanonicalClassQuery>::fmt(p0, p1);
-----------------
src/unicode.rs <unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
+p0.assert_receiver_is_total_eq();
+<unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<unicode::CanonicalClassQuery>::assert_receiver_is_total_eq(p0);
-----------------
src/unicode.rs <unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
let mut p1 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
+p0.eq(p1);
+<unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq(p0, p1);
+crate::<unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq(p0, p1);
+<unicode::CanonicalClassQuery>::eq(p0, p1);
-----------------
src/utf8.rs <utf8::Utf8Sequence as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.clone();
+<utf8::Utf8Sequence as std::clone::Clone>::clone(p0);
+crate::<utf8::Utf8Sequence as std::clone::Clone>::clone(p0);
+<utf8::Utf8Sequence>::clone(p0);
-----------------
src/utf8.rs <utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.assert_receiver_is_total_eq();
+<utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<utf8::Utf8Sequence>::assert_receiver_is_total_eq(p0);
-----------------
src/utf8.rs <utf8::Utf8Sequence as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.eq(p1);
+<utf8::Utf8Sequence as std::cmp::PartialEq>::eq(p0, p1);
+crate::<utf8::Utf8Sequence as std::cmp::PartialEq>::eq(p0, p1);
+<utf8::Utf8Sequence>::eq(p0, p1);
-----------------
src/utf8.rs <utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.partial_cmp(p1);
+<utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<utf8::Utf8Sequence>::partial_cmp(p0, p1);
-----------------
src/utf8.rs <utf8::Utf8Sequence as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.cmp(p1);
+<utf8::Utf8Sequence as std::cmp::Ord>::cmp(p0, p1);
+crate::<utf8::Utf8Sequence as std::cmp::Ord>::cmp(p0, p1);
+<utf8::Utf8Sequence>::cmp(p0, p1);
-----------------
src/utf8.rs utf8::Utf8Sequence::from_encoded_range
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+utf8::Utf8Sequence::from_encoded_range(p0, p1);
+crate::utf8::Utf8Sequence::from_encoded_range(p0, p1);
+<utf8::Utf8Sequence>::from_encoded_range(p0, p1);
-----------------
src/utf8.rs utf8::Utf8Sequence::as_slice
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.as_slice();
+utf8::Utf8Sequence::as_slice(p0);
+crate::utf8::Utf8Sequence::as_slice(p0);
+<utf8::Utf8Sequence>::as_slice(p0);
-----------------
src/utf8.rs utf8::Utf8Sequence::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.len();
+utf8::Utf8Sequence::len(p0);
+crate::utf8::Utf8Sequence::len(p0);
+<utf8::Utf8Sequence>::len(p0);
-----------------
src/utf8.rs utf8::Utf8Sequence::reverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.reverse();
+utf8::Utf8Sequence::reverse(p0);
+crate::utf8::Utf8Sequence::reverse(p0);
+<utf8::Utf8Sequence>::reverse(p0);
-----------------
src/utf8.rs utf8::Utf8Sequence::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.matches(p1);
+utf8::Utf8Sequence::matches(p0, p1);
+crate::utf8::Utf8Sequence::matches(p0, p1);
+<utf8::Utf8Sequence>::matches(p0, p1);
-----------------
src/utf8.rs <&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.into_iter();
+<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter(p0);
+<&'a utf8::Utf8Sequence>::into_iter(p0);
-----------------
src/utf8.rs <utf8::Utf8Sequence as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::Utf8Sequence as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::Utf8Sequence as std::fmt::Debug>::fmt(p0, p1);
+<utf8::Utf8Sequence>::fmt(p0, p1);
-----------------
src/utf8.rs <utf8::Utf8Range as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.clone();
+<utf8::Utf8Range as std::clone::Clone>::clone(p0);
+crate::<utf8::Utf8Range as std::clone::Clone>::clone(p0);
+<utf8::Utf8Range>::clone(p0);
-----------------
src/utf8.rs <utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.assert_receiver_is_total_eq();
+<utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<utf8::Utf8Range>::assert_receiver_is_total_eq(p0);
-----------------
src/utf8.rs <utf8::Utf8Range as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.eq(p1);
+<utf8::Utf8Range as std::cmp::PartialEq>::eq(p0, p1);
+crate::<utf8::Utf8Range as std::cmp::PartialEq>::eq(p0, p1);
+<utf8::Utf8Range>::eq(p0, p1);
-----------------
src/utf8.rs <utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.partial_cmp(p1);
+<utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<utf8::Utf8Range>::partial_cmp(p0, p1);
-----------------
src/utf8.rs <utf8::Utf8Range as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.cmp(p1);
+<utf8::Utf8Range as std::cmp::Ord>::cmp(p0, p1);
+crate::<utf8::Utf8Range as std::cmp::Ord>::cmp(p0, p1);
+<utf8::Utf8Range>::cmp(p0, p1);
-----------------
src/utf8.rs utf8::Utf8Range::new
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+utf8::Utf8Range::new(p0, p1);
+crate::utf8::Utf8Range::new(p0, p1);
+<utf8::Utf8Range>::new(p0, p1);
-----------------
src/utf8.rs utf8::Utf8Range::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = 0u8; // None+u8
+p0.matches(p1);
+utf8::Utf8Range::matches(p0, p1);
+crate::utf8::Utf8Range::matches(p0, p1);
+<utf8::Utf8Range>::matches(p0, p1);
-----------------
src/utf8.rs <utf8::Utf8Range as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::Utf8Range as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::Utf8Range as std::fmt::Debug>::fmt(p0, p1);
+<utf8::Utf8Range>::fmt(p0, p1);
-----------------
src/utf8.rs <utf8::Utf8Sequences as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::Utf8Sequences as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::Utf8Sequences as std::fmt::Debug>::fmt(p0, p1);
+<utf8::Utf8Sequences>::fmt(p0, p1);
-----------------
src/utf8.rs utf8::Utf8Sequences::new
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+utf8::Utf8Sequences::new(p0, p1);
+crate::utf8::Utf8Sequences::new(p0, p1);
+<utf8::Utf8Sequences>::new(p0, p1);
-----------------
src/utf8.rs utf8::Utf8Sequences::reset
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
let mut p1 = 'a'; // None+char
let mut p2 = 'a'; // None+char
+p0.reset(p1, p2);
+utf8::Utf8Sequences::reset(p0, p1, p2);
+crate::utf8::Utf8Sequences::reset(p0, p1, p2);
+<utf8::Utf8Sequences>::reset(p0, p1, p2);
-----------------
src/utf8.rs utf8::Utf8Sequences::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+p0.push(p1, p2);
+utf8::Utf8Sequences::push(p0, p1, p2);
+crate::utf8::Utf8Sequences::push(p0, p1, p2);
+<utf8::Utf8Sequences>::push(p0, p1, p2);
-----------------
src/utf8.rs <utf8::ScalarRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::ScalarRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::ScalarRange as std::fmt::Debug>::fmt(p0, p1);
+<utf8::ScalarRange>::fmt(p0, p1);
-----------------
src/utf8.rs <utf8::Utf8Sequences as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
+p0.next();
+<utf8::Utf8Sequences as std::iter::Iterator>::next(p0);
+crate::<utf8::Utf8Sequences as std::iter::Iterator>::next(p0);
+<utf8::Utf8Sequences>::next(p0);
-----------------
src/utf8.rs utf8::ScalarRange::split
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.split();
+utf8::ScalarRange::split(p0);
+crate::utf8::ScalarRange::split(p0);
+<utf8::ScalarRange>::split(p0);
-----------------
src/utf8.rs utf8::ScalarRange::is_valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.is_valid();
+utf8::ScalarRange::is_valid(p0);
+crate::utf8::ScalarRange::is_valid(p0);
+<utf8::ScalarRange>::is_valid(p0);
-----------------
src/utf8.rs utf8::ScalarRange::as_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.as_ascii();
+utf8::ScalarRange::as_ascii(p0);
+crate::utf8::ScalarRange::as_ascii(p0);
+<utf8::ScalarRange>::as_ascii(p0);
-----------------
src/utf8.rs utf8::ScalarRange::is_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.is_ascii();
+utf8::ScalarRange::is_ascii(p0);
+crate::utf8::ScalarRange::is_ascii(p0);
+<utf8::ScalarRange>::is_ascii(p0);
-----------------
src/utf8.rs utf8::ScalarRange::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
let mut p2 = &mut [0u8].as_mut_slice(); // None+[u8]
+p0.encode(p1, p2);
+utf8::ScalarRange::encode(p0, p1, p2);
+crate::utf8::ScalarRange::encode(p0, p1, p2);
+<utf8::ScalarRange>::encode(p0, p1, p2);