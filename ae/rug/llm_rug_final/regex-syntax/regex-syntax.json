{"dependencies":{"<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter":["utf8::Utf8Range","utf8::Utf8Sequence"],"<ast::Alternation as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Alternation as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Alternation as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::Assertion as std::clone::Clone>::clone":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span"],"<ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span"],"<ast::Assertion as std::cmp::PartialEq>::eq":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span"],"<ast::Assertion as std::fmt::Debug>::fmt":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::AssertionKind as std::clone::Clone>::clone":["ast::AssertionKind"],"<ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::AssertionKind"],"<ast::AssertionKind as std::cmp::PartialEq>::eq":["ast::AssertionKind"],"<ast::AssertionKind as std::fmt::Debug>::fmt":["ast::AssertionKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Ast as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Ast as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Ast as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Ast as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Ast as std::ops::Drop>::drop":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::CaptureName as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::CaptureName as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::CaptureName as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Class as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Class as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Class as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassAscii as std::clone::Clone>::clone":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span"],"<ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span"],"<ast::ClassAscii as std::cmp::PartialEq>::eq":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span"],"<ast::ClassAscii as std::fmt::Debug>::fmt":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassAsciiKind as std::clone::Clone>::clone":["ast::ClassAsciiKind"],"<ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassAsciiKind"],"<ast::ClassAsciiKind as std::cmp::PartialEq>::eq":["ast::ClassAsciiKind"],"<ast::ClassAsciiKind as std::fmt::Debug>::fmt":["ast::ClassAsciiKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassBracketed as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassBracketed as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassBracketed as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassPerl as std::clone::Clone>::clone":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span"],"<ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span"],"<ast::ClassPerl as std::cmp::PartialEq>::eq":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span"],"<ast::ClassPerl as std::fmt::Debug>::fmt":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassPerlKind as std::clone::Clone>::clone":["ast::ClassPerlKind"],"<ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassPerlKind"],"<ast::ClassPerlKind as std::cmp::PartialEq>::eq":["ast::ClassPerlKind"],"<ast::ClassPerlKind as std::fmt::Debug>::fmt":["ast::ClassPerlKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassSet as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSet as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSet as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassSet as std::ops::Drop>::drop":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSetBinaryOp as std::clone::Clone>::clone":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::ClassSetBinaryOp as std::fmt::Debug>::fmt":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::ClassSetBinaryOpKind as std::clone::Clone>::clone":["ast::ClassSetBinaryOpKind"],"<ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassSetBinaryOpKind"],"<ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq":["ast::ClassSetBinaryOpKind"],"<ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt":["ast::ClassSetBinaryOpKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassSetItem as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSetItem as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassSetItem as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassSetRange as std::clone::Clone>::clone":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::ClassSetRange as std::cmp::PartialEq>::eq":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::ClassSetRange as std::fmt::Debug>::fmt":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ClassSetUnion as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::ClassSetUnion as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::ClassSetUnion as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::ClassUnicode as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicode as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicode as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeKind as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeKind as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeKind as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ClassUnicodeOpKind as std::clone::Clone>::clone":["ast::ClassUnicodeOpKind"],"<ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ClassUnicodeOpKind"],"<ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq":["ast::ClassUnicodeOpKind"],"<ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt":["ast::ClassUnicodeOpKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Comment as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Comment as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Comment as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Concat as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Concat as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Concat as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::Error as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Error as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Error as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::Error as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::ErrorKind as std::clone::Clone>::clone":["ast::ErrorKind","ast::Position","ast::Span"],"<ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::ErrorKind","ast::Position","ast::Span"],"<ast::ErrorKind as std::cmp::PartialEq>::eq":["ast::ErrorKind","ast::Position","ast::Span"],"<ast::ErrorKind as std::fmt::Debug>::fmt":["ast::ErrorKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::ErrorKind as std::fmt::Display>::fmt":["ast::ErrorKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Flag as std::clone::Clone>::clone":["ast::Flag"],"<ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Flag"],"<ast::Flag as std::cmp::PartialEq>::eq":["ast::Flag"],"<ast::Flag as std::fmt::Debug>::fmt":["ast::Flag","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Flags as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Flags as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::Flags as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::FlagsItem as std::clone::Clone>::clone":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span"],"<ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span"],"<ast::FlagsItem as std::cmp::PartialEq>::eq":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span"],"<ast::FlagsItem as std::fmt::Debug>::fmt":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::FlagsItemKind as std::clone::Clone>::clone":["ast::Flag","ast::FlagsItemKind"],"<ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Flag","ast::FlagsItemKind"],"<ast::FlagsItemKind as std::cmp::PartialEq>::eq":["ast::Flag","ast::FlagsItemKind"],"<ast::FlagsItemKind as std::fmt::Debug>::fmt":["ast::Flag","ast::FlagsItemKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Group as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Group as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::Group as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::GroupKind as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::GroupKind as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::GroupKind as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::HexLiteralKind as std::clone::Clone>::clone":["ast::HexLiteralKind"],"<ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::HexLiteralKind"],"<ast::HexLiteralKind as std::cmp::PartialEq>::eq":["ast::HexLiteralKind"],"<ast::HexLiteralKind as std::fmt::Debug>::fmt":["ast::HexLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Literal as std::clone::Clone>::clone":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::Literal as std::cmp::PartialEq>::eq":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"<ast::Literal as std::fmt::Debug>::fmt":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::LiteralKind as std::clone::Clone>::clone":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind"],"<ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind"],"<ast::LiteralKind as std::cmp::PartialEq>::eq":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind"],"<ast::LiteralKind as std::fmt::Debug>::fmt":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Position as std::clone::Clone>::clone":["ast::Position"],"<ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Position"],"<ast::Position as std::cmp::Ord>::cmp":["ast::Position","std::cmp::Ordering"],"<ast::Position as std::cmp::PartialEq>::eq":["ast::Position"],"<ast::Position as std::cmp::PartialOrd>::partial_cmp":["ast::Position","std::marker::Sized","std::option::Option"],"<ast::Position as std::fmt::Debug>::fmt":["ast::Position","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::Repetition as std::clone::Clone>::clone":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::Repetition as std::cmp::PartialEq>::eq":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<ast::Repetition as std::fmt::Debug>::fmt":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::RepetitionKind as std::clone::Clone>::clone":["ast::RepetitionKind","ast::RepetitionRange"],"<ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::RepetitionKind","ast::RepetitionRange"],"<ast::RepetitionKind as std::cmp::PartialEq>::eq":["ast::RepetitionKind","ast::RepetitionRange"],"<ast::RepetitionKind as std::fmt::Debug>::fmt":["ast::RepetitionKind","ast::RepetitionRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::RepetitionOp as std::clone::Clone>::clone":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span"],"<ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span"],"<ast::RepetitionOp as std::cmp::PartialEq>::eq":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span"],"<ast::RepetitionOp as std::fmt::Debug>::fmt":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::RepetitionRange as std::clone::Clone>::clone":["ast::RepetitionRange"],"<ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::RepetitionRange"],"<ast::RepetitionRange as std::cmp::PartialEq>::eq":["ast::RepetitionRange"],"<ast::RepetitionRange as std::fmt::Debug>::fmt":["ast::RepetitionRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::SetFlags as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::SetFlags as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<ast::SetFlags as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<ast::Span as std::clone::Clone>::clone":["ast::Position","ast::Span"],"<ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::Position","ast::Span"],"<ast::Span as std::cmp::Ord>::cmp":["ast::Position","ast::Span","std::cmp::Ordering"],"<ast::Span as std::cmp::PartialEq>::eq":["ast::Position","ast::Span"],"<ast::Span as std::cmp::PartialOrd>::partial_cmp":["ast::Position","ast::Span","std::marker::Sized","std::option::Option"],"<ast::Span as std::fmt::Debug>::fmt":["ast::Position","ast::Span","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::SpecialLiteralKind as std::clone::Clone>::clone":["ast::SpecialLiteralKind"],"<ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq":["ast::SpecialLiteralKind"],"<ast::SpecialLiteralKind as std::cmp::PartialEq>::eq":["ast::SpecialLiteralKind"],"<ast::SpecialLiteralKind as std::fmt::Debug>::fmt":["ast::SpecialLiteralKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::WithComments as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::WithComments as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::WithComments as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::ClassState as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ClassState","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::ClassState as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ClassState","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::GroupState as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Alternation","ast::CaptureName","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::parse::GroupState","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::GroupState as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Alternation","ast::CaptureName","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::parse::GroupState","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":["ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt":["ast::parse::NestLimiter","ast::parse::ParserI","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::parse::Parser as std::clone::Clone>::clone":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"<ast::parse::Parser as std::fmt::Debug>::fmt":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::parse::ParserBuilder as std::clone::Clone>::clone":["ast::parse::ParserBuilder"],"<ast::parse::ParserBuilder as std::default::Default>::default":["ast::parse::ParserBuilder"],"<ast::parse::ParserBuilder as std::fmt::Debug>::fmt":["ast::parse::ParserBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone":["ast::parse::ParserI","std::marker::Sized"],"<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt":["ast::parse::ParserI","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::parse::Primitive as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::Primitive as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<ast::parse::Primitive as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Printer as std::fmt::Debug>::fmt":["ast::print::Printer","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::print::PrinterBuilder as std::clone::Clone>::clone":["ast::print::PrinterBuilder"],"<ast::print::PrinterBuilder as std::default::Default>::default":["ast::print::PrinterBuilder"],"<ast::print::PrinterBuilder as std::fmt::Debug>::fmt":["ast::print::PrinterBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::print::Writer<W> as ast::visitor::Visitor>::finish":["ast::print::Writer","std::marker::Sized","std::result::Result"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_alternation_in":["ast::print::Writer","std::marker::Sized","std::result::Result"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_post":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_pre":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::print::Writer<W> as std::fmt::Debug>::fmt":["ast::print::Writer","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassFrame","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<char as hir::interval::Bound>::as_u32":[],"<char as hir::interval::Bound>::decrement":[],"<char as hir::interval::Bound>::increment":[],"<char as hir::interval::Bound>::max_value":[],"<char as hir::interval::Bound>::min_value":[],"<debug::Byte as std::fmt::Debug>::fmt":["debug::Byte","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<debug::Bytes<'a> as std::fmt::Debug>::fmt":["debug::Bytes","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<either::Either<Left, Right> as std::clone::Clone>::clone":["either::Either","std::marker::Sized"],"<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq":["either::Either","std::marker::Sized"],"<either::Either<Left, Right> as std::cmp::PartialEq>::eq":["either::Either","std::marker::Sized"],"<either::Either<Left, Right> as std::fmt::Debug>::fmt":["either::Either","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<error::Error as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::convert::From<ast::Error>>::from":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::convert::From<hir::Error>>::from":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Error as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<error::Error as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<error::Formatter<'e, E> as std::fmt::Debug>::fmt":["ast::Position","ast::Span","error::Formatter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<error::Formatter<'e, E> as std::fmt::Display>::fmt":["ast::Position","ast::Span","error::Formatter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Formatter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from":["alloc::raw_vec::RawVec","ast::Position","ast::Span","error::Formatter","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Capture as std::clone::Clone>::clone":["hir::Capture","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"<hir::Capture as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::Capture","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"<hir::Capture as std::cmp::PartialEq>::eq":["hir::Capture","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"<hir::Capture as std::fmt::Debug>::fmt":["hir::Capture","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::Class as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::Class as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::Class as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassBytes as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassBytes as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassBytes as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt":["hir::ClassBytesIter","hir::interval::IntervalSetIter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"<hir::ClassBytesIter<'a> as std::iter::Iterator>::next":["hir::ClassBytesIter","hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassBytesRange","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassBytesRange as hir::interval::Interval>::lower":["hir::ClassBytesRange"],"<hir::ClassBytesRange as hir::interval::Interval>::set_lower":["hir::ClassBytesRange"],"<hir::ClassBytesRange as hir::interval::Interval>::set_upper":["hir::ClassBytesRange"],"<hir::ClassBytesRange as hir::interval::Interval>::upper":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::clone::Clone>::clone":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::cmp::Ord>::cmp":["hir::ClassBytesRange","std::cmp::Ordering"],"<hir::ClassBytesRange as std::cmp::PartialEq>::eq":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp":["hir::ClassBytesRange","std::marker::Sized","std::option::Option"],"<hir::ClassBytesRange as std::default::Default>::default":["hir::ClassBytesRange"],"<hir::ClassBytesRange as std::fmt::Debug>::fmt":["hir::ClassBytesRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::ClassUnicode as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassUnicode as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::ClassUnicode as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt":["hir::ClassUnicodeIter","hir::interval::IntervalSetIter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next":["hir::ClassUnicodeIter","hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassUnicodeRange","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::ClassUnicodeRange as hir::interval::Interval>::lower":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as hir::interval::Interval>::upper":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::clone::Clone>::clone":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::cmp::Ord>::cmp":["hir::ClassUnicodeRange","std::cmp::Ordering"],"<hir::ClassUnicodeRange as std::cmp::PartialEq>::eq":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp":["hir::ClassUnicodeRange","std::marker::Sized","std::option::Option"],"<hir::ClassUnicodeRange as std::default::Default>::default":["hir::ClassUnicodeRange"],"<hir::ClassUnicodeRange as std::fmt::Debug>::fmt":["hir::ClassUnicodeRange","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::Dot as std::clone::Clone>::clone":["hir::Dot"],"<hir::Dot as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::Dot"],"<hir::Dot as std::cmp::PartialEq>::eq":["hir::Dot"],"<hir::Dot as std::fmt::Debug>::fmt":["hir::Dot","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::Error as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Error as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<hir::Error as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::Error as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::ErrorKind as std::clone::Clone>::clone":["hir::ErrorKind"],"<hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::ErrorKind"],"<hir::ErrorKind as std::cmp::PartialEq>::eq":["hir::ErrorKind"],"<hir::ErrorKind as std::fmt::Debug>::fmt":["hir::ErrorKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::ErrorKind as std::fmt::Display>::fmt":["hir::ErrorKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::Hir as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::Hir as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::Hir as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::Hir as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::Hir as std::ops::Drop>::drop":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::HirKind as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::HirKind","hir::Literal","hir::Look","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::HirKind","hir::Literal","hir::Look","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::HirKind as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::HirKind","hir::Literal","hir::Look","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::HirKind as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::HirKind","hir::Literal","hir::Look","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::Literal as std::clone::Clone>::clone":["hir::Literal","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::Literal","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<hir::Literal as std::cmp::PartialEq>::eq":["hir::Literal","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<hir::Literal as std::fmt::Debug>::fmt":["hir::Literal","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::Look as std::clone::Clone>::clone":["hir::Look"],"<hir::Look as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::Look"],"<hir::Look as std::cmp::PartialEq>::eq":["hir::Look"],"<hir::Look as std::fmt::Debug>::fmt":["hir::Look","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::LookSet as std::clone::Clone>::clone":["hir::LookSet"],"<hir::LookSet as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::LookSet"],"<hir::LookSet as std::cmp::PartialEq>::eq":["hir::LookSet"],"<hir::LookSet as std::default::Default>::default":["hir::LookSet"],"<hir::LookSet as std::fmt::Debug>::fmt":["hir::LookSet","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::LookSetIter as std::clone::Clone>::clone":["hir::LookSet","hir::LookSetIter"],"<hir::LookSetIter as std::fmt::Debug>::fmt":["hir::LookSet","hir::LookSetIter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::LookSetIter as std::iter::Iterator>::next":["hir::LookSet","hir::LookSetIter","std::marker::Sized","std::option::Option"],"<hir::Properties as std::clone::Clone>::clone":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<hir::Properties as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<hir::Properties as std::cmp::PartialEq>::eq":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"<hir::Properties as std::fmt::Debug>::fmt":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::PropertiesI as std::clone::Clone>::clone":["hir::LookSet","hir::PropertiesI","std::marker::Sized","std::option::Option"],"<hir::PropertiesI as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::LookSet","hir::PropertiesI","std::marker::Sized","std::option::Option"],"<hir::PropertiesI as std::cmp::PartialEq>::eq":["hir::LookSet","hir::PropertiesI","std::marker::Sized","std::option::Option"],"<hir::PropertiesI as std::fmt::Debug>::fmt":["hir::LookSet","hir::PropertiesI","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::Repetition as std::clone::Clone>::clone":["hir::Repetition","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"<hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::Repetition","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"<hir::Repetition as std::cmp::PartialEq>::eq":["hir::Repetition","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"<hir::Repetition as std::fmt::Debug>::fmt":["hir::Repetition","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::interval::IntervalSet<I> as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt":["hir::interval::IntervalSetIter","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::result::Result","std::slice::Iter"],"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":["hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"<hir::literal::ExtractKind as std::clone::Clone>::clone":["hir::literal::ExtractKind"],"<hir::literal::ExtractKind as std::default::Default>::default":["hir::literal::ExtractKind"],"<hir::literal::ExtractKind as std::fmt::Debug>::fmt":["hir::literal::ExtractKind","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::literal::Extractor as std::clone::Clone>::clone":["hir::literal::ExtractKind","hir::literal::Extractor"],"<hir::literal::Extractor as std::default::Default>::default":["hir::literal::ExtractKind","hir::literal::Extractor"],"<hir::literal::Extractor as std::fmt::Debug>::fmt":["hir::literal::ExtractKind","hir::literal::Extractor","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::literal::Literal as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::cmp::Ord>::cmp":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::convert::From<char>>::from":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::convert::From<u8>>::from":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::Literal as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::literal::PreferenceTrie as std::default::Default>::default":["alloc::raw_vec::RawVec","hir::literal::PreferenceTrie","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::PreferenceTrie as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::literal::PreferenceTrie","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::literal::Seq as std::clone::Clone>::clone":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"<hir::literal::Seq as std::cmp::Eq>::assert_receiver_is_total_eq":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"<hir::literal::Seq as std::cmp::PartialEq>::eq":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"<hir::literal::Seq as std::fmt::Debug>::fmt":["hir::literal::Seq","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::literal::Seq as std::iter::FromIterator<hir::literal::Literal>>::from_iter":["hir::literal::Seq","std::iter::IntoIterator","std::marker::Sized","std::option::Option"],"<hir::literal::State as std::default::Default>::default":["alloc::raw_vec::RawVec","hir::literal::State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::literal::State as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::literal::State","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::print::Printer as std::fmt::Debug>::fmt":["hir::print::Printer","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::print::PrinterBuilder as std::clone::Clone>::clone":["hir::print::PrinterBuilder"],"<hir::print::PrinterBuilder as std::default::Default>::default":["hir::print::PrinterBuilder"],"<hir::print::PrinterBuilder as std::fmt::Debug>::fmt":["hir::print::PrinterBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::print::Writer<W> as hir::visitor::Visitor>::finish":["hir::print::Writer","std::marker::Sized","std::result::Result"],"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_alternation_in":["hir::print::Writer","std::marker::Sized","std::result::Result"],"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_post":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_pre":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::print::Writer<W> as std::fmt::Debug>::fmt":["hir::print::Writer","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::translate::Flags as std::clone::Clone>::clone":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"<hir::translate::Flags as std::default::Default>::default":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"<hir::translate::Flags as std::fmt::Debug>::fmt":["hir::translate::Flags","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::translate::HirFrame as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"<hir::translate::HirFrame as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"<hir::translate::Translator as std::clone::Clone>::clone":["hir::translate::Translator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"<hir::translate::Translator as std::fmt::Debug>::fmt":["hir::translate::Translator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::translate::TranslatorBuilder as std::clone::Clone>::clone":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"<hir::translate::TranslatorBuilder as std::default::Default>::default":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"<hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_alternation_in":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"<hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<parser::Parser as std::clone::Clone>::clone":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"<parser::Parser as std::fmt::Debug>::fmt":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<parser::ParserBuilder as std::clone::Clone>::clone":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"<parser::ParserBuilder as std::default::Default>::default":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"<parser::ParserBuilder as std::fmt::Debug>::fmt":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<u8 as hir::interval::Bound>::as_u32":[],"<u8 as hir::interval::Bound>::decrement":[],"<u8 as hir::interval::Bound>::increment":[],"<u8 as hir::interval::Bound>::max_value":[],"<u8 as hir::interval::Bound>::min_value":[],"<unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq":["unicode::CanonicalClassQuery"],"<unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq":["unicode::CanonicalClassQuery"],"<unicode::CanonicalClassQuery as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::CanonicalClassQuery"],"<unicode::CaseFoldError as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::CaseFoldError"],"<unicode::CaseFoldError as std::fmt::Display>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::CaseFoldError"],"<unicode::ClassQuery<'a> as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::ClassQuery"],"<unicode::Error as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::Error"],"<unicode::SimpleCaseFolder as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::SimpleCaseFolder"],"<unicode::UnicodeWordError as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::UnicodeWordError"],"<unicode::UnicodeWordError as std::fmt::Display>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","unicode::UnicodeWordError"],"<utf8::ScalarRange as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","utf8::ScalarRange"],"<utf8::Utf8Range as std::clone::Clone>::clone":["utf8::Utf8Range"],"<utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq":["utf8::Utf8Range"],"<utf8::Utf8Range as std::cmp::Ord>::cmp":["std::cmp::Ordering","utf8::Utf8Range"],"<utf8::Utf8Range as std::cmp::PartialEq>::eq":["utf8::Utf8Range"],"<utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","utf8::Utf8Range"],"<utf8::Utf8Range as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","utf8::Utf8Range"],"<utf8::Utf8Sequence as std::clone::Clone>::clone":["utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq":["utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::cmp::Ord>::cmp":["std::cmp::Ordering","utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::cmp::PartialEq>::eq":["utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequence as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","utf8::Utf8Range","utf8::Utf8Sequence"],"<utf8::Utf8Sequences as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","utf8::Utf8Sequences"],"<utf8::Utf8Sequences as std::iter::Iterator>::next":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"ast::Alternation":["alloc::raw_vec::RawVec","ast::Alternation","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Alternation::into_ast":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Assertion":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span"],"ast::AssertionKind":["ast::AssertionKind"],"ast::Ast":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Ast::has_subexprs":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Ast::is_empty":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Ast::span":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::CaptureName":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Class":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Class::span":["alloc::raw_vec::RawVec","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassAscii":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span"],"ast::ClassAsciiKind":["ast::ClassAsciiKind"],"ast::ClassAsciiKind::from_name":["std::marker::Sized","std::option::Option"],"ast::ClassBracketed":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassPerl":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span"],"ast::ClassPerlKind":["ast::ClassPerlKind"],"ast::ClassSet":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSet::is_empty":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSet::span":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSet::union":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSetBinaryOp":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"ast::ClassSetBinaryOpKind":["ast::ClassSetBinaryOpKind"],"ast::ClassSetItem":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSetItem::span":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSetRange":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"ast::ClassSetRange::is_valid":["ast::ClassSetRange","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"ast::ClassSetUnion":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::ClassSetUnion::into_item":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassSetUnion::push":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassUnicode":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassUnicode::is_negated":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassUnicodeKind":["alloc::raw_vec::RawVec","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ClassUnicodeOpKind":["ast::ClassUnicodeOpKind"],"ast::ClassUnicodeOpKind::is_equal":["ast::ClassUnicodeOpKind"],"ast::Comment":["alloc::raw_vec::RawVec","ast::Comment","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Concat":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Concat::into_ast":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error::auxiliary_span":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error::kind":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error::pattern":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Error::span":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::ErrorKind":["ast::ErrorKind","ast::Position","ast::Span"],"ast::Flag":["ast::Flag"],"ast::Flags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Flags::add_item":["alloc::raw_vec::RawVec","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Flags::flag_state":["alloc::raw_vec::RawVec","ast::Flag","ast::Flags","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::FlagsItem":["ast::Flag","ast::FlagsItem","ast::FlagsItemKind","ast::Position","ast::Span"],"ast::FlagsItemKind":["ast::Flag","ast::FlagsItemKind"],"ast::FlagsItemKind::is_negation":["ast::Flag","ast::FlagsItemKind"],"ast::Group":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Group::capture_index":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Group::flags":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::Group::is_capturing":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::GroupKind":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::GroupKind","ast::Position","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::HexLiteralKind":["ast::HexLiteralKind"],"ast::HexLiteralKind::digits":["ast::HexLiteralKind"],"ast::Literal":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind"],"ast::Literal::byte":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::marker::Sized","std::option::Option"],"ast::LiteralKind":["ast::HexLiteralKind","ast::LiteralKind","ast::SpecialLiteralKind"],"ast::Position":["ast::Position"],"ast::Position::new":["ast::Position"],"ast::Repetition":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"ast::RepetitionKind":["ast::RepetitionKind","ast::RepetitionRange"],"ast::RepetitionOp":["ast::Position","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span"],"ast::RepetitionRange":["ast::RepetitionRange"],"ast::RepetitionRange::is_valid":["ast::RepetitionRange"],"ast::SetFlags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::Span":["ast::Position","ast::Span"],"ast::Span::is_empty":["ast::Position","ast::Span"],"ast::Span::is_one_line":["ast::Position","ast::Span"],"ast::Span::new":["ast::Position","ast::Span"],"ast::Span::splat":["ast::Position","ast::Span"],"ast::Span::with_end":["ast::Position","ast::Span"],"ast::Span::with_start":["ast::Position","ast::Span"],"ast::SpecialLiteralKind":["ast::SpecialLiteralKind"],"ast::WithComments":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::ClassState":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ClassState","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::GroupState":["alloc::raw_vec::RawVec","ast::Alternation","ast::CaptureName","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::parse::GroupState","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::NestLimiter":["ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized"],"ast::parse::NestLimiter::<'p, 's, P>::check":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":["ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized"],"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":["ast::Position","ast::Span","ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::NestLimiter::<'p, 's, P>::new":["ast::parse::NestLimiter","ast::parse::ParserI","std::marker::Sized"],"ast::parse::Parser":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"ast::parse::Parser::new":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"ast::parse::Parser::parse":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"ast::parse::Parser::parse_with_comments":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"ast::parse::Parser::reset":["ast::parse::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"ast::parse::ParserBuilder":["ast::parse::ParserBuilder"],"ast::parse::ParserBuilder::build":["ast::parse::Parser","ast::parse::ParserBuilder","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"ast::parse::ParserBuilder::ignore_whitespace":["ast::parse::ParserBuilder"],"ast::parse::ParserBuilder::nest_limit":["ast::parse::ParserBuilder"],"ast::parse::ParserBuilder::new":["ast::parse::ParserBuilder"],"ast::parse::ParserBuilder::octal":["ast::parse::ParserBuilder"],"ast::parse::ParserI":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::add_capture_name":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::bump":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::bump_and_bump_space":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::bump_if":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::bump_space":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::char":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::char_at":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::column":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::error":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::ignore_whitespace":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::is_eof":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::line":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":["ast::parse::ParserI","std::marker::Sized","std::option::Option"],"ast::parse::ParserI::<'s, P>::new":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::next_capture_index":["ast::Position","ast::Span","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::offset":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::parse":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_capture_name":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_counted_repetition":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::parse_decimal":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_escape":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_flag":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_flags":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_group":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_hex":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_hex_brace":["ast::HexLiteralKind","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_hex_digits":["ast::HexLiteralKind","ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_octal":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::parse_perl_class":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::parse_primitive":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_set_class":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_set_class_item":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_set_class_open":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_set_class_range":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::RepetitionKind","ast::RepetitionRange","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::parse_unicode_class":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parse_with_comments":["ast::parse::ParserI","std::marker::Sized","std::result::Result"],"ast::parse::ParserI::<'s, P>::parser":["ast::parse::Parser","ast::parse::ParserI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::pattern":["ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::peek":["ast::parse::ParserI","std::marker::Sized","std::option::Option"],"ast::parse::ParserI::<'s, P>::peek_space":["ast::parse::ParserI","std::marker::Sized","std::option::Option"],"ast::parse::ParserI::<'s, P>::pop_class":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::pop_class_op":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ParserI","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::pop_group":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::pop_group_end":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::pos":["ast::Position","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::push_alternate":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::push_class_op":["alloc::raw_vec::RawVec","ast::ClassSetBinaryOpKind","ast::ClassSetUnion","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::push_class_open":["alloc::raw_vec::RawVec","ast::ClassSetUnion","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::push_group":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::push_or_add_alternation":["alloc::raw_vec::RawVec","ast::Concat","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::parse::ParserI::<'s, P>::span":["ast::Position","ast::Span","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::span_char":["ast::Position","ast::Span","ast::parse::ParserI","std::marker::Sized"],"ast::parse::ParserI::<'s, P>::unclosed_class_error":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","ast::parse::ParserI","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::Primitive":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::Primitive::into_ast":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::Primitive::into_class_literal":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ParserI","ast::parse::Primitive","std::alloc::Allocator","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::parse::Primitive::into_class_set_item":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::ParserI","ast::parse::Primitive","std::alloc::Allocator","std::borrow::Borrow","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::parse::Primitive::span":["alloc::raw_vec::RawVec","ast::Assertion","ast::AssertionKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::Primitive","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::parse::is_capture_char":[],"ast::parse::is_hex":[],"ast::parse::specialize_err":["ast::ErrorKind","ast::Position","ast::Span","std::marker::Sized","std::result::Result"],"ast::print::Printer":["ast::print::Printer"],"ast::print::Printer::new":["ast::print::Printer"],"ast::print::Printer::print":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::print::Printer","std::alloc::Allocator","std::boxed::Box","std::fmt::Write","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::PrinterBuilder":["ast::print::PrinterBuilder"],"ast::print::PrinterBuilder::build":["ast::print::Printer","ast::print::PrinterBuilder"],"ast::print::PrinterBuilder::new":["ast::print::PrinterBuilder"],"ast::print::Writer":["ast::print::Writer","std::marker::Sized"],"ast::print::Writer::<W>::fmt_assertion":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<W>::fmt_class_ascii":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<W>::fmt_class_bracketed_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<W>::fmt_class_bracketed_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<W>::fmt_class_perl":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<W>::fmt_class_set_binary_op_kind":["ast::ClassSetBinaryOpKind","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<W>::fmt_class_unicode":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","ast::print::Writer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<W>::fmt_flags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","ast::print::Writer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::print::Writer::<W>::fmt_group_post":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<W>::fmt_group_pre":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::print::Writer::<W>::fmt_literal":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<W>::fmt_repetition":["ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","ast::print::Writer","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"ast::print::Writer::<W>::fmt_repetition_range":["ast::RepetitionRange","ast::print::Writer","std::marker::Sized","std::result::Result"],"ast::print::Writer::<W>::fmt_set_flags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::SetFlags","ast::Span","ast::print::Writer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"ast::visitor::ClassFrame":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::ClassFrame::<'a>::child":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassFrame","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::ClassInduct":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::ClassInduct::<'a>::from_bracketed":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::ClassInduct::<'a>::from_set":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::Frame":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::visitor::Frame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::Frame::<'a>::child":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::visitor::Frame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor":["alloc::raw_vec::RawVec","ast::visitor::HeapVisitor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::induct":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::induct_class":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassInduct","ast::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::new":["alloc::raw_vec::RawVec","ast::visitor::HeapVisitor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::pop":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::visitor::Frame","ast::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::pop_class":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::visitor::ClassFrame","ast::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::visit":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::visit_class":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::visit_class_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::ClassInduct","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::HeapVisitor::<'a>::visit_class_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::ClassInduct","ast::visitor::HeapVisitor","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::Visitor::finish":["std::marker::Sized","std::result::Result"],"ast::visitor::Visitor::start":[],"ast::visitor::Visitor::visit_alternation_in":["std::marker::Sized","std::result::Result"],"ast::visitor::Visitor::visit_class_set_binary_op_in":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"ast::visitor::Visitor::visit_class_set_binary_op_post":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"ast::visitor::Visitor::visit_class_set_binary_op_pre":["ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Position","ast::Span","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result"],"ast::visitor::Visitor::visit_class_set_item_post":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::Visitor::visit_class_set_item_pre":["alloc::raw_vec::RawVec","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::Visitor::visit_post":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::Visitor::visit_pre":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"ast::visitor::visit":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::parse::ParserI","ast::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"debug::Byte":["debug::Byte"],"debug::Bytes":["debug::Bytes"],"debug::utf8_decode":["std::marker::Sized","std::option::Option"],"debug::utf8_decode::len":["std::marker::Sized","std::option::Option"],"either::Either":["either::Either","std::marker::Sized"],"error::Error":["alloc::raw_vec::RawVec","ast::Error","ast::ErrorKind","ast::Position","ast::Span","error::Error","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"error::Formatter":["ast::Position","ast::Span","error::Formatter","std::marker::Sized","std::option::Option"],"error::Spans":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"error::Spans::<'p>::add":["alloc::raw_vec::RawVec","ast::Position","ast::Span","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"error::Spans::<'p>::from_formatter":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","error::Formatter","error::Spans","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"error::Spans::<'p>::left_pad_line_number":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"error::Spans::<'p>::line_number_padding":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"error::Spans::<'p>::notate":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"error::Spans::<'p>::notate_line":["alloc::raw_vec::RawVec","error::Spans","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"error::repeat_char":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"escape":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"escape_into":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Capture":["hir::Capture","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"hir::Class":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::case_fold_simple":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::is_empty":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::is_utf8":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::literal":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::maximum_len":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::minimum_len":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::negate":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Class::try_case_fold_simple":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::ClassBytes":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::difference":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::empty":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::intersect":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::is_ascii":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::iter":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::ClassBytesIter","hir::interval::IntervalSet","hir::interval::IntervalSetIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::vec::Vec"],"hir::ClassBytes::literal":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::maximum_len":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::minimum_len":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::negate":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::new":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::push":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::ClassBytesRange","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::ranges":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::ClassBytesRange","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::symmetric_difference":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::to_unicode_class":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytes::union":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassBytesIter":["hir::ClassBytesIter","hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"hir::ClassBytesRange":["hir::ClassBytesRange"],"hir::ClassBytesRange::end":["hir::ClassBytesRange"],"hir::ClassBytesRange::len":["hir::ClassBytesRange"],"hir::ClassBytesRange::new":["hir::ClassBytesRange"],"hir::ClassBytesRange::start":["hir::ClassBytesRange"],"hir::ClassUnicode":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::difference":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::empty":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::intersect":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::is_ascii":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::iter":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::ClassUnicodeIter","hir::interval::IntervalSet","hir::interval::IntervalSetIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::vec::Vec"],"hir::ClassUnicode::literal":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::maximum_len":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::minimum_len":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::negate":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::new":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::push":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::ClassUnicodeRange","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::ranges":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::ClassUnicodeRange","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::symmetric_difference":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::to_byte_class":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicode::try_case_fold_simple":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::ClassUnicode::union":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::ClassUnicodeIter":["hir::ClassUnicodeIter","hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"hir::ClassUnicodeRange":["hir::ClassUnicodeRange"],"hir::ClassUnicodeRange::end":["hir::ClassUnicodeRange"],"hir::ClassUnicodeRange::len":["hir::ClassUnicodeRange"],"hir::ClassUnicodeRange::new":["hir::ClassUnicodeRange"],"hir::ClassUnicodeRange::start":["hir::ClassUnicodeRange"],"hir::Dot":["hir::Dot"],"hir::Error":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Error::kind":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Error::pattern":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::Error::span":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::ErrorKind":["hir::ErrorKind"],"hir::Hir":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::alternation":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::capture":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::class":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::concat":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::dot":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Dot","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::empty":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::fail":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::into_kind":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::into_parts":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::kind":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::literal":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::look":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::properties":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Hir::repetition":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::HirKind":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::HirKind","hir::Literal","hir::Look","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::HirKind::subs":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Literal":["hir::Literal","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Look":["hir::Look"],"hir::Look::as_char":["hir::Look"],"hir::Look::as_repr":["hir::Look"],"hir::Look::from_repr":["std::marker::Sized","std::option::Option"],"hir::Look::reversed":["hir::Look"],"hir::LookSet":["hir::LookSet"],"hir::LookSet::contains":["hir::Look","hir::LookSet"],"hir::LookSet::contains_anchor":["hir::LookSet"],"hir::LookSet::contains_anchor_crlf":["hir::LookSet"],"hir::LookSet::contains_anchor_haystack":["hir::LookSet"],"hir::LookSet::contains_anchor_lf":["hir::LookSet"],"hir::LookSet::contains_anchor_line":["hir::LookSet"],"hir::LookSet::contains_word":["hir::LookSet"],"hir::LookSet::contains_word_ascii":["hir::LookSet"],"hir::LookSet::contains_word_unicode":["hir::LookSet"],"hir::LookSet::empty":["hir::LookSet"],"hir::LookSet::full":["hir::LookSet"],"hir::LookSet::insert":["hir::Look","hir::LookSet"],"hir::LookSet::intersect":["hir::LookSet"],"hir::LookSet::is_empty":["hir::LookSet"],"hir::LookSet::iter":["hir::LookSet","hir::LookSetIter"],"hir::LookSet::len":["hir::LookSet"],"hir::LookSet::read_repr":["hir::LookSet"],"hir::LookSet::remove":["hir::Look","hir::LookSet"],"hir::LookSet::set_insert":["hir::Look","hir::LookSet"],"hir::LookSet::set_intersect":["hir::LookSet"],"hir::LookSet::set_remove":["hir::Look","hir::LookSet"],"hir::LookSet::set_subtract":["hir::LookSet"],"hir::LookSet::set_union":["hir::LookSet"],"hir::LookSet::singleton":["hir::Look","hir::LookSet"],"hir::LookSet::subtract":["hir::LookSet"],"hir::LookSet::union":["hir::LookSet"],"hir::LookSet::write_repr":["hir::LookSet"],"hir::LookSetIter":["hir::LookSet","hir::LookSetIter"],"hir::Properties":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::alternation":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Properties::capture":["hir::Capture","hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::class":["alloc::raw_vec::RawVec","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Properties","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Properties::concat":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::Properties::empty":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::explicit_captures_len":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::is_alternation_literal":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::is_literal":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::is_utf8":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::literal":["hir::Literal","hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::look":["hir::Look","hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::look_set":["hir::LookSet","hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::look_set_prefix":["hir::LookSet","hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::look_set_prefix_any":["hir::LookSet","hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::look_set_suffix":["hir::LookSet","hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::look_set_suffix_any":["hir::LookSet","hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::maximum_len":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::memory_usage":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::minimum_len":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::repetition":["hir::Properties","hir::Repetition","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::static_explicit_captures_len":["hir::Properties","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"hir::Properties::union":["hir::Properties","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique"],"hir::PropertiesI":["hir::LookSet","hir::PropertiesI","std::marker::Sized","std::option::Option"],"hir::Repetition":["hir::Repetition","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"hir::Repetition::with":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::class_bytes":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::class_chars":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::Bound::as_u32":[],"hir::interval::Bound::decrement":[],"hir::interval::Bound::increment":[],"hir::interval::Bound::max_value":[],"hir::interval::Bound::min_value":[],"hir::interval::Interval::case_fold_simple":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::interval::Interval::create":[],"hir::interval::Interval::difference":["std::marker::Sized","std::option::Option"],"hir::interval::Interval::intersect":["std::marker::Sized","std::option::Option"],"hir::interval::Interval::is_contiguous":[],"hir::interval::Interval::is_intersection_empty":[],"hir::interval::Interval::is_subset":[],"hir::interval::Interval::lower":[],"hir::interval::Interval::set_lower":[],"hir::interval::Interval::set_upper":[],"hir::interval::Interval::symmetric_difference":["std::marker::Sized","std::option::Option"],"hir::interval::Interval::union":["std::marker::Sized","std::option::Option"],"hir::interval::Interval::upper":[],"hir::interval::IntervalSet":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::canonicalize":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::case_fold_simple":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::interval::IntervalSet::<I>::difference":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::intersect":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::intervals":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::is_canonical":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::iter":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","hir::interval::IntervalSetIter","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::slice::Iter","std::vec::Vec"],"hir::interval::IntervalSet::<I>::negate":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::new":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::push":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::symmetric_difference":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSet::<I>::union":["alloc::raw_vec::RawVec","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::interval::IntervalSetIter":["hir::interval::IntervalSetIter","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter"],"hir::lift_common_prefix":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::literal::ExtractKind":["hir::literal::ExtractKind"],"hir::literal::ExtractKind::is_prefix":["hir::literal::ExtractKind"],"hir::literal::ExtractKind::is_suffix":["hir::literal::ExtractKind"],"hir::literal::Extractor":["hir::literal::ExtractKind","hir::literal::Extractor"],"hir::literal::Extractor::class_over_limit_bytes":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","hir::literal::ExtractKind","hir::literal::Extractor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Extractor::class_over_limit_unicode":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","hir::literal::ExtractKind","hir::literal::Extractor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Extractor::cross":["hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Extractor::enforce_literal_len":["hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Extractor::extract":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Seq","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Extractor::extract_alternation":["hir::ClassBytesIter","hir::interval::IntervalSetIter","hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Seq","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"hir::literal::Extractor::extract_class_bytes":["alloc::raw_vec::RawVec","hir::ClassBytes","hir::interval::IntervalSet","hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Seq","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Extractor::extract_class_unicode":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Seq","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Extractor::extract_concat":["hir::ClassBytesIter","hir::interval::IntervalSetIter","hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Seq","std::iter::Iterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::slice::Iter"],"hir::literal::Extractor::extract_repetition":["hir::Repetition","hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Seq","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique"],"hir::literal::Extractor::kind":["hir::literal::ExtractKind","hir::literal::Extractor"],"hir::literal::Extractor::limit_class":["hir::literal::ExtractKind","hir::literal::Extractor"],"hir::literal::Extractor::limit_literal_len":["hir::literal::ExtractKind","hir::literal::Extractor"],"hir::literal::Extractor::limit_repeat":["hir::literal::ExtractKind","hir::literal::Extractor"],"hir::literal::Extractor::limit_total":["hir::literal::ExtractKind","hir::literal::Extractor"],"hir::literal::Extractor::new":["hir::literal::ExtractKind","hir::literal::Extractor"],"hir::literal::Extractor::union":["hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Literal":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::as_bytes":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::exact":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::extend":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::inexact":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::convert::Into","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::into_bytes":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::is_empty":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::is_exact":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::is_poisonous":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::keep_first_bytes":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::keep_last_bytes":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::len":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::make_inexact":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Literal::reverse":["alloc::raw_vec::RawVec","hir::literal::Literal","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::PreferenceTrie":["alloc::raw_vec::RawVec","hir::literal::PreferenceTrie","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::PreferenceTrie::create_state":["alloc::raw_vec::RawVec","hir::literal::PreferenceTrie","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::PreferenceTrie::insert":["alloc::raw_vec::RawVec","hir::literal::PreferenceTrie","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::literal::PreferenceTrie::minimize":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::PreferenceTrie::root":["alloc::raw_vec::RawVec","hir::literal::PreferenceTrie","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Seq":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::cross_forward":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::cross_preamble":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::cross_reverse":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::dedup":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::empty":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::infinite":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::is_empty":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::is_exact":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::is_finite":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::is_inexact":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::keep_first_bytes":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::keep_last_bytes":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::len":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::literals":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::longest_common_prefix":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::longest_common_suffix":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::make_inexact":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::make_infinite":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::max_cross_len":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::max_literal_len":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::max_union_len":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::min_literal_len":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::minimize_by_preference":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::new":["alloc::raw_vec::RawVec","hir::literal::Literal","hir::literal::Seq","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Seq::optimize_by_preference":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::optimize_for_prefix_by_preference":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::optimize_for_suffix_by_preference":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::push":["alloc::raw_vec::RawVec","hir::literal::Literal","hir::literal::Seq","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Seq::reverse_literals":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::singleton":["alloc::raw_vec::RawVec","hir::literal::Literal","hir::literal::Seq","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::Seq::sort":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::union":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::Seq::union_into_empty":["hir::literal::Seq","std::marker::Sized","std::option::Option"],"hir::literal::State":["alloc::raw_vec::RawVec","hir::literal::State","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::literal::rank":[],"hir::print::Printer":["hir::print::Printer"],"hir::print::Printer::new":["hir::print::Printer"],"hir::print::Printer::print":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::print::Printer","std::alloc::Allocator","std::boxed::Box","std::fmt::Write","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::print::PrinterBuilder":["hir::print::PrinterBuilder"],"hir::print::PrinterBuilder::build":["hir::print::Printer","hir::print::PrinterBuilder"],"hir::print::PrinterBuilder::new":["hir::print::PrinterBuilder"],"hir::print::Writer":["hir::print::Writer","std::marker::Sized"],"hir::print::Writer::<W>::write_literal_byte":["hir::print::Writer","std::marker::Sized","std::result::Result"],"hir::print::Writer::<W>::write_literal_char":["hir::print::Writer","std::marker::Sized","std::result::Result"],"hir::print::Writer::<W>::write_literal_class_byte":["hir::print::Writer","std::marker::Sized","std::result::Result"],"hir::singleton_bytes":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::singleton_chars":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::Flags":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::case_insensitive":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::crlf":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::dot":["hir::Dot","hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::dot_matches_new_line":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::from_ast":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","hir::translate::Flags","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::Flags::merge":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::multi_line":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::swap_greed":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::Flags::unicode":["hir::translate::Flags","std::marker::Sized","std::option::Option"],"hir::translate::HirFrame":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::HirFrame::unwrap_alternation_pipe":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::HirFrame::unwrap_class_bytes":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::HirFrame::unwrap_class_unicode":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::HirFrame::unwrap_expr":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::HirFrame::unwrap_group":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::HirFrame::unwrap_repetition":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::Translator":["hir::translate::Translator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::Translator::new":["hir::translate::Translator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::Translator::translate":["alloc::raw_vec::RawVec","ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Concat","ast::Flags","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"hir::translate::TranslatorBuilder":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::build":["hir::translate::Flags","hir::translate::Translator","hir::translate::TranslatorBuilder","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::case_insensitive":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::crlf":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::dot_matches_new_line":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::multi_line":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::new":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::swap_greed":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::unicode":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorBuilder::utf8":["hir::translate::Flags","hir::translate::TranslatorBuilder","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorI":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::TranslatorI::<'t, 'p>::ast_literal_to_scalar":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::ClassBytes","hir::interval::IntervalSet","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::case_fold_char":["ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::class_literal_byte":["ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Span","ast::SpecialLiteralKind","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error":["ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::error":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::Error","hir::ErrorKind","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::flags":["hir::translate::Flags","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorI::<'t, 'p>::hir_ascii_byte_class":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_ascii_unicode_class":["ast::ClassAscii","ast::ClassAsciiKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_assertion":["ast::Assertion","ast::AssertionKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_capture":["alloc::raw_vec::RawVec","ast::CaptureName","ast::Flags","ast::Group","ast::GroupKind","ast::Position","ast::Span","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::hir_dot":["ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class":["ast::ClassPerl","ast::ClassPerlKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"hir::translate::TranslatorI::<'t, 'p>::hir_repetition":["alloc::raw_vec::RawVec","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::Span","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class":["alloc::raw_vec::RawVec","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Position","ast::Span","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::new":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::TranslatorI::<'t, 'p>::pop":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorI::<'t, 'p>::pop_alt_expr":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorI::<'t, 'p>::pop_concat_expr":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"hir::translate::TranslatorI::<'t, 'p>::push":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::translate::Flags","hir::translate::HirFrame","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::boxed::Box","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::push_byte":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::TranslatorI::<'t, 'p>::push_char":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::TranslatorI::<'t, 'p>::set_flags":["alloc::raw_vec::RawVec","ast::Flags","ast::Position","ast::Span","hir::translate::Flags","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::translate::TranslatorI::<'t, 'p>::trans":["hir::translate::Translator","hir::translate::TranslatorI","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate":["alloc::raw_vec::RawVec","ast::Position","ast::Span","hir::ClassUnicode","hir::interval::IntervalSet","hir::translate::Translator","hir::translate::TranslatorI","std::alloc::Allocator","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::translate::ascii_class":["ast::ClassAsciiKind"],"hir::translate::ascii_class_as_chars":["ast::ClassAsciiKind"],"hir::translate::hir_ascii_class_bytes":["alloc::raw_vec::RawVec","ast::ClassAsciiKind","hir::ClassBytes","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::Frame":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::visitor::Frame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::Frame::<'a>::child":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::visitor::Frame","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::HeapVisitor":["alloc::raw_vec::RawVec","hir::visitor::HeapVisitor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::HeapVisitor::<'a>::induct":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::HeapVisitor::<'a>::new":["alloc::raw_vec::RawVec","hir::visitor::HeapVisitor","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::HeapVisitor::<'a>::pop":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::visitor::Frame","hir::visitor::HeapVisitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"hir::visitor::HeapVisitor::<'a>::visit":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::print::Writer","hir::visitor::HeapVisitor","hir::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::visitor::Visitor::finish":["std::marker::Sized","std::result::Result"],"hir::visitor::Visitor::start":[],"hir::visitor::Visitor::visit_alternation_in":["std::marker::Sized","std::result::Result"],"hir::visitor::Visitor::visit_post":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::visitor::Visitor::visit_pre":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"hir::visitor::visit":["alloc::raw_vec::RawVec","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassUnicode","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::Properties","hir::Repetition","hir::interval::IntervalSet","hir::print::Writer","hir::visitor::Visitor","std::alloc::Allocator","std::boxed::Box","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec"],"is_escapeable_character":[],"is_meta_character":[],"is_word_byte":[],"is_word_character":[],"parser::Parser":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"parser::Parser::new":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell"],"parser::Parser::parse":["ast::parse::Parser","hir::translate::Translator","parser::Parser","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::result::Result"],"parser::ParserBuilder":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::build":["ast::parse::Parser","ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::Translator","hir::translate::TranslatorBuilder","parser::Parser","parser::ParserBuilder","std::cell::Cell","std::cell::RefCell","std::cell::UnsafeCell","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::case_insensitive":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::crlf":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::dot_matches_new_line":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::ignore_whitespace":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::multi_line":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::nest_limit":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::new":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::octal":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::swap_greed":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::unicode":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::ParserBuilder::utf8":["ast::parse::ParserBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder","std::marker::Sized","std::option::Option"],"parser::parse":["std::marker::Sized","std::result::Result"],"try_is_word_character":["std::marker::Sized","std::result::Result"],"unicode::CanonicalClassQuery":["unicode::CanonicalClassQuery"],"unicode::CaseFoldError":["unicode::CaseFoldError"],"unicode::ClassQuery":["unicode::ClassQuery"],"unicode::ClassQuery::<'a>::canonical_binary":["std::marker::Sized","std::result::Result","unicode::ClassQuery"],"unicode::ClassQuery::<'a>::canonicalize":["std::marker::Sized","std::result::Result","unicode::ClassQuery"],"unicode::Error":["unicode::Error"],"unicode::SimpleCaseFolder":["std::marker::Sized","std::option::Option","unicode::SimpleCaseFolder"],"unicode::SimpleCaseFolder::get":["std::marker::Sized","std::option::Option","std::result::Result","unicode::SimpleCaseFolder"],"unicode::SimpleCaseFolder::mapping":["std::marker::Sized","std::option::Option","unicode::SimpleCaseFolder"],"unicode::SimpleCaseFolder::new":["std::marker::Sized","std::result::Result"],"unicode::SimpleCaseFolder::overlaps":["std::marker::Sized","std::option::Option","unicode::SimpleCaseFolder"],"unicode::UnicodeWordError":["unicode::UnicodeWordError"],"unicode::ages":["std::marker::Sized","std::result::Result"],"unicode::ages::imp":["std::marker::Sized","std::result::Result"],"unicode::bool_property":["std::marker::Sized","std::result::Result"],"unicode::bool_property::imp":["std::marker::Sized","std::result::Result"],"unicode::canonical_gencat":["std::marker::Sized","std::result::Result"],"unicode::canonical_prop":["std::marker::Sized","std::result::Result"],"unicode::canonical_prop::imp":["std::marker::Sized","std::result::Result"],"unicode::canonical_script":["std::marker::Sized","std::result::Result"],"unicode::canonical_value":["std::marker::Sized","std::option::Option"],"unicode::class":["std::marker::Sized","std::result::Result","unicode::ClassQuery"],"unicode::gcb":["std::marker::Sized","std::result::Result"],"unicode::gcb::imp":["std::marker::Sized","std::result::Result"],"unicode::gencat":["std::marker::Sized","std::result::Result"],"unicode::gencat::imp":["std::marker::Sized","std::result::Result"],"unicode::hir_class":["alloc::raw_vec::RawVec","hir::ClassUnicode","hir::interval::IntervalSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec"],"unicode::is_word_character":["std::marker::Sized","std::result::Result"],"unicode::is_word_character::imp":["std::marker::Sized","std::result::Result"],"unicode::perl_digit":["std::marker::Sized","std::result::Result"],"unicode::perl_digit::imp":["std::marker::Sized","std::result::Result"],"unicode::perl_space":["std::marker::Sized","std::result::Result"],"unicode::perl_space::imp":["std::marker::Sized","std::result::Result"],"unicode::perl_word":["std::marker::Sized","std::result::Result"],"unicode::perl_word::imp":["std::marker::Sized","std::result::Result"],"unicode::property_set":["std::marker::Sized","std::option::Option"],"unicode::property_values":["std::marker::Sized","std::result::Result"],"unicode::property_values::imp":["std::marker::Sized","std::result::Result"],"unicode::sb":["std::marker::Sized","std::result::Result"],"unicode::sb::imp":["std::marker::Sized","std::result::Result"],"unicode::script":["std::marker::Sized","std::result::Result"],"unicode::script::imp":["std::marker::Sized","std::result::Result"],"unicode::script_extension":["std::marker::Sized","std::result::Result"],"unicode::script_extension::imp":["std::marker::Sized","std::result::Result"],"unicode::symbolic_name_normalize":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"unicode::symbolic_name_normalize_bytes":[],"unicode::wb":["std::marker::Sized","std::result::Result"],"unicode::wb::imp":["std::marker::Sized","std::result::Result"],"utf8::ScalarRange":["utf8::ScalarRange"],"utf8::ScalarRange::as_ascii":["std::marker::Sized","std::option::Option","utf8::ScalarRange"],"utf8::ScalarRange::encode":["utf8::ScalarRange"],"utf8::ScalarRange::is_ascii":["utf8::ScalarRange"],"utf8::ScalarRange::is_valid":["utf8::ScalarRange"],"utf8::ScalarRange::split":["std::marker::Sized","std::option::Option","utf8::ScalarRange"],"utf8::Utf8Range":["utf8::Utf8Range"],"utf8::Utf8Range::matches":["utf8::Utf8Range"],"utf8::Utf8Range::new":["utf8::Utf8Range"],"utf8::Utf8Sequence":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::as_slice":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::from_encoded_range":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::len":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::matches":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequence::reverse":["utf8::Utf8Range","utf8::Utf8Sequence"],"utf8::Utf8Sequences":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"utf8::Utf8Sequences::new":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"utf8::Utf8Sequences::push":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"utf8::Utf8Sequences::reset":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","utf8::Utf8Sequences"],"utf8::max_scalar_value":[]},"glob_path_import":{},"self_to_fn":{"ast::Alternation":["Clone","Debug","Eq","PartialEq","impl Alternation {\n    /// Return this alternation as an AST.\n    ///\n    /// If this alternation contains zero ASTs, then Ast::Empty is\n    /// returned. If this alternation contains exactly 1 AST, then the\n    /// corresponding AST is returned. Otherwise, Ast::Alternation is returned.\n    pub fn into_ast(mut self) -> Ast {\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Alternation(self),\n        }\n    }\n}"],"ast::Assertion":["Clone","Debug","Eq","PartialEq"],"ast::AssertionKind":["Clone","Debug","Eq","PartialEq"],"ast::Ast":["Clone","Debug","Eq","PartialEq","impl Ast {\n    /// Return the span of this abstract syntax tree.\n    pub fn span(&self) -> &Span {\n        match *self {\n            Ast::Empty(ref span) => span,\n            Ast::Flags(ref x) => &x.span,\n            Ast::Literal(ref x) => &x.span,\n            Ast::Dot(ref span) => span,\n            Ast::Assertion(ref x) => &x.span,\n            Ast::Class(ref x) => x.span(),\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        }\n    }\n\n    /// Return true if and only if this Ast is empty.\n    pub fn is_empty(&self) -> bool {\n        match *self {\n            Ast::Empty(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Returns true if and only if this AST has any (including possibly empty)\n    /// subexpressions.\n    fn has_subexprs(&self) -> bool {\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_) => false,\n            Ast::Class(_)\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => true,\n        }\n    }\n}","impl Drop for Ast {\n    fn drop(&mut self) {\n        use core::mem;\n\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            // Classes are recursive, so they get their own Drop impl.\n            | Ast::Class(_) => return,\n            Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Group(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Alternation(ref x) if x.asts.is_empty() => return,\n            Ast::Concat(ref x) if x.asts.is_empty() => return,\n            _ => {}\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_ast = || Ast::Empty(empty_span());\n        let mut stack = vec![mem::replace(self, empty_ast())];\n        while let Some(mut ast) = stack.pop() {\n            match ast {\n                Ast::Empty(_)\n                | Ast::Flags(_)\n                | Ast::Literal(_)\n                | Ast::Dot(_)\n                | Ast::Assertion(_)\n                // Classes are recursive, so they get their own Drop impl.\n                | Ast::Class(_) => {}\n                Ast::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Group(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Alternation(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n                Ast::Concat(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n            }\n        }\n    }\n}","impl core::fmt::Display for Ast {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        use crate::ast::print::Printer;\n        Printer::new().print(self, f)\n    }\n}"],"ast::CaptureName":["Clone","Debug","Eq","PartialEq"],"ast::Class":["Clone","Debug","Eq","PartialEq","impl Class {\n    /// Return the span of this character class.\n    pub fn span(&self) -> &Span {\n        match *self {\n            Class::Perl(ref x) => &x.span,\n            Class::Unicode(ref x) => &x.span,\n            Class::Bracketed(ref x) => &x.span,\n        }\n    }\n}"],"ast::ClassAscii":["Clone","Debug","Eq","PartialEq"],"ast::ClassAsciiKind":["Clone","Debug","Eq","PartialEq","impl ClassAsciiKind {\n    /// Return the corresponding ClassAsciiKind variant for the given name.\n    ///\n    /// The name given should correspond to the lowercase version of the\n    /// variant name. e.g., `cntrl` is the name for `ClassAsciiKind::Cntrl`.\n    ///\n    /// If no variant with the corresponding name exists, then `None` is\n    /// returned.\n    pub fn from_name(name: &str) -> Option<ClassAsciiKind> {\n        use self::ClassAsciiKind::*;\n        match name {\n            \"alnum\" => Some(Alnum),\n            \"alpha\" => Some(Alpha),\n            \"ascii\" => Some(Ascii),\n            \"blank\" => Some(Blank),\n            \"cntrl\" => Some(Cntrl),\n            \"digit\" => Some(Digit),\n            \"graph\" => Some(Graph),\n            \"lower\" => Some(Lower),\n            \"print\" => Some(Print),\n            \"punct\" => Some(Punct),\n            \"space\" => Some(Space),\n            \"upper\" => Some(Upper),\n            \"word\" => Some(Word),\n            \"xdigit\" => Some(Xdigit),\n            _ => None,\n        }\n    }\n}"],"ast::ClassBracketed":["Clone","Debug","Eq","PartialEq"],"ast::ClassPerl":["Clone","Debug","Eq","PartialEq"],"ast::ClassPerlKind":["Clone","Debug","Eq","PartialEq"],"ast::ClassSet":["Clone","Debug","Eq","PartialEq","impl ClassSet {\n    /// Build a set from a union.\n    pub fn union(ast: ClassSetUnion) -> ClassSet {\n        ClassSet::Item(ClassSetItem::Union(ast))\n    }\n\n    /// Return the span of this character class set.\n    pub fn span(&self) -> &Span {\n        match *self {\n            ClassSet::Item(ref x) => x.span(),\n            ClassSet::BinaryOp(ref x) => &x.span,\n        }\n    }\n\n    /// Return true if and only if this class set is empty.\n    fn is_empty(&self) -> bool {\n        match *self {\n            ClassSet::Item(ClassSetItem::Empty(_)) => true,\n            _ => false,\n        }\n    }\n}","impl Drop for ClassSet {\n    fn drop(&mut self) {\n        use core::mem;\n\n        match *self {\n            ClassSet::Item(ref item) => match *item {\n                ClassSetItem::Empty(_)\n                | ClassSetItem::Literal(_)\n                | ClassSetItem::Range(_)\n                | ClassSetItem::Ascii(_)\n                | ClassSetItem::Unicode(_)\n                | ClassSetItem::Perl(_) => return,\n                ClassSetItem::Bracketed(ref x) => {\n                    if x.kind.is_empty() {\n                        return;\n                    }\n                }\n                ClassSetItem::Union(ref x) => {\n                    if x.items.is_empty() {\n                        return;\n                    }\n                }\n            },\n            ClassSet::BinaryOp(ref op) => {\n                if op.lhs.is_empty() && op.rhs.is_empty() {\n                    return;\n                }\n            }\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));\n        let mut stack = vec![mem::replace(self, empty_set())];\n        while let Some(mut set) = stack.pop() {\n            match set {\n                ClassSet::Item(ref mut item) => match *item {\n                    ClassSetItem::Empty(_)\n                    | ClassSetItem::Literal(_)\n                    | ClassSetItem::Range(_)\n                    | ClassSetItem::Ascii(_)\n                    | ClassSetItem::Unicode(_)\n                    | ClassSetItem::Perl(_) => {}\n                    ClassSetItem::Bracketed(ref mut x) => {\n                        stack.push(mem::replace(&mut x.kind, empty_set()));\n                    }\n                    ClassSetItem::Union(ref mut x) => {\n                        stack.extend(x.items.drain(..).map(ClassSet::Item));\n                    }\n                },\n                ClassSet::BinaryOp(ref mut op) => {\n                    stack.push(mem::replace(&mut op.lhs, empty_set()));\n                    stack.push(mem::replace(&mut op.rhs, empty_set()));\n                }\n            }\n        }\n    }\n}"],"ast::ClassSetBinaryOp":["Clone","Debug","Eq","PartialEq"],"ast::ClassSetBinaryOpKind":["Clone","Copy","Debug","Eq","PartialEq"],"ast::ClassSetItem":["Clone","Debug","Eq","PartialEq","impl ClassSetItem {\n    /// Return the span of this character class set item.\n    pub fn span(&self) -> &Span {\n        match *self {\n            ClassSetItem::Empty(ref span) => span,\n            ClassSetItem::Literal(ref x) => &x.span,\n            ClassSetItem::Range(ref x) => &x.span,\n            ClassSetItem::Ascii(ref x) => &x.span,\n            ClassSetItem::Perl(ref x) => &x.span,\n            ClassSetItem::Unicode(ref x) => &x.span,\n            ClassSetItem::Bracketed(ref x) => &x.span,\n            ClassSetItem::Union(ref x) => &x.span,\n        }\n    }\n}"],"ast::ClassSetRange":["Clone","Debug","Eq","PartialEq","impl ClassSetRange {\n    /// Returns true if and only if this character class range is valid.\n    ///\n    /// The only case where a range is invalid is if its start is greater than\n    /// its end.\n    pub fn is_valid(&self) -> bool {\n        self.start.c <= self.end.c\n    }\n}"],"ast::ClassSetUnion":["Clone","Debug","Eq","PartialEq","impl ClassSetUnion {\n    /// Push a new item in this union.\n    ///\n    /// The ending position of this union's span is updated to the ending\n    /// position of the span of the item given. If the union is empty, then\n    /// the starting position of this union is set to the starting position\n    /// of this item.\n    ///\n    /// In other words, if you only use this method to add items to a union\n    /// and you set the spans on each item correctly, then you should never\n    /// need to adjust the span of the union directly.\n    pub fn push(&mut self, item: ClassSetItem) {\n        if self.items.is_empty() {\n            self.span.start = item.span().start;\n        }\n        self.span.end = item.span().end;\n        self.items.push(item);\n    }\n\n    /// Return this union as a character class set item.\n    ///\n    /// If this union contains zero items, then an empty union is\n    /// returned. If this concatenation contains exactly 1 item, then the\n    /// corresponding item is returned. Otherwise, ClassSetItem::Union is\n    /// returned.\n    pub fn into_item(mut self) -> ClassSetItem {\n        match self.items.len() {\n            0 => ClassSetItem::Empty(self.span),\n            1 => self.items.pop().unwrap(),\n            _ => ClassSetItem::Union(self),\n        }\n    }\n}"],"ast::ClassUnicode":["Clone","Debug","Eq","PartialEq","impl ClassUnicode {\n    /// Returns true if this class has been negated.\n    ///\n    /// Note that this takes the Unicode op into account, if it's present.\n    /// e.g., `is_negated` for `\\P{scx!=Katakana}` will return `false`.\n    pub fn is_negated(&self) -> bool {\n        match self.kind {\n            ClassUnicodeKind::NamedValue {\n                op: ClassUnicodeOpKind::NotEqual,\n                ..\n            } => !self.negated,\n            _ => self.negated,\n        }\n    }\n}"],"ast::ClassUnicodeKind":["Clone","Debug","Eq","PartialEq"],"ast::ClassUnicodeOpKind":["Clone","Debug","Eq","PartialEq","impl ClassUnicodeOpKind {\n    /// Whether the op is an equality op or not.\n    pub fn is_equal(&self) -> bool {\n        match *self {\n            ClassUnicodeOpKind::Equal | ClassUnicodeOpKind::Colon => true,\n            _ => false,\n        }\n    }\n}"],"ast::Comment":["Clone","Debug","Eq","PartialEq"],"ast::Concat":["Clone","Debug","Eq","PartialEq","impl Concat {\n    /// Return this concatenation as an AST.\n    ///\n    /// If this concatenation contains zero ASTs, then Ast::Empty is\n    /// returned. If this concatenation contains exactly 1 AST, then the\n    /// corresponding AST is returned. Otherwise, Ast::Concat is returned.\n    pub fn into_ast(mut self) -> Ast {\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Concat(self),\n        }\n    }\n}"],"ast::Error":["Clone","Debug","Eq","PartialEq","impl Error {\n    /// Return the type of this error.\n    pub fn kind(&self) -> &ErrorKind {\n        &self.kind\n    }\n\n    /// The original pattern string in which this error occurred.\n    ///\n    /// Every span reported by this error is reported in terms of this string.\n    pub fn pattern(&self) -> &str {\n        &self.pattern\n    }\n\n    /// Return the span at which this error occurred.\n    pub fn span(&self) -> &Span {\n        &self.span\n    }\n\n    /// Return an auxiliary span. This span exists only for some errors that\n    /// benefit from being able to point to two locations in the original\n    /// regular expression. For example, \"duplicate\" errors will have the\n    /// main error position set to the duplicate occurrence while its\n    /// auxiliary span will be set to the initial occurrence.\n    pub fn auxiliary_span(&self) -> Option<&Span> {\n        use self::ErrorKind::*;\n        match self.kind {\n            FlagDuplicate { ref original } => Some(original),\n            FlagRepeatedNegation { ref original, .. } => Some(original),\n            GroupNameDuplicate { ref original, .. } => Some(original),\n            _ => None,\n        }\n    }\n}","impl core::fmt::Display for Error {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        crate::error::Formatter::from(self).fmt(f)\n    }\n}","impl std::error::Error for Error {}"],"ast::ErrorKind":["Clone","Debug","Eq","PartialEq","impl core::fmt::Display for ErrorKind {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        use self::ErrorKind::*;\n        match *self {\n            CaptureLimitExceeded => write!(\n                f,\n                \"exceeded the maximum number of \\\n                 capturing groups ({})\",\n                u32::MAX\n            ),\n            ClassEscapeInvalid => {\n                write!(f, \"invalid escape sequence found in character class\")\n            }\n            ClassRangeInvalid => write!(\n                f,\n                \"invalid character class range, \\\n                 the start must be <= the end\"\n            ),\n            ClassRangeLiteral => {\n                write!(f, \"invalid range boundary, must be a literal\")\n            }\n            ClassUnclosed => write!(f, \"unclosed character class\"),\n            DecimalEmpty => write!(f, \"decimal literal empty\"),\n            DecimalInvalid => write!(f, \"decimal literal invalid\"),\n            EscapeHexEmpty => write!(f, \"hexadecimal literal empty\"),\n            EscapeHexInvalid => {\n                write!(f, \"hexadecimal literal is not a Unicode scalar value\")\n            }\n            EscapeHexInvalidDigit => write!(f, \"invalid hexadecimal digit\"),\n            EscapeUnexpectedEof => write!(\n                f,\n                \"incomplete escape sequence, \\\n                 reached end of pattern prematurely\"\n            ),\n            EscapeUnrecognized => write!(f, \"unrecognized escape sequence\"),\n            FlagDanglingNegation => {\n                write!(f, \"dangling flag negation operator\")\n            }\n            FlagDuplicate { .. } => write!(f, \"duplicate flag\"),\n            FlagRepeatedNegation { .. } => {\n                write!(f, \"flag negation operator repeated\")\n            }\n            FlagUnexpectedEof => {\n                write!(f, \"expected flag but got end of regex\")\n            }\n            FlagUnrecognized => write!(f, \"unrecognized flag\"),\n            GroupNameDuplicate { .. } => {\n                write!(f, \"duplicate capture group name\")\n            }\n            GroupNameEmpty => write!(f, \"empty capture group name\"),\n            GroupNameInvalid => write!(f, \"invalid capture group character\"),\n            GroupNameUnexpectedEof => write!(f, \"unclosed capture group name\"),\n            GroupUnclosed => write!(f, \"unclosed group\"),\n            GroupUnopened => write!(f, \"unopened group\"),\n            NestLimitExceeded(limit) => write!(\n                f,\n                \"exceed the maximum number of \\\n                 nested parentheses/brackets ({})\",\n                limit\n            ),\n            RepetitionCountInvalid => write!(\n                f,\n                \"invalid repetition count range, \\\n                 the start must be <= the end\"\n            ),\n            RepetitionCountDecimalEmpty => {\n                write!(f, \"repetition quantifier expects a valid decimal\")\n            }\n            RepetitionCountUnclosed => {\n                write!(f, \"unclosed counted repetition\")\n            }\n            RepetitionMissing => {\n                write!(f, \"repetition operator missing expression\")\n            }\n            UnicodeClassInvalid => {\n                write!(f, \"invalid Unicode character class\")\n            }\n            UnsupportedBackreference => {\n                write!(f, \"backreferences are not supported\")\n            }\n            UnsupportedLookAround => write!(\n                f,\n                \"look-around, including look-ahead and look-behind, \\\n                 is not supported\"\n            ),\n        }\n    }\n}"],"ast::Flag":["Clone","Copy","Debug","Eq","PartialEq"],"ast::Flags":["Clone","Debug","Eq","PartialEq","impl Flags {\n    /// Add the given item to this sequence of flags.\n    ///\n    /// If the item was added successfully, then `None` is returned. If the\n    /// given item is a duplicate, then `Some(i)` is returned, where\n    /// `items[i].kind == item.kind`.\n    pub fn add_item(&mut self, item: FlagsItem) -> Option<usize> {\n        for (i, x) in self.items.iter().enumerate() {\n            if x.kind == item.kind {\n                return Some(i);\n            }\n        }\n        self.items.push(item);\n        None\n    }\n\n    /// Returns the state of the given flag in this set.\n    ///\n    /// If the given flag is in the set but is negated, then `Some(false)` is\n    /// returned.\n    ///\n    /// If the given flag is in the set and is not negated, then `Some(true)`\n    /// is returned.\n    ///\n    /// Otherwise, `None` is returned.\n    pub fn flag_state(&self, flag: Flag) -> Option<bool> {\n        let mut negated = false;\n        for x in &self.items {\n            match x.kind {\n                FlagsItemKind::Negation => {\n                    negated = true;\n                }\n                FlagsItemKind::Flag(ref xflag) if xflag == &flag => {\n                    return Some(!negated);\n                }\n                _ => {}\n            }\n        }\n        None\n    }\n}"],"ast::FlagsItem":["Clone","Debug","Eq","PartialEq"],"ast::FlagsItemKind":["Clone","Debug","Eq","PartialEq","impl FlagsItemKind {\n    /// Returns true if and only if this item is a negation operator.\n    pub fn is_negation(&self) -> bool {\n        match *self {\n            FlagsItemKind::Negation => true,\n            _ => false,\n        }\n    }\n}"],"ast::Group":["Clone","Debug","Eq","PartialEq","impl Group {\n    /// If this group is non-capturing, then this returns the (possibly empty)\n    /// set of flags. Otherwise, `None` is returned.\n    pub fn flags(&self) -> Option<&Flags> {\n        match self.kind {\n            GroupKind::NonCapturing(ref flags) => Some(flags),\n            _ => None,\n        }\n    }\n\n    /// Returns true if and only if this group is capturing.\n    pub fn is_capturing(&self) -> bool {\n        match self.kind {\n            GroupKind::CaptureIndex(_) | GroupKind::CaptureName { .. } => true,\n            GroupKind::NonCapturing(_) => false,\n        }\n    }\n\n    /// Returns the capture index of this group, if this is a capturing group.\n    ///\n    /// This returns a capture index precisely when `is_capturing` is `true`.\n    pub fn capture_index(&self) -> Option<u32> {\n        match self.kind {\n            GroupKind::CaptureIndex(i) => Some(i),\n            GroupKind::CaptureName { ref name, .. } => Some(name.index),\n            GroupKind::NonCapturing(_) => None,\n        }\n    }\n}"],"ast::GroupKind":["Clone","Debug","Eq","PartialEq"],"ast::HexLiteralKind":["Clone","Debug","Eq","PartialEq","impl HexLiteralKind {\n    /// The number of digits that must be used with this literal form when\n    /// used without brackets. When used with brackets, there is no\n    /// restriction on the number of digits.\n    pub fn digits(&self) -> u32 {\n        match *self {\n            HexLiteralKind::X => 2,\n            HexLiteralKind::UnicodeShort => 4,\n            HexLiteralKind::UnicodeLong => 8,\n        }\n    }\n}"],"ast::Literal":["Clone","Debug","Eq","PartialEq","impl Literal {\n    /// If this literal was written as a `\\x` hex escape, then this returns\n    /// the corresponding byte value. Otherwise, this returns `None`.\n    pub fn byte(&self) -> Option<u8> {\n        match self.kind {\n            LiteralKind::HexFixed(HexLiteralKind::X) => {\n                u8::try_from(self.c).ok()\n            }\n            _ => None,\n        }\n    }\n}"],"ast::LiteralKind":["Clone","Debug","Eq","PartialEq"],"ast::Position":["Clone","Copy","Eq","PartialEq","impl Ord for Position {\n    fn cmp(&self, other: &Position) -> Ordering {\n        self.offset.cmp(&other.offset)\n    }\n}","impl PartialOrd for Position {\n    fn partial_cmp(&self, other: &Position) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl Position {\n    /// Create a new position with the given information.\n    ///\n    /// `offset` is the absolute offset of the position, starting at `0` from\n    /// the beginning of the regular expression pattern string.\n    ///\n    /// `line` is the line number, starting at `1`.\n    ///\n    /// `column` is the approximate column number, starting at `1`.\n    pub fn new(offset: usize, line: usize, column: usize) -> Position {\n        Position { offset, line, column }\n    }\n}","impl core::fmt::Debug for Position {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"Position(o: {:?}, l: {:?}, c: {:?})\",\n            self.offset, self.line, self.column\n        )\n    }\n}"],"ast::Repetition":["Clone","Debug","Eq","PartialEq"],"ast::RepetitionKind":["Clone","Debug","Eq","PartialEq"],"ast::RepetitionOp":["Clone","Debug","Eq","PartialEq"],"ast::RepetitionRange":["Clone","Debug","Eq","PartialEq","impl RepetitionRange {\n    /// Returns true if and only if this repetition range is valid.\n    ///\n    /// The only case where a repetition range is invalid is if it is bounded\n    /// and its start is greater than its end.\n    pub fn is_valid(&self) -> bool {\n        match *self {\n            RepetitionRange::Bounded(s, e) if s > e => false,\n            _ => true,\n        }\n    }\n}"],"ast::SetFlags":["Clone","Debug","Eq","PartialEq"],"ast::Span":["Clone","Copy","Eq","PartialEq","impl Ord for Span {\n    fn cmp(&self, other: &Span) -> Ordering {\n        (&self.start, &self.end).cmp(&(&other.start, &other.end))\n    }\n}","impl PartialOrd for Span {\n    fn partial_cmp(&self, other: &Span) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl Span {\n    /// Create a new span with the given positions.\n    pub fn new(start: Position, end: Position) -> Span {\n        Span { start, end }\n    }\n\n    /// Create a new span using the given position as the start and end.\n    pub fn splat(pos: Position) -> Span {\n        Span::new(pos, pos)\n    }\n\n    /// Create a new span by replacing the starting the position with the one\n    /// given.\n    pub fn with_start(self, pos: Position) -> Span {\n        Span { start: pos, ..self }\n    }\n\n    /// Create a new span by replacing the ending the position with the one\n    /// given.\n    pub fn with_end(self, pos: Position) -> Span {\n        Span { end: pos, ..self }\n    }\n\n    /// Returns true if and only if this span occurs on a single line.\n    pub fn is_one_line(&self) -> bool {\n        self.start.line == self.end.line\n    }\n\n    /// Returns true if and only if this span is empty. That is, it points to\n    /// a single position in the concrete syntax of a regular expression.\n    pub fn is_empty(&self) -> bool {\n        self.start.offset == self.end.offset\n    }\n}","impl core::fmt::Debug for Span {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(f, \"Span({:?}, {:?})\", self.start, self.end)\n    }\n}"],"ast::SpecialLiteralKind":["Clone","Debug","Eq","PartialEq"],"ast::WithComments":["Clone","Debug","Eq","PartialEq"],"ast::parse::ClassState":["Clone","Debug"],"ast::parse::GroupState":["Clone","Debug"],"ast::parse::NestLimiter":["Debug","impl<'p, 's, P: Borrow<Parser>> NestLimiter<'p, 's, P> {\n    fn new(p: &'p ParserI<'s, P>) -> NestLimiter<'p, 's, P> {\n        NestLimiter { p, depth: 0 }\n    }\n\n    #[inline(never)]\n    fn check(self, ast: &Ast) -> Result<()> {\n        ast::visit(ast, self)\n    }\n\n    fn increment_depth(&mut self, span: &Span) -> Result<()> {\n        let new = self.depth.checked_add(1).ok_or_else(|| {\n            self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(u32::MAX),\n            )\n        })?;\n        let limit = self.p.parser().nest_limit;\n        if new > limit {\n            return Err(self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(limit),\n            ));\n        }\n        self.depth = new;\n        Ok(())\n    }\n\n    fn decrement_depth(&mut self) {\n        // Assuming the correctness of the visitor, this should never drop\n        // below 0.\n        self.depth = self.depth.checked_sub(1).unwrap();\n    }\n}","impl<'p, 's, P: Borrow<Parser>> ast::Visitor for NestLimiter<'p, 's, P> {\n    type Output = ();\n    type Err = ast::Error;\n\n    fn finish(self) -> Result<()> {\n        Ok(())\n    }\n\n    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {\n        let span = match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            Ast::Class(ast::Class::Bracketed(ref x)) => &x.span,\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }\n\n    fn visit_post(&mut self, ast: &Ast) -> Result<()> {\n        match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            Ast::Class(ast::Class::Bracketed(_))\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }\n\n    fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        let span = match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            ast::ClassSetItem::Bracketed(ref x) => &x.span,\n            ast::ClassSetItem::Union(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }\n\n    fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            ast::ClassSetItem::Bracketed(_) | ast::ClassSetItem::Union(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }\n\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        self.increment_depth(&ast.span)\n    }\n\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        self.decrement_depth();\n        Ok(())\n    }\n}"],"ast::parse::Parser":["Clone","Debug","impl Parser {\n    /// Create a new parser with a default configuration.\n    ///\n    /// The parser can be run with either the `parse` or `parse_with_comments`\n    /// methods. The parse methods return an abstract syntax tree.\n    ///\n    /// To set configuration options on the parser, use [`ParserBuilder`].\n    pub fn new() -> Parser {\n        ParserBuilder::new().build()\n    }\n\n    /// Parse the regular expression into an abstract syntax tree.\n    pub fn parse(&mut self, pattern: &str) -> Result<Ast> {\n        ParserI::new(self, pattern).parse()\n    }\n\n    /// Parse the regular expression and return an abstract syntax tree with\n    /// all of the comments found in the pattern.\n    pub fn parse_with_comments(\n        &mut self,\n        pattern: &str,\n    ) -> Result<ast::WithComments> {\n        ParserI::new(self, pattern).parse_with_comments()\n    }\n\n    /// Reset the internal state of a parser.\n    ///\n    /// This is called at the beginning of every parse. This prevents the\n    /// parser from running with inconsistent state (say, if a previous\n    /// invocation returned an error and the parser is reused).\n    fn reset(&self) {\n        // These settings should be in line with the construction\n        // in `ParserBuilder::build`.\n        self.pos.set(Position { offset: 0, line: 1, column: 1 });\n        self.ignore_whitespace.set(self.initial_ignore_whitespace);\n        self.comments.borrow_mut().clear();\n        self.stack_group.borrow_mut().clear();\n        self.stack_class.borrow_mut().clear();\n    }\n}"],"ast::parse::ParserBuilder":["Clone","Debug","impl Default for ParserBuilder {\n    fn default() -> ParserBuilder {\n        ParserBuilder::new()\n    }\n}","impl ParserBuilder {\n    /// Create a new parser builder with a default configuration.\n    pub fn new() -> ParserBuilder {\n        ParserBuilder {\n            ignore_whitespace: false,\n            nest_limit: 250,\n            octal: false,\n        }\n    }\n\n    /// Build a parser from this configuration with the given pattern.\n    pub fn build(&self) -> Parser {\n        Parser {\n            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),\n            capture_index: Cell::new(0),\n            nest_limit: self.nest_limit,\n            octal: self.octal,\n            initial_ignore_whitespace: self.ignore_whitespace,\n            ignore_whitespace: Cell::new(self.ignore_whitespace),\n            comments: RefCell::new(vec![]),\n            stack_group: RefCell::new(vec![]),\n            stack_class: RefCell::new(vec![]),\n            capture_names: RefCell::new(vec![]),\n            scratch: RefCell::new(String::new()),\n        }\n    }\n\n    /// Set the nesting limit for this parser.\n    ///\n    /// The nesting limit controls how deep the abstract syntax tree is allowed\n    /// to be. If the AST exceeds the given limit (e.g., with too many nested\n    /// groups), then an error is returned by the parser.\n    ///\n    /// The purpose of this limit is to act as a heuristic to prevent stack\n    /// overflow for consumers that do structural induction on an `Ast` using\n    /// explicit recursion. While this crate never does this (instead using\n    /// constant stack space and moving the call stack to the heap), other\n    /// crates may.\n    ///\n    /// This limit is not checked until the entire AST is parsed. Therefore,\n    /// if callers want to put a limit on the amount of heap space used, then\n    /// they should impose a limit on the length, in bytes, of the concrete\n    /// pattern string. In particular, this is viable since this parser\n    /// implementation will limit itself to heap space proportional to the\n    /// length of the pattern string.\n    ///\n    /// Note that a nest limit of `0` will return a nest limit error for most\n    /// patterns but not all. For example, a nest limit of `0` permits `a` but\n    /// not `ab`, since `ab` requires a concatenation, which results in a nest\n    /// depth of `1`. In general, a nest limit is not something that manifests\n    /// in an obvious way in the concrete syntax, therefore, it should not be\n    /// used in a granular way.\n    pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {\n        self.nest_limit = limit;\n        self\n    }\n\n    /// Whether to support octal syntax or not.\n    ///\n    /// Octal syntax is a little-known way of uttering Unicode codepoints in\n    /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n    /// `\\141` are all equivalent regular expressions, where the last example\n    /// shows octal syntax.\n    ///\n    /// While supporting octal syntax isn't in and of itself a problem, it does\n    /// make good error messages harder. That is, in PCRE based regex engines,\n    /// syntax like `\\0` invokes a backreference, which is explicitly\n    /// unsupported in Rust's regex engine. However, many users expect it to\n    /// be supported. Therefore, when octal support is disabled, the error\n    /// message will explicitly mention that backreferences aren't supported.\n    ///\n    /// Octal syntax is disabled by default.\n    pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.octal = yes;\n        self\n    }\n\n    /// Enable verbose mode in the regular expression.\n    ///\n    /// When enabled, verbose mode permits insignificant whitespace in many\n    /// places in the regular expression, as well as comments. Comments are\n    /// started using `#` and continue until the end of the line.\n    ///\n    /// By default, this is disabled. It may be selectively enabled in the\n    /// regular expression by using the `x` flag regardless of this setting.\n    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.ignore_whitespace = yes;\n        self\n    }\n}"],"ast::parse::ParserI":["Clone","Debug","impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n    /// Build an internal parser from a parser configuration and a pattern.\n    fn new(parser: P, pattern: &'s str) -> ParserI<'s, P> {\n        ParserI { parser, pattern }\n    }\n\n    /// Return a reference to the parser state.\n    fn parser(&self) -> &Parser {\n        self.parser.borrow()\n    }\n\n    /// Return a reference to the pattern being parsed.\n    fn pattern(&self) -> &str {\n        self.pattern.borrow()\n    }\n\n    /// Create a new error with the given span and error type.\n    fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {\n        ast::Error { kind, pattern: self.pattern().to_string(), span }\n    }\n\n    /// Return the current offset of the parser.\n    ///\n    /// The offset starts at `0` from the beginning of the regular expression\n    /// pattern string.\n    fn offset(&self) -> usize {\n        self.parser().pos.get().offset\n    }\n\n    /// Return the current line number of the parser.\n    ///\n    /// The line number starts at `1`.\n    fn line(&self) -> usize {\n        self.parser().pos.get().line\n    }\n\n    /// Return the current column of the parser.\n    ///\n    /// The column number starts at `1` and is reset whenever a `\\n` is seen.\n    fn column(&self) -> usize {\n        self.parser().pos.get().column\n    }\n\n    /// Return the next capturing index. Each subsequent call increments the\n    /// internal index.\n    ///\n    /// The span given should correspond to the location of the opening\n    /// parenthesis.\n    ///\n    /// If the capture limit is exceeded, then an error is returned.\n    fn next_capture_index(&self, span: Span) -> Result<u32> {\n        let current = self.parser().capture_index.get();\n        let i = current.checked_add(1).ok_or_else(|| {\n            self.error(span, ast::ErrorKind::CaptureLimitExceeded)\n        })?;\n        self.parser().capture_index.set(i);\n        Ok(i)\n    }\n\n    /// Adds the given capture name to this parser. If this capture name has\n    /// already been used, then an error is returned.\n    fn add_capture_name(&self, cap: &ast::CaptureName) -> Result<()> {\n        let mut names = self.parser().capture_names.borrow_mut();\n        match names\n            .binary_search_by_key(&cap.name.as_str(), |c| c.name.as_str())\n        {\n            Err(i) => {\n                names.insert(i, cap.clone());\n                Ok(())\n            }\n            Ok(i) => Err(self.error(\n                cap.span,\n                ast::ErrorKind::GroupNameDuplicate { original: names[i].span },\n            )),\n        }\n    }\n\n    /// Return whether the parser should ignore whitespace or not.\n    fn ignore_whitespace(&self) -> bool {\n        self.parser().ignore_whitespace.get()\n    }\n\n    /// Return the character at the current position of the parser.\n    ///\n    /// This panics if the current position does not point to a valid char.\n    fn char(&self) -> char {\n        self.char_at(self.offset())\n    }\n\n    /// Return the character at the given position.\n    ///\n    /// This panics if the given position does not point to a valid char.\n    fn char_at(&self, i: usize) -> char {\n        self.pattern()[i..]\n            .chars()\n            .next()\n            .unwrap_or_else(|| panic!(\"expected char at offset {}\", i))\n    }\n\n    /// Bump the parser to the next Unicode scalar value.\n    ///\n    /// If the end of the input has been reached, then `false` is returned.\n    fn bump(&self) -> bool {\n        if self.is_eof() {\n            return false;\n        }\n        let Position { mut offset, mut line, mut column } = self.pos();\n        if self.char() == '\\n' {\n            line = line.checked_add(1).unwrap();\n            column = 1;\n        } else {\n            column = column.checked_add(1).unwrap();\n        }\n        offset += self.char().len_utf8();\n        self.parser().pos.set(Position { offset, line, column });\n        self.pattern()[self.offset()..].chars().next().is_some()\n    }\n\n    /// If the substring starting at the current position of the parser has\n    /// the given prefix, then bump the parser to the character immediately\n    /// following the prefix and return true. Otherwise, don't bump the parser\n    /// and return false.\n    fn bump_if(&self, prefix: &str) -> bool {\n        if self.pattern()[self.offset()..].starts_with(prefix) {\n            for _ in 0..prefix.chars().count() {\n                self.bump();\n            }\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Returns true if and only if the parser is positioned at a look-around\n    /// prefix. The conditions under which this returns true must always\n    /// correspond to a regular expression that would otherwise be consider\n    /// invalid.\n    ///\n    /// This should only be called immediately after parsing the opening of\n    /// a group or a set of flags.\n    fn is_lookaround_prefix(&self) -> bool {\n        self.bump_if(\"?=\")\n            || self.bump_if(\"?!\")\n            || self.bump_if(\"?<=\")\n            || self.bump_if(\"?<!\")\n    }\n\n    /// Bump the parser, and if the `x` flag is enabled, bump through any\n    /// subsequent spaces. Return true if and only if the parser is not at\n    /// EOF.\n    fn bump_and_bump_space(&self) -> bool {\n        if !self.bump() {\n            return false;\n        }\n        self.bump_space();\n        !self.is_eof()\n    }\n\n    /// If the `x` flag is enabled (i.e., whitespace insensitivity with\n    /// comments), then this will advance the parser through all whitespace\n    /// and comments to the next non-whitespace non-comment byte.\n    ///\n    /// If the `x` flag is disabled, then this is a no-op.\n    ///\n    /// This should be used selectively throughout the parser where\n    /// arbitrary whitespace is permitted when the `x` flag is enabled. For\n    /// example, `{   5  , 6}` is equivalent to `{5,6}`.\n    fn bump_space(&self) {\n        if !self.ignore_whitespace() {\n            return;\n        }\n        while !self.is_eof() {\n            if self.char().is_whitespace() {\n                self.bump();\n            } else if self.char() == '#' {\n                let start = self.pos();\n                let mut comment_text = String::new();\n                self.bump();\n                while !self.is_eof() {\n                    let c = self.char();\n                    self.bump();\n                    if c == '\\n' {\n                        break;\n                    }\n                    comment_text.push(c);\n                }\n                let comment = ast::Comment {\n                    span: Span::new(start, self.pos()),\n                    comment: comment_text,\n                };\n                self.parser().comments.borrow_mut().push(comment);\n            } else {\n                break;\n            }\n        }\n    }\n\n    /// Peek at the next character in the input without advancing the parser.\n    ///\n    /// If the input has been exhausted, then this returns `None`.\n    fn peek(&self) -> Option<char> {\n        if self.is_eof() {\n            return None;\n        }\n        self.pattern()[self.offset() + self.char().len_utf8()..].chars().next()\n    }\n\n    /// Like peek, but will ignore spaces when the parser is in whitespace\n    /// insensitive mode.\n    fn peek_space(&self) -> Option<char> {\n        if !self.ignore_whitespace() {\n            return self.peek();\n        }\n        if self.is_eof() {\n            return None;\n        }\n        let mut start = self.offset() + self.char().len_utf8();\n        let mut in_comment = false;\n        for (i, c) in self.pattern()[start..].char_indices() {\n            if c.is_whitespace() {\n                continue;\n            } else if !in_comment && c == '#' {\n                in_comment = true;\n            } else if in_comment && c == '\\n' {\n                in_comment = false;\n            } else {\n                start += i;\n                break;\n            }\n        }\n        self.pattern()[start..].chars().next()\n    }\n\n    /// Returns true if the next call to `bump` would return false.\n    fn is_eof(&self) -> bool {\n        self.offset() == self.pattern().len()\n    }\n\n    /// Return the current position of the parser, which includes the offset,\n    /// line and column.\n    fn pos(&self) -> Position {\n        self.parser().pos.get()\n    }\n\n    /// Create a span at the current position of the parser. Both the start\n    /// and end of the span are set.\n    fn span(&self) -> Span {\n        Span::splat(self.pos())\n    }\n\n    /// Create a span that covers the current character.\n    fn span_char(&self) -> Span {\n        let mut next = Position {\n            offset: self.offset().checked_add(self.char().len_utf8()).unwrap(),\n            line: self.line(),\n            column: self.column().checked_add(1).unwrap(),\n        };\n        if self.char() == '\\n' {\n            next.line += 1;\n            next.column = 1;\n        }\n        Span::new(self.pos(), next)\n    }\n\n    /// Parse and push a single alternation on to the parser's internal stack.\n    /// If the top of the stack already has an alternation, then add to that\n    /// instead of pushing a new one.\n    ///\n    /// The concatenation given corresponds to a single alternation branch.\n    /// The concatenation returned starts the next branch and is empty.\n    ///\n    /// This assumes the parser is currently positioned at `|` and will advance\n    /// the parser to the character following `|`.\n    #[inline(never)]\n    fn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat> {\n        assert_eq!(self.char(), '|');\n        concat.span.end = self.pos();\n        self.push_or_add_alternation(concat);\n        self.bump();\n        Ok(ast::Concat { span: self.span(), asts: vec![] })\n    }\n\n    /// Pushes or adds the given branch of an alternation to the parser's\n    /// internal stack of state.\n    fn push_or_add_alternation(&self, concat: ast::Concat) {\n        use self::GroupState::*;\n\n        let mut stack = self.parser().stack_group.borrow_mut();\n        if let Some(&mut Alternation(ref mut alts)) = stack.last_mut() {\n            alts.asts.push(concat.into_ast());\n            return;\n        }\n        stack.push(Alternation(ast::Alternation {\n            span: Span::new(concat.span.start, self.pos()),\n            asts: vec![concat.into_ast()],\n        }));\n    }\n\n    /// Parse and push a group AST (and its parent concatenation) on to the\n    /// parser's internal stack. Return a fresh concatenation corresponding\n    /// to the group's sub-AST.\n    ///\n    /// If a set of flags was found (with no group), then the concatenation\n    /// is returned with that set of flags added.\n    ///\n    /// This assumes that the parser is currently positioned on the opening\n    /// parenthesis. It advances the parser to the character at the start\n    /// of the sub-expression (or adjoining expression).\n    ///\n    /// If there was a problem parsing the start of the group, then an error\n    /// is returned.\n    #[inline(never)]\n    fn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat> {\n        assert_eq!(self.char(), '(');\n        match self.parse_group()? {\n            Either::Left(set) => {\n                let ignore = set.flags.flag_state(ast::Flag::IgnoreWhitespace);\n                if let Some(v) = ignore {\n                    self.parser().ignore_whitespace.set(v);\n                }\n\n                concat.asts.push(Ast::Flags(set));\n                Ok(concat)\n            }\n            Either::Right(group) => {\n                let old_ignore_whitespace = self.ignore_whitespace();\n                let new_ignore_whitespace = group\n                    .flags()\n                    .and_then(|f| f.flag_state(ast::Flag::IgnoreWhitespace))\n                    .unwrap_or(old_ignore_whitespace);\n                self.parser().stack_group.borrow_mut().push(\n                    GroupState::Group {\n                        concat,\n                        group,\n                        ignore_whitespace: old_ignore_whitespace,\n                    },\n                );\n                self.parser().ignore_whitespace.set(new_ignore_whitespace);\n                Ok(ast::Concat { span: self.span(), asts: vec![] })\n            }\n        }\n    }\n\n    /// Pop a group AST from the parser's internal stack and set the group's\n    /// AST to the given concatenation. Return the concatenation containing\n    /// the group.\n    ///\n    /// This assumes that the parser is currently positioned on the closing\n    /// parenthesis and advances the parser to the character following the `)`.\n    ///\n    /// If no such group could be popped, then an unopened group error is\n    /// returned.\n    #[inline(never)]\n    fn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat> {\n        use self::GroupState::*;\n\n        assert_eq!(self.char(), ')');\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let (mut prior_concat, mut group, ignore_whitespace, alt) = match stack\n            .pop()\n        {\n            Some(Group { concat, group, ignore_whitespace }) => {\n                (concat, group, ignore_whitespace, None)\n            }\n            Some(Alternation(alt)) => match stack.pop() {\n                Some(Group { concat, group, ignore_whitespace }) => {\n                    (concat, group, ignore_whitespace, Some(alt))\n                }\n                None | Some(Alternation(_)) => {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::GroupUnopened,\n                    ));\n                }\n            },\n            None => {\n                return Err(self\n                    .error(self.span_char(), ast::ErrorKind::GroupUnopened));\n            }\n        };\n        self.parser().ignore_whitespace.set(ignore_whitespace);\n        group_concat.span.end = self.pos();\n        self.bump();\n        group.span.end = self.pos();\n        match alt {\n            Some(mut alt) => {\n                alt.span.end = group_concat.span.end;\n                alt.asts.push(group_concat.into_ast());\n                group.ast = Box::new(alt.into_ast());\n            }\n            None => {\n                group.ast = Box::new(group_concat.into_ast());\n            }\n        }\n        prior_concat.asts.push(Ast::Group(group));\n        Ok(prior_concat)\n    }\n\n    /// Pop the last state from the parser's internal stack, if it exists, and\n    /// add the given concatenation to it. There either must be no state or a\n    /// single alternation item on the stack. Any other scenario produces an\n    /// error.\n    ///\n    /// This assumes that the parser has advanced to the end.\n    #[inline(never)]\n    fn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast> {\n        concat.span.end = self.pos();\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let ast = match stack.pop() {\n            None => Ok(concat.into_ast()),\n            Some(GroupState::Alternation(mut alt)) => {\n                alt.span.end = self.pos();\n                alt.asts.push(concat.into_ast());\n                Ok(Ast::Alternation(alt))\n            }\n            Some(GroupState::Group { group, .. }) => {\n                return Err(\n                    self.error(group.span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n        };\n        // If we try to pop again, there should be nothing.\n        match stack.pop() {\n            None => ast,\n            Some(GroupState::Alternation(_)) => {\n                // This unreachable is unfortunate. This case can't happen\n                // because the only way we can be here is if there were two\n                // `GroupState::Alternation`s adjacent in the parser's stack,\n                // which we guarantee to never happen because we never push a\n                // `GroupState::Alternation` if one is already at the top of\n                // the stack.\n                unreachable!()\n            }\n            Some(GroupState::Group { group, .. }) => {\n                Err(self.error(group.span, ast::ErrorKind::GroupUnclosed))\n            }\n        }\n    }\n\n    /// Parse the opening of a character class and push the current class\n    /// parsing context onto the parser's stack. This assumes that the parser\n    /// is positioned at an opening `[`. The given union should correspond to\n    /// the union of set items built up before seeing the `[`.\n    ///\n    /// If there was a problem parsing the opening of the class, then an error\n    /// is returned. Otherwise, a new union of set items for the class is\n    /// returned (which may be populated with either a `]` or a `-`).\n    #[inline(never)]\n    fn push_class_open(\n        &self,\n        parent_union: ast::ClassSetUnion,\n    ) -> Result<ast::ClassSetUnion> {\n        assert_eq!(self.char(), '[');\n\n        let (nested_set, nested_union) = self.parse_set_class_open()?;\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Open { union: parent_union, set: nested_set });\n        Ok(nested_union)\n    }\n\n    /// Parse the end of a character class set and pop the character class\n    /// parser stack. The union given corresponds to the last union built\n    /// before seeing the closing `]`. The union returned corresponds to the\n    /// parent character class set with the nested class added to it.\n    ///\n    /// This assumes that the parser is positioned at a `]` and will advance\n    /// the parser to the byte immediately following the `]`.\n    ///\n    /// If the stack is empty after popping, then this returns the final\n    /// \"top-level\" character class AST (where a \"top-level\" character class\n    /// is one that is not nested inside any other character class).\n    ///\n    /// If there is no corresponding opening bracket on the parser's stack,\n    /// then an error is returned.\n    #[inline(never)]\n    fn pop_class(\n        &self,\n        nested_union: ast::ClassSetUnion,\n    ) -> Result<Either<ast::ClassSetUnion, ast::Class>> {\n        assert_eq!(self.char(), ']');\n\n        let item = ast::ClassSet::Item(nested_union.into_item());\n        let prevset = self.pop_class_op(item);\n        let mut stack = self.parser().stack_class.borrow_mut();\n        match stack.pop() {\n            None => {\n                // We can never observe an empty stack:\n                //\n                // 1) We are guaranteed to start with a non-empty stack since\n                //    the character class parser is only initiated when it sees\n                //    a `[`.\n                // 2) If we ever observe an empty stack while popping after\n                //    seeing a `]`, then we signal the character class parser\n                //    to terminate.\n                panic!(\"unexpected empty character class stack\")\n            }\n            Some(ClassState::Op { .. }) => {\n                // This panic is unfortunate, but this case is impossible\n                // since we already popped the Op state if one exists above.\n                // Namely, every push to the class parser stack is guarded by\n                // whether an existing Op is already on the top of the stack.\n                // If it is, the existing Op is modified. That is, the stack\n                // can never have consecutive Op states.\n                panic!(\"unexpected ClassState::Op\")\n            }\n            Some(ClassState::Open { mut union, mut set }) => {\n                self.bump();\n                set.span.end = self.pos();\n                set.kind = prevset;\n                if stack.is_empty() {\n                    Ok(Either::Right(ast::Class::Bracketed(set)))\n                } else {\n                    union.push(ast::ClassSetItem::Bracketed(Box::new(set)));\n                    Ok(Either::Left(union))\n                }\n            }\n        }\n    }\n\n    /// Return an \"unclosed class\" error whose span points to the most\n    /// recently opened class.\n    ///\n    /// This should only be called while parsing a character class.\n    #[inline(never)]\n    fn unclosed_class_error(&self) -> ast::Error {\n        for state in self.parser().stack_class.borrow().iter().rev() {\n            if let ClassState::Open { ref set, .. } = *state {\n                return self.error(set.span, ast::ErrorKind::ClassUnclosed);\n            }\n        }\n        // We are guaranteed to have a non-empty stack with at least\n        // one open bracket, so we should never get here.\n        panic!(\"no open character class found\")\n    }\n\n    /// Push the current set of class items on to the class parser's stack as\n    /// the left hand side of the given operator.\n    ///\n    /// A fresh set union is returned, which should be used to build the right\n    /// hand side of this operator.\n    #[inline(never)]\n    fn push_class_op(\n        &self,\n        next_kind: ast::ClassSetBinaryOpKind,\n        next_union: ast::ClassSetUnion,\n    ) -> ast::ClassSetUnion {\n        let item = ast::ClassSet::Item(next_union.into_item());\n        let new_lhs = self.pop_class_op(item);\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Op { kind: next_kind, lhs: new_lhs });\n        ast::ClassSetUnion { span: self.span(), items: vec![] }\n    }\n\n    /// Pop a character class set from the character class parser stack. If the\n    /// top of the stack is just an item (not an operation), then return the\n    /// given set unchanged. If the top of the stack is an operation, then the\n    /// given set will be used as the rhs of the operation on the top of the\n    /// stack. In that case, the binary operation is returned as a set.\n    #[inline(never)]\n    fn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet {\n        let mut stack = self.parser().stack_class.borrow_mut();\n        let (kind, lhs) = match stack.pop() {\n            Some(ClassState::Op { kind, lhs }) => (kind, lhs),\n            Some(state @ ClassState::Open { .. }) => {\n                stack.push(state);\n                return rhs;\n            }\n            None => unreachable!(),\n        };\n        let span = Span::new(lhs.span().start, rhs.span().end);\n        ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n            span,\n            kind,\n            lhs: Box::new(lhs),\n            rhs: Box::new(rhs),\n        })\n    }\n}","impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n    /// Parse the regular expression into an abstract syntax tree.\n    fn parse(&self) -> Result<Ast> {\n        self.parse_with_comments().map(|astc| astc.ast)\n    }\n\n    /// Parse the regular expression and return an abstract syntax tree with\n    /// all of the comments found in the pattern.\n    fn parse_with_comments(&self) -> Result<ast::WithComments> {\n        assert_eq!(self.offset(), 0, \"parser can only be used once\");\n        self.parser().reset();\n        let mut concat = ast::Concat { span: self.span(), asts: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                break;\n            }\n            match self.char() {\n                '(' => concat = self.push_group(concat)?,\n                ')' => concat = self.pop_group(concat)?,\n                '|' => concat = self.push_alternate(concat)?,\n                '[' => {\n                    let class = self.parse_set_class()?;\n                    concat.asts.push(Ast::Class(class));\n                }\n                '?' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrOne,\n                    )?;\n                }\n                '*' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrMore,\n                    )?;\n                }\n                '+' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::OneOrMore,\n                    )?;\n                }\n                '{' => {\n                    concat = self.parse_counted_repetition(concat)?;\n                }\n                _ => concat.asts.push(self.parse_primitive()?.into_ast()),\n            }\n        }\n        let ast = self.pop_group_end(concat)?;\n        NestLimiter::new(self).check(&ast)?;\n        Ok(ast::WithComments {\n            ast,\n            comments: mem::replace(\n                &mut *self.parser().comments.borrow_mut(),\n                vec![],\n            ),\n        })\n    }\n\n    /// Parses an uncounted repetition operation. An uncounted repetition\n    /// operator includes ?, * and +, but does not include the {m,n} syntax.\n    /// The given `kind` should correspond to the operator observed by the\n    /// caller.\n    ///\n    /// This assumes that the parser is currently positioned at the repetition\n    /// operator and advances the parser to the first character after the\n    /// operator. (Note that the operator may include a single additional `?`,\n    /// which makes the operator ungreedy.)\n    ///\n    /// The caller should include the concatenation that is being built. The\n    /// concatenation returned includes the repetition operator applied to the\n    /// last expression in the given concatenation.\n    #[inline(never)]\n    fn parse_uncounted_repetition(\n        &self,\n        mut concat: ast::Concat,\n        kind: ast::RepetitionKind,\n    ) -> Result<ast::Concat> {\n        assert!(\n            self.char() == '?' || self.char() == '*' || self.char() == '+'\n        );\n        let op_start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        let mut greedy = true;\n        if self.bump() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: Span::new(op_start, self.pos()),\n                kind,\n            },\n            greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }\n\n    /// Parses a counted repetition operation. A counted repetition operator\n    /// corresponds to the {m,n} syntax, and does not include the ?, * or +\n    /// operators.\n    ///\n    /// This assumes that the parser is currently positioned at the opening `{`\n    /// and advances the parser to the first character after the operator.\n    /// (Note that the operator may include a single additional `?`, which\n    /// makes the operator ungreedy.)\n    ///\n    /// The caller should include the concatenation that is being built. The\n    /// concatenation returned includes the repetition operator applied to the\n    /// last expression in the given concatenation.\n    #[inline(never)]\n    fn parse_counted_repetition(\n        &self,\n        mut concat: ast::Concat,\n    ) -> Result<ast::Concat> {\n        assert!(self.char() == '{');\n        let start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        let count_start = specialize_err(\n            self.parse_decimal(),\n            ast::ErrorKind::DecimalEmpty,\n            ast::ErrorKind::RepetitionCountDecimalEmpty,\n        )?;\n        let mut range = ast::RepetitionRange::Exactly(count_start);\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        if self.char() == ',' {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::RepetitionCountUnclosed,\n                ));\n            }\n            if self.char() != '}' {\n                let count_end = specialize_err(\n                    self.parse_decimal(),\n                    ast::ErrorKind::DecimalEmpty,\n                    ast::ErrorKind::RepetitionCountDecimalEmpty,\n                )?;\n                range = ast::RepetitionRange::Bounded(count_start, count_end);\n            } else {\n                range = ast::RepetitionRange::AtLeast(count_start);\n            }\n        }\n        if self.is_eof() || self.char() != '}' {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n\n        let mut greedy = true;\n        if self.bump_and_bump_space() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n\n        let op_span = Span::new(start, self.pos());\n        if !range.is_valid() {\n            return Err(\n                self.error(op_span, ast::ErrorKind::RepetitionCountInvalid)\n            );\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: op_span,\n                kind: ast::RepetitionKind::Range(range),\n            },\n            greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }\n\n    /// Parse a group (which contains a sub-expression) or a set of flags.\n    ///\n    /// If a group was found, then it is returned with an empty AST. If a set\n    /// of flags is found, then that set is returned.\n    ///\n    /// The parser should be positioned at the opening parenthesis.\n    ///\n    /// This advances the parser to the character before the start of the\n    /// sub-expression (in the case of a group) or to the closing parenthesis\n    /// immediately following the set of flags.\n    ///\n    /// # Errors\n    ///\n    /// If flags are given and incorrectly specified, then a corresponding\n    /// error is returned.\n    ///\n    /// If a capture name is given and it is incorrectly specified, then a\n    /// corresponding error is returned.\n    #[inline(never)]\n    fn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>> {\n        assert_eq!(self.char(), '(');\n        let open_span = self.span_char();\n        self.bump();\n        self.bump_space();\n        if self.is_lookaround_prefix() {\n            return Err(self.error(\n                Span::new(open_span.start, self.span().end),\n                ast::ErrorKind::UnsupportedLookAround,\n            ));\n        }\n        let inner_span = self.span();\n        let mut starts_with_p = true;\n        if self.bump_if(\"?P<\") || {\n            starts_with_p = false;\n            self.bump_if(\"?<\")\n        } {\n            let capture_index = self.next_capture_index(open_span)?;\n            let name = self.parse_capture_name(capture_index)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureName { starts_with_p, name },\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        } else if self.bump_if(\"?\") {\n            if self.is_eof() {\n                return Err(\n                    self.error(open_span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n            let flags = self.parse_flags()?;\n            let char_end = self.char();\n            self.bump();\n            if char_end == ')' {\n                // We don't allow empty flags, e.g., `(?)`. We instead\n                // interpret it as a repetition operator missing its argument.\n                if flags.items.is_empty() {\n                    return Err(self.error(\n                        inner_span,\n                        ast::ErrorKind::RepetitionMissing,\n                    ));\n                }\n                Ok(Either::Left(ast::SetFlags {\n                    span: Span { end: self.pos(), ..open_span },\n                    flags,\n                }))\n            } else {\n                assert_eq!(char_end, ':');\n                Ok(Either::Right(ast::Group {\n                    span: open_span,\n                    kind: ast::GroupKind::NonCapturing(flags),\n                    ast: Box::new(Ast::Empty(self.span())),\n                }))\n            }\n        } else {\n            let capture_index = self.next_capture_index(open_span)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureIndex(capture_index),\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        }\n    }\n\n    /// Parses a capture group name. Assumes that the parser is positioned at\n    /// the first character in the name following the opening `<` (and may\n    /// possibly be EOF). This advances the parser to the first character\n    /// following the closing `>`.\n    ///\n    /// The caller must provide the capture index of the group for this name.\n    #[inline(never)]\n    fn parse_capture_name(\n        &self,\n        capture_index: u32,\n    ) -> Result<ast::CaptureName> {\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        let start = self.pos();\n        loop {\n            if self.char() == '>' {\n                break;\n            }\n            if !is_capture_char(self.char(), self.pos() == start) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::GroupNameInvalid,\n                ));\n            }\n            if !self.bump() {\n                break;\n            }\n        }\n        let end = self.pos();\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        assert_eq!(self.char(), '>');\n        self.bump();\n        let name = &self.pattern()[start.offset..end.offset];\n        if name.is_empty() {\n            return Err(self.error(\n                Span::new(start, start),\n                ast::ErrorKind::GroupNameEmpty,\n            ));\n        }\n        let capname = ast::CaptureName {\n            span: Span::new(start, end),\n            name: name.to_string(),\n            index: capture_index,\n        };\n        self.add_capture_name(&capname)?;\n        Ok(capname)\n    }\n\n    /// Parse a sequence of flags starting at the current character.\n    ///\n    /// This advances the parser to the character immediately following the\n    /// flags, which is guaranteed to be either `:` or `)`.\n    ///\n    /// # Errors\n    ///\n    /// If any flags are duplicated, then an error is returned.\n    ///\n    /// If the negation operator is used more than once, then an error is\n    /// returned.\n    ///\n    /// If no flags could be found or if the negation operation is not followed\n    /// by any flags, then an error is returned.\n    #[inline(never)]\n    fn parse_flags(&self) -> Result<ast::Flags> {\n        let mut flags = ast::Flags { span: self.span(), items: vec![] };\n        let mut last_was_negation = None;\n        while self.char() != ':' && self.char() != ')' {\n            if self.char() == '-' {\n                last_was_negation = Some(self.span_char());\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Negation,\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagRepeatedNegation {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            } else {\n                last_was_negation = None;\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Flag(self.parse_flag()?),\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagDuplicate {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            }\n            if !self.bump() {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::FlagUnexpectedEof)\n                );\n            }\n        }\n        if let Some(span) = last_was_negation {\n            return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));\n        }\n        flags.span.end = self.pos();\n        Ok(flags)\n    }\n\n    /// Parse the current character as a flag. Do not advance the parser.\n    ///\n    /// # Errors\n    ///\n    /// If the flag is not recognized, then an error is returned.\n    #[inline(never)]\n    fn parse_flag(&self) -> Result<ast::Flag> {\n        match self.char() {\n            'i' => Ok(ast::Flag::CaseInsensitive),\n            'm' => Ok(ast::Flag::MultiLine),\n            's' => Ok(ast::Flag::DotMatchesNewLine),\n            'U' => Ok(ast::Flag::SwapGreed),\n            'u' => Ok(ast::Flag::Unicode),\n            'R' => Ok(ast::Flag::CRLF),\n            'x' => Ok(ast::Flag::IgnoreWhitespace),\n            _ => {\n                Err(self\n                    .error(self.span_char(), ast::ErrorKind::FlagUnrecognized))\n            }\n        }\n    }\n\n    /// Parse a primitive AST. e.g., A literal, non-set character class or\n    /// assertion.\n    ///\n    /// This assumes that the parser expects a primitive at the current\n    /// location. i.e., All other non-primitive cases have been handled.\n    /// For example, if the parser's position is at `|`, then `|` will be\n    /// treated as a literal (e.g., inside a character class).\n    ///\n    /// This advances the parser to the first character immediately following\n    /// the primitive.\n    fn parse_primitive(&self) -> Result<Primitive> {\n        match self.char() {\n            '\\\\' => self.parse_escape(),\n            '.' => {\n                let ast = Primitive::Dot(self.span_char());\n                self.bump();\n                Ok(ast)\n            }\n            '^' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::StartLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            '$' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::EndLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            c => {\n                let ast = Primitive::Literal(ast::Literal {\n                    span: self.span_char(),\n                    kind: ast::LiteralKind::Verbatim,\n                    c,\n                });\n                self.bump();\n                Ok(ast)\n            }\n        }\n    }\n\n    /// Parse an escape sequence as a primitive AST.\n    ///\n    /// This assumes the parser is positioned at the start of the escape\n    /// sequence, i.e., `\\`. It advances the parser to the first position\n    /// immediately following the escape sequence.\n    #[inline(never)]\n    fn parse_escape(&self) -> Result<Primitive> {\n        assert_eq!(self.char(), '\\\\');\n        let start = self.pos();\n        if !self.bump() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let c = self.char();\n        // Put some of the more complicated routines into helpers.\n        match c {\n            '0'..='7' => {\n                if !self.parser().octal {\n                    return Err(self.error(\n                        Span::new(start, self.span_char().end),\n                        ast::ErrorKind::UnsupportedBackreference,\n                    ));\n                }\n                let mut lit = self.parse_octal();\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            '8'..='9' if !self.parser().octal => {\n                return Err(self.error(\n                    Span::new(start, self.span_char().end),\n                    ast::ErrorKind::UnsupportedBackreference,\n                ));\n            }\n            'x' | 'u' | 'U' => {\n                let mut lit = self.parse_hex()?;\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            'p' | 'P' => {\n                let mut cls = self.parse_unicode_class()?;\n                cls.span.start = start;\n                return Ok(Primitive::Unicode(cls));\n            }\n            'd' | 's' | 'w' | 'D' | 'S' | 'W' => {\n                let mut cls = self.parse_perl_class();\n                cls.span.start = start;\n                return Ok(Primitive::Perl(cls));\n            }\n            _ => {}\n        }\n\n        // Handle all of the one letter sequences inline.\n        self.bump();\n        let span = Span::new(start, self.pos());\n        if is_meta_character(c) {\n            return Ok(Primitive::Literal(ast::Literal {\n                span,\n                kind: ast::LiteralKind::Meta,\n                c,\n            }));\n        }\n        if is_escapeable_character(c) {\n            return Ok(Primitive::Literal(ast::Literal {\n                span,\n                kind: ast::LiteralKind::Superfluous,\n                c,\n            }));\n        }\n        let special = |kind, c| {\n            Ok(Primitive::Literal(ast::Literal {\n                span,\n                kind: ast::LiteralKind::Special(kind),\n                c,\n            }))\n        };\n        match c {\n            'a' => special(ast::SpecialLiteralKind::Bell, '\\x07'),\n            'f' => special(ast::SpecialLiteralKind::FormFeed, '\\x0C'),\n            't' => special(ast::SpecialLiteralKind::Tab, '\\t'),\n            'n' => special(ast::SpecialLiteralKind::LineFeed, '\\n'),\n            'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\\r'),\n            'v' => special(ast::SpecialLiteralKind::VerticalTab, '\\x0B'),\n            'A' => Ok(Primitive::Assertion(ast::Assertion {\n                span,\n                kind: ast::AssertionKind::StartText,\n            })),\n            'z' => Ok(Primitive::Assertion(ast::Assertion {\n                span,\n                kind: ast::AssertionKind::EndText,\n            })),\n            'b' => Ok(Primitive::Assertion(ast::Assertion {\n                span,\n                kind: ast::AssertionKind::WordBoundary,\n            })),\n            'B' => Ok(Primitive::Assertion(ast::Assertion {\n                span,\n                kind: ast::AssertionKind::NotWordBoundary,\n            })),\n            _ => Err(self.error(span, ast::ErrorKind::EscapeUnrecognized)),\n        }\n    }\n\n    /// Parse an octal representation of a Unicode codepoint up to 3 digits\n    /// long. This expects the parser to be positioned at the first octal\n    /// digit and advances the parser to the first character immediately\n    /// following the octal number. This also assumes that parsing octal\n    /// escapes is enabled.\n    ///\n    /// Assuming the preconditions are met, this routine can never fail.\n    #[inline(never)]\n    fn parse_octal(&self) -> ast::Literal {\n        assert!(self.parser().octal);\n        assert!('0' <= self.char() && self.char() <= '7');\n        let start = self.pos();\n        // Parse up to two more digits.\n        while self.bump()\n            && '0' <= self.char()\n            && self.char() <= '7'\n            && self.pos().offset - start.offset <= 2\n        {}\n        let end = self.pos();\n        let octal = &self.pattern()[start.offset..end.offset];\n        // Parsing the octal should never fail since the above guarantees a\n        // valid number.\n        let codepoint =\n            u32::from_str_radix(octal, 8).expect(\"valid octal number\");\n        // The max value for 3 digit octal is 0777 = 511 and [0, 511] has no\n        // invalid Unicode scalar values.\n        let c = char::from_u32(codepoint).expect(\"Unicode scalar value\");\n        ast::Literal {\n            span: Span::new(start, end),\n            kind: ast::LiteralKind::Octal,\n            c,\n        }\n    }\n\n    /// Parse a hex representation of a Unicode codepoint. This handles both\n    /// hex notations, i.e., `\\xFF` and `\\x{FFFF}`. This expects the parser to\n    /// be positioned at the `x`, `u` or `U` prefix. The parser is advanced to\n    /// the first character immediately following the hexadecimal literal.\n    #[inline(never)]\n    fn parse_hex(&self) -> Result<ast::Literal> {\n        assert!(\n            self.char() == 'x' || self.char() == 'u' || self.char() == 'U'\n        );\n\n        let hex_kind = match self.char() {\n            'x' => ast::HexLiteralKind::X,\n            'u' => ast::HexLiteralKind::UnicodeShort,\n            _ => ast::HexLiteralKind::UnicodeLong,\n        };\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        if self.char() == '{' {\n            self.parse_hex_brace(hex_kind)\n        } else {\n            self.parse_hex_digits(hex_kind)\n        }\n    }\n\n    /// Parse an N-digit hex representation of a Unicode codepoint. This\n    /// expects the parser to be positioned at the first digit and will advance\n    /// the parser to the first character immediately following the escape\n    /// sequence.\n    ///\n    /// The number of digits given must be 2 (for `\\xNN`), 4 (for `\\uNNNN`)\n    /// or 8 (for `\\UNNNNNNNN`).\n    #[inline(never)]\n    fn parse_hex_digits(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal> {\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let start = self.pos();\n        for i in 0..kind.digits() {\n            if i > 0 && !self.bump_and_bump_space() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        // The final bump just moves the parser past the literal, which may\n        // be EOF.\n        self.bump_and_bump_space();\n        let end = self.pos();\n        let hex = scratch.as_str();\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, end),\n                kind: ast::LiteralKind::HexFixed(kind),\n                c,\n            }),\n        }\n    }\n\n    /// Parse a hex representation of any Unicode scalar value. This expects\n    /// the parser to be positioned at the opening brace `{` and will advance\n    /// the parser to the first character following the closing brace `}`.\n    #[inline(never)]\n    fn parse_hex_brace(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal> {\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let brace_pos = self.pos();\n        let start = self.span_char().end;\n        while self.bump_and_bump_space() && self.char() != '}' {\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let end = self.pos();\n        let hex = scratch.as_str();\n        assert_eq!(self.char(), '}');\n        self.bump_and_bump_space();\n\n        if hex.is_empty() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeHexEmpty,\n            ));\n        }\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, self.pos()),\n                kind: ast::LiteralKind::HexBrace(kind),\n                c,\n            }),\n        }\n    }\n\n    /// Parse a decimal number into a u32 while trimming leading and trailing\n    /// whitespace.\n    ///\n    /// This expects the parser to be positioned at the first position where\n    /// a decimal digit could occur. This will advance the parser to the byte\n    /// immediately following the last contiguous decimal digit.\n    ///\n    /// If no decimal digit could be found or if there was a problem parsing\n    /// the complete set of digits into a u32, then an error is returned.\n    fn parse_decimal(&self) -> Result<u32> {\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump();\n        }\n        let start = self.pos();\n        while !self.is_eof() && '0' <= self.char() && self.char() <= '9' {\n            scratch.push(self.char());\n            self.bump_and_bump_space();\n        }\n        let span = Span::new(start, self.pos());\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump_and_bump_space();\n        }\n        let digits = scratch.as_str();\n        if digits.is_empty() {\n            return Err(self.error(span, ast::ErrorKind::DecimalEmpty));\n        }\n        match u32::from_str_radix(digits, 10).ok() {\n            Some(n) => Ok(n),\n            None => Err(self.error(span, ast::ErrorKind::DecimalInvalid)),\n        }\n    }\n\n    /// Parse a standard character class consisting primarily of characters or\n    /// character ranges, but can also contain nested character classes of\n    /// any type (sans `.`).\n    ///\n    /// This assumes the parser is positioned at the opening `[`. If parsing\n    /// is successful, then the parser is advanced to the position immediately\n    /// following the closing `]`.\n    #[inline(never)]\n    fn parse_set_class(&self) -> Result<ast::Class> {\n        assert_eq!(self.char(), '[');\n\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                return Err(self.unclosed_class_error());\n            }\n            match self.char() {\n                '[' => {\n                    // If we've already parsed the opening bracket, then\n                    // attempt to treat this as the beginning of an ASCII\n                    // class. If ASCII class parsing fails, then the parser\n                    // backs up to `[`.\n                    if !self.parser().stack_class.borrow().is_empty() {\n                        if let Some(cls) = self.maybe_parse_ascii_class() {\n                            union.push(ast::ClassSetItem::Ascii(cls));\n                            continue;\n                        }\n                    }\n                    union = self.push_class_open(union)?;\n                }\n                ']' => match self.pop_class(union)? {\n                    Either::Left(nested_union) => {\n                        union = nested_union;\n                    }\n                    Either::Right(class) => return Ok(class),\n                },\n                '&' if self.peek() == Some('&') => {\n                    assert!(self.bump_if(\"&&\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Intersection,\n                        union,\n                    );\n                }\n                '-' if self.peek() == Some('-') => {\n                    assert!(self.bump_if(\"--\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Difference,\n                        union,\n                    );\n                }\n                '~' if self.peek() == Some('~') => {\n                    assert!(self.bump_if(\"~~\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::SymmetricDifference,\n                        union,\n                    );\n                }\n                _ => {\n                    union.push(self.parse_set_class_range()?);\n                }\n            }\n        }\n    }\n\n    /// Parse a single primitive item in a character class set. The item to\n    /// be parsed can either be one of a simple literal character, a range\n    /// between two simple literal characters or a \"primitive\" character\n    /// class like \\w or \\p{Greek}.\n    ///\n    /// If an invalid escape is found, or if a character class is found where\n    /// a simple literal is expected (e.g., in a range), then an error is\n    /// returned.\n    #[inline(never)]\n    fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {\n        let prim1 = self.parse_set_class_item()?;\n        self.bump_space();\n        if self.is_eof() {\n            return Err(self.unclosed_class_error());\n        }\n        // If the next char isn't a `-`, then we don't have a range.\n        // There are two exceptions. If the char after a `-` is a `]`, then\n        // `-` is interpreted as a literal `-`. Alternatively, if the char\n        // after a `-` is a `-`, then `--` corresponds to a \"difference\"\n        // operation.\n        if self.char() != '-'\n            || self.peek_space() == Some(']')\n            || self.peek_space() == Some('-')\n        {\n            return prim1.into_class_set_item(self);\n        }\n        // OK, now we're parsing a range, so bump past the `-` and parse the\n        // second half of the range.\n        if !self.bump_and_bump_space() {\n            return Err(self.unclosed_class_error());\n        }\n        let prim2 = self.parse_set_class_item()?;\n        let range = ast::ClassSetRange {\n            span: Span::new(prim1.span().start, prim2.span().end),\n            start: prim1.into_class_literal(self)?,\n            end: prim2.into_class_literal(self)?,\n        };\n        if !range.is_valid() {\n            return Err(\n                self.error(range.span, ast::ErrorKind::ClassRangeInvalid)\n            );\n        }\n        Ok(ast::ClassSetItem::Range(range))\n    }\n\n    /// Parse a single item in a character class as a primitive, where the\n    /// primitive either consists of a verbatim literal or a single escape\n    /// sequence.\n    ///\n    /// This assumes the parser is positioned at the beginning of a primitive,\n    /// and advances the parser to the first position after the primitive if\n    /// successful.\n    ///\n    /// Note that it is the caller's responsibility to report an error if an\n    /// illegal primitive was parsed.\n    #[inline(never)]\n    fn parse_set_class_item(&self) -> Result<Primitive> {\n        if self.char() == '\\\\' {\n            self.parse_escape()\n        } else {\n            let x = Primitive::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: self.char(),\n            });\n            self.bump();\n            Ok(x)\n        }\n    }\n\n    /// Parses the opening of a character class set. This includes the opening\n    /// bracket along with `^` if present to indicate negation. This also\n    /// starts parsing the opening set of unioned items if applicable, since\n    /// there are special rules applied to certain characters in the opening\n    /// of a character class. For example, `[^]]` is the class of all\n    /// characters not equal to `]`. (`]` would need to be escaped in any other\n    /// position.) Similarly for `-`.\n    ///\n    /// In all cases, the op inside the returned `ast::ClassBracketed` is an\n    /// empty union. This empty union should be replaced with the actual item\n    /// when it is popped from the parser's stack.\n    ///\n    /// This assumes the parser is positioned at the opening `[` and advances\n    /// the parser to the first non-special byte of the character class.\n    ///\n    /// An error is returned if EOF is found.\n    #[inline(never)]\n    fn parse_set_class_open(\n        &self,\n    ) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {\n        assert_eq!(self.char(), '[');\n        let start = self.pos();\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::ClassUnclosed,\n            ));\n        }\n\n        let negated = if self.char() != '^' {\n            false\n        } else {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n            true\n        };\n        // Accept any number of `-` as literal `-`.\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        while self.char() == '-' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: '-',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, start),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        // If `]` is the *first* char in a set, then interpret it as a literal\n        // `]`. That is, an empty class is impossible to write.\n        if union.items.is_empty() && self.char() == ']' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: ']',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        let set = ast::ClassBracketed {\n            span: Span::new(start, self.pos()),\n            negated,\n            kind: ast::ClassSet::union(ast::ClassSetUnion {\n                span: Span::new(union.span.start, union.span.start),\n                items: vec![],\n            }),\n        };\n        Ok((set, union))\n    }\n\n    /// Attempt to parse an ASCII character class, e.g., `[:alnum:]`.\n    ///\n    /// This assumes the parser is positioned at the opening `[`.\n    ///\n    /// If no valid ASCII character class could be found, then this does not\n    /// advance the parser and `None` is returned. Otherwise, the parser is\n    /// advanced to the first byte following the closing `]` and the\n    /// corresponding ASCII class is returned.\n    #[inline(never)]\n    fn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii> {\n        // ASCII character classes are interesting from a parsing perspective\n        // because parsing cannot fail with any interesting error. For example,\n        // in order to use an ASCII character class, it must be enclosed in\n        // double brackets, e.g., `[[:alnum:]]`. Alternatively, you might think\n        // of it as \"ASCII character characters have the syntax `[:NAME:]`\n        // which can only appear within character brackets.\" This means that\n        // things like `[[:lower:]A]` are legal constructs.\n        //\n        // However, if one types an incorrect ASCII character class, e.g.,\n        // `[[:loower:]]`, then we treat that as a normal nested character\n        // class containing the characters `:elorw`. One might argue that we\n        // should return an error instead since the repeated colons give away\n        // the intent to write an ASCII class. But what if the user typed\n        // `[[:lower]]` instead? How can we tell that was intended to be an\n        // ASCII class and not just a normal nested class?\n        //\n        // Reasonable people can probably disagree over this, but for better\n        // or worse, we implement semantics that never fails at the expense\n        // of better failure modes.\n        assert_eq!(self.char(), '[');\n        // If parsing fails, then we back up the parser to this starting point.\n        let start = self.pos();\n        let mut negated = false;\n        if !self.bump() || self.char() != ':' {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if !self.bump() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if self.char() == '^' {\n            negated = true;\n            if !self.bump() {\n                self.parser().pos.set(start);\n                return None;\n            }\n        }\n        let name_start = self.offset();\n        while self.char() != ':' && self.bump() {}\n        if self.is_eof() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let name = &self.pattern()[name_start..self.offset()];\n        if !self.bump_if(\":]\") {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let kind = match ast::ClassAsciiKind::from_name(name) {\n            Some(kind) => kind,\n            None => {\n                self.parser().pos.set(start);\n                return None;\n            }\n        };\n        Some(ast::ClassAscii {\n            span: Span::new(start, self.pos()),\n            kind,\n            negated,\n        })\n    }\n\n    /// Parse a Unicode class in either the single character notation, `\\pN`\n    /// or the multi-character bracketed notation, `\\p{Greek}`. This assumes\n    /// the parser is positioned at the `p` (or `P` for negation) and will\n    /// advance the parser to the character immediately following the class.\n    ///\n    /// Note that this does not check whether the class name is valid or not.\n    #[inline(never)]\n    fn parse_unicode_class(&self) -> Result<ast::ClassUnicode> {\n        assert!(self.char() == 'p' || self.char() == 'P');\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let negated = self.char() == 'P';\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        let (start, kind) = if self.char() == '{' {\n            let start = self.span_char().end;\n            while self.bump_and_bump_space() && self.char() != '}' {\n                scratch.push(self.char());\n            }\n            if self.is_eof() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            assert_eq!(self.char(), '}');\n            self.bump();\n\n            let name = scratch.as_str();\n            if let Some(i) = name.find(\"!=\") {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::NotEqual,\n                        name: name[..i].to_string(),\n                        value: name[i + 2..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find(':') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Colon,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find('=') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Equal,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else {\n                (start, ast::ClassUnicodeKind::Named(name.to_string()))\n            }\n        } else {\n            let start = self.pos();\n            let c = self.char();\n            if c == '\\\\' {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::UnicodeClassInvalid,\n                ));\n            }\n            self.bump_and_bump_space();\n            let kind = ast::ClassUnicodeKind::OneLetter(c);\n            (start, kind)\n        };\n        Ok(ast::ClassUnicode {\n            span: Span::new(start, self.pos()),\n            negated,\n            kind,\n        })\n    }\n\n    /// Parse a Perl character class, e.g., `\\d` or `\\W`. This assumes the\n    /// parser is currently at a valid character class name and will be\n    /// advanced to the character immediately following the class.\n    #[inline(never)]\n    fn parse_perl_class(&self) -> ast::ClassPerl {\n        let c = self.char();\n        let span = self.span_char();\n        self.bump();\n        let (negated, kind) = match c {\n            'd' => (false, ast::ClassPerlKind::Digit),\n            'D' => (true, ast::ClassPerlKind::Digit),\n            's' => (false, ast::ClassPerlKind::Space),\n            'S' => (true, ast::ClassPerlKind::Space),\n            'w' => (false, ast::ClassPerlKind::Word),\n            'W' => (true, ast::ClassPerlKind::Word),\n            c => panic!(\"expected valid Perl class but got '{}'\", c),\n        };\n        ast::ClassPerl { span, kind, negated }\n    }\n}"],"ast::parse::Primitive":["Clone","Debug","Eq","PartialEq","impl Primitive {\n    /// Return the span of this primitive.\n    fn span(&self) -> &Span {\n        match *self {\n            Primitive::Literal(ref x) => &x.span,\n            Primitive::Assertion(ref x) => &x.span,\n            Primitive::Dot(ref span) => span,\n            Primitive::Perl(ref x) => &x.span,\n            Primitive::Unicode(ref x) => &x.span,\n        }\n    }\n\n    /// Convert this primitive into a proper AST.\n    fn into_ast(self) -> Ast {\n        match self {\n            Primitive::Literal(lit) => Ast::Literal(lit),\n            Primitive::Assertion(assert) => Ast::Assertion(assert),\n            Primitive::Dot(span) => Ast::Dot(span),\n            Primitive::Perl(cls) => Ast::Class(ast::Class::Perl(cls)),\n            Primitive::Unicode(cls) => Ast::Class(ast::Class::Unicode(cls)),\n        }\n    }\n\n    /// Convert this primitive into an item in a character class.\n    ///\n    /// If this primitive is not a legal item (i.e., an assertion or a dot),\n    /// then return an error.\n    fn into_class_set_item<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<'_, P>,\n    ) -> Result<ast::ClassSetItem> {\n        use self::Primitive::*;\n        use crate::ast::ClassSetItem;\n\n        match self {\n            Literal(lit) => Ok(ClassSetItem::Literal(lit)),\n            Perl(cls) => Ok(ClassSetItem::Perl(cls)),\n            Unicode(cls) => Ok(ClassSetItem::Unicode(cls)),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassEscapeInvalid)),\n        }\n    }\n\n    /// Convert this primitive into a literal in a character class. In\n    /// particular, literals are the only valid items that can appear in\n    /// ranges.\n    ///\n    /// If this primitive is not a legal item (i.e., a class, assertion or a\n    /// dot), then return an error.\n    fn into_class_literal<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<'_, P>,\n    ) -> Result<ast::Literal> {\n        use self::Primitive::*;\n\n        match self {\n            Literal(lit) => Ok(lit),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassRangeLiteral)),\n        }\n    }\n}"],"ast::print::Printer":["Debug","impl Printer {\n    /// Create a new printer.\n    pub fn new() -> Printer {\n        PrinterBuilder::new().build()\n    }\n\n    /// Print the given `Ast` to the given writer. The writer must implement\n    /// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n    /// here are a `fmt::Formatter` (which is available in `fmt::Display`\n    /// implementations) or a `&mut String`.\n    pub fn print<W: fmt::Write>(&mut self, ast: &Ast, wtr: W) -> fmt::Result {\n        visitor::visit(ast, Writer { wtr })\n    }\n}"],"ast::print::PrinterBuilder":["Clone","Debug","impl Default for PrinterBuilder {\n    fn default() -> PrinterBuilder {\n        PrinterBuilder::new()\n    }\n}","impl PrinterBuilder {\n    fn new() -> PrinterBuilder {\n        PrinterBuilder { _priv: () }\n    }\n\n    fn build(&self) -> Printer {\n        Printer { _priv: () }\n    }\n}"],"ast::print::Writer":["Debug","impl<W: fmt::Write> Visitor for Writer<W> {\n    type Output = ();\n    type Err = fmt::Error;\n\n    fn finish(self) -> fmt::Result {\n        Ok(())\n    }\n\n    fn visit_pre(&mut self, ast: &Ast) -> fmt::Result {\n        match *ast {\n            Ast::Group(ref x) => self.fmt_group_pre(x),\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }\n\n    fn visit_post(&mut self, ast: &Ast) -> fmt::Result {\n        use crate::ast::Class;\n\n        match *ast {\n            Ast::Empty(_) => Ok(()),\n            Ast::Flags(ref x) => self.fmt_set_flags(x),\n            Ast::Literal(ref x) => self.fmt_literal(x),\n            Ast::Dot(_) => self.wtr.write_str(\".\"),\n            Ast::Assertion(ref x) => self.fmt_assertion(x),\n            Ast::Class(Class::Perl(ref x)) => self.fmt_class_perl(x),\n            Ast::Class(Class::Unicode(ref x)) => self.fmt_class_unicode(x),\n            Ast::Class(Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_post(x)\n            }\n            Ast::Repetition(ref x) => self.fmt_repetition(x),\n            Ast::Group(ref x) => self.fmt_group_post(x),\n            Ast::Alternation(_) => Ok(()),\n            Ast::Concat(_) => Ok(()),\n        }\n    }\n\n    fn visit_alternation_in(&mut self) -> fmt::Result {\n        self.wtr.write_str(\"|\")\n    }\n\n    fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        match *ast {\n            ast::ClassSetItem::Bracketed(ref x) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }\n\n    fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        use crate::ast::ClassSetItem::*;\n\n        match *ast {\n            Empty(_) => Ok(()),\n            Literal(ref x) => self.fmt_literal(x),\n            Range(ref x) => {\n                self.fmt_literal(&x.start)?;\n                self.wtr.write_str(\"-\")?;\n                self.fmt_literal(&x.end)?;\n                Ok(())\n            }\n            Ascii(ref x) => self.fmt_class_ascii(x),\n            Unicode(ref x) => self.fmt_class_unicode(x),\n            Perl(ref x) => self.fmt_class_perl(x),\n            Bracketed(ref x) => self.fmt_class_bracketed_post(x),\n            Union(_) => Ok(()),\n        }\n    }\n\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        self.fmt_class_set_binary_op_kind(&ast.kind)\n    }\n}","impl<W: fmt::Write> Writer<W> {\n    fn fmt_group_pre(&mut self, ast: &ast::Group) -> fmt::Result {\n        use crate::ast::GroupKind::*;\n        match ast.kind {\n            CaptureIndex(_) => self.wtr.write_str(\"(\"),\n            CaptureName { ref name, starts_with_p } => {\n                let start = if starts_with_p { \"(?P<\" } else { \"(?<\" };\n                self.wtr.write_str(start)?;\n                self.wtr.write_str(&name.name)?;\n                self.wtr.write_str(\">\")?;\n                Ok(())\n            }\n            NonCapturing(ref flags) => {\n                self.wtr.write_str(\"(?\")?;\n                self.fmt_flags(flags)?;\n                self.wtr.write_str(\":\")?;\n                Ok(())\n            }\n        }\n    }\n\n    fn fmt_group_post(&mut self, _ast: &ast::Group) -> fmt::Result {\n        self.wtr.write_str(\")\")\n    }\n\n    fn fmt_repetition(&mut self, ast: &ast::Repetition) -> fmt::Result {\n        use crate::ast::RepetitionKind::*;\n        match ast.op.kind {\n            ZeroOrOne if ast.greedy => self.wtr.write_str(\"?\"),\n            ZeroOrOne => self.wtr.write_str(\"??\"),\n            ZeroOrMore if ast.greedy => self.wtr.write_str(\"*\"),\n            ZeroOrMore => self.wtr.write_str(\"*?\"),\n            OneOrMore if ast.greedy => self.wtr.write_str(\"+\"),\n            OneOrMore => self.wtr.write_str(\"+?\"),\n            Range(ref x) => {\n                self.fmt_repetition_range(x)?;\n                if !ast.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n                Ok(())\n            }\n        }\n    }\n\n    fn fmt_repetition_range(\n        &mut self,\n        ast: &ast::RepetitionRange,\n    ) -> fmt::Result {\n        use crate::ast::RepetitionRange::*;\n        match *ast {\n            Exactly(x) => write!(self.wtr, \"{{{}}}\", x),\n            AtLeast(x) => write!(self.wtr, \"{{{},}}\", x),\n            Bounded(x, y) => write!(self.wtr, \"{{{},{}}}\", x, y),\n        }\n    }\n\n    fn fmt_literal(&mut self, ast: &ast::Literal) -> fmt::Result {\n        use crate::ast::LiteralKind::*;\n\n        match ast.kind {\n            Verbatim => self.wtr.write_char(ast.c),\n            Meta | Superfluous => write!(self.wtr, r\"\\{}\", ast.c),\n            Octal => write!(self.wtr, r\"\\{:o}\", u32::from(ast.c)),\n            HexFixed(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{:02X}\", u32::from(ast.c))\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{:04X}\", u32::from(ast.c))\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{:08X}\", u32::from(ast.c))\n            }\n            HexBrace(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{{{:X}}}\", u32::from(ast.c))\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{{{:X}}}\", u32::from(ast.c))\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{{{:X}}}\", u32::from(ast.c))\n            }\n            Special(ast::SpecialLiteralKind::Bell) => {\n                self.wtr.write_str(r\"\\a\")\n            }\n            Special(ast::SpecialLiteralKind::FormFeed) => {\n                self.wtr.write_str(r\"\\f\")\n            }\n            Special(ast::SpecialLiteralKind::Tab) => self.wtr.write_str(r\"\\t\"),\n            Special(ast::SpecialLiteralKind::LineFeed) => {\n                self.wtr.write_str(r\"\\n\")\n            }\n            Special(ast::SpecialLiteralKind::CarriageReturn) => {\n                self.wtr.write_str(r\"\\r\")\n            }\n            Special(ast::SpecialLiteralKind::VerticalTab) => {\n                self.wtr.write_str(r\"\\v\")\n            }\n            Special(ast::SpecialLiteralKind::Space) => {\n                self.wtr.write_str(r\"\\ \")\n            }\n        }\n    }\n\n    fn fmt_assertion(&mut self, ast: &ast::Assertion) -> fmt::Result {\n        use crate::ast::AssertionKind::*;\n        match ast.kind {\n            StartLine => self.wtr.write_str(\"^\"),\n            EndLine => self.wtr.write_str(\"$\"),\n            StartText => self.wtr.write_str(r\"\\A\"),\n            EndText => self.wtr.write_str(r\"\\z\"),\n            WordBoundary => self.wtr.write_str(r\"\\b\"),\n            NotWordBoundary => self.wtr.write_str(r\"\\B\"),\n        }\n    }\n\n    fn fmt_set_flags(&mut self, ast: &ast::SetFlags) -> fmt::Result {\n        self.wtr.write_str(\"(?\")?;\n        self.fmt_flags(&ast.flags)?;\n        self.wtr.write_str(\")\")?;\n        Ok(())\n    }\n\n    fn fmt_flags(&mut self, ast: &ast::Flags) -> fmt::Result {\n        use crate::ast::{Flag, FlagsItemKind};\n\n        for item in &ast.items {\n            match item.kind {\n                FlagsItemKind::Negation => self.wtr.write_str(\"-\"),\n                FlagsItemKind::Flag(ref flag) => match *flag {\n                    Flag::CaseInsensitive => self.wtr.write_str(\"i\"),\n                    Flag::MultiLine => self.wtr.write_str(\"m\"),\n                    Flag::DotMatchesNewLine => self.wtr.write_str(\"s\"),\n                    Flag::SwapGreed => self.wtr.write_str(\"U\"),\n                    Flag::Unicode => self.wtr.write_str(\"u\"),\n                    Flag::CRLF => self.wtr.write_str(\"R\"),\n                    Flag::IgnoreWhitespace => self.wtr.write_str(\"x\"),\n                },\n            }?;\n        }\n        Ok(())\n    }\n\n    fn fmt_class_bracketed_pre(\n        &mut self,\n        ast: &ast::ClassBracketed,\n    ) -> fmt::Result {\n        if ast.negated {\n            self.wtr.write_str(\"[^\")\n        } else {\n            self.wtr.write_str(\"[\")\n        }\n    }\n\n    fn fmt_class_bracketed_post(\n        &mut self,\n        _ast: &ast::ClassBracketed,\n    ) -> fmt::Result {\n        self.wtr.write_str(\"]\")\n    }\n\n    fn fmt_class_set_binary_op_kind(\n        &mut self,\n        ast: &ast::ClassSetBinaryOpKind,\n    ) -> fmt::Result {\n        use crate::ast::ClassSetBinaryOpKind::*;\n        match *ast {\n            Intersection => self.wtr.write_str(\"&&\"),\n            Difference => self.wtr.write_str(\"--\"),\n            SymmetricDifference => self.wtr.write_str(\"~~\"),\n        }\n    }\n\n    fn fmt_class_perl(&mut self, ast: &ast::ClassPerl) -> fmt::Result {\n        use crate::ast::ClassPerlKind::*;\n        match ast.kind {\n            Digit if ast.negated => self.wtr.write_str(r\"\\D\"),\n            Digit => self.wtr.write_str(r\"\\d\"),\n            Space if ast.negated => self.wtr.write_str(r\"\\S\"),\n            Space => self.wtr.write_str(r\"\\s\"),\n            Word if ast.negated => self.wtr.write_str(r\"\\W\"),\n            Word => self.wtr.write_str(r\"\\w\"),\n        }\n    }\n\n    fn fmt_class_ascii(&mut self, ast: &ast::ClassAscii) -> fmt::Result {\n        use crate::ast::ClassAsciiKind::*;\n        match ast.kind {\n            Alnum if ast.negated => self.wtr.write_str(\"[:^alnum:]\"),\n            Alnum => self.wtr.write_str(\"[:alnum:]\"),\n            Alpha if ast.negated => self.wtr.write_str(\"[:^alpha:]\"),\n            Alpha => self.wtr.write_str(\"[:alpha:]\"),\n            Ascii if ast.negated => self.wtr.write_str(\"[:^ascii:]\"),\n            Ascii => self.wtr.write_str(\"[:ascii:]\"),\n            Blank if ast.negated => self.wtr.write_str(\"[:^blank:]\"),\n            Blank => self.wtr.write_str(\"[:blank:]\"),\n            Cntrl if ast.negated => self.wtr.write_str(\"[:^cntrl:]\"),\n            Cntrl => self.wtr.write_str(\"[:cntrl:]\"),\n            Digit if ast.negated => self.wtr.write_str(\"[:^digit:]\"),\n            Digit => self.wtr.write_str(\"[:digit:]\"),\n            Graph if ast.negated => self.wtr.write_str(\"[:^graph:]\"),\n            Graph => self.wtr.write_str(\"[:graph:]\"),\n            Lower if ast.negated => self.wtr.write_str(\"[:^lower:]\"),\n            Lower => self.wtr.write_str(\"[:lower:]\"),\n            Print if ast.negated => self.wtr.write_str(\"[:^print:]\"),\n            Print => self.wtr.write_str(\"[:print:]\"),\n            Punct if ast.negated => self.wtr.write_str(\"[:^punct:]\"),\n            Punct => self.wtr.write_str(\"[:punct:]\"),\n            Space if ast.negated => self.wtr.write_str(\"[:^space:]\"),\n            Space => self.wtr.write_str(\"[:space:]\"),\n            Upper if ast.negated => self.wtr.write_str(\"[:^upper:]\"),\n            Upper => self.wtr.write_str(\"[:upper:]\"),\n            Word if ast.negated => self.wtr.write_str(\"[:^word:]\"),\n            Word => self.wtr.write_str(\"[:word:]\"),\n            Xdigit if ast.negated => self.wtr.write_str(\"[:^xdigit:]\"),\n            Xdigit => self.wtr.write_str(\"[:xdigit:]\"),\n        }\n    }\n\n    fn fmt_class_unicode(&mut self, ast: &ast::ClassUnicode) -> fmt::Result {\n        use crate::ast::ClassUnicodeKind::*;\n        use crate::ast::ClassUnicodeOpKind::*;\n\n        if ast.negated {\n            self.wtr.write_str(r\"\\P\")?;\n        } else {\n            self.wtr.write_str(r\"\\p\")?;\n        }\n        match ast.kind {\n            OneLetter(c) => self.wtr.write_char(c),\n            Named(ref x) => write!(self.wtr, \"{{{}}}\", x),\n            NamedValue { op: Equal, ref name, ref value } => {\n                write!(self.wtr, \"{{{}={}}}\", name, value)\n            }\n            NamedValue { op: Colon, ref name, ref value } => {\n                write!(self.wtr, \"{{{}:{}}}\", name, value)\n            }\n            NamedValue { op: NotEqual, ref name, ref value } => {\n                write!(self.wtr, \"{{{}!={}}}\", name, value)\n            }\n        }\n    }\n}"],"ast::visitor::ClassFrame":["impl<'a> ClassFrame<'a> {\n    /// Perform the next inductive step on this frame and return the next\n    /// child class node to visit.\n    fn child(&self) -> ClassInduct<'a> {\n        match *self {\n            ClassFrame::Union { head, .. } => ClassInduct::Item(head),\n            ClassFrame::Binary { op, .. } => ClassInduct::BinaryOp(op),\n            ClassFrame::BinaryLHS { ref lhs, .. } => {\n                ClassInduct::from_set(lhs)\n            }\n            ClassFrame::BinaryRHS { ref rhs, .. } => {\n                ClassInduct::from_set(rhs)\n            }\n        }\n    }\n}","impl<'a> core::fmt::Debug for ClassFrame<'a> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let x = match *self {\n            ClassFrame::Union { .. } => \"Union\",\n            ClassFrame::Binary { .. } => \"Binary\",\n            ClassFrame::BinaryLHS { .. } => \"BinaryLHS\",\n            ClassFrame::BinaryRHS { .. } => \"BinaryRHS\",\n        };\n        write!(f, \"{}\", x)\n    }\n}"],"ast::visitor::ClassInduct":["impl<'a> ClassInduct<'a> {\n    fn from_bracketed(ast: &'a ast::ClassBracketed) -> ClassInduct<'a> {\n        ClassInduct::from_set(&ast.kind)\n    }\n\n    fn from_set(ast: &'a ast::ClassSet) -> ClassInduct<'a> {\n        match *ast {\n            ast::ClassSet::Item(ref item) => ClassInduct::Item(item),\n            ast::ClassSet::BinaryOp(ref op) => ClassInduct::BinaryOp(op),\n        }\n    }\n}","impl<'a> core::fmt::Debug for ClassInduct<'a> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let x = match *self {\n            ClassInduct::Item(it) => match *it {\n                ast::ClassSetItem::Empty(_) => \"Item(Empty)\",\n                ast::ClassSetItem::Literal(_) => \"Item(Literal)\",\n                ast::ClassSetItem::Range(_) => \"Item(Range)\",\n                ast::ClassSetItem::Ascii(_) => \"Item(Ascii)\",\n                ast::ClassSetItem::Perl(_) => \"Item(Perl)\",\n                ast::ClassSetItem::Unicode(_) => \"Item(Unicode)\",\n                ast::ClassSetItem::Bracketed(_) => \"Item(Bracketed)\",\n                ast::ClassSetItem::Union(_) => \"Item(Union)\",\n            },\n            ClassInduct::BinaryOp(it) => match it.kind {\n                ast::ClassSetBinaryOpKind::Intersection => {\n                    \"BinaryOp(Intersection)\"\n                }\n                ast::ClassSetBinaryOpKind::Difference => {\n                    \"BinaryOp(Difference)\"\n                }\n                ast::ClassSetBinaryOpKind::SymmetricDifference => {\n                    \"BinaryOp(SymmetricDifference)\"\n                }\n            },\n        };\n        write!(f, \"{}\", x)\n    }\n}"],"ast::visitor::Frame":["impl<'a> Frame<'a> {\n    /// Perform the next inductive step on this frame and return the next\n    /// child AST node to visit.\n    fn child(&self) -> &'a Ast {\n        match *self {\n            Frame::Repetition(rep) => &rep.ast,\n            Frame::Group(group) => &group.ast,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }\n}"],"ast::visitor::HeapVisitor":["impl<'a> HeapVisitor<'a> {\n    fn new() -> HeapVisitor<'a> {\n        HeapVisitor { stack: vec![], stack_class: vec![] }\n    }\n\n    fn visit<V: Visitor>(\n        &mut self,\n        mut ast: &'a Ast,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err> {\n        self.stack.clear();\n        self.stack_class.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(ast)?;\n            if let Some(x) = self.induct(ast, &mut visitor)? {\n                let child = x.child();\n                self.stack.push((ast, x));\n                ast = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(ast)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    ast = x.child();\n                    self.stack.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this AST, so we can post visit it now.\n                visitor.visit_post(post_ast)?;\n            }\n        }\n    }\n\n    /// Build a stack frame for the given AST if one is needed (which occurs if\n    /// and only if there are child nodes in the AST). Otherwise, return None.\n    ///\n    /// If this visits a class, then the underlying visitor implementation may\n    /// return an error which will be passed on here.\n    fn induct<V: Visitor>(\n        &mut self,\n        ast: &'a Ast,\n        visitor: &mut V,\n    ) -> Result<Option<Frame<'a>>, V::Err> {\n        Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat { head: &x.asts[0], tail: &x.asts[1..] })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => Some(Frame::Alternation {\n                head: &x.asts[0],\n                tail: &x.asts[1..],\n            }),\n            _ => None,\n        })\n    }\n\n    /// Pops the given frame. If the frame has an additional inductive step,\n    /// then return it, otherwise return `None`.\n    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }\n\n    fn visit_class<V: Visitor>(\n        &mut self,\n        ast: &'a ast::ClassBracketed,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {\n        let mut ast = ClassInduct::from_bracketed(ast);\n        loop {\n            self.visit_class_pre(&ast, visitor)?;\n            if let Some(x) = self.induct_class(&ast) {\n                let child = x.child();\n                self.stack_class.push((ast, x));\n                ast = child;\n                continue;\n            }\n            self.visit_class_post(&ast, visitor)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack_class.pop() {\n                    None => return Ok(()),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a union or a binary op, then we might have\n                // additional inductive steps to process.\n                if let Some(x) = self.pop_class(frame) {\n                    if let ClassFrame::BinaryRHS { ref op, .. } = x {\n                        visitor.visit_class_set_binary_op_in(op)?;\n                    }\n                    ast = x.child();\n                    self.stack_class.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this class node, so we can post visit it now.\n                self.visit_class_post(&post_ast, visitor)?;\n            }\n        }\n    }\n\n    /// Call the appropriate `Visitor` methods given an inductive step.\n    fn visit_class_pre<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_pre(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_pre(op)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Call the appropriate `Visitor` methods given an inductive step.\n    fn visit_class_post<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err> {\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_post(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_post(op)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Build a stack frame for the given class node if one is needed (which\n    /// occurs if and only if there are child nodes). Otherwise, return None.\n    fn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>> {\n        match *ast {\n            ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) => {\n                match x.kind {\n                    ast::ClassSet::Item(ref item) => {\n                        Some(ClassFrame::Union { head: item, tail: &[] })\n                    }\n                    ast::ClassSet::BinaryOp(ref op) => {\n                        Some(ClassFrame::Binary { op })\n                    }\n                }\n            }\n            ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) => {\n                if x.items.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &x.items[0],\n                        tail: &x.items[1..],\n                    })\n                }\n            }\n            ClassInduct::BinaryOp(op) => {\n                Some(ClassFrame::BinaryLHS { op, lhs: &op.lhs, rhs: &op.rhs })\n            }\n            _ => None,\n        }\n    }\n\n    /// Pops the given frame. If the frame has an additional inductive step,\n    /// then return it, otherwise return `None`.\n    fn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>> {\n        match induct {\n            ClassFrame::Union { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n            ClassFrame::Binary { .. } => None,\n            ClassFrame::BinaryLHS { op, rhs, .. } => {\n                Some(ClassFrame::BinaryRHS { op, rhs })\n            }\n            ClassFrame::BinaryRHS { .. } => None,\n        }\n    }\n}"],"debug::Byte":["impl core::fmt::Debug for Byte {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        // Special case ASCII space. It's too hard to read otherwise, so\n        // put quotes around it. I sometimes wonder whether just '\\x20' would\n        // be better...\n        if self.0 == b' ' {\n            return write!(f, \"' '\");\n        }\n        // 10 bytes is enough to cover any output from ascii::escape_default.\n        let mut bytes = [0u8; 10];\n        let mut len = 0;\n        for (i, mut b) in core::ascii::escape_default(self.0).enumerate() {\n            // capitalize \\xab to \\xAB\n            if i >= 2 && b'a' <= b && b <= b'f' {\n                b -= 32;\n            }\n            bytes[len] = b;\n            len += 1;\n        }\n        write!(f, \"{}\", core::str::from_utf8(&bytes[..len]).unwrap())\n    }\n}"],"debug::Bytes":["impl<'a> core::fmt::Debug for Bytes<'a> {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        write!(f, \"\\\"\")?;\n        // This is a sad re-implementation of a similar impl found in bstr.\n        let mut bytes = self.0;\n        while let Some(result) = utf8_decode(bytes) {\n            let ch = match result {\n                Ok(ch) => ch,\n                Err(byte) => {\n                    write!(f, r\"\\x{:02x}\", byte)?;\n                    bytes = &bytes[1..];\n                    continue;\n                }\n            };\n            bytes = &bytes[ch.len_utf8()..];\n            match ch {\n                '\\0' => write!(f, \"\\\\0\")?,\n                // ASCII control characters except \\0, \\n, \\r, \\t\n                '\\x01'..='\\x08'\n                | '\\x0b'\n                | '\\x0c'\n                | '\\x0e'..='\\x19'\n                | '\\x7f' => {\n                    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;\n                }\n                '\\n' | '\\r' | '\\t' | _ => {\n                    write!(f, \"{}\", ch.escape_debug())?;\n                }\n            }\n        }\n        write!(f, \"\\\"\")?;\n        Ok(())\n    }\n}"],"either::Either":["Clone","Debug","Eq","PartialEq"],"error::Error":["Clone","Debug","Eq","PartialEq","impl From<ast::Error> for Error {\n    fn from(err: ast::Error) -> Error {\n        Error::Parse(err)\n    }\n}","impl From<hir::Error> for Error {\n    fn from(err: hir::Error) -> Error {\n        Error::Translate(err)\n    }\n}","impl core::fmt::Display for Error {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        match *self {\n            Error::Parse(ref x) => x.fmt(f),\n            Error::Translate(ref x) => x.fmt(f),\n        }\n    }\n}","impl std::error::Error for Error {}"],"error::Formatter":["Debug","impl<'e, E: core::fmt::Display> core::fmt::Display for Formatter<'e, E> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let spans = Spans::from_formatter(self);\n        if self.pattern.contains('\\n') {\n            let divider = repeat_char('~', 79);\n\n            writeln!(f, \"regex parse error:\")?;\n            writeln!(f, \"{}\", divider)?;\n            let notated = spans.notate();\n            write!(f, \"{}\", notated)?;\n            writeln!(f, \"{}\", divider)?;\n            // If we have error spans that cover multiple lines, then we just\n            // note the line numbers.\n            if !spans.multi_line.is_empty() {\n                let mut notes = vec![];\n                for span in &spans.multi_line {\n                    notes.push(format!(\n                        \"on line {} (column {}) through line {} (column {})\",\n                        span.start.line,\n                        span.start.column,\n                        span.end.line,\n                        span.end.column - 1\n                    ));\n                }\n                writeln!(f, \"{}\", notes.join(\"\\n\"))?;\n            }\n            write!(f, \"error: {}\", self.err)?;\n        } else {\n            writeln!(f, \"regex parse error:\")?;\n            let notated = Spans::from_formatter(self).notate();\n            write!(f, \"{}\", notated)?;\n            write!(f, \"error: {}\", self.err)?;\n        }\n        Ok(())\n    }\n}","impl<'e> From<&'e ast::Error> for Formatter<'e, ast::ErrorKind> {\n    fn from(err: &'e ast::Error) -> Self {\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: err.auxiliary_span(),\n        }\n    }\n}","impl<'e> From<&'e hir::Error> for Formatter<'e, hir::ErrorKind> {\n    fn from(err: &'e hir::Error) -> Self {\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: None,\n        }\n    }\n}"],"error::Spans":["impl<'p> Spans<'p> {\n    /// Build a sequence of spans from a formatter.\n    fn from_formatter<'e, E: core::fmt::Display>(\n        fmter: &'p Formatter<'e, E>,\n    ) -> Spans<'p> {\n        let mut line_count = fmter.pattern.lines().count();\n        // If the pattern ends with a `\\n` literal, then our line count is\n        // off by one, since a span can occur immediately after the last `\\n`,\n        // which is consider to be an additional line.\n        if fmter.pattern.ends_with('\\n') {\n            line_count += 1;\n        }\n        let line_number_width =\n            if line_count <= 1 { 0 } else { line_count.to_string().len() };\n        let mut spans = Spans {\n            pattern: &fmter.pattern,\n            line_number_width,\n            by_line: vec![vec![]; line_count],\n            multi_line: vec![],\n        };\n        spans.add(fmter.span.clone());\n        if let Some(span) = fmter.aux_span {\n            spans.add(span.clone());\n        }\n        spans\n    }\n\n    /// Add the given span to this sequence, putting it in the right place.\n    fn add(&mut self, span: ast::Span) {\n        // This is grossly inefficient since we sort after each add, but right\n        // now, we only ever add two spans at most.\n        if span.is_one_line() {\n            let i = span.start.line - 1; // because lines are 1-indexed\n            self.by_line[i].push(span);\n            self.by_line[i].sort();\n        } else {\n            self.multi_line.push(span);\n            self.multi_line.sort();\n        }\n    }\n\n    /// Notate the pattern string with carents (`^`) pointing at each span\n    /// location. This only applies to spans that occur within a single line.\n    fn notate(&self) -> String {\n        let mut notated = String::new();\n        for (i, line) in self.pattern.lines().enumerate() {\n            if self.line_number_width > 0 {\n                notated.push_str(&self.left_pad_line_number(i + 1));\n                notated.push_str(\": \");\n            } else {\n                notated.push_str(\"    \");\n            }\n            notated.push_str(line);\n            notated.push('\\n');\n            if let Some(notes) = self.notate_line(i) {\n                notated.push_str(&notes);\n                notated.push('\\n');\n            }\n        }\n        notated\n    }\n\n    /// Return notes for the line indexed at `i` (zero-based). If there are no\n    /// spans for the given line, then `None` is returned. Otherwise, an\n    /// appropriately space padded string with correctly positioned `^` is\n    /// returned, accounting for line numbers.\n    fn notate_line(&self, i: usize) -> Option<String> {\n        let spans = &self.by_line[i];\n        if spans.is_empty() {\n            return None;\n        }\n        let mut notes = String::new();\n        for _ in 0..self.line_number_padding() {\n            notes.push(' ');\n        }\n        let mut pos = 0;\n        for span in spans {\n            for _ in pos..(span.start.column - 1) {\n                notes.push(' ');\n                pos += 1;\n            }\n            let note_len = span.end.column.saturating_sub(span.start.column);\n            for _ in 0..core::cmp::max(1, note_len) {\n                notes.push('^');\n                pos += 1;\n            }\n        }\n        Some(notes)\n    }\n\n    /// Left pad the given line number with spaces such that it is aligned with\n    /// other line numbers.\n    fn left_pad_line_number(&self, n: usize) -> String {\n        let n = n.to_string();\n        let pad = self.line_number_width.checked_sub(n.len()).unwrap();\n        let mut result = repeat_char(' ', pad);\n        result.push_str(&n);\n        result\n    }\n\n    /// Return the line number padding beginning at the start of each line of\n    /// the pattern.\n    ///\n    /// If the pattern is only one line, then this returns a fixed padding\n    /// for visual indentation.\n    fn line_number_padding(&self) -> usize {\n        if self.line_number_width == 0 {\n            4\n        } else {\n            2 + self.line_number_width\n        }\n    }\n}"],"hir::Capture":["Clone","Debug","Eq","PartialEq"],"hir::Class":["Clone","Eq","PartialEq","impl Class {\n    /// Apply Unicode simple case folding to this character class, in place.\n    /// The character class will be expanded to include all simple case folded\n    /// character variants.\n    ///\n    /// If this is a byte oriented character class, then this will be limited\n    /// to the ASCII ranges `A-Z` and `a-z`.\n    ///\n    /// # Panics\n    ///\n    /// This routine panics when the case mapping data necessary for this\n    /// routine to complete is unavailable. This occurs when the `unicode-case`\n    /// feature is not enabled and the underlying class is Unicode oriented.\n    ///\n    /// Callers should prefer using `try_case_fold_simple` instead, which will\n    /// return an error instead of panicking.\n    pub fn case_fold_simple(&mut self) {\n        match *self {\n            Class::Unicode(ref mut x) => x.case_fold_simple(),\n            Class::Bytes(ref mut x) => x.case_fold_simple(),\n        }\n    }\n\n    /// Apply Unicode simple case folding to this character class, in place.\n    /// The character class will be expanded to include all simple case folded\n    /// character variants.\n    ///\n    /// If this is a byte oriented character class, then this will be limited\n    /// to the ASCII ranges `A-Z` and `a-z`.\n    ///\n    /// # Error\n    ///\n    /// This routine returns an error when the case mapping data necessary\n    /// for this routine to complete is unavailable. This occurs when the\n    /// `unicode-case` feature is not enabled and the underlying class is\n    /// Unicode oriented.\n    pub fn try_case_fold_simple(\n        &mut self,\n    ) -> core::result::Result<(), CaseFoldError> {\n        match *self {\n            Class::Unicode(ref mut x) => x.try_case_fold_simple()?,\n            Class::Bytes(ref mut x) => x.case_fold_simple(),\n        }\n        Ok(())\n    }\n\n    /// Negate this character class in place.\n    ///\n    /// After completion, this character class will contain precisely the\n    /// characters that weren't previously in the class.\n    pub fn negate(&mut self) {\n        match *self {\n            Class::Unicode(ref mut x) => x.negate(),\n            Class::Bytes(ref mut x) => x.negate(),\n        }\n    }\n\n    /// Returns true if and only if this character class will only ever match\n    /// valid UTF-8.\n    ///\n    /// A character class can match invalid UTF-8 only when the following\n    /// conditions are met:\n    ///\n    /// 1. The translator was configured to permit generating an expression\n    ///    that can match invalid UTF-8. (By default, this is disabled.)\n    /// 2. Unicode mode (via the `u` flag) was disabled either in the concrete\n    ///    syntax or in the parser builder. By default, Unicode mode is\n    ///    enabled.\n    pub fn is_utf8(&self) -> bool {\n        match *self {\n            Class::Unicode(_) => true,\n            Class::Bytes(ref x) => x.is_ascii(),\n        }\n    }\n\n    /// Returns the length, in bytes, of the smallest string matched by this\n    /// character class.\n    ///\n    /// For non-empty byte oriented classes, this always returns `1`. For\n    /// non-empty Unicode oriented classes, this can return `1`, `2`, `3` or\n    /// `4`. For empty classes, `None` is returned. It is impossible for `0` to\n    /// be returned.\n    ///\n    /// # Example\n    ///\n    /// This example shows some examples of regexes and their corresponding\n    /// minimum length, if any.\n    ///\n    /// ```\n    /// use regex_syntax::{hir::Properties, parse};\n    ///\n    /// // The empty string has a min length of 0.\n    /// let hir = parse(r\"\")?;\n    /// assert_eq!(Some(0), hir.properties().minimum_len());\n    /// // As do other types of regexes that only match the empty string.\n    /// let hir = parse(r\"^$\\b\\B\")?;\n    /// assert_eq!(Some(0), hir.properties().minimum_len());\n    /// // A regex that can match the empty string but match more is still 0.\n    /// let hir = parse(r\"a*\")?;\n    /// assert_eq!(Some(0), hir.properties().minimum_len());\n    /// // A regex that matches nothing has no minimum defined.\n    /// let hir = parse(r\"[a&&b]\")?;\n    /// assert_eq!(None, hir.properties().minimum_len());\n    /// // Character classes usually have a minimum length of 1.\n    /// let hir = parse(r\"\\w\")?;\n    /// assert_eq!(Some(1), hir.properties().minimum_len());\n    /// // But sometimes Unicode classes might be bigger!\n    /// let hir = parse(r\"\\p{Cyrillic}\")?;\n    /// assert_eq!(Some(2), hir.properties().minimum_len());\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    pub fn minimum_len(&self) -> Option<usize> {\n        match *self {\n            Class::Unicode(ref x) => x.minimum_len(),\n            Class::Bytes(ref x) => x.minimum_len(),\n        }\n    }\n\n    /// Returns the length, in bytes, of the longest string matched by this\n    /// character class.\n    ///\n    /// For non-empty byte oriented classes, this always returns `1`. For\n    /// non-empty Unicode oriented classes, this can return `1`, `2`, `3` or\n    /// `4`. For empty classes, `None` is returned. It is impossible for `0` to\n    /// be returned.\n    ///\n    /// # Example\n    ///\n    /// This example shows some examples of regexes and their corresponding\n    /// maximum length, if any.\n    ///\n    /// ```\n    /// use regex_syntax::{hir::Properties, parse};\n    ///\n    /// // The empty string has a max length of 0.\n    /// let hir = parse(r\"\")?;\n    /// assert_eq!(Some(0), hir.properties().maximum_len());\n    /// // As do other types of regexes that only match the empty string.\n    /// let hir = parse(r\"^$\\b\\B\")?;\n    /// assert_eq!(Some(0), hir.properties().maximum_len());\n    /// // A regex that matches nothing has no maximum defined.\n    /// let hir = parse(r\"[a&&b]\")?;\n    /// assert_eq!(None, hir.properties().maximum_len());\n    /// // Bounded repeats work as you expect.\n    /// let hir = parse(r\"x{2,10}\")?;\n    /// assert_eq!(Some(10), hir.properties().maximum_len());\n    /// // An unbounded repeat means there is no maximum.\n    /// let hir = parse(r\"x{2,}\")?;\n    /// assert_eq!(None, hir.properties().maximum_len());\n    /// // With Unicode enabled, \\w can match up to 4 bytes!\n    /// let hir = parse(r\"\\w\")?;\n    /// assert_eq!(Some(4), hir.properties().maximum_len());\n    /// // Without Unicode enabled, \\w matches at most 1 byte.\n    /// let hir = parse(r\"(?-u)\\w\")?;\n    /// assert_eq!(Some(1), hir.properties().maximum_len());\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    pub fn maximum_len(&self) -> Option<usize> {\n        match *self {\n            Class::Unicode(ref x) => x.maximum_len(),\n            Class::Bytes(ref x) => x.maximum_len(),\n        }\n    }\n\n    /// Returns true if and only if this character class is empty. That is,\n    /// it has no elements.\n    ///\n    /// An empty character can never match anything, including an empty string.\n    pub fn is_empty(&self) -> bool {\n        match *self {\n            Class::Unicode(ref x) => x.ranges().is_empty(),\n            Class::Bytes(ref x) => x.ranges().is_empty(),\n        }\n    }\n\n    /// If this class consists of exactly one element (whether a codepoint or a\n    /// byte), then return it as a literal byte string.\n    ///\n    /// If this class is empty or contains more than one element, then `None`\n    /// is returned.\n    pub fn literal(&self) -> Option<Vec<u8>> {\n        match *self {\n            Class::Unicode(ref x) => x.literal(),\n            Class::Bytes(ref x) => x.literal(),\n        }\n    }\n}","impl core::fmt::Debug for Class {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        use crate::debug::Byte;\n\n        let mut fmter = f.debug_set();\n        match *self {\n            Class::Unicode(ref cls) => {\n                for r in cls.ranges().iter() {\n                    fmter.entry(&(r.start..=r.end));\n                }\n            }\n            Class::Bytes(ref cls) => {\n                for r in cls.ranges().iter() {\n                    fmter.entry(&(Byte(r.start)..=Byte(r.end)));\n                }\n            }\n        }\n        fmter.finish()\n    }\n}"],"hir::ClassBytes":["Clone","Debug","Eq","PartialEq","impl ClassBytes {\n    /// Create a new class from a sequence of ranges.\n    ///\n    /// The given ranges do not need to be in any specific order, and ranges\n    /// may overlap. Ranges will automatically be sorted into a canonical\n    /// non-overlapping order.\n    pub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,\n    {\n        ClassBytes { set: IntervalSet::new(ranges) }\n    }\n\n    /// Create a new class with no ranges.\n    ///\n    /// An empty class matches nothing. That is, it is equivalent to\n    /// [`Hir::fail`].\n    pub fn empty() -> ClassBytes {\n        ClassBytes::new(vec![])\n    }\n\n    /// Add a new range to this set.\n    pub fn push(&mut self, range: ClassBytesRange) {\n        self.set.push(range);\n    }\n\n    /// Return an iterator over all ranges in this class.\n    ///\n    /// The iterator yields ranges in ascending order.\n    pub fn iter(&self) -> ClassBytesIter<'_> {\n        ClassBytesIter(self.set.iter())\n    }\n\n    /// Return the underlying ranges as a slice.\n    pub fn ranges(&self) -> &[ClassBytesRange] {\n        self.set.intervals()\n    }\n\n    /// Expand this character class such that it contains all case folded\n    /// characters. For example, if this class consists of the range `a-z`,\n    /// then applying case folding will result in the class containing both the\n    /// ranges `a-z` and `A-Z`.\n    ///\n    /// Note that this only applies ASCII case folding, which is limited to the\n    /// characters `a-z` and `A-Z`.\n    pub fn case_fold_simple(&mut self) {\n        self.set.case_fold_simple().expect(\"ASCII case folding never fails\");\n    }\n\n    /// Negate this byte class.\n    ///\n    /// For all `b` where `b` is a any byte, if `b` was in this set, then it\n    /// will not be in this set after negation.\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n\n    /// Union this byte class with the given byte class, in place.\n    pub fn union(&mut self, other: &ClassBytes) {\n        self.set.union(&other.set);\n    }\n\n    /// Intersect this byte class with the given byte class, in place.\n    pub fn intersect(&mut self, other: &ClassBytes) {\n        self.set.intersect(&other.set);\n    }\n\n    /// Subtract the given byte class from this byte class, in place.\n    pub fn difference(&mut self, other: &ClassBytes) {\n        self.set.difference(&other.set);\n    }\n\n    /// Compute the symmetric difference of the given byte classes, in place.\n    ///\n    /// This computes the symmetric difference of two byte classes. This\n    /// removes all elements in this class that are also in the given class,\n    /// but all adds all elements from the given class that aren't in this\n    /// class. That is, the class will contain all elements in either class,\n    /// but will not contain any elements that are in both classes.\n    pub fn symmetric_difference(&mut self, other: &ClassBytes) {\n        self.set.symmetric_difference(&other.set);\n    }\n\n    /// Returns true if and only if this character class will either match\n    /// nothing or only ASCII bytes. Stated differently, this returns false\n    /// if and only if this class contains a non-ASCII byte.\n    pub fn is_ascii(&self) -> bool {\n        self.set.intervals().last().map_or(true, |r| r.end <= 0x7F)\n    }\n\n    /// Returns the length, in bytes, of the smallest string matched by this\n    /// character class.\n    ///\n    /// Returns `None` when the class is empty.\n    pub fn minimum_len(&self) -> Option<usize> {\n        if self.ranges().is_empty() {\n            None\n        } else {\n            Some(1)\n        }\n    }\n\n    /// Returns the length, in bytes, of the longest string matched by this\n    /// character class.\n    ///\n    /// Returns `None` when the class is empty.\n    pub fn maximum_len(&self) -> Option<usize> {\n        if self.ranges().is_empty() {\n            None\n        } else {\n            Some(1)\n        }\n    }\n\n    /// If this class consists of exactly one byte, then return it as\n    /// a literal byte string.\n    ///\n    /// If this class is empty or contains more than one byte, then `None`\n    /// is returned.\n    pub fn literal(&self) -> Option<Vec<u8>> {\n        let rs = self.ranges();\n        if rs.len() == 1 && rs[0].start == rs[0].end {\n            Some(vec![rs[0].start])\n        } else {\n            None\n        }\n    }\n\n    /// If this class consists of only ASCII ranges, then return its\n    /// corresponding and equivalent Unicode class.\n    pub fn to_unicode_class(&self) -> Option<ClassUnicode> {\n        if !self.is_ascii() {\n            return None;\n        }\n        Some(ClassUnicode::new(self.ranges().iter().map(|r| {\n            // Since we are guaranteed that our byte range is ASCII, the\n            // 'char::from' calls below are correct and will not erroneously\n            // convert a raw byte value into its corresponding codepoint.\n            ClassUnicodeRange {\n                start: char::from(r.start),\n                end: char::from(r.end),\n            }\n        })))\n    }\n}"],"hir::ClassBytesIter":["Debug","impl<'a> Iterator for ClassBytesIter<'a> {\n    type Item = &'a ClassBytesRange;\n\n    fn next(&mut self) -> Option<&'a ClassBytesRange> {\n        self.0.next()\n    }\n}"],"hir::ClassBytesRange":["Clone","Copy","Default","Eq","Ord","PartialEq","PartialOrd","impl ClassBytesRange {\n    /// Create a new byte range for a character class.\n    ///\n    /// The returned range is always in a canonical form. That is, the range\n    /// returned always satisfies the invariant that `start <= end`.\n    pub fn new(start: u8, end: u8) -> ClassBytesRange {\n        ClassBytesRange::create(start, end)\n    }\n\n    /// Return the start of this range.\n    ///\n    /// The start of a range is always less than or equal to the end of the\n    /// range.\n    pub fn start(&self) -> u8 {\n        self.start\n    }\n\n    /// Return the end of this range.\n    ///\n    /// The end of a range is always greater than or equal to the start of the\n    /// range.\n    pub fn end(&self) -> u8 {\n        self.end\n    }\n\n    /// Returns the number of bytes in this range.\n    pub fn len(&self) -> usize {\n        usize::from(self.end.checked_sub(self.start).unwrap())\n            .checked_add(1)\n            .unwrap()\n    }\n}","impl Interval for ClassBytesRange {\n    type Bound = u8;\n\n    #[inline]\n    fn lower(&self) -> u8 {\n        self.start\n    }\n    #[inline]\n    fn upper(&self) -> u8 {\n        self.end\n    }\n    #[inline]\n    fn set_lower(&mut self, bound: u8) {\n        self.start = bound;\n    }\n    #[inline]\n    fn set_upper(&mut self, bound: u8) {\n        self.end = bound;\n    }\n\n    /// Apply simple case folding to this byte range. Only ASCII case mappings\n    /// (for a-z) are applied.\n    ///\n    /// Additional ranges are appended to the given vector. Canonical ordering\n    /// is *not* maintained in the given vector.\n    fn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassBytesRange>,\n    ) -> Result<(), unicode::CaseFoldError> {\n        if !ClassBytesRange::new(b'a', b'z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'a');\n            let upper = cmp::min(self.end, b'z');\n            ranges.push(ClassBytesRange::new(lower - 32, upper - 32));\n        }\n        if !ClassBytesRange::new(b'A', b'Z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'A');\n            let upper = cmp::min(self.end, b'Z');\n            ranges.push(ClassBytesRange::new(lower + 32, upper + 32));\n        }\n        Ok(())\n    }\n}","impl core::fmt::Debug for ClassBytesRange {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"ClassBytesRange\")\n            .field(\"start\", &crate::debug::Byte(self.start))\n            .field(\"end\", &crate::debug::Byte(self.end))\n            .finish()\n    }\n}"],"hir::ClassUnicode":["Clone","Debug","Eq","PartialEq","impl ClassUnicode {\n    /// Create a new class from a sequence of ranges.\n    ///\n    /// The given ranges do not need to be in any specific order, and ranges\n    /// may overlap. Ranges will automatically be sorted into a canonical\n    /// non-overlapping order.\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {\n        ClassUnicode { set: IntervalSet::new(ranges) }\n    }\n\n    /// Create a new class with no ranges.\n    ///\n    /// An empty class matches nothing. That is, it is equivalent to\n    /// [`Hir::fail`].\n    pub fn empty() -> ClassUnicode {\n        ClassUnicode::new(vec![])\n    }\n\n    /// Add a new range to this set.\n    pub fn push(&mut self, range: ClassUnicodeRange) {\n        self.set.push(range);\n    }\n\n    /// Return an iterator over all ranges in this class.\n    ///\n    /// The iterator yields ranges in ascending order.\n    pub fn iter(&self) -> ClassUnicodeIter<'_> {\n        ClassUnicodeIter(self.set.iter())\n    }\n\n    /// Return the underlying ranges as a slice.\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {\n        self.set.intervals()\n    }\n\n    /// Expand this character class such that it contains all case folded\n    /// characters, according to Unicode's \"simple\" mapping. For example, if\n    /// this class consists of the range `a-z`, then applying case folding will\n    /// result in the class containing both the ranges `a-z` and `A-Z`.\n    ///\n    /// # Panics\n    ///\n    /// This routine panics when the case mapping data necessary for this\n    /// routine to complete is unavailable. This occurs when the `unicode-case`\n    /// feature is not enabled.\n    ///\n    /// Callers should prefer using `try_case_fold_simple` instead, which will\n    /// return an error instead of panicking.\n    pub fn case_fold_simple(&mut self) {\n        self.set\n            .case_fold_simple()\n            .expect(\"unicode-case feature must be enabled\");\n    }\n\n    /// Expand this character class such that it contains all case folded\n    /// characters, according to Unicode's \"simple\" mapping. For example, if\n    /// this class consists of the range `a-z`, then applying case folding will\n    /// result in the class containing both the ranges `a-z` and `A-Z`.\n    ///\n    /// # Error\n    ///\n    /// This routine returns an error when the case mapping data necessary\n    /// for this routine to complete is unavailable. This occurs when the\n    /// `unicode-case` feature is not enabled.\n    pub fn try_case_fold_simple(\n        &mut self,\n    ) -> core::result::Result<(), CaseFoldError> {\n        self.set.case_fold_simple()\n    }\n\n    /// Negate this character class.\n    ///\n    /// For all `c` where `c` is a Unicode scalar value, if `c` was in this\n    /// set, then it will not be in this set after negation.\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n\n    /// Union this character class with the given character class, in place.\n    pub fn union(&mut self, other: &ClassUnicode) {\n        self.set.union(&other.set);\n    }\n\n    /// Intersect this character class with the given character class, in\n    /// place.\n    pub fn intersect(&mut self, other: &ClassUnicode) {\n        self.set.intersect(&other.set);\n    }\n\n    /// Subtract the given character class from this character class, in place.\n    pub fn difference(&mut self, other: &ClassUnicode) {\n        self.set.difference(&other.set);\n    }\n\n    /// Compute the symmetric difference of the given character classes, in\n    /// place.\n    ///\n    /// This computes the symmetric difference of two character classes. This\n    /// removes all elements in this class that are also in the given class,\n    /// but all adds all elements from the given class that aren't in this\n    /// class. That is, the class will contain all elements in either class,\n    /// but will not contain any elements that are in both classes.\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {\n        self.set.symmetric_difference(&other.set);\n    }\n\n    /// Returns true if and only if this character class will either match\n    /// nothing or only ASCII bytes. Stated differently, this returns false\n    /// if and only if this class contains a non-ASCII codepoint.\n    pub fn is_ascii(&self) -> bool {\n        self.set.intervals().last().map_or(true, |r| r.end <= '\\x7F')\n    }\n\n    /// Returns the length, in bytes, of the smallest string matched by this\n    /// character class.\n    ///\n    /// Returns `None` when the class is empty.\n    pub fn minimum_len(&self) -> Option<usize> {\n        let first = self.ranges().get(0)?;\n        // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().\n        Some(first.start.len_utf8())\n    }\n\n    /// Returns the length, in bytes, of the longest string matched by this\n    /// character class.\n    ///\n    /// Returns `None` when the class is empty.\n    pub fn maximum_len(&self) -> Option<usize> {\n        let last = self.ranges().last()?;\n        // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().\n        Some(last.end.len_utf8())\n    }\n\n    /// If this class consists of exactly one codepoint, then return it as\n    /// a literal byte string.\n    ///\n    /// If this class is empty or contains more than one codepoint, then `None`\n    /// is returned.\n    pub fn literal(&self) -> Option<Vec<u8>> {\n        let rs = self.ranges();\n        if rs.len() == 1 && rs[0].start == rs[0].end {\n            Some(rs[0].start.encode_utf8(&mut [0; 4]).to_string().into_bytes())\n        } else {\n            None\n        }\n    }\n\n    /// If this class consists of only ASCII ranges, then return its\n    /// corresponding and equivalent byte class.\n    pub fn to_byte_class(&self) -> Option<ClassBytes> {\n        if !self.is_ascii() {\n            return None;\n        }\n        Some(ClassBytes::new(self.ranges().iter().map(|r| {\n            // Since we are guaranteed that our codepoint range is ASCII, the\n            // 'u8::try_from' calls below are guaranteed to be correct.\n            ClassBytesRange {\n                start: u8::try_from(r.start).unwrap(),\n                end: u8::try_from(r.end).unwrap(),\n            }\n        })))\n    }\n}"],"hir::ClassUnicodeIter":["Debug","impl<'a> Iterator for ClassUnicodeIter<'a> {\n    type Item = &'a ClassUnicodeRange;\n\n    fn next(&mut self) -> Option<&'a ClassUnicodeRange> {\n        self.0.next()\n    }\n}"],"hir::ClassUnicodeRange":["Clone","Copy","Default","Eq","Ord","PartialEq","PartialOrd","impl ClassUnicodeRange {\n    /// Create a new Unicode scalar value range for a character class.\n    ///\n    /// The returned range is always in a canonical form. That is, the range\n    /// returned always satisfies the invariant that `start <= end`.\n    pub fn new(start: char, end: char) -> ClassUnicodeRange {\n        ClassUnicodeRange::create(start, end)\n    }\n\n    /// Return the start of this range.\n    ///\n    /// The start of a range is always less than or equal to the end of the\n    /// range.\n    pub fn start(&self) -> char {\n        self.start\n    }\n\n    /// Return the end of this range.\n    ///\n    /// The end of a range is always greater than or equal to the start of the\n    /// range.\n    pub fn end(&self) -> char {\n        self.end\n    }\n\n    /// Returns the number of codepoints in this range.\n    pub fn len(&self) -> usize {\n        let diff = 1 + u32::from(self.end) - u32::from(self.start);\n        // This is likely to panic in 16-bit targets since a usize can only fit\n        // 2^16. It's not clear what to do here, other than to return an error\n        // when building a Unicode class that contains a range whose length\n        // overflows usize. (Which, to be honest, is probably quite common on\n        // 16-bit targets. For example, this would imply that '.' and '\\p{any}'\n        // would be impossible to build.)\n        usize::try_from(diff).expect(\"char class len fits in usize\")\n    }\n}","impl Interval for ClassUnicodeRange {\n    type Bound = char;\n\n    #[inline]\n    fn lower(&self) -> char {\n        self.start\n    }\n    #[inline]\n    fn upper(&self) -> char {\n        self.end\n    }\n    #[inline]\n    fn set_lower(&mut self, bound: char) {\n        self.start = bound;\n    }\n    #[inline]\n    fn set_upper(&mut self, bound: char) {\n        self.end = bound;\n    }\n\n    /// Apply simple case folding to this Unicode scalar value range.\n    ///\n    /// Additional ranges are appended to the given vector. Canonical ordering\n    /// is *not* maintained in the given vector.\n    fn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassUnicodeRange>,\n    ) -> Result<(), unicode::CaseFoldError> {\n        let mut folder = unicode::SimpleCaseFolder::new()?;\n        if !folder.overlaps(self.start, self.end) {\n            return Ok(());\n        }\n        let (start, end) = (u32::from(self.start), u32::from(self.end));\n        for cp in (start..=end).filter_map(char::from_u32) {\n            for &cp_folded in folder.mapping(cp) {\n                ranges.push(ClassUnicodeRange::new(cp_folded, cp_folded));\n            }\n        }\n        Ok(())\n    }\n}","impl core::fmt::Debug for ClassUnicodeRange {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let start = if !self.start.is_whitespace() && !self.start.is_control()\n        {\n            self.start.to_string()\n        } else {\n            format!(\"0x{:X}\", u32::from(self.start))\n        };\n        let end = if !self.end.is_whitespace() && !self.end.is_control() {\n            self.end.to_string()\n        } else {\n            format!(\"0x{:X}\", u32::from(self.end))\n        };\n        f.debug_struct(\"ClassUnicodeRange\")\n            .field(\"start\", &start)\n            .field(\"end\", &end)\n            .finish()\n    }\n}"],"hir::Dot":["Clone","Copy","Debug","Eq","PartialEq"],"hir::Error":["Clone","Debug","Eq","PartialEq","impl Error {\n    /// Return the type of this error.\n    pub fn kind(&self) -> &ErrorKind {\n        &self.kind\n    }\n\n    /// The original pattern string in which this error occurred.\n    ///\n    /// Every span reported by this error is reported in terms of this string.\n    pub fn pattern(&self) -> &str {\n        &self.pattern\n    }\n\n    /// Return the span at which this error occurred.\n    pub fn span(&self) -> &Span {\n        &self.span\n    }\n}","impl core::fmt::Display for Error {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        crate::error::Formatter::from(self).fmt(f)\n    }\n}","impl std::error::Error for Error {}"],"hir::ErrorKind":["Clone","Debug","Eq","PartialEq","impl core::fmt::Display for ErrorKind {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        use self::ErrorKind::*;\n\n        let msg = match *self {\n            UnicodeNotAllowed => \"Unicode not allowed here\",\n            InvalidUtf8 => \"pattern can match invalid UTF-8\",\n            UnicodePropertyNotFound => \"Unicode property not found\",\n            UnicodePropertyValueNotFound => \"Unicode property value not found\",\n            UnicodePerlClassNotFound => {\n                \"Unicode-aware Perl class not found \\\n                 (make sure the unicode-perl feature is enabled)\"\n            }\n            UnicodeCaseUnavailable => {\n                \"Unicode-aware case insensitivity matching is not available \\\n                 (make sure the unicode-case feature is enabled)\"\n            }\n        };\n        f.write_str(msg)\n    }\n}"],"hir::Hir":["Clone","Eq","PartialEq","impl Drop for Hir {\n    fn drop(&mut self) {\n        use core::mem;\n\n        match *self.kind() {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Look(_) => return,\n            HirKind::Capture(ref x) if x.sub.kind.subs().is_empty() => return,\n            HirKind::Repetition(ref x) if x.sub.kind.subs().is_empty() => {\n                return\n            }\n            HirKind::Concat(ref x) if x.is_empty() => return,\n            HirKind::Alternation(ref x) if x.is_empty() => return,\n            _ => {}\n        }\n\n        let mut stack = vec![mem::replace(self, Hir::empty())];\n        while let Some(mut expr) = stack.pop() {\n            match expr.kind {\n                HirKind::Empty\n                | HirKind::Literal(_)\n                | HirKind::Class(_)\n                | HirKind::Look(_) => {}\n                HirKind::Capture(ref mut x) => {\n                    stack.push(mem::replace(&mut x.sub, Hir::empty()));\n                }\n                HirKind::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.sub, Hir::empty()));\n                }\n                HirKind::Concat(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n                HirKind::Alternation(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n            }\n        }\n    }\n}","impl Hir {\n    /// Returns a reference to the underlying HIR kind.\n    pub fn kind(&self) -> &HirKind {\n        &self.kind\n    }\n\n    /// Consumes ownership of this HIR expression and returns its underlying\n    /// `HirKind`.\n    pub fn into_kind(mut self) -> HirKind {\n        core::mem::replace(&mut self.kind, HirKind::Empty)\n    }\n\n    /// Returns the properties computed for this `Hir`.\n    pub fn properties(&self) -> &Properties {\n        &self.props\n    }\n\n    /// Splits this HIR into its constituent parts.\n    ///\n    /// This is useful because `let Hir { kind, props } = hir;` does not work\n    /// because of `Hir`'s custom `Drop` implementation.\n    fn into_parts(mut self) -> (HirKind, Properties) {\n        (\n            core::mem::replace(&mut self.kind, HirKind::Empty),\n            core::mem::replace(&mut self.props, Properties::empty()),\n        )\n    }\n}","impl Hir {\n    /// Returns an empty HIR expression.\n    ///\n    /// An empty HIR expression always matches, including the empty string.\n    #[inline]\n    pub fn empty() -> Hir {\n        let props = Properties::empty();\n        Hir { kind: HirKind::Empty, props }\n    }\n\n    /// Returns an HIR expression that can never match anything. That is,\n    /// the size of the set of strings in the language described by the HIR\n    /// returned is `0`.\n    ///\n    /// This is distinct from [`Hir::empty`] in that the empty string matches\n    /// the HIR returned by `Hir::empty`. That is, the set of strings in the\n    /// language describe described by `Hir::empty` is non-empty.\n    ///\n    /// Note that currently, the HIR returned uses an empty character class to\n    /// indicate that nothing can match. An equivalent expression that cannot\n    /// match is an empty alternation, but all such \"fail\" expressions are\n    /// normalized (via smart constructors) to empty character classes. This is\n    /// because empty character classes can be spelled in the concrete syntax\n    /// of a regex (e.g., `\\P{any}` or `(?-u:[^\\x00-\\xFF])` or `[a&&b]`), but\n    /// empty alternations cannot.\n    #[inline]\n    pub fn fail() -> Hir {\n        let class = Class::Bytes(ClassBytes::empty());\n        let props = Properties::class(&class);\n        // We can't just call Hir::class here because it defers to Hir::fail\n        // in order to canonicalize the Hir value used to represent \"cannot\n        // match.\"\n        Hir { kind: HirKind::Class(class), props }\n    }\n\n    /// Creates a literal HIR expression.\n    ///\n    /// This accepts anything that can be converted into a `Box<[u8]>`.\n    ///\n    /// Note that there is no mechanism for storing a `char` or a `Box<str>`\n    /// in an HIR. Everything is \"just bytes.\" Whether a `Literal` (or\n    /// any HIR node) matches valid UTF-8 exclusively can be queried via\n    /// [`Properties::is_utf8`].\n    ///\n    /// # Example\n    ///\n    /// This example shows that concatenations of `Literal` HIR values will\n    /// automatically get flattened and combined together. So for example, even\n    /// if you concat multiple `Literal` values that are themselves not valid\n    /// UTF-8, they might add up to valid UTF-8. This also demonstrates just\n    /// how \"smart\" Hir's smart constructors are.\n    ///\n    /// ```\n    /// use regex_syntax::hir::{Hir, HirKind, Literal};\n    ///\n    /// let literals = vec![\n    ///     Hir::literal([0xE2]),\n    ///     Hir::literal([0x98]),\n    ///     Hir::literal([0x83]),\n    /// ];\n    /// // Each literal, on its own, is invalid UTF-8.\n    /// assert!(literals.iter().all(|hir| !hir.properties().is_utf8()));\n    ///\n    /// let concat = Hir::concat(literals);\n    /// // But the concatenation is valid UTF-8!\n    /// assert!(concat.properties().is_utf8());\n    ///\n    /// // And also notice that the literals have been concatenated into a\n    /// // single `Literal`, to the point where there is no explicit `Concat`!\n    /// let expected = HirKind::Literal(Literal(Box::from(\"☃\".as_bytes())));\n    /// assert_eq!(&expected, concat.kind());\n    /// ```\n    #[inline]\n    pub fn literal<B: Into<Box<[u8]>>>(lit: B) -> Hir {\n        let bytes = lit.into();\n        if bytes.is_empty() {\n            return Hir::empty();\n        }\n\n        let lit = Literal(bytes);\n        let props = Properties::literal(&lit);\n        Hir { kind: HirKind::Literal(lit), props }\n    }\n\n    /// Creates a class HIR expression. The class may either be defined over\n    /// ranges of Unicode codepoints or ranges of raw byte values.\n    ///\n    /// Note that an empty class is permitted. An empty class is equivalent to\n    /// `Hir::fail()`.\n    #[inline]\n    pub fn class(class: Class) -> Hir {\n        if class.is_empty() {\n            return Hir::fail();\n        } else if let Some(bytes) = class.literal() {\n            return Hir::literal(bytes);\n        }\n        let props = Properties::class(&class);\n        Hir { kind: HirKind::Class(class), props }\n    }\n\n    /// Creates a look-around assertion HIR expression.\n    #[inline]\n    pub fn look(look: Look) -> Hir {\n        let props = Properties::look(look);\n        Hir { kind: HirKind::Look(look), props }\n    }\n\n    /// Creates a repetition HIR expression.\n    #[inline]\n    pub fn repetition(rep: Repetition) -> Hir {\n        // The regex 'a{0}' is always equivalent to the empty regex. This is\n        // true even when 'a' is an expression that never matches anything\n        // (like '\\P{any}').\n        //\n        // Additionally, the regex 'a{1}' is always equivalent to 'a'.\n        if rep.min == 0 && rep.max == Some(0) {\n            return Hir::empty();\n        } else if rep.min == 1 && rep.max == Some(1) {\n            return *rep.sub;\n        }\n        let props = Properties::repetition(&rep);\n        Hir { kind: HirKind::Repetition(rep), props }\n    }\n\n    /// Creates a capture HIR expression.\n    ///\n    /// Note that there is no explicit HIR value for a non-capturing group.\n    /// Since a non-capturing group only exists to override precedence in the\n    /// concrete syntax and since an HIR already does its own grouping based on\n    /// what is parsed, there is no need to explicitly represent non-capturing\n    /// groups in the HIR.\n    #[inline]\n    pub fn capture(capture: Capture) -> Hir {\n        let props = Properties::capture(&capture);\n        Hir { kind: HirKind::Capture(capture), props }\n    }\n\n    /// Returns the concatenation of the given expressions.\n    ///\n    /// This attempts to flatten and simplify the concatenation as appropriate.\n    ///\n    /// # Example\n    ///\n    /// This shows a simple example of basic flattening of both concatenations\n    /// and literals.\n    ///\n    /// ```\n    /// use regex_syntax::hir::Hir;\n    ///\n    /// let hir = Hir::concat(vec![\n    ///     Hir::concat(vec![\n    ///         Hir::literal([b'a']),\n    ///         Hir::literal([b'b']),\n    ///         Hir::literal([b'c']),\n    ///     ]),\n    ///     Hir::concat(vec![\n    ///         Hir::literal([b'x']),\n    ///         Hir::literal([b'y']),\n    ///         Hir::literal([b'z']),\n    ///     ]),\n    /// ]);\n    /// let expected = Hir::literal(\"abcxyz\".as_bytes());\n    /// assert_eq!(expected, hir);\n    /// ```\n    pub fn concat(subs: Vec<Hir>) -> Hir {\n        // We rebuild the concatenation by simplifying it. Would be nice to do\n        // it in place, but that seems a little tricky?\n        let mut new = vec![];\n        // This gobbles up any adjacent literals in a concatenation and smushes\n        // them together. Basically, when we see a literal, we add its bytes\n        // to 'prior_lit', and whenever we see anything else, we first take\n        // any bytes in 'prior_lit' and add it to the 'new' concatenation.\n        let mut prior_lit: Option<Vec<u8>> = None;\n        for sub in subs {\n            let (kind, props) = sub.into_parts();\n            match kind {\n                HirKind::Literal(Literal(bytes)) => {\n                    if let Some(ref mut prior_bytes) = prior_lit {\n                        prior_bytes.extend_from_slice(&bytes);\n                    } else {\n                        prior_lit = Some(bytes.to_vec());\n                    }\n                }\n                // We also flatten concats that are direct children of another\n                // concat. We only need to do this one level deep since\n                // Hir::concat is the only way to build concatenations, and so\n                // flattening happens inductively.\n                HirKind::Concat(subs2) => {\n                    for sub2 in subs2 {\n                        let (kind2, props2) = sub2.into_parts();\n                        match kind2 {\n                            HirKind::Literal(Literal(bytes)) => {\n                                if let Some(ref mut prior_bytes) = prior_lit {\n                                    prior_bytes.extend_from_slice(&bytes);\n                                } else {\n                                    prior_lit = Some(bytes.to_vec());\n                                }\n                            }\n                            kind2 => {\n                                if let Some(prior_bytes) = prior_lit.take() {\n                                    new.push(Hir::literal(prior_bytes));\n                                }\n                                new.push(Hir { kind: kind2, props: props2 });\n                            }\n                        }\n                    }\n                }\n                // We can just skip empty HIRs.\n                HirKind::Empty => {}\n                kind => {\n                    if let Some(prior_bytes) = prior_lit.take() {\n                        new.push(Hir::literal(prior_bytes));\n                    }\n                    new.push(Hir { kind, props });\n                }\n            }\n        }\n        if let Some(prior_bytes) = prior_lit.take() {\n            new.push(Hir::literal(prior_bytes));\n        }\n        if new.is_empty() {\n            return Hir::empty();\n        } else if new.len() == 1 {\n            return new.pop().unwrap();\n        }\n        let props = Properties::concat(&new);\n        Hir { kind: HirKind::Concat(new), props }\n    }\n\n    /// Returns the alternation of the given expressions.\n    ///\n    /// This flattens and simplifies the alternation as appropriate. This may\n    /// include factoring out common prefixes or even rewriting the alternation\n    /// as a character class.\n    ///\n    /// Note that an empty alternation is equivalent to `Hir::fail()`. (It\n    /// is not possible for one to write an empty alternation, or even an\n    /// alternation with a single sub-expression, in the concrete syntax of a\n    /// regex.)\n    ///\n    /// # Example\n    ///\n    /// This is a simple example showing how an alternation might get\n    /// simplified.\n    ///\n    /// ```\n    /// use regex_syntax::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};\n    ///\n    /// let hir = Hir::alternation(vec![\n    ///     Hir::literal([b'a']),\n    ///     Hir::literal([b'b']),\n    ///     Hir::literal([b'c']),\n    ///     Hir::literal([b'd']),\n    ///     Hir::literal([b'e']),\n    ///     Hir::literal([b'f']),\n    /// ]);\n    /// let expected = Hir::class(Class::Unicode(ClassUnicode::new([\n    ///     ClassUnicodeRange::new('a', 'f'),\n    /// ])));\n    /// assert_eq!(expected, hir);\n    /// ```\n    ///\n    /// And another example showing how common prefixes might get factored\n    /// out.\n    ///\n    /// ```\n    /// use regex_syntax::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};\n    ///\n    /// let hir = Hir::alternation(vec![\n    ///     Hir::concat(vec![\n    ///         Hir::literal(\"abc\".as_bytes()),\n    ///         Hir::class(Class::Unicode(ClassUnicode::new([\n    ///             ClassUnicodeRange::new('A', 'Z'),\n    ///         ]))),\n    ///     ]),\n    ///     Hir::concat(vec![\n    ///         Hir::literal(\"abc\".as_bytes()),\n    ///         Hir::class(Class::Unicode(ClassUnicode::new([\n    ///             ClassUnicodeRange::new('a', 'z'),\n    ///         ]))),\n    ///     ]),\n    /// ]);\n    /// let expected = Hir::concat(vec![\n    ///     Hir::literal(\"abc\".as_bytes()),\n    ///     Hir::alternation(vec![\n    ///         Hir::class(Class::Unicode(ClassUnicode::new([\n    ///             ClassUnicodeRange::new('A', 'Z'),\n    ///         ]))),\n    ///         Hir::class(Class::Unicode(ClassUnicode::new([\n    ///             ClassUnicodeRange::new('a', 'z'),\n    ///         ]))),\n    ///     ]),\n    /// ]);\n    /// assert_eq!(expected, hir);\n    /// ```\n    ///\n    /// Note that these sorts of simplifications are not guaranteed.\n    pub fn alternation(subs: Vec<Hir>) -> Hir {\n        // We rebuild the alternation by simplifying it. We proceed similarly\n        // as the concatenation case. But in this case, there's no literal\n        // simplification happening. We're just flattening alternations.\n        let mut new = vec![];\n        for sub in subs {\n            let (kind, props) = sub.into_parts();\n            match kind {\n                HirKind::Alternation(subs2) => {\n                    new.extend(subs2);\n                }\n                kind => {\n                    new.push(Hir { kind, props });\n                }\n            }\n        }\n        if new.is_empty() {\n            return Hir::fail();\n        } else if new.len() == 1 {\n            return new.pop().unwrap();\n        }\n        // Now that it's completely flattened, look for the special case of\n        // 'char1|char2|...|charN' and collapse that into a class. Note that\n        // we look for 'char' first and then bytes. The issue here is that if\n        // we find both non-ASCII codepoints and non-ASCII singleton bytes,\n        // then it isn't actually possible to smush them into a single class.\n        // (Because classes are either \"all codepoints\" or \"all bytes.\" You\n        // can have a class that both matches non-ASCII but valid UTF-8 and\n        // invalid UTF-8.) So we look for all chars and then all bytes, and\n        // don't handle anything else.\n        if let Some(singletons) = singleton_chars(&new) {\n            let it = singletons\n                .into_iter()\n                .map(|ch| ClassUnicodeRange { start: ch, end: ch });\n            return Hir::class(Class::Unicode(ClassUnicode::new(it)));\n        }\n        if let Some(singletons) = singleton_bytes(&new) {\n            let it = singletons\n                .into_iter()\n                .map(|b| ClassBytesRange { start: b, end: b });\n            return Hir::class(Class::Bytes(ClassBytes::new(it)));\n        }\n        // Similar to singleton chars, we can also look for alternations of\n        // classes. Those can be smushed into a single class.\n        if let Some(cls) = class_chars(&new) {\n            return Hir::class(cls);\n        }\n        if let Some(cls) = class_bytes(&new) {\n            return Hir::class(cls);\n        }\n        // Factor out a common prefix if we can, which might potentially\n        // simplify the expression and unlock other optimizations downstream.\n        // It also might generally make NFA matching and DFA construction\n        // faster by reducing the scope of branching in the regex.\n        new = match lift_common_prefix(new) {\n            Ok(hir) => return hir,\n            Err(unchanged) => unchanged,\n        };\n        let props = Properties::alternation(&new);\n        Hir { kind: HirKind::Alternation(new), props }\n    }\n\n    /// Returns an HIR expression for `.`.\n    ///\n    /// * [`Dot::AnyChar`] maps to `(?su-R:.)`.\n    /// * [`Dot::AnyByte`] maps to `(?s-Ru:.)`.\n    /// * [`Dot::AnyCharExceptLF`] maps to `(?u-Rs:.)`.\n    /// * [`Dot::AnyCharExceptCRLF`] maps to `(?Ru-s:.)`.\n    /// * [`Dot::AnyByteExceptLF`] maps to `(?-Rsu:.)`.\n    /// * [`Dot::AnyByteExceptCRLF`] maps to `(?R-su:.)`.\n    ///\n    /// # Example\n    ///\n    /// Note that this is a convenience routine for constructing the correct\n    /// character class based on the value of `Dot`. There is no explicit \"dot\"\n    /// HIR value. It is just an abbreviation for a common character class.\n    ///\n    /// ```\n    /// use regex_syntax::hir::{Hir, Dot, Class, ClassBytes, ClassBytesRange};\n    ///\n    /// let hir = Hir::dot(Dot::AnyByte);\n    /// let expected = Hir::class(Class::Bytes(ClassBytes::new([\n    ///     ClassBytesRange::new(0x00, 0xFF),\n    /// ])));\n    /// assert_eq!(expected, hir);\n    /// ```\n    #[inline]\n    pub fn dot(dot: Dot) -> Hir {\n        match dot {\n            Dot::AnyChar => {\n                let mut cls = ClassUnicode::empty();\n                cls.push(ClassUnicodeRange::new('\\0', '\\u{10FFFF}'));\n                Hir::class(Class::Unicode(cls))\n            }\n            Dot::AnyByte => {\n                let mut cls = ClassBytes::empty();\n                cls.push(ClassBytesRange::new(b'\\0', b'\\xFF'));\n                Hir::class(Class::Bytes(cls))\n            }\n            Dot::AnyCharExceptLF => {\n                let mut cls = ClassUnicode::empty();\n                cls.push(ClassUnicodeRange::new('\\0', '\\x09'));\n                cls.push(ClassUnicodeRange::new('\\x0B', '\\u{10FFFF}'));\n                Hir::class(Class::Unicode(cls))\n            }\n            Dot::AnyCharExceptCRLF => {\n                let mut cls = ClassUnicode::empty();\n                cls.push(ClassUnicodeRange::new('\\0', '\\x09'));\n                cls.push(ClassUnicodeRange::new('\\x0B', '\\x0C'));\n                cls.push(ClassUnicodeRange::new('\\x0E', '\\u{10FFFF}'));\n                Hir::class(Class::Unicode(cls))\n            }\n            Dot::AnyByteExceptLF => {\n                let mut cls = ClassBytes::empty();\n                cls.push(ClassBytesRange::new(b'\\0', b'\\x09'));\n                cls.push(ClassBytesRange::new(b'\\x0B', b'\\xFF'));\n                Hir::class(Class::Bytes(cls))\n            }\n            Dot::AnyByteExceptCRLF => {\n                let mut cls = ClassBytes::empty();\n                cls.push(ClassBytesRange::new(b'\\0', b'\\x09'));\n                cls.push(ClassBytesRange::new(b'\\x0B', b'\\x0C'));\n                cls.push(ClassBytesRange::new(b'\\x0E', b'\\xFF'));\n                Hir::class(Class::Bytes(cls))\n            }\n        }\n    }\n}","impl core::fmt::Debug for Hir {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        self.kind.fmt(f)\n    }\n}","impl core::fmt::Display for Hir {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        crate::hir::print::Printer::new().print(self, f)\n    }\n}"],"hir::HirKind":["Clone","Debug","Eq","PartialEq","impl HirKind {\n    /// Returns a slice of this kind's sub-expressions, if any.\n    pub fn subs(&self) -> &[Hir] {\n        use core::slice::from_ref;\n\n        match *self {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Look(_) => &[],\n            HirKind::Repetition(Repetition { ref sub, .. }) => from_ref(sub),\n            HirKind::Capture(Capture { ref sub, .. }) => from_ref(sub),\n            HirKind::Concat(ref subs) => subs,\n            HirKind::Alternation(ref subs) => subs,\n        }\n    }\n}"],"hir::Literal":["Clone","Eq","PartialEq","impl core::fmt::Debug for Literal {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        crate::debug::Bytes(&self.0).fmt(f)\n    }\n}"],"hir::Look":["Clone","Copy","Debug","Eq","PartialEq","impl Look {\n    /// Flip the look-around assertion to its equivalent for reverse searches.\n    /// For example, `StartLF` gets translated to `EndLF`.\n    ///\n    /// Some assertions, such as `WordUnicode`, remain the same since they\n    /// match the same positions regardless of the direction of the search.\n    #[inline]\n    pub const fn reversed(self) -> Look {\n        match self {\n            Look::Start => Look::End,\n            Look::End => Look::Start,\n            Look::StartLF => Look::EndLF,\n            Look::EndLF => Look::StartLF,\n            Look::StartCRLF => Look::EndCRLF,\n            Look::EndCRLF => Look::StartCRLF,\n            Look::WordAscii => Look::WordAscii,\n            Look::WordAsciiNegate => Look::WordAsciiNegate,\n            Look::WordUnicode => Look::WordUnicode,\n            Look::WordUnicodeNegate => Look::WordUnicodeNegate,\n        }\n    }\n\n    /// Return the underlying representation of this look-around enumeration\n    /// as an integer. Giving the return value to the [`Look::from_repr`]\n    /// constructor is guaranteed to return the same look-around variant that\n    /// one started with within a semver compatible release of this crate.\n    #[inline]\n    pub const fn as_repr(self) -> u16 {\n        // AFAIK, 'as' is the only way to zero-cost convert an int enum to an\n        // actual int.\n        self as u16\n    }\n\n    /// Given the underlying representation of a `Look` value, return the\n    /// corresponding `Look` value if the representation is valid. Otherwise\n    /// `None` is returned.\n    #[inline]\n    pub const fn from_repr(repr: u16) -> Option<Look> {\n        match repr {\n            0b00_0000_0001 => Some(Look::Start),\n            0b00_0000_0010 => Some(Look::End),\n            0b00_0000_0100 => Some(Look::StartLF),\n            0b00_0000_1000 => Some(Look::EndLF),\n            0b00_0001_0000 => Some(Look::StartCRLF),\n            0b00_0010_0000 => Some(Look::EndCRLF),\n            0b00_0100_0000 => Some(Look::WordAscii),\n            0b00_1000_0000 => Some(Look::WordAsciiNegate),\n            0b01_0000_0000 => Some(Look::WordUnicode),\n            0b10_0000_0000 => Some(Look::WordUnicodeNegate),\n            _ => None,\n        }\n    }\n\n    /// Returns a convenient single codepoint representation of this\n    /// look-around assertion. Each assertion is guaranteed to be represented\n    /// by a distinct character.\n    ///\n    /// This is useful for succinctly representing a look-around assertion in\n    /// human friendly but succinct output intended for a programmer working on\n    /// regex internals.\n    #[inline]\n    pub const fn as_char(self) -> char {\n        match self {\n            Look::Start => 'A',\n            Look::End => 'z',\n            Look::StartLF => '^',\n            Look::EndLF => '$',\n            Look::StartCRLF => 'r',\n            Look::EndCRLF => 'R',\n            Look::WordAscii => 'b',\n            Look::WordAsciiNegate => 'B',\n            Look::WordUnicode => '𝛃',\n            Look::WordUnicodeNegate => '𝚩',\n        }\n    }\n}"],"hir::LookSet":["Clone","Copy","Default","Eq","PartialEq","impl LookSet {\n    /// Create an empty set of look-around assertions.\n    #[inline]\n    pub fn empty() -> LookSet {\n        LookSet { bits: 0 }\n    }\n\n    /// Create a full set of look-around assertions.\n    ///\n    /// This set contains all possible look-around assertions.\n    #[inline]\n    pub fn full() -> LookSet {\n        LookSet { bits: !0 }\n    }\n\n    /// Create a look-around set containing the look-around assertion given.\n    ///\n    /// This is a convenience routine for creating an empty set and inserting\n    /// one look-around assertions.\n    #[inline]\n    pub fn singleton(look: Look) -> LookSet {\n        LookSet::empty().insert(look)\n    }\n\n    /// Returns the total number of look-around assertions in this set.\n    #[inline]\n    pub fn len(self) -> usize {\n        // OK because max value always fits in a u8, which in turn always\n        // fits in a usize, regardless of target.\n        usize::try_from(self.bits.count_ones()).unwrap()\n    }\n\n    /// Returns true if and only if this set is empty.\n    #[inline]\n    pub fn is_empty(self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns true if and only if the given look-around assertion is in this\n    /// set.\n    #[inline]\n    pub fn contains(self, look: Look) -> bool {\n        self.bits & look.as_repr() != 0\n    }\n\n    /// Returns true if and only if this set contains any anchor assertions.\n    /// This includes both \"start/end of haystack\" and \"start/end of line.\"\n    #[inline]\n    pub fn contains_anchor(&self) -> bool {\n        self.contains_anchor_haystack() || self.contains_anchor_line()\n    }\n\n    /// Returns true if and only if this set contains any \"start/end of\n    /// haystack\" anchors. This doesn't include \"start/end of line\" anchors.\n    #[inline]\n    pub fn contains_anchor_haystack(&self) -> bool {\n        self.contains(Look::Start) || self.contains(Look::End)\n    }\n\n    /// Returns true if and only if this set contains any \"start/end of line\"\n    /// anchors. This doesn't include \"start/end of haystack\" anchors. This\n    /// includes both `\\n` line anchors and CRLF (`\\r\\n`) aware line anchors.\n    #[inline]\n    pub fn contains_anchor_line(&self) -> bool {\n        self.contains(Look::StartLF)\n            || self.contains(Look::EndLF)\n            || self.contains(Look::StartCRLF)\n            || self.contains(Look::EndCRLF)\n    }\n\n    /// Returns true if and only if this set contains any \"start/end of line\"\n    /// anchors that only treat `\\n` as line terminators. This does not include\n    /// haystack anchors or CRLF aware line anchors.\n    #[inline]\n    pub fn contains_anchor_lf(&self) -> bool {\n        self.contains(Look::StartLF) || self.contains(Look::EndLF)\n    }\n\n    /// Returns true if and only if this set contains any \"start/end of line\"\n    /// anchors that are CRLF-aware. This doesn't include \"start/end of\n    /// haystack\" or \"start/end of line-feed\" anchors.\n    #[inline]\n    pub fn contains_anchor_crlf(&self) -> bool {\n        self.contains(Look::StartCRLF) || self.contains(Look::EndCRLF)\n    }\n\n    /// Returns true if and only if this set contains any word boundary or\n    /// negated word boundary assertions. This include both Unicode and ASCII\n    /// word boundaries.\n    #[inline]\n    pub fn contains_word(self) -> bool {\n        self.contains_word_unicode() || self.contains_word_ascii()\n    }\n\n    /// Returns true if and only if this set contains any Unicode word boundary\n    /// or negated Unicode word boundary assertions.\n    #[inline]\n    pub fn contains_word_unicode(self) -> bool {\n        self.contains(Look::WordUnicode)\n            || self.contains(Look::WordUnicodeNegate)\n    }\n\n    /// Returns true if and only if this set contains any ASCII word boundary\n    /// or negated ASCII word boundary assertions.\n    #[inline]\n    pub fn contains_word_ascii(self) -> bool {\n        self.contains(Look::WordAscii) || self.contains(Look::WordAsciiNegate)\n    }\n\n    /// Returns an iterator over all of the look-around assertions in this set.\n    #[inline]\n    pub fn iter(self) -> LookSetIter {\n        LookSetIter { set: self }\n    }\n\n    /// Return a new set that is equivalent to the original, but with the given\n    /// assertion added to it. If the assertion is already in the set, then the\n    /// returned set is equivalent to the original.\n    #[inline]\n    pub fn insert(self, look: Look) -> LookSet {\n        LookSet { bits: self.bits | look.as_repr() }\n    }\n\n    /// Updates this set in place with the result of inserting the given\n    /// assertion into this set.\n    #[inline]\n    pub fn set_insert(&mut self, look: Look) {\n        *self = self.insert(look);\n    }\n\n    /// Return a new set that is equivalent to the original, but with the given\n    /// assertion removed from it. If the assertion is not in the set, then the\n    /// returned set is equivalent to the original.\n    #[inline]\n    pub fn remove(self, look: Look) -> LookSet {\n        LookSet { bits: self.bits & !look.as_repr() }\n    }\n\n    /// Updates this set in place with the result of removing the given\n    /// assertion from this set.\n    #[inline]\n    pub fn set_remove(&mut self, look: Look) {\n        *self = self.remove(look);\n    }\n\n    /// Returns a new set that is the result of subtracting the given set from\n    /// this set.\n    #[inline]\n    pub fn subtract(self, other: LookSet) -> LookSet {\n        LookSet { bits: self.bits & !other.bits }\n    }\n\n    /// Updates this set in place with the result of subtracting the given set\n    /// from this set.\n    #[inline]\n    pub fn set_subtract(&mut self, other: LookSet) {\n        *self = self.subtract(other);\n    }\n\n    /// Returns a new set that is the union of this and the one given.\n    #[inline]\n    pub fn union(self, other: LookSet) -> LookSet {\n        LookSet { bits: self.bits | other.bits }\n    }\n\n    /// Updates this set in place with the result of unioning it with the one\n    /// given.\n    #[inline]\n    pub fn set_union(&mut self, other: LookSet) {\n        *self = self.union(other);\n    }\n\n    /// Returns a new set that is the intersection of this and the one given.\n    #[inline]\n    pub fn intersect(self, other: LookSet) -> LookSet {\n        LookSet { bits: self.bits & other.bits }\n    }\n\n    /// Updates this set in place with the result of intersecting it with the\n    /// one given.\n    #[inline]\n    pub fn set_intersect(&mut self, other: LookSet) {\n        *self = self.intersect(other);\n    }\n\n    /// Return a `LookSet` from the slice given as a native endian 16-bit\n    /// integer.\n    ///\n    /// # Panics\n    ///\n    /// This panics if `slice.len() < 2`.\n    #[inline]\n    pub fn read_repr(slice: &[u8]) -> LookSet {\n        let bits = u16::from_ne_bytes(slice[..2].try_into().unwrap());\n        LookSet { bits }\n    }\n\n    /// Write a `LookSet` as a native endian 16-bit integer to the beginning\n    /// of the slice given.\n    ///\n    /// # Panics\n    ///\n    /// This panics if `slice.len() < 2`.\n    #[inline]\n    pub fn write_repr(self, slice: &mut [u8]) {\n        let raw = self.bits.to_ne_bytes();\n        slice[0] = raw[0];\n        slice[1] = raw[1];\n    }\n}","impl core::fmt::Debug for LookSet {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        if self.is_empty() {\n            return write!(f, \"∅\");\n        }\n        for look in self.iter() {\n            write!(f, \"{}\", look.as_char())?;\n        }\n        Ok(())\n    }\n}"],"hir::LookSetIter":["Clone","Debug","impl Iterator for LookSetIter {\n    type Item = Look;\n\n    #[inline]\n    fn next(&mut self) -> Option<Look> {\n        if self.set.is_empty() {\n            return None;\n        }\n        // We'll never have more than u8::MAX distinct look-around assertions,\n        // so 'repr' will always fit into a u16.\n        let repr = u16::try_from(self.set.bits.trailing_zeros()).unwrap();\n        let look = Look::from_repr(1 << repr)?;\n        self.set = self.set.remove(look);\n        Some(look)\n    }\n}"],"hir::Properties":["Clone","Debug","Eq","PartialEq","impl Properties {\n    /// Create a new set of HIR properties for an empty regex.\n    fn empty() -> Properties {\n        let inner = PropertiesI {\n            minimum_len: Some(0),\n            maximum_len: Some(0),\n            look_set: LookSet::empty(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            // It is debatable whether an empty regex always matches at valid\n            // UTF-8 boundaries. Strictly speaking, at a byte oriented view,\n            // it is clearly false. There are, for example, many empty strings\n            // between the bytes encoding a '☃'.\n            //\n            // However, when Unicode mode is enabled, the fundamental atom\n            // of matching is really a codepoint. And in that scenario, an\n            // empty regex is defined to only match at valid UTF-8 boundaries\n            // and to never split a codepoint. It just so happens that this\n            // enforcement is somewhat tricky to do for regexes that match\n            // the empty string inside regex engines themselves. It usually\n            // requires some layer above the regex engine to filter out such\n            // matches.\n            //\n            // In any case, 'true' is really the only coherent option. If it\n            // were false, for example, then 'a*' would also need to be false\n            // since it too can match the empty string.\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: false,\n            alternation_literal: false,\n        };\n        Properties(Box::new(inner))\n    }\n\n    /// Create a new set of HIR properties for a literal regex.\n    fn literal(lit: &Literal) -> Properties {\n        let inner = PropertiesI {\n            minimum_len: Some(lit.0.len()),\n            maximum_len: Some(lit.0.len()),\n            look_set: LookSet::empty(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: core::str::from_utf8(&lit.0).is_ok(),\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: true,\n            alternation_literal: true,\n        };\n        Properties(Box::new(inner))\n    }\n\n    /// Create a new set of HIR properties for a character class.\n    fn class(class: &Class) -> Properties {\n        let inner = PropertiesI {\n            minimum_len: class.minimum_len(),\n            maximum_len: class.maximum_len(),\n            look_set: LookSet::empty(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: class.is_utf8(),\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: false,\n            alternation_literal: false,\n        };\n        Properties(Box::new(inner))\n    }\n\n    /// Create a new set of HIR properties for a look-around assertion.\n    fn look(look: Look) -> Properties {\n        let inner = PropertiesI {\n            minimum_len: Some(0),\n            maximum_len: Some(0),\n            look_set: LookSet::singleton(look),\n            look_set_prefix: LookSet::singleton(look),\n            look_set_suffix: LookSet::singleton(look),\n            look_set_prefix_any: LookSet::singleton(look),\n            look_set_suffix_any: LookSet::singleton(look),\n            // This requires a little explanation. Basically, we don't consider\n            // matching an empty string to be equivalent to matching invalid\n            // UTF-8, even though technically matching every empty string will\n            // split the UTF-8 encoding of a single codepoint when treating a\n            // UTF-8 encoded string as a sequence of bytes. Our defense here is\n            // that in such a case, a codepoint should logically be treated as\n            // the fundamental atom for matching, and thus the only valid match\n            // points are between codepoints and not bytes.\n            //\n            // More practically, this is true here because it's also true\n            // for 'Hir::empty()', otherwise something like 'a*' would be\n            // considered to match invalid UTF-8. That in turn makes this\n            // property borderline useless.\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: false,\n            alternation_literal: false,\n        };\n        Properties(Box::new(inner))\n    }\n\n    /// Create a new set of HIR properties for a repetition.\n    fn repetition(rep: &Repetition) -> Properties {\n        let p = rep.sub.properties();\n        let minimum_len = p.minimum_len().map(|child_min| {\n            let rep_min = usize::try_from(rep.min).unwrap_or(usize::MAX);\n            child_min.saturating_mul(rep_min)\n        });\n        let maximum_len = rep.max.and_then(|rep_max| {\n            let rep_max = usize::try_from(rep_max).ok()?;\n            let child_max = p.maximum_len()?;\n            child_max.checked_mul(rep_max)\n        });\n\n        let mut inner = PropertiesI {\n            minimum_len,\n            maximum_len,\n            look_set: p.look_set(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: p.look_set_prefix_any(),\n            look_set_suffix_any: p.look_set_suffix_any(),\n            utf8: p.is_utf8(),\n            explicit_captures_len: p.explicit_captures_len(),\n            static_explicit_captures_len: p.static_explicit_captures_len(),\n            literal: false,\n            alternation_literal: false,\n        };\n        // If the repetition operator can match the empty string, then its\n        // lookset prefix and suffixes themselves remain empty since they are\n        // no longer required to match.\n        if rep.min > 0 {\n            inner.look_set_prefix = p.look_set_prefix();\n            inner.look_set_suffix = p.look_set_suffix();\n        }\n        // If the static captures len of the sub-expression is not known or is\n        // zero, then it automatically propagates to the repetition, regardless\n        // of the repetition. Otherwise, it might change, but only when the\n        // repetition can match 0 times.\n        if rep.min == 0\n            && inner.static_explicit_captures_len.map_or(false, |len| len > 0)\n        {\n            // If we require a match 0 times, then our captures len is\n            // guaranteed to be zero. Otherwise, if we *can* match the empty\n            // string, then it's impossible to know how many captures will be\n            // in the resulting match.\n            if rep.max == Some(0) {\n                inner.static_explicit_captures_len = Some(0);\n            } else {\n                inner.static_explicit_captures_len = None;\n            }\n        }\n        Properties(Box::new(inner))\n    }\n\n    /// Create a new set of HIR properties for a capture.\n    fn capture(capture: &Capture) -> Properties {\n        let p = capture.sub.properties();\n        Properties(Box::new(PropertiesI {\n            explicit_captures_len: p.explicit_captures_len().saturating_add(1),\n            static_explicit_captures_len: p\n                .static_explicit_captures_len()\n                .map(|len| len.saturating_add(1)),\n            literal: false,\n            alternation_literal: false,\n            ..*p.0.clone()\n        }))\n    }\n\n    /// Create a new set of HIR properties for a concatenation.\n    fn concat(concat: &[Hir]) -> Properties {\n        // The base case is an empty concatenation, which matches the empty\n        // string. Note though that empty concatenations aren't possible,\n        // because the Hir::concat smart constructor rewrites those as\n        // Hir::empty.\n        let mut props = PropertiesI {\n            minimum_len: Some(0),\n            maximum_len: Some(0),\n            look_set: LookSet::empty(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: true,\n            alternation_literal: true,\n        };\n        // Handle properties that need to visit every child hir.\n        for x in concat.iter() {\n            let p = x.properties();\n            props.look_set.set_union(p.look_set());\n            props.utf8 = props.utf8 && p.is_utf8();\n            props.explicit_captures_len = props\n                .explicit_captures_len\n                .saturating_add(p.explicit_captures_len());\n            props.static_explicit_captures_len = p\n                .static_explicit_captures_len()\n                .and_then(|len1| {\n                    Some((len1, props.static_explicit_captures_len?))\n                })\n                .and_then(|(len1, len2)| Some(len1.saturating_add(len2)));\n            props.literal = props.literal && p.is_literal();\n            props.alternation_literal =\n                props.alternation_literal && p.is_alternation_literal();\n            if let Some(ref mut minimum_len) = props.minimum_len {\n                match p.minimum_len() {\n                    None => props.minimum_len = None,\n                    Some(len) => *minimum_len += len,\n                }\n            }\n            if let Some(ref mut maximum_len) = props.maximum_len {\n                match p.maximum_len() {\n                    None => props.maximum_len = None,\n                    Some(len) => *maximum_len += len,\n                }\n            }\n        }\n        // Handle the prefix properties, which only requires visiting\n        // child exprs until one matches more than the empty string.\n        let mut it = concat.iter();\n        while let Some(x) = it.next() {\n            props.look_set_prefix.set_union(x.properties().look_set_prefix());\n            props\n                .look_set_prefix_any\n                .set_union(x.properties().look_set_prefix_any());\n            if x.properties().maximum_len().map_or(true, |x| x > 0) {\n                break;\n            }\n        }\n        // Same thing for the suffix properties, but in reverse.\n        let mut it = concat.iter().rev();\n        while let Some(x) = it.next() {\n            props.look_set_suffix.set_union(x.properties().look_set_suffix());\n            props\n                .look_set_suffix_any\n                .set_union(x.properties().look_set_suffix_any());\n            if x.properties().maximum_len().map_or(true, |x| x > 0) {\n                break;\n            }\n        }\n        Properties(Box::new(props))\n    }\n\n    /// Create a new set of HIR properties for a concatenation.\n    fn alternation(alts: &[Hir]) -> Properties {\n        Properties::union(alts.iter().map(|hir| hir.properties()))\n    }\n}","impl Properties {\n    /// Returns the length (in bytes) of the smallest string matched by this\n    /// HIR.\n    ///\n    /// A return value of `0` is possible and occurs when the HIR can match an\n    /// empty string.\n    ///\n    /// `None` is returned when there is no minimum length. This occurs in\n    /// precisely the cases where the HIR matches nothing. i.e., The language\n    /// the regex matches is empty. An example of such a regex is `\\P{any}`.\n    #[inline]\n    pub fn minimum_len(&self) -> Option<usize> {\n        self.0.minimum_len\n    }\n\n    /// Returns the length (in bytes) of the longest string matched by this\n    /// HIR.\n    ///\n    /// A return value of `0` is possible and occurs when nothing longer than\n    /// the empty string is in the language described by this HIR.\n    ///\n    /// `None` is returned when there is no longest matching string. This\n    /// occurs when the HIR matches nothing or when there is no upper bound on\n    /// the length of matching strings. Example of such regexes are `\\P{any}`\n    /// (matches nothing) and `a+` (has no upper bound).\n    #[inline]\n    pub fn maximum_len(&self) -> Option<usize> {\n        self.0.maximum_len\n    }\n\n    /// Returns a set of all look-around assertions that appear at least once\n    /// in this HIR value.\n    #[inline]\n    pub fn look_set(&self) -> LookSet {\n        self.0.look_set\n    }\n\n    /// Returns a set of all look-around assertions that appear as a prefix for\n    /// this HIR value. That is, the set returned corresponds to the set of\n    /// assertions that must be passed before matching any bytes in a haystack.\n    ///\n    /// For example, `hir.look_set_prefix().contains(Look::Start)` returns true\n    /// if and only if the HIR is fully anchored at the start.\n    #[inline]\n    pub fn look_set_prefix(&self) -> LookSet {\n        self.0.look_set_prefix\n    }\n\n    /// Returns a set of all look-around assertions that appear as a _possible_\n    /// prefix for this HIR value. That is, the set returned corresponds to the\n    /// set of assertions that _may_ be passed before matching any bytes in a\n    /// haystack.\n    ///\n    /// For example, `hir.look_set_prefix_any().contains(Look::Start)` returns\n    /// true if and only if it's possible for the regex to match through a\n    /// anchored assertion before consuming any input.\n    #[inline]\n    pub fn look_set_prefix_any(&self) -> LookSet {\n        self.0.look_set_prefix_any\n    }\n\n    /// Returns a set of all look-around assertions that appear as a suffix for\n    /// this HIR value. That is, the set returned corresponds to the set of\n    /// assertions that must be passed in order to be considered a match after\n    /// all other consuming HIR expressions.\n    ///\n    /// For example, `hir.look_set_suffix().contains(Look::End)` returns true\n    /// if and only if the HIR is fully anchored at the end.\n    #[inline]\n    pub fn look_set_suffix(&self) -> LookSet {\n        self.0.look_set_suffix\n    }\n\n    /// Returns a set of all look-around assertions that appear as a _possible_\n    /// suffix for this HIR value. That is, the set returned corresponds to the\n    /// set of assertions that _may_ be passed before matching any bytes in a\n    /// haystack.\n    ///\n    /// For example, `hir.look_set_suffix_any().contains(Look::End)` returns\n    /// true if and only if it's possible for the regex to match through a\n    /// anchored assertion at the end of a match without consuming any input.\n    #[inline]\n    pub fn look_set_suffix_any(&self) -> LookSet {\n        self.0.look_set_suffix_any\n    }\n\n    /// Return true if and only if the corresponding HIR will always match\n    /// valid UTF-8.\n    ///\n    /// When this returns false, then it is possible for this HIR expression to\n    /// match invalid UTF-8, including by matching between the code units of\n    /// a single UTF-8 encoded codepoint.\n    ///\n    /// Note that this returns true even when the corresponding HIR can match\n    /// the empty string. Since an empty string can technically appear between\n    /// UTF-8 code units, it is possible for a match to be reported that splits\n    /// a codepoint which could in turn be considered matching invalid UTF-8.\n    /// However, it is generally assumed that such empty matches are handled\n    /// specially by the search routine if it is absolutely required that\n    /// matches not split a codepoint.\n    ///\n    /// # Example\n    ///\n    /// This code example shows the UTF-8 property of a variety of patterns.\n    ///\n    /// ```\n    /// use regex_syntax::{ParserBuilder, parse};\n    ///\n    /// // Examples of 'is_utf8() == true'.\n    /// assert!(parse(r\"a\")?.properties().is_utf8());\n    /// assert!(parse(r\"[^a]\")?.properties().is_utf8());\n    /// assert!(parse(r\".\")?.properties().is_utf8());\n    /// assert!(parse(r\"\\W\")?.properties().is_utf8());\n    /// assert!(parse(r\"\\b\")?.properties().is_utf8());\n    /// assert!(parse(r\"\\B\")?.properties().is_utf8());\n    /// assert!(parse(r\"(?-u)\\b\")?.properties().is_utf8());\n    /// assert!(parse(r\"(?-u)\\B\")?.properties().is_utf8());\n    /// // Unicode mode is enabled by default, and in\n    /// // that mode, all \\x hex escapes are treated as\n    /// // codepoints. So this actually matches the UTF-8\n    /// // encoding of U+00FF.\n    /// assert!(parse(r\"\\xFF\")?.properties().is_utf8());\n    ///\n    /// // Now we show examples of 'is_utf8() == false'.\n    /// // The only way to do this is to force the parser\n    /// // to permit invalid UTF-8, otherwise all of these\n    /// // would fail to parse!\n    /// let parse = |pattern| {\n    ///     ParserBuilder::new().utf8(false).build().parse(pattern)\n    /// };\n    /// assert!(!parse(r\"(?-u)[^a]\")?.properties().is_utf8());\n    /// assert!(!parse(r\"(?-u).\")?.properties().is_utf8());\n    /// assert!(!parse(r\"(?-u)\\W\")?.properties().is_utf8());\n    /// // Conversely to the equivalent example above,\n    /// // when Unicode mode is disabled, \\x hex escapes\n    /// // are treated as their raw byte values.\n    /// assert!(!parse(r\"(?-u)\\xFF\")?.properties().is_utf8());\n    /// // Note that just because we disabled UTF-8 in the\n    /// // parser doesn't mean we still can't use Unicode.\n    /// // It is enabled by default, so \\xFF is still\n    /// // equivalent to matching the UTF-8 encoding of\n    /// // U+00FF by default.\n    /// assert!(parse(r\"\\xFF\")?.properties().is_utf8());\n    /// // Even though we use raw bytes that individually\n    /// // are not valid UTF-8, when combined together, the\n    /// // overall expression *does* match valid UTF-8!\n    /// assert!(parse(r\"(?-u)\\xE2\\x98\\x83\")?.properties().is_utf8());\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    #[inline]\n    pub fn is_utf8(&self) -> bool {\n        self.0.utf8\n    }\n\n    /// Returns the total number of explicit capturing groups in the\n    /// corresponding HIR.\n    ///\n    /// Note that this does not include the implicit capturing group\n    /// corresponding to the entire match that is typically included by regex\n    /// engines.\n    ///\n    /// # Example\n    ///\n    /// This method will return `0` for `a` and `1` for `(a)`:\n    ///\n    /// ```\n    /// use regex_syntax::parse;\n    ///\n    /// assert_eq!(0, parse(\"a\")?.properties().explicit_captures_len());\n    /// assert_eq!(1, parse(\"(a)\")?.properties().explicit_captures_len());\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    #[inline]\n    pub fn explicit_captures_len(&self) -> usize {\n        self.0.explicit_captures_len\n    }\n\n    /// Returns the total number of explicit capturing groups that appear in\n    /// every possible match.\n    ///\n    /// If the number of capture groups can vary depending on the match, then\n    /// this returns `None`. That is, a value is only returned when the number\n    /// of matching groups is invariant or \"static.\"\n    ///\n    /// Note that this does not include the implicit capturing group\n    /// corresponding to the entire match.\n    ///\n    /// # Example\n    ///\n    /// This shows a few cases where a static number of capture groups is\n    /// available and a few cases where it is not.\n    ///\n    /// ```\n    /// use regex_syntax::parse;\n    ///\n    /// let len = |pattern| {\n    ///     parse(pattern).map(|h| {\n    ///         h.properties().static_explicit_captures_len()\n    ///     })\n    /// };\n    ///\n    /// assert_eq!(Some(0), len(\"a\")?);\n    /// assert_eq!(Some(1), len(\"(a)\")?);\n    /// assert_eq!(Some(1), len(\"(a)|(b)\")?);\n    /// assert_eq!(Some(2), len(\"(a)(b)|(c)(d)\")?);\n    /// assert_eq!(None, len(\"(a)|b\")?);\n    /// assert_eq!(None, len(\"a|(b)\")?);\n    /// assert_eq!(None, len(\"(b)*\")?);\n    /// assert_eq!(Some(1), len(\"(b)+\")?);\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    #[inline]\n    pub fn static_explicit_captures_len(&self) -> Option<usize> {\n        self.0.static_explicit_captures_len\n    }\n\n    /// Return true if and only if this HIR is a simple literal. This is\n    /// only true when this HIR expression is either itself a `Literal` or a\n    /// concatenation of only `Literal`s.\n    ///\n    /// For example, `f` and `foo` are literals, but `f+`, `(foo)`, `foo()` and\n    /// the empty string are not (even though they contain sub-expressions that\n    /// are literals).\n    #[inline]\n    pub fn is_literal(&self) -> bool {\n        self.0.literal\n    }\n\n    /// Return true if and only if this HIR is either a simple literal or an\n    /// alternation of simple literals. This is only\n    /// true when this HIR expression is either itself a `Literal` or a\n    /// concatenation of only `Literal`s or an alternation of only `Literal`s.\n    ///\n    /// For example, `f`, `foo`, `a|b|c`, and `foo|bar|baz` are alternation\n    /// literals, but `f+`, `(foo)`, `foo()`, and the empty pattern are not\n    /// (even though that contain sub-expressions that are literals).\n    #[inline]\n    pub fn is_alternation_literal(&self) -> bool {\n        self.0.alternation_literal\n    }\n\n    /// Returns the total amount of heap memory usage, in bytes, used by this\n    /// `Properties` value.\n    #[inline]\n    pub fn memory_usage(&self) -> usize {\n        core::mem::size_of::<PropertiesI>()\n    }\n\n    /// Returns a new set of properties that corresponds to the union of the\n    /// iterator of properties given.\n    ///\n    /// This is useful when one has multiple `Hir` expressions and wants\n    /// to combine them into a single alternation without constructing the\n    /// corresponding `Hir`. This routine provides a way of combining the\n    /// properties of each `Hir` expression into one set of properties\n    /// representing the union of those expressions.\n    ///\n    /// # Example: union with HIRs that never match\n    ///\n    /// This example shows that unioning properties together with one that\n    /// represents a regex that never matches will \"poison\" certain attributes,\n    /// like the minimum and maximum lengths.\n    ///\n    /// ```\n    /// use regex_syntax::{hir::Properties, parse};\n    ///\n    /// let hir1 = parse(\"ab?c?\")?;\n    /// assert_eq!(Some(1), hir1.properties().minimum_len());\n    /// assert_eq!(Some(3), hir1.properties().maximum_len());\n    ///\n    /// let hir2 = parse(r\"[a&&b]\")?;\n    /// assert_eq!(None, hir2.properties().minimum_len());\n    /// assert_eq!(None, hir2.properties().maximum_len());\n    ///\n    /// let hir3 = parse(r\"wxy?z?\")?;\n    /// assert_eq!(Some(2), hir3.properties().minimum_len());\n    /// assert_eq!(Some(4), hir3.properties().maximum_len());\n    ///\n    /// let unioned = Properties::union([\n    ///\t\thir1.properties(),\n    ///\t\thir2.properties(),\n    ///\t\thir3.properties(),\n    ///\t]);\n    /// assert_eq!(None, unioned.minimum_len());\n    /// assert_eq!(None, unioned.maximum_len());\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    ///\n    /// The maximum length can also be \"poisoned\" by a pattern that has no\n    /// upper bound on the length of a match. The minimum length remains\n    /// unaffected:\n    ///\n    /// ```\n    /// use regex_syntax::{hir::Properties, parse};\n    ///\n    /// let hir1 = parse(\"ab?c?\")?;\n    /// assert_eq!(Some(1), hir1.properties().minimum_len());\n    /// assert_eq!(Some(3), hir1.properties().maximum_len());\n    ///\n    /// let hir2 = parse(r\"a+\")?;\n    /// assert_eq!(Some(1), hir2.properties().minimum_len());\n    /// assert_eq!(None, hir2.properties().maximum_len());\n    ///\n    /// let hir3 = parse(r\"wxy?z?\")?;\n    /// assert_eq!(Some(2), hir3.properties().minimum_len());\n    /// assert_eq!(Some(4), hir3.properties().maximum_len());\n    ///\n    /// let unioned = Properties::union([\n    ///\t\thir1.properties(),\n    ///\t\thir2.properties(),\n    ///\t\thir3.properties(),\n    ///\t]);\n    /// assert_eq!(Some(1), unioned.minimum_len());\n    /// assert_eq!(None, unioned.maximum_len());\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    pub fn union<I, P>(props: I) -> Properties\n    where\n        I: IntoIterator<Item = P>,\n        P: core::borrow::Borrow<Properties>,\n    {\n        let mut it = props.into_iter().peekable();\n        // While empty alternations aren't possible, we still behave as if they\n        // are. When we have an empty alternate, then clearly the look-around\n        // prefix and suffix is empty. Otherwise, it is the intersection of all\n        // prefixes and suffixes (respectively) of the branches.\n        let fix = if it.peek().is_none() {\n            LookSet::empty()\n        } else {\n            LookSet::full()\n        };\n        // And also, an empty alternate means we have 0 static capture groups,\n        // but we otherwise start with the number corresponding to the first\n        // alternate. If any subsequent alternate has a different number of\n        // static capture groups, then we overall have a variation and not a\n        // static number of groups.\n        let static_explicit_captures_len =\n            it.peek().and_then(|p| p.borrow().static_explicit_captures_len());\n        // The base case is an empty alternation, which matches nothing.\n        // Note though that empty alternations aren't possible, because the\n        // Hir::alternation smart constructor rewrites those as empty character\n        // classes.\n        let mut props = PropertiesI {\n            minimum_len: None,\n            maximum_len: None,\n            look_set: LookSet::empty(),\n            look_set_prefix: fix,\n            look_set_suffix: fix,\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len,\n            literal: false,\n            alternation_literal: true,\n        };\n        let (mut min_poisoned, mut max_poisoned) = (false, false);\n        // Handle properties that need to visit every child hir.\n        for prop in it {\n            let p = prop.borrow();\n            props.look_set.set_union(p.look_set());\n            props.look_set_prefix.set_intersect(p.look_set_prefix());\n            props.look_set_suffix.set_intersect(p.look_set_suffix());\n            props.look_set_prefix_any.set_union(p.look_set_prefix_any());\n            props.look_set_suffix_any.set_union(p.look_set_suffix_any());\n            props.utf8 = props.utf8 && p.is_utf8();\n            props.explicit_captures_len = props\n                .explicit_captures_len\n                .saturating_add(p.explicit_captures_len());\n            if props.static_explicit_captures_len\n                != p.static_explicit_captures_len()\n            {\n                props.static_explicit_captures_len = None;\n            }\n            props.alternation_literal =\n                props.alternation_literal && p.is_literal();\n            if !min_poisoned {\n                if let Some(xmin) = p.minimum_len() {\n                    if props.minimum_len.map_or(true, |pmin| xmin < pmin) {\n                        props.minimum_len = Some(xmin);\n                    }\n                } else {\n                    props.minimum_len = None;\n                    min_poisoned = true;\n                }\n            }\n            if !max_poisoned {\n                if let Some(xmax) = p.maximum_len() {\n                    if props.maximum_len.map_or(true, |pmax| xmax > pmax) {\n                        props.maximum_len = Some(xmax);\n                    }\n                } else {\n                    props.maximum_len = None;\n                    max_poisoned = true;\n                }\n            }\n        }\n        Properties(Box::new(props))\n    }\n}"],"hir::PropertiesI":["Clone","Debug","Eq","PartialEq"],"hir::Repetition":["Clone","Debug","Eq","PartialEq","impl Repetition {\n    /// Returns a new repetition with the same `min`, `max` and `greedy`\n    /// values, but with its sub-expression replaced with the one given.\n    pub fn with(&self, sub: Hir) -> Repetition {\n        Repetition {\n            min: self.min,\n            max: self.max,\n            greedy: self.greedy,\n            sub: Box::new(sub),\n        }\n    }\n}"],"hir::interval::IntervalSet":["Clone","Debug","impl<I: Interval> Eq for IntervalSet<I> {}","impl<I: Interval> IntervalSet<I> {\n    /// Create a new set from a sequence of intervals. Each interval is\n    /// specified as a pair of bounds, where both bounds are inclusive.\n    ///\n    /// The given ranges do not need to be in any specific order, and ranges\n    /// may overlap.\n    pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I> {\n        let ranges: Vec<I> = intervals.into_iter().collect();\n        // An empty set is case folded.\n        let folded = ranges.is_empty();\n        let mut set = IntervalSet { ranges, folded };\n        set.canonicalize();\n        set\n    }\n\n    /// Add a new interval to this set.\n    pub fn push(&mut self, interval: I) {\n        // TODO: This could be faster. e.g., Push the interval such that\n        // it preserves canonicalization.\n        self.ranges.push(interval);\n        self.canonicalize();\n        // We don't know whether the new interval added here is considered\n        // case folded, so we conservatively assume that the entire set is\n        // no longer case folded if it was previously.\n        self.folded = false;\n    }\n\n    /// Return an iterator over all intervals in this set.\n    ///\n    /// The iterator yields intervals in ascending order.\n    pub fn iter(&self) -> IntervalSetIter<'_, I> {\n        IntervalSetIter(self.ranges.iter())\n    }\n\n    /// Return an immutable slice of intervals in this set.\n    ///\n    /// The sequence returned is in canonical ordering.\n    pub fn intervals(&self) -> &[I] {\n        &self.ranges\n    }\n\n    /// Expand this interval set such that it contains all case folded\n    /// characters. For example, if this class consists of the range `a-z`,\n    /// then applying case folding will result in the class containing both the\n    /// ranges `a-z` and `A-Z`.\n    ///\n    /// This returns an error if the necessary case mapping data is not\n    /// available.\n    pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {\n        if self.folded {\n            return Ok(());\n        }\n        let len = self.ranges.len();\n        for i in 0..len {\n            let range = self.ranges[i];\n            if let Err(err) = range.case_fold_simple(&mut self.ranges) {\n                self.canonicalize();\n                return Err(err);\n            }\n        }\n        self.canonicalize();\n        self.folded = true;\n        Ok(())\n    }\n\n    /// Union this set with the given set, in place.\n    pub fn union(&mut self, other: &IntervalSet<I>) {\n        if other.ranges.is_empty() || self.ranges == other.ranges {\n            return;\n        }\n        // This could almost certainly be done more efficiently.\n        self.ranges.extend(&other.ranges);\n        self.canonicalize();\n        self.folded = self.folded && other.folded;\n    }\n\n    /// Intersect this set with the given set, in place.\n    pub fn intersect(&mut self, other: &IntervalSet<I>) {\n        if self.ranges.is_empty() {\n            return;\n        }\n        if other.ranges.is_empty() {\n            self.ranges.clear();\n            // An empty set is case folded.\n            self.folded = true;\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the intersection to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        let mut ita = 0..drain_end;\n        let mut itb = 0..other.ranges.len();\n        let mut a = ita.next().unwrap();\n        let mut b = itb.next().unwrap();\n        loop {\n            if let Some(ab) = self.ranges[a].intersect(&other.ranges[b]) {\n                self.ranges.push(ab);\n            }\n            let (it, aorb) =\n                if self.ranges[a].upper() < other.ranges[b].upper() {\n                    (&mut ita, &mut a)\n                } else {\n                    (&mut itb, &mut b)\n                };\n            match it.next() {\n                Some(v) => *aorb = v,\n                None => break,\n            }\n        }\n        self.ranges.drain(..drain_end);\n        self.folded = self.folded && other.folded;\n    }\n\n    /// Subtract the given set from this set, in place.\n    pub fn difference(&mut self, other: &IntervalSet<I>) {\n        if self.ranges.is_empty() || other.ranges.is_empty() {\n            return;\n        }\n\n        // This algorithm is (to me) surprisingly complex. A search of the\n        // interwebs indicate that this is a potentially interesting problem.\n        // Folks seem to suggest interval or segment trees, but I'd like to\n        // avoid the overhead (both runtime and conceptual) of that.\n        //\n        // The following is basically my Shitty First Draft. Therefore, in\n        // order to grok it, you probably need to read each line carefully.\n        // Simplifications are most welcome!\n        //\n        // Remember, we can assume the canonical format invariant here, which\n        // says that all ranges are sorted, not overlapping and not adjacent in\n        // each class.\n        let drain_end = self.ranges.len();\n        let (mut a, mut b) = (0, 0);\n        'LOOP: while a < drain_end && b < other.ranges.len() {\n            // Basically, the easy cases are when neither range overlaps with\n            // each other. If the `b` range is less than our current `a`\n            // range, then we can skip it and move on.\n            if other.ranges[b].upper() < self.ranges[a].lower() {\n                b += 1;\n                continue;\n            }\n            // ... similarly for the `a` range. If it's less than the smallest\n            // `b` range, then we can add it as-is.\n            if self.ranges[a].upper() < other.ranges[b].lower() {\n                let range = self.ranges[a];\n                self.ranges.push(range);\n                a += 1;\n                continue;\n            }\n            // Otherwise, we have overlapping ranges.\n            assert!(!self.ranges[a].is_intersection_empty(&other.ranges[b]));\n\n            // This part is tricky and was non-obvious to me without looking\n            // at explicit examples (see the tests). The trickiness stems from\n            // two things: 1) subtracting a range from another range could\n            // yield two ranges and 2) after subtracting a range, it's possible\n            // that future ranges can have an impact. The loop below advances\n            // the `b` ranges until they can't possible impact the current\n            // range.\n            //\n            // For example, if our `a` range is `a-t` and our next three `b`\n            // ranges are `a-c`, `g-i`, `r-t` and `x-z`, then we need to apply\n            // subtraction three times before moving on to the next `a` range.\n            let mut range = self.ranges[a];\n            while b < other.ranges.len()\n                && !range.is_intersection_empty(&other.ranges[b])\n            {\n                let old_range = range;\n                range = match range.difference(&other.ranges[b]) {\n                    (None, None) => {\n                        // We lost the entire range, so move on to the next\n                        // without adding this one.\n                        a += 1;\n                        continue 'LOOP;\n                    }\n                    (Some(range1), None) | (None, Some(range1)) => range1,\n                    (Some(range1), Some(range2)) => {\n                        self.ranges.push(range1);\n                        range2\n                    }\n                };\n                // It's possible that the `b` range has more to contribute\n                // here. In particular, if it is greater than the original\n                // range, then it might impact the next `a` range *and* it\n                // has impacted the current `a` range as much as possible,\n                // so we can quit. We don't bump `b` so that the next `a`\n                // range can apply it.\n                if other.ranges[b].upper() > old_range.upper() {\n                    break;\n                }\n                // Otherwise, the next `b` range might apply to the current\n                // `a` range.\n                b += 1;\n            }\n            self.ranges.push(range);\n            a += 1;\n        }\n        while a < drain_end {\n            let range = self.ranges[a];\n            self.ranges.push(range);\n            a += 1;\n        }\n        self.ranges.drain(..drain_end);\n        self.folded = self.folded && other.folded;\n    }\n\n    /// Compute the symmetric difference of the two sets, in place.\n    ///\n    /// This computes the symmetric difference of two interval sets. This\n    /// removes all elements in this set that are also in the given set,\n    /// but also adds all elements from the given set that aren't in this\n    /// set. That is, the set will contain all elements in either set,\n    /// but will not contain any elements that are in both sets.\n    pub fn symmetric_difference(&mut self, other: &IntervalSet<I>) {\n        // TODO(burntsushi): Fix this so that it amortizes allocation.\n        let mut intersection = self.clone();\n        intersection.intersect(other);\n        self.union(other);\n        self.difference(&intersection);\n    }\n\n    /// Negate this interval set.\n    ///\n    /// For all `x` where `x` is any element, if `x` was in this set, then it\n    /// will not be in this set after negation.\n    pub fn negate(&mut self) {\n        if self.ranges.is_empty() {\n            let (min, max) = (I::Bound::min_value(), I::Bound::max_value());\n            self.ranges.push(I::create(min, max));\n            // The set containing everything must case folded.\n            self.folded = true;\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the negation to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        // We do checked arithmetic below because of the canonical ordering\n        // invariant.\n        if self.ranges[0].lower() > I::Bound::min_value() {\n            let upper = self.ranges[0].lower().decrement();\n            self.ranges.push(I::create(I::Bound::min_value(), upper));\n        }\n        for i in 1..drain_end {\n            let lower = self.ranges[i - 1].upper().increment();\n            let upper = self.ranges[i].lower().decrement();\n            self.ranges.push(I::create(lower, upper));\n        }\n        if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {\n            let lower = self.ranges[drain_end - 1].upper().increment();\n            self.ranges.push(I::create(lower, I::Bound::max_value()));\n        }\n        self.ranges.drain(..drain_end);\n        // We don't need to update whether this set is folded or not, because\n        // it is conservatively preserved through negation. Namely, if a set\n        // is not folded, then it is possible that its negation is folded, for\n        // example, [^☃]. But we're fine with assuming that the set is not\n        // folded in that case. (`folded` permits false negatives but not false\n        // positives.)\n        //\n        // But what about when a set is folded, is its negation also\n        // necessarily folded? Yes. Because if a set is folded, then for every\n        // character in the set, it necessarily included its equivalence class\n        // of case folded characters. Negating it in turn means that all\n        // equivalence classes in the set are negated, and any equivalence\n        // class that was previously not in the set is now entirely in the set.\n    }\n\n    /// Converts this set into a canonical ordering.\n    fn canonicalize(&mut self) {\n        if self.is_canonical() {\n            return;\n        }\n        self.ranges.sort();\n        assert!(!self.ranges.is_empty());\n\n        // Is there a way to do this in-place with constant memory? I couldn't\n        // figure out a way to do it. So just append the canonicalization to\n        // the end of this range, and then drain it before we're done.\n        let drain_end = self.ranges.len();\n        for oldi in 0..drain_end {\n            // If we've added at least one new range, then check if we can\n            // merge this range in the previously added range.\n            if self.ranges.len() > drain_end {\n                let (last, rest) = self.ranges.split_last_mut().unwrap();\n                if let Some(union) = last.union(&rest[oldi]) {\n                    *last = union;\n                    continue;\n                }\n            }\n            let range = self.ranges[oldi];\n            self.ranges.push(range);\n        }\n        self.ranges.drain(..drain_end);\n    }\n\n    /// Returns true if and only if this class is in a canonical ordering.\n    fn is_canonical(&self) -> bool {\n        for pair in self.ranges.windows(2) {\n            if pair[0] >= pair[1] {\n                return false;\n            }\n            if pair[0].is_contiguous(&pair[1]) {\n                return false;\n            }\n        }\n        true\n    }\n}","impl<I: Interval> PartialEq for IntervalSet<I> {\n    fn eq(&self, other: &IntervalSet<I>) -> bool {\n        self.ranges.eq(&other.ranges)\n    }\n}"],"hir::interval::IntervalSetIter":["Debug","impl<'a, I> Iterator for IntervalSetIter<'a, I> {\n    type Item = &'a I;\n\n    fn next(&mut self) -> Option<&'a I> {\n        self.0.next()\n    }\n}"],"hir::literal::ExtractKind":["Clone","Debug","impl Default for ExtractKind {\n    fn default() -> ExtractKind {\n        ExtractKind::Prefix\n    }\n}","impl ExtractKind {\n    /// Returns true if this kind is the `Prefix` variant.\n    pub fn is_prefix(&self) -> bool {\n        matches!(*self, ExtractKind::Prefix)\n    }\n\n    /// Returns true if this kind is the `Suffix` variant.\n    pub fn is_suffix(&self) -> bool {\n        matches!(*self, ExtractKind::Suffix)\n    }\n}"],"hir::literal::Extractor":["Clone","Debug","impl Default for Extractor {\n    fn default() -> Extractor {\n        Extractor::new()\n    }\n}","impl Extractor {\n    /// Create a new extractor with a default configuration.\n    ///\n    /// The extractor can be optionally configured before calling\n    /// [`Extractor::extract`] to get a literal sequence.\n    pub fn new() -> Extractor {\n        Extractor {\n            kind: ExtractKind::Prefix,\n            limit_class: 10,\n            limit_repeat: 10,\n            limit_literal_len: 100,\n            limit_total: 250,\n        }\n    }\n\n    /// Execute the extractor and return a sequence of literals.\n    pub fn extract(&self, hir: &Hir) -> Seq {\n        use crate::hir::HirKind::*;\n\n        match *hir.kind() {\n            Empty | Look(_) => Seq::singleton(self::Literal::exact(vec![])),\n            Literal(hir::Literal(ref bytes)) => {\n                let mut seq =\n                    Seq::singleton(self::Literal::exact(bytes.to_vec()));\n                self.enforce_literal_len(&mut seq);\n                seq\n            }\n            Class(hir::Class::Unicode(ref cls)) => {\n                self.extract_class_unicode(cls)\n            }\n            Class(hir::Class::Bytes(ref cls)) => self.extract_class_bytes(cls),\n            Repetition(ref rep) => self.extract_repetition(rep),\n            Capture(hir::Capture { ref sub, .. }) => self.extract(sub),\n            Concat(ref hirs) => match self.kind {\n                ExtractKind::Prefix => self.extract_concat(hirs.iter()),\n                ExtractKind::Suffix => self.extract_concat(hirs.iter().rev()),\n            },\n            Alternation(ref hirs) => {\n                // Unlike concat, we always union starting from the beginning,\n                // since the beginning corresponds to the highest preference,\n                // which doesn't change based on forwards vs reverse.\n                self.extract_alternation(hirs.iter())\n            }\n        }\n    }\n\n    /// Set the kind of literal sequence to extract from an [`Hir`] expression.\n    ///\n    /// The default is to extract prefixes, but suffixes can be selected\n    /// instead. The contract for prefixes is that every match of the\n    /// corresponding `Hir` must start with one of the literals in the sequence\n    /// returned. Moreover, the _order_ of the sequence returned corresponds to\n    /// the preference order.\n    ///\n    /// Suffixes satisfy a similar contract in that every match of the\n    /// corresponding `Hir` must end with one of the literals in the sequence\n    /// returned. However, there is no guarantee that the literals are in\n    /// preference order.\n    ///\n    /// Remember that a sequence can be infinite. For example, unless the\n    /// limits are configured to be impractically large, attempting to extract\n    /// prefixes (or suffixes) for the pattern `[A-Z]` will return an infinite\n    /// sequence. Generally speaking, if the sequence returned is infinite,\n    /// then it is presumed to be unwise to do prefix (or suffix) optimizations\n    /// for the pattern.\n    pub fn kind(&mut self, kind: ExtractKind) -> &mut Extractor {\n        self.kind = kind;\n        self\n    }\n\n    /// Configure a limit on the length of the sequence that is permitted for\n    /// a character class. If a character class exceeds this limit, then the\n    /// sequence returned for it is infinite.\n    ///\n    /// This prevents classes like `[A-Z]` or `\\pL` from getting turned into\n    /// huge and likely unproductive sequences of literals.\n    ///\n    /// # Example\n    ///\n    /// This example shows how this limit can be lowered to decrease the tolerance\n    /// for character classes being turned into literal sequences.\n    ///\n    /// ```\n    /// use regex_syntax::{hir::literal::{Extractor, Seq}, parse};\n    ///\n    /// let hir = parse(r\"[0-9]\")?;\n    ///\n    /// let got = Extractor::new().extract(&hir);\n    /// let expected = Seq::new([\n    ///     \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n    /// ]);\n    /// assert_eq!(expected, got);\n    ///\n    /// // Now let's shrink the limit and see how that changes things.\n    /// let got = Extractor::new().limit_class(4).extract(&hir);\n    /// let expected = Seq::infinite();\n    /// assert_eq!(expected, got);\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    pub fn limit_class(&mut self, limit: usize) -> &mut Extractor {\n        self.limit_class = limit;\n        self\n    }\n\n    /// Configure a limit on the total number of repetitions that is permitted\n    /// before literal extraction is stopped.\n    ///\n    /// This is useful for limiting things like `(abcde){50}`, or more\n    /// insidiously, `(?:){1000000000}`. This limit prevents any one single\n    /// repetition from adding too much to a literal sequence.\n    ///\n    /// With this limit set, repetitions that exceed it will be stopped and any\n    /// literals extracted up to that point will be made inexact.\n    ///\n    /// # Example\n    ///\n    /// This shows how to decrease the limit and compares it with the default.\n    ///\n    /// ```\n    /// use regex_syntax::{hir::literal::{Extractor, Literal, Seq}, parse};\n    ///\n    /// let hir = parse(r\"(abc){8}\")?;\n    ///\n    /// let got = Extractor::new().extract(&hir);\n    /// let expected = Seq::new([\"abcabcabcabcabcabcabcabc\"]);\n    /// assert_eq!(expected, got);\n    ///\n    /// // Now let's shrink the limit and see how that changes things.\n    /// let got = Extractor::new().limit_repeat(4).extract(&hir);\n    /// let expected = Seq::from_iter([\n    ///     Literal::inexact(\"abcabcabcabc\"),\n    /// ]);\n    /// assert_eq!(expected, got);\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    pub fn limit_repeat(&mut self, limit: usize) -> &mut Extractor {\n        self.limit_repeat = limit;\n        self\n    }\n\n    /// Configure a limit on the maximum length of any literal in a sequence.\n    ///\n    /// This is useful for limiting things like `(abcde){5}{5}{5}{5}`. While\n    /// each repetition or literal in that regex is small, when all the\n    /// repetitions are applied, one ends up with a literal of length `5^4 =\n    /// 625`.\n    ///\n    /// With this limit set, literals that exceed it will be made inexact and\n    /// thus prevented from growing.\n    ///\n    /// # Example\n    ///\n    /// This shows how to decrease the limit and compares it with the default.\n    ///\n    /// ```\n    /// use regex_syntax::{hir::literal::{Extractor, Literal, Seq}, parse};\n    ///\n    /// let hir = parse(r\"(abc){2}{2}{2}\")?;\n    ///\n    /// let got = Extractor::new().extract(&hir);\n    /// let expected = Seq::new([\"abcabcabcabcabcabcabcabc\"]);\n    /// assert_eq!(expected, got);\n    ///\n    /// // Now let's shrink the limit and see how that changes things.\n    /// let got = Extractor::new().limit_literal_len(14).extract(&hir);\n    /// let expected = Seq::from_iter([\n    ///     Literal::inexact(\"abcabcabcabcab\"),\n    /// ]);\n    /// assert_eq!(expected, got);\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    pub fn limit_literal_len(&mut self, limit: usize) -> &mut Extractor {\n        self.limit_literal_len = limit;\n        self\n    }\n\n    /// Configure a limit on the total number of literals that will be\n    /// returned.\n    ///\n    /// This is useful as a practical measure for avoiding the creation of\n    /// large sequences of literals. While the extractor will automatically\n    /// handle local creations of large sequences (for example, `[A-Z]` yields\n    /// an infinite sequence by default), large sequences can be created\n    /// through non-local means as well.\n    ///\n    /// For example, `[ab]{3}{3}` would yield a sequence of length `512 = 2^9`\n    /// despite each of the repetitions being small on their own. This limit\n    /// thus represents a \"catch all\" for avoiding locally small sequences from\n    /// combining into large sequences.\n    ///\n    /// # Example\n    ///\n    /// This example shows how reducing the limit will change the literal\n    /// sequence returned.\n    ///\n    /// ```\n    /// use regex_syntax::{hir::literal::{Extractor, Literal, Seq}, parse};\n    ///\n    /// let hir = parse(r\"[ab]{2}{2}\")?;\n    ///\n    /// let got = Extractor::new().extract(&hir);\n    /// let expected = Seq::new([\n    ///     \"aaaa\", \"aaab\", \"aaba\", \"aabb\",\n    ///     \"abaa\", \"abab\", \"abba\", \"abbb\",\n    ///     \"baaa\", \"baab\", \"baba\", \"babb\",\n    ///     \"bbaa\", \"bbab\", \"bbba\", \"bbbb\",\n    /// ]);\n    /// assert_eq!(expected, got);\n    ///\n    /// // The default limit is not too big, but big enough to extract all\n    /// // literals from '[ab]{2}{2}'. If we shrink the limit to less than 16,\n    /// // then we'll get a truncated set. Notice that it returns a sequence of\n    /// // length 4 even though our limit was 10. This is because the sequence\n    /// // is difficult to increase without blowing the limit. Notice also\n    /// // that every literal in the sequence is now inexact because they were\n    /// // stripped of some suffix.\n    /// let got = Extractor::new().limit_total(10).extract(&hir);\n    /// let expected = Seq::from_iter([\n    ///     Literal::inexact(\"aa\"),\n    ///     Literal::inexact(\"ab\"),\n    ///     Literal::inexact(\"ba\"),\n    ///     Literal::inexact(\"bb\"),\n    /// ]);\n    /// assert_eq!(expected, got);\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    pub fn limit_total(&mut self, limit: usize) -> &mut Extractor {\n        self.limit_total = limit;\n        self\n    }\n\n    /// Extract a sequence from the given concatenation. Sequences from each of\n    /// the child HIR expressions are combined via cross product.\n    ///\n    /// This short circuits once the cross product turns into a sequence\n    /// containing only inexact literals.\n    fn extract_concat<'a, I: Iterator<Item = &'a Hir>>(&self, it: I) -> Seq {\n        let mut seq = Seq::singleton(self::Literal::exact(vec![]));\n        for hir in it {\n            // If every element in the sequence is inexact, then a cross\n            // product will always be a no-op. Thus, there is nothing else we\n            // can add to it and can quit early. Note that this also includes\n            // infinite sequences.\n            if seq.is_inexact() {\n                break;\n            }\n            // Note that 'cross' also dispatches based on whether we're\n            // extracting prefixes or suffixes.\n            seq = self.cross(seq, &mut self.extract(hir));\n        }\n        seq\n    }\n\n    /// Extract a sequence from the given alternation.\n    ///\n    /// This short circuits once the union turns into an infinite sequence.\n    fn extract_alternation<'a, I: Iterator<Item = &'a Hir>>(\n        &self,\n        it: I,\n    ) -> Seq {\n        let mut seq = Seq::empty();\n        for hir in it {\n            // Once our 'seq' is infinite, every subsequent union\n            // operation on it will itself always result in an\n            // infinite sequence. Thus, it can never change and we can\n            // short-circuit.\n            if !seq.is_finite() {\n                break;\n            }\n            seq = self.union(seq, &mut self.extract(hir));\n        }\n        seq\n    }\n\n    /// Extract a sequence of literals from the given repetition. We do our\n    /// best, Some examples:\n    ///\n    ///   'a*'    => [inexact(a), exact(\"\")]\n    ///   'a*?'   => [exact(\"\"), inexact(a)]\n    ///   'a+'    => [inexact(a)]\n    ///   'a{3}'  => [exact(aaa)]\n    ///   'a{3,5} => [inexact(aaa)]\n    ///\n    /// The key here really is making sure we get the 'inexact' vs 'exact'\n    /// attributes correct on each of the literals we add. For example, the\n    /// fact that 'a*' gives us an inexact 'a' and an exact empty string means\n    /// that a regex like 'ab*c' will result in [inexact(ab), exact(ac)]\n    /// literals being extracted, which might actually be a better prefilter\n    /// than just 'a'.\n    fn extract_repetition(&self, rep: &hir::Repetition) -> Seq {\n        let mut subseq = self.extract(&rep.sub);\n        match *rep {\n            hir::Repetition { min: 0, max, greedy, .. } => {\n                // When 'max=1', we can retain exactness, since 'a?' is\n                // equivalent to 'a|'. Similarly below, 'a??' is equivalent to\n                // '|a'.\n                if max != Some(1) {\n                    subseq.make_inexact();\n                }\n                let mut empty = Seq::singleton(Literal::exact(vec![]));\n                if !greedy {\n                    mem::swap(&mut subseq, &mut empty);\n                }\n                self.union(subseq, &mut empty)\n            }\n            hir::Repetition { min, max: Some(max), .. } if min == max => {\n                assert!(min > 0); // handled above\n                let limit =\n                    u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);\n                let mut seq = Seq::singleton(Literal::exact(vec![]));\n                for _ in 0..cmp::min(min, limit) {\n                    if seq.is_inexact() {\n                        break;\n                    }\n                    seq = self.cross(seq, &mut subseq.clone());\n                }\n                if usize::try_from(min).is_err() || min > limit {\n                    seq.make_inexact();\n                }\n                seq\n            }\n            hir::Repetition { min, max: Some(max), .. } if min < max => {\n                assert!(min > 0); // handled above\n                let limit =\n                    u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);\n                let mut seq = Seq::singleton(Literal::exact(vec![]));\n                for _ in 0..cmp::min(min, limit) {\n                    if seq.is_inexact() {\n                        break;\n                    }\n                    seq = self.cross(seq, &mut subseq.clone());\n                }\n                seq.make_inexact();\n                seq\n            }\n            hir::Repetition { .. } => {\n                subseq.make_inexact();\n                subseq\n            }\n        }\n    }\n\n    /// Convert the given Unicode class into a sequence of literals if the\n    /// class is small enough. If the class is too big, return an infinite\n    /// sequence.\n    fn extract_class_unicode(&self, cls: &hir::ClassUnicode) -> Seq {\n        if self.class_over_limit_unicode(cls) {\n            return Seq::infinite();\n        }\n        let mut seq = Seq::empty();\n        for r in cls.iter() {\n            for ch in r.start()..=r.end() {\n                seq.push(Literal::from(ch));\n            }\n        }\n        self.enforce_literal_len(&mut seq);\n        seq\n    }\n\n    /// Convert the given byte class into a sequence of literals if the class\n    /// is small enough. If the class is too big, return an infinite sequence.\n    fn extract_class_bytes(&self, cls: &hir::ClassBytes) -> Seq {\n        if self.class_over_limit_bytes(cls) {\n            return Seq::infinite();\n        }\n        let mut seq = Seq::empty();\n        for r in cls.iter() {\n            for b in r.start()..=r.end() {\n                seq.push(Literal::from(b));\n            }\n        }\n        self.enforce_literal_len(&mut seq);\n        seq\n    }\n\n    /// Returns true if the given Unicode class exceeds the configured limits\n    /// on this extractor.\n    fn class_over_limit_unicode(&self, cls: &hir::ClassUnicode) -> bool {\n        let mut count = 0;\n        for r in cls.iter() {\n            if count > self.limit_class {\n                return true;\n            }\n            count += r.len();\n        }\n        count > self.limit_class\n    }\n\n    /// Returns true if the given byte class exceeds the configured limits on\n    /// this extractor.\n    fn class_over_limit_bytes(&self, cls: &hir::ClassBytes) -> bool {\n        let mut count = 0;\n        for r in cls.iter() {\n            if count > self.limit_class {\n                return true;\n            }\n            count += r.len();\n        }\n        count > self.limit_class\n    }\n\n    /// Compute the cross product of the two sequences if the result would be\n    /// within configured limits. Otherwise, make `seq2` infinite and cross the\n    /// infinite sequence with `seq1`.\n    fn cross(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {\n        if seq1.max_cross_len(seq2).map_or(false, |len| len > self.limit_total)\n        {\n            seq2.make_infinite();\n        }\n        if let ExtractKind::Suffix = self.kind {\n            seq1.cross_reverse(seq2);\n        } else {\n            seq1.cross_forward(seq2);\n        }\n        assert!(seq1.len().map_or(true, |x| x <= self.limit_total));\n        self.enforce_literal_len(&mut seq1);\n        seq1\n    }\n\n    /// Union the two sequences if the result would be within configured\n    /// limits. Otherwise, make `seq2` infinite and union the infinite sequence\n    /// with `seq1`.\n    fn union(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {\n        if seq1.max_union_len(seq2).map_or(false, |len| len > self.limit_total)\n        {\n            // We try to trim our literal sequences to see if we can make\n            // room for more literals. The idea is that we'd rather trim down\n            // literals already in our sequence if it means we can add a few\n            // more and retain a finite sequence. Otherwise, we'll union with\n            // an infinite sequence and that infects everything and effectively\n            // stops literal extraction in its tracks.\n            //\n            // We do we keep 4 bytes here? Well, it's a bit of an abstraction\n            // leakage. Downstream, the literals may wind up getting fed to\n            // the Teddy algorithm, which supports searching literals up to\n            // length 4. So that's why we pick that number here. Arguably this\n            // should be a tuneable parameter, but it seems a little tricky to\n            // describe. And I'm still unsure if this is the right way to go\n            // about culling literal sequences.\n            match self.kind {\n                ExtractKind::Prefix => {\n                    seq1.keep_first_bytes(4);\n                    seq2.keep_first_bytes(4);\n                }\n                ExtractKind::Suffix => {\n                    seq1.keep_last_bytes(4);\n                    seq2.keep_last_bytes(4);\n                }\n            }\n            seq1.dedup();\n            seq2.dedup();\n            if seq1\n                .max_union_len(seq2)\n                .map_or(false, |len| len > self.limit_total)\n            {\n                seq2.make_infinite();\n            }\n        }\n        seq1.union(seq2);\n        assert!(seq1.len().map_or(true, |x| x <= self.limit_total));\n        seq1\n    }\n\n    /// Applies the literal length limit to the given sequence. If none of the\n    /// literals in the sequence exceed the limit, then this is a no-op.\n    fn enforce_literal_len(&self, seq: &mut Seq) {\n        let len = self.limit_literal_len;\n        match self.kind {\n            ExtractKind::Prefix => seq.keep_first_bytes(len),\n            ExtractKind::Suffix => seq.keep_last_bytes(len),\n        }\n    }\n}"],"hir::literal::Literal":["Clone","Eq","Ord","PartialEq","PartialOrd","impl AsRef<[u8]> for Literal {\n    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }\n}","impl From<char> for Literal {\n    fn from(ch: char) -> Literal {\n        use alloc::string::ToString;\n        Literal::exact(ch.encode_utf8(&mut [0; 4]).to_string())\n    }\n}","impl From<u8> for Literal {\n    fn from(byte: u8) -> Literal {\n        Literal::exact(vec![byte])\n    }\n}","impl Literal {\n    /// Returns a new exact literal containing the bytes given.\n    #[inline]\n    pub fn exact<B: Into<Vec<u8>>>(bytes: B) -> Literal {\n        Literal { bytes: bytes.into(), exact: true }\n    }\n\n    /// Returns a new inexact literal containing the bytes given.\n    #[inline]\n    pub fn inexact<B: Into<Vec<u8>>>(bytes: B) -> Literal {\n        Literal { bytes: bytes.into(), exact: false }\n    }\n\n    /// Returns the bytes in this literal.\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.bytes\n    }\n\n    /// Yields ownership of the bytes inside this literal.\n    ///\n    /// Note that this throws away whether the literal is \"exact\" or not.\n    #[inline]\n    pub fn into_bytes(self) -> Vec<u8> {\n        self.bytes\n    }\n\n    /// Returns the length of this literal in bytes.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.as_bytes().len()\n    }\n\n    /// Returns true if and only if this literal has zero bytes.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns true if and only if this literal is exact.\n    #[inline]\n    pub fn is_exact(&self) -> bool {\n        self.exact\n    }\n\n    /// Marks this literal as inexact.\n    ///\n    /// Inexact literals can never be extended. For example,\n    /// [`Seq::cross_forward`] will not extend inexact literals.\n    #[inline]\n    pub fn make_inexact(&mut self) {\n        self.exact = false;\n    }\n\n    /// Reverse the bytes in this literal.\n    #[inline]\n    pub fn reverse(&mut self) {\n        self.bytes.reverse();\n    }\n\n    /// Extend this literal with the literal given.\n    ///\n    /// If this literal is inexact, then this is a no-op.\n    #[inline]\n    pub fn extend(&mut self, lit: &Literal) {\n        if !self.is_exact() {\n            return;\n        }\n        self.bytes.extend_from_slice(&lit.bytes);\n    }\n\n    /// Trims this literal such that only the first `len` bytes remain. If\n    /// this literal has fewer than `len` bytes, then it remains unchanged.\n    /// Otherwise, the literal is marked as inexact.\n    #[inline]\n    pub fn keep_first_bytes(&mut self, len: usize) {\n        if len >= self.len() {\n            return;\n        }\n        self.make_inexact();\n        self.bytes.truncate(len);\n    }\n\n    /// Trims this literal such that only the last `len` bytes remain. If this\n    /// literal has fewer than `len` bytes, then it remains unchanged.\n    /// Otherwise, the literal is marked as inexact.\n    #[inline]\n    pub fn keep_last_bytes(&mut self, len: usize) {\n        if len >= self.len() {\n            return;\n        }\n        self.make_inexact();\n        self.bytes.drain(..self.len() - len);\n    }\n\n    /// Returns true if it is believe that this literal is likely to match very\n    /// frequently, and is thus not a good candidate for a prefilter.\n    fn is_poisonous(&self) -> bool {\n        self.is_empty() || (self.len() == 1 && rank(self.as_bytes()[0]) >= 250)\n    }\n}","impl core::fmt::Debug for Literal {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        let tag = if self.exact { \"E\" } else { \"I\" };\n        f.debug_tuple(tag)\n            .field(&crate::debug::Bytes(self.as_bytes()))\n            .finish()\n    }\n}"],"hir::literal::PreferenceTrie":["Debug","Default","impl PreferenceTrie {\n    /// Minimizes the given sequence of literals while preserving preference\n    /// order semantics.\n    ///\n    /// When `keep_exact` is true, the exactness of every literal retained is\n    /// kept. This is useful when dealing with a fully extracted `Seq` that\n    /// only contains exact literals. In that case, we can keep all retained\n    /// literals as exact because we know we'll never need to match anything\n    /// after them and because any removed literals are guaranteed to never\n    /// match.\n    fn minimize(literals: &mut Vec<Literal>, keep_exact: bool) {\n        use core::cell::RefCell;\n\n        // MSRV(1.61): Use retain_mut here to avoid interior mutability.\n        let trie = RefCell::new(PreferenceTrie::default());\n        let mut make_inexact = vec![];\n        literals.retain(|lit| {\n            match trie.borrow_mut().insert(lit.as_bytes()) {\n                Ok(_) => true,\n                Err(i) => {\n                    if !keep_exact {\n                        make_inexact.push(i);\n                    }\n                    false\n                }\n            }\n        });\n        for i in make_inexact {\n            literals[i].make_inexact();\n        }\n    }\n\n    /// Returns `Ok` if the given byte string is accepted into this trie and\n    /// `Err` otherwise. The index for the success case corresponds to the\n    /// index of the literal added. The index for the error case corresponds to\n    /// the index of the literal already in the trie that prevented the given\n    /// byte string from being added. (Which implies it is a prefix of the one\n    /// given.)\n    ///\n    /// In short, the byte string given is accepted into the trie if and only\n    /// if it is possible for it to match when executing a preference order\n    /// search.\n    fn insert(&mut self, bytes: &[u8]) -> Result<usize, usize> {\n        let mut prev = self.root();\n        if let Some(idx) = self.states[prev].literal_index {\n            return Err(idx);\n        }\n        for &b in bytes.iter() {\n            match self.states[prev].trans.binary_search_by_key(&b, |t| t.0) {\n                Ok(i) => {\n                    prev = self.states[prev].trans[i].1;\n                    if let Some(idx) = self.states[prev].literal_index {\n                        return Err(idx);\n                    }\n                }\n                Err(i) => {\n                    let next = self.create_state();\n                    self.states[prev].trans.insert(i, (b, next));\n                    prev = next;\n                }\n            }\n        }\n        let idx = self.next_literal_index;\n        self.next_literal_index += 1;\n        self.states[prev].literal_index = Some(idx);\n        Ok(idx)\n    }\n\n    /// Returns the root state ID, and if it doesn't exist, creates it.\n    fn root(&mut self) -> usize {\n        if !self.states.is_empty() {\n            0\n        } else {\n            self.create_state()\n        }\n    }\n\n    /// Creates a new empty state and returns its ID.\n    fn create_state(&mut self) -> usize {\n        let id = self.states.len();\n        self.states.push(State::default());\n        id\n    }\n}"],"hir::literal::Seq":["Clone","Eq","PartialEq","impl FromIterator<Literal> for Seq {\n    fn from_iter<T: IntoIterator<Item = Literal>>(it: T) -> Seq {\n        let mut seq = Seq::empty();\n        for literal in it {\n            seq.push(literal);\n        }\n        seq\n    }\n}","impl Seq {\n    /// Returns an empty sequence.\n    ///\n    /// An empty sequence matches zero literals, and thus corresponds to a\n    /// regex that itself can never match.\n    #[inline]\n    pub fn empty() -> Seq {\n        Seq { literals: Some(vec![]) }\n    }\n\n    /// Returns a sequence of literals without a finite size and may contain\n    /// any literal.\n    ///\n    /// A sequence without finite size does not reveal anything about the\n    /// characteristics of the literals in its set. There are no fixed prefixes\n    /// or suffixes, nor are lower or upper bounds on the length of the literals\n    /// in the set known.\n    ///\n    /// This is useful to represent constructs in a regex that are \"too big\"\n    /// to useful represent as a sequence of literals. For example, `[A-Za-z]`.\n    /// When sequences get too big, they lose their discriminating nature and\n    /// are more likely to produce false positives, which in turn makes them\n    /// less likely to speed up searches.\n    ///\n    /// More pragmatically, for many regexes, enumerating all possible literals\n    /// is itself not possible or might otherwise use too many resources. So\n    /// constraining the size of sets during extraction is a practical trade\n    /// off to make.\n    #[inline]\n    pub fn infinite() -> Seq {\n        Seq { literals: None }\n    }\n\n    /// Returns a sequence containing a single literal.\n    #[inline]\n    pub fn singleton(lit: Literal) -> Seq {\n        Seq { literals: Some(vec![lit]) }\n    }\n\n    /// Returns a sequence of exact literals from the given byte strings.\n    #[inline]\n    pub fn new<I, B>(it: I) -> Seq\n    where\n        I: IntoIterator<Item = B>,\n        B: AsRef<[u8]>,\n    {\n        it.into_iter().map(|b| Literal::exact(b.as_ref())).collect()\n    }\n\n    /// If this is a finite sequence, return its members as a slice of\n    /// literals.\n    ///\n    /// The slice returned may be empty, in which case, there are no literals\n    /// that can match this sequence.\n    #[inline]\n    pub fn literals(&self) -> Option<&[Literal]> {\n        self.literals.as_deref()\n    }\n\n    /// Push a literal to the end of this sequence.\n    ///\n    /// If this sequence is not finite, then this is a no-op.\n    ///\n    /// Similarly, if the most recently added item of this sequence is\n    /// equivalent to the literal given, then it is not added. This reflects\n    /// a `Seq`'s \"set like\" behavior, and represents a practical trade off.\n    /// Namely, there is never any need to have two adjacent and equivalent\n    /// literals in the same sequence, _and_ it is easy to detect in some\n    /// cases.\n    #[inline]\n    pub fn push(&mut self, lit: Literal) {\n        let lits = match self.literals {\n            None => return,\n            Some(ref mut lits) => lits,\n        };\n        if lits.last().map_or(false, |m| m == &lit) {\n            return;\n        }\n        lits.push(lit);\n    }\n\n    /// Make all of the literals in this sequence inexact.\n    ///\n    /// This is a no-op if this sequence is not finite.\n    #[inline]\n    pub fn make_inexact(&mut self) {\n        let lits = match self.literals {\n            None => return,\n            Some(ref mut lits) => lits,\n        };\n        for lit in lits.iter_mut() {\n            lit.make_inexact();\n        }\n    }\n\n    /// Converts this sequence to an infinite sequence.\n    ///\n    /// This is a no-op if the sequence is already infinite.\n    #[inline]\n    pub fn make_infinite(&mut self) {\n        self.literals = None;\n    }\n\n    /// Modify this sequence to contain the cross product between it and the\n    /// sequence given.\n    ///\n    /// The cross product only considers literals in this sequence that are\n    /// exact. That is, inexact literals are not extended.\n    ///\n    /// The literals are always drained from `other`, even if none are used.\n    /// This permits callers to reuse the sequence allocation elsewhere.\n    ///\n    /// If this sequence is infinite, then this is a no-op, regardless of what\n    /// `other` contains (and in this case, the literals are still drained from\n    /// `other`). If `other` is infinite and this sequence is finite, then this\n    /// is a no-op, unless this sequence contains a zero-length literal. In\n    /// which case, the infiniteness of `other` infects this sequence, and this\n    /// sequence is itself made infinite.\n    ///\n    /// Like [`Seq::union`], this may attempt to deduplicate literals. See\n    /// [`Seq::dedup`] for how deduplication deals with exact and inexact\n    /// literals.\n    ///\n    /// # Example\n    ///\n    /// This example shows basic usage and how exact and inexact literals\n    /// interact.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq1 = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// let mut seq2 = Seq::from_iter([\n    ///     Literal::inexact(\"quux\"),\n    ///     Literal::exact(\"baz\"),\n    /// ]);\n    /// seq1.cross_forward(&mut seq2);\n    ///\n    /// // The literals are pulled out of seq2.\n    /// assert_eq!(Some(0), seq2.len());\n    ///\n    /// let expected = Seq::from_iter([\n    ///     Literal::inexact(\"fooquux\"),\n    ///     Literal::exact(\"foobaz\"),\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// assert_eq!(expected, seq1);\n    /// ```\n    ///\n    /// This example shows the behavior of when `other` is an infinite\n    /// sequence.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq1 = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// let mut seq2 = Seq::infinite();\n    /// seq1.cross_forward(&mut seq2);\n    ///\n    /// // When seq2 is infinite, cross product doesn't add anything, but\n    /// // ensures all members of seq1 are inexact.\n    /// let expected = Seq::from_iter([\n    ///     Literal::inexact(\"foo\"),\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// assert_eq!(expected, seq1);\n    /// ```\n    ///\n    /// This example is like the one above, but shows what happens when this\n    /// sequence contains an empty string. In this case, an infinite `other`\n    /// sequence infects this sequence (because the empty string means that\n    /// there are no finite prefixes):\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq1 = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::exact(\"\"), // inexact provokes same behavior\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// let mut seq2 = Seq::infinite();\n    /// seq1.cross_forward(&mut seq2);\n    ///\n    /// // seq1 is now infinite!\n    /// assert!(!seq1.is_finite());\n    /// ```\n    ///\n    /// This example shows the behavior of this sequence is infinite.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq1 = Seq::infinite();\n    /// let mut seq2 = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// seq1.cross_forward(&mut seq2);\n    ///\n    /// // seq1 remains unchanged.\n    /// assert!(!seq1.is_finite());\n    /// // Even though the literals in seq2 weren't used, it was still drained.\n    /// assert_eq!(Some(0), seq2.len());\n    /// ```\n    #[inline]\n    pub fn cross_forward(&mut self, other: &mut Seq) {\n        let (lits1, lits2) = match self.cross_preamble(other) {\n            None => return,\n            Some((lits1, lits2)) => (lits1, lits2),\n        };\n        let newcap = lits1.len().saturating_mul(lits2.len());\n        for selflit in mem::replace(lits1, Vec::with_capacity(newcap)) {\n            if !selflit.is_exact() {\n                lits1.push(selflit);\n                continue;\n            }\n            for otherlit in lits2.iter() {\n                let mut newlit = Literal::exact(Vec::with_capacity(\n                    selflit.len() + otherlit.len(),\n                ));\n                newlit.extend(&selflit);\n                newlit.extend(&otherlit);\n                if !otherlit.is_exact() {\n                    newlit.make_inexact();\n                }\n                lits1.push(newlit);\n            }\n        }\n        lits2.drain(..);\n        self.dedup();\n    }\n\n    /// Modify this sequence to contain the cross product between it and\n    /// the sequence given, where the sequences are treated as suffixes\n    /// instead of prefixes. Namely, the sequence `other` is *prepended*\n    /// to `self` (as opposed to `other` being *appended* to `self` in\n    /// [`Seq::cross_forward`]).\n    ///\n    /// The cross product only considers literals in this sequence that are\n    /// exact. That is, inexact literals are not extended.\n    ///\n    /// The literals are always drained from `other`, even if none are used.\n    /// This permits callers to reuse the sequence allocation elsewhere.\n    ///\n    /// If this sequence is infinite, then this is a no-op, regardless of what\n    /// `other` contains (and in this case, the literals are still drained from\n    /// `other`). If `other` is infinite and this sequence is finite, then this\n    /// is a no-op, unless this sequence contains a zero-length literal. In\n    /// which case, the infiniteness of `other` infects this sequence, and this\n    /// sequence is itself made infinite.\n    ///\n    /// Like [`Seq::union`], this may attempt to deduplicate literals. See\n    /// [`Seq::dedup`] for how deduplication deals with exact and inexact\n    /// literals.\n    ///\n    /// # Example\n    ///\n    /// This example shows basic usage and how exact and inexact literals\n    /// interact.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq1 = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// let mut seq2 = Seq::from_iter([\n    ///     Literal::inexact(\"quux\"),\n    ///     Literal::exact(\"baz\"),\n    /// ]);\n    /// seq1.cross_reverse(&mut seq2);\n    ///\n    /// // The literals are pulled out of seq2.\n    /// assert_eq!(Some(0), seq2.len());\n    ///\n    /// let expected = Seq::from_iter([\n    ///     Literal::inexact(\"quuxfoo\"),\n    ///     Literal::inexact(\"bar\"),\n    ///     Literal::exact(\"bazfoo\"),\n    /// ]);\n    /// assert_eq!(expected, seq1);\n    /// ```\n    ///\n    /// This example shows the behavior of when `other` is an infinite\n    /// sequence.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq1 = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// let mut seq2 = Seq::infinite();\n    /// seq1.cross_reverse(&mut seq2);\n    ///\n    /// // When seq2 is infinite, cross product doesn't add anything, but\n    /// // ensures all members of seq1 are inexact.\n    /// let expected = Seq::from_iter([\n    ///     Literal::inexact(\"foo\"),\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// assert_eq!(expected, seq1);\n    /// ```\n    ///\n    /// This example is like the one above, but shows what happens when this\n    /// sequence contains an empty string. In this case, an infinite `other`\n    /// sequence infects this sequence (because the empty string means that\n    /// there are no finite suffixes):\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq1 = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::exact(\"\"), // inexact provokes same behavior\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// let mut seq2 = Seq::infinite();\n    /// seq1.cross_reverse(&mut seq2);\n    ///\n    /// // seq1 is now infinite!\n    /// assert!(!seq1.is_finite());\n    /// ```\n    ///\n    /// This example shows the behavior when this sequence is infinite.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq1 = Seq::infinite();\n    /// let mut seq2 = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::inexact(\"bar\"),\n    /// ]);\n    /// seq1.cross_reverse(&mut seq2);\n    ///\n    /// // seq1 remains unchanged.\n    /// assert!(!seq1.is_finite());\n    /// // Even though the literals in seq2 weren't used, it was still drained.\n    /// assert_eq!(Some(0), seq2.len());\n    /// ```\n    #[inline]\n    pub fn cross_reverse(&mut self, other: &mut Seq) {\n        let (lits1, lits2) = match self.cross_preamble(other) {\n            None => return,\n            Some((lits1, lits2)) => (lits1, lits2),\n        };\n        // We basically proceed as we do in 'cross_forward' at this point,\n        // except that the outer loop is now 'other' and the inner loop is now\n        // 'self'. That's because 'self' corresponds to suffixes and 'other'\n        // corresponds to the sequence we want to *prepend* to the suffixes.\n        let newcap = lits1.len().saturating_mul(lits2.len());\n        let selflits = mem::replace(lits1, Vec::with_capacity(newcap));\n        for (i, otherlit) in lits2.drain(..).enumerate() {\n            for selflit in selflits.iter() {\n                if !selflit.is_exact() {\n                    // If the suffix isn't exact, then we can't prepend\n                    // anything to it. However, we still want to keep it. But\n                    // we only want to keep one of them, to avoid duplication.\n                    // (The duplication is okay from a correctness perspective,\n                    // but wasteful.)\n                    if i == 0 {\n                        lits1.push(selflit.clone());\n                    }\n                    continue;\n                }\n                let mut newlit = Literal::exact(Vec::with_capacity(\n                    otherlit.len() + selflit.len(),\n                ));\n                newlit.extend(&otherlit);\n                newlit.extend(&selflit);\n                if !otherlit.is_exact() {\n                    newlit.make_inexact();\n                }\n                lits1.push(newlit);\n            }\n        }\n        self.dedup();\n    }\n\n    /// A helper function the corresponds to the subtle preamble for both\n    /// `cross_forward` and `cross_reverse`. In effect, it handles the cases\n    /// of infinite sequences for both `self` and `other`, as well as ensuring\n    /// that literals from `other` are drained even if they aren't used.\n    fn cross_preamble<'a>(\n        &'a mut self,\n        other: &'a mut Seq,\n    ) -> Option<(&'a mut Vec<Literal>, &'a mut Vec<Literal>)> {\n        let lits2 = match other.literals {\n            None => {\n                // If our current seq contains the empty string and the seq\n                // we're adding matches any literal, then it follows that the\n                // current seq must now also match any literal.\n                //\n                // Otherwise, we just have to make sure everything in this\n                // sequence is inexact.\n                if self.min_literal_len() == Some(0) {\n                    *self = Seq::infinite();\n                } else {\n                    self.make_inexact();\n                }\n                return None;\n            }\n            Some(ref mut lits) => lits,\n        };\n        let lits1 = match self.literals {\n            None => {\n                // If we aren't going to make it to the end of this routine\n                // where lits2 is drained, then we need to do it now.\n                lits2.drain(..);\n                return None;\n            }\n            Some(ref mut lits) => lits,\n        };\n        Some((lits1, lits2))\n    }\n\n    /// Unions the `other` sequence into this one.\n    ///\n    /// The literals are always drained out of the given `other` sequence,\n    /// even if they are being unioned into an infinite sequence. This permits\n    /// the caller to reuse the `other` sequence in another context.\n    ///\n    /// Some literal deduping may be performed. If any deduping happens,\n    /// any leftmost-first or \"preference\" order match semantics will be\n    /// preserved.\n    ///\n    /// # Example\n    ///\n    /// This example shows basic usage.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::Seq;\n    ///\n    /// let mut seq1 = Seq::new(&[\"foo\", \"bar\"]);\n    /// let mut seq2 = Seq::new(&[\"bar\", \"quux\", \"foo\"]);\n    /// seq1.union(&mut seq2);\n    ///\n    /// // The literals are pulled out of seq2.\n    /// assert_eq!(Some(0), seq2.len());\n    ///\n    /// // Adjacent literals are deduped, but non-adjacent literals may not be.\n    /// assert_eq!(Seq::new(&[\"foo\", \"bar\", \"quux\", \"foo\"]), seq1);\n    /// ```\n    ///\n    /// This example shows that literals are drained from `other` even when\n    /// they aren't necessarily used.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::Seq;\n    ///\n    /// let mut seq1 = Seq::infinite();\n    /// // Infinite sequences have no finite length.\n    /// assert_eq!(None, seq1.len());\n    ///\n    /// let mut seq2 = Seq::new(&[\"bar\", \"quux\", \"foo\"]);\n    /// seq1.union(&mut seq2);\n    ///\n    /// // seq1 is still infinite and seq2 has been drained.\n    /// assert_eq!(None, seq1.len());\n    /// assert_eq!(Some(0), seq2.len());\n    /// ```\n    #[inline]\n    pub fn union(&mut self, other: &mut Seq) {\n        let lits2 = match other.literals {\n            None => {\n                // Unioning with an infinite sequence always results in an\n                // infinite sequence.\n                self.make_infinite();\n                return;\n            }\n            Some(ref mut lits) => lits.drain(..),\n        };\n        let lits1 = match self.literals {\n            None => return,\n            Some(ref mut lits) => lits,\n        };\n        lits1.extend(lits2);\n        self.dedup();\n    }\n\n    /// Unions the `other` sequence into this one by splice the `other`\n    /// sequence at the position of the first zero-length literal.\n    ///\n    /// This is useful for preserving preference order semantics when combining\n    /// two literal sequences. For example, in the regex `(a||f)+foo`, the\n    /// correct preference order prefix sequence is `[a, foo, f]`.\n    ///\n    /// The literals are always drained out of the given `other` sequence,\n    /// even if they are being unioned into an infinite sequence. This permits\n    /// the caller to reuse the `other` sequence in another context. Note that\n    /// the literals are drained even if no union is performed as well, i.e.,\n    /// when this sequence does not contain a zero-length literal.\n    ///\n    /// Some literal deduping may be performed. If any deduping happens,\n    /// any leftmost-first or \"preference\" order match semantics will be\n    /// preserved.\n    ///\n    /// # Example\n    ///\n    /// This example shows basic usage.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::Seq;\n    ///\n    /// let mut seq1 = Seq::new(&[\"a\", \"\", \"f\", \"\"]);\n    /// let mut seq2 = Seq::new(&[\"foo\"]);\n    /// seq1.union_into_empty(&mut seq2);\n    ///\n    /// // The literals are pulled out of seq2.\n    /// assert_eq!(Some(0), seq2.len());\n    /// // 'foo' gets spliced into seq1 where the first empty string occurs.\n    /// assert_eq!(Seq::new(&[\"a\", \"foo\", \"f\"]), seq1);\n    /// ```\n    ///\n    /// This example shows that literals are drained from `other` even when\n    /// they aren't necessarily used.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::Seq;\n    ///\n    /// let mut seq1 = Seq::new(&[\"foo\", \"bar\"]);\n    /// let mut seq2 = Seq::new(&[\"bar\", \"quux\", \"foo\"]);\n    /// seq1.union_into_empty(&mut seq2);\n    ///\n    /// // seq1 has no zero length literals, so no splicing happens.\n    /// assert_eq!(Seq::new(&[\"foo\", \"bar\"]), seq1);\n    /// // Even though no splicing happens, seq2 is still drained.\n    /// assert_eq!(Some(0), seq2.len());\n    /// ```\n    #[inline]\n    pub fn union_into_empty(&mut self, other: &mut Seq) {\n        let lits2 = other.literals.as_mut().map(|lits| lits.drain(..));\n        let lits1 = match self.literals {\n            None => return,\n            Some(ref mut lits) => lits,\n        };\n        let first_empty = match lits1.iter().position(|m| m.is_empty()) {\n            None => return,\n            Some(i) => i,\n        };\n        let lits2 = match lits2 {\n            None => {\n                // Note that we are only here if we've found an empty literal,\n                // which implies that an infinite sequence infects this seq and\n                // also turns it into an infinite sequence.\n                self.literals = None;\n                return;\n            }\n            Some(lits) => lits,\n        };\n        // Clearing out the empties needs to come before the splice because\n        // the splice might add more empties that we don't want to get rid\n        // of. Since we're splicing into the position of the first empty, the\n        // 'first_empty' position computed above is still correct.\n        lits1.retain(|m| !m.is_empty());\n        lits1.splice(first_empty..first_empty, lits2);\n        self.dedup();\n    }\n\n    /// Deduplicate adjacent equivalent literals in this sequence.\n    ///\n    /// If adjacent literals are equivalent strings but one is exact and the\n    /// other inexact, the inexact literal is kept and the exact one is\n    /// removed.\n    ///\n    /// Deduping an infinite sequence is a no-op.\n    ///\n    /// # Example\n    ///\n    /// This example shows how literals that are duplicate byte strings but\n    /// are not equivalent with respect to exactness are resolved.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::inexact(\"foo\"),\n    /// ]);\n    /// seq.dedup();\n    ///\n    /// assert_eq!(Seq::from_iter([Literal::inexact(\"foo\")]), seq);\n    /// ```\n    #[inline]\n    pub fn dedup(&mut self) {\n        if let Some(ref mut lits) = self.literals {\n            lits.dedup_by(|lit1, lit2| {\n                if lit1.as_bytes() != lit2.as_bytes() {\n                    return false;\n                }\n                if lit1.is_exact() != lit2.is_exact() {\n                    lit1.make_inexact();\n                    lit2.make_inexact();\n                }\n                true\n            });\n        }\n    }\n\n    /// Sorts this sequence of literals lexicographically.\n    ///\n    /// Note that if, before sorting, if a literal that is a prefix of another\n    /// literal appears after it, then after sorting, the sequence will not\n    /// represent the same preference order match semantics. For example,\n    /// sorting the sequence `[samwise, sam]` yields the sequence `[sam,\n    /// samwise]`. Under preference order semantics, the latter sequence will\n    /// never match `samwise` where as the first sequence can.\n    ///\n    /// # Example\n    ///\n    /// This example shows basic usage.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::Seq;\n    ///\n    /// let mut seq = Seq::new(&[\"foo\", \"quux\", \"bar\"]);\n    /// seq.sort();\n    ///\n    /// assert_eq!(Seq::new(&[\"bar\", \"foo\", \"quux\"]), seq);\n    /// ```\n    #[inline]\n    pub fn sort(&mut self) {\n        if let Some(ref mut lits) = self.literals {\n            lits.sort();\n        }\n    }\n\n    /// Reverses all of the literals in this sequence.\n    ///\n    /// The order of the sequence itself is preserved.\n    ///\n    /// # Example\n    ///\n    /// This example shows basic usage.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::Seq;\n    ///\n    /// let mut seq = Seq::new(&[\"oof\", \"rab\"]);\n    /// seq.reverse_literals();\n    /// assert_eq!(Seq::new(&[\"foo\", \"bar\"]), seq);\n    /// ```\n    #[inline]\n    pub fn reverse_literals(&mut self) {\n        if let Some(ref mut lits) = self.literals {\n            for lit in lits.iter_mut() {\n                lit.reverse();\n            }\n        }\n    }\n\n    /// Shrinks this seq to its minimal size while respecting the preference\n    /// order of its literals.\n    ///\n    /// While this routine will remove duplicate literals from this seq, it\n    /// will also remove literals that can never match in a leftmost-first or\n    /// \"preference order\" search. Similar to [`Seq::dedup`], if a literal is\n    /// deduped, then the one that remains is made inexact.\n    ///\n    /// This is a no-op on seqs that are empty or not finite.\n    ///\n    /// # Example\n    ///\n    /// This example shows the difference between `{sam, samwise}` and\n    /// `{samwise, sam}`.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// // If 'sam' comes before 'samwise' and a preference order search is\n    /// // executed, then 'samwise' can never match.\n    /// let mut seq = Seq::new(&[\"sam\", \"samwise\"]);\n    /// seq.minimize_by_preference();\n    /// assert_eq!(Seq::from_iter([Literal::inexact(\"sam\")]), seq);\n    ///\n    /// // But if they are reversed, then it's possible for 'samwise' to match\n    /// // since it is given higher preference.\n    /// let mut seq = Seq::new(&[\"samwise\", \"sam\"]);\n    /// seq.minimize_by_preference();\n    /// assert_eq!(Seq::new(&[\"samwise\", \"sam\"]), seq);\n    /// ```\n    ///\n    /// This example shows that if an empty string is in this seq, then\n    /// anything that comes after it can never match.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// // An empty string is a prefix of all strings, so it automatically\n    /// // inhibits any subsequent strings from matching.\n    /// let mut seq = Seq::new(&[\"foo\", \"bar\", \"\", \"quux\", \"fox\"]);\n    /// seq.minimize_by_preference();\n    /// let expected = Seq::from_iter([\n    ///     Literal::exact(\"foo\"),\n    ///     Literal::exact(\"bar\"),\n    ///     Literal::inexact(\"\"),\n    /// ]);\n    /// assert_eq!(expected, seq);\n    ///\n    /// // And of course, if it's at the beginning, then it makes it impossible\n    /// // for anything else to match.\n    /// let mut seq = Seq::new(&[\"\", \"foo\", \"quux\", \"fox\"]);\n    /// seq.minimize_by_preference();\n    /// assert_eq!(Seq::from_iter([Literal::inexact(\"\")]), seq);\n    /// ```\n    #[inline]\n    pub fn minimize_by_preference(&mut self) {\n        if let Some(ref mut lits) = self.literals {\n            PreferenceTrie::minimize(lits, false);\n        }\n    }\n\n    /// Trims all literals in this seq such that only the first `len` bytes\n    /// remain. If a literal has less than or equal to `len` bytes, then it\n    /// remains unchanged. Otherwise, it is trimmed and made inexact.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq = Seq::new(&[\"a\", \"foo\", \"quux\"]);\n    /// seq.keep_first_bytes(2);\n    ///\n    /// let expected = Seq::from_iter([\n    ///     Literal::exact(\"a\"),\n    ///     Literal::inexact(\"fo\"),\n    ///     Literal::inexact(\"qu\"),\n    /// ]);\n    /// assert_eq!(expected, seq);\n    /// ```\n    #[inline]\n    pub fn keep_first_bytes(&mut self, len: usize) {\n        if let Some(ref mut lits) = self.literals {\n            for m in lits.iter_mut() {\n                m.keep_first_bytes(len);\n            }\n        }\n    }\n\n    /// Trims all literals in this seq such that only the last `len` bytes\n    /// remain. If a literal has less than or equal to `len` bytes, then it\n    /// remains unchanged. Otherwise, it is trimmed and made inexact.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Literal, Seq};\n    ///\n    /// let mut seq = Seq::new(&[\"a\", \"foo\", \"quux\"]);\n    /// seq.keep_last_bytes(2);\n    ///\n    /// let expected = Seq::from_iter([\n    ///     Literal::exact(\"a\"),\n    ///     Literal::inexact(\"oo\"),\n    ///     Literal::inexact(\"ux\"),\n    /// ]);\n    /// assert_eq!(expected, seq);\n    /// ```\n    #[inline]\n    pub fn keep_last_bytes(&mut self, len: usize) {\n        if let Some(ref mut lits) = self.literals {\n            for m in lits.iter_mut() {\n                m.keep_last_bytes(len);\n            }\n        }\n    }\n\n    /// Returns true if this sequence is finite.\n    ///\n    /// When false, this sequence is infinite and must be treated as if it\n    /// contains every possible literal.\n    #[inline]\n    pub fn is_finite(&self) -> bool {\n        self.literals.is_some()\n    }\n\n    /// Returns true if and only if this sequence is finite and empty.\n    ///\n    /// An empty sequence never matches anything. It can only be produced by\n    /// literal extraction when the corresponding regex itself cannot match.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == Some(0)\n    }\n\n    /// Returns the number of literals in this sequence if the sequence is\n    /// finite. If the sequence is infinite, then `None` is returned.\n    #[inline]\n    pub fn len(&self) -> Option<usize> {\n        self.literals.as_ref().map(|lits| lits.len())\n    }\n\n    /// Returns true if and only if all literals in this sequence are exact.\n    ///\n    /// This returns false if the sequence is infinite.\n    #[inline]\n    pub fn is_exact(&self) -> bool {\n        self.literals().map_or(false, |lits| lits.iter().all(|x| x.is_exact()))\n    }\n\n    /// Returns true if and only if all literals in this sequence are inexact.\n    ///\n    /// This returns true if the sequence is infinite.\n    #[inline]\n    pub fn is_inexact(&self) -> bool {\n        self.literals().map_or(true, |lits| lits.iter().all(|x| !x.is_exact()))\n    }\n\n    /// Return the maximum length of the sequence that would result from\n    /// unioning `self` with `other`. If either set is infinite, then this\n    /// returns `None`.\n    #[inline]\n    fn max_union_len(&self, other: &Seq) -> Option<usize> {\n        let len1 = self.len()?;\n        let len2 = other.len()?;\n        Some(len1.saturating_add(len2))\n    }\n\n    /// Return the maximum length of the sequence that would result from the\n    /// cross product of `self` with `other`. If either set is infinite, then\n    /// this returns `None`.\n    #[inline]\n    fn max_cross_len(&self, other: &Seq) -> Option<usize> {\n        let len1 = self.len()?;\n        let len2 = other.len()?;\n        Some(len1.saturating_mul(len2))\n    }\n\n    /// Returns the length of the shortest literal in this sequence.\n    ///\n    /// If the sequence is infinite or empty, then this returns `None`.\n    #[inline]\n    pub fn min_literal_len(&self) -> Option<usize> {\n        self.literals.as_ref()?.iter().map(|x| x.len()).min()\n    }\n\n    /// Returns the length of the longest literal in this sequence.\n    ///\n    /// If the sequence is infinite or empty, then this returns `None`.\n    #[inline]\n    pub fn max_literal_len(&self) -> Option<usize> {\n        self.literals.as_ref()?.iter().map(|x| x.len()).max()\n    }\n\n    /// Returns the longest common prefix from this seq.\n    ///\n    /// If the seq matches any literal or other contains no literals, then\n    /// there is no meaningful prefix and this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// This shows some example seqs and their longest common prefix.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::Seq;\n    ///\n    /// let seq = Seq::new(&[\"foo\", \"foobar\", \"fo\"]);\n    /// assert_eq!(Some(&b\"fo\"[..]), seq.longest_common_prefix());\n    /// let seq = Seq::new(&[\"foo\", \"foo\"]);\n    /// assert_eq!(Some(&b\"foo\"[..]), seq.longest_common_prefix());\n    /// let seq = Seq::new(&[\"foo\", \"bar\"]);\n    /// assert_eq!(Some(&b\"\"[..]), seq.longest_common_prefix());\n    /// let seq = Seq::new(&[\"\"]);\n    /// assert_eq!(Some(&b\"\"[..]), seq.longest_common_prefix());\n    ///\n    /// let seq = Seq::infinite();\n    /// assert_eq!(None, seq.longest_common_prefix());\n    /// let seq = Seq::empty();\n    /// assert_eq!(None, seq.longest_common_prefix());\n    /// ```\n    #[inline]\n    pub fn longest_common_prefix(&self) -> Option<&[u8]> {\n        // If we match everything or match nothing, then there's no meaningful\n        // longest common prefix.\n        let lits = match self.literals {\n            None => return None,\n            Some(ref lits) => lits,\n        };\n        if lits.len() == 0 {\n            return None;\n        }\n        let base = lits[0].as_bytes();\n        let mut len = base.len();\n        for m in lits.iter().skip(1) {\n            len = m\n                .as_bytes()\n                .iter()\n                .zip(base[..len].iter())\n                .take_while(|&(a, b)| a == b)\n                .count();\n            if len == 0 {\n                return Some(&[]);\n            }\n        }\n        Some(&base[..len])\n    }\n\n    /// Returns the longest common suffix from this seq.\n    ///\n    /// If the seq matches any literal or other contains no literals, then\n    /// there is no meaningful suffix and this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// This shows some example seqs and their longest common suffix.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::Seq;\n    ///\n    /// let seq = Seq::new(&[\"oof\", \"raboof\", \"of\"]);\n    /// assert_eq!(Some(&b\"of\"[..]), seq.longest_common_suffix());\n    /// let seq = Seq::new(&[\"foo\", \"foo\"]);\n    /// assert_eq!(Some(&b\"foo\"[..]), seq.longest_common_suffix());\n    /// let seq = Seq::new(&[\"foo\", \"bar\"]);\n    /// assert_eq!(Some(&b\"\"[..]), seq.longest_common_suffix());\n    /// let seq = Seq::new(&[\"\"]);\n    /// assert_eq!(Some(&b\"\"[..]), seq.longest_common_suffix());\n    ///\n    /// let seq = Seq::infinite();\n    /// assert_eq!(None, seq.longest_common_suffix());\n    /// let seq = Seq::empty();\n    /// assert_eq!(None, seq.longest_common_suffix());\n    /// ```\n    #[inline]\n    pub fn longest_common_suffix(&self) -> Option<&[u8]> {\n        // If we match everything or match nothing, then there's no meaningful\n        // longest common suffix.\n        let lits = match self.literals {\n            None => return None,\n            Some(ref lits) => lits,\n        };\n        if lits.len() == 0 {\n            return None;\n        }\n        let base = lits[0].as_bytes();\n        let mut len = base.len();\n        for m in lits.iter().skip(1) {\n            len = m\n                .as_bytes()\n                .iter()\n                .rev()\n                .zip(base[base.len() - len..].iter().rev())\n                .take_while(|&(a, b)| a == b)\n                .count();\n            if len == 0 {\n                return Some(&[]);\n            }\n        }\n        Some(&base[base.len() - len..])\n    }\n\n    /// Optimizes this seq while treating its literals as prefixes and\n    /// respecting the preference order of its literals.\n    ///\n    /// The specific way \"optimization\" works is meant to be an implementation\n    /// detail, as it essentially represents a set of heuristics. The goal\n    /// that optimization tries to accomplish is to make the literals in this\n    /// set reflect inputs that will result in a more effective prefilter.\n    /// Principally by reducing the false positive rate of candidates found by\n    /// the literals in this sequence. That is, when a match of a literal is\n    /// found, we would like it to be a strong predictor of the overall match\n    /// of the regex. If it isn't, then much time will be spent starting and\n    /// stopping the prefilter search and attempting to confirm the match only\n    /// to have it fail.\n    ///\n    /// Some of those heuristics might be:\n    ///\n    /// * Identifying a common prefix from a larger sequence of literals, and\n    /// shrinking the sequence down to that single common prefix.\n    /// * Rejecting the sequence entirely if it is believed to result in very\n    /// high false positive rate. When this happens, the sequence is made\n    /// infinite.\n    /// * Shrinking the sequence to a smaller number of literals representing\n    /// prefixes, but not shrinking it so much as to make literals too short.\n    /// (A sequence with very short literals, of 1 or 2 bytes, will typically\n    /// result in a higher false positive rate.)\n    ///\n    /// Optimization should only be run once extraction is complete. Namely,\n    /// optimization may make assumptions that do not compose with other\n    /// operations in the middle of extraction. For example, optimization will\n    /// reduce `[E(sam), E(samwise)]` to `[E(sam)]`, but such a transformation\n    /// is only valid if no other extraction will occur. If other extraction\n    /// may occur, then the correct transformation would be to `[I(sam)]`.\n    ///\n    /// The [`Seq::optimize_for_suffix_by_preference`] does the same thing, but\n    /// for suffixes.\n    ///\n    /// # Example\n    ///\n    /// This shows how optimization might transform a sequence. Note that\n    /// the specific behavior is not a documented guarantee. The heuristics\n    /// used are an implementation detail and may change over time in semver\n    /// compatible releases.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Seq, Literal};\n    ///\n    /// let mut seq = Seq::new(&[\n    ///     \"samantha\",\n    ///     \"sam\",\n    ///     \"samwise\",\n    ///     \"frodo\",\n    /// ]);\n    /// seq.optimize_for_prefix_by_preference();\n    /// assert_eq!(Seq::from_iter([\n    ///     Literal::exact(\"samantha\"),\n    ///     // Kept exact even though 'samwise' got pruned\n    ///     // because optimization assumes literal extraction\n    ///     // has finished.\n    ///     Literal::exact(\"sam\"),\n    ///     Literal::exact(\"frodo\"),\n    /// ]), seq);\n    /// ```\n    ///\n    /// # Example: optimization may make the sequence infinite\n    ///\n    /// If the heuristics deem that the sequence could cause a very high false\n    /// positive rate, then it may make the sequence infinite, effectively\n    /// disabling its use as a prefilter.\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Seq, Literal};\n    ///\n    /// let mut seq = Seq::new(&[\n    ///     \"samantha\",\n    ///     // An empty string matches at every position,\n    ///     // thus rendering the prefilter completely\n    ///     // ineffective.\n    ///     \"\",\n    ///     \"sam\",\n    ///     \"samwise\",\n    ///     \"frodo\",\n    /// ]);\n    /// seq.optimize_for_prefix_by_preference();\n    /// assert!(!seq.is_finite());\n    /// ```\n    ///\n    /// Do note that just because there is a `\" \"` in the sequence, that\n    /// doesn't mean the sequence will always be made infinite after it is\n    /// optimized. Namely, if the sequence is considered exact (any match\n    /// corresponds to an overall match of the original regex), then any match\n    /// is an overall match, and so the false positive rate is always `0`.\n    ///\n    /// To demonstrate this, we remove `samwise` from our sequence. This\n    /// results in no optimization happening and all literals remain exact.\n    /// Thus the entire sequence is exact, and it is kept as-is, even though\n    /// one is an ASCII space:\n    ///\n    /// ```\n    /// use regex_syntax::hir::literal::{Seq, Literal};\n    ///\n    /// let mut seq = Seq::new(&[\n    ///     \"samantha\",\n    ///     \" \",\n    ///     \"sam\",\n    ///     \"frodo\",\n    /// ]);\n    /// seq.optimize_for_prefix_by_preference();\n    /// assert!(seq.is_finite());\n    /// ```\n    #[inline]\n    pub fn optimize_for_prefix_by_preference(&mut self) {\n        self.optimize_by_preference(true);\n    }\n\n    /// Optimizes this seq while treating its literals as suffixes and\n    /// respecting the preference order of its literals.\n    ///\n    /// Optimization should only be run once extraction is complete.\n    ///\n    /// The [`Seq::optimize_for_prefix_by_preference`] does the same thing, but\n    /// for prefixes. See its documentation for more explanation.\n    #[inline]\n    pub fn optimize_for_suffix_by_preference(&mut self) {\n        self.optimize_by_preference(false);\n    }\n\n    fn optimize_by_preference(&mut self, prefix: bool) {\n        let origlen = match self.len() {\n            None => return,\n            Some(len) => len,\n        };\n        // Make sure we start with the smallest sequence possible. We use a\n        // special version of preference minimization that retains exactness.\n        // This is legal because optimization is only expected to occur once\n        // extraction is complete.\n        if prefix {\n            if let Some(ref mut lits) = self.literals {\n                PreferenceTrie::minimize(lits, true);\n            }\n        }\n\n        // Look for a common prefix (or suffix). If we found one of those and\n        // it's long enough, then it's a good bet that it will be our fastest\n        // possible prefilter since single-substring search is so fast.\n        let fix = if prefix {\n            self.longest_common_prefix()\n        } else {\n            self.longest_common_suffix()\n        };\n        if let Some(fix) = fix {\n            // As a special case, if we have a common prefix and the leading\n            // byte of that prefix is one that we think probably occurs rarely,\n            // then strip everything down to just that single byte. This should\n            // promote the use of memchr.\n            //\n            // ... we only do this though if our sequence has more than one\n            // literal. Otherwise, we'd rather just stick with a single literal\n            // scan. That is, using memchr is probably better than looking\n            // for 2 or more literals, but probably not as good as a straight\n            // memmem search.\n            //\n            // ... and also only do this when the prefix is short and probably\n            // not too discriminatory anyway. If it's longer, then it's\n            // probably quite discriminatory and thus is likely to have a low\n            // false positive rate.\n            if prefix\n                && origlen > 1\n                && fix.len() >= 1\n                && fix.len() <= 3\n                && rank(fix[0]) < 200\n            {\n                self.keep_first_bytes(1);\n                self.dedup();\n                return;\n            }\n            // We only strip down to the common prefix/suffix if we think\n            // the existing set of literals isn't great, or if the common\n            // prefix/suffix is expected to be particularly discriminatory.\n            let isfast =\n                self.is_exact() && self.len().map_or(false, |len| len <= 16);\n            let usefix = fix.len() > 4 || (fix.len() > 1 && !isfast);\n            if usefix {\n                // If we keep exactly the number of bytes equal to the length\n                // of the prefix (or suffix), then by the definition of a\n                // prefix, every literal in the sequence will be equivalent.\n                // Thus, 'dedup' will leave us with one literal.\n                //\n                // We do it this way to avoid an alloc, but also to make sure\n                // the exactness of literals is kept (or not).\n                if prefix {\n                    self.keep_first_bytes(fix.len());\n                } else {\n                    self.keep_last_bytes(fix.len());\n                }\n                self.dedup();\n                assert_eq!(Some(1), self.len());\n                // We still fall through here. In particular, we want our\n                // longest common prefix to be subject to the poison check.\n            }\n        }\n        // Everything below this check is more-or-less about trying to\n        // heuristically reduce the false positive rate of a prefilter. But\n        // if our sequence is completely exact, then it's possible the regex\n        // engine can be skipped entirely. In this case, the false positive\n        // rate is zero because every literal match corresponds to a regex\n        // match.\n        //\n        // This is OK even if the sequence contains a poison literal. Remember,\n        // a literal is only poisononous because of what we assume about its\n        // impact on the false positive rate. However, we do still check for\n        // an empty string. Empty strings are weird and it's best to let the\n        // regex engine handle those.\n        //\n        // We do currently do this check after the longest common prefix (or\n        // suffix) check, under the theory that single-substring search is so\n        // fast that we want that even if we'd end up turning an exact sequence\n        // into an inexact one. But this might be wrong...\n        if self.is_exact()\n            && self.min_literal_len().map_or(false, |len| len > 0)\n        {\n            return;\n        }\n        // Now we attempt to shorten the sequence. The idea here is that we\n        // don't want to look for too many literals, but we want to shorten\n        // our sequence enough to improve our odds of using better algorithms\n        // downstream (such as Teddy).\n        const ATTEMPTS: [(usize, usize); 5] =\n            [(5, 64), (4, 64), (3, 64), (2, 64), (1, 10)];\n        for (keep, limit) in ATTEMPTS {\n            let len = match self.len() {\n                None => break,\n                Some(len) => len,\n            };\n            if len <= limit {\n                break;\n            }\n            if prefix {\n                self.keep_first_bytes(keep);\n            } else {\n                self.keep_last_bytes(keep);\n            }\n            self.minimize_by_preference();\n        }\n        // Check for a poison literal. A poison literal is one that is short\n        // and is believed to have a very high match count. These poisons\n        // generally lead to a prefilter with a very high false positive rate,\n        // and thus overall worse performance.\n        //\n        // We do this last because we could have gone from a non-poisonous\n        // sequence to a poisonous one. Perhaps we should add some code to\n        // prevent such transitions in the first place, but then again, we\n        // likely only made the transition in the first place if the sequence\n        // was itself huge. And huge sequences are themselves poisonous. So...\n        if let Some(lits) = self.literals() {\n            if lits.iter().any(|lit| lit.is_poisonous()) {\n                self.make_infinite();\n            }\n        }\n    }\n}","impl core::fmt::Debug for Seq {\n    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n        write!(f, \"Seq\")?;\n        if let Some(lits) = self.literals() {\n            f.debug_list().entries(lits.iter()).finish()\n        } else {\n            write!(f, \"[∅]\")\n        }\n    }\n}"],"hir::literal::State":["Debug","Default"],"hir::print::Printer":["Debug","impl Printer {\n    /// Create a new printer.\n    pub fn new() -> Printer {\n        PrinterBuilder::new().build()\n    }\n\n    /// Print the given `Ast` to the given writer. The writer must implement\n    /// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n    /// here are a `fmt::Formatter` (which is available in `fmt::Display`\n    /// implementations) or a `&mut String`.\n    pub fn print<W: fmt::Write>(&mut self, hir: &Hir, wtr: W) -> fmt::Result {\n        visitor::visit(hir, Writer { wtr })\n    }\n}"],"hir::print::PrinterBuilder":["Clone","Debug","impl Default for PrinterBuilder {\n    fn default() -> PrinterBuilder {\n        PrinterBuilder::new()\n    }\n}","impl PrinterBuilder {\n    fn new() -> PrinterBuilder {\n        PrinterBuilder { _priv: () }\n    }\n\n    fn build(&self) -> Printer {\n        Printer { _priv: () }\n    }\n}"],"hir::print::Writer":["Debug","impl<W: fmt::Write> Visitor for Writer<W> {\n    type Output = ();\n    type Err = fmt::Error;\n\n    fn finish(self) -> fmt::Result {\n        Ok(())\n    }\n\n    fn visit_pre(&mut self, hir: &Hir) -> fmt::Result {\n        match *hir.kind() {\n            // Empty is represented by nothing in the concrete syntax, and\n            // repetition operators are strictly suffix oriented.\n            HirKind::Empty | HirKind::Repetition(_) => {}\n            HirKind::Literal(hir::Literal(ref bytes)) => {\n                // See the comment on the 'Concat' and 'Alternation' case below\n                // for why we put parens here. Literals are, conceptually,\n                // a special case of concatenation where each element is a\n                // character. The HIR flattens this into a Box<[u8]>, but we\n                // still need to treat it like a concatenation for correct\n                // printing. As a special case, we don't write parens if there\n                // is only one character. One character means there is no\n                // concat so we don't need parens. Adding parens would still be\n                // correct, but we drop them here because it tends to create\n                // rather noisy regexes even in simple cases.\n                let result = core::str::from_utf8(bytes);\n                let len = result.map_or(bytes.len(), |s| s.chars().count());\n                if len > 1 {\n                    self.wtr.write_str(r\"(?:\")?;\n                }\n                match result {\n                    Ok(string) => {\n                        for c in string.chars() {\n                            self.write_literal_char(c)?;\n                        }\n                    }\n                    Err(_) => {\n                        for &b in bytes.iter() {\n                            self.write_literal_byte(b)?;\n                        }\n                    }\n                }\n                if len > 1 {\n                    self.wtr.write_str(r\")\")?;\n                }\n            }\n            HirKind::Class(hir::Class::Unicode(ref cls)) => {\n                if cls.ranges().is_empty() {\n                    return self.wtr.write_str(\"[a&&b]\");\n                }\n                self.wtr.write_str(\"[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_char(range.start())?;\n                    } else if u32::from(range.start()) + 1\n                        == u32::from(range.end())\n                    {\n                        self.write_literal_char(range.start())?;\n                        self.write_literal_char(range.end())?;\n                    } else {\n                        self.write_literal_char(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_char(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"]\")?;\n            }\n            HirKind::Class(hir::Class::Bytes(ref cls)) => {\n                if cls.ranges().is_empty() {\n                    return self.wtr.write_str(\"[a&&b]\");\n                }\n                self.wtr.write_str(\"(?-u:[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_class_byte(range.start())?;\n                    } else if range.start() + 1 == range.end() {\n                        self.write_literal_class_byte(range.start())?;\n                        self.write_literal_class_byte(range.end())?;\n                    } else {\n                        self.write_literal_class_byte(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_class_byte(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"])\")?;\n            }\n            HirKind::Look(ref look) => match *look {\n                hir::Look::Start => {\n                    self.wtr.write_str(r\"\\A\")?;\n                }\n                hir::Look::End => {\n                    self.wtr.write_str(r\"\\z\")?;\n                }\n                hir::Look::StartLF => {\n                    self.wtr.write_str(\"(?m:^)\")?;\n                }\n                hir::Look::EndLF => {\n                    self.wtr.write_str(\"(?m:$)\")?;\n                }\n                hir::Look::StartCRLF => {\n                    self.wtr.write_str(\"(?mR:^)\")?;\n                }\n                hir::Look::EndCRLF => {\n                    self.wtr.write_str(\"(?mR:$)\")?;\n                }\n                hir::Look::WordAscii => {\n                    self.wtr.write_str(r\"(?-u:\\b)\")?;\n                }\n                hir::Look::WordAsciiNegate => {\n                    self.wtr.write_str(r\"(?-u:\\B)\")?;\n                }\n                hir::Look::WordUnicode => {\n                    self.wtr.write_str(r\"\\b\")?;\n                }\n                hir::Look::WordUnicodeNegate => {\n                    self.wtr.write_str(r\"\\B\")?;\n                }\n            },\n            HirKind::Capture(hir::Capture { ref name, .. }) => {\n                self.wtr.write_str(\"(\")?;\n                if let Some(ref name) = *name {\n                    write!(self.wtr, \"?P<{}>\", name)?;\n                }\n            }\n            // Why do this? Wrapping concats and alts in non-capturing groups\n            // is not *always* necessary, but is sometimes necessary. For\n            // example, 'concat(a, alt(b, c))' should be written as 'a(?:b|c)'\n            // and not 'ab|c'. The former is clearly the intended meaning, but\n            // the latter is actually 'alt(concat(a, b), c)'.\n            //\n            // It would be possible to only group these things in cases where\n            // it's strictly necessary, but it requires knowing the parent\n            // expression. And since this technique is simpler and always\n            // correct, we take this route. More to the point, it is a non-goal\n            // of an HIR printer to show a nice easy-to-read regex. Indeed,\n            // its construction forbids it from doing so. Therefore, inserting\n            // extra groups where they aren't necessary is perfectly okay.\n            HirKind::Concat(_) | HirKind::Alternation(_) => {\n                self.wtr.write_str(r\"(?:\")?;\n            }\n        }\n        Ok(())\n    }\n\n    fn visit_post(&mut self, hir: &Hir) -> fmt::Result {\n        match *hir.kind() {\n            // Handled during visit_pre\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Look(_) => {}\n            HirKind::Repetition(ref x) => {\n                match (x.min, x.max) {\n                    (0, Some(1)) => {\n                        self.wtr.write_str(\"?\")?;\n                    }\n                    (0, None) => {\n                        self.wtr.write_str(\"*\")?;\n                    }\n                    (1, None) => {\n                        self.wtr.write_str(\"+\")?;\n                    }\n                    (1, Some(1)) => {\n                        // 'a{1}' and 'a{1}?' are exactly equivalent to 'a'.\n                        return Ok(());\n                    }\n                    (m, None) => {\n                        write!(self.wtr, \"{{{},}}\", m)?;\n                    }\n                    (m, Some(n)) if m == n => {\n                        write!(self.wtr, \"{{{}}}\", m)?;\n                        // a{m} and a{m}? are always exactly equivalent.\n                        return Ok(());\n                    }\n                    (m, Some(n)) => {\n                        write!(self.wtr, \"{{{},{}}}\", m, n)?;\n                    }\n                }\n                if !x.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n            }\n            HirKind::Capture(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => {\n                self.wtr.write_str(r\")\")?;\n            }\n        }\n        Ok(())\n    }\n\n    fn visit_alternation_in(&mut self) -> fmt::Result {\n        self.wtr.write_str(\"|\")\n    }\n}","impl<W: fmt::Write> Writer<W> {\n    fn write_literal_char(&mut self, c: char) -> fmt::Result {\n        if is_meta_character(c) {\n            self.wtr.write_str(\"\\\\\")?;\n        }\n        self.wtr.write_char(c)\n    }\n\n    fn write_literal_byte(&mut self, b: u8) -> fmt::Result {\n        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {\n            self.write_literal_char(char::try_from(b).unwrap())\n        } else {\n            write!(self.wtr, \"(?-u:\\\\x{:02X})\", b)\n        }\n    }\n\n    fn write_literal_class_byte(&mut self, b: u8) -> fmt::Result {\n        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {\n            self.write_literal_char(char::try_from(b).unwrap())\n        } else {\n            write!(self.wtr, \"\\\\x{:02X}\", b)\n        }\n    }\n}"],"hir::translate::Flags":["Clone","Copy","Debug","Default","impl Flags {\n    fn from_ast(ast: &ast::Flags) -> Flags {\n        let mut flags = Flags::default();\n        let mut enable = true;\n        for item in &ast.items {\n            match item.kind {\n                ast::FlagsItemKind::Negation => {\n                    enable = false;\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive) => {\n                    flags.case_insensitive = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::MultiLine) => {\n                    flags.multi_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::DotMatchesNewLine) => {\n                    flags.dot_matches_new_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::SwapGreed) => {\n                    flags.swap_greed = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::Unicode) => {\n                    flags.unicode = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::CRLF) => {\n                    flags.crlf = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::IgnoreWhitespace) => {}\n            }\n        }\n        flags\n    }\n\n    fn merge(&mut self, previous: &Flags) {\n        if self.case_insensitive.is_none() {\n            self.case_insensitive = previous.case_insensitive;\n        }\n        if self.multi_line.is_none() {\n            self.multi_line = previous.multi_line;\n        }\n        if self.dot_matches_new_line.is_none() {\n            self.dot_matches_new_line = previous.dot_matches_new_line;\n        }\n        if self.swap_greed.is_none() {\n            self.swap_greed = previous.swap_greed;\n        }\n        if self.unicode.is_none() {\n            self.unicode = previous.unicode;\n        }\n        if self.crlf.is_none() {\n            self.crlf = previous.crlf;\n        }\n    }\n\n    fn dot(&self) -> hir::Dot {\n        if self.dot_matches_new_line() {\n            if self.unicode() {\n                hir::Dot::AnyChar\n            } else {\n                hir::Dot::AnyByte\n            }\n        } else {\n            if self.unicode() {\n                if self.crlf() {\n                    hir::Dot::AnyCharExceptCRLF\n                } else {\n                    hir::Dot::AnyCharExceptLF\n                }\n            } else {\n                if self.crlf() {\n                    hir::Dot::AnyByteExceptCRLF\n                } else {\n                    hir::Dot::AnyByteExceptLF\n                }\n            }\n        }\n    }\n\n    fn case_insensitive(&self) -> bool {\n        self.case_insensitive.unwrap_or(false)\n    }\n\n    fn multi_line(&self) -> bool {\n        self.multi_line.unwrap_or(false)\n    }\n\n    fn dot_matches_new_line(&self) -> bool {\n        self.dot_matches_new_line.unwrap_or(false)\n    }\n\n    fn swap_greed(&self) -> bool {\n        self.swap_greed.unwrap_or(false)\n    }\n\n    fn unicode(&self) -> bool {\n        self.unicode.unwrap_or(true)\n    }\n\n    fn crlf(&self) -> bool {\n        self.crlf.unwrap_or(false)\n    }\n}"],"hir::translate::HirFrame":["Clone","Debug","impl HirFrame {\n    /// Assert that the current stack frame is an Hir expression and return it.\n    fn unwrap_expr(self) -> Hir {\n        match self {\n            HirFrame::Expr(expr) => expr,\n            HirFrame::Literal(lit) => Hir::literal(lit),\n            _ => panic!(\"tried to unwrap expr from HirFrame, got: {:?}\", self),\n        }\n    }\n\n    /// Assert that the current stack frame is a Unicode class expression and\n    /// return it.\n    fn unwrap_class_unicode(self) -> hir::ClassUnicode {\n        match self {\n            HirFrame::ClassUnicode(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap Unicode class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }\n\n    /// Assert that the current stack frame is a byte class expression and\n    /// return it.\n    fn unwrap_class_bytes(self) -> hir::ClassBytes {\n        match self {\n            HirFrame::ClassBytes(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap byte class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }\n\n    /// Assert that the current stack frame is a repetition sentinel. If it\n    /// isn't, then panic.\n    fn unwrap_repetition(self) {\n        match self {\n            HirFrame::Repetition => {}\n            _ => {\n                panic!(\n                    \"tried to unwrap repetition from HirFrame, got: {:?}\",\n                    self\n                )\n            }\n        }\n    }\n\n    /// Assert that the current stack frame is a group indicator and return\n    /// its corresponding flags (the flags that were active at the time the\n    /// group was entered).\n    fn unwrap_group(self) -> Flags {\n        match self {\n            HirFrame::Group { old_flags } => old_flags,\n            _ => {\n                panic!(\"tried to unwrap group from HirFrame, got: {:?}\", self)\n            }\n        }\n    }\n\n    /// Assert that the current stack frame is an alternation pipe sentinel. If\n    /// it isn't, then panic.\n    fn unwrap_alternation_pipe(self) {\n        match self {\n            HirFrame::AlternationBranch => {}\n            _ => {\n                panic!(\n                    \"tried to unwrap alt pipe from HirFrame, got: {:?}\",\n                    self\n                )\n            }\n        }\n    }\n}"],"hir::translate::Translator":["Clone","Debug","impl Translator {\n    /// Create a new translator using the default configuration.\n    pub fn new() -> Translator {\n        TranslatorBuilder::new().build()\n    }\n\n    /// Translate the given abstract syntax tree (AST) into a high level\n    /// intermediate representation (HIR).\n    ///\n    /// If there was a problem doing the translation, then an HIR-specific\n    /// error is returned.\n    ///\n    /// The original pattern string used to produce the `Ast` *must* also be\n    /// provided. The translator does not use the pattern string during any\n    /// correct translation, but is used for error reporting.\n    pub fn translate(&mut self, pattern: &str, ast: &Ast) -> Result<Hir> {\n        ast::visit(ast, TranslatorI::new(self, pattern))\n    }\n}"],"hir::translate::TranslatorBuilder":["Clone","Debug","impl Default for TranslatorBuilder {\n    fn default() -> TranslatorBuilder {\n        TranslatorBuilder::new()\n    }\n}","impl TranslatorBuilder {\n    /// Create a new translator builder with a default c onfiguration.\n    pub fn new() -> TranslatorBuilder {\n        TranslatorBuilder { utf8: true, flags: Flags::default() }\n    }\n\n    /// Build a translator using the current configuration.\n    pub fn build(&self) -> Translator {\n        Translator {\n            stack: RefCell::new(vec![]),\n            flags: Cell::new(self.flags),\n            utf8: self.utf8,\n        }\n    }\n\n    /// When disabled, translation will permit the construction of a regular\n    /// expression that may match invalid UTF-8.\n    ///\n    /// When enabled (the default), the translator is guaranteed to produce an\n    /// expression that, for non-empty matches, will only ever produce spans\n    /// that are entirely valid UTF-8 (otherwise, the translator will return an\n    /// error).\n    ///\n    /// Perhaps surprisingly, when UTF-8 is enabled, an empty regex or even\n    /// a negated ASCII word boundary (uttered as `(?-u:\\B)` in the concrete\n    /// syntax) will be allowed even though they can produce matches that split\n    /// a UTF-8 encoded codepoint. This only applies to zero-width or \"empty\"\n    /// matches, and it is expected that the regex engine itself must handle\n    /// these cases if necessary (perhaps by suppressing any zero-width matches\n    /// that split a codepoint).\n    pub fn utf8(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.utf8 = yes;\n        self\n    }\n\n    /// Enable or disable the case insensitive flag (`i`) by default.\n    pub fn case_insensitive(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.case_insensitive = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the multi-line matching flag (`m`) by default.\n    pub fn multi_line(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.multi_line = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the \"dot matches any character\" flag (`s`) by\n    /// default.\n    pub fn dot_matches_new_line(\n        &mut self,\n        yes: bool,\n    ) -> &mut TranslatorBuilder {\n        self.flags.dot_matches_new_line = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the CRLF mode flag (`R`) by default.\n    pub fn crlf(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.crlf = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the \"swap greed\" flag (`U`) by default.\n    pub fn swap_greed(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.swap_greed = if yes { Some(true) } else { None };\n        self\n    }\n\n    /// Enable or disable the Unicode flag (`u`) by default.\n    pub fn unicode(&mut self, yes: bool) -> &mut TranslatorBuilder {\n        self.flags.unicode = if yes { None } else { Some(false) };\n        self\n    }\n}"],"hir::translate::TranslatorI":["Clone","Debug","impl<'t, 'p> TranslatorI<'t, 'p> {\n    /// Build a new internal translator.\n    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n        TranslatorI { trans, pattern }\n    }\n\n    /// Return a reference to the underlying translator.\n    fn trans(&self) -> &Translator {\n        &self.trans\n    }\n\n    /// Push the given frame on to the call stack.\n    fn push(&self, frame: HirFrame) {\n        self.trans().stack.borrow_mut().push(frame);\n    }\n\n    /// Push the given literal char on to the call stack.\n    ///\n    /// If the top-most element of the stack is a literal, then the char\n    /// is appended to the end of that literal. Otherwise, a new literal\n    /// containing just the given char is pushed to the top of the stack.\n    fn push_char(&self, ch: char) {\n        let mut buf = [0; 4];\n        let bytes = ch.encode_utf8(&mut buf).as_bytes();\n        let mut stack = self.trans().stack.borrow_mut();\n        if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {\n            literal.extend_from_slice(bytes);\n        } else {\n            stack.push(HirFrame::Literal(bytes.to_vec()));\n        }\n    }\n\n    /// Push the given literal byte on to the call stack.\n    ///\n    /// If the top-most element of the stack is a literal, then the byte\n    /// is appended to the end of that literal. Otherwise, a new literal\n    /// containing just the given byte is pushed to the top of the stack.\n    fn push_byte(&self, byte: u8) {\n        let mut stack = self.trans().stack.borrow_mut();\n        if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {\n            literal.push(byte);\n        } else {\n            stack.push(HirFrame::Literal(vec![byte]));\n        }\n    }\n\n    /// Pop the top of the call stack. If the call stack is empty, return None.\n    fn pop(&self) -> Option<HirFrame> {\n        self.trans().stack.borrow_mut().pop()\n    }\n\n    /// Pop an HIR expression from the top of the stack for a concatenation.\n    ///\n    /// This returns None if the stack is empty or when a concat frame is seen.\n    /// Otherwise, it panics if it could not find an HIR expression.\n    fn pop_concat_expr(&self) -> Option<Hir> {\n        let frame = self.pop()?;\n        match frame {\n            HirFrame::Concat => None,\n            HirFrame::Expr(expr) => Some(expr),\n            HirFrame::Literal(lit) => Some(Hir::literal(lit)),\n            HirFrame::ClassUnicode(_) => {\n                unreachable!(\"expected expr or concat, got Unicode class\")\n            }\n            HirFrame::ClassBytes(_) => {\n                unreachable!(\"expected expr or concat, got byte class\")\n            }\n            HirFrame::Repetition => {\n                unreachable!(\"expected expr or concat, got repetition\")\n            }\n            HirFrame::Group { .. } => {\n                unreachable!(\"expected expr or concat, got group\")\n            }\n            HirFrame::Alternation => {\n                unreachable!(\"expected expr or concat, got alt marker\")\n            }\n            HirFrame::AlternationBranch => {\n                unreachable!(\"expected expr or concat, got alt branch marker\")\n            }\n        }\n    }\n\n    /// Pop an HIR expression from the top of the stack for an alternation.\n    ///\n    /// This returns None if the stack is empty or when an alternation frame is\n    /// seen. Otherwise, it panics if it could not find an HIR expression.\n    fn pop_alt_expr(&self) -> Option<Hir> {\n        let frame = self.pop()?;\n        match frame {\n            HirFrame::Alternation => None,\n            HirFrame::Expr(expr) => Some(expr),\n            HirFrame::Literal(lit) => Some(Hir::literal(lit)),\n            HirFrame::ClassUnicode(_) => {\n                unreachable!(\"expected expr or alt, got Unicode class\")\n            }\n            HirFrame::ClassBytes(_) => {\n                unreachable!(\"expected expr or alt, got byte class\")\n            }\n            HirFrame::Repetition => {\n                unreachable!(\"expected expr or alt, got repetition\")\n            }\n            HirFrame::Group { .. } => {\n                unreachable!(\"expected expr or alt, got group\")\n            }\n            HirFrame::Concat => {\n                unreachable!(\"expected expr or alt, got concat marker\")\n            }\n            HirFrame::AlternationBranch => {\n                unreachable!(\"expected expr or alt, got alt branch marker\")\n            }\n        }\n    }\n\n    /// Create a new error with the given span and error type.\n    fn error(&self, span: Span, kind: ErrorKind) -> Error {\n        Error { kind, pattern: self.pattern.to_string(), span }\n    }\n\n    /// Return a copy of the active flags.\n    fn flags(&self) -> Flags {\n        self.trans().flags.get()\n    }\n\n    /// Set the flags of this translator from the flags set in the given AST.\n    /// Then, return the old flags.\n    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {\n        let old_flags = self.flags();\n        let mut new_flags = Flags::from_ast(ast_flags);\n        new_flags.merge(&old_flags);\n        self.trans().flags.set(new_flags);\n        old_flags\n    }\n\n    /// Convert an Ast literal to its scalar representation.\n    ///\n    /// When Unicode mode is enabled, then this always succeeds and returns a\n    /// `char` (Unicode scalar value).\n    ///\n    /// When Unicode mode is disabled, then a `char` will still be returned\n    /// whenever possible. A byte is returned only when invalid UTF-8 is\n    /// allowed and when the byte is not ASCII. Otherwise, a non-ASCII byte\n    /// will result in an error when invalid UTF-8 is not allowed.\n    fn ast_literal_to_scalar(\n        &self,\n        lit: &ast::Literal,\n    ) -> Result<Either<char, u8>> {\n        if self.flags().unicode() {\n            return Ok(Either::Left(lit.c));\n        }\n        let byte = match lit.byte() {\n            None => return Ok(Either::Left(lit.c)),\n            Some(byte) => byte,\n        };\n        if byte <= 0x7F {\n            return Ok(Either::Left(char::try_from(byte).unwrap()));\n        }\n        if self.trans().utf8 {\n            return Err(self.error(lit.span, ErrorKind::InvalidUtf8));\n        }\n        Ok(Either::Right(byte))\n    }\n\n    fn case_fold_char(&self, span: Span, c: char) -> Result<Option<Hir>> {\n        if !self.flags().case_insensitive() {\n            return Ok(None);\n        }\n        if self.flags().unicode() {\n            // If case folding won't do anything, then don't bother trying.\n            let map = unicode::SimpleCaseFolder::new()\n                .map(|f| f.overlaps(c, c))\n                .map_err(|_| {\n                    self.error(span, ErrorKind::UnicodeCaseUnavailable)\n                })?;\n            if !map {\n                return Ok(None);\n            }\n            let mut cls =\n                hir::ClassUnicode::new(vec![hir::ClassUnicodeRange::new(\n                    c, c,\n                )]);\n            cls.try_case_fold_simple().map_err(|_| {\n                self.error(span, ErrorKind::UnicodeCaseUnavailable)\n            })?;\n            Ok(Some(Hir::class(hir::Class::Unicode(cls))))\n        } else {\n            if c.len_utf8() > 1 {\n                return Err(self.error(span, ErrorKind::UnicodeNotAllowed));\n            }\n            // If case folding won't do anything, then don't bother trying.\n            match c {\n                'A'..='Z' | 'a'..='z' => {}\n                _ => return Ok(None),\n            }\n            let mut cls =\n                hir::ClassBytes::new(vec![hir::ClassBytesRange::new(\n                    // OK because 'c.len_utf8() == 1' which in turn implies\n                    // that 'c' is ASCII.\n                    u8::try_from(c).unwrap(),\n                    u8::try_from(c).unwrap(),\n                )]);\n            cls.case_fold_simple();\n            Ok(Some(Hir::class(hir::Class::Bytes(cls))))\n        }\n    }\n\n    fn hir_dot(&self, span: Span) -> Result<Hir> {\n        if !self.flags().unicode() && self.trans().utf8 {\n            return Err(self.error(span, ErrorKind::InvalidUtf8));\n        }\n        Ok(Hir::dot(self.flags().dot()))\n    }\n\n    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {\n        let unicode = self.flags().unicode();\n        let multi_line = self.flags().multi_line();\n        let crlf = self.flags().crlf();\n        Ok(match asst.kind {\n            ast::AssertionKind::StartLine => Hir::look(if multi_line {\n                if crlf {\n                    hir::Look::StartCRLF\n                } else {\n                    hir::Look::StartLF\n                }\n            } else {\n                hir::Look::Start\n            }),\n            ast::AssertionKind::EndLine => Hir::look(if multi_line {\n                if crlf {\n                    hir::Look::EndCRLF\n                } else {\n                    hir::Look::EndLF\n                }\n            } else {\n                hir::Look::End\n            }),\n            ast::AssertionKind::StartText => Hir::look(hir::Look::Start),\n            ast::AssertionKind::EndText => Hir::look(hir::Look::End),\n            ast::AssertionKind::WordBoundary => Hir::look(if unicode {\n                hir::Look::WordUnicode\n            } else {\n                hir::Look::WordAscii\n            }),\n            ast::AssertionKind::NotWordBoundary => Hir::look(if unicode {\n                hir::Look::WordUnicodeNegate\n            } else {\n                hir::Look::WordAsciiNegate\n            }),\n        })\n    }\n\n    fn hir_capture(&self, group: &ast::Group, expr: Hir) -> Hir {\n        let (index, name) = match group.kind {\n            ast::GroupKind::CaptureIndex(index) => (index, None),\n            ast::GroupKind::CaptureName { ref name, .. } => {\n                (name.index, Some(name.name.clone().into_boxed_str()))\n            }\n            // The HIR doesn't need to use non-capturing groups, since the way\n            // in which the data type is defined handles this automatically.\n            ast::GroupKind::NonCapturing(_) => return expr,\n        };\n        Hir::capture(hir::Capture { index, name, sub: Box::new(expr) })\n    }\n\n    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {\n        let (min, max) = match rep.op.kind {\n            ast::RepetitionKind::ZeroOrOne => (0, Some(1)),\n            ast::RepetitionKind::ZeroOrMore => (0, None),\n            ast::RepetitionKind::OneOrMore => (1, None),\n            ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {\n                (m, Some(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {\n                (m, None)\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(\n                m,\n                n,\n            )) => (m, Some(n)),\n        };\n        let greedy =\n            if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };\n        Hir::repetition(hir::Repetition {\n            min,\n            max,\n            greedy,\n            sub: Box::new(expr),\n        })\n    }\n\n    fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode> {\n        use crate::ast::ClassUnicodeKind::*;\n\n        if !self.flags().unicode() {\n            return Err(\n                self.error(ast_class.span, ErrorKind::UnicodeNotAllowed)\n            );\n        }\n        let query = match ast_class.kind {\n            OneLetter(name) => ClassQuery::OneLetter(name),\n            Named(ref name) => ClassQuery::Binary(name),\n            NamedValue { ref name, ref value, .. } => ClassQuery::ByValue {\n                property_name: name,\n                property_value: value,\n            },\n        };\n        let mut result = self.convert_unicode_class_error(\n            &ast_class.span,\n            unicode::class(query),\n        );\n        if let Ok(ref mut class) = result {\n            self.unicode_fold_and_negate(\n                &ast_class.span,\n                ast_class.negated,\n                class,\n            )?;\n        }\n        result\n    }\n\n    fn hir_ascii_unicode_class(\n        &self,\n        ast: &ast::ClassAscii,\n    ) -> Result<hir::ClassUnicode> {\n        let mut cls = hir::ClassUnicode::new(\n            ascii_class_as_chars(&ast.kind)\n                .map(|(s, e)| hir::ClassUnicodeRange::new(s, e)),\n        );\n        self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls)?;\n        Ok(cls)\n    }\n\n    fn hir_ascii_byte_class(\n        &self,\n        ast: &ast::ClassAscii,\n    ) -> Result<hir::ClassBytes> {\n        let mut cls = hir::ClassBytes::new(\n            ascii_class(&ast.kind)\n                .map(|(s, e)| hir::ClassBytesRange::new(s, e)),\n        );\n        self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls)?;\n        Ok(cls)\n    }\n\n    fn hir_perl_unicode_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassUnicode> {\n        use crate::ast::ClassPerlKind::*;\n\n        assert!(self.flags().unicode());\n        let result = match ast_class.kind {\n            Digit => unicode::perl_digit(),\n            Space => unicode::perl_space(),\n            Word => unicode::perl_word(),\n        };\n        let mut class =\n            self.convert_unicode_class_error(&ast_class.span, result)?;\n        // We needn't apply case folding here because the Perl Unicode classes\n        // are already closed under Unicode simple case folding.\n        if ast_class.negated {\n            class.negate();\n        }\n        Ok(class)\n    }\n\n    fn hir_perl_byte_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassBytes> {\n        use crate::ast::ClassPerlKind::*;\n\n        assert!(!self.flags().unicode());\n        let mut class = match ast_class.kind {\n            Digit => hir_ascii_class_bytes(&ast::ClassAsciiKind::Digit),\n            Space => hir_ascii_class_bytes(&ast::ClassAsciiKind::Space),\n            Word => hir_ascii_class_bytes(&ast::ClassAsciiKind::Word),\n        };\n        // We needn't apply case folding here because the Perl ASCII classes\n        // are already closed (under ASCII case folding).\n        if ast_class.negated {\n            class.negate();\n        }\n        // Negating a Perl byte class is likely to cause it to match invalid\n        // UTF-8. That's only OK if the translator is configured to allow such\n        // things.\n        if self.trans().utf8 && !class.is_ascii() {\n            return Err(self.error(ast_class.span, ErrorKind::InvalidUtf8));\n        }\n        Ok(class)\n    }\n\n    /// Converts the given Unicode specific error to an HIR translation error.\n    ///\n    /// The span given should approximate the position at which an error would\n    /// occur.\n    fn convert_unicode_class_error(\n        &self,\n        span: &Span,\n        result: core::result::Result<hir::ClassUnicode, unicode::Error>,\n    ) -> Result<hir::ClassUnicode> {\n        result.map_err(|err| {\n            let sp = span.clone();\n            match err {\n                unicode::Error::PropertyNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyNotFound)\n                }\n                unicode::Error::PropertyValueNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyValueNotFound)\n                }\n                unicode::Error::PerlClassNotFound => {\n                    self.error(sp, ErrorKind::UnicodePerlClassNotFound)\n                }\n            }\n        })\n    }\n\n    fn unicode_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassUnicode,\n    ) -> Result<()> {\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation first, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.try_case_fold_simple().map_err(|_| {\n                self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)\n            })?;\n        }\n        if negated {\n            class.negate();\n        }\n        Ok(())\n    }\n\n    fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()> {\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation first, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.case_fold_simple();\n        }\n        if negated {\n            class.negate();\n        }\n        if self.trans().utf8 && !class.is_ascii() {\n            return Err(self.error(span.clone(), ErrorKind::InvalidUtf8));\n        }\n        Ok(())\n    }\n\n    /// Return a scalar byte value suitable for use as a literal in a byte\n    /// character class.\n    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8> {\n        match self.ast_literal_to_scalar(ast)? {\n            Either::Right(byte) => Ok(byte),\n            Either::Left(ch) => {\n                let cp = u32::from(ch);\n                if cp <= 0x7F {\n                    Ok(u8::try_from(cp).unwrap())\n                } else {\n                    // We can't feasibly support Unicode in\n                    // byte oriented classes. Byte classes don't\n                    // do Unicode case folding.\n                    Err(self.error(ast.span, ErrorKind::UnicodeNotAllowed))\n                }\n            }\n        }\n    }\n}","impl<'t, 'p> Visitor for TranslatorI<'t, 'p> {\n    type Output = Hir;\n    type Err = Error;\n\n    fn finish(self) -> Result<Hir> {\n        // ... otherwise, we should have exactly one HIR on the stack.\n        assert_eq!(self.trans().stack.borrow().len(), 1);\n        Ok(self.pop().unwrap().unwrap_expr())\n    }\n\n    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {\n        match *ast {\n            Ast::Class(ast::Class::Bracketed(_)) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            Ast::Repetition(_) => self.push(HirFrame::Repetition),\n            Ast::Group(ref x) => {\n                let old_flags = x\n                    .flags()\n                    .map(|ast| self.set_flags(ast))\n                    .unwrap_or_else(|| self.flags());\n                self.push(HirFrame::Group { old_flags });\n            }\n            Ast::Concat(ref x) if x.asts.is_empty() => {}\n            Ast::Concat(_) => {\n                self.push(HirFrame::Concat);\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => {}\n            Ast::Alternation(_) => {\n                self.push(HirFrame::Alternation);\n                self.push(HirFrame::AlternationBranch);\n            }\n            _ => {}\n        }\n        Ok(())\n    }\n\n    fn visit_post(&mut self, ast: &Ast) -> Result<()> {\n        match *ast {\n            Ast::Empty(_) => {\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Flags(ref x) => {\n                self.set_flags(&x.flags);\n                // Flags in the AST are generally considered directives and\n                // not actual sub-expressions. However, they can be used in\n                // the concrete syntax like `((?i))`, and we need some kind of\n                // indication of an expression there, and Empty is the correct\n                // choice.\n                //\n                // There can also be things like `(?i)+`, but we rule those out\n                // in the parser. In the future, we might allow them for\n                // consistency sake.\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Literal(ref x) => {\n                match self.ast_literal_to_scalar(x)? {\n                    Either::Right(byte) => self.push_byte(byte),\n                    Either::Left(ch) => {\n                        if !self.flags().unicode() && ch.len_utf8() > 1 {\n                            return Err(self\n                                .error(x.span, ErrorKind::UnicodeNotAllowed));\n                        }\n                        match self.case_fold_char(x.span, ch)? {\n                            None => self.push_char(ch),\n                            Some(expr) => self.push(HirFrame::Expr(expr)),\n                        }\n                    }\n                }\n                // self.push(HirFrame::Expr(self.hir_literal(x)?));\n            }\n            Ast::Dot(span) => {\n                self.push(HirFrame::Expr(self.hir_dot(span)?));\n            }\n            Ast::Assertion(ref x) => {\n                self.push(HirFrame::Expr(self.hir_assertion(x)?));\n            }\n            Ast::Class(ast::Class::Perl(ref x)) => {\n                if self.flags().unicode() {\n                    let cls = self.hir_perl_unicode_class(x)?;\n                    let hcls = hir::Class::Unicode(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                } else {\n                    let cls = self.hir_perl_byte_class(x)?;\n                    let hcls = hir::Class::Bytes(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                }\n            }\n            Ast::Class(ast::Class::Unicode(ref x)) => {\n                let cls = hir::Class::Unicode(self.hir_unicode_class(x)?);\n                self.push(HirFrame::Expr(Hir::class(cls)));\n            }\n            Ast::Class(ast::Class::Bracketed(ref ast)) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    let expr = Hir::class(hir::Class::Unicode(cls));\n                    self.push(HirFrame::Expr(expr));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    let expr = Hir::class(hir::Class::Bytes(cls));\n                    self.push(HirFrame::Expr(expr));\n                }\n            }\n            Ast::Repetition(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                self.pop().unwrap().unwrap_repetition();\n                self.push(HirFrame::Expr(self.hir_repetition(x, expr)));\n            }\n            Ast::Group(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                let old_flags = self.pop().unwrap().unwrap_group();\n                self.trans().flags.set(old_flags);\n                self.push(HirFrame::Expr(self.hir_capture(x, expr)));\n            }\n            Ast::Concat(_) => {\n                let mut exprs = vec![];\n                while let Some(expr) = self.pop_concat_expr() {\n                    if !matches!(*expr.kind(), HirKind::Empty) {\n                        exprs.push(expr);\n                    }\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::concat(exprs)));\n            }\n            Ast::Alternation(_) => {\n                let mut exprs = vec![];\n                while let Some(expr) = self.pop_alt_expr() {\n                    self.pop().unwrap().unwrap_alternation_pipe();\n                    exprs.push(expr);\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::alternation(exprs)));\n            }\n        }\n        Ok(())\n    }\n\n    fn visit_alternation_in(&mut self) -> Result<()> {\n        self.push(HirFrame::AlternationBranch);\n        Ok(())\n    }\n\n    fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Bracketed(_) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            // We needn't handle the Union case here since the visitor will\n            // do it for us.\n            _ => {}\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()> {\n        match *ast {\n            ast::ClassSetItem::Empty(_) => {}\n            ast::ClassSetItem::Literal(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.c, x.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let byte = self.class_literal_byte(x)?;\n                    cls.push(hir::ClassBytesRange::new(byte, byte));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Range(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.start.c, x.end.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let start = self.class_literal_byte(&x.start)?;\n                    let end = self.class_literal_byte(&x.end)?;\n                    cls.push(hir::ClassBytesRange::new(start, end));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Ascii(ref x) => {\n                if self.flags().unicode() {\n                    let xcls = self.hir_ascii_unicode_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let xcls = self.hir_ascii_byte_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Unicode(ref x) => {\n                let xcls = self.hir_unicode_class(x)?;\n                let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                cls.union(&xcls);\n                self.push(HirFrame::ClassUnicode(cls));\n            }\n            ast::ClassSetItem::Perl(ref x) => {\n                if self.flags().unicode() {\n                    let xcls = self.hir_perl_unicode_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let xcls = self.hir_perl_byte_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Bracketed(ref ast) => {\n                if self.flags().unicode() {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_unicode();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassUnicode(cls2));\n                } else {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassBytes(cls2));\n                }\n            }\n            // This is handled automatically by the visitor.\n            ast::ClassSetItem::Union(_) => {}\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        op: &ast::ClassSetBinaryOp,\n    ) -> Result<()> {\n        use crate::ast::ClassSetBinaryOpKind::*;\n\n        if self.flags().unicode() {\n            let mut rhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut lhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut cls = self.pop().unwrap().unwrap_class_unicode();\n            if self.flags().case_insensitive() {\n                rhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.rhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n                lhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.lhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let mut rhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut lhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut cls = self.pop().unwrap().unwrap_class_bytes();\n            if self.flags().case_insensitive() {\n                rhs.case_fold_simple();\n                lhs.case_fold_simple();\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }\n}"],"hir::visitor::Frame":["impl<'a> Frame<'a> {\n    /// Perform the next inductive step on this frame and return the next\n    /// child HIR node to visit.\n    fn child(&self) -> &'a Hir {\n        match *self {\n            Frame::Repetition(rep) => &rep.sub,\n            Frame::Capture(capture) => &capture.sub,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }\n}"],"hir::visitor::HeapVisitor":["impl<'a> HeapVisitor<'a> {\n    fn new() -> HeapVisitor<'a> {\n        HeapVisitor { stack: vec![] }\n    }\n\n    fn visit<V: Visitor>(\n        &mut self,\n        mut hir: &'a Hir,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err> {\n        self.stack.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(hir)?;\n            if let Some(x) = self.induct(hir) {\n                let child = x.child();\n                self.stack.push((hir, x));\n                hir = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(hir)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_hir, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_hir, frame)) => (post_hir, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    hir = x.child();\n                    self.stack.push((post_hir, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this HIR, so we can post visit it now.\n                visitor.visit_post(post_hir)?;\n            }\n        }\n    }\n\n    /// Build a stack frame for the given HIR if one is needed (which occurs if\n    /// and only if there are child nodes in the HIR). Otherwise, return None.\n    fn induct(&mut self, hir: &'a Hir) -> Option<Frame<'a>> {\n        match *hir.kind() {\n            HirKind::Repetition(ref x) => Some(Frame::Repetition(x)),\n            HirKind::Capture(ref x) => Some(Frame::Capture(x)),\n            HirKind::Concat(ref x) if x.is_empty() => None,\n            HirKind::Concat(ref x) => {\n                Some(Frame::Concat { head: &x[0], tail: &x[1..] })\n            }\n            HirKind::Alternation(ref x) if x.is_empty() => None,\n            HirKind::Alternation(ref x) => {\n                Some(Frame::Alternation { head: &x[0], tail: &x[1..] })\n            }\n            _ => None,\n        }\n    }\n\n    /// Pops the given frame. If the frame has an additional inductive step,\n    /// then return it, otherwise return `None`.\n    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Capture(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }\n}"],"parser::Parser":["Clone","Debug","impl Parser {\n    /// Create a new parser with a default configuration.\n    ///\n    /// The parser can be run with `parse` method. The parse method returns\n    /// a high level intermediate representation of the given regular\n    /// expression.\n    ///\n    /// To set configuration options on the parser, use [`ParserBuilder`].\n    pub fn new() -> Parser {\n        ParserBuilder::new().build()\n    }\n\n    /// Parse the regular expression into a high level intermediate\n    /// representation.\n    pub fn parse(&mut self, pattern: &str) -> Result<hir::Hir, Error> {\n        let ast = self.ast.parse(pattern)?;\n        let hir = self.hir.translate(pattern, &ast)?;\n        Ok(hir)\n    }\n}"],"parser::ParserBuilder":["Clone","Debug","Default","impl ParserBuilder {\n    /// Create a new parser builder with a default configuration.\n    pub fn new() -> ParserBuilder {\n        ParserBuilder::default()\n    }\n\n    /// Build a parser from this configuration with the given pattern.\n    pub fn build(&self) -> Parser {\n        Parser { ast: self.ast.build(), hir: self.hir.build() }\n    }\n\n    /// Set the nesting limit for this parser.\n    ///\n    /// The nesting limit controls how deep the abstract syntax tree is allowed\n    /// to be. If the AST exceeds the given limit (e.g., with too many nested\n    /// groups), then an error is returned by the parser.\n    ///\n    /// The purpose of this limit is to act as a heuristic to prevent stack\n    /// overflow for consumers that do structural induction on an `Ast` using\n    /// explicit recursion. While this crate never does this (instead using\n    /// constant stack space and moving the call stack to the heap), other\n    /// crates may.\n    ///\n    /// This limit is not checked until the entire Ast is parsed. Therefore,\n    /// if callers want to put a limit on the amount of heap space used, then\n    /// they should impose a limit on the length, in bytes, of the concrete\n    /// pattern string. In particular, this is viable since this parser\n    /// implementation will limit itself to heap space proportional to the\n    /// length of the pattern string.\n    ///\n    /// Note that a nest limit of `0` will return a nest limit error for most\n    /// patterns but not all. For example, a nest limit of `0` permits `a` but\n    /// not `ab`, since `ab` requires a concatenation, which results in a nest\n    /// depth of `1`. In general, a nest limit is not something that manifests\n    /// in an obvious way in the concrete syntax, therefore, it should not be\n    /// used in a granular way.\n    pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {\n        self.ast.nest_limit(limit);\n        self\n    }\n\n    /// Whether to support octal syntax or not.\n    ///\n    /// Octal syntax is a little-known way of uttering Unicode codepoints in\n    /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n    /// `\\141` are all equivalent regular expressions, where the last example\n    /// shows octal syntax.\n    ///\n    /// While supporting octal syntax isn't in and of itself a problem, it does\n    /// make good error messages harder. That is, in PCRE based regex engines,\n    /// syntax like `\\0` invokes a backreference, which is explicitly\n    /// unsupported in Rust's regex engine. However, many users expect it to\n    /// be supported. Therefore, when octal support is disabled, the error\n    /// message will explicitly mention that backreferences aren't supported.\n    ///\n    /// Octal syntax is disabled by default.\n    pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.ast.octal(yes);\n        self\n    }\n\n    /// When disabled, translation will permit the construction of a regular\n    /// expression that may match invalid UTF-8.\n    ///\n    /// When enabled (the default), the translator is guaranteed to produce an\n    /// expression that, for non-empty matches, will only ever produce spans\n    /// that are entirely valid UTF-8 (otherwise, the translator will return an\n    /// error).\n    ///\n    /// Perhaps surprisingly, when UTF-8 is enabled, an empty regex or even\n    /// a negated ASCII word boundary (uttered as `(?-u:\\B)` in the concrete\n    /// syntax) will be allowed even though they can produce matches that split\n    /// a UTF-8 encoded codepoint. This only applies to zero-width or \"empty\"\n    /// matches, and it is expected that the regex engine itself must handle\n    /// these cases if necessary (perhaps by suppressing any zero-width matches\n    /// that split a codepoint).\n    pub fn utf8(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.utf8(yes);\n        self\n    }\n\n    /// Enable verbose mode in the regular expression.\n    ///\n    /// When enabled, verbose mode permits insignificant whitespace in many\n    /// places in the regular expression, as well as comments. Comments are\n    /// started using `#` and continue until the end of the line.\n    ///\n    /// By default, this is disabled. It may be selectively enabled in the\n    /// regular expression by using the `x` flag regardless of this setting.\n    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.ast.ignore_whitespace(yes);\n        self\n    }\n\n    /// Enable or disable the case insensitive flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `i` flag.\n    pub fn case_insensitive(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.case_insensitive(yes);\n        self\n    }\n\n    /// Enable or disable the multi-line matching flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `m` flag.\n    pub fn multi_line(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.multi_line(yes);\n        self\n    }\n\n    /// Enable or disable the \"dot matches any character\" flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `s` flag.\n    pub fn dot_matches_new_line(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.dot_matches_new_line(yes);\n        self\n    }\n\n    /// Enable or disable the CRLF mode flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `R` flag.\n    ///\n    /// When CRLF mode is enabled, the following happens:\n    ///\n    /// * Unless `dot_matches_new_line` is enabled, `.` will match any character\n    /// except for `\\r` and `\\n`.\n    /// * When `multi_line` mode is enabled, `^` and `$` will treat `\\r\\n`,\n    /// `\\r` and `\\n` as line terminators. And in particular, neither will\n    /// match between a `\\r` and a `\\n`.\n    pub fn crlf(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.crlf(yes);\n        self\n    }\n\n    /// Enable or disable the \"swap greed\" flag by default.\n    ///\n    /// By default this is disabled. It may alternatively be selectively\n    /// enabled in the regular expression itself via the `U` flag.\n    pub fn swap_greed(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.swap_greed(yes);\n        self\n    }\n\n    /// Enable or disable the Unicode flag (`u`) by default.\n    ///\n    /// By default this is **enabled**. It may alternatively be selectively\n    /// disabled in the regular expression itself via the `u` flag.\n    ///\n    /// Note that unless `utf8` is disabled (it's enabled by default), a\n    /// regular expression will fail to parse if Unicode mode is disabled and a\n    /// sub-expression could possibly match invalid UTF-8.\n    pub fn unicode(&mut self, yes: bool) -> &mut ParserBuilder {\n        self.hir.unicode(yes);\n        self\n    }\n}"],"unicode::CanonicalClassQuery":["Debug","Eq","PartialEq"],"unicode::CaseFoldError":["Debug","impl core::fmt::Display for CaseFoldError {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"Unicode-aware case folding is not available \\\n             (probably because the unicode-case feature is not enabled)\"\n        )\n    }\n}","impl std::error::Error for CaseFoldError {}"],"unicode::ClassQuery":["Debug","impl<'a> ClassQuery<'a> {\n    fn canonicalize(&self) -> Result<CanonicalClassQuery, Error> {\n        match *self {\n            ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),\n            ClassQuery::Binary(name) => self.canonical_binary(name),\n            ClassQuery::ByValue { property_name, property_value } => {\n                let property_name = symbolic_name_normalize(property_name);\n                let property_value = symbolic_name_normalize(property_value);\n\n                let canon_name = match canonical_prop(&property_name)? {\n                    None => return Err(Error::PropertyNotFound),\n                    Some(canon_name) => canon_name,\n                };\n                Ok(match canon_name {\n                    \"General_Category\" => {\n                        let canon = match canonical_gencat(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::GeneralCategory(canon)\n                    }\n                    \"Script\" => {\n                        let canon = match canonical_script(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::Script(canon)\n                    }\n                    _ => {\n                        let vals = match property_values(canon_name)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(vals) => vals,\n                        };\n                        let canon_val =\n                            match canonical_value(vals, &property_value) {\n                                None => {\n                                    return Err(Error::PropertyValueNotFound)\n                                }\n                                Some(canon_val) => canon_val,\n                            };\n                        CanonicalClassQuery::ByValue {\n                            property_name: canon_name,\n                            property_value: canon_val,\n                        }\n                    }\n                })\n            }\n        }\n    }\n\n    fn canonical_binary(\n        &self,\n        name: &str,\n    ) -> Result<CanonicalClassQuery, Error> {\n        let norm = symbolic_name_normalize(name);\n\n        // This is a special case where 'cf' refers to the 'Format' general\n        // category, but where the 'cf' abbreviation is also an abbreviation\n        // for the 'Case_Folding' property. But we want to treat it as\n        // a general category. (Currently, we don't even support the\n        // 'Case_Folding' property. But if we do in the future, users will be\n        // required to spell it out.)\n        //\n        // Also 'sc' refers to the 'Currency_Symbol' general category, but is\n        // also the abbreviation for the 'Script' property. So we avoid calling\n        // 'canonical_prop' for it too, which would erroneously normalize it\n        // to 'Script'.\n        //\n        // Another case: 'lc' is an abbreviation for the 'Cased_Letter'\n        // general category, but is also an abbreviation for the 'Lowercase_Mapping'\n        // property. We don't currently support the latter, so as with 'cf'\n        // above, we treat 'lc' as 'Cased_Letter'.\n        if norm != \"cf\" && norm != \"sc\" && norm != \"lc\" {\n            if let Some(canon) = canonical_prop(&norm)? {\n                return Ok(CanonicalClassQuery::Binary(canon));\n            }\n        }\n        if let Some(canon) = canonical_gencat(&norm)? {\n            return Ok(CanonicalClassQuery::GeneralCategory(canon));\n        }\n        if let Some(canon) = canonical_script(&norm)? {\n            return Ok(CanonicalClassQuery::Script(canon));\n        }\n        Err(Error::PropertyNotFound)\n    }\n}"],"unicode::Error":["Debug"],"unicode::SimpleCaseFolder":["Debug","impl SimpleCaseFolder {\n    /// Create a new simple case folder, returning an error if the underlying\n    /// case folding table is unavailable.\n    pub fn new() -> Result<SimpleCaseFolder, CaseFoldError> {\n        #[cfg(not(feature = \"unicode-case\"))]\n        {\n            Err(CaseFoldError(()))\n        }\n        #[cfg(feature = \"unicode-case\")]\n        {\n            Ok(SimpleCaseFolder {\n                table: crate::unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE,\n                last: None,\n                next: 0,\n            })\n        }\n    }\n\n    /// Return the equivalence class of case folded codepoints for the given\n    /// codepoint. The equivalence class returned never includes the codepoint\n    /// given. If the given codepoint has no case folded codepoints (i.e.,\n    /// no entry in the underlying case folding table), then this returns an\n    /// empty slice.\n    ///\n    /// # Panics\n    ///\n    /// This panics when called with a `c` that is less than or equal to the\n    /// previous call. In other words, callers need to use this method with\n    /// strictly increasing values of `c`.\n    pub fn mapping(&mut self, c: char) -> &'static [char] {\n        if let Some(last) = self.last {\n            assert!(\n                last < c,\n                \"got codepoint U+{:X} which occurs before \\\n                 last codepoint U+{:X}\",\n                u32::from(c),\n                u32::from(last),\n            );\n        }\n        self.last = Some(c);\n        if self.next >= self.table.len() {\n            return &[];\n        }\n        let (k, v) = self.table[self.next];\n        if k == c {\n            self.next += 1;\n            return v;\n        }\n        match self.get(c) {\n            Err(i) => {\n                self.next = i;\n                &[]\n            }\n            Ok(i) => {\n                // Since we require lookups to proceed\n                // in order, anything we find should be\n                // after whatever we thought might be\n                // next. Otherwise, the caller is either\n                // going out of order or we would have\n                // found our next key at 'self.next'.\n                assert!(i > self.next);\n                self.next = i + 1;\n                self.table[i].1\n            }\n        }\n    }\n\n    /// Returns true if and only if the given range overlaps with any region\n    /// of the underlying case folding table. That is, when true, there exists\n    /// at least one codepoint in the inclusive range `[start, end]` that has\n    /// a non-trivial equivalence class of case folded codepoints. Conversely,\n    /// when this returns false, all codepoints in the range `[start, end]`\n    /// correspond to the trivial equivalence class of case folded codepoints,\n    /// i.e., itself.\n    ///\n    /// This is useful to call before iterating over the codepoints in the\n    /// range and looking up the mapping for each. If you know none of the\n    /// mappings will return anything, then you might be able to skip doing it\n    /// altogether.\n    ///\n    /// # Panics\n    ///\n    /// This panics when `end < start`.\n    pub fn overlaps(&self, start: char, end: char) -> bool {\n        use core::cmp::Ordering;\n\n        assert!(start <= end);\n        self.table\n            .binary_search_by(|&(c, _)| {\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if c > end {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok()\n    }\n\n    /// Returns the index at which `c` occurs in the simple case fold table. If\n    /// `c` does not occur, then this returns an `i` such that `table[i-1].0 <\n    /// c` and `table[i].0 > c`.\n    fn get(&self, c: char) -> Result<usize, usize> {\n        self.table.binary_search_by_key(&c, |&(c1, _)| c1)\n    }\n}"],"unicode::UnicodeWordError":["Debug","impl core::fmt::Display for UnicodeWordError {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"Unicode-aware \\\\w class is not available \\\n             (probably because the unicode-perl feature is not enabled)\"\n        )\n    }\n}","impl std::error::Error for UnicodeWordError {}"],"utf8::ScalarRange":["impl ScalarRange {\n    /// split splits this range if it overlaps with a surrogate codepoint.\n    ///\n    /// Either or both ranges may be invalid.\n    fn split(&self) -> Option<(ScalarRange, ScalarRange)> {\n        if self.start < 0xE000 && self.end > 0xD7FF {\n            Some((\n                ScalarRange { start: self.start, end: 0xD7FF },\n                ScalarRange { start: 0xE000, end: self.end },\n            ))\n        } else {\n            None\n        }\n    }\n\n    /// is_valid returns true if and only if start <= end.\n    fn is_valid(&self) -> bool {\n        self.start <= self.end\n    }\n\n    /// as_ascii returns this range as a Utf8Range if and only if all scalar\n    /// values in this range can be encoded as a single byte.\n    fn as_ascii(&self) -> Option<Utf8Range> {\n        if self.is_ascii() {\n            let start = u8::try_from(self.start).unwrap();\n            let end = u8::try_from(self.end).unwrap();\n            Some(Utf8Range::new(start, end))\n        } else {\n            None\n        }\n    }\n\n    /// is_ascii returns true if the range is ASCII only (i.e., takes a single\n    /// byte to encode any scalar value).\n    fn is_ascii(&self) -> bool {\n        self.is_valid() && self.end <= 0x7f\n    }\n\n    /// encode writes the UTF-8 encoding of the start and end of this range\n    /// to the corresponding destination slices, and returns the number of\n    /// bytes written.\n    ///\n    /// The slices should have room for at least `MAX_UTF8_BYTES`.\n    fn encode(&self, start: &mut [u8], end: &mut [u8]) -> usize {\n        let cs = char::from_u32(self.start).unwrap();\n        let ce = char::from_u32(self.end).unwrap();\n        let ss = cs.encode_utf8(start);\n        let se = ce.encode_utf8(end);\n        assert_eq!(ss.len(), se.len());\n        ss.len()\n    }\n}","impl fmt::Debug for ScalarRange {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"ScalarRange({:X}, {:X})\", self.start, self.end)\n    }\n}"],"utf8::Utf8Range":["Clone","Copy","Eq","Ord","PartialEq","PartialOrd","impl Utf8Range {\n    fn new(start: u8, end: u8) -> Self {\n        Utf8Range { start, end }\n    }\n\n    /// Returns true if and only if the given byte is in this range.\n    pub fn matches(&self, b: u8) -> bool {\n        self.start <= b && b <= self.end\n    }\n}","impl fmt::Debug for Utf8Range {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.start == self.end {\n            write!(f, \"[{:X}]\", self.start)\n        } else {\n            write!(f, \"[{:X}-{:X}]\", self.start, self.end)\n        }\n    }\n}"],"utf8::Utf8Sequence":["Clone","Copy","Eq","Ord","PartialEq","PartialOrd","impl Utf8Sequence {\n    /// Creates a new UTF-8 sequence from the encoded bytes of a scalar value\n    /// range.\n    ///\n    /// This assumes that `start` and `end` have the same length.\n    fn from_encoded_range(start: &[u8], end: &[u8]) -> Self {\n        assert_eq!(start.len(), end.len());\n        match start.len() {\n            2 => Utf8Sequence::Two([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n            ]),\n            3 => Utf8Sequence::Three([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n            ]),\n            4 => Utf8Sequence::Four([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n                Utf8Range::new(start[3], end[3]),\n            ]),\n            n => unreachable!(\"invalid encoded length: {}\", n),\n        }\n    }\n\n    /// Returns the underlying sequence of byte ranges as a slice.\n    pub fn as_slice(&self) -> &[Utf8Range] {\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => slice::from_ref(r),\n            Two(ref r) => &r[..],\n            Three(ref r) => &r[..],\n            Four(ref r) => &r[..],\n        }\n    }\n\n    /// Returns the number of byte ranges in this sequence.\n    ///\n    /// The length is guaranteed to be in the closed interval `[1, 4]`.\n    pub fn len(&self) -> usize {\n        self.as_slice().len()\n    }\n\n    /// Reverses the ranges in this sequence.\n    ///\n    /// For example, if this corresponds to the following sequence:\n    ///\n    /// ```text\n    /// [D0-D3][80-BF]\n    /// ```\n    ///\n    /// Then after reversal, it will be\n    ///\n    /// ```text\n    /// [80-BF][D0-D3]\n    /// ```\n    ///\n    /// This is useful when one is constructing a UTF-8 automaton to match\n    /// character classes in reverse.\n    pub fn reverse(&mut self) {\n        match *self {\n            Utf8Sequence::One(_) => {}\n            Utf8Sequence::Two(ref mut x) => x.reverse(),\n            Utf8Sequence::Three(ref mut x) => x.reverse(),\n            Utf8Sequence::Four(ref mut x) => x.reverse(),\n        }\n    }\n\n    /// Returns true if and only if a prefix of `bytes` matches this sequence\n    /// of byte ranges.\n    pub fn matches(&self, bytes: &[u8]) -> bool {\n        if bytes.len() < self.len() {\n            return false;\n        }\n        for (&b, r) in bytes.iter().zip(self) {\n            if !r.matches(b) {\n                return false;\n            }\n        }\n        true\n    }\n}","impl fmt::Debug for Utf8Sequence {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => write!(f, \"{:?}\", r),\n            Two(ref r) => write!(f, \"{:?}{:?}\", r[0], r[1]),\n            Three(ref r) => write!(f, \"{:?}{:?}{:?}\", r[0], r[1], r[2]),\n            Four(ref r) => {\n                write!(f, \"{:?}{:?}{:?}{:?}\", r[0], r[1], r[2], r[3])\n            }\n        }\n    }\n}"],"utf8::Utf8Sequences":["Debug","impl FusedIterator for Utf8Sequences {}","impl Iterator for Utf8Sequences {\n    type Item = Utf8Sequence;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        'TOP: while let Some(mut r) = self.range_stack.pop() {\n            'INNER: loop {\n                if let Some((r1, r2)) = r.split() {\n                    self.push(r2.start, r2.end);\n                    r.start = r1.start;\n                    r.end = r1.end;\n                    continue 'INNER;\n                }\n                if !r.is_valid() {\n                    continue 'TOP;\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let max = max_scalar_value(i);\n                    if r.start <= max && max < r.end {\n                        self.push(max + 1, r.end);\n                        r.end = max;\n                        continue 'INNER;\n                    }\n                }\n                if let Some(ascii_range) = r.as_ascii() {\n                    return Some(Utf8Sequence::One(ascii_range));\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let m = (1 << (6 * i)) - 1;\n                    if (r.start & !m) != (r.end & !m) {\n                        if (r.start & m) != 0 {\n                            self.push((r.start | m) + 1, r.end);\n                            r.end = r.start | m;\n                            continue 'INNER;\n                        }\n                        if (r.end & m) != m {\n                            self.push(r.end & !m, r.end);\n                            r.end = (r.end & !m) - 1;\n                            continue 'INNER;\n                        }\n                    }\n                }\n                let mut start = [0; MAX_UTF8_BYTES];\n                let mut end = [0; MAX_UTF8_BYTES];\n                let n = r.encode(&mut start, &mut end);\n                return Some(Utf8Sequence::from_encoded_range(\n                    &start[0..n],\n                    &end[0..n],\n                ));\n            }\n        }\n        None\n    }\n}","impl Utf8Sequences {\n    /// Create a new iterator over UTF-8 byte ranges for the scalar value range\n    /// given.\n    pub fn new(start: char, end: char) -> Self {\n        let mut it = Utf8Sequences { range_stack: vec![] };\n        it.push(u32::from(start), u32::from(end));\n        it\n    }\n\n    /// reset resets the scalar value range.\n    /// Any existing state is cleared, but resources may be reused.\n    ///\n    /// N.B. Benchmarks say that this method is dubious.\n    #[doc(hidden)]\n    pub fn reset(&mut self, start: char, end: char) {\n        self.range_stack.clear();\n        self.push(u32::from(start), u32::from(end));\n    }\n\n    fn push(&mut self, start: u32, end: u32) {\n        self.range_stack.push(ScalarRange { start, end });\n    }\n}"]},"single_path_import":{"ast::visitor::Visitor":"ast::Visitor","ast::visitor::visit":"ast::visit","error::Error":"Error","hir::visitor::Visitor":"hir::Visitor","hir::visitor::visit":"hir::visit","parser::Parser":"Parser","parser::ParserBuilder":"ParserBuilder","parser::parse":"parse","unicode::CaseFoldError":"hir::CaseFoldError","unicode::UnicodeWordError":"UnicodeWordError"},"srcs":{"<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.as_slice().iter()\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<ast::Ast as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        use crate::ast::print::Printer;\n        Printer::new().print(self, f)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Ast as std::ops::Drop>::drop":["fn drop(&mut self){\n        use core::mem;\n\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            // Classes are recursive, so they get their own Drop impl.\n            | Ast::Class(_) => return,\n            Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Group(ref x) if !x.ast.has_subexprs() => return,\n            Ast::Alternation(ref x) if x.asts.is_empty() => return,\n            Ast::Concat(ref x) if x.asts.is_empty() => return,\n            _ => {}\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_ast = || Ast::Empty(empty_span());\n        let mut stack = vec![mem::replace(self, empty_ast())];\n        while let Some(mut ast) = stack.pop() {\n            match ast {\n                Ast::Empty(_)\n                | Ast::Flags(_)\n                | Ast::Literal(_)\n                | Ast::Dot(_)\n                | Ast::Assertion(_)\n                // Classes are recursive, so they get their own Drop impl.\n                | Ast::Class(_) => {}\n                Ast::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Group(ref mut x) => {\n                    stack.push(mem::replace(&mut x.ast, empty_ast()));\n                }\n                Ast::Alternation(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n                Ast::Concat(ref mut x) => {\n                    stack.extend(x.asts.drain(..));\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::ClassSet as std::ops::Drop>::drop":["fn drop(&mut self){\n        use core::mem;\n\n        match *self {\n            ClassSet::Item(ref item) => match *item {\n                ClassSetItem::Empty(_)\n                | ClassSetItem::Literal(_)\n                | ClassSetItem::Range(_)\n                | ClassSetItem::Ascii(_)\n                | ClassSetItem::Unicode(_)\n                | ClassSetItem::Perl(_) => return,\n                ClassSetItem::Bracketed(ref x) => {\n                    if x.kind.is_empty() {\n                        return;\n                    }\n                }\n                ClassSetItem::Union(ref x) => {\n                    if x.items.is_empty() {\n                        return;\n                    }\n                }\n            },\n            ClassSet::BinaryOp(ref op) => {\n                if op.lhs.is_empty() && op.rhs.is_empty() {\n                    return;\n                }\n            }\n        }\n\n        let empty_span = || Span::splat(Position::new(0, 0, 0));\n        let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));\n        let mut stack = vec![mem::replace(self, empty_set())];\n        while let Some(mut set) = stack.pop() {\n            match set {\n                ClassSet::Item(ref mut item) => match *item {\n                    ClassSetItem::Empty(_)\n                    | ClassSetItem::Literal(_)\n                    | ClassSetItem::Range(_)\n                    | ClassSetItem::Ascii(_)\n                    | ClassSetItem::Unicode(_)\n                    | ClassSetItem::Perl(_) => {}\n                    ClassSetItem::Bracketed(ref mut x) => {\n                        stack.push(mem::replace(&mut x.kind, empty_set()));\n                    }\n                    ClassSetItem::Union(ref mut x) => {\n                        stack.extend(x.items.drain(..).map(ClassSet::Item));\n                    }\n                },\n                ClassSet::BinaryOp(ref mut op) => {\n                    stack.push(mem::replace(&mut op.lhs, empty_set()));\n                    stack.push(mem::replace(&mut op.rhs, empty_set()));\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        crate::error::Formatter::from(self).fmt(f)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::ErrorKind as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        use self::ErrorKind::*;\n        match *self {\n            CaptureLimitExceeded => write!(\n                f,\n                \"exceeded the maximum number of \\\n                 capturing groups ({})\",\n                u32::MAX\n            ),\n            ClassEscapeInvalid => {\n                write!(f, \"invalid escape sequence found in character class\")\n            }\n            ClassRangeInvalid => write!(\n                f,\n                \"invalid character class range, \\\n                 the start must be <= the end\"\n            ),\n            ClassRangeLiteral => {\n                write!(f, \"invalid range boundary, must be a literal\")\n            }\n            ClassUnclosed => write!(f, \"unclosed character class\"),\n            DecimalEmpty => write!(f, \"decimal literal empty\"),\n            DecimalInvalid => write!(f, \"decimal literal invalid\"),\n            EscapeHexEmpty => write!(f, \"hexadecimal literal empty\"),\n            EscapeHexInvalid => {\n                write!(f, \"hexadecimal literal is not a Unicode scalar value\")\n            }\n            EscapeHexInvalidDigit => write!(f, \"invalid hexadecimal digit\"),\n            EscapeUnexpectedEof => write!(\n                f,\n                \"incomplete escape sequence, \\\n                 reached end of pattern prematurely\"\n            ),\n            EscapeUnrecognized => write!(f, \"unrecognized escape sequence\"),\n            FlagDanglingNegation => {\n                write!(f, \"dangling flag negation operator\")\n            }\n            FlagDuplicate { .. } => write!(f, \"duplicate flag\"),\n            FlagRepeatedNegation { .. } => {\n                write!(f, \"flag negation operator repeated\")\n            }\n            FlagUnexpectedEof => {\n                write!(f, \"expected flag but got end of regex\")\n            }\n            FlagUnrecognized => write!(f, \"unrecognized flag\"),\n            GroupNameDuplicate { .. } => {\n                write!(f, \"duplicate capture group name\")\n            }\n            GroupNameEmpty => write!(f, \"empty capture group name\"),\n            GroupNameInvalid => write!(f, \"invalid capture group character\"),\n            GroupNameUnexpectedEof => write!(f, \"unclosed capture group name\"),\n            GroupUnclosed => write!(f, \"unclosed group\"),\n            GroupUnopened => write!(f, \"unopened group\"),\n            NestLimitExceeded(limit) => write!(\n                f,\n                \"exceed the maximum number of \\\n                 nested parentheses/brackets ({})\",\n                limit\n            ),\n            RepetitionCountInvalid => write!(\n                f,\n                \"invalid repetition count range, \\\n                 the start must be <= the end\"\n            ),\n            RepetitionCountDecimalEmpty => {\n                write!(f, \"repetition quantifier expects a valid decimal\")\n            }\n            RepetitionCountUnclosed => {\n                write!(f, \"unclosed counted repetition\")\n            }\n            RepetitionMissing => {\n                write!(f, \"repetition operator missing expression\")\n            }\n            UnicodeClassInvalid => {\n                write!(f, \"invalid Unicode character class\")\n            }\n            UnsupportedBackreference => {\n                write!(f, \"backreferences are not supported\")\n            }\n            UnsupportedLookAround => write!(\n                f,\n                \"look-around, including look-ahead and look-behind, \\\n                 is not supported\"\n            ),\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Position as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Position) -> Ordering{\n        self.offset.cmp(&other.offset)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Position as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Position) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Position as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        write!(\n            f,\n            \"Position(o: {:?}, l: {:?}, c: {:?})\",\n            self.offset, self.line, self.column\n        )\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Span as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Span) -> Ordering{\n        (&self.start, &self.end).cmp(&(&other.start, &other.end))\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Span as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Span) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::Span as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        write!(f, \"Span({:?}, {:?})\", self.start, self.end)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":["fn finish(self) -> Result<()>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        self.decrement_depth();\n        Ok(())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["fn visit_class_set_binary_op_pre(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        self.increment_depth(&ast.span)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":["fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()>{\n        match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            ast::ClassSetItem::Bracketed(_) | ast::ClassSetItem::Union(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":["fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()>{\n        let span = match *ast {\n            ast::ClassSetItem::Empty(_)\n            | ast::ClassSetItem::Literal(_)\n            | ast::ClassSetItem::Range(_)\n            | ast::ClassSetItem::Ascii(_)\n            | ast::ClassSetItem::Unicode(_)\n            | ast::ClassSetItem::Perl(_) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            ast::ClassSetItem::Bracketed(ref x) => &x.span,\n            ast::ClassSetItem::Union(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":["fn visit_post(&mut self, ast: &Ast) -> Result<()>{\n        match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't decrement depth.\n                Ok(())\n            }\n            Ast::Class(ast::Class::Bracketed(_))\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => {\n                self.decrement_depth();\n                Ok(())\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":["fn visit_pre(&mut self, ast: &Ast) -> Result<()>{\n        let span = match *ast {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_)\n            | Ast::Class(ast::Class::Unicode(_))\n            | Ast::Class(ast::Class::Perl(_)) => {\n                // These are all base cases, so we don't increment depth.\n                return Ok(());\n            }\n            Ast::Class(ast::Class::Bracketed(ref x)) => &x.span,\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        };\n        self.increment_depth(span)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::parse::ParserBuilder as std::default::Default>::default":["fn default() -> ParserBuilder{\n        ParserBuilder::new()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"<ast::print::PrinterBuilder as std::default::Default>::default":["fn default() -> PrinterBuilder{\n        PrinterBuilder::new()\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<W> as ast::visitor::Visitor>::finish":["fn finish(self) -> fmt::Result{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_alternation_in":["fn visit_alternation_in(&mut self) -> fmt::Result{\n        self.wtr.write_str(\"|\")\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["fn visit_class_set_binary_op_in(\n        &mut self,\n        ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err>{\n        self.fmt_class_set_binary_op_kind(&ast.kind)\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_post":["fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err>{\n        use crate::ast::ClassSetItem::*;\n\n        match *ast {\n            Empty(_) => Ok(()),\n            Literal(ref x) => self.fmt_literal(x),\n            Range(ref x) => {\n                self.fmt_literal(&x.start)?;\n                self.wtr.write_str(\"-\")?;\n                self.fmt_literal(&x.end)?;\n                Ok(())\n            }\n            Ascii(ref x) => self.fmt_class_ascii(x),\n            Unicode(ref x) => self.fmt_class_unicode(x),\n            Perl(ref x) => self.fmt_class_perl(x),\n            Bracketed(ref x) => self.fmt_class_bracketed_post(x),\n            Union(_) => Ok(()),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_pre":["fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err>{\n        match *ast {\n            ast::ClassSetItem::Bracketed(ref x) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_post":["fn visit_post(&mut self, ast: &Ast) -> fmt::Result{\n        use crate::ast::Class;\n\n        match *ast {\n            Ast::Empty(_) => Ok(()),\n            Ast::Flags(ref x) => self.fmt_set_flags(x),\n            Ast::Literal(ref x) => self.fmt_literal(x),\n            Ast::Dot(_) => self.wtr.write_str(\".\"),\n            Ast::Assertion(ref x) => self.fmt_assertion(x),\n            Ast::Class(Class::Perl(ref x)) => self.fmt_class_perl(x),\n            Ast::Class(Class::Unicode(ref x)) => self.fmt_class_unicode(x),\n            Ast::Class(Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_post(x)\n            }\n            Ast::Repetition(ref x) => self.fmt_repetition(x),\n            Ast::Group(ref x) => self.fmt_group_post(x),\n            Ast::Alternation(_) => Ok(()),\n            Ast::Concat(_) => Ok(()),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_pre":["fn visit_pre(&mut self, ast: &Ast) -> fmt::Result{\n        match *ast {\n            Ast::Group(ref x) => self.fmt_group_pre(x),\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.fmt_class_bracketed_pre(x)\n            }\n            _ => Ok(()),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        let x = match *self {\n            ClassFrame::Union { .. } => \"Union\",\n            ClassFrame::Binary { .. } => \"Binary\",\n            ClassFrame::BinaryLHS { .. } => \"BinaryLHS\",\n            ClassFrame::BinaryRHS { .. } => \"BinaryRHS\",\n        };\n        write!(f, \"{}\", x)\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        let x = match *self {\n            ClassInduct::Item(it) => match *it {\n                ast::ClassSetItem::Empty(_) => \"Item(Empty)\",\n                ast::ClassSetItem::Literal(_) => \"Item(Literal)\",\n                ast::ClassSetItem::Range(_) => \"Item(Range)\",\n                ast::ClassSetItem::Ascii(_) => \"Item(Ascii)\",\n                ast::ClassSetItem::Perl(_) => \"Item(Perl)\",\n                ast::ClassSetItem::Unicode(_) => \"Item(Unicode)\",\n                ast::ClassSetItem::Bracketed(_) => \"Item(Bracketed)\",\n                ast::ClassSetItem::Union(_) => \"Item(Union)\",\n            },\n            ClassInduct::BinaryOp(it) => match it.kind {\n                ast::ClassSetBinaryOpKind::Intersection => {\n                    \"BinaryOp(Intersection)\"\n                }\n                ast::ClassSetBinaryOpKind::Difference => {\n                    \"BinaryOp(Difference)\"\n                }\n                ast::ClassSetBinaryOpKind::SymmetricDifference => {\n                    \"BinaryOp(SymmetricDifference)\"\n                }\n            },\n        };\n        write!(f, \"{}\", x)\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"<char as hir::interval::Bound>::as_u32":["fn as_u32(self) -> u32{\n        u32::from(self)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<char as hir::interval::Bound>::decrement":["fn decrement(self) -> Self{\n        match self {\n            '\\u{E000}' => '\\u{D7FF}',\n            c => char::from_u32(u32::from(c).checked_sub(1).unwrap()).unwrap(),\n        }\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<char as hir::interval::Bound>::increment":["fn increment(self) -> Self{\n        match self {\n            '\\u{D7FF}' => '\\u{E000}',\n            c => char::from_u32(u32::from(c).checked_add(1).unwrap()).unwrap(),\n        }\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<char as hir::interval::Bound>::max_value":["fn max_value() -> Self{\n        '\\u{10FFFF}'\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<char as hir::interval::Bound>::min_value":["fn min_value() -> Self{\n        '\\x00'\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<debug::Byte as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result{\n        // Special case ASCII space. It's too hard to read otherwise, so\n        // put quotes around it. I sometimes wonder whether just '\\x20' would\n        // be better...\n        if self.0 == b' ' {\n            return write!(f, \"' '\");\n        }\n        // 10 bytes is enough to cover any output from ascii::escape_default.\n        let mut bytes = [0u8; 10];\n        let mut len = 0;\n        for (i, mut b) in core::ascii::escape_default(self.0).enumerate() {\n            // capitalize \\xab to \\xAB\n            if i >= 2 && b'a' <= b && b <= b'f' {\n                b -= 32;\n            }\n            bytes[len] = b;\n            len += 1;\n        }\n        write!(f, \"{}\", core::str::from_utf8(&bytes[..len]).unwrap())\n    }","Real(LocalPath(\"src/debug.rs\"))"],"<debug::Bytes<'a> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result{\n        write!(f, \"\\\"\")?;\n        // This is a sad re-implementation of a similar impl found in bstr.\n        let mut bytes = self.0;\n        while let Some(result) = utf8_decode(bytes) {\n            let ch = match result {\n                Ok(ch) => ch,\n                Err(byte) => {\n                    write!(f, r\"\\x{:02x}\", byte)?;\n                    bytes = &bytes[1..];\n                    continue;\n                }\n            };\n            bytes = &bytes[ch.len_utf8()..];\n            match ch {\n                '\\0' => write!(f, \"\\\\0\")?,\n                // ASCII control characters except \\0, \\n, \\r, \\t\n                '\\x01'..='\\x08'\n                | '\\x0b'\n                | '\\x0c'\n                | '\\x0e'..='\\x19'\n                | '\\x7f' => {\n                    write!(f, \"\\\\x{:02x}\", u32::from(ch))?;\n                }\n                '\\n' | '\\r' | '\\t' | _ => {\n                    write!(f, \"{}\", ch.escape_debug())?;\n                }\n            }\n        }\n        write!(f, \"\\\"\")?;\n        Ok(())\n    }","Real(LocalPath(\"src/debug.rs\"))"],"<error::Error as std::convert::From<ast::Error>>::from":["fn from(err: ast::Error) -> Error{\n        Error::Parse(err)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::convert::From<hir::Error>>::from":["fn from(err: hir::Error) -> Error{\n        Error::Translate(err)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        match *self {\n            Error::Parse(ref x) => x.fmt(f),\n            Error::Translate(ref x) => x.fmt(f),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Formatter<'e, E> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        let spans = Spans::from_formatter(self);\n        if self.pattern.contains('\\n') {\n            let divider = repeat_char('~', 79);\n\n            writeln!(f, \"regex parse error:\")?;\n            writeln!(f, \"{}\", divider)?;\n            let notated = spans.notate();\n            write!(f, \"{}\", notated)?;\n            writeln!(f, \"{}\", divider)?;\n            // If we have error spans that cover multiple lines, then we just\n            // note the line numbers.\n            if !spans.multi_line.is_empty() {\n                let mut notes = vec![];\n                for span in &spans.multi_line {\n                    notes.push(format!(\n                        \"on line {} (column {}) through line {} (column {})\",\n                        span.start.line,\n                        span.start.column,\n                        span.end.line,\n                        span.end.column - 1\n                    ));\n                }\n                writeln!(f, \"{}\", notes.join(\"\\n\"))?;\n            }\n            write!(f, \"error: {}\", self.err)?;\n        } else {\n            writeln!(f, \"regex parse error:\")?;\n            let notated = Spans::from_formatter(self).notate();\n            write!(f, \"{}\", notated)?;\n            write!(f, \"error: {}\", self.err)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from":["fn from(err: &'e ast::Error) -> Self{\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: err.auxiliary_span(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from":["fn from(err: &'e hir::Error) -> Self{\n        Formatter {\n            pattern: err.pattern(),\n            err: err.kind(),\n            span: err.span(),\n            aux_span: None,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<hir::Class as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result{\n        use crate::debug::Byte;\n\n        let mut fmter = f.debug_set();\n        match *self {\n            Class::Unicode(ref cls) => {\n                for r in cls.ranges().iter() {\n                    fmter.entry(&(r.start..=r.end));\n                }\n            }\n            Class::Bytes(ref cls) => {\n                for r in cls.ranges().iter() {\n                    fmter.entry(&(Byte(r.start)..=Byte(r.end)));\n                }\n            }\n        }\n        fmter.finish()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a ClassBytesRange>{\n        self.0.next()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple":["/// Apply simple case folding to this byte range. Only ASCII case mappings\n/// (for a-z) are applied.\n///\n/// Additional ranges are appended to the given vector. Canonical ordering\n/// is *not* maintained in the given vector.\nfn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassBytesRange>,\n    ) -> Result<(), unicode::CaseFoldError>{\n        if !ClassBytesRange::new(b'a', b'z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'a');\n            let upper = cmp::min(self.end, b'z');\n            ranges.push(ClassBytesRange::new(lower - 32, upper - 32));\n        }\n        if !ClassBytesRange::new(b'A', b'Z').is_intersection_empty(self) {\n            let lower = cmp::max(self.start, b'A');\n            let upper = cmp::min(self.end, b'Z');\n            ranges.push(ClassBytesRange::new(lower + 32, upper + 32));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::lower":["#[inline]\nfn lower(&self) -> u8{\n        self.start\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::set_lower":["#[inline]\nfn set_lower(&mut self, bound: u8){\n        self.start = bound;\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::set_upper":["#[inline]\nfn set_upper(&mut self, bound: u8){\n        self.end = bound;\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as hir::interval::Interval>::upper":["#[inline]\nfn upper(&self) -> u8{\n        self.end\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassBytesRange as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        f.debug_struct(\"ClassBytesRange\")\n            .field(\"start\", &crate::debug::Byte(self.start))\n            .field(\"end\", &crate::debug::Byte(self.end))\n            .finish()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a ClassUnicodeRange>{\n        self.0.next()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple":["/// Apply simple case folding to this Unicode scalar value range.\n///\n/// Additional ranges are appended to the given vector. Canonical ordering\n/// is *not* maintained in the given vector.\nfn case_fold_simple(\n        &self,\n        ranges: &mut Vec<ClassUnicodeRange>,\n    ) -> Result<(), unicode::CaseFoldError>{\n        let mut folder = unicode::SimpleCaseFolder::new()?;\n        if !folder.overlaps(self.start, self.end) {\n            return Ok(());\n        }\n        let (start, end) = (u32::from(self.start), u32::from(self.end));\n        for cp in (start..=end).filter_map(char::from_u32) {\n            for &cp_folded in folder.mapping(cp) {\n                ranges.push(ClassUnicodeRange::new(cp_folded, cp_folded));\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::lower":["#[inline]\nfn lower(&self) -> char{\n        self.start\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower":["#[inline]\nfn set_lower(&mut self, bound: char){\n        self.start = bound;\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper":["#[inline]\nfn set_upper(&mut self, bound: char){\n        self.end = bound;\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as hir::interval::Interval>::upper":["#[inline]\nfn upper(&self) -> char{\n        self.end\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ClassUnicodeRange as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        let start = if !self.start.is_whitespace() && !self.start.is_control()\n        {\n            self.start.to_string()\n        } else {\n            format!(\"0x{:X}\", u32::from(self.start))\n        };\n        let end = if !self.end.is_whitespace() && !self.end.is_control() {\n            self.end.to_string()\n        } else {\n            format!(\"0x{:X}\", u32::from(self.end))\n        };\n        f.debug_struct(\"ClassUnicodeRange\")\n            .field(\"start\", &start)\n            .field(\"end\", &end)\n            .finish()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        crate::error::Formatter::from(self).fmt(f)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::ErrorKind as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        use self::ErrorKind::*;\n\n        let msg = match *self {\n            UnicodeNotAllowed => \"Unicode not allowed here\",\n            InvalidUtf8 => \"pattern can match invalid UTF-8\",\n            UnicodePropertyNotFound => \"Unicode property not found\",\n            UnicodePropertyValueNotFound => \"Unicode property value not found\",\n            UnicodePerlClassNotFound => {\n                \"Unicode-aware Perl class not found \\\n                 (make sure the unicode-perl feature is enabled)\"\n            }\n            UnicodeCaseUnavailable => {\n                \"Unicode-aware case insensitivity matching is not available \\\n                 (make sure the unicode-case feature is enabled)\"\n            }\n        };\n        f.write_str(msg)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::Hir as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        self.kind.fmt(f)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::Hir as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        crate::hir::print::Printer::new().print(self, f)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::Hir as std::ops::Drop>::drop":["fn drop(&mut self){\n        use core::mem;\n\n        match *self.kind() {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Look(_) => return,\n            HirKind::Capture(ref x) if x.sub.kind.subs().is_empty() => return,\n            HirKind::Repetition(ref x) if x.sub.kind.subs().is_empty() => {\n                return\n            }\n            HirKind::Concat(ref x) if x.is_empty() => return,\n            HirKind::Alternation(ref x) if x.is_empty() => return,\n            _ => {}\n        }\n\n        let mut stack = vec![mem::replace(self, Hir::empty())];\n        while let Some(mut expr) = stack.pop() {\n            match expr.kind {\n                HirKind::Empty\n                | HirKind::Literal(_)\n                | HirKind::Class(_)\n                | HirKind::Look(_) => {}\n                HirKind::Capture(ref mut x) => {\n                    stack.push(mem::replace(&mut x.sub, Hir::empty()));\n                }\n                HirKind::Repetition(ref mut x) => {\n                    stack.push(mem::replace(&mut x.sub, Hir::empty()));\n                }\n                HirKind::Concat(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n                HirKind::Alternation(ref mut x) => {\n                    stack.extend(x.drain(..));\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::Literal as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result{\n        crate::debug::Bytes(&self.0).fmt(f)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::LookSet as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result{\n        if self.is_empty() {\n            return write!(f, \"∅\");\n        }\n        for look in self.iter() {\n            write!(f, \"{}\", look.as_char())?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::LookSetIter as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Look>{\n        if self.set.is_empty() {\n            return None;\n        }\n        // We'll never have more than u8::MAX distinct look-around assertions,\n        // so 'repr' will always fit into a u16.\n        let repr = u16::try_from(self.set.bits.trailing_zeros()).unwrap();\n        let look = Look::from_repr(1 << repr)?;\n        self.set = self.set.remove(look);\n        Some(look)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":["fn eq(&self, other: &IntervalSet<I>) -> bool{\n        self.ranges.eq(&other.ranges)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a I>{\n        self.0.next()\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<hir::literal::ExtractKind as std::default::Default>::default":["fn default() -> ExtractKind{\n        ExtractKind::Prefix\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"<hir::literal::Extractor as std::default::Default>::default":["fn default() -> Extractor{\n        Extractor::new()\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref":["fn as_ref(&self) -> &[u8]{\n        self.as_bytes()\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"<hir::literal::Literal as std::convert::From<char>>::from":["fn from(ch: char) -> Literal{\n        use alloc::string::ToString;\n        Literal::exact(ch.encode_utf8(&mut [0; 4]).to_string())\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"<hir::literal::Literal as std::convert::From<u8>>::from":["fn from(byte: u8) -> Literal{\n        Literal::exact(vec![byte])\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"<hir::literal::Literal as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result{\n        let tag = if self.exact { \"E\" } else { \"I\" };\n        f.debug_tuple(tag)\n            .field(&crate::debug::Bytes(self.as_bytes()))\n            .finish()\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"<hir::literal::Seq as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result{\n        write!(f, \"Seq\")?;\n        if let Some(lits) = self.literals() {\n            f.debug_list().entries(lits.iter()).finish()\n        } else {\n            write!(f, \"[∅]\")\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"<hir::literal::Seq as std::iter::FromIterator<hir::literal::Literal>>::from_iter":["fn from_iter<T: IntoIterator<Item = Literal>>(it: T) -> Seq{\n        let mut seq = Seq::empty();\n        for literal in it {\n            seq.push(literal);\n        }\n        seq\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"<hir::print::PrinterBuilder as std::default::Default>::default":["fn default() -> PrinterBuilder{\n        PrinterBuilder::new()\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::print::Writer<W> as hir::visitor::Visitor>::finish":["fn finish(self) -> fmt::Result{\n        Ok(())\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_alternation_in":["fn visit_alternation_in(&mut self) -> fmt::Result{\n        self.wtr.write_str(\"|\")\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_post":["fn visit_post(&mut self, hir: &Hir) -> fmt::Result{\n        match *hir.kind() {\n            // Handled during visit_pre\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Look(_) => {}\n            HirKind::Repetition(ref x) => {\n                match (x.min, x.max) {\n                    (0, Some(1)) => {\n                        self.wtr.write_str(\"?\")?;\n                    }\n                    (0, None) => {\n                        self.wtr.write_str(\"*\")?;\n                    }\n                    (1, None) => {\n                        self.wtr.write_str(\"+\")?;\n                    }\n                    (1, Some(1)) => {\n                        // 'a{1}' and 'a{1}?' are exactly equivalent to 'a'.\n                        return Ok(());\n                    }\n                    (m, None) => {\n                        write!(self.wtr, \"{{{},}}\", m)?;\n                    }\n                    (m, Some(n)) if m == n => {\n                        write!(self.wtr, \"{{{}}}\", m)?;\n                        // a{m} and a{m}? are always exactly equivalent.\n                        return Ok(());\n                    }\n                    (m, Some(n)) => {\n                        write!(self.wtr, \"{{{},{}}}\", m, n)?;\n                    }\n                }\n                if !x.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n            }\n            HirKind::Capture(_)\n            | HirKind::Concat(_)\n            | HirKind::Alternation(_) => {\n                self.wtr.write_str(r\")\")?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_pre":["fn visit_pre(&mut self, hir: &Hir) -> fmt::Result{\n        match *hir.kind() {\n            // Empty is represented by nothing in the concrete syntax, and\n            // repetition operators are strictly suffix oriented.\n            HirKind::Empty | HirKind::Repetition(_) => {}\n            HirKind::Literal(hir::Literal(ref bytes)) => {\n                // See the comment on the 'Concat' and 'Alternation' case below\n                // for why we put parens here. Literals are, conceptually,\n                // a special case of concatenation where each element is a\n                // character. The HIR flattens this into a Box<[u8]>, but we\n                // still need to treat it like a concatenation for correct\n                // printing. As a special case, we don't write parens if there\n                // is only one character. One character means there is no\n                // concat so we don't need parens. Adding parens would still be\n                // correct, but we drop them here because it tends to create\n                // rather noisy regexes even in simple cases.\n                let result = core::str::from_utf8(bytes);\n                let len = result.map_or(bytes.len(), |s| s.chars().count());\n                if len > 1 {\n                    self.wtr.write_str(r\"(?:\")?;\n                }\n                match result {\n                    Ok(string) => {\n                        for c in string.chars() {\n                            self.write_literal_char(c)?;\n                        }\n                    }\n                    Err(_) => {\n                        for &b in bytes.iter() {\n                            self.write_literal_byte(b)?;\n                        }\n                    }\n                }\n                if len > 1 {\n                    self.wtr.write_str(r\")\")?;\n                }\n            }\n            HirKind::Class(hir::Class::Unicode(ref cls)) => {\n                if cls.ranges().is_empty() {\n                    return self.wtr.write_str(\"[a&&b]\");\n                }\n                self.wtr.write_str(\"[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_char(range.start())?;\n                    } else if u32::from(range.start()) + 1\n                        == u32::from(range.end())\n                    {\n                        self.write_literal_char(range.start())?;\n                        self.write_literal_char(range.end())?;\n                    } else {\n                        self.write_literal_char(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_char(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"]\")?;\n            }\n            HirKind::Class(hir::Class::Bytes(ref cls)) => {\n                if cls.ranges().is_empty() {\n                    return self.wtr.write_str(\"[a&&b]\");\n                }\n                self.wtr.write_str(\"(?-u:[\")?;\n                for range in cls.iter() {\n                    if range.start() == range.end() {\n                        self.write_literal_class_byte(range.start())?;\n                    } else if range.start() + 1 == range.end() {\n                        self.write_literal_class_byte(range.start())?;\n                        self.write_literal_class_byte(range.end())?;\n                    } else {\n                        self.write_literal_class_byte(range.start())?;\n                        self.wtr.write_str(\"-\")?;\n                        self.write_literal_class_byte(range.end())?;\n                    }\n                }\n                self.wtr.write_str(\"])\")?;\n            }\n            HirKind::Look(ref look) => match *look {\n                hir::Look::Start => {\n                    self.wtr.write_str(r\"\\A\")?;\n                }\n                hir::Look::End => {\n                    self.wtr.write_str(r\"\\z\")?;\n                }\n                hir::Look::StartLF => {\n                    self.wtr.write_str(\"(?m:^)\")?;\n                }\n                hir::Look::EndLF => {\n                    self.wtr.write_str(\"(?m:$)\")?;\n                }\n                hir::Look::StartCRLF => {\n                    self.wtr.write_str(\"(?mR:^)\")?;\n                }\n                hir::Look::EndCRLF => {\n                    self.wtr.write_str(\"(?mR:$)\")?;\n                }\n                hir::Look::WordAscii => {\n                    self.wtr.write_str(r\"(?-u:\\b)\")?;\n                }\n                hir::Look::WordAsciiNegate => {\n                    self.wtr.write_str(r\"(?-u:\\B)\")?;\n                }\n                hir::Look::WordUnicode => {\n                    self.wtr.write_str(r\"\\b\")?;\n                }\n                hir::Look::WordUnicodeNegate => {\n                    self.wtr.write_str(r\"\\B\")?;\n                }\n            },\n            HirKind::Capture(hir::Capture { ref name, .. }) => {\n                self.wtr.write_str(\"(\")?;\n                if let Some(ref name) = *name {\n                    write!(self.wtr, \"?P<{}>\", name)?;\n                }\n            }\n            // Why do this? Wrapping concats and alts in non-capturing groups\n            // is not *always* necessary, but is sometimes necessary. For\n            // example, 'concat(a, alt(b, c))' should be written as 'a(?:b|c)'\n            // and not 'ab|c'. The former is clearly the intended meaning, but\n            // the latter is actually 'alt(concat(a, b), c)'.\n            //\n            // It would be possible to only group these things in cases where\n            // it's strictly necessary, but it requires knowing the parent\n            // expression. And since this technique is simpler and always\n            // correct, we take this route. More to the point, it is a non-goal\n            // of an HIR printer to show a nice easy-to-read regex. Indeed,\n            // its construction forbids it from doing so. Therefore, inserting\n            // extra groups where they aren't necessary is perfectly okay.\n            HirKind::Concat(_) | HirKind::Alternation(_) => {\n                self.wtr.write_str(r\"(?:\")?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"<hir::translate::TranslatorBuilder as std::default::Default>::default":["fn default() -> TranslatorBuilder{\n        TranslatorBuilder::new()\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish":["fn finish(self) -> Result<Hir>{\n        // ... otherwise, we should have exactly one HIR on the stack.\n        assert_eq!(self.trans().stack.borrow().len(), 1);\n        Ok(self.pop().unwrap().unwrap_expr())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_alternation_in":["fn visit_alternation_in(&mut self) -> Result<()>{\n        self.push(HirFrame::AlternationBranch);\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["fn visit_class_set_binary_op_in(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["fn visit_class_set_binary_op_post(\n        &mut self,\n        op: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        use crate::ast::ClassSetBinaryOpKind::*;\n\n        if self.flags().unicode() {\n            let mut rhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut lhs = self.pop().unwrap().unwrap_class_unicode();\n            let mut cls = self.pop().unwrap().unwrap_class_unicode();\n            if self.flags().case_insensitive() {\n                rhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.rhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n                lhs.try_case_fold_simple().map_err(|_| {\n                    self.error(\n                        op.lhs.span().clone(),\n                        ErrorKind::UnicodeCaseUnavailable,\n                    )\n                })?;\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let mut rhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut lhs = self.pop().unwrap().unwrap_class_bytes();\n            let mut cls = self.pop().unwrap().unwrap_class_bytes();\n            if self.flags().case_insensitive() {\n                rhs.case_fold_simple();\n                lhs.case_fold_simple();\n            }\n            match op.kind {\n                Intersection => lhs.intersect(&rhs),\n                Difference => lhs.difference(&rhs),\n                SymmetricDifference => lhs.symmetric_difference(&rhs),\n            }\n            cls.union(&lhs);\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["fn visit_class_set_binary_op_pre(\n        &mut self,\n        _op: &ast::ClassSetBinaryOp,\n    ) -> Result<()>{\n        if self.flags().unicode() {\n            let cls = hir::ClassUnicode::empty();\n            self.push(HirFrame::ClassUnicode(cls));\n        } else {\n            let cls = hir::ClassBytes::empty();\n            self.push(HirFrame::ClassBytes(cls));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post":["fn visit_class_set_item_post(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()>{\n        match *ast {\n            ast::ClassSetItem::Empty(_) => {}\n            ast::ClassSetItem::Literal(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.c, x.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let byte = self.class_literal_byte(x)?;\n                    cls.push(hir::ClassBytesRange::new(byte, byte));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Range(ref x) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.push(hir::ClassUnicodeRange::new(x.start.c, x.end.c));\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    let start = self.class_literal_byte(&x.start)?;\n                    let end = self.class_literal_byte(&x.end)?;\n                    cls.push(hir::ClassBytesRange::new(start, end));\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Ascii(ref x) => {\n                if self.flags().unicode() {\n                    let xcls = self.hir_ascii_unicode_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let xcls = self.hir_ascii_byte_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Unicode(ref x) => {\n                let xcls = self.hir_unicode_class(x)?;\n                let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                cls.union(&xcls);\n                self.push(HirFrame::ClassUnicode(cls));\n            }\n            ast::ClassSetItem::Perl(ref x) => {\n                if self.flags().unicode() {\n                    let xcls = self.hir_perl_unicode_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let xcls = self.hir_perl_byte_class(x)?;\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    cls.union(&xcls);\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            ast::ClassSetItem::Bracketed(ref ast) => {\n                if self.flags().unicode() {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_unicode();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassUnicode(cls2));\n                } else {\n                    let mut cls1 = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls1,\n                    )?;\n\n                    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();\n                    cls2.union(&cls1);\n                    self.push(HirFrame::ClassBytes(cls2));\n                }\n            }\n            // This is handled automatically by the visitor.\n            ast::ClassSetItem::Union(_) => {}\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre":["fn visit_class_set_item_pre(\n        &mut self,\n        ast: &ast::ClassSetItem,\n    ) -> Result<()>{\n        match *ast {\n            ast::ClassSetItem::Bracketed(_) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            // We needn't handle the Union case here since the visitor will\n            // do it for us.\n            _ => {}\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post":["fn visit_post(&mut self, ast: &Ast) -> Result<()>{\n        match *ast {\n            Ast::Empty(_) => {\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Flags(ref x) => {\n                self.set_flags(&x.flags);\n                // Flags in the AST are generally considered directives and\n                // not actual sub-expressions. However, they can be used in\n                // the concrete syntax like `((?i))`, and we need some kind of\n                // indication of an expression there, and Empty is the correct\n                // choice.\n                //\n                // There can also be things like `(?i)+`, but we rule those out\n                // in the parser. In the future, we might allow them for\n                // consistency sake.\n                self.push(HirFrame::Expr(Hir::empty()));\n            }\n            Ast::Literal(ref x) => {\n                match self.ast_literal_to_scalar(x)? {\n                    Either::Right(byte) => self.push_byte(byte),\n                    Either::Left(ch) => {\n                        if !self.flags().unicode() && ch.len_utf8() > 1 {\n                            return Err(self\n                                .error(x.span, ErrorKind::UnicodeNotAllowed));\n                        }\n                        match self.case_fold_char(x.span, ch)? {\n                            None => self.push_char(ch),\n                            Some(expr) => self.push(HirFrame::Expr(expr)),\n                        }\n                    }\n                }\n                // self.push(HirFrame::Expr(self.hir_literal(x)?));\n            }\n            Ast::Dot(span) => {\n                self.push(HirFrame::Expr(self.hir_dot(span)?));\n            }\n            Ast::Assertion(ref x) => {\n                self.push(HirFrame::Expr(self.hir_assertion(x)?));\n            }\n            Ast::Class(ast::Class::Perl(ref x)) => {\n                if self.flags().unicode() {\n                    let cls = self.hir_perl_unicode_class(x)?;\n                    let hcls = hir::Class::Unicode(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                } else {\n                    let cls = self.hir_perl_byte_class(x)?;\n                    let hcls = hir::Class::Bytes(cls);\n                    self.push(HirFrame::Expr(Hir::class(hcls)));\n                }\n            }\n            Ast::Class(ast::Class::Unicode(ref x)) => {\n                let cls = hir::Class::Unicode(self.hir_unicode_class(x)?);\n                self.push(HirFrame::Expr(Hir::class(cls)));\n            }\n            Ast::Class(ast::Class::Bracketed(ref ast)) => {\n                if self.flags().unicode() {\n                    let mut cls = self.pop().unwrap().unwrap_class_unicode();\n                    self.unicode_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    let expr = Hir::class(hir::Class::Unicode(cls));\n                    self.push(HirFrame::Expr(expr));\n                } else {\n                    let mut cls = self.pop().unwrap().unwrap_class_bytes();\n                    self.bytes_fold_and_negate(\n                        &ast.span,\n                        ast.negated,\n                        &mut cls,\n                    )?;\n                    let expr = Hir::class(hir::Class::Bytes(cls));\n                    self.push(HirFrame::Expr(expr));\n                }\n            }\n            Ast::Repetition(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                self.pop().unwrap().unwrap_repetition();\n                self.push(HirFrame::Expr(self.hir_repetition(x, expr)));\n            }\n            Ast::Group(ref x) => {\n                let expr = self.pop().unwrap().unwrap_expr();\n                let old_flags = self.pop().unwrap().unwrap_group();\n                self.trans().flags.set(old_flags);\n                self.push(HirFrame::Expr(self.hir_capture(x, expr)));\n            }\n            Ast::Concat(_) => {\n                let mut exprs = vec![];\n                while let Some(expr) = self.pop_concat_expr() {\n                    if !matches!(*expr.kind(), HirKind::Empty) {\n                        exprs.push(expr);\n                    }\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::concat(exprs)));\n            }\n            Ast::Alternation(_) => {\n                let mut exprs = vec![];\n                while let Some(expr) = self.pop_alt_expr() {\n                    self.pop().unwrap().unwrap_alternation_pipe();\n                    exprs.push(expr);\n                }\n                exprs.reverse();\n                self.push(HirFrame::Expr(Hir::alternation(exprs)));\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre":["fn visit_pre(&mut self, ast: &Ast) -> Result<()>{\n        match *ast {\n            Ast::Class(ast::Class::Bracketed(_)) => {\n                if self.flags().unicode() {\n                    let cls = hir::ClassUnicode::empty();\n                    self.push(HirFrame::ClassUnicode(cls));\n                } else {\n                    let cls = hir::ClassBytes::empty();\n                    self.push(HirFrame::ClassBytes(cls));\n                }\n            }\n            Ast::Repetition(_) => self.push(HirFrame::Repetition),\n            Ast::Group(ref x) => {\n                let old_flags = x\n                    .flags()\n                    .map(|ast| self.set_flags(ast))\n                    .unwrap_or_else(|| self.flags());\n                self.push(HirFrame::Group { old_flags });\n            }\n            Ast::Concat(ref x) if x.asts.is_empty() => {}\n            Ast::Concat(_) => {\n                self.push(HirFrame::Concat);\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => {}\n            Ast::Alternation(_) => {\n                self.push(HirFrame::Alternation);\n                self.push(HirFrame::AlternationBranch);\n            }\n            _ => {}\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"<u8 as hir::interval::Bound>::as_u32":["fn as_u32(self) -> u32{\n        u32::from(self)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<u8 as hir::interval::Bound>::decrement":["fn decrement(self) -> Self{\n        self.checked_sub(1).unwrap()\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<u8 as hir::interval::Bound>::increment":["fn increment(self) -> Self{\n        self.checked_add(1).unwrap()\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<u8 as hir::interval::Bound>::max_value":["fn max_value() -> Self{\n        u8::MAX\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<u8 as hir::interval::Bound>::min_value":["fn min_value() -> Self{\n        u8::MIN\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"<unicode::CaseFoldError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        write!(\n            f,\n            \"Unicode-aware case folding is not available \\\n             (probably because the unicode-case feature is not enabled)\"\n        )\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"<unicode::UnicodeWordError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        write!(\n            f,\n            \"Unicode-aware \\\\w class is not available \\\n             (probably because the unicode-perl feature is not enabled)\"\n        )\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"<utf8::ScalarRange as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"ScalarRange({:X}, {:X})\", self.start, self.end)\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Range as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        if self.start == self.end {\n            write!(f, \"[{:X}]\", self.start)\n        } else {\n            write!(f, \"[{:X}-{:X}]\", self.start, self.end)\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Sequence as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => write!(f, \"{:?}\", r),\n            Two(ref r) => write!(f, \"{:?}{:?}\", r[0], r[1]),\n            Three(ref r) => write!(f, \"{:?}{:?}{:?}\", r[0], r[1], r[2]),\n            Four(ref r) => {\n                write!(f, \"{:?}{:?}{:?}{:?}\", r[0], r[1], r[2], r[3])\n            }\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"<utf8::Utf8Sequences as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        'TOP: while let Some(mut r) = self.range_stack.pop() {\n            'INNER: loop {\n                if let Some((r1, r2)) = r.split() {\n                    self.push(r2.start, r2.end);\n                    r.start = r1.start;\n                    r.end = r1.end;\n                    continue 'INNER;\n                }\n                if !r.is_valid() {\n                    continue 'TOP;\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let max = max_scalar_value(i);\n                    if r.start <= max && max < r.end {\n                        self.push(max + 1, r.end);\n                        r.end = max;\n                        continue 'INNER;\n                    }\n                }\n                if let Some(ascii_range) = r.as_ascii() {\n                    return Some(Utf8Sequence::One(ascii_range));\n                }\n                for i in 1..MAX_UTF8_BYTES {\n                    let m = (1 << (6 * i)) - 1;\n                    if (r.start & !m) != (r.end & !m) {\n                        if (r.start & m) != 0 {\n                            self.push((r.start | m) + 1, r.end);\n                            r.end = r.start | m;\n                            continue 'INNER;\n                        }\n                        if (r.end & m) != m {\n                            self.push(r.end & !m, r.end);\n                            r.end = (r.end & !m) - 1;\n                            continue 'INNER;\n                        }\n                    }\n                }\n                let mut start = [0; MAX_UTF8_BYTES];\n                let mut end = [0; MAX_UTF8_BYTES];\n                let n = r.encode(&mut start, &mut end);\n                return Some(Utf8Sequence::from_encoded_range(\n                    &start[0..n],\n                    &end[0..n],\n                ));\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"ast::Alternation":["/// An alternation of regular expressions.\npub struct Alternation {\n    /// The span of this alternation.\n    pub span: Span,\n    /// The alternate regular expressions.\n    pub asts: Vec<Ast>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Alternation::into_ast":["/// Return this alternation as an AST.\n///\n/// If this alternation contains zero ASTs, then Ast::Empty is\n/// returned. If this alternation contains exactly 1 AST, then the\n/// corresponding AST is returned. Otherwise, Ast::Alternation is returned.\npub fn into_ast(mut self) -> Ast{\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Alternation(self),\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Assertion":["/// A single zero-width assertion.\npub struct Assertion {\n    /// The span of this assertion.\n    pub span: Span,\n    /// The assertion kind, e.g., `\\b` or `^`.\n    pub kind: AssertionKind,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::AssertionKind":["/// An assertion kind.\npub enum AssertionKind {\n    /// `^`\n    StartLine,\n    /// `$`\n    EndLine,\n    /// `\\A`\n    StartText,\n    /// `\\z`\n    EndText,\n    /// `\\b`\n    WordBoundary,\n    /// `\\B`\n    NotWordBoundary,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Ast":["/// An abstract syntax tree for a single regular expression.\n///\n/// An `Ast`'s `fmt::Display` implementation uses constant stack space and heap\n/// space proportional to the size of the `Ast`.\n///\n/// This type defines its own destructor that uses constant stack space and\n/// heap space proportional to the size of the `Ast`.\npub enum Ast {\n    /// An empty regex that matches everything.\n    Empty(Span),\n    /// A set of flags, e.g., `(?is)`.\n    Flags(SetFlags),\n    /// A single character literal, which includes escape sequences.\n    Literal(Literal),\n    /// The \"any character\" class.\n    Dot(Span),\n    /// A single zero-width assertion.\n    Assertion(Assertion),\n    /// A single character class. This includes all forms of character classes\n    /// except for `.`. e.g., `\\d`, `\\pN`, `[a-z]` and `[[:alpha:]]`.\n    Class(Class),\n    /// A repetition operator applied to an arbitrary regular expression.\n    Repetition(Repetition),\n    /// A grouped regular expression.\n    Group(Group),\n    /// An alternation of regular expressions.\n    Alternation(Alternation),\n    /// A concatenation of regular expressions.\n    Concat(Concat),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Ast::has_subexprs":["/// Returns true if and only if this AST has any (including possibly empty)\n/// subexpressions.\nfn has_subexprs(&self) -> bool{\n        match *self {\n            Ast::Empty(_)\n            | Ast::Flags(_)\n            | Ast::Literal(_)\n            | Ast::Dot(_)\n            | Ast::Assertion(_) => false,\n            Ast::Class(_)\n            | Ast::Repetition(_)\n            | Ast::Group(_)\n            | Ast::Alternation(_)\n            | Ast::Concat(_) => true,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Ast::is_empty":["/// Return true if and only if this Ast is empty.\npub fn is_empty(&self) -> bool{\n        match *self {\n            Ast::Empty(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Ast::span":["/// Return the span of this abstract syntax tree.\npub fn span(&self) -> &Span{\n        match *self {\n            Ast::Empty(ref span) => span,\n            Ast::Flags(ref x) => &x.span,\n            Ast::Literal(ref x) => &x.span,\n            Ast::Dot(ref span) => span,\n            Ast::Assertion(ref x) => &x.span,\n            Ast::Class(ref x) => x.span(),\n            Ast::Repetition(ref x) => &x.span,\n            Ast::Group(ref x) => &x.span,\n            Ast::Alternation(ref x) => &x.span,\n            Ast::Concat(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::CaptureName":["/// A capture name.\n///\n/// This corresponds to the name itself between the angle brackets in, e.g.,\n/// `(?P<foo>expr)`.\npub struct CaptureName {\n    /// The span of this capture name.\n    pub span: Span,\n    /// The capture name.\n    pub name: String,\n    /// The capture index.\n    pub index: u32,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Class":["/// A single character class expression.\npub enum Class {\n    /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    Unicode(ClassUnicode),\n    /// A perl character class, e.g., `\\d` or `\\W`.\n    Perl(ClassPerl),\n    /// A bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    Bracketed(ClassBracketed),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Class::span":["/// Return the span of this character class.\npub fn span(&self) -> &Span{\n        match *self {\n            Class::Perl(ref x) => &x.span,\n            Class::Unicode(ref x) => &x.span,\n            Class::Bracketed(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassAscii":["/// An ASCII character class.\npub struct ClassAscii {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of ASCII class.\n    pub kind: ClassAsciiKind,\n    /// Whether the class is negated or not. e.g., `[[:alpha:]]` is not negated\n    /// but `[[:^alpha:]]` is.\n    pub negated: bool,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassAsciiKind":["/// The available ASCII character classes.\npub enum ClassAsciiKind {\n    /// `[0-9A-Za-z]`\n    Alnum,\n    /// `[A-Za-z]`\n    Alpha,\n    /// `[\\x00-\\x7F]`\n    Ascii,\n    /// `[ \\t]`\n    Blank,\n    /// `[\\x00-\\x1F\\x7F]`\n    Cntrl,\n    /// `[0-9]`\n    Digit,\n    /// `[!-~]`\n    Graph,\n    /// `[a-z]`\n    Lower,\n    /// `[ -~]`\n    Print,\n    /// `[!-/:-@\\[-`{-~]`\n    Punct,\n    /// `[\\t\\n\\v\\f\\r ]`\n    Space,\n    /// `[A-Z]`\n    Upper,\n    /// `[0-9A-Za-z_]`\n    Word,\n    /// `[0-9A-Fa-f]`\n    Xdigit,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassAsciiKind::from_name":["/// Return the corresponding ClassAsciiKind variant for the given name.\n///\n/// The name given should correspond to the lowercase version of the\n/// variant name. e.g., `cntrl` is the name for `ClassAsciiKind::Cntrl`.\n///\n/// If no variant with the corresponding name exists, then `None` is\n/// returned.\npub fn from_name(name: &str) -> Option<ClassAsciiKind>{\n        use self::ClassAsciiKind::*;\n        match name {\n            \"alnum\" => Some(Alnum),\n            \"alpha\" => Some(Alpha),\n            \"ascii\" => Some(Ascii),\n            \"blank\" => Some(Blank),\n            \"cntrl\" => Some(Cntrl),\n            \"digit\" => Some(Digit),\n            \"graph\" => Some(Graph),\n            \"lower\" => Some(Lower),\n            \"print\" => Some(Print),\n            \"punct\" => Some(Punct),\n            \"space\" => Some(Space),\n            \"upper\" => Some(Upper),\n            \"word\" => Some(Word),\n            \"xdigit\" => Some(Xdigit),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassBracketed":["/// A bracketed character class, e.g., `[a-z0-9]`.\npub struct ClassBracketed {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not. e.g., `[a]` is not negated but\n    /// `[^a]` is.\n    pub negated: bool,\n    /// The type of this set. A set is either a normal union of things, e.g.,\n    /// `[abc]` or a result of applying set operations, e.g., `[\\pL--c]`.\n    pub kind: ClassSet,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassPerl":["/// A Perl character class.\npub struct ClassPerl {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of Perl class.\n    pub kind: ClassPerlKind,\n    /// Whether the class is negated or not. e.g., `\\d` is not negated but\n    /// `\\D` is.\n    pub negated: bool,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassPerlKind":["/// The available Perl character classes.\npub enum ClassPerlKind {\n    /// Decimal numbers.\n    Digit,\n    /// Whitespace.\n    Space,\n    /// Word characters.\n    Word,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSet":["/// A character class set.\n///\n/// This type corresponds to the internal structure of a bracketed character\n/// class. That is, every bracketed character is one of two types: a union of\n/// items (literals, ranges, other bracketed classes) or a tree of binary set\n/// operations.\npub enum ClassSet {\n    /// An item, which can be a single literal, range, nested character class\n    /// or a union of items.\n    Item(ClassSetItem),\n    /// A single binary operation (i.e., &&, -- or ~~).\n    BinaryOp(ClassSetBinaryOp),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSet::is_empty":["/// Return true if and only if this class set is empty.\nfn is_empty(&self) -> bool{\n        match *self {\n            ClassSet::Item(ClassSetItem::Empty(_)) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSet::span":["/// Return the span of this character class set.\npub fn span(&self) -> &Span{\n        match *self {\n            ClassSet::Item(ref x) => x.span(),\n            ClassSet::BinaryOp(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSet::union":["/// Build a set from a union.\npub fn union(ast: ClassSetUnion) -> ClassSet{\n        ClassSet::Item(ClassSetItem::Union(ast))\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetBinaryOp":["/// A Unicode character class set operation.\npub struct ClassSetBinaryOp {\n    /// The span of this operation. e.g., the `a-z--[h-p]` in `[a-z--h-p]`.\n    pub span: Span,\n    /// The type of this set operation.\n    pub kind: ClassSetBinaryOpKind,\n    /// The left hand side of the operation.\n    pub lhs: Box<ClassSet>,\n    /// The right hand side of the operation.\n    pub rhs: Box<ClassSet>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetBinaryOpKind":["/// The type of a Unicode character class set operation.\n///\n/// Note that this doesn't explicitly represent union since there is no\n/// explicit union operator. Concatenation inside a character class corresponds\n/// to the union operation.\npub enum ClassSetBinaryOpKind {\n    /// The intersection of two sets, e.g., `\\pN&&[a-z]`.\n    Intersection,\n    /// The difference of two sets, e.g., `\\pN--[0-9]`.\n    Difference,\n    /// The symmetric difference of two sets. The symmetric difference is the\n    /// set of elements belonging to one but not both sets.\n    /// e.g., `[\\pL~~[:ascii:]]`.\n    SymmetricDifference,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetItem":["/// A single component of a character class set.\npub enum ClassSetItem {\n    /// An empty item.\n    ///\n    /// Note that a bracketed character class cannot contain a single empty\n    /// item. Empty items can appear when using one of the binary operators.\n    /// For example, `[&&]` is the intersection of two empty classes.\n    Empty(Span),\n    /// A single literal.\n    Literal(Literal),\n    /// A range between two literals.\n    Range(ClassSetRange),\n    /// An ASCII character class, e.g., `[:alnum:]` or `[:punct:]`.\n    Ascii(ClassAscii),\n    /// A Unicode character class, e.g., `\\pL` or `\\p{Greek}`.\n    Unicode(ClassUnicode),\n    /// A perl character class, e.g., `\\d` or `\\W`.\n    Perl(ClassPerl),\n    /// A bracketed character class set, which may contain zero or more\n    /// character ranges and/or zero or more nested classes. e.g.,\n    /// `[a-zA-Z\\pL]`.\n    Bracketed(Box<ClassBracketed>),\n    /// A union of items.\n    Union(ClassSetUnion),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetItem::span":["/// Return the span of this character class set item.\npub fn span(&self) -> &Span{\n        match *self {\n            ClassSetItem::Empty(ref span) => span,\n            ClassSetItem::Literal(ref x) => &x.span,\n            ClassSetItem::Range(ref x) => &x.span,\n            ClassSetItem::Ascii(ref x) => &x.span,\n            ClassSetItem::Perl(ref x) => &x.span,\n            ClassSetItem::Unicode(ref x) => &x.span,\n            ClassSetItem::Bracketed(ref x) => &x.span,\n            ClassSetItem::Union(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetRange":["/// A single character class range in a set.\npub struct ClassSetRange {\n    /// The span of this range.\n    pub span: Span,\n    /// The start of this range.\n    pub start: Literal,\n    /// The end of this range.\n    pub end: Literal,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetRange::is_valid":["/// Returns true if and only if this character class range is valid.\n///\n/// The only case where a range is invalid is if its start is greater than\n/// its end.\npub fn is_valid(&self) -> bool{\n        self.start.c <= self.end.c\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetUnion":["/// A union of items inside a character class set.\npub struct ClassSetUnion {\n    /// The span of the items in this operation. e.g., the `a-z0-9` in\n    /// `[^a-z0-9]`\n    pub span: Span,\n    /// The sequence of items that make up this union.\n    pub items: Vec<ClassSetItem>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetUnion::into_item":["/// Return this union as a character class set item.\n///\n/// If this union contains zero items, then an empty union is\n/// returned. If this concatenation contains exactly 1 item, then the\n/// corresponding item is returned. Otherwise, ClassSetItem::Union is\n/// returned.\npub fn into_item(mut self) -> ClassSetItem{\n        match self.items.len() {\n            0 => ClassSetItem::Empty(self.span),\n            1 => self.items.pop().unwrap(),\n            _ => ClassSetItem::Union(self),\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassSetUnion::push":["/// Push a new item in this union.\n///\n/// The ending position of this union's span is updated to the ending\n/// position of the span of the item given. If the union is empty, then\n/// the starting position of this union is set to the starting position\n/// of this item.\n///\n/// In other words, if you only use this method to add items to a union\n/// and you set the spans on each item correctly, then you should never\n/// need to adjust the span of the union directly.\npub fn push(&mut self, item: ClassSetItem){\n        if self.items.is_empty() {\n            self.span.start = item.span().start;\n        }\n        self.span.end = item.span().end;\n        self.items.push(item);\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicode":["/// A Unicode character class.\npub struct ClassUnicode {\n    /// The span of this class.\n    pub span: Span,\n    /// Whether this class is negated or not.\n    ///\n    /// Note: be careful when using this attribute. This specifically refers\n    /// to whether the class is written as `\\p` or `\\P`, where the latter\n    /// is `negated = true`. However, it also possible to write something like\n    /// `\\P{scx!=Katakana}` which is actually equivalent to\n    /// `\\p{scx=Katakana}` and is therefore not actually negated even though\n    /// `negated = true` here. To test whether this class is truly negated\n    /// or not, use the `is_negated` method.\n    pub negated: bool,\n    /// The kind of Unicode class.\n    pub kind: ClassUnicodeKind,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicode::is_negated":["/// Returns true if this class has been negated.\n///\n/// Note that this takes the Unicode op into account, if it's present.\n/// e.g., `is_negated` for `\\P{scx!=Katakana}` will return `false`.\npub fn is_negated(&self) -> bool{\n        match self.kind {\n            ClassUnicodeKind::NamedValue {\n                op: ClassUnicodeOpKind::NotEqual,\n                ..\n            } => !self.negated,\n            _ => self.negated,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicodeKind":["/// The available forms of Unicode character classes.\npub enum ClassUnicodeKind {\n    /// A one letter abbreviated class, e.g., `\\pN`.\n    OneLetter(char),\n    /// A binary property, general category or script. The string may be\n    /// empty.\n    Named(String),\n    /// A property name and an associated value.\n    NamedValue {\n        /// The type of Unicode op used to associate `name` with `value`.\n        op: ClassUnicodeOpKind,\n        /// The property name (which may be empty).\n        name: String,\n        /// The property value (which may be empty).\n        value: String,\n    },\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicodeOpKind":["/// The type of op used in a Unicode character class.\npub enum ClassUnicodeOpKind {\n    /// A property set to a specific value, e.g., `\\p{scx=Katakana}`.\n    Equal,\n    /// A property set to a specific value using a colon, e.g.,\n    /// `\\p{scx:Katakana}`.\n    Colon,\n    /// A property that isn't a particular value, e.g., `\\p{scx!=Katakana}`.\n    NotEqual,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ClassUnicodeOpKind::is_equal":["/// Whether the op is an equality op or not.\npub fn is_equal(&self) -> bool{\n        match *self {\n            ClassUnicodeOpKind::Equal | ClassUnicodeOpKind::Colon => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Comment":["/// A comment from a regular expression with an associated span.\n///\n/// A regular expression can only contain comments when the `x` flag is\n/// enabled.\npub struct Comment {\n    /// The span of this comment, including the beginning `#` and ending `\\n`.\n    pub span: Span,\n    /// The comment text, starting with the first character following the `#`\n    /// and ending with the last character preceding the `\\n`.\n    pub comment: String,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Concat":["/// A concatenation of regular expressions.\npub struct Concat {\n    /// The span of this concatenation.\n    pub span: Span,\n    /// The concatenation regular expressions.\n    pub asts: Vec<Ast>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Concat::into_ast":["/// Return this concatenation as an AST.\n///\n/// If this concatenation contains zero ASTs, then Ast::Empty is\n/// returned. If this concatenation contains exactly 1 AST, then the\n/// corresponding AST is returned. Otherwise, Ast::Concat is returned.\npub fn into_ast(mut self) -> Ast{\n        match self.asts.len() {\n            0 => Ast::Empty(self.span),\n            1 => self.asts.pop().unwrap(),\n            _ => Ast::Concat(self),\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error":["/// An error that occurred while parsing a regular expression into an abstract\n/// syntax tree.\n///\n/// Note that not all ASTs represents a valid regular expression. For example,\n/// an AST is constructed without error for `\\p{Quux}`, but `Quux` is not a\n/// valid Unicode property name. That particular error is reported when\n/// translating an AST to the high-level intermediate representation (`HIR`).\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the parser generated the error from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error.\n    span: Span,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error::auxiliary_span":["/// Return an auxiliary span. This span exists only for some errors that\n/// benefit from being able to point to two locations in the original\n/// regular expression. For example, \"duplicate\" errors will have the\n/// main error position set to the duplicate occurrence while its\n/// auxiliary span will be set to the initial occurrence.\npub fn auxiliary_span(&self) -> Option<&Span>{\n        use self::ErrorKind::*;\n        match self.kind {\n            FlagDuplicate { ref original } => Some(original),\n            FlagRepeatedNegation { ref original, .. } => Some(original),\n            GroupNameDuplicate { ref original, .. } => Some(original),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error::kind":["/// Return the type of this error.\npub fn kind(&self) -> &ErrorKind{\n        &self.kind\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error::pattern":["/// The original pattern string in which this error occurred.\n///\n/// Every span reported by this error is reported in terms of this string.\npub fn pattern(&self) -> &str{\n        &self.pattern\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Error::span":["/// Return the span at which this error occurred.\npub fn span(&self) -> &Span{\n        &self.span\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::ErrorKind":["/// The type of an error that occurred while building an AST.\n///\n/// This error type is marked as `non_exhaustive`. This means that adding a\n/// new variant is not considered a breaking change.\n#[non_exhaustive]\npub enum ErrorKind {\n    /// The capturing group limit was exceeded.\n    ///\n    /// Note that this represents a limit on the total number of capturing\n    /// groups in a regex and not necessarily the number of nested capturing\n    /// groups. That is, the nest limit can be low and it is still possible for\n    /// this error to occur.\n    CaptureLimitExceeded,\n    /// An invalid escape sequence was found in a character class set.\n    ClassEscapeInvalid,\n    /// An invalid character class range was found. An invalid range is any\n    /// range where the start is greater than the end.\n    ClassRangeInvalid,\n    /// An invalid range boundary was found in a character class. Range\n    /// boundaries must be a single literal codepoint, but this error indicates\n    /// that something else was found, such as a nested class.\n    ClassRangeLiteral,\n    /// An opening `[` was found with no corresponding closing `]`.\n    ClassUnclosed,\n    /// Note that this error variant is no longer used. Namely, a decimal\n    /// number can only appear as a repetition quantifier. When the number\n    /// in a repetition quantifier is empty, then it gets its own specialized\n    /// error, `RepetitionCountDecimalEmpty`.\n    DecimalEmpty,\n    /// An invalid decimal number was given where one was expected.\n    DecimalInvalid,\n    /// A bracketed hex literal was empty.\n    EscapeHexEmpty,\n    /// A bracketed hex literal did not correspond to a Unicode scalar value.\n    EscapeHexInvalid,\n    /// An invalid hexadecimal digit was found.\n    EscapeHexInvalidDigit,\n    /// EOF was found before an escape sequence was completed.\n    EscapeUnexpectedEof,\n    /// An unrecognized escape sequence.\n    EscapeUnrecognized,\n    /// A dangling negation was used when setting flags, e.g., `i-`.\n    FlagDanglingNegation,\n    /// A flag was used twice, e.g., `i-i`.\n    FlagDuplicate {\n        /// The position of the original flag. The error position\n        /// points to the duplicate flag.\n        original: Span,\n    },\n    /// The negation operator was used twice, e.g., `-i-s`.\n    FlagRepeatedNegation {\n        /// The position of the original negation operator. The error position\n        /// points to the duplicate negation operator.\n        original: Span,\n    },\n    /// Expected a flag but got EOF, e.g., `(?`.\n    FlagUnexpectedEof,\n    /// Unrecognized flag, e.g., `a`.\n    FlagUnrecognized,\n    /// A duplicate capture name was found.\n    GroupNameDuplicate {\n        /// The position of the initial occurrence of the capture name. The\n        /// error position itself points to the duplicate occurrence.\n        original: Span,\n    },\n    /// A capture group name is empty, e.g., `(?P<>abc)`.\n    GroupNameEmpty,\n    /// An invalid character was seen for a capture group name. This includes\n    /// errors where the first character is a digit (even though subsequent\n    /// characters are allowed to be digits).\n    GroupNameInvalid,\n    /// A closing `>` could not be found for a capture group name.\n    GroupNameUnexpectedEof,\n    /// An unclosed group, e.g., `(ab`.\n    ///\n    /// The span of this error corresponds to the unclosed parenthesis.\n    GroupUnclosed,\n    /// An unopened group, e.g., `ab)`.\n    GroupUnopened,\n    /// The nest limit was exceeded. The limit stored here is the limit\n    /// configured in the parser.\n    NestLimitExceeded(u32),\n    /// The range provided in a counted repetition operator is invalid. The\n    /// range is invalid if the start is greater than the end.\n    RepetitionCountInvalid,\n    /// An opening `{` was not followed by a valid decimal value.\n    /// For example, `x{}` or `x{]}` would fail.\n    RepetitionCountDecimalEmpty,\n    /// An opening `{` was found with no corresponding closing `}`.\n    RepetitionCountUnclosed,\n    /// A repetition operator was applied to a missing sub-expression. This\n    /// occurs, for example, in the regex consisting of just a `*` or even\n    /// `(?i)*`. It is, however, possible to create a repetition operating on\n    /// an empty sub-expression. For example, `()*` is still considered valid.\n    RepetitionMissing,\n    /// The Unicode class is not valid. This typically occurs when a `\\p` is\n    /// followed by something other than a `{`.\n    UnicodeClassInvalid,\n    /// When octal support is disabled, this error is produced when an octal\n    /// escape is used. The octal escape is assumed to be an invocation of\n    /// a backreference, which is the common case.\n    UnsupportedBackreference,\n    /// When syntax similar to PCRE's look-around is used, this error is\n    /// returned. Some example syntaxes that are rejected include, but are\n    /// not necessarily limited to, `(?=re)`, `(?!re)`, `(?<=re)` and\n    /// `(?<!re)`. Note that all of these syntaxes are otherwise invalid; this\n    /// error is used to improve the user experience.\n    UnsupportedLookAround,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Flag":["/// A single flag.\npub enum Flag {\n    /// `i`\n    CaseInsensitive,\n    /// `m`\n    MultiLine,\n    /// `s`\n    DotMatchesNewLine,\n    /// `U`\n    SwapGreed,\n    /// `u`\n    Unicode,\n    /// `R`\n    CRLF,\n    /// `x`\n    IgnoreWhitespace,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Flags":["/// A group of flags.\n///\n/// This corresponds only to the sequence of flags themselves, e.g., `is-u`.\npub struct Flags {\n    /// The span of this group of flags.\n    pub span: Span,\n    /// A sequence of flag items. Each item is either a flag or a negation\n    /// operator.\n    pub items: Vec<FlagsItem>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Flags::add_item":["/// Add the given item to this sequence of flags.\n///\n/// If the item was added successfully, then `None` is returned. If the\n/// given item is a duplicate, then `Some(i)` is returned, where\n/// `items[i].kind == item.kind`.\npub fn add_item(&mut self, item: FlagsItem) -> Option<usize>{\n        for (i, x) in self.items.iter().enumerate() {\n            if x.kind == item.kind {\n                return Some(i);\n            }\n        }\n        self.items.push(item);\n        None\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Flags::flag_state":["/// Returns the state of the given flag in this set.\n///\n/// If the given flag is in the set but is negated, then `Some(false)` is\n/// returned.\n///\n/// If the given flag is in the set and is not negated, then `Some(true)`\n/// is returned.\n///\n/// Otherwise, `None` is returned.\npub fn flag_state(&self, flag: Flag) -> Option<bool>{\n        let mut negated = false;\n        for x in &self.items {\n            match x.kind {\n                FlagsItemKind::Negation => {\n                    negated = true;\n                }\n                FlagsItemKind::Flag(ref xflag) if xflag == &flag => {\n                    return Some(!negated);\n                }\n                _ => {}\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::FlagsItem":["/// A single item in a group of flags.\npub struct FlagsItem {\n    /// The span of this item.\n    pub span: Span,\n    /// The kind of this item.\n    pub kind: FlagsItemKind,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::FlagsItemKind":["/// The kind of an item in a group of flags.\npub enum FlagsItemKind {\n    /// A negation operator applied to all subsequent flags in the enclosing\n    /// group.\n    Negation,\n    /// A single flag in a group.\n    Flag(Flag),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::FlagsItemKind::is_negation":["/// Returns true if and only if this item is a negation operator.\npub fn is_negation(&self) -> bool{\n        match *self {\n            FlagsItemKind::Negation => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Group":["/// A grouped regular expression.\n///\n/// This includes both capturing and non-capturing groups. This does **not**\n/// include flag-only groups like `(?is)`, but does contain any group that\n/// contains a sub-expression, e.g., `(a)`, `(?P<name>a)`, `(?:a)` and\n/// `(?is:a)`.\npub struct Group {\n    /// The span of this group.\n    pub span: Span,\n    /// The kind of this group.\n    pub kind: GroupKind,\n    /// The regular expression in this group.\n    pub ast: Box<Ast>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Group::capture_index":["/// Returns the capture index of this group, if this is a capturing group.\n///\n/// This returns a capture index precisely when `is_capturing` is `true`.\npub fn capture_index(&self) -> Option<u32>{\n        match self.kind {\n            GroupKind::CaptureIndex(i) => Some(i),\n            GroupKind::CaptureName { ref name, .. } => Some(name.index),\n            GroupKind::NonCapturing(_) => None,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Group::flags":["/// If this group is non-capturing, then this returns the (possibly empty)\n/// set of flags. Otherwise, `None` is returned.\npub fn flags(&self) -> Option<&Flags>{\n        match self.kind {\n            GroupKind::NonCapturing(ref flags) => Some(flags),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Group::is_capturing":["/// Returns true if and only if this group is capturing.\npub fn is_capturing(&self) -> bool{\n        match self.kind {\n            GroupKind::CaptureIndex(_) | GroupKind::CaptureName { .. } => true,\n            GroupKind::NonCapturing(_) => false,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::GroupKind":["/// The kind of a group.\npub enum GroupKind {\n    /// `(a)`\n    CaptureIndex(u32),\n    /// `(?<name>a)` or `(?P<name>a)`\n    CaptureName {\n        /// True if the `?P<` syntax is used and false if the `?<` syntax is used.\n        starts_with_p: bool,\n        /// The capture name.\n        name: CaptureName,\n    },\n    /// `(?:a)` and `(?i:a)`\n    NonCapturing(Flags),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::HexLiteralKind":["/// The type of a Unicode hex literal.\n///\n/// Note that all variants behave the same when used with brackets. They only\n/// differ when used without brackets in the number of hex digits that must\n/// follow.\npub enum HexLiteralKind {\n    /// A `\\x` prefix. When used without brackets, this form is limited to\n    /// two digits.\n    X,\n    /// A `\\u` prefix. When used without brackets, this form is limited to\n    /// four digits.\n    UnicodeShort,\n    /// A `\\U` prefix. When used without brackets, this form is limited to\n    /// eight digits.\n    UnicodeLong,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::HexLiteralKind::digits":["/// The number of digits that must be used with this literal form when\n/// used without brackets. When used with brackets, there is no\n/// restriction on the number of digits.\npub fn digits(&self) -> u32{\n        match *self {\n            HexLiteralKind::X => 2,\n            HexLiteralKind::UnicodeShort => 4,\n            HexLiteralKind::UnicodeLong => 8,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Literal":["/// A single literal expression.\n///\n/// A literal corresponds to a single Unicode scalar value. Literals may be\n/// represented in their literal form, e.g., `a` or in their escaped form,\n/// e.g., `\\x61`.\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Literal::byte":["/// If this literal was written as a `\\x` hex escape, then this returns\n/// the corresponding byte value. Otherwise, this returns `None`.\npub fn byte(&self) -> Option<u8>{\n        match self.kind {\n            LiteralKind::HexFixed(HexLiteralKind::X) => {\n                u8::try_from(self.c).ok()\n            }\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::LiteralKind":["/// The kind of a single literal expression.\npub enum LiteralKind {\n    /// The literal is written verbatim, e.g., `a` or `☃`.\n    Verbatim,\n    /// The literal is written as an escape because it is otherwise a special\n    /// regex meta character, e.g., `\\*` or `\\[`.\n    Meta,\n    /// The literal is written as an escape despite the fact that the escape is\n    /// unnecessary, e.g., `\\%` or `\\/`.\n    Superfluous,\n    /// The literal is written as an octal escape, e.g., `\\141`.\n    Octal,\n    /// The literal is written as a hex code with a fixed number of digits\n    /// depending on the type of the escape, e.g., `\\x61` or or `\\u0061` or\n    /// `\\U00000061`.\n    HexFixed(HexLiteralKind),\n    /// The literal is written as a hex code with a bracketed number of\n    /// digits. The only restriction is that the bracketed hex code must refer\n    /// to a valid Unicode scalar value.\n    HexBrace(HexLiteralKind),\n    /// The literal is written as a specially recognized escape, e.g., `\\f`\n    /// or `\\n`.\n    Special(SpecialLiteralKind),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Position":["/// A single position in a regular expression.\n///\n/// A position encodes one half of a span, and include the byte offset, line\n/// number and column number.\npub struct Position {\n    /// The absolute offset of this position, starting at `0` from the\n    /// beginning of the regular expression pattern string.\n    pub offset: usize,\n    /// The line number, starting at `1`.\n    pub line: usize,\n    /// The approximate column number, starting at `1`.\n    pub column: usize,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Position::new":["/// Create a new position with the given information.\n///\n/// `offset` is the absolute offset of the position, starting at `0` from\n/// the beginning of the regular expression pattern string.\n///\n/// `line` is the line number, starting at `1`.\n///\n/// `column` is the approximate column number, starting at `1`.\npub fn new(offset: usize, line: usize, column: usize) -> Position{\n        Position { offset, line, column }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Repetition":["/// A repetition operation applied to a regular expression.\npub struct Repetition {\n    /// The span of this operation.\n    pub span: Span,\n    /// The actual operation.\n    pub op: RepetitionOp,\n    /// Whether this operation was applied greedily or not.\n    pub greedy: bool,\n    /// The regular expression under repetition.\n    pub ast: Box<Ast>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::RepetitionKind":["/// The kind of a repetition operator.\npub enum RepetitionKind {\n    /// `?`\n    ZeroOrOne,\n    /// `*`\n    ZeroOrMore,\n    /// `+`\n    OneOrMore,\n    /// `{m,n}`\n    Range(RepetitionRange),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::RepetitionOp":["/// The repetition operator itself.\npub struct RepetitionOp {\n    /// The span of this operator. This includes things like `+`, `*?` and\n    /// `{m,n}`.\n    pub span: Span,\n    /// The type of operation.\n    pub kind: RepetitionKind,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::RepetitionRange":["/// A range repetition operator.\npub enum RepetitionRange {\n    /// `{m}`\n    Exactly(u32),\n    /// `{m,}`\n    AtLeast(u32),\n    /// `{m,n}`\n    Bounded(u32, u32),\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::RepetitionRange::is_valid":["/// Returns true if and only if this repetition range is valid.\n///\n/// The only case where a repetition range is invalid is if it is bounded\n/// and its start is greater than its end.\npub fn is_valid(&self) -> bool{\n        match *self {\n            RepetitionRange::Bounded(s, e) if s > e => false,\n            _ => true,\n        }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::SetFlags":["/// A group of flags that is not applied to a particular regular expression.\npub struct SetFlags {\n    /// The span of these flags, including the grouping parentheses.\n    pub span: Span,\n    /// The actual sequence of flags.\n    pub flags: Flags,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span":["/// Span represents the position information of a single AST item.\n///\n/// All span positions are absolute byte offsets that can be used on the\n/// original regular expression that was parsed.\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::is_empty":["/// Returns true if and only if this span is empty. That is, it points to\n/// a single position in the concrete syntax of a regular expression.\npub fn is_empty(&self) -> bool{\n        self.start.offset == self.end.offset\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::is_one_line":["/// Returns true if and only if this span occurs on a single line.\npub fn is_one_line(&self) -> bool{\n        self.start.line == self.end.line\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::new":["/// Create a new span with the given positions.\npub fn new(start: Position, end: Position) -> Span{\n        Span { start, end }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::splat":["/// Create a new span using the given position as the start and end.\npub fn splat(pos: Position) -> Span{\n        Span::new(pos, pos)\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::with_end":["/// Create a new span by replacing the ending the position with the one\n/// given.\npub fn with_end(self, pos: Position) -> Span{\n        Span { end: pos, ..self }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::Span::with_start":["/// Create a new span by replacing the starting the position with the one\n/// given.\npub fn with_start(self, pos: Position) -> Span{\n        Span { start: pos, ..self }\n    }","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::SpecialLiteralKind":["/// The type of a special literal.\n///\n/// A special literal is a special escape sequence recognized by the regex\n/// parser, e.g., `\\f` or `\\n`.\npub enum SpecialLiteralKind {\n    /// Bell, spelled `\\a` (`\\x07`).\n    Bell,\n    /// Form feed, spelled `\\f` (`\\x0C`).\n    FormFeed,\n    /// Tab, spelled `\\t` (`\\x09`).\n    Tab,\n    /// Line feed, spelled `\\n` (`\\x0A`).\n    LineFeed,\n    /// Carriage return, spelled `\\r` (`\\x0D`).\n    CarriageReturn,\n    /// Vertical tab, spelled `\\v` (`\\x0B`).\n    VerticalTab,\n    /// Space, spelled `\\ ` (`\\x20`). Note that this can only appear when\n    /// parsing in verbose mode.\n    Space,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::WithComments":["/// An abstract syntax tree for a singular expression along with comments\n/// found.\n///\n/// Comments are not stored in the tree itself to avoid complexity. Each\n/// comment contains a span of precisely where it occurred in the original\n/// regular expression.\npub struct WithComments {\n    /// The actual ast.\n    pub ast: Ast,\n    /// All comments found in the original regular expression.\n    pub comments: Vec<Comment>,\n}","Real(LocalPath(\"src/ast/mod.rs\"))"],"ast::parse::ClassState":["/// ClassState represents a single stack frame while parsing character classes.\n/// Each frame records the state up to an intersection, difference, symmetric\n/// difference or nested class.\n///\n/// Note that a parser's character class stack is only non-empty when parsing\n/// a character class. In all other cases, it is empty.\nenum ClassState {\n    /// This state is pushed whenever an opening bracket is found.\n    Open {\n        /// The union of class items immediately preceding this class.\n        union: ast::ClassSetUnion,\n        /// The class that has been opened. Typically this just corresponds\n        /// to the `[`, but it can also include `[^` since `^` indicates\n        /// negation of the class.\n        set: ast::ClassBracketed,\n    },\n    /// This state is pushed when a operator is seen. When popped, the stored\n    /// set becomes the left hand side of the operator.\n    Op {\n        /// The type of the operation, i.e., &&, -- or ~~.\n        kind: ast::ClassSetBinaryOpKind,\n        /// The left-hand side of the operator.\n        lhs: ast::ClassSet,\n    },\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::GroupState":["/// GroupState represents a single stack frame while parsing nested groups\n/// and alternations. Each frame records the state up to an opening parenthesis\n/// or a alternating bracket `|`.\nenum GroupState {\n    /// This state is pushed whenever an opening group is found.\n    Group {\n        /// The concatenation immediately preceding the opening group.\n        concat: ast::Concat,\n        /// The group that has been opened. Its sub-AST is always empty.\n        group: ast::Group,\n        /// Whether this group has the `x` flag enabled or not.\n        ignore_whitespace: bool,\n    },\n    /// This state is pushed whenever a new alternation branch is found. If\n    /// an alternation branch is found and this state is at the top of the\n    /// stack, then this state should be modified to include the new\n    /// alternation.\n    Alternation(ast::Alternation),\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter":["/// A type that traverses a fully parsed Ast and checks whether its depth\n/// exceeds the specified nesting limit. If it does, then an error is returned.\nstruct NestLimiter<'p, 's, P> {\n    /// The parser that is checking the nest limit.\n    p: &'p ParserI<'s, P>,\n    /// The current depth while walking an Ast.\n    depth: u32,\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter::<'p, 's, P>::check":["#[inline(never)]\nfn check(self, ast: &Ast) -> Result<()>{\n        ast::visit(ast, self)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":["fn decrement_depth(&mut self){\n        // Assuming the correctness of the visitor, this should never drop\n        // below 0.\n        self.depth = self.depth.checked_sub(1).unwrap();\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":["fn increment_depth(&mut self, span: &Span) -> Result<()>{\n        let new = self.depth.checked_add(1).ok_or_else(|| {\n            self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(u32::MAX),\n            )\n        })?;\n        let limit = self.p.parser().nest_limit;\n        if new > limit {\n            return Err(self.p.error(\n                span.clone(),\n                ast::ErrorKind::NestLimitExceeded(limit),\n            ));\n        }\n        self.depth = new;\n        Ok(())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::NestLimiter::<'p, 's, P>::new":["fn new(p: &'p ParserI<'s, P>) -> NestLimiter<'p, 's, P>{\n        NestLimiter { p, depth: 0 }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser":["/// A regular expression parser.\n///\n/// This parses a string representation of a regular expression into an\n/// abstract syntax tree. The size of the tree is proportional to the length\n/// of the regular expression pattern.\n///\n/// A `Parser` can be configured in more detail via a [`ParserBuilder`].\npub struct Parser {\n    /// The current position of the parser.\n    pos: Cell<Position>,\n    /// The current capture index.\n    capture_index: Cell<u32>,\n    /// The maximum number of open parens/brackets allowed. If the parser\n    /// exceeds this number, then an error is returned.\n    nest_limit: u32,\n    /// Whether to support octal syntax or not. When `false`, the parser will\n    /// return an error helpfully pointing out that backreferences are not\n    /// supported.\n    octal: bool,\n    /// The initial setting for `ignore_whitespace` as provided by\n    /// `ParserBuilder`. It is used when resetting the parser's state.\n    initial_ignore_whitespace: bool,\n    /// Whether whitespace should be ignored. When enabled, comments are\n    /// also permitted.\n    ignore_whitespace: Cell<bool>,\n    /// A list of comments, in order of appearance.\n    comments: RefCell<Vec<ast::Comment>>,\n    /// A stack of grouped sub-expressions, including alternations.\n    stack_group: RefCell<Vec<GroupState>>,\n    /// A stack of nested character classes. This is only non-empty when\n    /// parsing a class.\n    stack_class: RefCell<Vec<ClassState>>,\n    /// A sorted sequence of capture names. This is used to detect duplicate\n    /// capture names and report an error if one is detected.\n    capture_names: RefCell<Vec<ast::CaptureName>>,\n    /// A scratch buffer used in various places. Mostly this is used to\n    /// accumulate relevant characters from parts of a pattern.\n    scratch: RefCell<String>,\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser::new":["/// Create a new parser with a default configuration.\n///\n/// The parser can be run with either the `parse` or `parse_with_comments`\n/// methods. The parse methods return an abstract syntax tree.\n///\n/// To set configuration options on the parser, use [`ParserBuilder`].\npub fn new() -> Parser{\n        ParserBuilder::new().build()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser::parse":["/// Parse the regular expression into an abstract syntax tree.\npub fn parse(&mut self, pattern: &str) -> Result<Ast>{\n        ParserI::new(self, pattern).parse()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser::parse_with_comments":["/// Parse the regular expression and return an abstract syntax tree with\n/// all of the comments found in the pattern.\npub fn parse_with_comments(\n        &mut self,\n        pattern: &str,\n    ) -> Result<ast::WithComments>{\n        ParserI::new(self, pattern).parse_with_comments()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Parser::reset":["/// Reset the internal state of a parser.\n///\n/// This is called at the beginning of every parse. This prevents the\n/// parser from running with inconsistent state (say, if a previous\n/// invocation returned an error and the parser is reused).\nfn reset(&self){\n        // These settings should be in line with the construction\n        // in `ParserBuilder::build`.\n        self.pos.set(Position { offset: 0, line: 1, column: 1 });\n        self.ignore_whitespace.set(self.initial_ignore_whitespace);\n        self.comments.borrow_mut().clear();\n        self.stack_group.borrow_mut().clear();\n        self.stack_class.borrow_mut().clear();\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder":["/// A builder for a regular expression parser.\n///\n/// This builder permits modifying configuration options for the parser.\npub struct ParserBuilder {\n    ignore_whitespace: bool,\n    nest_limit: u32,\n    octal: bool,\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::build":["/// Build a parser from this configuration with the given pattern.\npub fn build(&self) -> Parser{\n        Parser {\n            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),\n            capture_index: Cell::new(0),\n            nest_limit: self.nest_limit,\n            octal: self.octal,\n            initial_ignore_whitespace: self.ignore_whitespace,\n            ignore_whitespace: Cell::new(self.ignore_whitespace),\n            comments: RefCell::new(vec![]),\n            stack_group: RefCell::new(vec![]),\n            stack_class: RefCell::new(vec![]),\n            capture_names: RefCell::new(vec![]),\n            scratch: RefCell::new(String::new()),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::ignore_whitespace":["/// Enable verbose mode in the regular expression.\n///\n/// When enabled, verbose mode permits insignificant whitespace in many\n/// places in the regular expression, as well as comments. Comments are\n/// started using `#` and continue until the end of the line.\n///\n/// By default, this is disabled. It may be selectively enabled in the\n/// regular expression by using the `x` flag regardless of this setting.\npub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.ignore_whitespace = yes;\n        self\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::nest_limit":["/// Set the nesting limit for this parser.\n///\n/// The nesting limit controls how deep the abstract syntax tree is allowed\n/// to be. If the AST exceeds the given limit (e.g., with too many nested\n/// groups), then an error is returned by the parser.\n///\n/// The purpose of this limit is to act as a heuristic to prevent stack\n/// overflow for consumers that do structural induction on an `Ast` using\n/// explicit recursion. While this crate never does this (instead using\n/// constant stack space and moving the call stack to the heap), other\n/// crates may.\n///\n/// This limit is not checked until the entire AST is parsed. Therefore,\n/// if callers want to put a limit on the amount of heap space used, then\n/// they should impose a limit on the length, in bytes, of the concrete\n/// pattern string. In particular, this is viable since this parser\n/// implementation will limit itself to heap space proportional to the\n/// length of the pattern string.\n///\n/// Note that a nest limit of `0` will return a nest limit error for most\n/// patterns but not all. For example, a nest limit of `0` permits `a` but\n/// not `ab`, since `ab` requires a concatenation, which results in a nest\n/// depth of `1`. In general, a nest limit is not something that manifests\n/// in an obvious way in the concrete syntax, therefore, it should not be\n/// used in a granular way.\npub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder{\n        self.nest_limit = limit;\n        self\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::new":["/// Create a new parser builder with a default configuration.\npub fn new() -> ParserBuilder{\n        ParserBuilder {\n            ignore_whitespace: false,\n            nest_limit: 250,\n            octal: false,\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserBuilder::octal":["/// Whether to support octal syntax or not.\n///\n/// Octal syntax is a little-known way of uttering Unicode codepoints in\n/// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n/// `\\141` are all equivalent regular expressions, where the last example\n/// shows octal syntax.\n///\n/// While supporting octal syntax isn't in and of itself a problem, it does\n/// make good error messages harder. That is, in PCRE based regex engines,\n/// syntax like `\\0` invokes a backreference, which is explicitly\n/// unsupported in Rust's regex engine. However, many users expect it to\n/// be supported. Therefore, when octal support is disabled, the error\n/// message will explicitly mention that backreferences aren't supported.\n///\n/// Octal syntax is disabled by default.\npub fn octal(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.octal = yes;\n        self\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI":["/// ParserI is the internal parser implementation.\n///\n/// We use this separate type so that we can carry the provided pattern string\n/// along with us. In particular, a `Parser` internal state is not tied to any\n/// one pattern, but `ParserI` is.\n///\n/// This type also lets us use `ParserI<&Parser>` in production code while\n/// retaining the convenience of `ParserI<Parser>` for tests, which sometimes\n/// work against the internal interface of the parser.\nstruct ParserI<'s, P> {\n    /// The parser state/configuration.\n    parser: P,\n    /// The full regular expression provided by the user.\n    pattern: &'s str,\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::add_capture_name":["/// Adds the given capture name to this parser. If this capture name has\n/// already been used, then an error is returned.\nfn add_capture_name(&self, cap: &ast::CaptureName) -> Result<()>{\n        let mut names = self.parser().capture_names.borrow_mut();\n        match names\n            .binary_search_by_key(&cap.name.as_str(), |c| c.name.as_str())\n        {\n            Err(i) => {\n                names.insert(i, cap.clone());\n                Ok(())\n            }\n            Ok(i) => Err(self.error(\n                cap.span,\n                ast::ErrorKind::GroupNameDuplicate { original: names[i].span },\n            )),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::bump":["/// Bump the parser to the next Unicode scalar value.\n///\n/// If the end of the input has been reached, then `false` is returned.\nfn bump(&self) -> bool{\n        if self.is_eof() {\n            return false;\n        }\n        let Position { mut offset, mut line, mut column } = self.pos();\n        if self.char() == '\\n' {\n            line = line.checked_add(1).unwrap();\n            column = 1;\n        } else {\n            column = column.checked_add(1).unwrap();\n        }\n        offset += self.char().len_utf8();\n        self.parser().pos.set(Position { offset, line, column });\n        self.pattern()[self.offset()..].chars().next().is_some()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::bump_and_bump_space":["/// Bump the parser, and if the `x` flag is enabled, bump through any\n/// subsequent spaces. Return true if and only if the parser is not at\n/// EOF.\nfn bump_and_bump_space(&self) -> bool{\n        if !self.bump() {\n            return false;\n        }\n        self.bump_space();\n        !self.is_eof()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::bump_if":["/// If the substring starting at the current position of the parser has\n/// the given prefix, then bump the parser to the character immediately\n/// following the prefix and return true. Otherwise, don't bump the parser\n/// and return false.\nfn bump_if(&self, prefix: &str) -> bool{\n        if self.pattern()[self.offset()..].starts_with(prefix) {\n            for _ in 0..prefix.chars().count() {\n                self.bump();\n            }\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::bump_space":["/// If the `x` flag is enabled (i.e., whitespace insensitivity with\n/// comments), then this will advance the parser through all whitespace\n/// and comments to the next non-whitespace non-comment byte.\n///\n/// If the `x` flag is disabled, then this is a no-op.\n///\n/// This should be used selectively throughout the parser where\n/// arbitrary whitespace is permitted when the `x` flag is enabled. For\n/// example, `{   5  , 6}` is equivalent to `{5,6}`.\nfn bump_space(&self){\n        if !self.ignore_whitespace() {\n            return;\n        }\n        while !self.is_eof() {\n            if self.char().is_whitespace() {\n                self.bump();\n            } else if self.char() == '#' {\n                let start = self.pos();\n                let mut comment_text = String::new();\n                self.bump();\n                while !self.is_eof() {\n                    let c = self.char();\n                    self.bump();\n                    if c == '\\n' {\n                        break;\n                    }\n                    comment_text.push(c);\n                }\n                let comment = ast::Comment {\n                    span: Span::new(start, self.pos()),\n                    comment: comment_text,\n                };\n                self.parser().comments.borrow_mut().push(comment);\n            } else {\n                break;\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::char":["/// Return the character at the current position of the parser.\n///\n/// This panics if the current position does not point to a valid char.\nfn char(&self) -> char{\n        self.char_at(self.offset())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::char_at":["/// Return the character at the given position.\n///\n/// This panics if the given position does not point to a valid char.\nfn char_at(&self, i: usize) -> char{\n        self.pattern()[i..]\n            .chars()\n            .next()\n            .unwrap_or_else(|| panic!(\"expected char at offset {}\", i))\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::column":["/// Return the current column of the parser.\n///\n/// The column number starts at `1` and is reset whenever a `\\n` is seen.\nfn column(&self) -> usize{\n        self.parser().pos.get().column\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::error":["/// Create a new error with the given span and error type.\nfn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error{\n        ast::Error { kind, pattern: self.pattern().to_string(), span }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::ignore_whitespace":["/// Return whether the parser should ignore whitespace or not.\nfn ignore_whitespace(&self) -> bool{\n        self.parser().ignore_whitespace.get()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::is_eof":["/// Returns true if the next call to `bump` would return false.\nfn is_eof(&self) -> bool{\n        self.offset() == self.pattern().len()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":["/// Returns true if and only if the parser is positioned at a look-around\n/// prefix. The conditions under which this returns true must always\n/// correspond to a regular expression that would otherwise be consider\n/// invalid.\n///\n/// This should only be called immediately after parsing the opening of\n/// a group or a set of flags.\nfn is_lookaround_prefix(&self) -> bool{\n        self.bump_if(\"?=\")\n            || self.bump_if(\"?!\")\n            || self.bump_if(\"?<=\")\n            || self.bump_if(\"?<!\")\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::line":["/// Return the current line number of the parser.\n///\n/// The line number starts at `1`.\nfn line(&self) -> usize{\n        self.parser().pos.get().line\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":["/// Attempt to parse an ASCII character class, e.g., `[:alnum:]`.\n///\n/// This assumes the parser is positioned at the opening `[`.\n///\n/// If no valid ASCII character class could be found, then this does not\n/// advance the parser and `None` is returned. Otherwise, the parser is\n/// advanced to the first byte following the closing `]` and the\n/// corresponding ASCII class is returned.\n#[inline(never)]\nfn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii>{\n        // ASCII character classes are interesting from a parsing perspective\n        // because parsing cannot fail with any interesting error. For example,\n        // in order to use an ASCII character class, it must be enclosed in\n        // double brackets, e.g., `[[:alnum:]]`. Alternatively, you might think\n        // of it as \"ASCII character characters have the syntax `[:NAME:]`\n        // which can only appear within character brackets.\" This means that\n        // things like `[[:lower:]A]` are legal constructs.\n        //\n        // However, if one types an incorrect ASCII character class, e.g.,\n        // `[[:loower:]]`, then we treat that as a normal nested character\n        // class containing the characters `:elorw`. One might argue that we\n        // should return an error instead since the repeated colons give away\n        // the intent to write an ASCII class. But what if the user typed\n        // `[[:lower]]` instead? How can we tell that was intended to be an\n        // ASCII class and not just a normal nested class?\n        //\n        // Reasonable people can probably disagree over this, but for better\n        // or worse, we implement semantics that never fails at the expense\n        // of better failure modes.\n        assert_eq!(self.char(), '[');\n        // If parsing fails, then we back up the parser to this starting point.\n        let start = self.pos();\n        let mut negated = false;\n        if !self.bump() || self.char() != ':' {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if !self.bump() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        if self.char() == '^' {\n            negated = true;\n            if !self.bump() {\n                self.parser().pos.set(start);\n                return None;\n            }\n        }\n        let name_start = self.offset();\n        while self.char() != ':' && self.bump() {}\n        if self.is_eof() {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let name = &self.pattern()[name_start..self.offset()];\n        if !self.bump_if(\":]\") {\n            self.parser().pos.set(start);\n            return None;\n        }\n        let kind = match ast::ClassAsciiKind::from_name(name) {\n            Some(kind) => kind,\n            None => {\n                self.parser().pos.set(start);\n                return None;\n            }\n        };\n        Some(ast::ClassAscii {\n            span: Span::new(start, self.pos()),\n            kind,\n            negated,\n        })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::new":["/// Build an internal parser from a parser configuration and a pattern.\nfn new(parser: P, pattern: &'s str) -> ParserI<'s, P>{\n        ParserI { parser, pattern }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::next_capture_index":["/// Return the next capturing index. Each subsequent call increments the\n/// internal index.\n///\n/// The span given should correspond to the location of the opening\n/// parenthesis.\n///\n/// If the capture limit is exceeded, then an error is returned.\nfn next_capture_index(&self, span: Span) -> Result<u32>{\n        let current = self.parser().capture_index.get();\n        let i = current.checked_add(1).ok_or_else(|| {\n            self.error(span, ast::ErrorKind::CaptureLimitExceeded)\n        })?;\n        self.parser().capture_index.set(i);\n        Ok(i)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::offset":["/// Return the current offset of the parser.\n///\n/// The offset starts at `0` from the beginning of the regular expression\n/// pattern string.\nfn offset(&self) -> usize{\n        self.parser().pos.get().offset\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse":["/// Parse the regular expression into an abstract syntax tree.\nfn parse(&self) -> Result<Ast>{\n        self.parse_with_comments().map(|astc| astc.ast)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_capture_name":["/// Parses a capture group name. Assumes that the parser is positioned at\n/// the first character in the name following the opening `<` (and may\n/// possibly be EOF). This advances the parser to the first character\n/// following the closing `>`.\n///\n/// The caller must provide the capture index of the group for this name.\n#[inline(never)]\nfn parse_capture_name(\n        &self,\n        capture_index: u32,\n    ) -> Result<ast::CaptureName>{\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        let start = self.pos();\n        loop {\n            if self.char() == '>' {\n                break;\n            }\n            if !is_capture_char(self.char(), self.pos() == start) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::GroupNameInvalid,\n                ));\n            }\n            if !self.bump() {\n                break;\n            }\n        }\n        let end = self.pos();\n        if self.is_eof() {\n            return Err(self\n                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));\n        }\n        assert_eq!(self.char(), '>');\n        self.bump();\n        let name = &self.pattern()[start.offset..end.offset];\n        if name.is_empty() {\n            return Err(self.error(\n                Span::new(start, start),\n                ast::ErrorKind::GroupNameEmpty,\n            ));\n        }\n        let capname = ast::CaptureName {\n            span: Span::new(start, end),\n            name: name.to_string(),\n            index: capture_index,\n        };\n        self.add_capture_name(&capname)?;\n        Ok(capname)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_counted_repetition":["/// Parses a counted repetition operation. A counted repetition operator\n/// corresponds to the {m,n} syntax, and does not include the ?, * or +\n/// operators.\n///\n/// This assumes that the parser is currently positioned at the opening `{`\n/// and advances the parser to the first character after the operator.\n/// (Note that the operator may include a single additional `?`, which\n/// makes the operator ungreedy.)\n///\n/// The caller should include the concatenation that is being built. The\n/// concatenation returned includes the repetition operator applied to the\n/// last expression in the given concatenation.\n#[inline(never)]\nfn parse_counted_repetition(\n        &self,\n        mut concat: ast::Concat,\n    ) -> Result<ast::Concat>{\n        assert!(self.char() == '{');\n        let start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        let count_start = specialize_err(\n            self.parse_decimal(),\n            ast::ErrorKind::DecimalEmpty,\n            ast::ErrorKind::RepetitionCountDecimalEmpty,\n        )?;\n        let mut range = ast::RepetitionRange::Exactly(count_start);\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n        if self.char() == ',' {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::RepetitionCountUnclosed,\n                ));\n            }\n            if self.char() != '}' {\n                let count_end = specialize_err(\n                    self.parse_decimal(),\n                    ast::ErrorKind::DecimalEmpty,\n                    ast::ErrorKind::RepetitionCountDecimalEmpty,\n                )?;\n                range = ast::RepetitionRange::Bounded(count_start, count_end);\n            } else {\n                range = ast::RepetitionRange::AtLeast(count_start);\n            }\n        }\n        if self.is_eof() || self.char() != '}' {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::RepetitionCountUnclosed,\n            ));\n        }\n\n        let mut greedy = true;\n        if self.bump_and_bump_space() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n\n        let op_span = Span::new(start, self.pos());\n        if !range.is_valid() {\n            return Err(\n                self.error(op_span, ast::ErrorKind::RepetitionCountInvalid)\n            );\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: op_span,\n                kind: ast::RepetitionKind::Range(range),\n            },\n            greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_decimal":["/// Parse a decimal number into a u32 while trimming leading and trailing\n/// whitespace.\n///\n/// This expects the parser to be positioned at the first position where\n/// a decimal digit could occur. This will advance the parser to the byte\n/// immediately following the last contiguous decimal digit.\n///\n/// If no decimal digit could be found or if there was a problem parsing\n/// the complete set of digits into a u32, then an error is returned.\nfn parse_decimal(&self) -> Result<u32>{\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump();\n        }\n        let start = self.pos();\n        while !self.is_eof() && '0' <= self.char() && self.char() <= '9' {\n            scratch.push(self.char());\n            self.bump_and_bump_space();\n        }\n        let span = Span::new(start, self.pos());\n        while !self.is_eof() && self.char().is_whitespace() {\n            self.bump_and_bump_space();\n        }\n        let digits = scratch.as_str();\n        if digits.is_empty() {\n            return Err(self.error(span, ast::ErrorKind::DecimalEmpty));\n        }\n        match u32::from_str_radix(digits, 10).ok() {\n            Some(n) => Ok(n),\n            None => Err(self.error(span, ast::ErrorKind::DecimalInvalid)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_escape":["/// Parse an escape sequence as a primitive AST.\n///\n/// This assumes the parser is positioned at the start of the escape\n/// sequence, i.e., `\\`. It advances the parser to the first position\n/// immediately following the escape sequence.\n#[inline(never)]\nfn parse_escape(&self) -> Result<Primitive>{\n        assert_eq!(self.char(), '\\\\');\n        let start = self.pos();\n        if !self.bump() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let c = self.char();\n        // Put some of the more complicated routines into helpers.\n        match c {\n            '0'..='7' => {\n                if !self.parser().octal {\n                    return Err(self.error(\n                        Span::new(start, self.span_char().end),\n                        ast::ErrorKind::UnsupportedBackreference,\n                    ));\n                }\n                let mut lit = self.parse_octal();\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            '8'..='9' if !self.parser().octal => {\n                return Err(self.error(\n                    Span::new(start, self.span_char().end),\n                    ast::ErrorKind::UnsupportedBackreference,\n                ));\n            }\n            'x' | 'u' | 'U' => {\n                let mut lit = self.parse_hex()?;\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            'p' | 'P' => {\n                let mut cls = self.parse_unicode_class()?;\n                cls.span.start = start;\n                return Ok(Primitive::Unicode(cls));\n            }\n            'd' | 's' | 'w' | 'D' | 'S' | 'W' => {\n                let mut cls = self.parse_perl_class();\n                cls.span.start = start;\n                return Ok(Primitive::Perl(cls));\n            }\n            _ => {}\n        }\n\n        // Handle all of the one letter sequences inline.\n        self.bump();\n        let span = Span::new(start, self.pos());\n        if is_meta_character(c) {\n            return Ok(Primitive::Literal(ast::Literal {\n                span,\n                kind: ast::LiteralKind::Meta,\n                c,\n            }));\n        }\n        if is_escapeable_character(c) {\n            return Ok(Primitive::Literal(ast::Literal {\n                span,\n                kind: ast::LiteralKind::Superfluous,\n                c,\n            }));\n        }\n        let special = |kind, c| {\n            Ok(Primitive::Literal(ast::Literal {\n                span,\n                kind: ast::LiteralKind::Special(kind),\n                c,\n            }))\n        };\n        match c {\n            'a' => special(ast::SpecialLiteralKind::Bell, '\\x07'),\n            'f' => special(ast::SpecialLiteralKind::FormFeed, '\\x0C'),\n            't' => special(ast::SpecialLiteralKind::Tab, '\\t'),\n            'n' => special(ast::SpecialLiteralKind::LineFeed, '\\n'),\n            'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\\r'),\n            'v' => special(ast::SpecialLiteralKind::VerticalTab, '\\x0B'),\n            'A' => Ok(Primitive::Assertion(ast::Assertion {\n                span,\n                kind: ast::AssertionKind::StartText,\n            })),\n            'z' => Ok(Primitive::Assertion(ast::Assertion {\n                span,\n                kind: ast::AssertionKind::EndText,\n            })),\n            'b' => Ok(Primitive::Assertion(ast::Assertion {\n                span,\n                kind: ast::AssertionKind::WordBoundary,\n            })),\n            'B' => Ok(Primitive::Assertion(ast::Assertion {\n                span,\n                kind: ast::AssertionKind::NotWordBoundary,\n            })),\n            _ => Err(self.error(span, ast::ErrorKind::EscapeUnrecognized)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_flag":["/// Parse the current character as a flag. Do not advance the parser.\n///\n/// # Errors\n///\n/// If the flag is not recognized, then an error is returned.\n#[inline(never)]\nfn parse_flag(&self) -> Result<ast::Flag>{\n        match self.char() {\n            'i' => Ok(ast::Flag::CaseInsensitive),\n            'm' => Ok(ast::Flag::MultiLine),\n            's' => Ok(ast::Flag::DotMatchesNewLine),\n            'U' => Ok(ast::Flag::SwapGreed),\n            'u' => Ok(ast::Flag::Unicode),\n            'R' => Ok(ast::Flag::CRLF),\n            'x' => Ok(ast::Flag::IgnoreWhitespace),\n            _ => {\n                Err(self\n                    .error(self.span_char(), ast::ErrorKind::FlagUnrecognized))\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_flags":["/// Parse a sequence of flags starting at the current character.\n///\n/// This advances the parser to the character immediately following the\n/// flags, which is guaranteed to be either `:` or `)`.\n///\n/// # Errors\n///\n/// If any flags are duplicated, then an error is returned.\n///\n/// If the negation operator is used more than once, then an error is\n/// returned.\n///\n/// If no flags could be found or if the negation operation is not followed\n/// by any flags, then an error is returned.\n#[inline(never)]\nfn parse_flags(&self) -> Result<ast::Flags>{\n        let mut flags = ast::Flags { span: self.span(), items: vec![] };\n        let mut last_was_negation = None;\n        while self.char() != ':' && self.char() != ')' {\n            if self.char() == '-' {\n                last_was_negation = Some(self.span_char());\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Negation,\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagRepeatedNegation {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            } else {\n                last_was_negation = None;\n                let item = ast::FlagsItem {\n                    span: self.span_char(),\n                    kind: ast::FlagsItemKind::Flag(self.parse_flag()?),\n                };\n                if let Some(i) = flags.add_item(item) {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::FlagDuplicate {\n                            original: flags.items[i].span,\n                        },\n                    ));\n                }\n            }\n            if !self.bump() {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::FlagUnexpectedEof)\n                );\n            }\n        }\n        if let Some(span) = last_was_negation {\n            return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));\n        }\n        flags.span.end = self.pos();\n        Ok(flags)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_group":["/// Parse a group (which contains a sub-expression) or a set of flags.\n///\n/// If a group was found, then it is returned with an empty AST. If a set\n/// of flags is found, then that set is returned.\n///\n/// The parser should be positioned at the opening parenthesis.\n///\n/// This advances the parser to the character before the start of the\n/// sub-expression (in the case of a group) or to the closing parenthesis\n/// immediately following the set of flags.\n///\n/// # Errors\n///\n/// If flags are given and incorrectly specified, then a corresponding\n/// error is returned.\n///\n/// If a capture name is given and it is incorrectly specified, then a\n/// corresponding error is returned.\n#[inline(never)]\nfn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>>{\n        assert_eq!(self.char(), '(');\n        let open_span = self.span_char();\n        self.bump();\n        self.bump_space();\n        if self.is_lookaround_prefix() {\n            return Err(self.error(\n                Span::new(open_span.start, self.span().end),\n                ast::ErrorKind::UnsupportedLookAround,\n            ));\n        }\n        let inner_span = self.span();\n        let mut starts_with_p = true;\n        if self.bump_if(\"?P<\") || {\n            starts_with_p = false;\n            self.bump_if(\"?<\")\n        } {\n            let capture_index = self.next_capture_index(open_span)?;\n            let name = self.parse_capture_name(capture_index)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureName { starts_with_p, name },\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        } else if self.bump_if(\"?\") {\n            if self.is_eof() {\n                return Err(\n                    self.error(open_span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n            let flags = self.parse_flags()?;\n            let char_end = self.char();\n            self.bump();\n            if char_end == ')' {\n                // We don't allow empty flags, e.g., `(?)`. We instead\n                // interpret it as a repetition operator missing its argument.\n                if flags.items.is_empty() {\n                    return Err(self.error(\n                        inner_span,\n                        ast::ErrorKind::RepetitionMissing,\n                    ));\n                }\n                Ok(Either::Left(ast::SetFlags {\n                    span: Span { end: self.pos(), ..open_span },\n                    flags,\n                }))\n            } else {\n                assert_eq!(char_end, ':');\n                Ok(Either::Right(ast::Group {\n                    span: open_span,\n                    kind: ast::GroupKind::NonCapturing(flags),\n                    ast: Box::new(Ast::Empty(self.span())),\n                }))\n            }\n        } else {\n            let capture_index = self.next_capture_index(open_span)?;\n            Ok(Either::Right(ast::Group {\n                span: open_span,\n                kind: ast::GroupKind::CaptureIndex(capture_index),\n                ast: Box::new(Ast::Empty(self.span())),\n            }))\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_hex":["/// Parse a hex representation of a Unicode codepoint. This handles both\n/// hex notations, i.e., `\\xFF` and `\\x{FFFF}`. This expects the parser to\n/// be positioned at the `x`, `u` or `U` prefix. The parser is advanced to\n/// the first character immediately following the hexadecimal literal.\n#[inline(never)]\nfn parse_hex(&self) -> Result<ast::Literal>{\n        assert!(\n            self.char() == 'x' || self.char() == 'u' || self.char() == 'U'\n        );\n\n        let hex_kind = match self.char() {\n            'x' => ast::HexLiteralKind::X,\n            'u' => ast::HexLiteralKind::UnicodeShort,\n            _ => ast::HexLiteralKind::UnicodeLong,\n        };\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        if self.char() == '{' {\n            self.parse_hex_brace(hex_kind)\n        } else {\n            self.parse_hex_digits(hex_kind)\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_hex_brace":["/// Parse a hex representation of any Unicode scalar value. This expects\n/// the parser to be positioned at the opening brace `{` and will advance\n/// the parser to the first character following the closing brace `}`.\n#[inline(never)]\nfn parse_hex_brace(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal>{\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let brace_pos = self.pos();\n        let start = self.span_char().end;\n        while self.bump_and_bump_space() && self.char() != '}' {\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        if self.is_eof() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeUnexpectedEof,\n            ));\n        }\n        let end = self.pos();\n        let hex = scratch.as_str();\n        assert_eq!(self.char(), '}');\n        self.bump_and_bump_space();\n\n        if hex.is_empty() {\n            return Err(self.error(\n                Span::new(brace_pos, self.pos()),\n                ast::ErrorKind::EscapeHexEmpty,\n            ));\n        }\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, self.pos()),\n                kind: ast::LiteralKind::HexBrace(kind),\n                c,\n            }),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_hex_digits":["/// Parse an N-digit hex representation of a Unicode codepoint. This\n/// expects the parser to be positioned at the first digit and will advance\n/// the parser to the first character immediately following the escape\n/// sequence.\n///\n/// The number of digits given must be 2 (for `\\xNN`), 4 (for `\\uNNNN`)\n/// or 8 (for `\\UNNNNNNNN`).\n#[inline(never)]\nfn parse_hex_digits(\n        &self,\n        kind: ast::HexLiteralKind,\n    ) -> Result<ast::Literal>{\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let start = self.pos();\n        for i in 0..kind.digits() {\n            if i > 0 && !self.bump_and_bump_space() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            if !is_hex(self.char()) {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::EscapeHexInvalidDigit,\n                ));\n            }\n            scratch.push(self.char());\n        }\n        // The final bump just moves the parser past the literal, which may\n        // be EOF.\n        self.bump_and_bump_space();\n        let end = self.pos();\n        let hex = scratch.as_str();\n        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {\n            None => Err(self.error(\n                Span::new(start, end),\n                ast::ErrorKind::EscapeHexInvalid,\n            )),\n            Some(c) => Ok(ast::Literal {\n                span: Span::new(start, end),\n                kind: ast::LiteralKind::HexFixed(kind),\n                c,\n            }),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_octal":["/// Parse an octal representation of a Unicode codepoint up to 3 digits\n/// long. This expects the parser to be positioned at the first octal\n/// digit and advances the parser to the first character immediately\n/// following the octal number. This also assumes that parsing octal\n/// escapes is enabled.\n///\n/// Assuming the preconditions are met, this routine can never fail.\n#[inline(never)]\nfn parse_octal(&self) -> ast::Literal{\n        assert!(self.parser().octal);\n        assert!('0' <= self.char() && self.char() <= '7');\n        let start = self.pos();\n        // Parse up to two more digits.\n        while self.bump()\n            && '0' <= self.char()\n            && self.char() <= '7'\n            && self.pos().offset - start.offset <= 2\n        {}\n        let end = self.pos();\n        let octal = &self.pattern()[start.offset..end.offset];\n        // Parsing the octal should never fail since the above guarantees a\n        // valid number.\n        let codepoint =\n            u32::from_str_radix(octal, 8).expect(\"valid octal number\");\n        // The max value for 3 digit octal is 0777 = 511 and [0, 511] has no\n        // invalid Unicode scalar values.\n        let c = char::from_u32(codepoint).expect(\"Unicode scalar value\");\n        ast::Literal {\n            span: Span::new(start, end),\n            kind: ast::LiteralKind::Octal,\n            c,\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_perl_class":["/// Parse a Perl character class, e.g., `\\d` or `\\W`. This assumes the\n/// parser is currently at a valid character class name and will be\n/// advanced to the character immediately following the class.\n#[inline(never)]\nfn parse_perl_class(&self) -> ast::ClassPerl{\n        let c = self.char();\n        let span = self.span_char();\n        self.bump();\n        let (negated, kind) = match c {\n            'd' => (false, ast::ClassPerlKind::Digit),\n            'D' => (true, ast::ClassPerlKind::Digit),\n            's' => (false, ast::ClassPerlKind::Space),\n            'S' => (true, ast::ClassPerlKind::Space),\n            'w' => (false, ast::ClassPerlKind::Word),\n            'W' => (true, ast::ClassPerlKind::Word),\n            c => panic!(\"expected valid Perl class but got '{}'\", c),\n        };\n        ast::ClassPerl { span, kind, negated }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_primitive":["/// Parse a primitive AST. e.g., A literal, non-set character class or\n/// assertion.\n///\n/// This assumes that the parser expects a primitive at the current\n/// location. i.e., All other non-primitive cases have been handled.\n/// For example, if the parser's position is at `|`, then `|` will be\n/// treated as a literal (e.g., inside a character class).\n///\n/// This advances the parser to the first character immediately following\n/// the primitive.\nfn parse_primitive(&self) -> Result<Primitive>{\n        match self.char() {\n            '\\\\' => self.parse_escape(),\n            '.' => {\n                let ast = Primitive::Dot(self.span_char());\n                self.bump();\n                Ok(ast)\n            }\n            '^' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::StartLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            '$' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::EndLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            c => {\n                let ast = Primitive::Literal(ast::Literal {\n                    span: self.span_char(),\n                    kind: ast::LiteralKind::Verbatim,\n                    c,\n                });\n                self.bump();\n                Ok(ast)\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_set_class":["/// Parse a standard character class consisting primarily of characters or\n/// character ranges, but can also contain nested character classes of\n/// any type (sans `.`).\n///\n/// This assumes the parser is positioned at the opening `[`. If parsing\n/// is successful, then the parser is advanced to the position immediately\n/// following the closing `]`.\n#[inline(never)]\nfn parse_set_class(&self) -> Result<ast::Class>{\n        assert_eq!(self.char(), '[');\n\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                return Err(self.unclosed_class_error());\n            }\n            match self.char() {\n                '[' => {\n                    // If we've already parsed the opening bracket, then\n                    // attempt to treat this as the beginning of an ASCII\n                    // class. If ASCII class parsing fails, then the parser\n                    // backs up to `[`.\n                    if !self.parser().stack_class.borrow().is_empty() {\n                        if let Some(cls) = self.maybe_parse_ascii_class() {\n                            union.push(ast::ClassSetItem::Ascii(cls));\n                            continue;\n                        }\n                    }\n                    union = self.push_class_open(union)?;\n                }\n                ']' => match self.pop_class(union)? {\n                    Either::Left(nested_union) => {\n                        union = nested_union;\n                    }\n                    Either::Right(class) => return Ok(class),\n                },\n                '&' if self.peek() == Some('&') => {\n                    assert!(self.bump_if(\"&&\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Intersection,\n                        union,\n                    );\n                }\n                '-' if self.peek() == Some('-') => {\n                    assert!(self.bump_if(\"--\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::Difference,\n                        union,\n                    );\n                }\n                '~' if self.peek() == Some('~') => {\n                    assert!(self.bump_if(\"~~\"));\n                    union = self.push_class_op(\n                        ast::ClassSetBinaryOpKind::SymmetricDifference,\n                        union,\n                    );\n                }\n                _ => {\n                    union.push(self.parse_set_class_range()?);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_set_class_item":["/// Parse a single item in a character class as a primitive, where the\n/// primitive either consists of a verbatim literal or a single escape\n/// sequence.\n///\n/// This assumes the parser is positioned at the beginning of a primitive,\n/// and advances the parser to the first position after the primitive if\n/// successful.\n///\n/// Note that it is the caller's responsibility to report an error if an\n/// illegal primitive was parsed.\n#[inline(never)]\nfn parse_set_class_item(&self) -> Result<Primitive>{\n        if self.char() == '\\\\' {\n            self.parse_escape()\n        } else {\n            let x = Primitive::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: self.char(),\n            });\n            self.bump();\n            Ok(x)\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_set_class_open":["/// Parses the opening of a character class set. This includes the opening\n/// bracket along with `^` if present to indicate negation. This also\n/// starts parsing the opening set of unioned items if applicable, since\n/// there are special rules applied to certain characters in the opening\n/// of a character class. For example, `[^]]` is the class of all\n/// characters not equal to `]`. (`]` would need to be escaped in any other\n/// position.) Similarly for `-`.\n///\n/// In all cases, the op inside the returned `ast::ClassBracketed` is an\n/// empty union. This empty union should be replaced with the actual item\n/// when it is popped from the parser's stack.\n///\n/// This assumes the parser is positioned at the opening `[` and advances\n/// the parser to the first non-special byte of the character class.\n///\n/// An error is returned if EOF is found.\n#[inline(never)]\nfn parse_set_class_open(\n        &self,\n    ) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)>{\n        assert_eq!(self.char(), '[');\n        let start = self.pos();\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::ClassUnclosed,\n            ));\n        }\n\n        let negated = if self.char() != '^' {\n            false\n        } else {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n            true\n        };\n        // Accept any number of `-` as literal `-`.\n        let mut union =\n            ast::ClassSetUnion { span: self.span(), items: vec![] };\n        while self.char() == '-' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: '-',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, start),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        // If `]` is the *first* char in a set, then interpret it as a literal\n        // `]`. That is, an empty class is impossible to write.\n        if union.items.is_empty() && self.char() == ']' {\n            union.push(ast::ClassSetItem::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: ']',\n            }));\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n        }\n        let set = ast::ClassBracketed {\n            span: Span::new(start, self.pos()),\n            negated,\n            kind: ast::ClassSet::union(ast::ClassSetUnion {\n                span: Span::new(union.span.start, union.span.start),\n                items: vec![],\n            }),\n        };\n        Ok((set, union))\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_set_class_range":["/// Parse a single primitive item in a character class set. The item to\n/// be parsed can either be one of a simple literal character, a range\n/// between two simple literal characters or a \"primitive\" character\n/// class like \\w or \\p{Greek}.\n///\n/// If an invalid escape is found, or if a character class is found where\n/// a simple literal is expected (e.g., in a range), then an error is\n/// returned.\n#[inline(never)]\nfn parse_set_class_range(&self) -> Result<ast::ClassSetItem>{\n        let prim1 = self.parse_set_class_item()?;\n        self.bump_space();\n        if self.is_eof() {\n            return Err(self.unclosed_class_error());\n        }\n        // If the next char isn't a `-`, then we don't have a range.\n        // There are two exceptions. If the char after a `-` is a `]`, then\n        // `-` is interpreted as a literal `-`. Alternatively, if the char\n        // after a `-` is a `-`, then `--` corresponds to a \"difference\"\n        // operation.\n        if self.char() != '-'\n            || self.peek_space() == Some(']')\n            || self.peek_space() == Some('-')\n        {\n            return prim1.into_class_set_item(self);\n        }\n        // OK, now we're parsing a range, so bump past the `-` and parse the\n        // second half of the range.\n        if !self.bump_and_bump_space() {\n            return Err(self.unclosed_class_error());\n        }\n        let prim2 = self.parse_set_class_item()?;\n        let range = ast::ClassSetRange {\n            span: Span::new(prim1.span().start, prim2.span().end),\n            start: prim1.into_class_literal(self)?,\n            end: prim2.into_class_literal(self)?,\n        };\n        if !range.is_valid() {\n            return Err(\n                self.error(range.span, ast::ErrorKind::ClassRangeInvalid)\n            );\n        }\n        Ok(ast::ClassSetItem::Range(range))\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":["/// Parses an uncounted repetition operation. An uncounted repetition\n/// operator includes ?, * and +, but does not include the {m,n} syntax.\n/// The given `kind` should correspond to the operator observed by the\n/// caller.\n///\n/// This assumes that the parser is currently positioned at the repetition\n/// operator and advances the parser to the first character after the\n/// operator. (Note that the operator may include a single additional `?`,\n/// which makes the operator ungreedy.)\n///\n/// The caller should include the concatenation that is being built. The\n/// concatenation returned includes the repetition operator applied to the\n/// last expression in the given concatenation.\n#[inline(never)]\nfn parse_uncounted_repetition(\n        &self,\n        mut concat: ast::Concat,\n        kind: ast::RepetitionKind,\n    ) -> Result<ast::Concat>{\n        assert!(\n            self.char() == '?' || self.char() == '*' || self.char() == '+'\n        );\n        let op_start = self.pos();\n        let ast = match concat.asts.pop() {\n            Some(ast) => ast,\n            None => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n        };\n        match ast {\n            Ast::Empty(_) | Ast::Flags(_) => {\n                return Err(\n                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)\n                )\n            }\n            _ => {}\n        }\n        let mut greedy = true;\n        if self.bump() && self.char() == '?' {\n            greedy = false;\n            self.bump();\n        }\n        concat.asts.push(Ast::Repetition(ast::Repetition {\n            span: ast.span().with_end(self.pos()),\n            op: ast::RepetitionOp {\n                span: Span::new(op_start, self.pos()),\n                kind,\n            },\n            greedy,\n            ast: Box::new(ast),\n        }));\n        Ok(concat)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_unicode_class":["/// Parse a Unicode class in either the single character notation, `\\pN`\n/// or the multi-character bracketed notation, `\\p{Greek}`. This assumes\n/// the parser is positioned at the `p` (or `P` for negation) and will\n/// advance the parser to the character immediately following the class.\n///\n/// Note that this does not check whether the class name is valid or not.\n#[inline(never)]\nfn parse_unicode_class(&self) -> Result<ast::ClassUnicode>{\n        assert!(self.char() == 'p' || self.char() == 'P');\n\n        let mut scratch = self.parser().scratch.borrow_mut();\n        scratch.clear();\n\n        let negated = self.char() == 'P';\n        if !self.bump_and_bump_space() {\n            return Err(\n                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)\n            );\n        }\n        let (start, kind) = if self.char() == '{' {\n            let start = self.span_char().end;\n            while self.bump_and_bump_space() && self.char() != '}' {\n                scratch.push(self.char());\n            }\n            if self.is_eof() {\n                return Err(self\n                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));\n            }\n            assert_eq!(self.char(), '}');\n            self.bump();\n\n            let name = scratch.as_str();\n            if let Some(i) = name.find(\"!=\") {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::NotEqual,\n                        name: name[..i].to_string(),\n                        value: name[i + 2..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find(':') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Colon,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else if let Some(i) = name.find('=') {\n                (\n                    start,\n                    ast::ClassUnicodeKind::NamedValue {\n                        op: ast::ClassUnicodeOpKind::Equal,\n                        name: name[..i].to_string(),\n                        value: name[i + 1..].to_string(),\n                    },\n                )\n            } else {\n                (start, ast::ClassUnicodeKind::Named(name.to_string()))\n            }\n        } else {\n            let start = self.pos();\n            let c = self.char();\n            if c == '\\\\' {\n                return Err(self.error(\n                    self.span_char(),\n                    ast::ErrorKind::UnicodeClassInvalid,\n                ));\n            }\n            self.bump_and_bump_space();\n            let kind = ast::ClassUnicodeKind::OneLetter(c);\n            (start, kind)\n        };\n        Ok(ast::ClassUnicode {\n            span: Span::new(start, self.pos()),\n            negated,\n            kind,\n        })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parse_with_comments":["/// Parse the regular expression and return an abstract syntax tree with\n/// all of the comments found in the pattern.\nfn parse_with_comments(&self) -> Result<ast::WithComments>{\n        assert_eq!(self.offset(), 0, \"parser can only be used once\");\n        self.parser().reset();\n        let mut concat = ast::Concat { span: self.span(), asts: vec![] };\n        loop {\n            self.bump_space();\n            if self.is_eof() {\n                break;\n            }\n            match self.char() {\n                '(' => concat = self.push_group(concat)?,\n                ')' => concat = self.pop_group(concat)?,\n                '|' => concat = self.push_alternate(concat)?,\n                '[' => {\n                    let class = self.parse_set_class()?;\n                    concat.asts.push(Ast::Class(class));\n                }\n                '?' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrOne,\n                    )?;\n                }\n                '*' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::ZeroOrMore,\n                    )?;\n                }\n                '+' => {\n                    concat = self.parse_uncounted_repetition(\n                        concat,\n                        ast::RepetitionKind::OneOrMore,\n                    )?;\n                }\n                '{' => {\n                    concat = self.parse_counted_repetition(concat)?;\n                }\n                _ => concat.asts.push(self.parse_primitive()?.into_ast()),\n            }\n        }\n        let ast = self.pop_group_end(concat)?;\n        NestLimiter::new(self).check(&ast)?;\n        Ok(ast::WithComments {\n            ast,\n            comments: mem::replace(\n                &mut *self.parser().comments.borrow_mut(),\n                vec![],\n            ),\n        })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::parser":["/// Return a reference to the parser state.\nfn parser(&self) -> &Parser{\n        self.parser.borrow()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pattern":["/// Return a reference to the pattern being parsed.\nfn pattern(&self) -> &str{\n        self.pattern.borrow()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::peek":["/// Peek at the next character in the input without advancing the parser.\n///\n/// If the input has been exhausted, then this returns `None`.\nfn peek(&self) -> Option<char>{\n        if self.is_eof() {\n            return None;\n        }\n        self.pattern()[self.offset() + self.char().len_utf8()..].chars().next()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::peek_space":["/// Like peek, but will ignore spaces when the parser is in whitespace\n/// insensitive mode.\nfn peek_space(&self) -> Option<char>{\n        if !self.ignore_whitespace() {\n            return self.peek();\n        }\n        if self.is_eof() {\n            return None;\n        }\n        let mut start = self.offset() + self.char().len_utf8();\n        let mut in_comment = false;\n        for (i, c) in self.pattern()[start..].char_indices() {\n            if c.is_whitespace() {\n                continue;\n            } else if !in_comment && c == '#' {\n                in_comment = true;\n            } else if in_comment && c == '\\n' {\n                in_comment = false;\n            } else {\n                start += i;\n                break;\n            }\n        }\n        self.pattern()[start..].chars().next()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pop_class":["/// Parse the end of a character class set and pop the character class\n/// parser stack. The union given corresponds to the last union built\n/// before seeing the closing `]`. The union returned corresponds to the\n/// parent character class set with the nested class added to it.\n///\n/// This assumes that the parser is positioned at a `]` and will advance\n/// the parser to the byte immediately following the `]`.\n///\n/// If the stack is empty after popping, then this returns the final\n/// \"top-level\" character class AST (where a \"top-level\" character class\n/// is one that is not nested inside any other character class).\n///\n/// If there is no corresponding opening bracket on the parser's stack,\n/// then an error is returned.\n#[inline(never)]\nfn pop_class(\n        &self,\n        nested_union: ast::ClassSetUnion,\n    ) -> Result<Either<ast::ClassSetUnion, ast::Class>>{\n        assert_eq!(self.char(), ']');\n\n        let item = ast::ClassSet::Item(nested_union.into_item());\n        let prevset = self.pop_class_op(item);\n        let mut stack = self.parser().stack_class.borrow_mut();\n        match stack.pop() {\n            None => {\n                // We can never observe an empty stack:\n                //\n                // 1) We are guaranteed to start with a non-empty stack since\n                //    the character class parser is only initiated when it sees\n                //    a `[`.\n                // 2) If we ever observe an empty stack while popping after\n                //    seeing a `]`, then we signal the character class parser\n                //    to terminate.\n                panic!(\"unexpected empty character class stack\")\n            }\n            Some(ClassState::Op { .. }) => {\n                // This panic is unfortunate, but this case is impossible\n                // since we already popped the Op state if one exists above.\n                // Namely, every push to the class parser stack is guarded by\n                // whether an existing Op is already on the top of the stack.\n                // If it is, the existing Op is modified. That is, the stack\n                // can never have consecutive Op states.\n                panic!(\"unexpected ClassState::Op\")\n            }\n            Some(ClassState::Open { mut union, mut set }) => {\n                self.bump();\n                set.span.end = self.pos();\n                set.kind = prevset;\n                if stack.is_empty() {\n                    Ok(Either::Right(ast::Class::Bracketed(set)))\n                } else {\n                    union.push(ast::ClassSetItem::Bracketed(Box::new(set)));\n                    Ok(Either::Left(union))\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pop_class_op":["/// Pop a character class set from the character class parser stack. If the\n/// top of the stack is just an item (not an operation), then return the\n/// given set unchanged. If the top of the stack is an operation, then the\n/// given set will be used as the rhs of the operation on the top of the\n/// stack. In that case, the binary operation is returned as a set.\n#[inline(never)]\nfn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet{\n        let mut stack = self.parser().stack_class.borrow_mut();\n        let (kind, lhs) = match stack.pop() {\n            Some(ClassState::Op { kind, lhs }) => (kind, lhs),\n            Some(state @ ClassState::Open { .. }) => {\n                stack.push(state);\n                return rhs;\n            }\n            None => unreachable!(),\n        };\n        let span = Span::new(lhs.span().start, rhs.span().end);\n        ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {\n            span,\n            kind,\n            lhs: Box::new(lhs),\n            rhs: Box::new(rhs),\n        })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pop_group":["/// Pop a group AST from the parser's internal stack and set the group's\n/// AST to the given concatenation. Return the concatenation containing\n/// the group.\n///\n/// This assumes that the parser is currently positioned on the closing\n/// parenthesis and advances the parser to the character following the `)`.\n///\n/// If no such group could be popped, then an unopened group error is\n/// returned.\n#[inline(never)]\nfn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat>{\n        use self::GroupState::*;\n\n        assert_eq!(self.char(), ')');\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let (mut prior_concat, mut group, ignore_whitespace, alt) = match stack\n            .pop()\n        {\n            Some(Group { concat, group, ignore_whitespace }) => {\n                (concat, group, ignore_whitespace, None)\n            }\n            Some(Alternation(alt)) => match stack.pop() {\n                Some(Group { concat, group, ignore_whitespace }) => {\n                    (concat, group, ignore_whitespace, Some(alt))\n                }\n                None | Some(Alternation(_)) => {\n                    return Err(self.error(\n                        self.span_char(),\n                        ast::ErrorKind::GroupUnopened,\n                    ));\n                }\n            },\n            None => {\n                return Err(self\n                    .error(self.span_char(), ast::ErrorKind::GroupUnopened));\n            }\n        };\n        self.parser().ignore_whitespace.set(ignore_whitespace);\n        group_concat.span.end = self.pos();\n        self.bump();\n        group.span.end = self.pos();\n        match alt {\n            Some(mut alt) => {\n                alt.span.end = group_concat.span.end;\n                alt.asts.push(group_concat.into_ast());\n                group.ast = Box::new(alt.into_ast());\n            }\n            None => {\n                group.ast = Box::new(group_concat.into_ast());\n            }\n        }\n        prior_concat.asts.push(Ast::Group(group));\n        Ok(prior_concat)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pop_group_end":["/// Pop the last state from the parser's internal stack, if it exists, and\n/// add the given concatenation to it. There either must be no state or a\n/// single alternation item on the stack. Any other scenario produces an\n/// error.\n///\n/// This assumes that the parser has advanced to the end.\n#[inline(never)]\nfn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast>{\n        concat.span.end = self.pos();\n        let mut stack = self.parser().stack_group.borrow_mut();\n        let ast = match stack.pop() {\n            None => Ok(concat.into_ast()),\n            Some(GroupState::Alternation(mut alt)) => {\n                alt.span.end = self.pos();\n                alt.asts.push(concat.into_ast());\n                Ok(Ast::Alternation(alt))\n            }\n            Some(GroupState::Group { group, .. }) => {\n                return Err(\n                    self.error(group.span, ast::ErrorKind::GroupUnclosed)\n                );\n            }\n        };\n        // If we try to pop again, there should be nothing.\n        match stack.pop() {\n            None => ast,\n            Some(GroupState::Alternation(_)) => {\n                // This unreachable is unfortunate. This case can't happen\n                // because the only way we can be here is if there were two\n                // `GroupState::Alternation`s adjacent in the parser's stack,\n                // which we guarantee to never happen because we never push a\n                // `GroupState::Alternation` if one is already at the top of\n                // the stack.\n                unreachable!()\n            }\n            Some(GroupState::Group { group, .. }) => {\n                Err(self.error(group.span, ast::ErrorKind::GroupUnclosed))\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::pos":["/// Return the current position of the parser, which includes the offset,\n/// line and column.\nfn pos(&self) -> Position{\n        self.parser().pos.get()\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_alternate":["/// Parse and push a single alternation on to the parser's internal stack.\n/// If the top of the stack already has an alternation, then add to that\n/// instead of pushing a new one.\n///\n/// The concatenation given corresponds to a single alternation branch.\n/// The concatenation returned starts the next branch and is empty.\n///\n/// This assumes the parser is currently positioned at `|` and will advance\n/// the parser to the character following `|`.\n#[inline(never)]\nfn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat>{\n        assert_eq!(self.char(), '|');\n        concat.span.end = self.pos();\n        self.push_or_add_alternation(concat);\n        self.bump();\n        Ok(ast::Concat { span: self.span(), asts: vec![] })\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_class_op":["/// Push the current set of class items on to the class parser's stack as\n/// the left hand side of the given operator.\n///\n/// A fresh set union is returned, which should be used to build the right\n/// hand side of this operator.\n#[inline(never)]\nfn push_class_op(\n        &self,\n        next_kind: ast::ClassSetBinaryOpKind,\n        next_union: ast::ClassSetUnion,\n    ) -> ast::ClassSetUnion{\n        let item = ast::ClassSet::Item(next_union.into_item());\n        let new_lhs = self.pop_class_op(item);\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Op { kind: next_kind, lhs: new_lhs });\n        ast::ClassSetUnion { span: self.span(), items: vec![] }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_class_open":["/// Parse the opening of a character class and push the current class\n/// parsing context onto the parser's stack. This assumes that the parser\n/// is positioned at an opening `[`. The given union should correspond to\n/// the union of set items built up before seeing the `[`.\n///\n/// If there was a problem parsing the opening of the class, then an error\n/// is returned. Otherwise, a new union of set items for the class is\n/// returned (which may be populated with either a `]` or a `-`).\n#[inline(never)]\nfn push_class_open(\n        &self,\n        parent_union: ast::ClassSetUnion,\n    ) -> Result<ast::ClassSetUnion>{\n        assert_eq!(self.char(), '[');\n\n        let (nested_set, nested_union) = self.parse_set_class_open()?;\n        self.parser()\n            .stack_class\n            .borrow_mut()\n            .push(ClassState::Open { union: parent_union, set: nested_set });\n        Ok(nested_union)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_group":["/// Parse and push a group AST (and its parent concatenation) on to the\n/// parser's internal stack. Return a fresh concatenation corresponding\n/// to the group's sub-AST.\n///\n/// If a set of flags was found (with no group), then the concatenation\n/// is returned with that set of flags added.\n///\n/// This assumes that the parser is currently positioned on the opening\n/// parenthesis. It advances the parser to the character at the start\n/// of the sub-expression (or adjoining expression).\n///\n/// If there was a problem parsing the start of the group, then an error\n/// is returned.\n#[inline(never)]\nfn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat>{\n        assert_eq!(self.char(), '(');\n        match self.parse_group()? {\n            Either::Left(set) => {\n                let ignore = set.flags.flag_state(ast::Flag::IgnoreWhitespace);\n                if let Some(v) = ignore {\n                    self.parser().ignore_whitespace.set(v);\n                }\n\n                concat.asts.push(Ast::Flags(set));\n                Ok(concat)\n            }\n            Either::Right(group) => {\n                let old_ignore_whitespace = self.ignore_whitespace();\n                let new_ignore_whitespace = group\n                    .flags()\n                    .and_then(|f| f.flag_state(ast::Flag::IgnoreWhitespace))\n                    .unwrap_or(old_ignore_whitespace);\n                self.parser().stack_group.borrow_mut().push(\n                    GroupState::Group {\n                        concat,\n                        group,\n                        ignore_whitespace: old_ignore_whitespace,\n                    },\n                );\n                self.parser().ignore_whitespace.set(new_ignore_whitespace);\n                Ok(ast::Concat { span: self.span(), asts: vec![] })\n            }\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::push_or_add_alternation":["/// Pushes or adds the given branch of an alternation to the parser's\n/// internal stack of state.\nfn push_or_add_alternation(&self, concat: ast::Concat){\n        use self::GroupState::*;\n\n        let mut stack = self.parser().stack_group.borrow_mut();\n        if let Some(&mut Alternation(ref mut alts)) = stack.last_mut() {\n            alts.asts.push(concat.into_ast());\n            return;\n        }\n        stack.push(Alternation(ast::Alternation {\n            span: Span::new(concat.span.start, self.pos()),\n            asts: vec![concat.into_ast()],\n        }));\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::span":["/// Create a span at the current position of the parser. Both the start\n/// and end of the span are set.\nfn span(&self) -> Span{\n        Span::splat(self.pos())\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::span_char":["/// Create a span that covers the current character.\nfn span_char(&self) -> Span{\n        let mut next = Position {\n            offset: self.offset().checked_add(self.char().len_utf8()).unwrap(),\n            line: self.line(),\n            column: self.column().checked_add(1).unwrap(),\n        };\n        if self.char() == '\\n' {\n            next.line += 1;\n            next.column = 1;\n        }\n        Span::new(self.pos(), next)\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::ParserI::<'s, P>::unclosed_class_error":["/// Return an \"unclosed class\" error whose span points to the most\n/// recently opened class.\n///\n/// This should only be called while parsing a character class.\n#[inline(never)]\nfn unclosed_class_error(&self) -> ast::Error{\n        for state in self.parser().stack_class.borrow().iter().rev() {\n            if let ClassState::Open { ref set, .. } = *state {\n                return self.error(set.span, ast::ErrorKind::ClassUnclosed);\n            }\n        }\n        // We are guaranteed to have a non-empty stack with at least\n        // one open bracket, so we should never get here.\n        panic!(\"no open character class found\")\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive":["/// A primitive is an expression with no sub-expressions. This includes\n/// literals, assertions and non-set character classes. This representation\n/// is used as intermediate state in the parser.\n///\n/// This does not include ASCII character classes, since they can only appear\n/// within a set character class.\nenum Primitive {\n    Literal(ast::Literal),\n    Assertion(ast::Assertion),\n    Dot(Span),\n    Perl(ast::ClassPerl),\n    Unicode(ast::ClassUnicode),\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive::into_ast":["/// Convert this primitive into a proper AST.\nfn into_ast(self) -> Ast{\n        match self {\n            Primitive::Literal(lit) => Ast::Literal(lit),\n            Primitive::Assertion(assert) => Ast::Assertion(assert),\n            Primitive::Dot(span) => Ast::Dot(span),\n            Primitive::Perl(cls) => Ast::Class(ast::Class::Perl(cls)),\n            Primitive::Unicode(cls) => Ast::Class(ast::Class::Unicode(cls)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive::into_class_literal":["/// Convert this primitive into a literal in a character class. In\n/// particular, literals are the only valid items that can appear in\n/// ranges.\n///\n/// If this primitive is not a legal item (i.e., a class, assertion or a\n/// dot), then return an error.\nfn into_class_literal<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<'_, P>,\n    ) -> Result<ast::Literal>{\n        use self::Primitive::*;\n\n        match self {\n            Literal(lit) => Ok(lit),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassRangeLiteral)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive::into_class_set_item":["/// Convert this primitive into an item in a character class.\n///\n/// If this primitive is not a legal item (i.e., an assertion or a dot),\n/// then return an error.\nfn into_class_set_item<P: Borrow<Parser>>(\n        self,\n        p: &ParserI<'_, P>,\n    ) -> Result<ast::ClassSetItem>{\n        use self::Primitive::*;\n        use crate::ast::ClassSetItem;\n\n        match self {\n            Literal(lit) => Ok(ClassSetItem::Literal(lit)),\n            Perl(cls) => Ok(ClassSetItem::Perl(cls)),\n            Unicode(cls) => Ok(ClassSetItem::Unicode(cls)),\n            x => Err(p.error(*x.span(), ast::ErrorKind::ClassEscapeInvalid)),\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::Primitive::span":["/// Return the span of this primitive.\nfn span(&self) -> &Span{\n        match *self {\n            Primitive::Literal(ref x) => &x.span,\n            Primitive::Assertion(ref x) => &x.span,\n            Primitive::Dot(ref span) => span,\n            Primitive::Perl(ref x) => &x.span,\n            Primitive::Unicode(ref x) => &x.span,\n        }\n    }","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::is_capture_char":["/// Returns true if the given character is a valid in a capture group name.\n///\n/// If `first` is true, then `c` is treated as the first character in the\n/// group name (which must be alphabetic or underscore).\nfn is_capture_char(c: char, first: bool) -> bool{\n    if first {\n        c == '_' || c.is_alphabetic()\n    } else {\n        c == '_' || c == '.' || c == '[' || c == ']' || c.is_alphanumeric()\n    }\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::is_hex":["/// Returns true if the given character is a hexadecimal digit.\nfn is_hex(c: char) -> bool{\n    ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::parse::specialize_err":["/// When the result is an error, transforms the ast::ErrorKind from the source\n/// Result into another one. This function is used to return clearer error\n/// messages when possible.\nfn specialize_err<T>(\n    result: Result<T>,\n    from: ast::ErrorKind,\n    to: ast::ErrorKind,\n) -> Result<T>{\n    if let Err(e) = result {\n        if e.kind == from {\n            Err(ast::Error { kind: to, pattern: e.pattern, span: e.span })\n        } else {\n            Err(e)\n        }\n    } else {\n        result\n    }\n}","Real(LocalPath(\"src/ast/parse.rs\"))"],"ast::print::Printer":["/// A printer for a regular expression abstract syntax tree.\n///\n/// A printer converts an abstract syntax tree (AST) to a regular expression\n/// pattern string. This particular printer uses constant stack space and heap\n/// space proportional to the size of the AST.\n///\n/// This printer will not necessarily preserve the original formatting of the\n/// regular expression pattern string. For example, all whitespace and comments\n/// are ignored.\npub struct Printer {\n    _priv: (),\n}","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Printer::new":["/// Create a new printer.\npub fn new() -> Printer{\n        PrinterBuilder::new().build()\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Printer::print":["/// Print the given `Ast` to the given writer. The writer must implement\n/// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n/// here are a `fmt::Formatter` (which is available in `fmt::Display`\n/// implementations) or a `&mut String`.\npub fn print<W: fmt::Write>(&mut self, ast: &Ast, wtr: W) -> fmt::Result{\n        visitor::visit(ast, Writer { wtr })\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::PrinterBuilder":["/// A builder for constructing a printer.\n///\n/// Note that since a printer doesn't have any configuration knobs, this type\n/// remains unexported.\nstruct PrinterBuilder {\n    _priv: (),\n}","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::PrinterBuilder::build":["fn build(&self) -> Printer{\n        Printer { _priv: () }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::PrinterBuilder::new":["fn new() -> PrinterBuilder{\n        PrinterBuilder { _priv: () }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer":["struct Writer<W> {\n    wtr: W,\n}","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_assertion":["fn fmt_assertion(&mut self, ast: &ast::Assertion) -> fmt::Result{\n        use crate::ast::AssertionKind::*;\n        match ast.kind {\n            StartLine => self.wtr.write_str(\"^\"),\n            EndLine => self.wtr.write_str(\"$\"),\n            StartText => self.wtr.write_str(r\"\\A\"),\n            EndText => self.wtr.write_str(r\"\\z\"),\n            WordBoundary => self.wtr.write_str(r\"\\b\"),\n            NotWordBoundary => self.wtr.write_str(r\"\\B\"),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_class_ascii":["fn fmt_class_ascii(&mut self, ast: &ast::ClassAscii) -> fmt::Result{\n        use crate::ast::ClassAsciiKind::*;\n        match ast.kind {\n            Alnum if ast.negated => self.wtr.write_str(\"[:^alnum:]\"),\n            Alnum => self.wtr.write_str(\"[:alnum:]\"),\n            Alpha if ast.negated => self.wtr.write_str(\"[:^alpha:]\"),\n            Alpha => self.wtr.write_str(\"[:alpha:]\"),\n            Ascii if ast.negated => self.wtr.write_str(\"[:^ascii:]\"),\n            Ascii => self.wtr.write_str(\"[:ascii:]\"),\n            Blank if ast.negated => self.wtr.write_str(\"[:^blank:]\"),\n            Blank => self.wtr.write_str(\"[:blank:]\"),\n            Cntrl if ast.negated => self.wtr.write_str(\"[:^cntrl:]\"),\n            Cntrl => self.wtr.write_str(\"[:cntrl:]\"),\n            Digit if ast.negated => self.wtr.write_str(\"[:^digit:]\"),\n            Digit => self.wtr.write_str(\"[:digit:]\"),\n            Graph if ast.negated => self.wtr.write_str(\"[:^graph:]\"),\n            Graph => self.wtr.write_str(\"[:graph:]\"),\n            Lower if ast.negated => self.wtr.write_str(\"[:^lower:]\"),\n            Lower => self.wtr.write_str(\"[:lower:]\"),\n            Print if ast.negated => self.wtr.write_str(\"[:^print:]\"),\n            Print => self.wtr.write_str(\"[:print:]\"),\n            Punct if ast.negated => self.wtr.write_str(\"[:^punct:]\"),\n            Punct => self.wtr.write_str(\"[:punct:]\"),\n            Space if ast.negated => self.wtr.write_str(\"[:^space:]\"),\n            Space => self.wtr.write_str(\"[:space:]\"),\n            Upper if ast.negated => self.wtr.write_str(\"[:^upper:]\"),\n            Upper => self.wtr.write_str(\"[:upper:]\"),\n            Word if ast.negated => self.wtr.write_str(\"[:^word:]\"),\n            Word => self.wtr.write_str(\"[:word:]\"),\n            Xdigit if ast.negated => self.wtr.write_str(\"[:^xdigit:]\"),\n            Xdigit => self.wtr.write_str(\"[:xdigit:]\"),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_class_bracketed_post":["fn fmt_class_bracketed_post(\n        &mut self,\n        _ast: &ast::ClassBracketed,\n    ) -> fmt::Result{\n        self.wtr.write_str(\"]\")\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_class_bracketed_pre":["fn fmt_class_bracketed_pre(\n        &mut self,\n        ast: &ast::ClassBracketed,\n    ) -> fmt::Result{\n        if ast.negated {\n            self.wtr.write_str(\"[^\")\n        } else {\n            self.wtr.write_str(\"[\")\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_class_perl":["fn fmt_class_perl(&mut self, ast: &ast::ClassPerl) -> fmt::Result{\n        use crate::ast::ClassPerlKind::*;\n        match ast.kind {\n            Digit if ast.negated => self.wtr.write_str(r\"\\D\"),\n            Digit => self.wtr.write_str(r\"\\d\"),\n            Space if ast.negated => self.wtr.write_str(r\"\\S\"),\n            Space => self.wtr.write_str(r\"\\s\"),\n            Word if ast.negated => self.wtr.write_str(r\"\\W\"),\n            Word => self.wtr.write_str(r\"\\w\"),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_class_set_binary_op_kind":["fn fmt_class_set_binary_op_kind(\n        &mut self,\n        ast: &ast::ClassSetBinaryOpKind,\n    ) -> fmt::Result{\n        use crate::ast::ClassSetBinaryOpKind::*;\n        match *ast {\n            Intersection => self.wtr.write_str(\"&&\"),\n            Difference => self.wtr.write_str(\"--\"),\n            SymmetricDifference => self.wtr.write_str(\"~~\"),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_class_unicode":["fn fmt_class_unicode(&mut self, ast: &ast::ClassUnicode) -> fmt::Result{\n        use crate::ast::ClassUnicodeKind::*;\n        use crate::ast::ClassUnicodeOpKind::*;\n\n        if ast.negated {\n            self.wtr.write_str(r\"\\P\")?;\n        } else {\n            self.wtr.write_str(r\"\\p\")?;\n        }\n        match ast.kind {\n            OneLetter(c) => self.wtr.write_char(c),\n            Named(ref x) => write!(self.wtr, \"{{{}}}\", x),\n            NamedValue { op: Equal, ref name, ref value } => {\n                write!(self.wtr, \"{{{}={}}}\", name, value)\n            }\n            NamedValue { op: Colon, ref name, ref value } => {\n                write!(self.wtr, \"{{{}:{}}}\", name, value)\n            }\n            NamedValue { op: NotEqual, ref name, ref value } => {\n                write!(self.wtr, \"{{{}!={}}}\", name, value)\n            }\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_flags":["fn fmt_flags(&mut self, ast: &ast::Flags) -> fmt::Result{\n        use crate::ast::{Flag, FlagsItemKind};\n\n        for item in &ast.items {\n            match item.kind {\n                FlagsItemKind::Negation => self.wtr.write_str(\"-\"),\n                FlagsItemKind::Flag(ref flag) => match *flag {\n                    Flag::CaseInsensitive => self.wtr.write_str(\"i\"),\n                    Flag::MultiLine => self.wtr.write_str(\"m\"),\n                    Flag::DotMatchesNewLine => self.wtr.write_str(\"s\"),\n                    Flag::SwapGreed => self.wtr.write_str(\"U\"),\n                    Flag::Unicode => self.wtr.write_str(\"u\"),\n                    Flag::CRLF => self.wtr.write_str(\"R\"),\n                    Flag::IgnoreWhitespace => self.wtr.write_str(\"x\"),\n                },\n            }?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_group_post":["fn fmt_group_post(&mut self, _ast: &ast::Group) -> fmt::Result{\n        self.wtr.write_str(\")\")\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_group_pre":["fn fmt_group_pre(&mut self, ast: &ast::Group) -> fmt::Result{\n        use crate::ast::GroupKind::*;\n        match ast.kind {\n            CaptureIndex(_) => self.wtr.write_str(\"(\"),\n            CaptureName { ref name, starts_with_p } => {\n                let start = if starts_with_p { \"(?P<\" } else { \"(?<\" };\n                self.wtr.write_str(start)?;\n                self.wtr.write_str(&name.name)?;\n                self.wtr.write_str(\">\")?;\n                Ok(())\n            }\n            NonCapturing(ref flags) => {\n                self.wtr.write_str(\"(?\")?;\n                self.fmt_flags(flags)?;\n                self.wtr.write_str(\":\")?;\n                Ok(())\n            }\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_literal":["fn fmt_literal(&mut self, ast: &ast::Literal) -> fmt::Result{\n        use crate::ast::LiteralKind::*;\n\n        match ast.kind {\n            Verbatim => self.wtr.write_char(ast.c),\n            Meta | Superfluous => write!(self.wtr, r\"\\{}\", ast.c),\n            Octal => write!(self.wtr, r\"\\{:o}\", u32::from(ast.c)),\n            HexFixed(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{:02X}\", u32::from(ast.c))\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{:04X}\", u32::from(ast.c))\n            }\n            HexFixed(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{:08X}\", u32::from(ast.c))\n            }\n            HexBrace(ast::HexLiteralKind::X) => {\n                write!(self.wtr, r\"\\x{{{:X}}}\", u32::from(ast.c))\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeShort) => {\n                write!(self.wtr, r\"\\u{{{:X}}}\", u32::from(ast.c))\n            }\n            HexBrace(ast::HexLiteralKind::UnicodeLong) => {\n                write!(self.wtr, r\"\\U{{{:X}}}\", u32::from(ast.c))\n            }\n            Special(ast::SpecialLiteralKind::Bell) => {\n                self.wtr.write_str(r\"\\a\")\n            }\n            Special(ast::SpecialLiteralKind::FormFeed) => {\n                self.wtr.write_str(r\"\\f\")\n            }\n            Special(ast::SpecialLiteralKind::Tab) => self.wtr.write_str(r\"\\t\"),\n            Special(ast::SpecialLiteralKind::LineFeed) => {\n                self.wtr.write_str(r\"\\n\")\n            }\n            Special(ast::SpecialLiteralKind::CarriageReturn) => {\n                self.wtr.write_str(r\"\\r\")\n            }\n            Special(ast::SpecialLiteralKind::VerticalTab) => {\n                self.wtr.write_str(r\"\\v\")\n            }\n            Special(ast::SpecialLiteralKind::Space) => {\n                self.wtr.write_str(r\"\\ \")\n            }\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_repetition":["fn fmt_repetition(&mut self, ast: &ast::Repetition) -> fmt::Result{\n        use crate::ast::RepetitionKind::*;\n        match ast.op.kind {\n            ZeroOrOne if ast.greedy => self.wtr.write_str(\"?\"),\n            ZeroOrOne => self.wtr.write_str(\"??\"),\n            ZeroOrMore if ast.greedy => self.wtr.write_str(\"*\"),\n            ZeroOrMore => self.wtr.write_str(\"*?\"),\n            OneOrMore if ast.greedy => self.wtr.write_str(\"+\"),\n            OneOrMore => self.wtr.write_str(\"+?\"),\n            Range(ref x) => {\n                self.fmt_repetition_range(x)?;\n                if !ast.greedy {\n                    self.wtr.write_str(\"?\")?;\n                }\n                Ok(())\n            }\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_repetition_range":["fn fmt_repetition_range(\n        &mut self,\n        ast: &ast::RepetitionRange,\n    ) -> fmt::Result{\n        use crate::ast::RepetitionRange::*;\n        match *ast {\n            Exactly(x) => write!(self.wtr, \"{{{}}}\", x),\n            AtLeast(x) => write!(self.wtr, \"{{{},}}\", x),\n            Bounded(x, y) => write!(self.wtr, \"{{{},{}}}\", x, y),\n        }\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::print::Writer::<W>::fmt_set_flags":["fn fmt_set_flags(&mut self, ast: &ast::SetFlags) -> fmt::Result{\n        self.wtr.write_str(\"(?\")?;\n        self.fmt_flags(&ast.flags)?;\n        self.wtr.write_str(\")\")?;\n        Ok(())\n    }","Real(LocalPath(\"src/ast/print.rs\"))"],"ast::visitor::ClassFrame":["/// Represents a single stack frame while performing structural induction over\n/// a character class.\nenum ClassFrame<'a> {\n    /// The stack frame used while visiting every child node of a union of\n    /// character class items.\n    Union {\n        /// The child node we are currently visiting.\n        head: &'a ast::ClassSetItem,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [ast::ClassSetItem],\n    },\n    /// The stack frame used while a binary class operation.\n    Binary { op: &'a ast::ClassSetBinaryOp },\n    /// A stack frame allocated just before descending into a binary operator's\n    /// left hand child node.\n    BinaryLHS {\n        op: &'a ast::ClassSetBinaryOp,\n        lhs: &'a ast::ClassSet,\n        rhs: &'a ast::ClassSet,\n    },\n    /// A stack frame allocated just before descending into a binary operator's\n    /// right hand child node.\n    BinaryRHS { op: &'a ast::ClassSetBinaryOp, rhs: &'a ast::ClassSet },\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::ClassFrame::<'a>::child":["/// Perform the next inductive step on this frame and return the next\n/// child class node to visit.\nfn child(&self) -> ClassInduct<'a>{\n        match *self {\n            ClassFrame::Union { head, .. } => ClassInduct::Item(head),\n            ClassFrame::Binary { op, .. } => ClassInduct::BinaryOp(op),\n            ClassFrame::BinaryLHS { ref lhs, .. } => {\n                ClassInduct::from_set(lhs)\n            }\n            ClassFrame::BinaryRHS { ref rhs, .. } => {\n                ClassInduct::from_set(rhs)\n            }\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::ClassInduct":["/// A representation of the inductive step when performing structural induction\n/// over a character class.\n///\n/// Note that there is no analogous explicit type for the inductive step for\n/// `Ast` nodes because the inductive step is just an `Ast`. For character\n/// classes, the inductive step can produce one of two possible child nodes:\n/// an item or a binary operation. (An item cannot be a binary operation\n/// because that would imply binary operations can be unioned in the concrete\n/// syntax, which is not possible.)\nenum ClassInduct<'a> {\n    Item(&'a ast::ClassSetItem),\n    BinaryOp(&'a ast::ClassSetBinaryOp),\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::ClassInduct::<'a>::from_bracketed":["fn from_bracketed(ast: &'a ast::ClassBracketed) -> ClassInduct<'a>{\n        ClassInduct::from_set(&ast.kind)\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::ClassInduct::<'a>::from_set":["fn from_set(ast: &'a ast::ClassSet) -> ClassInduct<'a>{\n        match *ast {\n            ast::ClassSet::Item(ref item) => ClassInduct::Item(item),\n            ast::ClassSet::BinaryOp(ref op) => ClassInduct::BinaryOp(op),\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Frame":["/// Represents a single stack frame while performing structural induction over\n/// an `Ast`.\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a ast::Repetition),\n    /// A stack frame allocated just before descending into a group's child\n    /// node.\n    Group(&'a ast::Group),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Frame::<'a>::child":["/// Perform the next inductive step on this frame and return the next\n/// child AST node to visit.\nfn child(&self) -> &'a Ast{\n        match *self {\n            Frame::Repetition(rep) => &rep.ast,\n            Frame::Group(group) => &group.ast,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor":["/// HeapVisitor visits every item in an `Ast` recursively using constant stack\n/// size and a heap size proportional to the size of the `Ast`.\nstruct HeapVisitor<'a> {\n    /// A stack of `Ast` nodes. This is roughly analogous to the call stack\n    /// used in a typical recursive visitor.\n    stack: Vec<(&'a Ast, Frame<'a>)>,\n    /// Similar to the `Ast` stack above, but is used only for character\n    /// classes. In particular, character classes embed their own mini\n    /// recursive syntax.\n    stack_class: Vec<(ClassInduct<'a>, ClassFrame<'a>)>,\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::induct":["/// Build a stack frame for the given AST if one is needed (which occurs if\n/// and only if there are child nodes in the AST). Otherwise, return None.\n///\n/// If this visits a class, then the underlying visitor implementation may\n/// return an error which will be passed on here.\nfn induct<V: Visitor>(\n        &mut self,\n        ast: &'a Ast,\n        visitor: &mut V,\n    ) -> Result<Option<Frame<'a>>, V::Err>{\n        Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat { head: &x.asts[0], tail: &x.asts[1..] })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => Some(Frame::Alternation {\n                head: &x.asts[0],\n                tail: &x.asts[1..],\n            }),\n            _ => None,\n        })\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::induct_class":["/// Build a stack frame for the given class node if one is needed (which\n/// occurs if and only if there are child nodes). Otherwise, return None.\nfn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>>{\n        match *ast {\n            ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) => {\n                match x.kind {\n                    ast::ClassSet::Item(ref item) => {\n                        Some(ClassFrame::Union { head: item, tail: &[] })\n                    }\n                    ast::ClassSet::BinaryOp(ref op) => {\n                        Some(ClassFrame::Binary { op })\n                    }\n                }\n            }\n            ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) => {\n                if x.items.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &x.items[0],\n                        tail: &x.items[1..],\n                    })\n                }\n            }\n            ClassInduct::BinaryOp(op) => {\n                Some(ClassFrame::BinaryLHS { op, lhs: &op.lhs, rhs: &op.rhs })\n            }\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::new":["fn new() -> HeapVisitor<'a>{\n        HeapVisitor { stack: vec![], stack_class: vec![] }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::pop":["/// Pops the given frame. If the frame has an additional inductive step,\n/// then return it, otherwise return `None`.\nfn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>>{\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::pop_class":["/// Pops the given frame. If the frame has an additional inductive step,\n/// then return it, otherwise return `None`.\nfn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>>{\n        match induct {\n            ClassFrame::Union { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(ClassFrame::Union {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n            ClassFrame::Binary { .. } => None,\n            ClassFrame::BinaryLHS { op, rhs, .. } => {\n                Some(ClassFrame::BinaryRHS { op, rhs })\n            }\n            ClassFrame::BinaryRHS { .. } => None,\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::visit":["fn visit<V: Visitor>(\n        &mut self,\n        mut ast: &'a Ast,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err>{\n        self.stack.clear();\n        self.stack_class.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(ast)?;\n            if let Some(x) = self.induct(ast, &mut visitor)? {\n                let child = x.child();\n                self.stack.push((ast, x));\n                ast = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(ast)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    ast = x.child();\n                    self.stack.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this AST, so we can post visit it now.\n                visitor.visit_post(post_ast)?;\n            }\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::visit_class":["fn visit_class<V: Visitor>(\n        &mut self,\n        ast: &'a ast::ClassBracketed,\n        visitor: &mut V,\n    ) -> Result<(), V::Err>{\n        let mut ast = ClassInduct::from_bracketed(ast);\n        loop {\n            self.visit_class_pre(&ast, visitor)?;\n            if let Some(x) = self.induct_class(&ast) {\n                let child = x.child();\n                self.stack_class.push((ast, x));\n                ast = child;\n                continue;\n            }\n            self.visit_class_post(&ast, visitor)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_ast, frame) = match self.stack_class.pop() {\n                    None => return Ok(()),\n                    Some((post_ast, frame)) => (post_ast, frame),\n                };\n                // If this is a union or a binary op, then we might have\n                // additional inductive steps to process.\n                if let Some(x) = self.pop_class(frame) {\n                    if let ClassFrame::BinaryRHS { ref op, .. } = x {\n                        visitor.visit_class_set_binary_op_in(op)?;\n                    }\n                    ast = x.child();\n                    self.stack_class.push((post_ast, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this class node, so we can post visit it now.\n                self.visit_class_post(&post_ast, visitor)?;\n            }\n        }\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::visit_class_post":["/// Call the appropriate `Visitor` methods given an inductive step.\nfn visit_class_post<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err>{\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_post(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_post(op)?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::HeapVisitor::<'a>::visit_class_pre":["/// Call the appropriate `Visitor` methods given an inductive step.\nfn visit_class_pre<V: Visitor>(\n        &self,\n        ast: &ClassInduct<'a>,\n        visitor: &mut V,\n    ) -> Result<(), V::Err>{\n        match *ast {\n            ClassInduct::Item(item) => {\n                visitor.visit_class_set_item_pre(item)?;\n            }\n            ClassInduct::BinaryOp(op) => {\n                visitor.visit_class_set_binary_op_pre(op)?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor":["/// A trait for visiting an abstract syntax tree (AST) in depth first order.\n///\n/// The principle aim of this trait is to enable callers to perform case\n/// analysis on an abstract syntax tree without necessarily using recursion.\n/// In particular, this permits callers to do case analysis with constant stack\n/// usage, which can be important since the size of an abstract syntax tree\n/// may be proportional to end user input.\n///\n/// Typical usage of this trait involves providing an implementation and then\n/// running it using the [`visit`] function.\n///\n/// Note that the abstract syntax tree for a regular expression is quite\n/// complex. Unless you specifically need it, you might be able to use the much\n/// simpler [high-level intermediate representation](crate::hir::Hir) and its\n/// [corresponding `Visitor` trait](crate::hir::Visitor) instead.\npub trait Visitor {\n    /// The result of visiting an AST.\n    type Output;\n    /// An error that visiting an AST might return.\n    type Err;\n\n    /// All implementors of `Visitor` must provide a `finish` method, which\n    /// yields the result of visiting the AST or an error.\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n\n    /// This method is called before beginning traversal of the AST.\n    fn start(&mut self) {}\n\n    /// This method is called on an `Ast` before descending into child `Ast`\n    /// nodes.\n    fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on an `Ast` after descending all of its child\n    /// `Ast` nodes.\n    fn visit_post(&mut self, _ast: &Ast) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called between child nodes of an\n    /// [`Alternation`](ast::Alternation).\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every [`ClassSetItem`](ast::ClassSetItem)\n    /// before descending into child nodes.\n    fn visit_class_set_item_pre(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every [`ClassSetItem`](ast::ClassSetItem)\n    /// after descending into child nodes.\n    fn visit_class_set_item_post(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetBinaryOp`](ast::ClassSetBinaryOp) before descending into\n    /// child nodes.\n    fn visit_class_set_binary_op_pre(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on every\n    /// [`ClassSetBinaryOp`](ast::ClassSetBinaryOp) after descending into child\n    /// nodes.\n    fn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called between the left hand and right hand child nodes\n    /// of a [`ClassSetBinaryOp`](ast::ClassSetBinaryOp).\n    fn visit_class_set_binary_op_in(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::start":["/// This method is called before beginning traversal of the AST.\nfn start(&mut self){}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_alternation_in":["/// This method is called between child nodes of an\n/// [`Alternation`](ast::Alternation).\nfn visit_alternation_in(&mut self) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_binary_op_in":["/// This method is called between the left hand and right hand child nodes\n/// of a [`ClassSetBinaryOp`](ast::ClassSetBinaryOp).\nfn visit_class_set_binary_op_in(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_binary_op_post":["/// This method is called on every\n/// [`ClassSetBinaryOp`](ast::ClassSetBinaryOp) after descending into child\n/// nodes.\nfn visit_class_set_binary_op_post(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_binary_op_pre":["/// This method is called on every\n/// [`ClassSetBinaryOp`](ast::ClassSetBinaryOp) before descending into\n/// child nodes.\nfn visit_class_set_binary_op_pre(\n        &mut self,\n        _ast: &ast::ClassSetBinaryOp,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_item_post":["/// This method is called on every [`ClassSetItem`](ast::ClassSetItem)\n/// after descending into child nodes.\nfn visit_class_set_item_post(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_class_set_item_pre":["/// This method is called on every [`ClassSetItem`](ast::ClassSetItem)\n/// before descending into child nodes.\nfn visit_class_set_item_pre(\n        &mut self,\n        _ast: &ast::ClassSetItem,\n    ) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_post":["/// This method is called on an `Ast` after descending all of its child\n/// `Ast` nodes.\nfn visit_post(&mut self, _ast: &Ast) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::Visitor::visit_pre":["/// This method is called on an `Ast` before descending into child `Ast`\n/// nodes.\nfn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/ast/visitor.rs\"))"],"ast::visitor::visit":["/// Executes an implementation of `Visitor` in constant stack space.\n///\n/// This function will visit every node in the given `Ast` while calling the\n/// appropriate methods provided by the [`Visitor`] trait.\n///\n/// The primary use case for this method is when one wants to perform case\n/// analysis over an `Ast` without using a stack size proportional to the depth\n/// of the `Ast`. Namely, this method will instead use constant stack size, but\n/// will use heap space proportional to the size of the `Ast`. This may be\n/// desirable in cases where the size of `Ast` is proportional to end user\n/// input.\n///\n/// If the visitor returns an error at any point, then visiting is stopped and\n/// the error is returned.\npub fn visit<V: Visitor>(ast: &Ast, visitor: V) -> Result<V::Output, V::Err>{\n    HeapVisitor::new().visit(ast, visitor)\n}","Real(LocalPath(\"src/ast/visitor.rs\"))"],"debug::Byte":["/// A type that wraps a single byte with a convenient fmt::Debug impl that\n/// escapes the byte.\npub(crate) struct Byte(pub(crate) u8);","Real(LocalPath(\"src/debug.rs\"))"],"debug::Bytes":["/// A type that provides a human readable debug impl for arbitrary bytes.\n///\n/// This generally works best when the bytes are presumed to be mostly UTF-8,\n/// but will work for anything.\n///\n/// N.B. This is copied nearly verbatim from regex-automata. Sigh.\npub(crate) struct Bytes<'a>(pub(crate) &'a [u8]);","Real(LocalPath(\"src/debug.rs\"))"],"debug::utf8_decode":["/// Decodes the next UTF-8 encoded codepoint from the given byte slice.\n///\n/// If no valid encoding of a codepoint exists at the beginning of the given\n/// byte slice, then the first byte is returned instead.\n///\n/// This returns `None` if and only if `bytes` is empty.\npub(crate) fn utf8_decode(bytes: &[u8]) -> Option<Result<char, u8>>{\n    fn len(byte: u8) -> Option<usize> {\n        if byte <= 0x7F {\n            return Some(1);\n        } else if byte & 0b1100_0000 == 0b1000_0000 {\n            return None;\n        } else if byte <= 0b1101_1111 {\n            Some(2)\n        } else if byte <= 0b1110_1111 {\n            Some(3)\n        } else if byte <= 0b1111_0111 {\n            Some(4)\n        } else {\n            None\n        }\n    }\n\n    if bytes.is_empty() {\n        return None;\n    }\n    let len = match len(bytes[0]) {\n        None => return Some(Err(bytes[0])),\n        Some(len) if len > bytes.len() => return Some(Err(bytes[0])),\n        Some(1) => return Some(Ok(char::from(bytes[0]))),\n        Some(len) => len,\n    };\n    match core::str::from_utf8(&bytes[..len]) {\n        Ok(s) => Some(Ok(s.chars().next().unwrap())),\n        Err(_) => Some(Err(bytes[0])),\n    }\n}","Real(LocalPath(\"src/debug.rs\"))"],"debug::utf8_decode::len":["fn len(byte: u8) -> Option<usize>{\n        if byte <= 0x7F {\n            return Some(1);\n        } else if byte & 0b1100_0000 == 0b1000_0000 {\n            return None;\n        } else if byte <= 0b1101_1111 {\n            Some(2)\n        } else if byte <= 0b1110_1111 {\n            Some(3)\n        } else if byte <= 0b1111_0111 {\n            Some(4)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/debug.rs\"))"],"either::Either":["/// A simple binary sum type.\n///\n/// This is occasionally useful in an ad hoc fashion.\npub enum Either<Left, Right> {\n    Left(Left),\n    Right(Right),\n}","Real(LocalPath(\"src/either.rs\"))"],"error::Error":["/// This error type encompasses any error that can be returned by this crate.\n///\n/// This error type is marked as `non_exhaustive`. This means that adding a\n/// new variant is not considered a breaking change.\n#[non_exhaustive]\npub enum Error {\n    /// An error that occurred while translating concrete syntax into abstract\n    /// syntax (AST).\n    Parse(ast::Error),\n    /// An error that occurred while translating abstract syntax into a high\n    /// level intermediate representation (HIR).\n    Translate(hir::Error),\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Formatter":["/// A helper type for formatting nice error messages.\n///\n/// This type is responsible for reporting regex parse errors in a nice human\n/// readable format. Most of its complexity is from interspersing notational\n/// markers pointing out the position where an error occurred.\npub struct Formatter<'e, E> {\n    /// The original regex pattern in which the error occurred.\n    pattern: &'e str,\n    /// The error kind. It must impl fmt::Display.\n    err: &'e E,\n    /// The primary span of the error.\n    span: &'e ast::Span,\n    /// An auxiliary and optional span, in case the error needs to point to\n    /// two locations (e.g., when reporting a duplicate capture group name).\n    aux_span: Option<&'e ast::Span>,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Spans":["/// This type represents an arbitrary number of error spans in a way that makes\n/// it convenient to notate the regex pattern. (\"Notate\" means \"point out\n/// exactly where the error occurred in the regex pattern.\")\n///\n/// Technically, we can only ever have two spans given our current error\n/// structure. However, after toiling with a specific algorithm for handling\n/// two spans, it became obvious that an algorithm to handle an arbitrary\n/// number of spans was actually much simpler.\nstruct Spans<'p> {\n    /// The original regex pattern string.\n    pattern: &'p str,\n    /// The total width that should be used for line numbers. The width is\n    /// used for left padding the line numbers for alignment.\n    ///\n    /// A value of `0` means line numbers should not be displayed. That is,\n    /// the pattern is itself only one line.\n    line_number_width: usize,\n    /// All error spans that occur on a single line. This sequence always has\n    /// length equivalent to the number of lines in `pattern`, where the index\n    /// of the sequence represents a line number, starting at `0`. The spans\n    /// in each line are sorted in ascending order.\n    by_line: Vec<Vec<ast::Span>>,\n    /// All error spans that occur over one or more lines. That is, the start\n    /// and end position of the span have different line numbers. The spans are\n    /// sorted in ascending order.\n    multi_line: Vec<ast::Span>,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::add":["/// Add the given span to this sequence, putting it in the right place.\nfn add(&mut self, span: ast::Span){\n        // This is grossly inefficient since we sort after each add, but right\n        // now, we only ever add two spans at most.\n        if span.is_one_line() {\n            let i = span.start.line - 1; // because lines are 1-indexed\n            self.by_line[i].push(span);\n            self.by_line[i].sort();\n        } else {\n            self.multi_line.push(span);\n            self.multi_line.sort();\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::from_formatter":["/// Build a sequence of spans from a formatter.\nfn from_formatter<'e, E: core::fmt::Display>(\n        fmter: &'p Formatter<'e, E>,\n    ) -> Spans<'p>{\n        let mut line_count = fmter.pattern.lines().count();\n        // If the pattern ends with a `\\n` literal, then our line count is\n        // off by one, since a span can occur immediately after the last `\\n`,\n        // which is consider to be an additional line.\n        if fmter.pattern.ends_with('\\n') {\n            line_count += 1;\n        }\n        let line_number_width =\n            if line_count <= 1 { 0 } else { line_count.to_string().len() };\n        let mut spans = Spans {\n            pattern: &fmter.pattern,\n            line_number_width,\n            by_line: vec![vec![]; line_count],\n            multi_line: vec![],\n        };\n        spans.add(fmter.span.clone());\n        if let Some(span) = fmter.aux_span {\n            spans.add(span.clone());\n        }\n        spans\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::left_pad_line_number":["/// Left pad the given line number with spaces such that it is aligned with\n/// other line numbers.\nfn left_pad_line_number(&self, n: usize) -> String{\n        let n = n.to_string();\n        let pad = self.line_number_width.checked_sub(n.len()).unwrap();\n        let mut result = repeat_char(' ', pad);\n        result.push_str(&n);\n        result\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::line_number_padding":["/// Return the line number padding beginning at the start of each line of\n/// the pattern.\n///\n/// If the pattern is only one line, then this returns a fixed padding\n/// for visual indentation.\nfn line_number_padding(&self) -> usize{\n        if self.line_number_width == 0 {\n            4\n        } else {\n            2 + self.line_number_width\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::notate":["/// Notate the pattern string with carents (`^`) pointing at each span\n/// location. This only applies to spans that occur within a single line.\nfn notate(&self) -> String{\n        let mut notated = String::new();\n        for (i, line) in self.pattern.lines().enumerate() {\n            if self.line_number_width > 0 {\n                notated.push_str(&self.left_pad_line_number(i + 1));\n                notated.push_str(\": \");\n            } else {\n                notated.push_str(\"    \");\n            }\n            notated.push_str(line);\n            notated.push('\\n');\n            if let Some(notes) = self.notate_line(i) {\n                notated.push_str(&notes);\n                notated.push('\\n');\n            }\n        }\n        notated\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Spans::<'p>::notate_line":["/// Return notes for the line indexed at `i` (zero-based). If there are no\n/// spans for the given line, then `None` is returned. Otherwise, an\n/// appropriately space padded string with correctly positioned `^` is\n/// returned, accounting for line numbers.\nfn notate_line(&self, i: usize) -> Option<String>{\n        let spans = &self.by_line[i];\n        if spans.is_empty() {\n            return None;\n        }\n        let mut notes = String::new();\n        for _ in 0..self.line_number_padding() {\n            notes.push(' ');\n        }\n        let mut pos = 0;\n        for span in spans {\n            for _ in pos..(span.start.column - 1) {\n                notes.push(' ');\n                pos += 1;\n            }\n            let note_len = span.end.column.saturating_sub(span.start.column);\n            for _ in 0..core::cmp::max(1, note_len) {\n                notes.push('^');\n                pos += 1;\n            }\n        }\n        Some(notes)\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::repeat_char":["fn repeat_char(c: char, count: usize) -> String{\n    core::iter::repeat(c).take(count).collect()\n}","Real(LocalPath(\"src/error.rs\"))"],"escape":["/// Escapes all regular expression meta characters in `text`.\n///\n/// The string returned may be safely used as a literal in a regular\n/// expression.\npub fn escape(text: &str) -> String{\n    let mut quoted = String::new();\n    escape_into(text, &mut quoted);\n    quoted\n}","Real(LocalPath(\"src/lib.rs\"))"],"escape_into":["/// Escapes all meta characters in `text` and writes the result into `buf`.\n///\n/// This will append escape characters into the given buffer. The characters\n/// that are appended are safe to use as a literal in a regular expression.\npub fn escape_into(text: &str, buf: &mut String){\n    buf.reserve(text.len());\n    for c in text.chars() {\n        if is_meta_character(c) {\n            buf.push('\\\\');\n        }\n        buf.push(c);\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"hir::Capture":["/// The high-level intermediate representation for a capturing group.\n///\n/// A capturing group always has an index and a child expression. It may\n/// also have a name associated with it (e.g., `(?P<foo>\\w)`), but it's not\n/// necessary.\n///\n/// Note that there is no explicit representation of a non-capturing group\n/// in a `Hir`. Instead, non-capturing grouping is handled automatically by\n/// the recursive structure of the `Hir` itself.\npub struct Capture {\n    /// The capture index of the capture.\n    pub index: u32,\n    /// The name of the capture, if it exists.\n    pub name: Option<Box<str>>,\n    /// The expression inside the capturing group, which may be empty.\n    pub sub: Box<Hir>,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class":["/// The high-level intermediate representation of a character class.\n///\n/// A character class corresponds to a set of characters. A character is either\n/// defined by a Unicode scalar value or a byte. Unicode characters are used\n/// by default, while bytes are used when Unicode mode (via the `u` flag) is\n/// disabled.\n///\n/// A character class, regardless of its character type, is represented by a\n/// sequence of non-overlapping non-adjacent ranges of characters.\n///\n/// Note that `Bytes` variant may be produced even when it exclusively matches\n/// valid UTF-8. This is because a `Bytes` variant represents an intention by\n/// the author of the regular expression to disable Unicode mode, which in turn\n/// impacts the semantics of case insensitive matching. For example, `(?i)k`\n/// and `(?i-u)k` will not match the same set of strings.\npub enum Class {\n    /// A set of characters represented by Unicode scalar values.\n    Unicode(ClassUnicode),\n    /// A set of characters represented by arbitrary bytes (one byte per\n    /// character).\n    Bytes(ClassBytes),\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::case_fold_simple":["/// Apply Unicode simple case folding to this character class, in place.\n/// The character class will be expanded to include all simple case folded\n/// character variants.\n///\n/// If this is a byte oriented character class, then this will be limited\n/// to the ASCII ranges `A-Z` and `a-z`.\n///\n/// # Panics\n///\n/// This routine panics when the case mapping data necessary for this\n/// routine to complete is unavailable. This occurs when the `unicode-case`\n/// feature is not enabled and the underlying class is Unicode oriented.\n///\n/// Callers should prefer using `try_case_fold_simple` instead, which will\n/// return an error instead of panicking.\npub fn case_fold_simple(&mut self){\n        match *self {\n            Class::Unicode(ref mut x) => x.case_fold_simple(),\n            Class::Bytes(ref mut x) => x.case_fold_simple(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::is_empty":["/// Returns true if and only if this character class is empty. That is,\n/// it has no elements.\n///\n/// An empty character can never match anything, including an empty string.\npub fn is_empty(&self) -> bool{\n        match *self {\n            Class::Unicode(ref x) => x.ranges().is_empty(),\n            Class::Bytes(ref x) => x.ranges().is_empty(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::is_utf8":["/// Returns true if and only if this character class will only ever match\n/// valid UTF-8.\n///\n/// A character class can match invalid UTF-8 only when the following\n/// conditions are met:\n///\n/// 1. The translator was configured to permit generating an expression\n///    that can match invalid UTF-8. (By default, this is disabled.)\n/// 2. Unicode mode (via the `u` flag) was disabled either in the concrete\n///    syntax or in the parser builder. By default, Unicode mode is\n///    enabled.\npub fn is_utf8(&self) -> bool{\n        match *self {\n            Class::Unicode(_) => true,\n            Class::Bytes(ref x) => x.is_ascii(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::literal":["/// If this class consists of exactly one element (whether a codepoint or a\n/// byte), then return it as a literal byte string.\n///\n/// If this class is empty or contains more than one element, then `None`\n/// is returned.\npub fn literal(&self) -> Option<Vec<u8>>{\n        match *self {\n            Class::Unicode(ref x) => x.literal(),\n            Class::Bytes(ref x) => x.literal(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::maximum_len":["/// Returns the length, in bytes, of the longest string matched by this\n/// character class.\n///\n/// For non-empty byte oriented classes, this always returns `1`. For\n/// non-empty Unicode oriented classes, this can return `1`, `2`, `3` or\n/// `4`. For empty classes, `None` is returned. It is impossible for `0` to\n/// be returned.\n///\n/// # Example\n///\n/// This example shows some examples of regexes and their corresponding\n/// maximum length, if any.\n///\n/// ```\n/// use regex_syntax::{hir::Properties, parse};\n///\n/// // The empty string has a max length of 0.\n/// let hir = parse(r\"\")?;\n/// assert_eq!(Some(0), hir.properties().maximum_len());\n/// // As do other types of regexes that only match the empty string.\n/// let hir = parse(r\"^$\\b\\B\")?;\n/// assert_eq!(Some(0), hir.properties().maximum_len());\n/// // A regex that matches nothing has no maximum defined.\n/// let hir = parse(r\"[a&&b]\")?;\n/// assert_eq!(None, hir.properties().maximum_len());\n/// // Bounded repeats work as you expect.\n/// let hir = parse(r\"x{2,10}\")?;\n/// assert_eq!(Some(10), hir.properties().maximum_len());\n/// // An unbounded repeat means there is no maximum.\n/// let hir = parse(r\"x{2,}\")?;\n/// assert_eq!(None, hir.properties().maximum_len());\n/// // With Unicode enabled, \\w can match up to 4 bytes!\n/// let hir = parse(r\"\\w\")?;\n/// assert_eq!(Some(4), hir.properties().maximum_len());\n/// // Without Unicode enabled, \\w matches at most 1 byte.\n/// let hir = parse(r\"(?-u)\\w\")?;\n/// assert_eq!(Some(1), hir.properties().maximum_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\npub fn maximum_len(&self) -> Option<usize>{\n        match *self {\n            Class::Unicode(ref x) => x.maximum_len(),\n            Class::Bytes(ref x) => x.maximum_len(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::minimum_len":["/// Returns the length, in bytes, of the smallest string matched by this\n/// character class.\n///\n/// For non-empty byte oriented classes, this always returns `1`. For\n/// non-empty Unicode oriented classes, this can return `1`, `2`, `3` or\n/// `4`. For empty classes, `None` is returned. It is impossible for `0` to\n/// be returned.\n///\n/// # Example\n///\n/// This example shows some examples of regexes and their corresponding\n/// minimum length, if any.\n///\n/// ```\n/// use regex_syntax::{hir::Properties, parse};\n///\n/// // The empty string has a min length of 0.\n/// let hir = parse(r\"\")?;\n/// assert_eq!(Some(0), hir.properties().minimum_len());\n/// // As do other types of regexes that only match the empty string.\n/// let hir = parse(r\"^$\\b\\B\")?;\n/// assert_eq!(Some(0), hir.properties().minimum_len());\n/// // A regex that can match the empty string but match more is still 0.\n/// let hir = parse(r\"a*\")?;\n/// assert_eq!(Some(0), hir.properties().minimum_len());\n/// // A regex that matches nothing has no minimum defined.\n/// let hir = parse(r\"[a&&b]\")?;\n/// assert_eq!(None, hir.properties().minimum_len());\n/// // Character classes usually have a minimum length of 1.\n/// let hir = parse(r\"\\w\")?;\n/// assert_eq!(Some(1), hir.properties().minimum_len());\n/// // But sometimes Unicode classes might be bigger!\n/// let hir = parse(r\"\\p{Cyrillic}\")?;\n/// assert_eq!(Some(2), hir.properties().minimum_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\npub fn minimum_len(&self) -> Option<usize>{\n        match *self {\n            Class::Unicode(ref x) => x.minimum_len(),\n            Class::Bytes(ref x) => x.minimum_len(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::negate":["/// Negate this character class in place.\n///\n/// After completion, this character class will contain precisely the\n/// characters that weren't previously in the class.\npub fn negate(&mut self){\n        match *self {\n            Class::Unicode(ref mut x) => x.negate(),\n            Class::Bytes(ref mut x) => x.negate(),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Class::try_case_fold_simple":["/// Apply Unicode simple case folding to this character class, in place.\n/// The character class will be expanded to include all simple case folded\n/// character variants.\n///\n/// If this is a byte oriented character class, then this will be limited\n/// to the ASCII ranges `A-Z` and `a-z`.\n///\n/// # Error\n///\n/// This routine returns an error when the case mapping data necessary\n/// for this routine to complete is unavailable. This occurs when the\n/// `unicode-case` feature is not enabled and the underlying class is\n/// Unicode oriented.\npub fn try_case_fold_simple(\n        &mut self,\n    ) -> core::result::Result<(), CaseFoldError>{\n        match *self {\n            Class::Unicode(ref mut x) => x.try_case_fold_simple()?,\n            Class::Bytes(ref mut x) => x.case_fold_simple(),\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes":["/// A set of characters represented by arbitrary bytes (where one byte\n/// corresponds to one character).\npub struct ClassBytes {\n    set: IntervalSet<ClassBytesRange>,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::case_fold_simple":["/// Expand this character class such that it contains all case folded\n/// characters. For example, if this class consists of the range `a-z`,\n/// then applying case folding will result in the class containing both the\n/// ranges `a-z` and `A-Z`.\n///\n/// Note that this only applies ASCII case folding, which is limited to the\n/// characters `a-z` and `A-Z`.\npub fn case_fold_simple(&mut self){\n        self.set.case_fold_simple().expect(\"ASCII case folding never fails\");\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::difference":["/// Subtract the given byte class from this byte class, in place.\npub fn difference(&mut self, other: &ClassBytes){\n        self.set.difference(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::empty":["/// Create a new class with no ranges.\n///\n/// An empty class matches nothing. That is, it is equivalent to\n/// [`Hir::fail`].\npub fn empty() -> ClassBytes{\n        ClassBytes::new(vec![])\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::intersect":["/// Intersect this byte class with the given byte class, in place.\npub fn intersect(&mut self, other: &ClassBytes){\n        self.set.intersect(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::is_ascii":["/// Returns true if and only if this character class will either match\n/// nothing or only ASCII bytes. Stated differently, this returns false\n/// if and only if this class contains a non-ASCII byte.\npub fn is_ascii(&self) -> bool{\n        self.set.intervals().last().map_or(true, |r| r.end <= 0x7F)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::iter":["/// Return an iterator over all ranges in this class.\n///\n/// The iterator yields ranges in ascending order.\npub fn iter(&self) -> ClassBytesIter<'_>{\n        ClassBytesIter(self.set.iter())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::literal":["/// If this class consists of exactly one byte, then return it as\n/// a literal byte string.\n///\n/// If this class is empty or contains more than one byte, then `None`\n/// is returned.\npub fn literal(&self) -> Option<Vec<u8>>{\n        let rs = self.ranges();\n        if rs.len() == 1 && rs[0].start == rs[0].end {\n            Some(vec![rs[0].start])\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::maximum_len":["/// Returns the length, in bytes, of the longest string matched by this\n/// character class.\n///\n/// Returns `None` when the class is empty.\npub fn maximum_len(&self) -> Option<usize>{\n        if self.ranges().is_empty() {\n            None\n        } else {\n            Some(1)\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::minimum_len":["/// Returns the length, in bytes, of the smallest string matched by this\n/// character class.\n///\n/// Returns `None` when the class is empty.\npub fn minimum_len(&self) -> Option<usize>{\n        if self.ranges().is_empty() {\n            None\n        } else {\n            Some(1)\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::negate":["/// Negate this byte class.\n///\n/// For all `b` where `b` is a any byte, if `b` was in this set, then it\n/// will not be in this set after negation.\npub fn negate(&mut self){\n        self.set.negate();\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::new":["/// Create a new class from a sequence of ranges.\n///\n/// The given ranges do not need to be in any specific order, and ranges\n/// may overlap. Ranges will automatically be sorted into a canonical\n/// non-overlapping order.\npub fn new<I>(ranges: I) -> ClassBytes\n    where\n        I: IntoIterator<Item = ClassBytesRange>,{\n        ClassBytes { set: IntervalSet::new(ranges) }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::push":["/// Add a new range to this set.\npub fn push(&mut self, range: ClassBytesRange){\n        self.set.push(range);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::ranges":["/// Return the underlying ranges as a slice.\npub fn ranges(&self) -> &[ClassBytesRange]{\n        self.set.intervals()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::symmetric_difference":["/// Compute the symmetric difference of the given byte classes, in place.\n///\n/// This computes the symmetric difference of two byte classes. This\n/// removes all elements in this class that are also in the given class,\n/// but all adds all elements from the given class that aren't in this\n/// class. That is, the class will contain all elements in either class,\n/// but will not contain any elements that are in both classes.\npub fn symmetric_difference(&mut self, other: &ClassBytes){\n        self.set.symmetric_difference(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::to_unicode_class":["/// If this class consists of only ASCII ranges, then return its\n/// corresponding and equivalent Unicode class.\npub fn to_unicode_class(&self) -> Option<ClassUnicode>{\n        if !self.is_ascii() {\n            return None;\n        }\n        Some(ClassUnicode::new(self.ranges().iter().map(|r| {\n            // Since we are guaranteed that our byte range is ASCII, the\n            // 'char::from' calls below are correct and will not erroneously\n            // convert a raw byte value into its corresponding codepoint.\n            ClassUnicodeRange {\n                start: char::from(r.start),\n                end: char::from(r.end),\n            }\n        })))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytes::union":["/// Union this byte class with the given byte class, in place.\npub fn union(&mut self, other: &ClassBytes){\n        self.set.union(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesIter":["/// An iterator over all ranges in a byte character class.\n///\n/// The lifetime `'a` refers to the lifetime of the underlying class.\npub struct ClassBytesIter<'a>(IntervalSetIter<'a, ClassBytesRange>);","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesRange":["/// A single range of characters represented by arbitrary bytes.\n///\n/// The range is closed. That is, the start and end of the range are included\n/// in the range.\npub struct ClassBytesRange {\n    start: u8,\n    end: u8,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesRange::end":["/// Return the end of this range.\n///\n/// The end of a range is always greater than or equal to the start of the\n/// range.\npub fn end(&self) -> u8{\n        self.end\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesRange::len":["/// Returns the number of bytes in this range.\npub fn len(&self) -> usize{\n        usize::from(self.end.checked_sub(self.start).unwrap())\n            .checked_add(1)\n            .unwrap()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesRange::new":["/// Create a new byte range for a character class.\n///\n/// The returned range is always in a canonical form. That is, the range\n/// returned always satisfies the invariant that `start <= end`.\npub fn new(start: u8, end: u8) -> ClassBytesRange{\n        ClassBytesRange::create(start, end)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassBytesRange::start":["/// Return the start of this range.\n///\n/// The start of a range is always less than or equal to the end of the\n/// range.\npub fn start(&self) -> u8{\n        self.start\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode":["/// A set of characters represented by Unicode scalar values.\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::case_fold_simple":["/// Expand this character class such that it contains all case folded\n/// characters, according to Unicode's \"simple\" mapping. For example, if\n/// this class consists of the range `a-z`, then applying case folding will\n/// result in the class containing both the ranges `a-z` and `A-Z`.\n///\n/// # Panics\n///\n/// This routine panics when the case mapping data necessary for this\n/// routine to complete is unavailable. This occurs when the `unicode-case`\n/// feature is not enabled.\n///\n/// Callers should prefer using `try_case_fold_simple` instead, which will\n/// return an error instead of panicking.\npub fn case_fold_simple(&mut self){\n        self.set\n            .case_fold_simple()\n            .expect(\"unicode-case feature must be enabled\");\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::difference":["/// Subtract the given character class from this character class, in place.\npub fn difference(&mut self, other: &ClassUnicode){\n        self.set.difference(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::empty":["/// Create a new class with no ranges.\n///\n/// An empty class matches nothing. That is, it is equivalent to\n/// [`Hir::fail`].\npub fn empty() -> ClassUnicode{\n        ClassUnicode::new(vec![])\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::intersect":["/// Intersect this character class with the given character class, in\n/// place.\npub fn intersect(&mut self, other: &ClassUnicode){\n        self.set.intersect(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::is_ascii":["/// Returns true if and only if this character class will either match\n/// nothing or only ASCII bytes. Stated differently, this returns false\n/// if and only if this class contains a non-ASCII codepoint.\npub fn is_ascii(&self) -> bool{\n        self.set.intervals().last().map_or(true, |r| r.end <= '\\x7F')\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::iter":["/// Return an iterator over all ranges in this class.\n///\n/// The iterator yields ranges in ascending order.\npub fn iter(&self) -> ClassUnicodeIter<'_>{\n        ClassUnicodeIter(self.set.iter())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::literal":["/// If this class consists of exactly one codepoint, then return it as\n/// a literal byte string.\n///\n/// If this class is empty or contains more than one codepoint, then `None`\n/// is returned.\npub fn literal(&self) -> Option<Vec<u8>>{\n        let rs = self.ranges();\n        if rs.len() == 1 && rs[0].start == rs[0].end {\n            Some(rs[0].start.encode_utf8(&mut [0; 4]).to_string().into_bytes())\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::maximum_len":["/// Returns the length, in bytes, of the longest string matched by this\n/// character class.\n///\n/// Returns `None` when the class is empty.\npub fn maximum_len(&self) -> Option<usize>{\n        let last = self.ranges().last()?;\n        // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().\n        Some(last.end.len_utf8())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::minimum_len":["/// Returns the length, in bytes, of the smallest string matched by this\n/// character class.\n///\n/// Returns `None` when the class is empty.\npub fn minimum_len(&self) -> Option<usize>{\n        let first = self.ranges().get(0)?;\n        // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().\n        Some(first.start.len_utf8())\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::negate":["/// Negate this character class.\n///\n/// For all `c` where `c` is a Unicode scalar value, if `c` was in this\n/// set, then it will not be in this set after negation.\npub fn negate(&mut self){\n        self.set.negate();\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::new":["/// Create a new class from a sequence of ranges.\n///\n/// The given ranges do not need to be in any specific order, and ranges\n/// may overlap. Ranges will automatically be sorted into a canonical\n/// non-overlapping order.\npub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,{\n        ClassUnicode { set: IntervalSet::new(ranges) }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::push":["/// Add a new range to this set.\npub fn push(&mut self, range: ClassUnicodeRange){\n        self.set.push(range);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::ranges":["/// Return the underlying ranges as a slice.\npub fn ranges(&self) -> &[ClassUnicodeRange]{\n        self.set.intervals()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::symmetric_difference":["/// Compute the symmetric difference of the given character classes, in\n/// place.\n///\n/// This computes the symmetric difference of two character classes. This\n/// removes all elements in this class that are also in the given class,\n/// but all adds all elements from the given class that aren't in this\n/// class. That is, the class will contain all elements in either class,\n/// but will not contain any elements that are in both classes.\npub fn symmetric_difference(&mut self, other: &ClassUnicode){\n        self.set.symmetric_difference(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::to_byte_class":["/// If this class consists of only ASCII ranges, then return its\n/// corresponding and equivalent byte class.\npub fn to_byte_class(&self) -> Option<ClassBytes>{\n        if !self.is_ascii() {\n            return None;\n        }\n        Some(ClassBytes::new(self.ranges().iter().map(|r| {\n            // Since we are guaranteed that our codepoint range is ASCII, the\n            // 'u8::try_from' calls below are guaranteed to be correct.\n            ClassBytesRange {\n                start: u8::try_from(r.start).unwrap(),\n                end: u8::try_from(r.end).unwrap(),\n            }\n        })))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::try_case_fold_simple":["/// Expand this character class such that it contains all case folded\n/// characters, according to Unicode's \"simple\" mapping. For example, if\n/// this class consists of the range `a-z`, then applying case folding will\n/// result in the class containing both the ranges `a-z` and `A-Z`.\n///\n/// # Error\n///\n/// This routine returns an error when the case mapping data necessary\n/// for this routine to complete is unavailable. This occurs when the\n/// `unicode-case` feature is not enabled.\npub fn try_case_fold_simple(\n        &mut self,\n    ) -> core::result::Result<(), CaseFoldError>{\n        self.set.case_fold_simple()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicode::union":["/// Union this character class with the given character class, in place.\npub fn union(&mut self, other: &ClassUnicode){\n        self.set.union(&other.set);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeIter":["/// An iterator over all ranges in a Unicode character class.\n///\n/// The lifetime `'a` refers to the lifetime of the underlying class.\npub struct ClassUnicodeIter<'a>(IntervalSetIter<'a, ClassUnicodeRange>);","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeRange":["/// A single range of characters represented by Unicode scalar values.\n///\n/// The range is closed. That is, the start and end of the range are included\n/// in the range.\npub struct ClassUnicodeRange {\n    start: char,\n    end: char,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeRange::end":["/// Return the end of this range.\n///\n/// The end of a range is always greater than or equal to the start of the\n/// range.\npub fn end(&self) -> char{\n        self.end\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeRange::len":["/// Returns the number of codepoints in this range.\npub fn len(&self) -> usize{\n        let diff = 1 + u32::from(self.end) - u32::from(self.start);\n        // This is likely to panic in 16-bit targets since a usize can only fit\n        // 2^16. It's not clear what to do here, other than to return an error\n        // when building a Unicode class that contains a range whose length\n        // overflows usize. (Which, to be honest, is probably quite common on\n        // 16-bit targets. For example, this would imply that '.' and '\\p{any}'\n        // would be impossible to build.)\n        usize::try_from(diff).expect(\"char class len fits in usize\")\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeRange::new":["/// Create a new Unicode scalar value range for a character class.\n///\n/// The returned range is always in a canonical form. That is, the range\n/// returned always satisfies the invariant that `start <= end`.\npub fn new(start: char, end: char) -> ClassUnicodeRange{\n        ClassUnicodeRange::create(start, end)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ClassUnicodeRange::start":["/// Return the start of this range.\n///\n/// The start of a range is always less than or equal to the end of the\n/// range.\npub fn start(&self) -> char{\n        self.start\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Dot":["/// A type describing the different flavors of `.`.\n///\n/// This type is meant to be used with [`Hir::dot`], which is a convenience\n/// routine for building HIR values derived from the `.` regex.\n#[non_exhaustive]\npub enum Dot {\n    /// Matches the UTF-8 encoding of any Unicode scalar value.\n    ///\n    /// This is equivalent to `(?su:.)` and also `\\p{any}`.\n    AnyChar,\n    /// Matches any byte value.\n    ///\n    /// This is equivalent to `(?s-u:.)` and also `(?-u:[\\x00-\\xFF])`.\n    AnyByte,\n    /// Matches the UTF-8 encoding of any Unicode scalar value except for `\\n`.\n    ///\n    /// This is equivalent to `(?u-s:.)` and also `[\\p{any}--\\n]`.\n    AnyCharExceptLF,\n    /// Matches the UTF-8 encoding of any Unicode scalar value except for `\\r`\n    /// and `\\n`.\n    ///\n    /// This is equivalent to `(?uR-s:.)` and also `[\\p{any}--\\r\\n]`.\n    AnyCharExceptCRLF,\n    /// Matches any byte value except for `\\n`.\n    ///\n    /// This is equivalent to `(?-su:.)` and also `(?-u:[[\\x00-\\xFF]--\\n])`.\n    AnyByteExceptLF,\n    /// Matches any byte value except for `\\r` and `\\n`.\n    ///\n    /// This is equivalent to `(?R-su:.)` and also `(?-u:[[\\x00-\\xFF]--\\r\\n])`.\n    AnyByteExceptCRLF,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Error":["/// An error that can occur while translating an `Ast` to a `Hir`.\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the translator's Ast was parsed from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error, derived from the Ast given to the translator.\n    span: Span,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Error::kind":["/// Return the type of this error.\npub fn kind(&self) -> &ErrorKind{\n        &self.kind\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Error::pattern":["/// The original pattern string in which this error occurred.\n///\n/// Every span reported by this error is reported in terms of this string.\npub fn pattern(&self) -> &str{\n        &self.pattern\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Error::span":["/// Return the span at which this error occurred.\npub fn span(&self) -> &Span{\n        &self.span\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::ErrorKind":["/// The type of an error that occurred while building an `Hir`.\n///\n/// This error type is marked as `non_exhaustive`. This means that adding a\n/// new variant is not considered a breaking change.\n#[non_exhaustive]\npub enum ErrorKind {\n    /// This error occurs when a Unicode feature is used when Unicode\n    /// support is disabled. For example `(?-u:\\pL)` would trigger this error.\n    UnicodeNotAllowed,\n    /// This error occurs when translating a pattern that could match a byte\n    /// sequence that isn't UTF-8 and `utf8` was enabled.\n    InvalidUtf8,\n    /// This occurs when an unrecognized Unicode property name could not\n    /// be found.\n    UnicodePropertyNotFound,\n    /// This occurs when an unrecognized Unicode property value could not\n    /// be found.\n    UnicodePropertyValueNotFound,\n    /// This occurs when a Unicode-aware Perl character class (`\\w`, `\\s` or\n    /// `\\d`) could not be found. This can occur when the `unicode-perl`\n    /// crate feature is not enabled.\n    UnicodePerlClassNotFound,\n    /// This occurs when the Unicode simple case mapping tables are not\n    /// available, and the regular expression required Unicode aware case\n    /// insensitivity.\n    UnicodeCaseUnavailable,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir":["/// A high-level intermediate representation (HIR) for a regular expression.\n///\n/// An HIR value is a combination of a [`HirKind`] and a set of [`Properties`].\n/// An `HirKind` indicates what kind of regular expression it is (a literal,\n/// a repetition, a look-around assertion, etc.), where as a `Properties`\n/// describes various facts about the regular expression. For example, whether\n/// it matches UTF-8 or if it matches the empty string.\n///\n/// The HIR of a regular expression represents an intermediate step between\n/// its abstract syntax (a structured description of the concrete syntax) and\n/// an actual regex matcher. The purpose of HIR is to make regular expressions\n/// easier to analyze. In particular, the AST is much more complex than the\n/// HIR. For example, while an AST supports arbitrarily nested character\n/// classes, the HIR will flatten all nested classes into a single set. The HIR\n/// will also \"compile away\" every flag present in the concrete syntax. For\n/// example, users of HIR expressions never need to worry about case folding;\n/// it is handled automatically by the translator (e.g., by translating\n/// `(?i:A)` to `[aA]`).\n///\n/// The specific type of an HIR expression can be accessed via its `kind`\n/// or `into_kind` methods. This extra level of indirection exists for two\n/// reasons:\n///\n/// 1. Construction of an HIR expression *must* use the constructor methods on\n/// this `Hir` type instead of building the `HirKind` values directly. This\n/// permits construction to enforce invariants like \"concatenations always\n/// consist of two or more sub-expressions.\"\n/// 2. Every HIR expression contains attributes that are defined inductively,\n/// and can be computed cheaply during the construction process. For example,\n/// one such attribute is whether the expression must match at the beginning of\n/// the haystack.\n///\n/// In particular, if you have an `HirKind` value, then there is intentionally\n/// no way to build an `Hir` value from it. You instead need to do case\n/// analysis on the `HirKind` value and build the `Hir` value using its smart\n/// constructors.\n///\n/// # UTF-8\n///\n/// If the HIR was produced by a translator with\n/// [`TranslatorBuilder::utf8`](translate::TranslatorBuilder::utf8) enabled,\n/// then the HIR is guaranteed to match UTF-8 exclusively for all non-empty\n/// matches.\n///\n/// For empty matches, those can occur at any position. It is the\n/// repsonsibility of the regex engine to determine whether empty matches are\n/// permitted between the code units of a single codepoint.\n///\n/// # Stack space\n///\n/// This type defines its own destructor that uses constant stack space and\n/// heap space proportional to the size of the HIR.\n///\n/// Also, an `Hir`'s `fmt::Display` implementation prints an HIR as a regular\n/// expression pattern string, and uses constant stack space and heap space\n/// proportional to the size of the `Hir`. The regex it prints is guaranteed to\n/// be _semantically_ equivalent to the original concrete syntax, but it may\n/// look very different. (And potentially not practically readable by a human.)\n///\n/// An `Hir`'s `fmt::Debug` implementation currently does not use constant\n/// stack space. The implementation will also suppress some details (such as\n/// the `Properties` inlined into every `Hir` value to make it less noisy).\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    props: Properties,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::alternation":["/// Returns the alternation of the given expressions.\n///\n/// This flattens and simplifies the alternation as appropriate. This may\n/// include factoring out common prefixes or even rewriting the alternation\n/// as a character class.\n///\n/// Note that an empty alternation is equivalent to `Hir::fail()`. (It\n/// is not possible for one to write an empty alternation, or even an\n/// alternation with a single sub-expression, in the concrete syntax of a\n/// regex.)\n///\n/// # Example\n///\n/// This is a simple example showing how an alternation might get\n/// simplified.\n///\n/// ```\n/// use regex_syntax::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};\n///\n/// let hir = Hir::alternation(vec![\n///     Hir::literal([b'a']),\n///     Hir::literal([b'b']),\n///     Hir::literal([b'c']),\n///     Hir::literal([b'd']),\n///     Hir::literal([b'e']),\n///     Hir::literal([b'f']),\n/// ]);\n/// let expected = Hir::class(Class::Unicode(ClassUnicode::new([\n///     ClassUnicodeRange::new('a', 'f'),\n/// ])));\n/// assert_eq!(expected, hir);\n/// ```\n///\n/// And another example showing how common prefixes might get factored\n/// out.\n///\n/// ```\n/// use regex_syntax::hir::{Hir, Class, ClassUnicode, ClassUnicodeRange};\n///\n/// let hir = Hir::alternation(vec![\n///     Hir::concat(vec![\n///         Hir::literal(\"abc\".as_bytes()),\n///         Hir::class(Class::Unicode(ClassUnicode::new([\n///             ClassUnicodeRange::new('A', 'Z'),\n///         ]))),\n///     ]),\n///     Hir::concat(vec![\n///         Hir::literal(\"abc\".as_bytes()),\n///         Hir::class(Class::Unicode(ClassUnicode::new([\n///             ClassUnicodeRange::new('a', 'z'),\n///         ]))),\n///     ]),\n/// ]);\n/// let expected = Hir::concat(vec![\n///     Hir::literal(\"abc\".as_bytes()),\n///     Hir::alternation(vec![\n///         Hir::class(Class::Unicode(ClassUnicode::new([\n///             ClassUnicodeRange::new('A', 'Z'),\n///         ]))),\n///         Hir::class(Class::Unicode(ClassUnicode::new([\n///             ClassUnicodeRange::new('a', 'z'),\n///         ]))),\n///     ]),\n/// ]);\n/// assert_eq!(expected, hir);\n/// ```\n///\n/// Note that these sorts of simplifications are not guaranteed.\npub fn alternation(subs: Vec<Hir>) -> Hir{\n        // We rebuild the alternation by simplifying it. We proceed similarly\n        // as the concatenation case. But in this case, there's no literal\n        // simplification happening. We're just flattening alternations.\n        let mut new = vec![];\n        for sub in subs {\n            let (kind, props) = sub.into_parts();\n            match kind {\n                HirKind::Alternation(subs2) => {\n                    new.extend(subs2);\n                }\n                kind => {\n                    new.push(Hir { kind, props });\n                }\n            }\n        }\n        if new.is_empty() {\n            return Hir::fail();\n        } else if new.len() == 1 {\n            return new.pop().unwrap();\n        }\n        // Now that it's completely flattened, look for the special case of\n        // 'char1|char2|...|charN' and collapse that into a class. Note that\n        // we look for 'char' first and then bytes. The issue here is that if\n        // we find both non-ASCII codepoints and non-ASCII singleton bytes,\n        // then it isn't actually possible to smush them into a single class.\n        // (Because classes are either \"all codepoints\" or \"all bytes.\" You\n        // can have a class that both matches non-ASCII but valid UTF-8 and\n        // invalid UTF-8.) So we look for all chars and then all bytes, and\n        // don't handle anything else.\n        if let Some(singletons) = singleton_chars(&new) {\n            let it = singletons\n                .into_iter()\n                .map(|ch| ClassUnicodeRange { start: ch, end: ch });\n            return Hir::class(Class::Unicode(ClassUnicode::new(it)));\n        }\n        if let Some(singletons) = singleton_bytes(&new) {\n            let it = singletons\n                .into_iter()\n                .map(|b| ClassBytesRange { start: b, end: b });\n            return Hir::class(Class::Bytes(ClassBytes::new(it)));\n        }\n        // Similar to singleton chars, we can also look for alternations of\n        // classes. Those can be smushed into a single class.\n        if let Some(cls) = class_chars(&new) {\n            return Hir::class(cls);\n        }\n        if let Some(cls) = class_bytes(&new) {\n            return Hir::class(cls);\n        }\n        // Factor out a common prefix if we can, which might potentially\n        // simplify the expression and unlock other optimizations downstream.\n        // It also might generally make NFA matching and DFA construction\n        // faster by reducing the scope of branching in the regex.\n        new = match lift_common_prefix(new) {\n            Ok(hir) => return hir,\n            Err(unchanged) => unchanged,\n        };\n        let props = Properties::alternation(&new);\n        Hir { kind: HirKind::Alternation(new), props }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::capture":["/// Creates a capture HIR expression.\n///\n/// Note that there is no explicit HIR value for a non-capturing group.\n/// Since a non-capturing group only exists to override precedence in the\n/// concrete syntax and since an HIR already does its own grouping based on\n/// what is parsed, there is no need to explicitly represent non-capturing\n/// groups in the HIR.\n#[inline]\npub fn capture(capture: Capture) -> Hir{\n        let props = Properties::capture(&capture);\n        Hir { kind: HirKind::Capture(capture), props }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::class":["/// Creates a class HIR expression. The class may either be defined over\n/// ranges of Unicode codepoints or ranges of raw byte values.\n///\n/// Note that an empty class is permitted. An empty class is equivalent to\n/// `Hir::fail()`.\n#[inline]\npub fn class(class: Class) -> Hir{\n        if class.is_empty() {\n            return Hir::fail();\n        } else if let Some(bytes) = class.literal() {\n            return Hir::literal(bytes);\n        }\n        let props = Properties::class(&class);\n        Hir { kind: HirKind::Class(class), props }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::concat":["/// Returns the concatenation of the given expressions.\n///\n/// This attempts to flatten and simplify the concatenation as appropriate.\n///\n/// # Example\n///\n/// This shows a simple example of basic flattening of both concatenations\n/// and literals.\n///\n/// ```\n/// use regex_syntax::hir::Hir;\n///\n/// let hir = Hir::concat(vec![\n///     Hir::concat(vec![\n///         Hir::literal([b'a']),\n///         Hir::literal([b'b']),\n///         Hir::literal([b'c']),\n///     ]),\n///     Hir::concat(vec![\n///         Hir::literal([b'x']),\n///         Hir::literal([b'y']),\n///         Hir::literal([b'z']),\n///     ]),\n/// ]);\n/// let expected = Hir::literal(\"abcxyz\".as_bytes());\n/// assert_eq!(expected, hir);\n/// ```\npub fn concat(subs: Vec<Hir>) -> Hir{\n        // We rebuild the concatenation by simplifying it. Would be nice to do\n        // it in place, but that seems a little tricky?\n        let mut new = vec![];\n        // This gobbles up any adjacent literals in a concatenation and smushes\n        // them together. Basically, when we see a literal, we add its bytes\n        // to 'prior_lit', and whenever we see anything else, we first take\n        // any bytes in 'prior_lit' and add it to the 'new' concatenation.\n        let mut prior_lit: Option<Vec<u8>> = None;\n        for sub in subs {\n            let (kind, props) = sub.into_parts();\n            match kind {\n                HirKind::Literal(Literal(bytes)) => {\n                    if let Some(ref mut prior_bytes) = prior_lit {\n                        prior_bytes.extend_from_slice(&bytes);\n                    } else {\n                        prior_lit = Some(bytes.to_vec());\n                    }\n                }\n                // We also flatten concats that are direct children of another\n                // concat. We only need to do this one level deep since\n                // Hir::concat is the only way to build concatenations, and so\n                // flattening happens inductively.\n                HirKind::Concat(subs2) => {\n                    for sub2 in subs2 {\n                        let (kind2, props2) = sub2.into_parts();\n                        match kind2 {\n                            HirKind::Literal(Literal(bytes)) => {\n                                if let Some(ref mut prior_bytes) = prior_lit {\n                                    prior_bytes.extend_from_slice(&bytes);\n                                } else {\n                                    prior_lit = Some(bytes.to_vec());\n                                }\n                            }\n                            kind2 => {\n                                if let Some(prior_bytes) = prior_lit.take() {\n                                    new.push(Hir::literal(prior_bytes));\n                                }\n                                new.push(Hir { kind: kind2, props: props2 });\n                            }\n                        }\n                    }\n                }\n                // We can just skip empty HIRs.\n                HirKind::Empty => {}\n                kind => {\n                    if let Some(prior_bytes) = prior_lit.take() {\n                        new.push(Hir::literal(prior_bytes));\n                    }\n                    new.push(Hir { kind, props });\n                }\n            }\n        }\n        if let Some(prior_bytes) = prior_lit.take() {\n            new.push(Hir::literal(prior_bytes));\n        }\n        if new.is_empty() {\n            return Hir::empty();\n        } else if new.len() == 1 {\n            return new.pop().unwrap();\n        }\n        let props = Properties::concat(&new);\n        Hir { kind: HirKind::Concat(new), props }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::dot":["/// Returns an HIR expression for `.`.\n///\n/// * [`Dot::AnyChar`] maps to `(?su-R:.)`.\n/// * [`Dot::AnyByte`] maps to `(?s-Ru:.)`.\n/// * [`Dot::AnyCharExceptLF`] maps to `(?u-Rs:.)`.\n/// * [`Dot::AnyCharExceptCRLF`] maps to `(?Ru-s:.)`.\n/// * [`Dot::AnyByteExceptLF`] maps to `(?-Rsu:.)`.\n/// * [`Dot::AnyByteExceptCRLF`] maps to `(?R-su:.)`.\n///\n/// # Example\n///\n/// Note that this is a convenience routine for constructing the correct\n/// character class based on the value of `Dot`. There is no explicit \"dot\"\n/// HIR value. It is just an abbreviation for a common character class.\n///\n/// ```\n/// use regex_syntax::hir::{Hir, Dot, Class, ClassBytes, ClassBytesRange};\n///\n/// let hir = Hir::dot(Dot::AnyByte);\n/// let expected = Hir::class(Class::Bytes(ClassBytes::new([\n///     ClassBytesRange::new(0x00, 0xFF),\n/// ])));\n/// assert_eq!(expected, hir);\n/// ```\n#[inline]\npub fn dot(dot: Dot) -> Hir{\n        match dot {\n            Dot::AnyChar => {\n                let mut cls = ClassUnicode::empty();\n                cls.push(ClassUnicodeRange::new('\\0', '\\u{10FFFF}'));\n                Hir::class(Class::Unicode(cls))\n            }\n            Dot::AnyByte => {\n                let mut cls = ClassBytes::empty();\n                cls.push(ClassBytesRange::new(b'\\0', b'\\xFF'));\n                Hir::class(Class::Bytes(cls))\n            }\n            Dot::AnyCharExceptLF => {\n                let mut cls = ClassUnicode::empty();\n                cls.push(ClassUnicodeRange::new('\\0', '\\x09'));\n                cls.push(ClassUnicodeRange::new('\\x0B', '\\u{10FFFF}'));\n                Hir::class(Class::Unicode(cls))\n            }\n            Dot::AnyCharExceptCRLF => {\n                let mut cls = ClassUnicode::empty();\n                cls.push(ClassUnicodeRange::new('\\0', '\\x09'));\n                cls.push(ClassUnicodeRange::new('\\x0B', '\\x0C'));\n                cls.push(ClassUnicodeRange::new('\\x0E', '\\u{10FFFF}'));\n                Hir::class(Class::Unicode(cls))\n            }\n            Dot::AnyByteExceptLF => {\n                let mut cls = ClassBytes::empty();\n                cls.push(ClassBytesRange::new(b'\\0', b'\\x09'));\n                cls.push(ClassBytesRange::new(b'\\x0B', b'\\xFF'));\n                Hir::class(Class::Bytes(cls))\n            }\n            Dot::AnyByteExceptCRLF => {\n                let mut cls = ClassBytes::empty();\n                cls.push(ClassBytesRange::new(b'\\0', b'\\x09'));\n                cls.push(ClassBytesRange::new(b'\\x0B', b'\\x0C'));\n                cls.push(ClassBytesRange::new(b'\\x0E', b'\\xFF'));\n                Hir::class(Class::Bytes(cls))\n            }\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::empty":["/// Returns an empty HIR expression.\n///\n/// An empty HIR expression always matches, including the empty string.\n#[inline]\npub fn empty() -> Hir{\n        let props = Properties::empty();\n        Hir { kind: HirKind::Empty, props }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::fail":["/// Returns an HIR expression that can never match anything. That is,\n/// the size of the set of strings in the language described by the HIR\n/// returned is `0`.\n///\n/// This is distinct from [`Hir::empty`] in that the empty string matches\n/// the HIR returned by `Hir::empty`. That is, the set of strings in the\n/// language describe described by `Hir::empty` is non-empty.\n///\n/// Note that currently, the HIR returned uses an empty character class to\n/// indicate that nothing can match. An equivalent expression that cannot\n/// match is an empty alternation, but all such \"fail\" expressions are\n/// normalized (via smart constructors) to empty character classes. This is\n/// because empty character classes can be spelled in the concrete syntax\n/// of a regex (e.g., `\\P{any}` or `(?-u:[^\\x00-\\xFF])` or `[a&&b]`), but\n/// empty alternations cannot.\n#[inline]\npub fn fail() -> Hir{\n        let class = Class::Bytes(ClassBytes::empty());\n        let props = Properties::class(&class);\n        // We can't just call Hir::class here because it defers to Hir::fail\n        // in order to canonicalize the Hir value used to represent \"cannot\n        // match.\"\n        Hir { kind: HirKind::Class(class), props }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::into_kind":["/// Consumes ownership of this HIR expression and returns its underlying\n/// `HirKind`.\npub fn into_kind(mut self) -> HirKind{\n        core::mem::replace(&mut self.kind, HirKind::Empty)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::into_parts":["/// Splits this HIR into its constituent parts.\n///\n/// This is useful because `let Hir { kind, props } = hir;` does not work\n/// because of `Hir`'s custom `Drop` implementation.\nfn into_parts(mut self) -> (HirKind, Properties){\n        (\n            core::mem::replace(&mut self.kind, HirKind::Empty),\n            core::mem::replace(&mut self.props, Properties::empty()),\n        )\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::kind":["/// Returns a reference to the underlying HIR kind.\npub fn kind(&self) -> &HirKind{\n        &self.kind\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::literal":["/// Creates a literal HIR expression.\n///\n/// This accepts anything that can be converted into a `Box<[u8]>`.\n///\n/// Note that there is no mechanism for storing a `char` or a `Box<str>`\n/// in an HIR. Everything is \"just bytes.\" Whether a `Literal` (or\n/// any HIR node) matches valid UTF-8 exclusively can be queried via\n/// [`Properties::is_utf8`].\n///\n/// # Example\n///\n/// This example shows that concatenations of `Literal` HIR values will\n/// automatically get flattened and combined together. So for example, even\n/// if you concat multiple `Literal` values that are themselves not valid\n/// UTF-8, they might add up to valid UTF-8. This also demonstrates just\n/// how \"smart\" Hir's smart constructors are.\n///\n/// ```\n/// use regex_syntax::hir::{Hir, HirKind, Literal};\n///\n/// let literals = vec![\n///     Hir::literal([0xE2]),\n///     Hir::literal([0x98]),\n///     Hir::literal([0x83]),\n/// ];\n/// // Each literal, on its own, is invalid UTF-8.\n/// assert!(literals.iter().all(|hir| !hir.properties().is_utf8()));\n///\n/// let concat = Hir::concat(literals);\n/// // But the concatenation is valid UTF-8!\n/// assert!(concat.properties().is_utf8());\n///\n/// // And also notice that the literals have been concatenated into a\n/// // single `Literal`, to the point where there is no explicit `Concat`!\n/// let expected = HirKind::Literal(Literal(Box::from(\"☃\".as_bytes())));\n/// assert_eq!(&expected, concat.kind());\n/// ```\n#[inline]\npub fn literal<B: Into<Box<[u8]>>>(lit: B) -> Hir{\n        let bytes = lit.into();\n        if bytes.is_empty() {\n            return Hir::empty();\n        }\n\n        let lit = Literal(bytes);\n        let props = Properties::literal(&lit);\n        Hir { kind: HirKind::Literal(lit), props }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::look":["/// Creates a look-around assertion HIR expression.\n#[inline]\npub fn look(look: Look) -> Hir{\n        let props = Properties::look(look);\n        Hir { kind: HirKind::Look(look), props }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::properties":["/// Returns the properties computed for this `Hir`.\npub fn properties(&self) -> &Properties{\n        &self.props\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Hir::repetition":["/// Creates a repetition HIR expression.\n#[inline]\npub fn repetition(rep: Repetition) -> Hir{\n        // The regex 'a{0}' is always equivalent to the empty regex. This is\n        // true even when 'a' is an expression that never matches anything\n        // (like '\\P{any}').\n        //\n        // Additionally, the regex 'a{1}' is always equivalent to 'a'.\n        if rep.min == 0 && rep.max == Some(0) {\n            return Hir::empty();\n        } else if rep.min == 1 && rep.max == Some(1) {\n            return *rep.sub;\n        }\n        let props = Properties::repetition(&rep);\n        Hir { kind: HirKind::Repetition(rep), props }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirKind":["/// The underlying kind of an arbitrary [`Hir`] expression.\n///\n/// An `HirKind` is principally useful for doing case analysis on the type\n/// of a regular expression. If you're looking to build new `Hir` values,\n/// then you _must_ use the smart constructors defined on `Hir`, like\n/// [`Hir::repetition`], to build new `Hir` values. The API intentionally does\n/// not expose any way of building an `Hir` directly from an `HirKind`.\npub enum HirKind {\n    /// The empty regular expression, which matches everything, including the\n    /// empty string.\n    Empty,\n    /// A literalstring that matches exactly these bytes.\n    Literal(Literal),\n    /// A single character class that matches any of the characters in the\n    /// class. A class can either consist of Unicode scalar values as\n    /// characters, or it can use bytes.\n    ///\n    /// A class may be empty. In which case, it matches nothing.\n    Class(Class),\n    /// A look-around assertion. A look-around match always has zero length.\n    Look(Look),\n    /// A repetition operation applied to a sub-expression.\n    Repetition(Repetition),\n    /// A capturing group, which contains a sub-expression.\n    Capture(Capture),\n    /// A concatenation of expressions.\n    ///\n    /// A concatenation matches only if each of its sub-expressions match one\n    /// after the other.\n    ///\n    /// Concatenations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Concat(Vec<Hir>),\n    /// An alternation of expressions.\n    ///\n    /// An alternation matches only if at least one of its sub-expressions\n    /// match. If multiple sub-expressions match, then the leftmost is\n    /// preferred.\n    ///\n    /// Alternations are guaranteed by `Hir`'s smart constructors to always\n    /// have at least two sub-expressions.\n    Alternation(Vec<Hir>),\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::HirKind::subs":["/// Returns a slice of this kind's sub-expressions, if any.\npub fn subs(&self) -> &[Hir]{\n        use core::slice::from_ref;\n\n        match *self {\n            HirKind::Empty\n            | HirKind::Literal(_)\n            | HirKind::Class(_)\n            | HirKind::Look(_) => &[],\n            HirKind::Repetition(Repetition { ref sub, .. }) => from_ref(sub),\n            HirKind::Capture(Capture { ref sub, .. }) => from_ref(sub),\n            HirKind::Concat(ref subs) => subs,\n            HirKind::Alternation(ref subs) => subs,\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Literal":["/// The high-level intermediate representation of a literal.\n///\n/// A literal corresponds to `0` or more bytes that should be matched\n/// literally. The smart constructors defined on `Hir` will automatically\n/// concatenate adjacent literals into one literal, and will even automatically\n/// replace empty literals with `Hir::empty()`.\n///\n/// Note that despite a literal being represented by a sequence of bytes, its\n/// `Debug` implementation will attempt to print it as a normal string. (That\n/// is, not a sequence of decimal numbers.)\npub struct Literal(pub Box<[u8]>);","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Look":["/// The high-level intermediate representation for a look-around assertion.\n///\n/// An assertion match is always zero-length. Also called an \"empty match.\"\npub enum Look {\n    /// Match the beginning of text. Specifically, this matches at the starting\n    /// position of the input.\n    Start = 1 << 0,\n    /// Match the end of text. Specifically, this matches at the ending\n    /// position of the input.\n    End = 1 << 1,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following a `\\n` character.\n    StartLF = 1 << 2,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\n` character.\n    EndLF = 1 << 3,\n    /// Match the beginning of a line or the beginning of text. Specifically,\n    /// this matches at the starting position of the input, or at the position\n    /// immediately following either a `\\r` or `\\n` character, but never after\n    /// a `\\r` when a `\\n` follows.\n    StartCRLF = 1 << 4,\n    /// Match the end of a line or the end of text. Specifically, this matches\n    /// at the end position of the input, or at the position immediately\n    /// preceding a `\\r` or `\\n` character, but never before a `\\n` when a `\\r`\n    /// precedes it.\n    EndCRLF = 1 << 5,\n    /// Match an ASCII-only word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    WordAscii = 1 << 6,\n    /// Match an ASCII-only negation of a word boundary.\n    WordAsciiNegate = 1 << 7,\n    /// Match a Unicode-aware word boundary. That is, this matches a position\n    /// where the left adjacent character and right adjacent character\n    /// correspond to a word and non-word or a non-word and word character.\n    WordUnicode = 1 << 8,\n    /// Match a Unicode-aware negation of a word boundary.\n    WordUnicodeNegate = 1 << 9,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Look::as_char":["/// Returns a convenient single codepoint representation of this\n/// look-around assertion. Each assertion is guaranteed to be represented\n/// by a distinct character.\n///\n/// This is useful for succinctly representing a look-around assertion in\n/// human friendly but succinct output intended for a programmer working on\n/// regex internals.\n#[inline]\npub const fn as_char(self) -> char{\n        match self {\n            Look::Start => 'A',\n            Look::End => 'z',\n            Look::StartLF => '^',\n            Look::EndLF => '$',\n            Look::StartCRLF => 'r',\n            Look::EndCRLF => 'R',\n            Look::WordAscii => 'b',\n            Look::WordAsciiNegate => 'B',\n            Look::WordUnicode => '𝛃',\n            Look::WordUnicodeNegate => '𝚩',\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Look::as_repr":["/// Return the underlying representation of this look-around enumeration\n/// as an integer. Giving the return value to the [`Look::from_repr`]\n/// constructor is guaranteed to return the same look-around variant that\n/// one started with within a semver compatible release of this crate.\n#[inline]\npub const fn as_repr(self) -> u16{\n        // AFAIK, 'as' is the only way to zero-cost convert an int enum to an\n        // actual int.\n        self as u16\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Look::from_repr":["/// Given the underlying representation of a `Look` value, return the\n/// corresponding `Look` value if the representation is valid. Otherwise\n/// `None` is returned.\n#[inline]\npub const fn from_repr(repr: u16) -> Option<Look>{\n        match repr {\n            0b00_0000_0001 => Some(Look::Start),\n            0b00_0000_0010 => Some(Look::End),\n            0b00_0000_0100 => Some(Look::StartLF),\n            0b00_0000_1000 => Some(Look::EndLF),\n            0b00_0001_0000 => Some(Look::StartCRLF),\n            0b00_0010_0000 => Some(Look::EndCRLF),\n            0b00_0100_0000 => Some(Look::WordAscii),\n            0b00_1000_0000 => Some(Look::WordAsciiNegate),\n            0b01_0000_0000 => Some(Look::WordUnicode),\n            0b10_0000_0000 => Some(Look::WordUnicodeNegate),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Look::reversed":["/// Flip the look-around assertion to its equivalent for reverse searches.\n/// For example, `StartLF` gets translated to `EndLF`.\n///\n/// Some assertions, such as `WordUnicode`, remain the same since they\n/// match the same positions regardless of the direction of the search.\n#[inline]\npub const fn reversed(self) -> Look{\n        match self {\n            Look::Start => Look::End,\n            Look::End => Look::Start,\n            Look::StartLF => Look::EndLF,\n            Look::EndLF => Look::StartLF,\n            Look::StartCRLF => Look::EndCRLF,\n            Look::EndCRLF => Look::StartCRLF,\n            Look::WordAscii => Look::WordAscii,\n            Look::WordAsciiNegate => Look::WordAsciiNegate,\n            Look::WordUnicode => Look::WordUnicode,\n            Look::WordUnicodeNegate => Look::WordUnicodeNegate,\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet":["/// A set of look-around assertions.\n///\n/// This is useful for efficiently tracking look-around assertions. For\n/// example, an [`Hir`] provides properties that return `LookSet`s.\npub struct LookSet {\n    /// The underlying representation this set is exposed to make it possible\n    /// to store it somewhere efficiently. The representation is that\n    /// of a bitset, where each assertion occupies bit `i` where `i =\n    /// Look::as_repr()`.\n    ///\n    /// Note that users of this internal representation must permit the full\n    /// range of `u16` values to be represented. For example, even if the\n    /// current implementation only makes use of the 10 least significant bits,\n    /// it may use more bits in a future semver compatible release.\n    pub bits: u16,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::contains":["/// Returns true if and only if the given look-around assertion is in this\n/// set.\n#[inline]\npub fn contains(self, look: Look) -> bool{\n        self.bits & look.as_repr() != 0\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::contains_anchor":["/// Returns true if and only if this set contains any anchor assertions.\n/// This includes both \"start/end of haystack\" and \"start/end of line.\"\n#[inline]\npub fn contains_anchor(&self) -> bool{\n        self.contains_anchor_haystack() || self.contains_anchor_line()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::contains_anchor_crlf":["/// Returns true if and only if this set contains any \"start/end of line\"\n/// anchors that are CRLF-aware. This doesn't include \"start/end of\n/// haystack\" or \"start/end of line-feed\" anchors.\n#[inline]\npub fn contains_anchor_crlf(&self) -> bool{\n        self.contains(Look::StartCRLF) || self.contains(Look::EndCRLF)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::contains_anchor_haystack":["/// Returns true if and only if this set contains any \"start/end of\n/// haystack\" anchors. This doesn't include \"start/end of line\" anchors.\n#[inline]\npub fn contains_anchor_haystack(&self) -> bool{\n        self.contains(Look::Start) || self.contains(Look::End)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::contains_anchor_lf":["/// Returns true if and only if this set contains any \"start/end of line\"\n/// anchors that only treat `\\n` as line terminators. This does not include\n/// haystack anchors or CRLF aware line anchors.\n#[inline]\npub fn contains_anchor_lf(&self) -> bool{\n        self.contains(Look::StartLF) || self.contains(Look::EndLF)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::contains_anchor_line":["/// Returns true if and only if this set contains any \"start/end of line\"\n/// anchors. This doesn't include \"start/end of haystack\" anchors. This\n/// includes both `\\n` line anchors and CRLF (`\\r\\n`) aware line anchors.\n#[inline]\npub fn contains_anchor_line(&self) -> bool{\n        self.contains(Look::StartLF)\n            || self.contains(Look::EndLF)\n            || self.contains(Look::StartCRLF)\n            || self.contains(Look::EndCRLF)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::contains_word":["/// Returns true if and only if this set contains any word boundary or\n/// negated word boundary assertions. This include both Unicode and ASCII\n/// word boundaries.\n#[inline]\npub fn contains_word(self) -> bool{\n        self.contains_word_unicode() || self.contains_word_ascii()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::contains_word_ascii":["/// Returns true if and only if this set contains any ASCII word boundary\n/// or negated ASCII word boundary assertions.\n#[inline]\npub fn contains_word_ascii(self) -> bool{\n        self.contains(Look::WordAscii) || self.contains(Look::WordAsciiNegate)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::contains_word_unicode":["/// Returns true if and only if this set contains any Unicode word boundary\n/// or negated Unicode word boundary assertions.\n#[inline]\npub fn contains_word_unicode(self) -> bool{\n        self.contains(Look::WordUnicode)\n            || self.contains(Look::WordUnicodeNegate)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::empty":["/// Create an empty set of look-around assertions.\n#[inline]\npub fn empty() -> LookSet{\n        LookSet { bits: 0 }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::full":["/// Create a full set of look-around assertions.\n///\n/// This set contains all possible look-around assertions.\n#[inline]\npub fn full() -> LookSet{\n        LookSet { bits: !0 }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::insert":["/// Return a new set that is equivalent to the original, but with the given\n/// assertion added to it. If the assertion is already in the set, then the\n/// returned set is equivalent to the original.\n#[inline]\npub fn insert(self, look: Look) -> LookSet{\n        LookSet { bits: self.bits | look.as_repr() }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::intersect":["/// Returns a new set that is the intersection of this and the one given.\n#[inline]\npub fn intersect(self, other: LookSet) -> LookSet{\n        LookSet { bits: self.bits & other.bits }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::is_empty":["/// Returns true if and only if this set is empty.\n#[inline]\npub fn is_empty(self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::iter":["/// Returns an iterator over all of the look-around assertions in this set.\n#[inline]\npub fn iter(self) -> LookSetIter{\n        LookSetIter { set: self }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::len":["/// Returns the total number of look-around assertions in this set.\n#[inline]\npub fn len(self) -> usize{\n        // OK because max value always fits in a u8, which in turn always\n        // fits in a usize, regardless of target.\n        usize::try_from(self.bits.count_ones()).unwrap()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::read_repr":["/// Return a `LookSet` from the slice given as a native endian 16-bit\n/// integer.\n///\n/// # Panics\n///\n/// This panics if `slice.len() < 2`.\n#[inline]\npub fn read_repr(slice: &[u8]) -> LookSet{\n        let bits = u16::from_ne_bytes(slice[..2].try_into().unwrap());\n        LookSet { bits }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::remove":["/// Return a new set that is equivalent to the original, but with the given\n/// assertion removed from it. If the assertion is not in the set, then the\n/// returned set is equivalent to the original.\n#[inline]\npub fn remove(self, look: Look) -> LookSet{\n        LookSet { bits: self.bits & !look.as_repr() }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::set_insert":["/// Updates this set in place with the result of inserting the given\n/// assertion into this set.\n#[inline]\npub fn set_insert(&mut self, look: Look){\n        *self = self.insert(look);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::set_intersect":["/// Updates this set in place with the result of intersecting it with the\n/// one given.\n#[inline]\npub fn set_intersect(&mut self, other: LookSet){\n        *self = self.intersect(other);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::set_remove":["/// Updates this set in place with the result of removing the given\n/// assertion from this set.\n#[inline]\npub fn set_remove(&mut self, look: Look){\n        *self = self.remove(look);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::set_subtract":["/// Updates this set in place with the result of subtracting the given set\n/// from this set.\n#[inline]\npub fn set_subtract(&mut self, other: LookSet){\n        *self = self.subtract(other);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::set_union":["/// Updates this set in place with the result of unioning it with the one\n/// given.\n#[inline]\npub fn set_union(&mut self, other: LookSet){\n        *self = self.union(other);\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::singleton":["/// Create a look-around set containing the look-around assertion given.\n///\n/// This is a convenience routine for creating an empty set and inserting\n/// one look-around assertions.\n#[inline]\npub fn singleton(look: Look) -> LookSet{\n        LookSet::empty().insert(look)\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::subtract":["/// Returns a new set that is the result of subtracting the given set from\n/// this set.\n#[inline]\npub fn subtract(self, other: LookSet) -> LookSet{\n        LookSet { bits: self.bits & !other.bits }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::union":["/// Returns a new set that is the union of this and the one given.\n#[inline]\npub fn union(self, other: LookSet) -> LookSet{\n        LookSet { bits: self.bits | other.bits }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSet::write_repr":["/// Write a `LookSet` as a native endian 16-bit integer to the beginning\n/// of the slice given.\n///\n/// # Panics\n///\n/// This panics if `slice.len() < 2`.\n#[inline]\npub fn write_repr(self, slice: &mut [u8]){\n        let raw = self.bits.to_ne_bytes();\n        slice[0] = raw[0];\n        slice[1] = raw[1];\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::LookSetIter":["/// An iterator over all look-around assertions in a [`LookSet`].\n///\n/// This iterator is created by [`LookSet::iter`].\npub struct LookSetIter {\n    set: LookSet,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties":["/// A type that collects various properties of an HIR value.\n///\n/// Properties are always scalar values and represent meta data that is\n/// computed inductively on an HIR value. Properties are defined for all\n/// HIR values.\n///\n/// All methods on a `Properties` value take constant time and are meant to\n/// be cheap to call.\npub struct Properties(Box<PropertiesI>);","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::alternation":["/// Create a new set of HIR properties for a concatenation.\nfn alternation(alts: &[Hir]) -> Properties{\n        Properties::union(alts.iter().map(|hir| hir.properties()))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::capture":["/// Create a new set of HIR properties for a capture.\nfn capture(capture: &Capture) -> Properties{\n        let p = capture.sub.properties();\n        Properties(Box::new(PropertiesI {\n            explicit_captures_len: p.explicit_captures_len().saturating_add(1),\n            static_explicit_captures_len: p\n                .static_explicit_captures_len()\n                .map(|len| len.saturating_add(1)),\n            literal: false,\n            alternation_literal: false,\n            ..*p.0.clone()\n        }))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::class":["/// Create a new set of HIR properties for a character class.\nfn class(class: &Class) -> Properties{\n        let inner = PropertiesI {\n            minimum_len: class.minimum_len(),\n            maximum_len: class.maximum_len(),\n            look_set: LookSet::empty(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: class.is_utf8(),\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: false,\n            alternation_literal: false,\n        };\n        Properties(Box::new(inner))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::concat":["/// Create a new set of HIR properties for a concatenation.\nfn concat(concat: &[Hir]) -> Properties{\n        // The base case is an empty concatenation, which matches the empty\n        // string. Note though that empty concatenations aren't possible,\n        // because the Hir::concat smart constructor rewrites those as\n        // Hir::empty.\n        let mut props = PropertiesI {\n            minimum_len: Some(0),\n            maximum_len: Some(0),\n            look_set: LookSet::empty(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: true,\n            alternation_literal: true,\n        };\n        // Handle properties that need to visit every child hir.\n        for x in concat.iter() {\n            let p = x.properties();\n            props.look_set.set_union(p.look_set());\n            props.utf8 = props.utf8 && p.is_utf8();\n            props.explicit_captures_len = props\n                .explicit_captures_len\n                .saturating_add(p.explicit_captures_len());\n            props.static_explicit_captures_len = p\n                .static_explicit_captures_len()\n                .and_then(|len1| {\n                    Some((len1, props.static_explicit_captures_len?))\n                })\n                .and_then(|(len1, len2)| Some(len1.saturating_add(len2)));\n            props.literal = props.literal && p.is_literal();\n            props.alternation_literal =\n                props.alternation_literal && p.is_alternation_literal();\n            if let Some(ref mut minimum_len) = props.minimum_len {\n                match p.minimum_len() {\n                    None => props.minimum_len = None,\n                    Some(len) => *minimum_len += len,\n                }\n            }\n            if let Some(ref mut maximum_len) = props.maximum_len {\n                match p.maximum_len() {\n                    None => props.maximum_len = None,\n                    Some(len) => *maximum_len += len,\n                }\n            }\n        }\n        // Handle the prefix properties, which only requires visiting\n        // child exprs until one matches more than the empty string.\n        let mut it = concat.iter();\n        while let Some(x) = it.next() {\n            props.look_set_prefix.set_union(x.properties().look_set_prefix());\n            props\n                .look_set_prefix_any\n                .set_union(x.properties().look_set_prefix_any());\n            if x.properties().maximum_len().map_or(true, |x| x > 0) {\n                break;\n            }\n        }\n        // Same thing for the suffix properties, but in reverse.\n        let mut it = concat.iter().rev();\n        while let Some(x) = it.next() {\n            props.look_set_suffix.set_union(x.properties().look_set_suffix());\n            props\n                .look_set_suffix_any\n                .set_union(x.properties().look_set_suffix_any());\n            if x.properties().maximum_len().map_or(true, |x| x > 0) {\n                break;\n            }\n        }\n        Properties(Box::new(props))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::empty":["/// Create a new set of HIR properties for an empty regex.\nfn empty() -> Properties{\n        let inner = PropertiesI {\n            minimum_len: Some(0),\n            maximum_len: Some(0),\n            look_set: LookSet::empty(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            // It is debatable whether an empty regex always matches at valid\n            // UTF-8 boundaries. Strictly speaking, at a byte oriented view,\n            // it is clearly false. There are, for example, many empty strings\n            // between the bytes encoding a '☃'.\n            //\n            // However, when Unicode mode is enabled, the fundamental atom\n            // of matching is really a codepoint. And in that scenario, an\n            // empty regex is defined to only match at valid UTF-8 boundaries\n            // and to never split a codepoint. It just so happens that this\n            // enforcement is somewhat tricky to do for regexes that match\n            // the empty string inside regex engines themselves. It usually\n            // requires some layer above the regex engine to filter out such\n            // matches.\n            //\n            // In any case, 'true' is really the only coherent option. If it\n            // were false, for example, then 'a*' would also need to be false\n            // since it too can match the empty string.\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: false,\n            alternation_literal: false,\n        };\n        Properties(Box::new(inner))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::explicit_captures_len":["/// Returns the total number of explicit capturing groups in the\n/// corresponding HIR.\n///\n/// Note that this does not include the implicit capturing group\n/// corresponding to the entire match that is typically included by regex\n/// engines.\n///\n/// # Example\n///\n/// This method will return `0` for `a` and `1` for `(a)`:\n///\n/// ```\n/// use regex_syntax::parse;\n///\n/// assert_eq!(0, parse(\"a\")?.properties().explicit_captures_len());\n/// assert_eq!(1, parse(\"(a)\")?.properties().explicit_captures_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n#[inline]\npub fn explicit_captures_len(&self) -> usize{\n        self.0.explicit_captures_len\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::is_alternation_literal":["/// Return true if and only if this HIR is either a simple literal or an\n/// alternation of simple literals. This is only\n/// true when this HIR expression is either itself a `Literal` or a\n/// concatenation of only `Literal`s or an alternation of only `Literal`s.\n///\n/// For example, `f`, `foo`, `a|b|c`, and `foo|bar|baz` are alternation\n/// literals, but `f+`, `(foo)`, `foo()`, and the empty pattern are not\n/// (even though that contain sub-expressions that are literals).\n#[inline]\npub fn is_alternation_literal(&self) -> bool{\n        self.0.alternation_literal\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::is_literal":["/// Return true if and only if this HIR is a simple literal. This is\n/// only true when this HIR expression is either itself a `Literal` or a\n/// concatenation of only `Literal`s.\n///\n/// For example, `f` and `foo` are literals, but `f+`, `(foo)`, `foo()` and\n/// the empty string are not (even though they contain sub-expressions that\n/// are literals).\n#[inline]\npub fn is_literal(&self) -> bool{\n        self.0.literal\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::is_utf8":["/// Return true if and only if the corresponding HIR will always match\n/// valid UTF-8.\n///\n/// When this returns false, then it is possible for this HIR expression to\n/// match invalid UTF-8, including by matching between the code units of\n/// a single UTF-8 encoded codepoint.\n///\n/// Note that this returns true even when the corresponding HIR can match\n/// the empty string. Since an empty string can technically appear between\n/// UTF-8 code units, it is possible for a match to be reported that splits\n/// a codepoint which could in turn be considered matching invalid UTF-8.\n/// However, it is generally assumed that such empty matches are handled\n/// specially by the search routine if it is absolutely required that\n/// matches not split a codepoint.\n///\n/// # Example\n///\n/// This code example shows the UTF-8 property of a variety of patterns.\n///\n/// ```\n/// use regex_syntax::{ParserBuilder, parse};\n///\n/// // Examples of 'is_utf8() == true'.\n/// assert!(parse(r\"a\")?.properties().is_utf8());\n/// assert!(parse(r\"[^a]\")?.properties().is_utf8());\n/// assert!(parse(r\".\")?.properties().is_utf8());\n/// assert!(parse(r\"\\W\")?.properties().is_utf8());\n/// assert!(parse(r\"\\b\")?.properties().is_utf8());\n/// assert!(parse(r\"\\B\")?.properties().is_utf8());\n/// assert!(parse(r\"(?-u)\\b\")?.properties().is_utf8());\n/// assert!(parse(r\"(?-u)\\B\")?.properties().is_utf8());\n/// // Unicode mode is enabled by default, and in\n/// // that mode, all \\x hex escapes are treated as\n/// // codepoints. So this actually matches the UTF-8\n/// // encoding of U+00FF.\n/// assert!(parse(r\"\\xFF\")?.properties().is_utf8());\n///\n/// // Now we show examples of 'is_utf8() == false'.\n/// // The only way to do this is to force the parser\n/// // to permit invalid UTF-8, otherwise all of these\n/// // would fail to parse!\n/// let parse = |pattern| {\n///     ParserBuilder::new().utf8(false).build().parse(pattern)\n/// };\n/// assert!(!parse(r\"(?-u)[^a]\")?.properties().is_utf8());\n/// assert!(!parse(r\"(?-u).\")?.properties().is_utf8());\n/// assert!(!parse(r\"(?-u)\\W\")?.properties().is_utf8());\n/// // Conversely to the equivalent example above,\n/// // when Unicode mode is disabled, \\x hex escapes\n/// // are treated as their raw byte values.\n/// assert!(!parse(r\"(?-u)\\xFF\")?.properties().is_utf8());\n/// // Note that just because we disabled UTF-8 in the\n/// // parser doesn't mean we still can't use Unicode.\n/// // It is enabled by default, so \\xFF is still\n/// // equivalent to matching the UTF-8 encoding of\n/// // U+00FF by default.\n/// assert!(parse(r\"\\xFF\")?.properties().is_utf8());\n/// // Even though we use raw bytes that individually\n/// // are not valid UTF-8, when combined together, the\n/// // overall expression *does* match valid UTF-8!\n/// assert!(parse(r\"(?-u)\\xE2\\x98\\x83\")?.properties().is_utf8());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n#[inline]\npub fn is_utf8(&self) -> bool{\n        self.0.utf8\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::literal":["/// Create a new set of HIR properties for a literal regex.\nfn literal(lit: &Literal) -> Properties{\n        let inner = PropertiesI {\n            minimum_len: Some(lit.0.len()),\n            maximum_len: Some(lit.0.len()),\n            look_set: LookSet::empty(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: core::str::from_utf8(&lit.0).is_ok(),\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: true,\n            alternation_literal: true,\n        };\n        Properties(Box::new(inner))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::look":["/// Create a new set of HIR properties for a look-around assertion.\nfn look(look: Look) -> Properties{\n        let inner = PropertiesI {\n            minimum_len: Some(0),\n            maximum_len: Some(0),\n            look_set: LookSet::singleton(look),\n            look_set_prefix: LookSet::singleton(look),\n            look_set_suffix: LookSet::singleton(look),\n            look_set_prefix_any: LookSet::singleton(look),\n            look_set_suffix_any: LookSet::singleton(look),\n            // This requires a little explanation. Basically, we don't consider\n            // matching an empty string to be equivalent to matching invalid\n            // UTF-8, even though technically matching every empty string will\n            // split the UTF-8 encoding of a single codepoint when treating a\n            // UTF-8 encoded string as a sequence of bytes. Our defense here is\n            // that in such a case, a codepoint should logically be treated as\n            // the fundamental atom for matching, and thus the only valid match\n            // points are between codepoints and not bytes.\n            //\n            // More practically, this is true here because it's also true\n            // for 'Hir::empty()', otherwise something like 'a*' would be\n            // considered to match invalid UTF-8. That in turn makes this\n            // property borderline useless.\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len: Some(0),\n            literal: false,\n            alternation_literal: false,\n        };\n        Properties(Box::new(inner))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::look_set":["/// Returns a set of all look-around assertions that appear at least once\n/// in this HIR value.\n#[inline]\npub fn look_set(&self) -> LookSet{\n        self.0.look_set\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::look_set_prefix":["/// Returns a set of all look-around assertions that appear as a prefix for\n/// this HIR value. That is, the set returned corresponds to the set of\n/// assertions that must be passed before matching any bytes in a haystack.\n///\n/// For example, `hir.look_set_prefix().contains(Look::Start)` returns true\n/// if and only if the HIR is fully anchored at the start.\n#[inline]\npub fn look_set_prefix(&self) -> LookSet{\n        self.0.look_set_prefix\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::look_set_prefix_any":["/// Returns a set of all look-around assertions that appear as a _possible_\n/// prefix for this HIR value. That is, the set returned corresponds to the\n/// set of assertions that _may_ be passed before matching any bytes in a\n/// haystack.\n///\n/// For example, `hir.look_set_prefix_any().contains(Look::Start)` returns\n/// true if and only if it's possible for the regex to match through a\n/// anchored assertion before consuming any input.\n#[inline]\npub fn look_set_prefix_any(&self) -> LookSet{\n        self.0.look_set_prefix_any\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::look_set_suffix":["/// Returns a set of all look-around assertions that appear as a suffix for\n/// this HIR value. That is, the set returned corresponds to the set of\n/// assertions that must be passed in order to be considered a match after\n/// all other consuming HIR expressions.\n///\n/// For example, `hir.look_set_suffix().contains(Look::End)` returns true\n/// if and only if the HIR is fully anchored at the end.\n#[inline]\npub fn look_set_suffix(&self) -> LookSet{\n        self.0.look_set_suffix\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::look_set_suffix_any":["/// Returns a set of all look-around assertions that appear as a _possible_\n/// suffix for this HIR value. That is, the set returned corresponds to the\n/// set of assertions that _may_ be passed before matching any bytes in a\n/// haystack.\n///\n/// For example, `hir.look_set_suffix_any().contains(Look::End)` returns\n/// true if and only if it's possible for the regex to match through a\n/// anchored assertion at the end of a match without consuming any input.\n#[inline]\npub fn look_set_suffix_any(&self) -> LookSet{\n        self.0.look_set_suffix_any\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::maximum_len":["/// Returns the length (in bytes) of the longest string matched by this\n/// HIR.\n///\n/// A return value of `0` is possible and occurs when nothing longer than\n/// the empty string is in the language described by this HIR.\n///\n/// `None` is returned when there is no longest matching string. This\n/// occurs when the HIR matches nothing or when there is no upper bound on\n/// the length of matching strings. Example of such regexes are `\\P{any}`\n/// (matches nothing) and `a+` (has no upper bound).\n#[inline]\npub fn maximum_len(&self) -> Option<usize>{\n        self.0.maximum_len\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::memory_usage":["/// Returns the total amount of heap memory usage, in bytes, used by this\n/// `Properties` value.\n#[inline]\npub fn memory_usage(&self) -> usize{\n        core::mem::size_of::<PropertiesI>()\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::minimum_len":["/// Returns the length (in bytes) of the smallest string matched by this\n/// HIR.\n///\n/// A return value of `0` is possible and occurs when the HIR can match an\n/// empty string.\n///\n/// `None` is returned when there is no minimum length. This occurs in\n/// precisely the cases where the HIR matches nothing. i.e., The language\n/// the regex matches is empty. An example of such a regex is `\\P{any}`.\n#[inline]\npub fn minimum_len(&self) -> Option<usize>{\n        self.0.minimum_len\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::repetition":["/// Create a new set of HIR properties for a repetition.\nfn repetition(rep: &Repetition) -> Properties{\n        let p = rep.sub.properties();\n        let minimum_len = p.minimum_len().map(|child_min| {\n            let rep_min = usize::try_from(rep.min).unwrap_or(usize::MAX);\n            child_min.saturating_mul(rep_min)\n        });\n        let maximum_len = rep.max.and_then(|rep_max| {\n            let rep_max = usize::try_from(rep_max).ok()?;\n            let child_max = p.maximum_len()?;\n            child_max.checked_mul(rep_max)\n        });\n\n        let mut inner = PropertiesI {\n            minimum_len,\n            maximum_len,\n            look_set: p.look_set(),\n            look_set_prefix: LookSet::empty(),\n            look_set_suffix: LookSet::empty(),\n            look_set_prefix_any: p.look_set_prefix_any(),\n            look_set_suffix_any: p.look_set_suffix_any(),\n            utf8: p.is_utf8(),\n            explicit_captures_len: p.explicit_captures_len(),\n            static_explicit_captures_len: p.static_explicit_captures_len(),\n            literal: false,\n            alternation_literal: false,\n        };\n        // If the repetition operator can match the empty string, then its\n        // lookset prefix and suffixes themselves remain empty since they are\n        // no longer required to match.\n        if rep.min > 0 {\n            inner.look_set_prefix = p.look_set_prefix();\n            inner.look_set_suffix = p.look_set_suffix();\n        }\n        // If the static captures len of the sub-expression is not known or is\n        // zero, then it automatically propagates to the repetition, regardless\n        // of the repetition. Otherwise, it might change, but only when the\n        // repetition can match 0 times.\n        if rep.min == 0\n            && inner.static_explicit_captures_len.map_or(false, |len| len > 0)\n        {\n            // If we require a match 0 times, then our captures len is\n            // guaranteed to be zero. Otherwise, if we *can* match the empty\n            // string, then it's impossible to know how many captures will be\n            // in the resulting match.\n            if rep.max == Some(0) {\n                inner.static_explicit_captures_len = Some(0);\n            } else {\n                inner.static_explicit_captures_len = None;\n            }\n        }\n        Properties(Box::new(inner))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::static_explicit_captures_len":["/// Returns the total number of explicit capturing groups that appear in\n/// every possible match.\n///\n/// If the number of capture groups can vary depending on the match, then\n/// this returns `None`. That is, a value is only returned when the number\n/// of matching groups is invariant or \"static.\"\n///\n/// Note that this does not include the implicit capturing group\n/// corresponding to the entire match.\n///\n/// # Example\n///\n/// This shows a few cases where a static number of capture groups is\n/// available and a few cases where it is not.\n///\n/// ```\n/// use regex_syntax::parse;\n///\n/// let len = |pattern| {\n///     parse(pattern).map(|h| {\n///         h.properties().static_explicit_captures_len()\n///     })\n/// };\n///\n/// assert_eq!(Some(0), len(\"a\")?);\n/// assert_eq!(Some(1), len(\"(a)\")?);\n/// assert_eq!(Some(1), len(\"(a)|(b)\")?);\n/// assert_eq!(Some(2), len(\"(a)(b)|(c)(d)\")?);\n/// assert_eq!(None, len(\"(a)|b\")?);\n/// assert_eq!(None, len(\"a|(b)\")?);\n/// assert_eq!(None, len(\"(b)*\")?);\n/// assert_eq!(Some(1), len(\"(b)+\")?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n#[inline]\npub fn static_explicit_captures_len(&self) -> Option<usize>{\n        self.0.static_explicit_captures_len\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Properties::union":["/// Returns a new set of properties that corresponds to the union of the\n/// iterator of properties given.\n///\n/// This is useful when one has multiple `Hir` expressions and wants\n/// to combine them into a single alternation without constructing the\n/// corresponding `Hir`. This routine provides a way of combining the\n/// properties of each `Hir` expression into one set of properties\n/// representing the union of those expressions.\n///\n/// # Example: union with HIRs that never match\n///\n/// This example shows that unioning properties together with one that\n/// represents a regex that never matches will \"poison\" certain attributes,\n/// like the minimum and maximum lengths.\n///\n/// ```\n/// use regex_syntax::{hir::Properties, parse};\n///\n/// let hir1 = parse(\"ab?c?\")?;\n/// assert_eq!(Some(1), hir1.properties().minimum_len());\n/// assert_eq!(Some(3), hir1.properties().maximum_len());\n///\n/// let hir2 = parse(r\"[a&&b]\")?;\n/// assert_eq!(None, hir2.properties().minimum_len());\n/// assert_eq!(None, hir2.properties().maximum_len());\n///\n/// let hir3 = parse(r\"wxy?z?\")?;\n/// assert_eq!(Some(2), hir3.properties().minimum_len());\n/// assert_eq!(Some(4), hir3.properties().maximum_len());\n///\n/// let unioned = Properties::union([\n///\t\thir1.properties(),\n///\t\thir2.properties(),\n///\t\thir3.properties(),\n///\t]);\n/// assert_eq!(None, unioned.minimum_len());\n/// assert_eq!(None, unioned.maximum_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// The maximum length can also be \"poisoned\" by a pattern that has no\n/// upper bound on the length of a match. The minimum length remains\n/// unaffected:\n///\n/// ```\n/// use regex_syntax::{hir::Properties, parse};\n///\n/// let hir1 = parse(\"ab?c?\")?;\n/// assert_eq!(Some(1), hir1.properties().minimum_len());\n/// assert_eq!(Some(3), hir1.properties().maximum_len());\n///\n/// let hir2 = parse(r\"a+\")?;\n/// assert_eq!(Some(1), hir2.properties().minimum_len());\n/// assert_eq!(None, hir2.properties().maximum_len());\n///\n/// let hir3 = parse(r\"wxy?z?\")?;\n/// assert_eq!(Some(2), hir3.properties().minimum_len());\n/// assert_eq!(Some(4), hir3.properties().maximum_len());\n///\n/// let unioned = Properties::union([\n///\t\thir1.properties(),\n///\t\thir2.properties(),\n///\t\thir3.properties(),\n///\t]);\n/// assert_eq!(Some(1), unioned.minimum_len());\n/// assert_eq!(None, unioned.maximum_len());\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\npub fn union<I, P>(props: I) -> Properties\n    where\n        I: IntoIterator<Item = P>,\n        P: core::borrow::Borrow<Properties>,{\n        let mut it = props.into_iter().peekable();\n        // While empty alternations aren't possible, we still behave as if they\n        // are. When we have an empty alternate, then clearly the look-around\n        // prefix and suffix is empty. Otherwise, it is the intersection of all\n        // prefixes and suffixes (respectively) of the branches.\n        let fix = if it.peek().is_none() {\n            LookSet::empty()\n        } else {\n            LookSet::full()\n        };\n        // And also, an empty alternate means we have 0 static capture groups,\n        // but we otherwise start with the number corresponding to the first\n        // alternate. If any subsequent alternate has a different number of\n        // static capture groups, then we overall have a variation and not a\n        // static number of groups.\n        let static_explicit_captures_len =\n            it.peek().and_then(|p| p.borrow().static_explicit_captures_len());\n        // The base case is an empty alternation, which matches nothing.\n        // Note though that empty alternations aren't possible, because the\n        // Hir::alternation smart constructor rewrites those as empty character\n        // classes.\n        let mut props = PropertiesI {\n            minimum_len: None,\n            maximum_len: None,\n            look_set: LookSet::empty(),\n            look_set_prefix: fix,\n            look_set_suffix: fix,\n            look_set_prefix_any: LookSet::empty(),\n            look_set_suffix_any: LookSet::empty(),\n            utf8: true,\n            explicit_captures_len: 0,\n            static_explicit_captures_len,\n            literal: false,\n            alternation_literal: true,\n        };\n        let (mut min_poisoned, mut max_poisoned) = (false, false);\n        // Handle properties that need to visit every child hir.\n        for prop in it {\n            let p = prop.borrow();\n            props.look_set.set_union(p.look_set());\n            props.look_set_prefix.set_intersect(p.look_set_prefix());\n            props.look_set_suffix.set_intersect(p.look_set_suffix());\n            props.look_set_prefix_any.set_union(p.look_set_prefix_any());\n            props.look_set_suffix_any.set_union(p.look_set_suffix_any());\n            props.utf8 = props.utf8 && p.is_utf8();\n            props.explicit_captures_len = props\n                .explicit_captures_len\n                .saturating_add(p.explicit_captures_len());\n            if props.static_explicit_captures_len\n                != p.static_explicit_captures_len()\n            {\n                props.static_explicit_captures_len = None;\n            }\n            props.alternation_literal =\n                props.alternation_literal && p.is_literal();\n            if !min_poisoned {\n                if let Some(xmin) = p.minimum_len() {\n                    if props.minimum_len.map_or(true, |pmin| xmin < pmin) {\n                        props.minimum_len = Some(xmin);\n                    }\n                } else {\n                    props.minimum_len = None;\n                    min_poisoned = true;\n                }\n            }\n            if !max_poisoned {\n                if let Some(xmax) = p.maximum_len() {\n                    if props.maximum_len.map_or(true, |pmax| xmax > pmax) {\n                        props.maximum_len = Some(xmax);\n                    }\n                } else {\n                    props.maximum_len = None;\n                    max_poisoned = true;\n                }\n            }\n        }\n        Properties(Box::new(props))\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::PropertiesI":["/// The property definition. It is split out so that we can box it, and\n/// there by make `Properties` use less stack size. This is kind-of important\n/// because every HIR value has a `Properties` attached to it.\n///\n/// This does have the unfortunate consequence that creating any HIR value\n/// always leads to at least one alloc for properties, but this is generally\n/// true anyway (for pretty much all HirKinds except for look-arounds).\nstruct PropertiesI {\n    minimum_len: Option<usize>,\n    maximum_len: Option<usize>,\n    look_set: LookSet,\n    look_set_prefix: LookSet,\n    look_set_suffix: LookSet,\n    look_set_prefix_any: LookSet,\n    look_set_suffix_any: LookSet,\n    utf8: bool,\n    explicit_captures_len: usize,\n    static_explicit_captures_len: Option<usize>,\n    literal: bool,\n    alternation_literal: bool,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Repetition":["/// The high-level intermediate representation of a repetition operator.\n///\n/// A repetition operator permits the repetition of an arbitrary\n/// sub-expression.\npub struct Repetition {\n    /// The minimum range of the repetition.\n    ///\n    /// Note that special cases like `?`, `+` and `*` all get translated into\n    /// the ranges `{0,1}`, `{1,}` and `{0,}`, respectively.\n    ///\n    /// When `min` is zero, this expression can match the empty string\n    /// regardless of what its sub-expression is.\n    pub min: u32,\n    /// The maximum range of the repetition.\n    ///\n    /// Note that when `max` is `None`, `min` acts as a lower bound but where\n    /// there is no upper bound. For something like `x{5}` where the min and\n    /// max are equivalent, `min` will be set to `5` and `max` will be set to\n    /// `Some(5)`.\n    pub max: Option<u32>,\n    /// Whether this repetition operator is greedy or not. A greedy operator\n    /// will match as much as it can. A non-greedy operator will match as\n    /// little as it can.\n    ///\n    /// Typically, operators are greedy by default and are only non-greedy when\n    /// a `?` suffix is used, e.g., `(expr)*` is greedy while `(expr)*?` is\n    /// not. However, this can be inverted via the `U` \"ungreedy\" flag.\n    pub greedy: bool,\n    /// The expression being repeated.\n    pub sub: Box<Hir>,\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::Repetition::with":["/// Returns a new repetition with the same `min`, `max` and `greedy`\n/// values, but with its sub-expression replaced with the one given.\npub fn with(&self, sub: Hir) -> Repetition{\n        Repetition {\n            min: self.min,\n            max: self.max,\n            greedy: self.greedy,\n            sub: Box::new(sub),\n        }\n    }","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::class_bytes":["/// Given a sequence of HIR values where each value corresponds to a byte class\n/// (or an all-ASCII Unicode class), return a single byte class corresponding\n/// to the union of the classes found.\nfn class_bytes(hirs: &[Hir]) -> Option<Class>{\n    let mut cls = ClassBytes::new(vec![]);\n    for hir in hirs.iter() {\n        match *hir.kind() {\n            HirKind::Class(Class::Unicode(ref cls2)) => {\n                cls.union(&cls2.to_byte_class()?);\n            }\n            HirKind::Class(Class::Bytes(ref cls2)) => {\n                cls.union(cls2);\n            }\n            _ => return None,\n        };\n    }\n    Some(Class::Bytes(cls))\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::class_chars":["/// Given a sequence of HIR values where each value corresponds to a Unicode\n/// class (or an all-ASCII byte class), return a single Unicode class\n/// corresponding to the union of the classes found.\nfn class_chars(hirs: &[Hir]) -> Option<Class>{\n    let mut cls = ClassUnicode::new(vec![]);\n    for hir in hirs.iter() {\n        match *hir.kind() {\n            HirKind::Class(Class::Unicode(ref cls2)) => {\n                cls.union(cls2);\n            }\n            HirKind::Class(Class::Bytes(ref cls2)) => {\n                cls.union(&cls2.to_unicode_class()?);\n            }\n            _ => return None,\n        };\n    }\n    Some(Class::Unicode(cls))\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::interval::Bound":["pub trait Bound:\n    Copy + Clone + Debug + Eq + PartialEq + PartialOrd + Ord\n{\n    fn min_value() -> Self;\n    fn max_value() -> Self;\n    fn as_u32(self) -> u32;\n    fn increment(self) -> Self;\n    fn decrement(self) -> Self;\n}","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval":["pub trait Interval:\n    Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n{\n    type Bound: Bound;\n\n    fn lower(&self) -> Self::Bound;\n    fn upper(&self) -> Self::Bound;\n    fn set_lower(&mut self, bound: Self::Bound);\n    fn set_upper(&mut self, bound: Self::Bound);\n    fn case_fold_simple(\n        &self,\n        intervals: &mut Vec<Self>,\n    ) -> Result<(), unicode::CaseFoldError>;\n\n    /// Create a new interval.\n    fn create(lower: Self::Bound, upper: Self::Bound) -> Self {\n        let mut int = Self::default();\n        if lower <= upper {\n            int.set_lower(lower);\n            int.set_upper(upper);\n        } else {\n            int.set_lower(upper);\n            int.set_upper(lower);\n        }\n        int\n    }\n\n    /// Union the given overlapping range into this range.\n    ///\n    /// If the two ranges aren't contiguous, then this returns `None`.\n    fn union(&self, other: &Self) -> Option<Self> {\n        if !self.is_contiguous(other) {\n            return None;\n        }\n        let lower = cmp::min(self.lower(), other.lower());\n        let upper = cmp::max(self.upper(), other.upper());\n        Some(Self::create(lower, upper))\n    }\n\n    /// Intersect this range with the given range and return the result.\n    ///\n    /// If the intersection is empty, then this returns `None`.\n    fn intersect(&self, other: &Self) -> Option<Self> {\n        let lower = cmp::max(self.lower(), other.lower());\n        let upper = cmp::min(self.upper(), other.upper());\n        if lower <= upper {\n            Some(Self::create(lower, upper))\n        } else {\n            None\n        }\n    }\n\n    /// Subtract the given range from this range and return the resulting\n    /// ranges.\n    ///\n    /// If subtraction would result in an empty range, then no ranges are\n    /// returned.\n    fn difference(&self, other: &Self) -> (Option<Self>, Option<Self>) {\n        if self.is_subset(other) {\n            return (None, None);\n        }\n        if self.is_intersection_empty(other) {\n            return (Some(self.clone()), None);\n        }\n        let add_lower = other.lower() > self.lower();\n        let add_upper = other.upper() < self.upper();\n        // We know this because !self.is_subset(other) and the ranges have\n        // a non-empty intersection.\n        assert!(add_lower || add_upper);\n        let mut ret = (None, None);\n        if add_lower {\n            let upper = other.lower().decrement();\n            ret.0 = Some(Self::create(self.lower(), upper));\n        }\n        if add_upper {\n            let lower = other.upper().increment();\n            let range = Self::create(lower, self.upper());\n            if ret.0.is_none() {\n                ret.0 = Some(range);\n            } else {\n                ret.1 = Some(range);\n            }\n        }\n        ret\n    }\n\n    /// Compute the symmetric difference the given range from this range. This\n    /// returns the union of the two ranges minus its intersection.\n    fn symmetric_difference(\n        &self,\n        other: &Self,\n    ) -> (Option<Self>, Option<Self>) {\n        let union = match self.union(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(union) => union,\n        };\n        let intersection = match self.intersect(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(intersection) => intersection,\n        };\n        union.difference(&intersection)\n    }\n\n    /// Returns true if and only if the two ranges are contiguous. Two ranges\n    /// are contiguous if and only if the ranges are either overlapping or\n    /// adjacent.\n    fn is_contiguous(&self, other: &Self) -> bool {\n        let lower1 = self.lower().as_u32();\n        let upper1 = self.upper().as_u32();\n        let lower2 = other.lower().as_u32();\n        let upper2 = other.upper().as_u32();\n        cmp::max(lower1, lower2) <= cmp::min(upper1, upper2).saturating_add(1)\n    }\n\n    /// Returns true if and only if the intersection of this range and the\n    /// other range is empty.\n    fn is_intersection_empty(&self, other: &Self) -> bool {\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        cmp::max(lower1, lower2) > cmp::min(upper1, upper2)\n    }\n\n    /// Returns true if and only if this range is a subset of the other range.\n    fn is_subset(&self, other: &Self) -> bool {\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        (lower2 <= lower1 && lower1 <= upper2)\n            && (lower2 <= upper1 && upper1 <= upper2)\n    }\n}","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::create":["/// Create a new interval.\nfn create(lower: Self::Bound, upper: Self::Bound) -> Self{\n        let mut int = Self::default();\n        if lower <= upper {\n            int.set_lower(lower);\n            int.set_upper(upper);\n        } else {\n            int.set_lower(upper);\n            int.set_upper(lower);\n        }\n        int\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::difference":["/// Subtract the given range from this range and return the resulting\n/// ranges.\n///\n/// If subtraction would result in an empty range, then no ranges are\n/// returned.\nfn difference(&self, other: &Self) -> (Option<Self>, Option<Self>){\n        if self.is_subset(other) {\n            return (None, None);\n        }\n        if self.is_intersection_empty(other) {\n            return (Some(self.clone()), None);\n        }\n        let add_lower = other.lower() > self.lower();\n        let add_upper = other.upper() < self.upper();\n        // We know this because !self.is_subset(other) and the ranges have\n        // a non-empty intersection.\n        assert!(add_lower || add_upper);\n        let mut ret = (None, None);\n        if add_lower {\n            let upper = other.lower().decrement();\n            ret.0 = Some(Self::create(self.lower(), upper));\n        }\n        if add_upper {\n            let lower = other.upper().increment();\n            let range = Self::create(lower, self.upper());\n            if ret.0.is_none() {\n                ret.0 = Some(range);\n            } else {\n                ret.1 = Some(range);\n            }\n        }\n        ret\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::intersect":["/// Intersect this range with the given range and return the result.\n///\n/// If the intersection is empty, then this returns `None`.\nfn intersect(&self, other: &Self) -> Option<Self>{\n        let lower = cmp::max(self.lower(), other.lower());\n        let upper = cmp::min(self.upper(), other.upper());\n        if lower <= upper {\n            Some(Self::create(lower, upper))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::is_contiguous":["/// Returns true if and only if the two ranges are contiguous. Two ranges\n/// are contiguous if and only if the ranges are either overlapping or\n/// adjacent.\nfn is_contiguous(&self, other: &Self) -> bool{\n        let lower1 = self.lower().as_u32();\n        let upper1 = self.upper().as_u32();\n        let lower2 = other.lower().as_u32();\n        let upper2 = other.upper().as_u32();\n        cmp::max(lower1, lower2) <= cmp::min(upper1, upper2).saturating_add(1)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::is_intersection_empty":["/// Returns true if and only if the intersection of this range and the\n/// other range is empty.\nfn is_intersection_empty(&self, other: &Self) -> bool{\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        cmp::max(lower1, lower2) > cmp::min(upper1, upper2)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::is_subset":["/// Returns true if and only if this range is a subset of the other range.\nfn is_subset(&self, other: &Self) -> bool{\n        let (lower1, upper1) = (self.lower(), self.upper());\n        let (lower2, upper2) = (other.lower(), other.upper());\n        (lower2 <= lower1 && lower1 <= upper2)\n            && (lower2 <= upper1 && upper1 <= upper2)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::symmetric_difference":["/// Compute the symmetric difference the given range from this range. This\n/// returns the union of the two ranges minus its intersection.\nfn symmetric_difference(\n        &self,\n        other: &Self,\n    ) -> (Option<Self>, Option<Self>){\n        let union = match self.union(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(union) => union,\n        };\n        let intersection = match self.intersect(other) {\n            None => return (Some(self.clone()), Some(other.clone())),\n            Some(intersection) => intersection,\n        };\n        union.difference(&intersection)\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::Interval::union":["/// Union the given overlapping range into this range.\n///\n/// If the two ranges aren't contiguous, then this returns `None`.\nfn union(&self, other: &Self) -> Option<Self>{\n        if !self.is_contiguous(other) {\n            return None;\n        }\n        let lower = cmp::min(self.lower(), other.lower());\n        let upper = cmp::max(self.upper(), other.upper());\n        Some(Self::create(lower, upper))\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet":["pub struct IntervalSet<I> {\n    /// A sorted set of non-overlapping ranges.\n    ranges: Vec<I>,\n    /// While not required at all for correctness, we keep track of whether an\n    /// interval set has been case folded or not. This helps us avoid doing\n    /// redundant work if, for example, a set has already been cased folded.\n    /// And note that whether a set is folded or not is preserved through\n    /// all of the pairwise set operations. That is, if both interval sets\n    /// have been case folded, then any of difference, union, intersection or\n    /// symmetric difference all produce a case folded set.\n    ///\n    /// Note that when this is true, it *must* be the case that the set is case\n    /// folded. But when it's false, the set *may* be case folded. In other\n    /// words, we only set this to true when we know it to be case, but we're\n    /// okay with it being false if it would otherwise be costly to determine\n    /// whether it should be true. This means code cannot assume that a false\n    /// value necessarily indicates that the set is not case folded.\n    ///\n    /// Bottom line: this is a performance optimization.\n    folded: bool,\n}","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::canonicalize":["/// Converts this set into a canonical ordering.\nfn canonicalize(&mut self){\n        if self.is_canonical() {\n            return;\n        }\n        self.ranges.sort();\n        assert!(!self.ranges.is_empty());\n\n        // Is there a way to do this in-place with constant memory? I couldn't\n        // figure out a way to do it. So just append the canonicalization to\n        // the end of this range, and then drain it before we're done.\n        let drain_end = self.ranges.len();\n        for oldi in 0..drain_end {\n            // If we've added at least one new range, then check if we can\n            // merge this range in the previously added range.\n            if self.ranges.len() > drain_end {\n                let (last, rest) = self.ranges.split_last_mut().unwrap();\n                if let Some(union) = last.union(&rest[oldi]) {\n                    *last = union;\n                    continue;\n                }\n            }\n            let range = self.ranges[oldi];\n            self.ranges.push(range);\n        }\n        self.ranges.drain(..drain_end);\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::case_fold_simple":["/// Expand this interval set such that it contains all case folded\n/// characters. For example, if this class consists of the range `a-z`,\n/// then applying case folding will result in the class containing both the\n/// ranges `a-z` and `A-Z`.\n///\n/// This returns an error if the necessary case mapping data is not\n/// available.\npub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError>{\n        if self.folded {\n            return Ok(());\n        }\n        let len = self.ranges.len();\n        for i in 0..len {\n            let range = self.ranges[i];\n            if let Err(err) = range.case_fold_simple(&mut self.ranges) {\n                self.canonicalize();\n                return Err(err);\n            }\n        }\n        self.canonicalize();\n        self.folded = true;\n        Ok(())\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::difference":["/// Subtract the given set from this set, in place.\npub fn difference(&mut self, other: &IntervalSet<I>){\n        if self.ranges.is_empty() || other.ranges.is_empty() {\n            return;\n        }\n\n        // This algorithm is (to me) surprisingly complex. A search of the\n        // interwebs indicate that this is a potentially interesting problem.\n        // Folks seem to suggest interval or segment trees, but I'd like to\n        // avoid the overhead (both runtime and conceptual) of that.\n        //\n        // The following is basically my Shitty First Draft. Therefore, in\n        // order to grok it, you probably need to read each line carefully.\n        // Simplifications are most welcome!\n        //\n        // Remember, we can assume the canonical format invariant here, which\n        // says that all ranges are sorted, not overlapping and not adjacent in\n        // each class.\n        let drain_end = self.ranges.len();\n        let (mut a, mut b) = (0, 0);\n        'LOOP: while a < drain_end && b < other.ranges.len() {\n            // Basically, the easy cases are when neither range overlaps with\n            // each other. If the `b` range is less than our current `a`\n            // range, then we can skip it and move on.\n            if other.ranges[b].upper() < self.ranges[a].lower() {\n                b += 1;\n                continue;\n            }\n            // ... similarly for the `a` range. If it's less than the smallest\n            // `b` range, then we can add it as-is.\n            if self.ranges[a].upper() < other.ranges[b].lower() {\n                let range = self.ranges[a];\n                self.ranges.push(range);\n                a += 1;\n                continue;\n            }\n            // Otherwise, we have overlapping ranges.\n            assert!(!self.ranges[a].is_intersection_empty(&other.ranges[b]));\n\n            // This part is tricky and was non-obvious to me without looking\n            // at explicit examples (see the tests). The trickiness stems from\n            // two things: 1) subtracting a range from another range could\n            // yield two ranges and 2) after subtracting a range, it's possible\n            // that future ranges can have an impact. The loop below advances\n            // the `b` ranges until they can't possible impact the current\n            // range.\n            //\n            // For example, if our `a` range is `a-t` and our next three `b`\n            // ranges are `a-c`, `g-i`, `r-t` and `x-z`, then we need to apply\n            // subtraction three times before moving on to the next `a` range.\n            let mut range = self.ranges[a];\n            while b < other.ranges.len()\n                && !range.is_intersection_empty(&other.ranges[b])\n            {\n                let old_range = range;\n                range = match range.difference(&other.ranges[b]) {\n                    (None, None) => {\n                        // We lost the entire range, so move on to the next\n                        // without adding this one.\n                        a += 1;\n                        continue 'LOOP;\n                    }\n                    (Some(range1), None) | (None, Some(range1)) => range1,\n                    (Some(range1), Some(range2)) => {\n                        self.ranges.push(range1);\n                        range2\n                    }\n                };\n                // It's possible that the `b` range has more to contribute\n                // here. In particular, if it is greater than the original\n                // range, then it might impact the next `a` range *and* it\n                // has impacted the current `a` range as much as possible,\n                // so we can quit. We don't bump `b` so that the next `a`\n                // range can apply it.\n                if other.ranges[b].upper() > old_range.upper() {\n                    break;\n                }\n                // Otherwise, the next `b` range might apply to the current\n                // `a` range.\n                b += 1;\n            }\n            self.ranges.push(range);\n            a += 1;\n        }\n        while a < drain_end {\n            let range = self.ranges[a];\n            self.ranges.push(range);\n            a += 1;\n        }\n        self.ranges.drain(..drain_end);\n        self.folded = self.folded && other.folded;\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::intersect":["/// Intersect this set with the given set, in place.\npub fn intersect(&mut self, other: &IntervalSet<I>){\n        if self.ranges.is_empty() {\n            return;\n        }\n        if other.ranges.is_empty() {\n            self.ranges.clear();\n            // An empty set is case folded.\n            self.folded = true;\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the intersection to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        let mut ita = 0..drain_end;\n        let mut itb = 0..other.ranges.len();\n        let mut a = ita.next().unwrap();\n        let mut b = itb.next().unwrap();\n        loop {\n            if let Some(ab) = self.ranges[a].intersect(&other.ranges[b]) {\n                self.ranges.push(ab);\n            }\n            let (it, aorb) =\n                if self.ranges[a].upper() < other.ranges[b].upper() {\n                    (&mut ita, &mut a)\n                } else {\n                    (&mut itb, &mut b)\n                };\n            match it.next() {\n                Some(v) => *aorb = v,\n                None => break,\n            }\n        }\n        self.ranges.drain(..drain_end);\n        self.folded = self.folded && other.folded;\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::intervals":["/// Return an immutable slice of intervals in this set.\n///\n/// The sequence returned is in canonical ordering.\npub fn intervals(&self) -> &[I]{\n        &self.ranges\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::is_canonical":["/// Returns true if and only if this class is in a canonical ordering.\nfn is_canonical(&self) -> bool{\n        for pair in self.ranges.windows(2) {\n            if pair[0] >= pair[1] {\n                return false;\n            }\n            if pair[0].is_contiguous(&pair[1]) {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::iter":["/// Return an iterator over all intervals in this set.\n///\n/// The iterator yields intervals in ascending order.\npub fn iter(&self) -> IntervalSetIter<'_, I>{\n        IntervalSetIter(self.ranges.iter())\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::negate":["/// Negate this interval set.\n///\n/// For all `x` where `x` is any element, if `x` was in this set, then it\n/// will not be in this set after negation.\npub fn negate(&mut self){\n        if self.ranges.is_empty() {\n            let (min, max) = (I::Bound::min_value(), I::Bound::max_value());\n            self.ranges.push(I::create(min, max));\n            // The set containing everything must case folded.\n            self.folded = true;\n            return;\n        }\n\n        // There should be a way to do this in-place with constant memory,\n        // but I couldn't figure out a simple way to do it. So just append\n        // the negation to the end of this range, and then drain it before\n        // we're done.\n        let drain_end = self.ranges.len();\n\n        // We do checked arithmetic below because of the canonical ordering\n        // invariant.\n        if self.ranges[0].lower() > I::Bound::min_value() {\n            let upper = self.ranges[0].lower().decrement();\n            self.ranges.push(I::create(I::Bound::min_value(), upper));\n        }\n        for i in 1..drain_end {\n            let lower = self.ranges[i - 1].upper().increment();\n            let upper = self.ranges[i].lower().decrement();\n            self.ranges.push(I::create(lower, upper));\n        }\n        if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {\n            let lower = self.ranges[drain_end - 1].upper().increment();\n            self.ranges.push(I::create(lower, I::Bound::max_value()));\n        }\n        self.ranges.drain(..drain_end);\n        // We don't need to update whether this set is folded or not, because\n        // it is conservatively preserved through negation. Namely, if a set\n        // is not folded, then it is possible that its negation is folded, for\n        // example, [^☃]. But we're fine with assuming that the set is not\n        // folded in that case. (`folded` permits false negatives but not false\n        // positives.)\n        //\n        // But what about when a set is folded, is its negation also\n        // necessarily folded? Yes. Because if a set is folded, then for every\n        // character in the set, it necessarily included its equivalence class\n        // of case folded characters. Negating it in turn means that all\n        // equivalence classes in the set are negated, and any equivalence\n        // class that was previously not in the set is now entirely in the set.\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::new":["/// Create a new set from a sequence of intervals. Each interval is\n/// specified as a pair of bounds, where both bounds are inclusive.\n///\n/// The given ranges do not need to be in any specific order, and ranges\n/// may overlap.\npub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I>{\n        let ranges: Vec<I> = intervals.into_iter().collect();\n        // An empty set is case folded.\n        let folded = ranges.is_empty();\n        let mut set = IntervalSet { ranges, folded };\n        set.canonicalize();\n        set\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::push":["/// Add a new interval to this set.\npub fn push(&mut self, interval: I){\n        // TODO: This could be faster. e.g., Push the interval such that\n        // it preserves canonicalization.\n        self.ranges.push(interval);\n        self.canonicalize();\n        // We don't know whether the new interval added here is considered\n        // case folded, so we conservatively assume that the entire set is\n        // no longer case folded if it was previously.\n        self.folded = false;\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::symmetric_difference":["/// Compute the symmetric difference of the two sets, in place.\n///\n/// This computes the symmetric difference of two interval sets. This\n/// removes all elements in this set that are also in the given set,\n/// but also adds all elements from the given set that aren't in this\n/// set. That is, the set will contain all elements in either set,\n/// but will not contain any elements that are in both sets.\npub fn symmetric_difference(&mut self, other: &IntervalSet<I>){\n        // TODO(burntsushi): Fix this so that it amortizes allocation.\n        let mut intersection = self.clone();\n        intersection.intersect(other);\n        self.union(other);\n        self.difference(&intersection);\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSet::<I>::union":["/// Union this set with the given set, in place.\npub fn union(&mut self, other: &IntervalSet<I>){\n        if other.ranges.is_empty() || self.ranges == other.ranges {\n            return;\n        }\n        // This could almost certainly be done more efficiently.\n        self.ranges.extend(&other.ranges);\n        self.canonicalize();\n        self.folded = self.folded && other.folded;\n    }","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::interval::IntervalSetIter":["/// An iterator over intervals.\npub struct IntervalSetIter<'a, I>(slice::Iter<'a, I>);","Real(LocalPath(\"src/hir/interval.rs\"))"],"hir::lift_common_prefix":["/// Looks for a common prefix in the list of alternation branches given. If one\n/// is found, then an equivalent but (hopefully) simplified Hir is returned.\n/// Otherwise, the original given list of branches is returned unmodified.\n///\n/// This is not quite as good as it could be. Right now, it requires that\n/// all branches are 'Concat' expressions. It also doesn't do well with\n/// literals. For example, given 'foofoo|foobar', it will not refactor it to\n/// 'foo(?:foo|bar)' because literals are flattened into their own special\n/// concatenation. (One wonders if perhaps 'Literal' should be a single atom\n/// instead of a string of bytes because of this. Otherwise, handling the\n/// current representation in this routine will be pretty gnarly. Sigh.)\nfn lift_common_prefix(hirs: Vec<Hir>) -> Result<Hir, Vec<Hir>>{\n    if hirs.len() <= 1 {\n        return Err(hirs);\n    }\n    let mut prefix = match hirs[0].kind() {\n        HirKind::Concat(ref xs) => &**xs,\n        _ => return Err(hirs),\n    };\n    if prefix.is_empty() {\n        return Err(hirs);\n    }\n    for h in hirs.iter().skip(1) {\n        let concat = match h.kind() {\n            HirKind::Concat(ref xs) => xs,\n            _ => return Err(hirs),\n        };\n        let common_len = prefix\n            .iter()\n            .zip(concat.iter())\n            .take_while(|(x, y)| x == y)\n            .count();\n        prefix = &prefix[..common_len];\n        if prefix.is_empty() {\n            return Err(hirs);\n        }\n    }\n    let len = prefix.len();\n    assert_ne!(0, len);\n    let mut prefix_concat = vec![];\n    let mut suffix_alts = vec![];\n    for h in hirs {\n        let mut concat = match h.into_kind() {\n            HirKind::Concat(xs) => xs,\n            // We required all sub-expressions to be\n            // concats above, so we're only here if we\n            // have a concat.\n            _ => unreachable!(),\n        };\n        suffix_alts.push(Hir::concat(concat.split_off(len)));\n        if prefix_concat.is_empty() {\n            prefix_concat = concat;\n        }\n    }\n    let mut concat = prefix_concat;\n    concat.push(Hir::alternation(suffix_alts));\n    Ok(Hir::concat(concat))\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::literal::ExtractKind":["/// The kind of literals to extract from an [`Hir`] expression.\n///\n/// The default extraction kind is `Prefix`.\n#[non_exhaustive]\npub enum ExtractKind {\n    /// Extracts only prefix literals from a regex.\n    Prefix,\n    /// Extracts only suffix literals from a regex.\n    ///\n    /// Note that the sequence returned by suffix literals currently may\n    /// not correctly represent leftmost-first or \"preference\" order match\n    /// semantics.\n    Suffix,\n}","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::ExtractKind::is_prefix":["/// Returns true if this kind is the `Prefix` variant.\npub fn is_prefix(&self) -> bool{\n        matches!(*self, ExtractKind::Prefix)\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::ExtractKind::is_suffix":["/// Returns true if this kind is the `Suffix` variant.\npub fn is_suffix(&self) -> bool{\n        matches!(*self, ExtractKind::Suffix)\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor":["/// Extracts prefix or suffix literal sequences from [`Hir`] expressions.\n///\n/// Literal extraction is based on the following observations:\n///\n/// * Many regexes start with one or a small number of literals.\n/// * Substring search for literals is often much faster (sometimes by an order\n/// of magnitude) than a regex search.\n///\n/// Thus, in many cases, one can search for literals to find candidate starting\n/// locations of a match, and then only run the full regex engine at each such\n/// location instead of over the full haystack.\n///\n/// The main downside of literal extraction is that it can wind up causing a\n/// search to be slower overall. For example, if there are many matches or if\n/// there are many candidates that don't ultimately lead to a match, then a\n/// lot of overhead will be spent in shuffing back-and-forth between substring\n/// search and the regex engine. This is the fundamental reason why literal\n/// optimizations for regex patterns is sometimes considered a \"black art.\"\n///\n/// # Look-around assertions\n///\n/// Literal extraction treats all look-around assertions as-if they match every\n/// empty string. So for example, the regex `\\bquux\\b` will yield a sequence\n/// containing a single exact literal `quux`. However, not all occurrences\n/// of `quux` correspond to a match a of the regex. For example, `\\bquux\\b`\n/// does not match `ZquuxZ` anywhere because `quux` does not fall on a word\n/// boundary.\n///\n/// In effect, if your regex contains look-around assertions, then a match of\n/// an exact literal does not necessarily mean the regex overall matches. So\n/// you may still need to run the regex engine in such cases to confirm the\n/// match.\n///\n/// The precise guarantee you get from a literal sequence is: if every literal\n/// in the sequence is exact and the original regex contains zero look-around\n/// assertions, then a preference-order multi-substring search of those\n/// literals will precisely match a preference-order search of the original\n/// regex.\n///\n/// # Example\n///\n/// This shows how to extract prefixes:\n///\n/// ```\n/// use regex_syntax::{hir::literal::{Extractor, Literal, Seq}, parse};\n///\n/// let hir = parse(r\"(a|b|c)(x|y|z)[A-Z]+foo\")?;\n/// let got = Extractor::new().extract(&hir);\n/// // All literals returned are \"inexact\" because none of them reach the\n/// // match state.\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"ax\"),\n///     Literal::inexact(\"ay\"),\n///     Literal::inexact(\"az\"),\n///     Literal::inexact(\"bx\"),\n///     Literal::inexact(\"by\"),\n///     Literal::inexact(\"bz\"),\n///     Literal::inexact(\"cx\"),\n///     Literal::inexact(\"cy\"),\n///     Literal::inexact(\"cz\"),\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n///\n/// This shows how to extract suffixes:\n///\n/// ```\n/// use regex_syntax::{\n///     hir::literal::{Extractor, ExtractKind, Literal, Seq},\n///     parse,\n/// };\n///\n/// let hir = parse(r\"foo|[A-Z]+bar\")?;\n/// let got = Extractor::new().kind(ExtractKind::Suffix).extract(&hir);\n/// // Since 'foo' gets to a match state, it is considered exact. But 'bar'\n/// // does not because of the '[A-Z]+', and thus is marked inexact.\n/// let expected = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\npub struct Extractor {\n    kind: ExtractKind,\n    limit_class: usize,\n    limit_repeat: usize,\n    limit_literal_len: usize,\n    limit_total: usize,\n}","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::class_over_limit_bytes":["/// Returns true if the given byte class exceeds the configured limits on\n/// this extractor.\nfn class_over_limit_bytes(&self, cls: &hir::ClassBytes) -> bool{\n        let mut count = 0;\n        for r in cls.iter() {\n            if count > self.limit_class {\n                return true;\n            }\n            count += r.len();\n        }\n        count > self.limit_class\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::class_over_limit_unicode":["/// Returns true if the given Unicode class exceeds the configured limits\n/// on this extractor.\nfn class_over_limit_unicode(&self, cls: &hir::ClassUnicode) -> bool{\n        let mut count = 0;\n        for r in cls.iter() {\n            if count > self.limit_class {\n                return true;\n            }\n            count += r.len();\n        }\n        count > self.limit_class\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::cross":["/// Compute the cross product of the two sequences if the result would be\n/// within configured limits. Otherwise, make `seq2` infinite and cross the\n/// infinite sequence with `seq1`.\nfn cross(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq{\n        if seq1.max_cross_len(seq2).map_or(false, |len| len > self.limit_total)\n        {\n            seq2.make_infinite();\n        }\n        if let ExtractKind::Suffix = self.kind {\n            seq1.cross_reverse(seq2);\n        } else {\n            seq1.cross_forward(seq2);\n        }\n        assert!(seq1.len().map_or(true, |x| x <= self.limit_total));\n        self.enforce_literal_len(&mut seq1);\n        seq1\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::enforce_literal_len":["/// Applies the literal length limit to the given sequence. If none of the\n/// literals in the sequence exceed the limit, then this is a no-op.\nfn enforce_literal_len(&self, seq: &mut Seq){\n        let len = self.limit_literal_len;\n        match self.kind {\n            ExtractKind::Prefix => seq.keep_first_bytes(len),\n            ExtractKind::Suffix => seq.keep_last_bytes(len),\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::extract":["/// Execute the extractor and return a sequence of literals.\npub fn extract(&self, hir: &Hir) -> Seq{\n        use crate::hir::HirKind::*;\n\n        match *hir.kind() {\n            Empty | Look(_) => Seq::singleton(self::Literal::exact(vec![])),\n            Literal(hir::Literal(ref bytes)) => {\n                let mut seq =\n                    Seq::singleton(self::Literal::exact(bytes.to_vec()));\n                self.enforce_literal_len(&mut seq);\n                seq\n            }\n            Class(hir::Class::Unicode(ref cls)) => {\n                self.extract_class_unicode(cls)\n            }\n            Class(hir::Class::Bytes(ref cls)) => self.extract_class_bytes(cls),\n            Repetition(ref rep) => self.extract_repetition(rep),\n            Capture(hir::Capture { ref sub, .. }) => self.extract(sub),\n            Concat(ref hirs) => match self.kind {\n                ExtractKind::Prefix => self.extract_concat(hirs.iter()),\n                ExtractKind::Suffix => self.extract_concat(hirs.iter().rev()),\n            },\n            Alternation(ref hirs) => {\n                // Unlike concat, we always union starting from the beginning,\n                // since the beginning corresponds to the highest preference,\n                // which doesn't change based on forwards vs reverse.\n                self.extract_alternation(hirs.iter())\n            }\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::extract_alternation":["/// Extract a sequence from the given alternation.\n///\n/// This short circuits once the union turns into an infinite sequence.\nfn extract_alternation<'a, I: Iterator<Item = &'a Hir>>(\n        &self,\n        it: I,\n    ) -> Seq{\n        let mut seq = Seq::empty();\n        for hir in it {\n            // Once our 'seq' is infinite, every subsequent union\n            // operation on it will itself always result in an\n            // infinite sequence. Thus, it can never change and we can\n            // short-circuit.\n            if !seq.is_finite() {\n                break;\n            }\n            seq = self.union(seq, &mut self.extract(hir));\n        }\n        seq\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::extract_class_bytes":["/// Convert the given byte class into a sequence of literals if the class\n/// is small enough. If the class is too big, return an infinite sequence.\nfn extract_class_bytes(&self, cls: &hir::ClassBytes) -> Seq{\n        if self.class_over_limit_bytes(cls) {\n            return Seq::infinite();\n        }\n        let mut seq = Seq::empty();\n        for r in cls.iter() {\n            for b in r.start()..=r.end() {\n                seq.push(Literal::from(b));\n            }\n        }\n        self.enforce_literal_len(&mut seq);\n        seq\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::extract_class_unicode":["/// Convert the given Unicode class into a sequence of literals if the\n/// class is small enough. If the class is too big, return an infinite\n/// sequence.\nfn extract_class_unicode(&self, cls: &hir::ClassUnicode) -> Seq{\n        if self.class_over_limit_unicode(cls) {\n            return Seq::infinite();\n        }\n        let mut seq = Seq::empty();\n        for r in cls.iter() {\n            for ch in r.start()..=r.end() {\n                seq.push(Literal::from(ch));\n            }\n        }\n        self.enforce_literal_len(&mut seq);\n        seq\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::extract_concat":["/// Extract a sequence from the given concatenation. Sequences from each of\n/// the child HIR expressions are combined via cross product.\n///\n/// This short circuits once the cross product turns into a sequence\n/// containing only inexact literals.\nfn extract_concat<'a, I: Iterator<Item = &'a Hir>>(&self, it: I) -> Seq{\n        let mut seq = Seq::singleton(self::Literal::exact(vec![]));\n        for hir in it {\n            // If every element in the sequence is inexact, then a cross\n            // product will always be a no-op. Thus, there is nothing else we\n            // can add to it and can quit early. Note that this also includes\n            // infinite sequences.\n            if seq.is_inexact() {\n                break;\n            }\n            // Note that 'cross' also dispatches based on whether we're\n            // extracting prefixes or suffixes.\n            seq = self.cross(seq, &mut self.extract(hir));\n        }\n        seq\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::extract_repetition":["/// Extract a sequence of literals from the given repetition. We do our\n/// best, Some examples:\n///\n///   'a*'    => [inexact(a), exact(\"\")]\n///   'a*?'   => [exact(\"\"), inexact(a)]\n///   'a+'    => [inexact(a)]\n///   'a{3}'  => [exact(aaa)]\n///   'a{3,5} => [inexact(aaa)]\n///\n/// The key here really is making sure we get the 'inexact' vs 'exact'\n/// attributes correct on each of the literals we add. For example, the\n/// fact that 'a*' gives us an inexact 'a' and an exact empty string means\n/// that a regex like 'ab*c' will result in [inexact(ab), exact(ac)]\n/// literals being extracted, which might actually be a better prefilter\n/// than just 'a'.\nfn extract_repetition(&self, rep: &hir::Repetition) -> Seq{\n        let mut subseq = self.extract(&rep.sub);\n        match *rep {\n            hir::Repetition { min: 0, max, greedy, .. } => {\n                // When 'max=1', we can retain exactness, since 'a?' is\n                // equivalent to 'a|'. Similarly below, 'a??' is equivalent to\n                // '|a'.\n                if max != Some(1) {\n                    subseq.make_inexact();\n                }\n                let mut empty = Seq::singleton(Literal::exact(vec![]));\n                if !greedy {\n                    mem::swap(&mut subseq, &mut empty);\n                }\n                self.union(subseq, &mut empty)\n            }\n            hir::Repetition { min, max: Some(max), .. } if min == max => {\n                assert!(min > 0); // handled above\n                let limit =\n                    u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);\n                let mut seq = Seq::singleton(Literal::exact(vec![]));\n                for _ in 0..cmp::min(min, limit) {\n                    if seq.is_inexact() {\n                        break;\n                    }\n                    seq = self.cross(seq, &mut subseq.clone());\n                }\n                if usize::try_from(min).is_err() || min > limit {\n                    seq.make_inexact();\n                }\n                seq\n            }\n            hir::Repetition { min, max: Some(max), .. } if min < max => {\n                assert!(min > 0); // handled above\n                let limit =\n                    u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);\n                let mut seq = Seq::singleton(Literal::exact(vec![]));\n                for _ in 0..cmp::min(min, limit) {\n                    if seq.is_inexact() {\n                        break;\n                    }\n                    seq = self.cross(seq, &mut subseq.clone());\n                }\n                seq.make_inexact();\n                seq\n            }\n            hir::Repetition { .. } => {\n                subseq.make_inexact();\n                subseq\n            }\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::kind":["/// Set the kind of literal sequence to extract from an [`Hir`] expression.\n///\n/// The default is to extract prefixes, but suffixes can be selected\n/// instead. The contract for prefixes is that every match of the\n/// corresponding `Hir` must start with one of the literals in the sequence\n/// returned. Moreover, the _order_ of the sequence returned corresponds to\n/// the preference order.\n///\n/// Suffixes satisfy a similar contract in that every match of the\n/// corresponding `Hir` must end with one of the literals in the sequence\n/// returned. However, there is no guarantee that the literals are in\n/// preference order.\n///\n/// Remember that a sequence can be infinite. For example, unless the\n/// limits are configured to be impractically large, attempting to extract\n/// prefixes (or suffixes) for the pattern `[A-Z]` will return an infinite\n/// sequence. Generally speaking, if the sequence returned is infinite,\n/// then it is presumed to be unwise to do prefix (or suffix) optimizations\n/// for the pattern.\npub fn kind(&mut self, kind: ExtractKind) -> &mut Extractor{\n        self.kind = kind;\n        self\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::limit_class":["/// Configure a limit on the length of the sequence that is permitted for\n/// a character class. If a character class exceeds this limit, then the\n/// sequence returned for it is infinite.\n///\n/// This prevents classes like `[A-Z]` or `\\pL` from getting turned into\n/// huge and likely unproductive sequences of literals.\n///\n/// # Example\n///\n/// This example shows how this limit can be lowered to decrease the tolerance\n/// for character classes being turned into literal sequences.\n///\n/// ```\n/// use regex_syntax::{hir::literal::{Extractor, Seq}, parse};\n///\n/// let hir = parse(r\"[0-9]\")?;\n///\n/// let got = Extractor::new().extract(&hir);\n/// let expected = Seq::new([\n///     \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// // Now let's shrink the limit and see how that changes things.\n/// let got = Extractor::new().limit_class(4).extract(&hir);\n/// let expected = Seq::infinite();\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\npub fn limit_class(&mut self, limit: usize) -> &mut Extractor{\n        self.limit_class = limit;\n        self\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::limit_literal_len":["/// Configure a limit on the maximum length of any literal in a sequence.\n///\n/// This is useful for limiting things like `(abcde){5}{5}{5}{5}`. While\n/// each repetition or literal in that regex is small, when all the\n/// repetitions are applied, one ends up with a literal of length `5^4 =\n/// 625`.\n///\n/// With this limit set, literals that exceed it will be made inexact and\n/// thus prevented from growing.\n///\n/// # Example\n///\n/// This shows how to decrease the limit and compares it with the default.\n///\n/// ```\n/// use regex_syntax::{hir::literal::{Extractor, Literal, Seq}, parse};\n///\n/// let hir = parse(r\"(abc){2}{2}{2}\")?;\n///\n/// let got = Extractor::new().extract(&hir);\n/// let expected = Seq::new([\"abcabcabcabcabcabcabcabc\"]);\n/// assert_eq!(expected, got);\n///\n/// // Now let's shrink the limit and see how that changes things.\n/// let got = Extractor::new().limit_literal_len(14).extract(&hir);\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"abcabcabcabcab\"),\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\npub fn limit_literal_len(&mut self, limit: usize) -> &mut Extractor{\n        self.limit_literal_len = limit;\n        self\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::limit_repeat":["/// Configure a limit on the total number of repetitions that is permitted\n/// before literal extraction is stopped.\n///\n/// This is useful for limiting things like `(abcde){50}`, or more\n/// insidiously, `(?:){1000000000}`. This limit prevents any one single\n/// repetition from adding too much to a literal sequence.\n///\n/// With this limit set, repetitions that exceed it will be stopped and any\n/// literals extracted up to that point will be made inexact.\n///\n/// # Example\n///\n/// This shows how to decrease the limit and compares it with the default.\n///\n/// ```\n/// use regex_syntax::{hir::literal::{Extractor, Literal, Seq}, parse};\n///\n/// let hir = parse(r\"(abc){8}\")?;\n///\n/// let got = Extractor::new().extract(&hir);\n/// let expected = Seq::new([\"abcabcabcabcabcabcabcabc\"]);\n/// assert_eq!(expected, got);\n///\n/// // Now let's shrink the limit and see how that changes things.\n/// let got = Extractor::new().limit_repeat(4).extract(&hir);\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"abcabcabcabc\"),\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\npub fn limit_repeat(&mut self, limit: usize) -> &mut Extractor{\n        self.limit_repeat = limit;\n        self\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::limit_total":["/// Configure a limit on the total number of literals that will be\n/// returned.\n///\n/// This is useful as a practical measure for avoiding the creation of\n/// large sequences of literals. While the extractor will automatically\n/// handle local creations of large sequences (for example, `[A-Z]` yields\n/// an infinite sequence by default), large sequences can be created\n/// through non-local means as well.\n///\n/// For example, `[ab]{3}{3}` would yield a sequence of length `512 = 2^9`\n/// despite each of the repetitions being small on their own. This limit\n/// thus represents a \"catch all\" for avoiding locally small sequences from\n/// combining into large sequences.\n///\n/// # Example\n///\n/// This example shows how reducing the limit will change the literal\n/// sequence returned.\n///\n/// ```\n/// use regex_syntax::{hir::literal::{Extractor, Literal, Seq}, parse};\n///\n/// let hir = parse(r\"[ab]{2}{2}\")?;\n///\n/// let got = Extractor::new().extract(&hir);\n/// let expected = Seq::new([\n///     \"aaaa\", \"aaab\", \"aaba\", \"aabb\",\n///     \"abaa\", \"abab\", \"abba\", \"abbb\",\n///     \"baaa\", \"baab\", \"baba\", \"babb\",\n///     \"bbaa\", \"bbab\", \"bbba\", \"bbbb\",\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// // The default limit is not too big, but big enough to extract all\n/// // literals from '[ab]{2}{2}'. If we shrink the limit to less than 16,\n/// // then we'll get a truncated set. Notice that it returns a sequence of\n/// // length 4 even though our limit was 10. This is because the sequence\n/// // is difficult to increase without blowing the limit. Notice also\n/// // that every literal in the sequence is now inexact because they were\n/// // stripped of some suffix.\n/// let got = Extractor::new().limit_total(10).extract(&hir);\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"aa\"),\n///     Literal::inexact(\"ab\"),\n///     Literal::inexact(\"ba\"),\n///     Literal::inexact(\"bb\"),\n/// ]);\n/// assert_eq!(expected, got);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\npub fn limit_total(&mut self, limit: usize) -> &mut Extractor{\n        self.limit_total = limit;\n        self\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::new":["/// Create a new extractor with a default configuration.\n///\n/// The extractor can be optionally configured before calling\n/// [`Extractor::extract`] to get a literal sequence.\npub fn new() -> Extractor{\n        Extractor {\n            kind: ExtractKind::Prefix,\n            limit_class: 10,\n            limit_repeat: 10,\n            limit_literal_len: 100,\n            limit_total: 250,\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Extractor::union":["/// Union the two sequences if the result would be within configured\n/// limits. Otherwise, make `seq2` infinite and union the infinite sequence\n/// with `seq1`.\nfn union(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq{\n        if seq1.max_union_len(seq2).map_or(false, |len| len > self.limit_total)\n        {\n            // We try to trim our literal sequences to see if we can make\n            // room for more literals. The idea is that we'd rather trim down\n            // literals already in our sequence if it means we can add a few\n            // more and retain a finite sequence. Otherwise, we'll union with\n            // an infinite sequence and that infects everything and effectively\n            // stops literal extraction in its tracks.\n            //\n            // We do we keep 4 bytes here? Well, it's a bit of an abstraction\n            // leakage. Downstream, the literals may wind up getting fed to\n            // the Teddy algorithm, which supports searching literals up to\n            // length 4. So that's why we pick that number here. Arguably this\n            // should be a tuneable parameter, but it seems a little tricky to\n            // describe. And I'm still unsure if this is the right way to go\n            // about culling literal sequences.\n            match self.kind {\n                ExtractKind::Prefix => {\n                    seq1.keep_first_bytes(4);\n                    seq2.keep_first_bytes(4);\n                }\n                ExtractKind::Suffix => {\n                    seq1.keep_last_bytes(4);\n                    seq2.keep_last_bytes(4);\n                }\n            }\n            seq1.dedup();\n            seq2.dedup();\n            if seq1\n                .max_union_len(seq2)\n                .map_or(false, |len| len > self.limit_total)\n            {\n                seq2.make_infinite();\n            }\n        }\n        seq1.union(seq2);\n        assert!(seq1.len().map_or(true, |x| x <= self.limit_total));\n        seq1\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal":["/// A single literal extracted from an [`Hir`] expression.\n///\n/// A literal is composed of two things:\n///\n/// * A sequence of bytes. No guarantees with respect to UTF-8 are provided.\n/// In particular, even if the regex a literal is extracted from is UTF-8, the\n/// literal extracted may not be valid UTF-8. (For example, if an [`Extractor`]\n/// limit resulted in trimming a literal in a way that splits a codepoint.)\n/// * Whether the literal is \"exact\" or not. An \"exact\" literal means that it\n/// has not been trimmed, and may continue to be extended. If a literal is\n/// \"exact\" after visiting the entire `Hir` expression, then this implies that\n/// the literal leads to a match state. (Although it doesn't necessarily imply\n/// all occurrences of the literal correspond to a match of the regex, since\n/// literal extraction ignores look-around assertions.)\npub struct Literal {\n    bytes: Vec<u8>,\n    exact: bool,\n}","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::as_bytes":["/// Returns the bytes in this literal.\n#[inline]\npub fn as_bytes(&self) -> &[u8]{\n        &self.bytes\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::exact":["/// Returns a new exact literal containing the bytes given.\n#[inline]\npub fn exact<B: Into<Vec<u8>>>(bytes: B) -> Literal{\n        Literal { bytes: bytes.into(), exact: true }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::extend":["/// Extend this literal with the literal given.\n///\n/// If this literal is inexact, then this is a no-op.\n#[inline]\npub fn extend(&mut self, lit: &Literal){\n        if !self.is_exact() {\n            return;\n        }\n        self.bytes.extend_from_slice(&lit.bytes);\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::inexact":["/// Returns a new inexact literal containing the bytes given.\n#[inline]\npub fn inexact<B: Into<Vec<u8>>>(bytes: B) -> Literal{\n        Literal { bytes: bytes.into(), exact: false }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::into_bytes":["/// Yields ownership of the bytes inside this literal.\n///\n/// Note that this throws away whether the literal is \"exact\" or not.\n#[inline]\npub fn into_bytes(self) -> Vec<u8>{\n        self.bytes\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::is_empty":["/// Returns true if and only if this literal has zero bytes.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::is_exact":["/// Returns true if and only if this literal is exact.\n#[inline]\npub fn is_exact(&self) -> bool{\n        self.exact\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::is_poisonous":["/// Returns true if it is believe that this literal is likely to match very\n/// frequently, and is thus not a good candidate for a prefilter.\nfn is_poisonous(&self) -> bool{\n        self.is_empty() || (self.len() == 1 && rank(self.as_bytes()[0]) >= 250)\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::keep_first_bytes":["/// Trims this literal such that only the first `len` bytes remain. If\n/// this literal has fewer than `len` bytes, then it remains unchanged.\n/// Otherwise, the literal is marked as inexact.\n#[inline]\npub fn keep_first_bytes(&mut self, len: usize){\n        if len >= self.len() {\n            return;\n        }\n        self.make_inexact();\n        self.bytes.truncate(len);\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::keep_last_bytes":["/// Trims this literal such that only the last `len` bytes remain. If this\n/// literal has fewer than `len` bytes, then it remains unchanged.\n/// Otherwise, the literal is marked as inexact.\n#[inline]\npub fn keep_last_bytes(&mut self, len: usize){\n        if len >= self.len() {\n            return;\n        }\n        self.make_inexact();\n        self.bytes.drain(..self.len() - len);\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::len":["/// Returns the length of this literal in bytes.\n#[inline]\npub fn len(&self) -> usize{\n        self.as_bytes().len()\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::make_inexact":["/// Marks this literal as inexact.\n///\n/// Inexact literals can never be extended. For example,\n/// [`Seq::cross_forward`] will not extend inexact literals.\n#[inline]\npub fn make_inexact(&mut self){\n        self.exact = false;\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Literal::reverse":["/// Reverse the bytes in this literal.\n#[inline]\npub fn reverse(&mut self){\n        self.bytes.reverse();\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::PreferenceTrie":["/// A \"preference\" trie that rejects literals that will never match when\n/// executing a leftmost first or \"preference\" search.\n///\n/// For example, if 'sam' is inserted, then trying to insert 'samwise' will be\n/// rejected because 'samwise' can never match since 'sam' will always take\n/// priority. However, if 'samwise' is inserted first, then inserting 'sam'\n/// after it is accepted. In this case, either 'samwise' or 'sam' can match in\n/// a \"preference\" search.\n///\n/// Note that we only use this trie as a \"set.\" That is, given a sequence of\n/// literals, we insert each one in order. An `insert` will reject a literal\n/// if a prefix of that literal already exists in the trie. Thus, to rebuild\n/// the \"minimal\" sequence, we simply only keep literals that were successfully\n/// inserted. (Since we don't need traversal, one wonders whether we can make\n/// some simplifications here, but I haven't given it a ton of thought and I've\n/// never seen this show up on a profile. Because of the heuristic limits\n/// imposed on literal extractions, the size of the inputs here is usually\n/// very small.)\nstruct PreferenceTrie {\n    /// The states in this trie. The index of a state in this vector is its ID.\n    states: Vec<State>,\n    /// The index to allocate to the next literal added to this trie. Starts at\n    /// 0 and increments by 1 for every literal successfully added to the trie.\n    next_literal_index: usize,\n}","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::PreferenceTrie::create_state":["/// Creates a new empty state and returns its ID.\nfn create_state(&mut self) -> usize{\n        let id = self.states.len();\n        self.states.push(State::default());\n        id\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::PreferenceTrie::insert":["/// Returns `Ok` if the given byte string is accepted into this trie and\n/// `Err` otherwise. The index for the success case corresponds to the\n/// index of the literal added. The index for the error case corresponds to\n/// the index of the literal already in the trie that prevented the given\n/// byte string from being added. (Which implies it is a prefix of the one\n/// given.)\n///\n/// In short, the byte string given is accepted into the trie if and only\n/// if it is possible for it to match when executing a preference order\n/// search.\nfn insert(&mut self, bytes: &[u8]) -> Result<usize, usize>{\n        let mut prev = self.root();\n        if let Some(idx) = self.states[prev].literal_index {\n            return Err(idx);\n        }\n        for &b in bytes.iter() {\n            match self.states[prev].trans.binary_search_by_key(&b, |t| t.0) {\n                Ok(i) => {\n                    prev = self.states[prev].trans[i].1;\n                    if let Some(idx) = self.states[prev].literal_index {\n                        return Err(idx);\n                    }\n                }\n                Err(i) => {\n                    let next = self.create_state();\n                    self.states[prev].trans.insert(i, (b, next));\n                    prev = next;\n                }\n            }\n        }\n        let idx = self.next_literal_index;\n        self.next_literal_index += 1;\n        self.states[prev].literal_index = Some(idx);\n        Ok(idx)\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::PreferenceTrie::minimize":["/// Minimizes the given sequence of literals while preserving preference\n/// order semantics.\n///\n/// When `keep_exact` is true, the exactness of every literal retained is\n/// kept. This is useful when dealing with a fully extracted `Seq` that\n/// only contains exact literals. In that case, we can keep all retained\n/// literals as exact because we know we'll never need to match anything\n/// after them and because any removed literals are guaranteed to never\n/// match.\nfn minimize(literals: &mut Vec<Literal>, keep_exact: bool){\n        use core::cell::RefCell;\n\n        // MSRV(1.61): Use retain_mut here to avoid interior mutability.\n        let trie = RefCell::new(PreferenceTrie::default());\n        let mut make_inexact = vec![];\n        literals.retain(|lit| {\n            match trie.borrow_mut().insert(lit.as_bytes()) {\n                Ok(_) => true,\n                Err(i) => {\n                    if !keep_exact {\n                        make_inexact.push(i);\n                    }\n                    false\n                }\n            }\n        });\n        for i in make_inexact {\n            literals[i].make_inexact();\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::PreferenceTrie::root":["/// Returns the root state ID, and if it doesn't exist, creates it.\nfn root(&mut self) -> usize{\n        if !self.states.is_empty() {\n            0\n        } else {\n            self.create_state()\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq":["/// A sequence of literals.\n///\n/// A `Seq` is very much like a set in that it represents a union of its\n/// members. That is, it corresponds to a set of literals where at least one\n/// must match in order for a particular [`Hir`] expression to match. (Whether\n/// this corresponds to the entire `Hir` expression, a prefix of it or a suffix\n/// of it depends on how the `Seq` was extracted from the `Hir`.)\n///\n/// It is also unlike a set in that multiple identical literals may appear,\n/// and that the order of the literals in the `Seq` matters. For example, if\n/// the sequence is `[sam, samwise]` and leftmost-first matching is used, then\n/// `samwise` can never match and the sequence is equivalent to `[sam]`.\n///\n/// # States of a sequence\n///\n/// A `Seq` has a few different logical states to consider:\n///\n/// * The sequence can represent \"any\" literal. When this happens, the set does\n/// not have a finite size. The purpose of this state is to inhibit callers\n/// from making assumptions about what literals are required in order to match\n/// a particular [`Hir`] expression. Generally speaking, when a set is in this\n/// state, literal optimizations are inhibited. A good example of a regex that\n/// will cause this sort of set to apppear is `[A-Za-z]`. The character class\n/// is just too big (and also too narrow) to be usefully expanded into 52\n/// different literals. (Note that the decision for when a seq should become\n/// infinite is determined by the caller. A seq itself has no hard-coded\n/// limits.)\n/// * The sequence can be empty, in which case, it is an affirmative statement\n/// that there are no literals that can match the corresponding `Hir`.\n/// Consequently, the `Hir` never matches any input. For example, `[a&&b]`.\n/// * The sequence can be non-empty, in which case, at least one of the\n/// literals must match in order for the corresponding `Hir` to match.\n///\n/// # Example\n///\n/// This example shows how literal sequences can be simplified by stripping\n/// suffixes and minimizing while maintaining preference order.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq = Seq::new(&[\n///     \"farm\",\n///     \"appliance\",\n///     \"faraway\",\n///     \"apple\",\n///     \"fare\",\n///     \"gap\",\n///     \"applicant\",\n///     \"applaud\",\n/// ]);\n/// seq.keep_first_bytes(3);\n/// seq.minimize_by_preference();\n/// // Notice that 'far' comes before 'app', which matches the order in the\n/// // original sequence. This guarantees that leftmost-first semantics are\n/// // not altered by simplifying the set.\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"far\"),\n///     Literal::inexact(\"app\"),\n///     Literal::exact(\"gap\"),\n/// ]);\n/// assert_eq!(expected, seq);\n/// ```\npub struct Seq {\n    /// The members of this seq.\n    ///\n    /// When `None`, the seq represents all possible literals. That is, it\n    /// prevents one from making assumptions about specific literals in the\n    /// seq, and forces one to treat it as if any literal might be in the seq.\n    ///\n    /// Note that `Some(vec![])` is valid and corresponds to the empty seq of\n    /// literals, i.e., a regex that can never match. For example, `[a&&b]`.\n    /// It is distinct from `Some(vec![\"\"])`, which corresponds to the seq\n    /// containing an empty string, which matches at every position.\n    literals: Option<Vec<Literal>>,\n}","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::cross_forward":["/// Modify this sequence to contain the cross product between it and the\n/// sequence given.\n///\n/// The cross product only considers literals in this sequence that are\n/// exact. That is, inexact literals are not extended.\n///\n/// The literals are always drained from `other`, even if none are used.\n/// This permits callers to reuse the sequence allocation elsewhere.\n///\n/// If this sequence is infinite, then this is a no-op, regardless of what\n/// `other` contains (and in this case, the literals are still drained from\n/// `other`). If `other` is infinite and this sequence is finite, then this\n/// is a no-op, unless this sequence contains a zero-length literal. In\n/// which case, the infiniteness of `other` infects this sequence, and this\n/// sequence is itself made infinite.\n///\n/// Like [`Seq::union`], this may attempt to deduplicate literals. See\n/// [`Seq::dedup`] for how deduplication deals with exact and inexact\n/// literals.\n///\n/// # Example\n///\n/// This example shows basic usage and how exact and inexact literals\n/// interact.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq1 = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// let mut seq2 = Seq::from_iter([\n///     Literal::inexact(\"quux\"),\n///     Literal::exact(\"baz\"),\n/// ]);\n/// seq1.cross_forward(&mut seq2);\n///\n/// // The literals are pulled out of seq2.\n/// assert_eq!(Some(0), seq2.len());\n///\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"fooquux\"),\n///     Literal::exact(\"foobaz\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// assert_eq!(expected, seq1);\n/// ```\n///\n/// This example shows the behavior of when `other` is an infinite\n/// sequence.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq1 = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// let mut seq2 = Seq::infinite();\n/// seq1.cross_forward(&mut seq2);\n///\n/// // When seq2 is infinite, cross product doesn't add anything, but\n/// // ensures all members of seq1 are inexact.\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"foo\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// assert_eq!(expected, seq1);\n/// ```\n///\n/// This example is like the one above, but shows what happens when this\n/// sequence contains an empty string. In this case, an infinite `other`\n/// sequence infects this sequence (because the empty string means that\n/// there are no finite prefixes):\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq1 = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::exact(\"\"), // inexact provokes same behavior\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// let mut seq2 = Seq::infinite();\n/// seq1.cross_forward(&mut seq2);\n///\n/// // seq1 is now infinite!\n/// assert!(!seq1.is_finite());\n/// ```\n///\n/// This example shows the behavior of this sequence is infinite.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq1 = Seq::infinite();\n/// let mut seq2 = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// seq1.cross_forward(&mut seq2);\n///\n/// // seq1 remains unchanged.\n/// assert!(!seq1.is_finite());\n/// // Even though the literals in seq2 weren't used, it was still drained.\n/// assert_eq!(Some(0), seq2.len());\n/// ```\n#[inline]\npub fn cross_forward(&mut self, other: &mut Seq){\n        let (lits1, lits2) = match self.cross_preamble(other) {\n            None => return,\n            Some((lits1, lits2)) => (lits1, lits2),\n        };\n        let newcap = lits1.len().saturating_mul(lits2.len());\n        for selflit in mem::replace(lits1, Vec::with_capacity(newcap)) {\n            if !selflit.is_exact() {\n                lits1.push(selflit);\n                continue;\n            }\n            for otherlit in lits2.iter() {\n                let mut newlit = Literal::exact(Vec::with_capacity(\n                    selflit.len() + otherlit.len(),\n                ));\n                newlit.extend(&selflit);\n                newlit.extend(&otherlit);\n                if !otherlit.is_exact() {\n                    newlit.make_inexact();\n                }\n                lits1.push(newlit);\n            }\n        }\n        lits2.drain(..);\n        self.dedup();\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::cross_preamble":["/// A helper function the corresponds to the subtle preamble for both\n/// `cross_forward` and `cross_reverse`. In effect, it handles the cases\n/// of infinite sequences for both `self` and `other`, as well as ensuring\n/// that literals from `other` are drained even if they aren't used.\nfn cross_preamble<'a>(\n        &'a mut self,\n        other: &'a mut Seq,\n    ) -> Option<(&'a mut Vec<Literal>, &'a mut Vec<Literal>)>{\n        let lits2 = match other.literals {\n            None => {\n                // If our current seq contains the empty string and the seq\n                // we're adding matches any literal, then it follows that the\n                // current seq must now also match any literal.\n                //\n                // Otherwise, we just have to make sure everything in this\n                // sequence is inexact.\n                if self.min_literal_len() == Some(0) {\n                    *self = Seq::infinite();\n                } else {\n                    self.make_inexact();\n                }\n                return None;\n            }\n            Some(ref mut lits) => lits,\n        };\n        let lits1 = match self.literals {\n            None => {\n                // If we aren't going to make it to the end of this routine\n                // where lits2 is drained, then we need to do it now.\n                lits2.drain(..);\n                return None;\n            }\n            Some(ref mut lits) => lits,\n        };\n        Some((lits1, lits2))\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::cross_reverse":["/// Modify this sequence to contain the cross product between it and\n/// the sequence given, where the sequences are treated as suffixes\n/// instead of prefixes. Namely, the sequence `other` is *prepended*\n/// to `self` (as opposed to `other` being *appended* to `self` in\n/// [`Seq::cross_forward`]).\n///\n/// The cross product only considers literals in this sequence that are\n/// exact. That is, inexact literals are not extended.\n///\n/// The literals are always drained from `other`, even if none are used.\n/// This permits callers to reuse the sequence allocation elsewhere.\n///\n/// If this sequence is infinite, then this is a no-op, regardless of what\n/// `other` contains (and in this case, the literals are still drained from\n/// `other`). If `other` is infinite and this sequence is finite, then this\n/// is a no-op, unless this sequence contains a zero-length literal. In\n/// which case, the infiniteness of `other` infects this sequence, and this\n/// sequence is itself made infinite.\n///\n/// Like [`Seq::union`], this may attempt to deduplicate literals. See\n/// [`Seq::dedup`] for how deduplication deals with exact and inexact\n/// literals.\n///\n/// # Example\n///\n/// This example shows basic usage and how exact and inexact literals\n/// interact.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq1 = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// let mut seq2 = Seq::from_iter([\n///     Literal::inexact(\"quux\"),\n///     Literal::exact(\"baz\"),\n/// ]);\n/// seq1.cross_reverse(&mut seq2);\n///\n/// // The literals are pulled out of seq2.\n/// assert_eq!(Some(0), seq2.len());\n///\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"quuxfoo\"),\n///     Literal::inexact(\"bar\"),\n///     Literal::exact(\"bazfoo\"),\n/// ]);\n/// assert_eq!(expected, seq1);\n/// ```\n///\n/// This example shows the behavior of when `other` is an infinite\n/// sequence.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq1 = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// let mut seq2 = Seq::infinite();\n/// seq1.cross_reverse(&mut seq2);\n///\n/// // When seq2 is infinite, cross product doesn't add anything, but\n/// // ensures all members of seq1 are inexact.\n/// let expected = Seq::from_iter([\n///     Literal::inexact(\"foo\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// assert_eq!(expected, seq1);\n/// ```\n///\n/// This example is like the one above, but shows what happens when this\n/// sequence contains an empty string. In this case, an infinite `other`\n/// sequence infects this sequence (because the empty string means that\n/// there are no finite suffixes):\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq1 = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::exact(\"\"), // inexact provokes same behavior\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// let mut seq2 = Seq::infinite();\n/// seq1.cross_reverse(&mut seq2);\n///\n/// // seq1 is now infinite!\n/// assert!(!seq1.is_finite());\n/// ```\n///\n/// This example shows the behavior when this sequence is infinite.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq1 = Seq::infinite();\n/// let mut seq2 = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::inexact(\"bar\"),\n/// ]);\n/// seq1.cross_reverse(&mut seq2);\n///\n/// // seq1 remains unchanged.\n/// assert!(!seq1.is_finite());\n/// // Even though the literals in seq2 weren't used, it was still drained.\n/// assert_eq!(Some(0), seq2.len());\n/// ```\n#[inline]\npub fn cross_reverse(&mut self, other: &mut Seq){\n        let (lits1, lits2) = match self.cross_preamble(other) {\n            None => return,\n            Some((lits1, lits2)) => (lits1, lits2),\n        };\n        // We basically proceed as we do in 'cross_forward' at this point,\n        // except that the outer loop is now 'other' and the inner loop is now\n        // 'self'. That's because 'self' corresponds to suffixes and 'other'\n        // corresponds to the sequence we want to *prepend* to the suffixes.\n        let newcap = lits1.len().saturating_mul(lits2.len());\n        let selflits = mem::replace(lits1, Vec::with_capacity(newcap));\n        for (i, otherlit) in lits2.drain(..).enumerate() {\n            for selflit in selflits.iter() {\n                if !selflit.is_exact() {\n                    // If the suffix isn't exact, then we can't prepend\n                    // anything to it. However, we still want to keep it. But\n                    // we only want to keep one of them, to avoid duplication.\n                    // (The duplication is okay from a correctness perspective,\n                    // but wasteful.)\n                    if i == 0 {\n                        lits1.push(selflit.clone());\n                    }\n                    continue;\n                }\n                let mut newlit = Literal::exact(Vec::with_capacity(\n                    otherlit.len() + selflit.len(),\n                ));\n                newlit.extend(&otherlit);\n                newlit.extend(&selflit);\n                if !otherlit.is_exact() {\n                    newlit.make_inexact();\n                }\n                lits1.push(newlit);\n            }\n        }\n        self.dedup();\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::dedup":["/// Deduplicate adjacent equivalent literals in this sequence.\n///\n/// If adjacent literals are equivalent strings but one is exact and the\n/// other inexact, the inexact literal is kept and the exact one is\n/// removed.\n///\n/// Deduping an infinite sequence is a no-op.\n///\n/// # Example\n///\n/// This example shows how literals that are duplicate byte strings but\n/// are not equivalent with respect to exactness are resolved.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::inexact(\"foo\"),\n/// ]);\n/// seq.dedup();\n///\n/// assert_eq!(Seq::from_iter([Literal::inexact(\"foo\")]), seq);\n/// ```\n#[inline]\npub fn dedup(&mut self){\n        if let Some(ref mut lits) = self.literals {\n            lits.dedup_by(|lit1, lit2| {\n                if lit1.as_bytes() != lit2.as_bytes() {\n                    return false;\n                }\n                if lit1.is_exact() != lit2.is_exact() {\n                    lit1.make_inexact();\n                    lit2.make_inexact();\n                }\n                true\n            });\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::empty":["/// Returns an empty sequence.\n///\n/// An empty sequence matches zero literals, and thus corresponds to a\n/// regex that itself can never match.\n#[inline]\npub fn empty() -> Seq{\n        Seq { literals: Some(vec![]) }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::infinite":["/// Returns a sequence of literals without a finite size and may contain\n/// any literal.\n///\n/// A sequence without finite size does not reveal anything about the\n/// characteristics of the literals in its set. There are no fixed prefixes\n/// or suffixes, nor are lower or upper bounds on the length of the literals\n/// in the set known.\n///\n/// This is useful to represent constructs in a regex that are \"too big\"\n/// to useful represent as a sequence of literals. For example, `[A-Za-z]`.\n/// When sequences get too big, they lose their discriminating nature and\n/// are more likely to produce false positives, which in turn makes them\n/// less likely to speed up searches.\n///\n/// More pragmatically, for many regexes, enumerating all possible literals\n/// is itself not possible or might otherwise use too many resources. So\n/// constraining the size of sets during extraction is a practical trade\n/// off to make.\n#[inline]\npub fn infinite() -> Seq{\n        Seq { literals: None }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::is_empty":["/// Returns true if and only if this sequence is finite and empty.\n///\n/// An empty sequence never matches anything. It can only be produced by\n/// literal extraction when the corresponding regex itself cannot match.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == Some(0)\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::is_exact":["/// Returns true if and only if all literals in this sequence are exact.\n///\n/// This returns false if the sequence is infinite.\n#[inline]\npub fn is_exact(&self) -> bool{\n        self.literals().map_or(false, |lits| lits.iter().all(|x| x.is_exact()))\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::is_finite":["/// Returns true if this sequence is finite.\n///\n/// When false, this sequence is infinite and must be treated as if it\n/// contains every possible literal.\n#[inline]\npub fn is_finite(&self) -> bool{\n        self.literals.is_some()\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::is_inexact":["/// Returns true if and only if all literals in this sequence are inexact.\n///\n/// This returns true if the sequence is infinite.\n#[inline]\npub fn is_inexact(&self) -> bool{\n        self.literals().map_or(true, |lits| lits.iter().all(|x| !x.is_exact()))\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::keep_first_bytes":["/// Trims all literals in this seq such that only the first `len` bytes\n/// remain. If a literal has less than or equal to `len` bytes, then it\n/// remains unchanged. Otherwise, it is trimmed and made inexact.\n///\n/// # Example\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq = Seq::new(&[\"a\", \"foo\", \"quux\"]);\n/// seq.keep_first_bytes(2);\n///\n/// let expected = Seq::from_iter([\n///     Literal::exact(\"a\"),\n///     Literal::inexact(\"fo\"),\n///     Literal::inexact(\"qu\"),\n/// ]);\n/// assert_eq!(expected, seq);\n/// ```\n#[inline]\npub fn keep_first_bytes(&mut self, len: usize){\n        if let Some(ref mut lits) = self.literals {\n            for m in lits.iter_mut() {\n                m.keep_first_bytes(len);\n            }\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::keep_last_bytes":["/// Trims all literals in this seq such that only the last `len` bytes\n/// remain. If a literal has less than or equal to `len` bytes, then it\n/// remains unchanged. Otherwise, it is trimmed and made inexact.\n///\n/// # Example\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// let mut seq = Seq::new(&[\"a\", \"foo\", \"quux\"]);\n/// seq.keep_last_bytes(2);\n///\n/// let expected = Seq::from_iter([\n///     Literal::exact(\"a\"),\n///     Literal::inexact(\"oo\"),\n///     Literal::inexact(\"ux\"),\n/// ]);\n/// assert_eq!(expected, seq);\n/// ```\n#[inline]\npub fn keep_last_bytes(&mut self, len: usize){\n        if let Some(ref mut lits) = self.literals {\n            for m in lits.iter_mut() {\n                m.keep_last_bytes(len);\n            }\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::len":["/// Returns the number of literals in this sequence if the sequence is\n/// finite. If the sequence is infinite, then `None` is returned.\n#[inline]\npub fn len(&self) -> Option<usize>{\n        self.literals.as_ref().map(|lits| lits.len())\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::literals":["/// If this is a finite sequence, return its members as a slice of\n/// literals.\n///\n/// The slice returned may be empty, in which case, there are no literals\n/// that can match this sequence.\n#[inline]\npub fn literals(&self) -> Option<&[Literal]>{\n        self.literals.as_deref()\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::longest_common_prefix":["/// Returns the longest common prefix from this seq.\n///\n/// If the seq matches any literal or other contains no literals, then\n/// there is no meaningful prefix and this returns `None`.\n///\n/// # Example\n///\n/// This shows some example seqs and their longest common prefix.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let seq = Seq::new(&[\"foo\", \"foobar\", \"fo\"]);\n/// assert_eq!(Some(&b\"fo\"[..]), seq.longest_common_prefix());\n/// let seq = Seq::new(&[\"foo\", \"foo\"]);\n/// assert_eq!(Some(&b\"foo\"[..]), seq.longest_common_prefix());\n/// let seq = Seq::new(&[\"foo\", \"bar\"]);\n/// assert_eq!(Some(&b\"\"[..]), seq.longest_common_prefix());\n/// let seq = Seq::new(&[\"\"]);\n/// assert_eq!(Some(&b\"\"[..]), seq.longest_common_prefix());\n///\n/// let seq = Seq::infinite();\n/// assert_eq!(None, seq.longest_common_prefix());\n/// let seq = Seq::empty();\n/// assert_eq!(None, seq.longest_common_prefix());\n/// ```\n#[inline]\npub fn longest_common_prefix(&self) -> Option<&[u8]>{\n        // If we match everything or match nothing, then there's no meaningful\n        // longest common prefix.\n        let lits = match self.literals {\n            None => return None,\n            Some(ref lits) => lits,\n        };\n        if lits.len() == 0 {\n            return None;\n        }\n        let base = lits[0].as_bytes();\n        let mut len = base.len();\n        for m in lits.iter().skip(1) {\n            len = m\n                .as_bytes()\n                .iter()\n                .zip(base[..len].iter())\n                .take_while(|&(a, b)| a == b)\n                .count();\n            if len == 0 {\n                return Some(&[]);\n            }\n        }\n        Some(&base[..len])\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::longest_common_suffix":["/// Returns the longest common suffix from this seq.\n///\n/// If the seq matches any literal or other contains no literals, then\n/// there is no meaningful suffix and this returns `None`.\n///\n/// # Example\n///\n/// This shows some example seqs and their longest common suffix.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let seq = Seq::new(&[\"oof\", \"raboof\", \"of\"]);\n/// assert_eq!(Some(&b\"of\"[..]), seq.longest_common_suffix());\n/// let seq = Seq::new(&[\"foo\", \"foo\"]);\n/// assert_eq!(Some(&b\"foo\"[..]), seq.longest_common_suffix());\n/// let seq = Seq::new(&[\"foo\", \"bar\"]);\n/// assert_eq!(Some(&b\"\"[..]), seq.longest_common_suffix());\n/// let seq = Seq::new(&[\"\"]);\n/// assert_eq!(Some(&b\"\"[..]), seq.longest_common_suffix());\n///\n/// let seq = Seq::infinite();\n/// assert_eq!(None, seq.longest_common_suffix());\n/// let seq = Seq::empty();\n/// assert_eq!(None, seq.longest_common_suffix());\n/// ```\n#[inline]\npub fn longest_common_suffix(&self) -> Option<&[u8]>{\n        // If we match everything or match nothing, then there's no meaningful\n        // longest common suffix.\n        let lits = match self.literals {\n            None => return None,\n            Some(ref lits) => lits,\n        };\n        if lits.len() == 0 {\n            return None;\n        }\n        let base = lits[0].as_bytes();\n        let mut len = base.len();\n        for m in lits.iter().skip(1) {\n            len = m\n                .as_bytes()\n                .iter()\n                .rev()\n                .zip(base[base.len() - len..].iter().rev())\n                .take_while(|&(a, b)| a == b)\n                .count();\n            if len == 0 {\n                return Some(&[]);\n            }\n        }\n        Some(&base[base.len() - len..])\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::make_inexact":["/// Make all of the literals in this sequence inexact.\n///\n/// This is a no-op if this sequence is not finite.\n#[inline]\npub fn make_inexact(&mut self){\n        let lits = match self.literals {\n            None => return,\n            Some(ref mut lits) => lits,\n        };\n        for lit in lits.iter_mut() {\n            lit.make_inexact();\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::make_infinite":["/// Converts this sequence to an infinite sequence.\n///\n/// This is a no-op if the sequence is already infinite.\n#[inline]\npub fn make_infinite(&mut self){\n        self.literals = None;\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::max_cross_len":["/// Return the maximum length of the sequence that would result from the\n/// cross product of `self` with `other`. If either set is infinite, then\n/// this returns `None`.\n#[inline]\nfn max_cross_len(&self, other: &Seq) -> Option<usize>{\n        let len1 = self.len()?;\n        let len2 = other.len()?;\n        Some(len1.saturating_mul(len2))\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::max_literal_len":["/// Returns the length of the longest literal in this sequence.\n///\n/// If the sequence is infinite or empty, then this returns `None`.\n#[inline]\npub fn max_literal_len(&self) -> Option<usize>{\n        self.literals.as_ref()?.iter().map(|x| x.len()).max()\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::max_union_len":["/// Return the maximum length of the sequence that would result from\n/// unioning `self` with `other`. If either set is infinite, then this\n/// returns `None`.\n#[inline]\nfn max_union_len(&self, other: &Seq) -> Option<usize>{\n        let len1 = self.len()?;\n        let len2 = other.len()?;\n        Some(len1.saturating_add(len2))\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::min_literal_len":["/// Returns the length of the shortest literal in this sequence.\n///\n/// If the sequence is infinite or empty, then this returns `None`.\n#[inline]\npub fn min_literal_len(&self) -> Option<usize>{\n        self.literals.as_ref()?.iter().map(|x| x.len()).min()\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::minimize_by_preference":["/// Shrinks this seq to its minimal size while respecting the preference\n/// order of its literals.\n///\n/// While this routine will remove duplicate literals from this seq, it\n/// will also remove literals that can never match in a leftmost-first or\n/// \"preference order\" search. Similar to [`Seq::dedup`], if a literal is\n/// deduped, then the one that remains is made inexact.\n///\n/// This is a no-op on seqs that are empty or not finite.\n///\n/// # Example\n///\n/// This example shows the difference between `{sam, samwise}` and\n/// `{samwise, sam}`.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// // If 'sam' comes before 'samwise' and a preference order search is\n/// // executed, then 'samwise' can never match.\n/// let mut seq = Seq::new(&[\"sam\", \"samwise\"]);\n/// seq.minimize_by_preference();\n/// assert_eq!(Seq::from_iter([Literal::inexact(\"sam\")]), seq);\n///\n/// // But if they are reversed, then it's possible for 'samwise' to match\n/// // since it is given higher preference.\n/// let mut seq = Seq::new(&[\"samwise\", \"sam\"]);\n/// seq.minimize_by_preference();\n/// assert_eq!(Seq::new(&[\"samwise\", \"sam\"]), seq);\n/// ```\n///\n/// This example shows that if an empty string is in this seq, then\n/// anything that comes after it can never match.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Literal, Seq};\n///\n/// // An empty string is a prefix of all strings, so it automatically\n/// // inhibits any subsequent strings from matching.\n/// let mut seq = Seq::new(&[\"foo\", \"bar\", \"\", \"quux\", \"fox\"]);\n/// seq.minimize_by_preference();\n/// let expected = Seq::from_iter([\n///     Literal::exact(\"foo\"),\n///     Literal::exact(\"bar\"),\n///     Literal::inexact(\"\"),\n/// ]);\n/// assert_eq!(expected, seq);\n///\n/// // And of course, if it's at the beginning, then it makes it impossible\n/// // for anything else to match.\n/// let mut seq = Seq::new(&[\"\", \"foo\", \"quux\", \"fox\"]);\n/// seq.minimize_by_preference();\n/// assert_eq!(Seq::from_iter([Literal::inexact(\"\")]), seq);\n/// ```\n#[inline]\npub fn minimize_by_preference(&mut self){\n        if let Some(ref mut lits) = self.literals {\n            PreferenceTrie::minimize(lits, false);\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::new":["/// Returns a sequence of exact literals from the given byte strings.\n#[inline]\npub fn new<I, B>(it: I) -> Seq\n    where\n        I: IntoIterator<Item = B>,\n        B: AsRef<[u8]>,{\n        it.into_iter().map(|b| Literal::exact(b.as_ref())).collect()\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::optimize_by_preference":["fn optimize_by_preference(&mut self, prefix: bool){\n        let origlen = match self.len() {\n            None => return,\n            Some(len) => len,\n        };\n        // Make sure we start with the smallest sequence possible. We use a\n        // special version of preference minimization that retains exactness.\n        // This is legal because optimization is only expected to occur once\n        // extraction is complete.\n        if prefix {\n            if let Some(ref mut lits) = self.literals {\n                PreferenceTrie::minimize(lits, true);\n            }\n        }\n\n        // Look for a common prefix (or suffix). If we found one of those and\n        // it's long enough, then it's a good bet that it will be our fastest\n        // possible prefilter since single-substring search is so fast.\n        let fix = if prefix {\n            self.longest_common_prefix()\n        } else {\n            self.longest_common_suffix()\n        };\n        if let Some(fix) = fix {\n            // As a special case, if we have a common prefix and the leading\n            // byte of that prefix is one that we think probably occurs rarely,\n            // then strip everything down to just that single byte. This should\n            // promote the use of memchr.\n            //\n            // ... we only do this though if our sequence has more than one\n            // literal. Otherwise, we'd rather just stick with a single literal\n            // scan. That is, using memchr is probably better than looking\n            // for 2 or more literals, but probably not as good as a straight\n            // memmem search.\n            //\n            // ... and also only do this when the prefix is short and probably\n            // not too discriminatory anyway. If it's longer, then it's\n            // probably quite discriminatory and thus is likely to have a low\n            // false positive rate.\n            if prefix\n                && origlen > 1\n                && fix.len() >= 1\n                && fix.len() <= 3\n                && rank(fix[0]) < 200\n            {\n                self.keep_first_bytes(1);\n                self.dedup();\n                return;\n            }\n            // We only strip down to the common prefix/suffix if we think\n            // the existing set of literals isn't great, or if the common\n            // prefix/suffix is expected to be particularly discriminatory.\n            let isfast =\n                self.is_exact() && self.len().map_or(false, |len| len <= 16);\n            let usefix = fix.len() > 4 || (fix.len() > 1 && !isfast);\n            if usefix {\n                // If we keep exactly the number of bytes equal to the length\n                // of the prefix (or suffix), then by the definition of a\n                // prefix, every literal in the sequence will be equivalent.\n                // Thus, 'dedup' will leave us with one literal.\n                //\n                // We do it this way to avoid an alloc, but also to make sure\n                // the exactness of literals is kept (or not).\n                if prefix {\n                    self.keep_first_bytes(fix.len());\n                } else {\n                    self.keep_last_bytes(fix.len());\n                }\n                self.dedup();\n                assert_eq!(Some(1), self.len());\n                // We still fall through here. In particular, we want our\n                // longest common prefix to be subject to the poison check.\n            }\n        }\n        // Everything below this check is more-or-less about trying to\n        // heuristically reduce the false positive rate of a prefilter. But\n        // if our sequence is completely exact, then it's possible the regex\n        // engine can be skipped entirely. In this case, the false positive\n        // rate is zero because every literal match corresponds to a regex\n        // match.\n        //\n        // This is OK even if the sequence contains a poison literal. Remember,\n        // a literal is only poisononous because of what we assume about its\n        // impact on the false positive rate. However, we do still check for\n        // an empty string. Empty strings are weird and it's best to let the\n        // regex engine handle those.\n        //\n        // We do currently do this check after the longest common prefix (or\n        // suffix) check, under the theory that single-substring search is so\n        // fast that we want that even if we'd end up turning an exact sequence\n        // into an inexact one. But this might be wrong...\n        if self.is_exact()\n            && self.min_literal_len().map_or(false, |len| len > 0)\n        {\n            return;\n        }\n        // Now we attempt to shorten the sequence. The idea here is that we\n        // don't want to look for too many literals, but we want to shorten\n        // our sequence enough to improve our odds of using better algorithms\n        // downstream (such as Teddy).\n        const ATTEMPTS: [(usize, usize); 5] =\n            [(5, 64), (4, 64), (3, 64), (2, 64), (1, 10)];\n        for (keep, limit) in ATTEMPTS {\n            let len = match self.len() {\n                None => break,\n                Some(len) => len,\n            };\n            if len <= limit {\n                break;\n            }\n            if prefix {\n                self.keep_first_bytes(keep);\n            } else {\n                self.keep_last_bytes(keep);\n            }\n            self.minimize_by_preference();\n        }\n        // Check for a poison literal. A poison literal is one that is short\n        // and is believed to have a very high match count. These poisons\n        // generally lead to a prefilter with a very high false positive rate,\n        // and thus overall worse performance.\n        //\n        // We do this last because we could have gone from a non-poisonous\n        // sequence to a poisonous one. Perhaps we should add some code to\n        // prevent such transitions in the first place, but then again, we\n        // likely only made the transition in the first place if the sequence\n        // was itself huge. And huge sequences are themselves poisonous. So...\n        if let Some(lits) = self.literals() {\n            if lits.iter().any(|lit| lit.is_poisonous()) {\n                self.make_infinite();\n            }\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::optimize_for_prefix_by_preference":["/// Optimizes this seq while treating its literals as prefixes and\n/// respecting the preference order of its literals.\n///\n/// The specific way \"optimization\" works is meant to be an implementation\n/// detail, as it essentially represents a set of heuristics. The goal\n/// that optimization tries to accomplish is to make the literals in this\n/// set reflect inputs that will result in a more effective prefilter.\n/// Principally by reducing the false positive rate of candidates found by\n/// the literals in this sequence. That is, when a match of a literal is\n/// found, we would like it to be a strong predictor of the overall match\n/// of the regex. If it isn't, then much time will be spent starting and\n/// stopping the prefilter search and attempting to confirm the match only\n/// to have it fail.\n///\n/// Some of those heuristics might be:\n///\n/// * Identifying a common prefix from a larger sequence of literals, and\n/// shrinking the sequence down to that single common prefix.\n/// * Rejecting the sequence entirely if it is believed to result in very\n/// high false positive rate. When this happens, the sequence is made\n/// infinite.\n/// * Shrinking the sequence to a smaller number of literals representing\n/// prefixes, but not shrinking it so much as to make literals too short.\n/// (A sequence with very short literals, of 1 or 2 bytes, will typically\n/// result in a higher false positive rate.)\n///\n/// Optimization should only be run once extraction is complete. Namely,\n/// optimization may make assumptions that do not compose with other\n/// operations in the middle of extraction. For example, optimization will\n/// reduce `[E(sam), E(samwise)]` to `[E(sam)]`, but such a transformation\n/// is only valid if no other extraction will occur. If other extraction\n/// may occur, then the correct transformation would be to `[I(sam)]`.\n///\n/// The [`Seq::optimize_for_suffix_by_preference`] does the same thing, but\n/// for suffixes.\n///\n/// # Example\n///\n/// This shows how optimization might transform a sequence. Note that\n/// the specific behavior is not a documented guarantee. The heuristics\n/// used are an implementation detail and may change over time in semver\n/// compatible releases.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Seq, Literal};\n///\n/// let mut seq = Seq::new(&[\n///     \"samantha\",\n///     \"sam\",\n///     \"samwise\",\n///     \"frodo\",\n/// ]);\n/// seq.optimize_for_prefix_by_preference();\n/// assert_eq!(Seq::from_iter([\n///     Literal::exact(\"samantha\"),\n///     // Kept exact even though 'samwise' got pruned\n///     // because optimization assumes literal extraction\n///     // has finished.\n///     Literal::exact(\"sam\"),\n///     Literal::exact(\"frodo\"),\n/// ]), seq);\n/// ```\n///\n/// # Example: optimization may make the sequence infinite\n///\n/// If the heuristics deem that the sequence could cause a very high false\n/// positive rate, then it may make the sequence infinite, effectively\n/// disabling its use as a prefilter.\n///\n/// ```\n/// use regex_syntax::hir::literal::{Seq, Literal};\n///\n/// let mut seq = Seq::new(&[\n///     \"samantha\",\n///     // An empty string matches at every position,\n///     // thus rendering the prefilter completely\n///     // ineffective.\n///     \"\",\n///     \"sam\",\n///     \"samwise\",\n///     \"frodo\",\n/// ]);\n/// seq.optimize_for_prefix_by_preference();\n/// assert!(!seq.is_finite());\n/// ```\n///\n/// Do note that just because there is a `\" \"` in the sequence, that\n/// doesn't mean the sequence will always be made infinite after it is\n/// optimized. Namely, if the sequence is considered exact (any match\n/// corresponds to an overall match of the original regex), then any match\n/// is an overall match, and so the false positive rate is always `0`.\n///\n/// To demonstrate this, we remove `samwise` from our sequence. This\n/// results in no optimization happening and all literals remain exact.\n/// Thus the entire sequence is exact, and it is kept as-is, even though\n/// one is an ASCII space:\n///\n/// ```\n/// use regex_syntax::hir::literal::{Seq, Literal};\n///\n/// let mut seq = Seq::new(&[\n///     \"samantha\",\n///     \" \",\n///     \"sam\",\n///     \"frodo\",\n/// ]);\n/// seq.optimize_for_prefix_by_preference();\n/// assert!(seq.is_finite());\n/// ```\n#[inline]\npub fn optimize_for_prefix_by_preference(&mut self){\n        self.optimize_by_preference(true);\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::optimize_for_suffix_by_preference":["/// Optimizes this seq while treating its literals as suffixes and\n/// respecting the preference order of its literals.\n///\n/// Optimization should only be run once extraction is complete.\n///\n/// The [`Seq::optimize_for_prefix_by_preference`] does the same thing, but\n/// for prefixes. See its documentation for more explanation.\n#[inline]\npub fn optimize_for_suffix_by_preference(&mut self){\n        self.optimize_by_preference(false);\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::push":["/// Push a literal to the end of this sequence.\n///\n/// If this sequence is not finite, then this is a no-op.\n///\n/// Similarly, if the most recently added item of this sequence is\n/// equivalent to the literal given, then it is not added. This reflects\n/// a `Seq`'s \"set like\" behavior, and represents a practical trade off.\n/// Namely, there is never any need to have two adjacent and equivalent\n/// literals in the same sequence, _and_ it is easy to detect in some\n/// cases.\n#[inline]\npub fn push(&mut self, lit: Literal){\n        let lits = match self.literals {\n            None => return,\n            Some(ref mut lits) => lits,\n        };\n        if lits.last().map_or(false, |m| m == &lit) {\n            return;\n        }\n        lits.push(lit);\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::reverse_literals":["/// Reverses all of the literals in this sequence.\n///\n/// The order of the sequence itself is preserved.\n///\n/// # Example\n///\n/// This example shows basic usage.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let mut seq = Seq::new(&[\"oof\", \"rab\"]);\n/// seq.reverse_literals();\n/// assert_eq!(Seq::new(&[\"foo\", \"bar\"]), seq);\n/// ```\n#[inline]\npub fn reverse_literals(&mut self){\n        if let Some(ref mut lits) = self.literals {\n            for lit in lits.iter_mut() {\n                lit.reverse();\n            }\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::singleton":["/// Returns a sequence containing a single literal.\n#[inline]\npub fn singleton(lit: Literal) -> Seq{\n        Seq { literals: Some(vec![lit]) }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::sort":["/// Sorts this sequence of literals lexicographically.\n///\n/// Note that if, before sorting, if a literal that is a prefix of another\n/// literal appears after it, then after sorting, the sequence will not\n/// represent the same preference order match semantics. For example,\n/// sorting the sequence `[samwise, sam]` yields the sequence `[sam,\n/// samwise]`. Under preference order semantics, the latter sequence will\n/// never match `samwise` where as the first sequence can.\n///\n/// # Example\n///\n/// This example shows basic usage.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let mut seq = Seq::new(&[\"foo\", \"quux\", \"bar\"]);\n/// seq.sort();\n///\n/// assert_eq!(Seq::new(&[\"bar\", \"foo\", \"quux\"]), seq);\n/// ```\n#[inline]\npub fn sort(&mut self){\n        if let Some(ref mut lits) = self.literals {\n            lits.sort();\n        }\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::union":["/// Unions the `other` sequence into this one.\n///\n/// The literals are always drained out of the given `other` sequence,\n/// even if they are being unioned into an infinite sequence. This permits\n/// the caller to reuse the `other` sequence in another context.\n///\n/// Some literal deduping may be performed. If any deduping happens,\n/// any leftmost-first or \"preference\" order match semantics will be\n/// preserved.\n///\n/// # Example\n///\n/// This example shows basic usage.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let mut seq1 = Seq::new(&[\"foo\", \"bar\"]);\n/// let mut seq2 = Seq::new(&[\"bar\", \"quux\", \"foo\"]);\n/// seq1.union(&mut seq2);\n///\n/// // The literals are pulled out of seq2.\n/// assert_eq!(Some(0), seq2.len());\n///\n/// // Adjacent literals are deduped, but non-adjacent literals may not be.\n/// assert_eq!(Seq::new(&[\"foo\", \"bar\", \"quux\", \"foo\"]), seq1);\n/// ```\n///\n/// This example shows that literals are drained from `other` even when\n/// they aren't necessarily used.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let mut seq1 = Seq::infinite();\n/// // Infinite sequences have no finite length.\n/// assert_eq!(None, seq1.len());\n///\n/// let mut seq2 = Seq::new(&[\"bar\", \"quux\", \"foo\"]);\n/// seq1.union(&mut seq2);\n///\n/// // seq1 is still infinite and seq2 has been drained.\n/// assert_eq!(None, seq1.len());\n/// assert_eq!(Some(0), seq2.len());\n/// ```\n#[inline]\npub fn union(&mut self, other: &mut Seq){\n        let lits2 = match other.literals {\n            None => {\n                // Unioning with an infinite sequence always results in an\n                // infinite sequence.\n                self.make_infinite();\n                return;\n            }\n            Some(ref mut lits) => lits.drain(..),\n        };\n        let lits1 = match self.literals {\n            None => return,\n            Some(ref mut lits) => lits,\n        };\n        lits1.extend(lits2);\n        self.dedup();\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::Seq::union_into_empty":["/// Unions the `other` sequence into this one by splice the `other`\n/// sequence at the position of the first zero-length literal.\n///\n/// This is useful for preserving preference order semantics when combining\n/// two literal sequences. For example, in the regex `(a||f)+foo`, the\n/// correct preference order prefix sequence is `[a, foo, f]`.\n///\n/// The literals are always drained out of the given `other` sequence,\n/// even if they are being unioned into an infinite sequence. This permits\n/// the caller to reuse the `other` sequence in another context. Note that\n/// the literals are drained even if no union is performed as well, i.e.,\n/// when this sequence does not contain a zero-length literal.\n///\n/// Some literal deduping may be performed. If any deduping happens,\n/// any leftmost-first or \"preference\" order match semantics will be\n/// preserved.\n///\n/// # Example\n///\n/// This example shows basic usage.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let mut seq1 = Seq::new(&[\"a\", \"\", \"f\", \"\"]);\n/// let mut seq2 = Seq::new(&[\"foo\"]);\n/// seq1.union_into_empty(&mut seq2);\n///\n/// // The literals are pulled out of seq2.\n/// assert_eq!(Some(0), seq2.len());\n/// // 'foo' gets spliced into seq1 where the first empty string occurs.\n/// assert_eq!(Seq::new(&[\"a\", \"foo\", \"f\"]), seq1);\n/// ```\n///\n/// This example shows that literals are drained from `other` even when\n/// they aren't necessarily used.\n///\n/// ```\n/// use regex_syntax::hir::literal::Seq;\n///\n/// let mut seq1 = Seq::new(&[\"foo\", \"bar\"]);\n/// let mut seq2 = Seq::new(&[\"bar\", \"quux\", \"foo\"]);\n/// seq1.union_into_empty(&mut seq2);\n///\n/// // seq1 has no zero length literals, so no splicing happens.\n/// assert_eq!(Seq::new(&[\"foo\", \"bar\"]), seq1);\n/// // Even though no splicing happens, seq2 is still drained.\n/// assert_eq!(Some(0), seq2.len());\n/// ```\n#[inline]\npub fn union_into_empty(&mut self, other: &mut Seq){\n        let lits2 = other.literals.as_mut().map(|lits| lits.drain(..));\n        let lits1 = match self.literals {\n            None => return,\n            Some(ref mut lits) => lits,\n        };\n        let first_empty = match lits1.iter().position(|m| m.is_empty()) {\n            None => return,\n            Some(i) => i,\n        };\n        let lits2 = match lits2 {\n            None => {\n                // Note that we are only here if we've found an empty literal,\n                // which implies that an infinite sequence infects this seq and\n                // also turns it into an infinite sequence.\n                self.literals = None;\n                return;\n            }\n            Some(lits) => lits,\n        };\n        // Clearing out the empties needs to come before the splice because\n        // the splice might add more empties that we don't want to get rid\n        // of. Since we're splicing into the position of the first empty, the\n        // 'first_empty' position computed above is still correct.\n        lits1.retain(|m| !m.is_empty());\n        lits1.splice(first_empty..first_empty, lits2);\n        self.dedup();\n    }","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::State":["/// A single state in a trie. Uses a sparse representation for its transitions.\nstruct State {\n    /// Sparse representation of the transitions out of this state. Transitions\n    /// are sorted by byte. There is at most one such transition for any\n    /// particular byte.\n    trans: Vec<(u8, usize)>,\n    /// Whether this is a matching state or not. If it is, then it contains the\n    /// index to the matching literal.\n    literal_index: Option<usize>,\n}","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::literal::rank":["/// Returns the \"rank\" of the given byte.\n///\n/// The minimum rank value is `0` and the maximum rank value is `255`.\n///\n/// The rank of a byte is derived from a heuristic background distribution of\n/// relative frequencies of bytes. The heuristic says that lower the rank of a\n/// byte, the less likely that byte is to appear in any arbitrary haystack.\npub fn rank(byte: u8) -> u8{\n    crate::rank::BYTE_FREQUENCIES[usize::from(byte)]\n}","Real(LocalPath(\"src/hir/literal.rs\"))"],"hir::print::Printer":["/// A printer for a regular expression's high-level intermediate\n/// representation.\n///\n/// A printer converts a high-level intermediate representation (HIR) to a\n/// regular expression pattern string. This particular printer uses constant\n/// stack space and heap space proportional to the size of the HIR.\n///\n/// Since this printer is only using the HIR, the pattern it prints will likely\n/// not resemble the original pattern at all. For example, a pattern like\n/// `\\pL` will have its entire class written out.\n///\n/// The purpose of this printer is to provide a means to mutate an HIR and then\n/// build a regular expression from the result of that mutation. (A regex\n/// library could provide a constructor from this HIR explicitly, but that\n/// creates an unnecessary public coupling between the regex library and this\n/// specific HIR representation.)\npub struct Printer {\n    _priv: (),\n}","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Printer::new":["/// Create a new printer.\npub fn new() -> Printer{\n        PrinterBuilder::new().build()\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Printer::print":["/// Print the given `Ast` to the given writer. The writer must implement\n/// `fmt::Write`. Typical implementations of `fmt::Write` that can be used\n/// here are a `fmt::Formatter` (which is available in `fmt::Display`\n/// implementations) or a `&mut String`.\npub fn print<W: fmt::Write>(&mut self, hir: &Hir, wtr: W) -> fmt::Result{\n        visitor::visit(hir, Writer { wtr })\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::PrinterBuilder":["/// A builder for constructing a printer.\n///\n/// Note that since a printer doesn't have any configuration knobs, this type\n/// remains unexported.\nstruct PrinterBuilder {\n    _priv: (),\n}","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::PrinterBuilder::build":["fn build(&self) -> Printer{\n        Printer { _priv: () }\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::PrinterBuilder::new":["fn new() -> PrinterBuilder{\n        PrinterBuilder { _priv: () }\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Writer":["struct Writer<W> {\n    wtr: W,\n}","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Writer::<W>::write_literal_byte":["fn write_literal_byte(&mut self, b: u8) -> fmt::Result{\n        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {\n            self.write_literal_char(char::try_from(b).unwrap())\n        } else {\n            write!(self.wtr, \"(?-u:\\\\x{:02X})\", b)\n        }\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Writer::<W>::write_literal_char":["fn write_literal_char(&mut self, c: char) -> fmt::Result{\n        if is_meta_character(c) {\n            self.wtr.write_str(\"\\\\\")?;\n        }\n        self.wtr.write_char(c)\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::print::Writer::<W>::write_literal_class_byte":["fn write_literal_class_byte(&mut self, b: u8) -> fmt::Result{\n        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {\n            self.write_literal_char(char::try_from(b).unwrap())\n        } else {\n            write!(self.wtr, \"\\\\x{:02X}\", b)\n        }\n    }","Real(LocalPath(\"src/hir/print.rs\"))"],"hir::singleton_bytes":["/// Given a sequence of HIR values where each value corresponds to a literal\n/// that is a single byte, return that sequence of bytes. Otherwise return\n/// None. No deduplication is done.\nfn singleton_bytes(hirs: &[Hir]) -> Option<Vec<u8>>{\n    let mut singletons = vec![];\n    for hir in hirs.iter() {\n        let literal = match *hir.kind() {\n            HirKind::Literal(Literal(ref bytes)) => bytes,\n            _ => return None,\n        };\n        if literal.len() != 1 {\n            return None;\n        }\n        singletons.push(literal[0]);\n    }\n    Some(singletons)\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::singleton_chars":["/// Given a sequence of HIR values where each value corresponds to a literal\n/// that is a single `char`, return that sequence of `char`s. Otherwise return\n/// None. No deduplication is done.\nfn singleton_chars(hirs: &[Hir]) -> Option<Vec<char>>{\n    let mut singletons = vec![];\n    for hir in hirs.iter() {\n        let literal = match *hir.kind() {\n            HirKind::Literal(Literal(ref bytes)) => bytes,\n            _ => return None,\n        };\n        let ch = match crate::debug::utf8_decode(literal) {\n            None => return None,\n            Some(Err(_)) => return None,\n            Some(Ok(ch)) => ch,\n        };\n        if literal.len() != ch.len_utf8() {\n            return None;\n        }\n        singletons.push(ch);\n    }\n    Some(singletons)\n}","Real(LocalPath(\"src/hir/mod.rs\"))"],"hir::translate::Flags":["/// A translator's representation of a regular expression's flags at any given\n/// moment in time.\n///\n/// Each flag can be in one of three states: absent, present but disabled or\n/// present but enabled.\nstruct Flags {\n    case_insensitive: Option<bool>,\n    multi_line: Option<bool>,\n    dot_matches_new_line: Option<bool>,\n    swap_greed: Option<bool>,\n    unicode: Option<bool>,\n    crlf: Option<bool>,\n    // Note that `ignore_whitespace` is omitted here because it is handled\n    // entirely in the parser.\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::case_insensitive":["fn case_insensitive(&self) -> bool{\n        self.case_insensitive.unwrap_or(false)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::crlf":["fn crlf(&self) -> bool{\n        self.crlf.unwrap_or(false)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::dot":["fn dot(&self) -> hir::Dot{\n        if self.dot_matches_new_line() {\n            if self.unicode() {\n                hir::Dot::AnyChar\n            } else {\n                hir::Dot::AnyByte\n            }\n        } else {\n            if self.unicode() {\n                if self.crlf() {\n                    hir::Dot::AnyCharExceptCRLF\n                } else {\n                    hir::Dot::AnyCharExceptLF\n                }\n            } else {\n                if self.crlf() {\n                    hir::Dot::AnyByteExceptCRLF\n                } else {\n                    hir::Dot::AnyByteExceptLF\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::dot_matches_new_line":["fn dot_matches_new_line(&self) -> bool{\n        self.dot_matches_new_line.unwrap_or(false)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::from_ast":["fn from_ast(ast: &ast::Flags) -> Flags{\n        let mut flags = Flags::default();\n        let mut enable = true;\n        for item in &ast.items {\n            match item.kind {\n                ast::FlagsItemKind::Negation => {\n                    enable = false;\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive) => {\n                    flags.case_insensitive = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::MultiLine) => {\n                    flags.multi_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::DotMatchesNewLine) => {\n                    flags.dot_matches_new_line = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::SwapGreed) => {\n                    flags.swap_greed = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::Unicode) => {\n                    flags.unicode = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::CRLF) => {\n                    flags.crlf = Some(enable);\n                }\n                ast::FlagsItemKind::Flag(ast::Flag::IgnoreWhitespace) => {}\n            }\n        }\n        flags\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::merge":["fn merge(&mut self, previous: &Flags){\n        if self.case_insensitive.is_none() {\n            self.case_insensitive = previous.case_insensitive;\n        }\n        if self.multi_line.is_none() {\n            self.multi_line = previous.multi_line;\n        }\n        if self.dot_matches_new_line.is_none() {\n            self.dot_matches_new_line = previous.dot_matches_new_line;\n        }\n        if self.swap_greed.is_none() {\n            self.swap_greed = previous.swap_greed;\n        }\n        if self.unicode.is_none() {\n            self.unicode = previous.unicode;\n        }\n        if self.crlf.is_none() {\n            self.crlf = previous.crlf;\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::multi_line":["fn multi_line(&self) -> bool{\n        self.multi_line.unwrap_or(false)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::swap_greed":["fn swap_greed(&self) -> bool{\n        self.swap_greed.unwrap_or(false)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Flags::unicode":["fn unicode(&self) -> bool{\n        self.unicode.unwrap_or(true)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame":["/// An HirFrame is a single stack frame, represented explicitly, which is\n/// created for each item in the Ast that we traverse.\n///\n/// Note that technically, this type doesn't represent our entire stack\n/// frame. In particular, the Ast visitor represents any state associated with\n/// traversing the Ast itself.\nenum HirFrame {\n    /// An arbitrary HIR expression. These get pushed whenever we hit a base\n    /// case in the Ast. They get popped after an inductive (i.e., recursive)\n    /// step is complete.\n    Expr(Hir),\n    /// A literal that is being constructed, character by character, from the\n    /// AST. We need this because the AST gives each individual character its\n    /// own node. So as we see characters, we peek at the top-most HirFrame.\n    /// If it's a literal, then we add to it. Otherwise, we push a new literal.\n    /// When it comes time to pop it, we convert it to an Hir via Hir::literal.\n    Literal(Vec<u8>),\n    /// A Unicode character class. This frame is mutated as we descend into\n    /// the Ast of a character class (which is itself its own mini recursive\n    /// structure).\n    ClassUnicode(hir::ClassUnicode),\n    /// A byte-oriented character class. This frame is mutated as we descend\n    /// into the Ast of a character class (which is itself its own mini\n    /// recursive structure).\n    ///\n    /// Byte character classes are created when Unicode mode (`u`) is disabled.\n    /// If `utf8` is enabled (the default), then a byte character is only\n    /// permitted to match ASCII text.\n    ClassBytes(hir::ClassBytes),\n    /// This is pushed whenever a repetition is observed. After visiting every\n    /// sub-expression in the repetition, the translator's stack is expected to\n    /// have this sentinel at the top.\n    ///\n    /// This sentinel only exists to stop other things (like flattening\n    /// literals) from reaching across repetition operators.\n    Repetition,\n    /// This is pushed on to the stack upon first seeing any kind of capture,\n    /// indicated by parentheses (including non-capturing groups). It is popped\n    /// upon leaving a group.\n    Group {\n        /// The old active flags when this group was opened.\n        ///\n        /// If this group sets flags, then the new active flags are set to the\n        /// result of merging the old flags with the flags introduced by this\n        /// group. If the group doesn't set any flags, then this is simply\n        /// equivalent to whatever flags were set when the group was opened.\n        ///\n        /// When this group is popped, the active flags should be restored to\n        /// the flags set here.\n        ///\n        /// The \"active\" flags correspond to whatever flags are set in the\n        /// Translator.\n        old_flags: Flags,\n    },\n    /// This is pushed whenever a concatenation is observed. After visiting\n    /// every sub-expression in the concatenation, the translator's stack is\n    /// popped until it sees a Concat frame.\n    Concat,\n    /// This is pushed whenever an alternation is observed. After visiting\n    /// every sub-expression in the alternation, the translator's stack is\n    /// popped until it sees an Alternation frame.\n    Alternation,\n    /// This is pushed immediately before each sub-expression in an\n    /// alternation. This separates the branches of an alternation on the\n    /// stack and prevents literal flattening from reaching across alternation\n    /// branches.\n    ///\n    /// It is popped after each expression in a branch until an 'Alternation'\n    /// frame is observed when doing a post visit on an alternation.\n    AlternationBranch,\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_alternation_pipe":["/// Assert that the current stack frame is an alternation pipe sentinel. If\n/// it isn't, then panic.\nfn unwrap_alternation_pipe(self){\n        match self {\n            HirFrame::AlternationBranch => {}\n            _ => {\n                panic!(\n                    \"tried to unwrap alt pipe from HirFrame, got: {:?}\",\n                    self\n                )\n            }\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_class_bytes":["/// Assert that the current stack frame is a byte class expression and\n/// return it.\nfn unwrap_class_bytes(self) -> hir::ClassBytes{\n        match self {\n            HirFrame::ClassBytes(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap byte class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_class_unicode":["/// Assert that the current stack frame is a Unicode class expression and\n/// return it.\nfn unwrap_class_unicode(self) -> hir::ClassUnicode{\n        match self {\n            HirFrame::ClassUnicode(cls) => cls,\n            _ => panic!(\n                \"tried to unwrap Unicode class \\\n                 from HirFrame, got: {:?}\",\n                self\n            ),\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_expr":["/// Assert that the current stack frame is an Hir expression and return it.\nfn unwrap_expr(self) -> Hir{\n        match self {\n            HirFrame::Expr(expr) => expr,\n            HirFrame::Literal(lit) => Hir::literal(lit),\n            _ => panic!(\"tried to unwrap expr from HirFrame, got: {:?}\", self),\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_group":["/// Assert that the current stack frame is a group indicator and return\n/// its corresponding flags (the flags that were active at the time the\n/// group was entered).\nfn unwrap_group(self) -> Flags{\n        match self {\n            HirFrame::Group { old_flags } => old_flags,\n            _ => {\n                panic!(\"tried to unwrap group from HirFrame, got: {:?}\", self)\n            }\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::HirFrame::unwrap_repetition":["/// Assert that the current stack frame is a repetition sentinel. If it\n/// isn't, then panic.\nfn unwrap_repetition(self){\n        match self {\n            HirFrame::Repetition => {}\n            _ => {\n                panic!(\n                    \"tried to unwrap repetition from HirFrame, got: {:?}\",\n                    self\n                )\n            }\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Translator":["/// A translator maps abstract syntax to a high level intermediate\n/// representation.\n///\n/// A translator may be benefit from reuse. That is, a translator can translate\n/// many abstract syntax trees.\n///\n/// A `Translator` can be configured in more detail via a\n/// [`TranslatorBuilder`].\npub struct Translator {\n    /// Our call stack, but on the heap.\n    stack: RefCell<Vec<HirFrame>>,\n    /// The current flag settings.\n    flags: Cell<Flags>,\n    /// Whether we're allowed to produce HIR that can match arbitrary bytes.\n    utf8: bool,\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Translator::new":["/// Create a new translator using the default configuration.\npub fn new() -> Translator{\n        TranslatorBuilder::new().build()\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::Translator::translate":["/// Translate the given abstract syntax tree (AST) into a high level\n/// intermediate representation (HIR).\n///\n/// If there was a problem doing the translation, then an HIR-specific\n/// error is returned.\n///\n/// The original pattern string used to produce the `Ast` *must* also be\n/// provided. The translator does not use the pattern string during any\n/// correct translation, but is used for error reporting.\npub fn translate(&mut self, pattern: &str, ast: &Ast) -> Result<Hir>{\n        ast::visit(ast, TranslatorI::new(self, pattern))\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder":["/// A builder for constructing an AST->HIR translator.\npub struct TranslatorBuilder {\n    utf8: bool,\n    flags: Flags,\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::build":["/// Build a translator using the current configuration.\npub fn build(&self) -> Translator{\n        Translator {\n            stack: RefCell::new(vec![]),\n            flags: Cell::new(self.flags),\n            utf8: self.utf8,\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::case_insensitive":["/// Enable or disable the case insensitive flag (`i`) by default.\npub fn case_insensitive(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.flags.case_insensitive = if yes { Some(true) } else { None };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::crlf":["/// Enable or disable the CRLF mode flag (`R`) by default.\npub fn crlf(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.flags.crlf = if yes { Some(true) } else { None };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::dot_matches_new_line":["/// Enable or disable the \"dot matches any character\" flag (`s`) by\n/// default.\npub fn dot_matches_new_line(\n        &mut self,\n        yes: bool,\n    ) -> &mut TranslatorBuilder{\n        self.flags.dot_matches_new_line = if yes { Some(true) } else { None };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::multi_line":["/// Enable or disable the multi-line matching flag (`m`) by default.\npub fn multi_line(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.flags.multi_line = if yes { Some(true) } else { None };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::new":["/// Create a new translator builder with a default c onfiguration.\npub fn new() -> TranslatorBuilder{\n        TranslatorBuilder { utf8: true, flags: Flags::default() }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::swap_greed":["/// Enable or disable the \"swap greed\" flag (`U`) by default.\npub fn swap_greed(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.flags.swap_greed = if yes { Some(true) } else { None };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::unicode":["/// Enable or disable the Unicode flag (`u`) by default.\npub fn unicode(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.flags.unicode = if yes { None } else { Some(false) };\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorBuilder::utf8":["/// When disabled, translation will permit the construction of a regular\n/// expression that may match invalid UTF-8.\n///\n/// When enabled (the default), the translator is guaranteed to produce an\n/// expression that, for non-empty matches, will only ever produce spans\n/// that are entirely valid UTF-8 (otherwise, the translator will return an\n/// error).\n///\n/// Perhaps surprisingly, when UTF-8 is enabled, an empty regex or even\n/// a negated ASCII word boundary (uttered as `(?-u:\\B)` in the concrete\n/// syntax) will be allowed even though they can produce matches that split\n/// a UTF-8 encoded codepoint. This only applies to zero-width or \"empty\"\n/// matches, and it is expected that the regex engine itself must handle\n/// these cases if necessary (perhaps by suppressing any zero-width matches\n/// that split a codepoint).\npub fn utf8(&mut self, yes: bool) -> &mut TranslatorBuilder{\n        self.utf8 = yes;\n        self\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI":["/// The internal implementation of a translator.\n///\n/// This type is responsible for carrying around the original pattern string,\n/// which is not tied to the internal state of a translator.\n///\n/// A TranslatorI exists for the time it takes to translate a single Ast.\nstruct TranslatorI<'t, 'p> {\n    trans: &'t Translator,\n    pattern: &'p str,\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::ast_literal_to_scalar":["/// Convert an Ast literal to its scalar representation.\n///\n/// When Unicode mode is enabled, then this always succeeds and returns a\n/// `char` (Unicode scalar value).\n///\n/// When Unicode mode is disabled, then a `char` will still be returned\n/// whenever possible. A byte is returned only when invalid UTF-8 is\n/// allowed and when the byte is not ASCII. Otherwise, a non-ASCII byte\n/// will result in an error when invalid UTF-8 is not allowed.\nfn ast_literal_to_scalar(\n        &self,\n        lit: &ast::Literal,\n    ) -> Result<Either<char, u8>>{\n        if self.flags().unicode() {\n            return Ok(Either::Left(lit.c));\n        }\n        let byte = match lit.byte() {\n            None => return Ok(Either::Left(lit.c)),\n            Some(byte) => byte,\n        };\n        if byte <= 0x7F {\n            return Ok(Either::Left(char::try_from(byte).unwrap()));\n        }\n        if self.trans().utf8 {\n            return Err(self.error(lit.span, ErrorKind::InvalidUtf8));\n        }\n        Ok(Either::Right(byte))\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate":["fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()>{\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation first, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.case_fold_simple();\n        }\n        if negated {\n            class.negate();\n        }\n        if self.trans().utf8 && !class.is_ascii() {\n            return Err(self.error(span.clone(), ErrorKind::InvalidUtf8));\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::case_fold_char":["fn case_fold_char(&self, span: Span, c: char) -> Result<Option<Hir>>{\n        if !self.flags().case_insensitive() {\n            return Ok(None);\n        }\n        if self.flags().unicode() {\n            // If case folding won't do anything, then don't bother trying.\n            let map = unicode::SimpleCaseFolder::new()\n                .map(|f| f.overlaps(c, c))\n                .map_err(|_| {\n                    self.error(span, ErrorKind::UnicodeCaseUnavailable)\n                })?;\n            if !map {\n                return Ok(None);\n            }\n            let mut cls =\n                hir::ClassUnicode::new(vec![hir::ClassUnicodeRange::new(\n                    c, c,\n                )]);\n            cls.try_case_fold_simple().map_err(|_| {\n                self.error(span, ErrorKind::UnicodeCaseUnavailable)\n            })?;\n            Ok(Some(Hir::class(hir::Class::Unicode(cls))))\n        } else {\n            if c.len_utf8() > 1 {\n                return Err(self.error(span, ErrorKind::UnicodeNotAllowed));\n            }\n            // If case folding won't do anything, then don't bother trying.\n            match c {\n                'A'..='Z' | 'a'..='z' => {}\n                _ => return Ok(None),\n            }\n            let mut cls =\n                hir::ClassBytes::new(vec![hir::ClassBytesRange::new(\n                    // OK because 'c.len_utf8() == 1' which in turn implies\n                    // that 'c' is ASCII.\n                    u8::try_from(c).unwrap(),\n                    u8::try_from(c).unwrap(),\n                )]);\n            cls.case_fold_simple();\n            Ok(Some(Hir::class(hir::Class::Bytes(cls))))\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::class_literal_byte":["/// Return a scalar byte value suitable for use as a literal in a byte\n/// character class.\nfn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8>{\n        match self.ast_literal_to_scalar(ast)? {\n            Either::Right(byte) => Ok(byte),\n            Either::Left(ch) => {\n                let cp = u32::from(ch);\n                if cp <= 0x7F {\n                    Ok(u8::try_from(cp).unwrap())\n                } else {\n                    // We can't feasibly support Unicode in\n                    // byte oriented classes. Byte classes don't\n                    // do Unicode case folding.\n                    Err(self.error(ast.span, ErrorKind::UnicodeNotAllowed))\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error":["/// Converts the given Unicode specific error to an HIR translation error.\n///\n/// The span given should approximate the position at which an error would\n/// occur.\nfn convert_unicode_class_error(\n        &self,\n        span: &Span,\n        result: core::result::Result<hir::ClassUnicode, unicode::Error>,\n    ) -> Result<hir::ClassUnicode>{\n        result.map_err(|err| {\n            let sp = span.clone();\n            match err {\n                unicode::Error::PropertyNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyNotFound)\n                }\n                unicode::Error::PropertyValueNotFound => {\n                    self.error(sp, ErrorKind::UnicodePropertyValueNotFound)\n                }\n                unicode::Error::PerlClassNotFound => {\n                    self.error(sp, ErrorKind::UnicodePerlClassNotFound)\n                }\n            }\n        })\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::error":["/// Create a new error with the given span and error type.\nfn error(&self, span: Span, kind: ErrorKind) -> Error{\n        Error { kind, pattern: self.pattern.to_string(), span }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::flags":["/// Return a copy of the active flags.\nfn flags(&self) -> Flags{\n        self.trans().flags.get()\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_ascii_byte_class":["fn hir_ascii_byte_class(\n        &self,\n        ast: &ast::ClassAscii,\n    ) -> Result<hir::ClassBytes>{\n        let mut cls = hir::ClassBytes::new(\n            ascii_class(&ast.kind)\n                .map(|(s, e)| hir::ClassBytesRange::new(s, e)),\n        );\n        self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls)?;\n        Ok(cls)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_ascii_unicode_class":["fn hir_ascii_unicode_class(\n        &self,\n        ast: &ast::ClassAscii,\n    ) -> Result<hir::ClassUnicode>{\n        let mut cls = hir::ClassUnicode::new(\n            ascii_class_as_chars(&ast.kind)\n                .map(|(s, e)| hir::ClassUnicodeRange::new(s, e)),\n        );\n        self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls)?;\n        Ok(cls)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_assertion":["fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir>{\n        let unicode = self.flags().unicode();\n        let multi_line = self.flags().multi_line();\n        let crlf = self.flags().crlf();\n        Ok(match asst.kind {\n            ast::AssertionKind::StartLine => Hir::look(if multi_line {\n                if crlf {\n                    hir::Look::StartCRLF\n                } else {\n                    hir::Look::StartLF\n                }\n            } else {\n                hir::Look::Start\n            }),\n            ast::AssertionKind::EndLine => Hir::look(if multi_line {\n                if crlf {\n                    hir::Look::EndCRLF\n                } else {\n                    hir::Look::EndLF\n                }\n            } else {\n                hir::Look::End\n            }),\n            ast::AssertionKind::StartText => Hir::look(hir::Look::Start),\n            ast::AssertionKind::EndText => Hir::look(hir::Look::End),\n            ast::AssertionKind::WordBoundary => Hir::look(if unicode {\n                hir::Look::WordUnicode\n            } else {\n                hir::Look::WordAscii\n            }),\n            ast::AssertionKind::NotWordBoundary => Hir::look(if unicode {\n                hir::Look::WordUnicodeNegate\n            } else {\n                hir::Look::WordAsciiNegate\n            }),\n        })\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_capture":["fn hir_capture(&self, group: &ast::Group, expr: Hir) -> Hir{\n        let (index, name) = match group.kind {\n            ast::GroupKind::CaptureIndex(index) => (index, None),\n            ast::GroupKind::CaptureName { ref name, .. } => {\n                (name.index, Some(name.name.clone().into_boxed_str()))\n            }\n            // The HIR doesn't need to use non-capturing groups, since the way\n            // in which the data type is defined handles this automatically.\n            ast::GroupKind::NonCapturing(_) => return expr,\n        };\n        Hir::capture(hir::Capture { index, name, sub: Box::new(expr) })\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_dot":["fn hir_dot(&self, span: Span) -> Result<Hir>{\n        if !self.flags().unicode() && self.trans().utf8 {\n            return Err(self.error(span, ErrorKind::InvalidUtf8));\n        }\n        Ok(Hir::dot(self.flags().dot()))\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class":["fn hir_perl_byte_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassBytes>{\n        use crate::ast::ClassPerlKind::*;\n\n        assert!(!self.flags().unicode());\n        let mut class = match ast_class.kind {\n            Digit => hir_ascii_class_bytes(&ast::ClassAsciiKind::Digit),\n            Space => hir_ascii_class_bytes(&ast::ClassAsciiKind::Space),\n            Word => hir_ascii_class_bytes(&ast::ClassAsciiKind::Word),\n        };\n        // We needn't apply case folding here because the Perl ASCII classes\n        // are already closed (under ASCII case folding).\n        if ast_class.negated {\n            class.negate();\n        }\n        // Negating a Perl byte class is likely to cause it to match invalid\n        // UTF-8. That's only OK if the translator is configured to allow such\n        // things.\n        if self.trans().utf8 && !class.is_ascii() {\n            return Err(self.error(ast_class.span, ErrorKind::InvalidUtf8));\n        }\n        Ok(class)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class":["fn hir_perl_unicode_class(\n        &self,\n        ast_class: &ast::ClassPerl,\n    ) -> Result<hir::ClassUnicode>{\n        use crate::ast::ClassPerlKind::*;\n\n        assert!(self.flags().unicode());\n        let result = match ast_class.kind {\n            Digit => unicode::perl_digit(),\n            Space => unicode::perl_space(),\n            Word => unicode::perl_word(),\n        };\n        let mut class =\n            self.convert_unicode_class_error(&ast_class.span, result)?;\n        // We needn't apply case folding here because the Perl Unicode classes\n        // are already closed under Unicode simple case folding.\n        if ast_class.negated {\n            class.negate();\n        }\n        Ok(class)\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_repetition":["fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir{\n        let (min, max) = match rep.op.kind {\n            ast::RepetitionKind::ZeroOrOne => (0, Some(1)),\n            ast::RepetitionKind::ZeroOrMore => (0, None),\n            ast::RepetitionKind::OneOrMore => (1, None),\n            ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {\n                (m, Some(m))\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {\n                (m, None)\n            }\n            ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(\n                m,\n                n,\n            )) => (m, Some(n)),\n        };\n        let greedy =\n            if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };\n        Hir::repetition(hir::Repetition {\n            min,\n            max,\n            greedy,\n            sub: Box::new(expr),\n        })\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class":["fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode>{\n        use crate::ast::ClassUnicodeKind::*;\n\n        if !self.flags().unicode() {\n            return Err(\n                self.error(ast_class.span, ErrorKind::UnicodeNotAllowed)\n            );\n        }\n        let query = match ast_class.kind {\n            OneLetter(name) => ClassQuery::OneLetter(name),\n            Named(ref name) => ClassQuery::Binary(name),\n            NamedValue { ref name, ref value, .. } => ClassQuery::ByValue {\n                property_name: name,\n                property_value: value,\n            },\n        };\n        let mut result = self.convert_unicode_class_error(\n            &ast_class.span,\n            unicode::class(query),\n        );\n        if let Ok(ref mut class) = result {\n            self.unicode_fold_and_negate(\n                &ast_class.span,\n                ast_class.negated,\n                class,\n            )?;\n        }\n        result\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::new":["/// Build a new internal translator.\nfn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p>{\n        TranslatorI { trans, pattern }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::pop":["/// Pop the top of the call stack. If the call stack is empty, return None.\nfn pop(&self) -> Option<HirFrame>{\n        self.trans().stack.borrow_mut().pop()\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::pop_alt_expr":["/// Pop an HIR expression from the top of the stack for an alternation.\n///\n/// This returns None if the stack is empty or when an alternation frame is\n/// seen. Otherwise, it panics if it could not find an HIR expression.\nfn pop_alt_expr(&self) -> Option<Hir>{\n        let frame = self.pop()?;\n        match frame {\n            HirFrame::Alternation => None,\n            HirFrame::Expr(expr) => Some(expr),\n            HirFrame::Literal(lit) => Some(Hir::literal(lit)),\n            HirFrame::ClassUnicode(_) => {\n                unreachable!(\"expected expr or alt, got Unicode class\")\n            }\n            HirFrame::ClassBytes(_) => {\n                unreachable!(\"expected expr or alt, got byte class\")\n            }\n            HirFrame::Repetition => {\n                unreachable!(\"expected expr or alt, got repetition\")\n            }\n            HirFrame::Group { .. } => {\n                unreachable!(\"expected expr or alt, got group\")\n            }\n            HirFrame::Concat => {\n                unreachable!(\"expected expr or alt, got concat marker\")\n            }\n            HirFrame::AlternationBranch => {\n                unreachable!(\"expected expr or alt, got alt branch marker\")\n            }\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::pop_concat_expr":["/// Pop an HIR expression from the top of the stack for a concatenation.\n///\n/// This returns None if the stack is empty or when a concat frame is seen.\n/// Otherwise, it panics if it could not find an HIR expression.\nfn pop_concat_expr(&self) -> Option<Hir>{\n        let frame = self.pop()?;\n        match frame {\n            HirFrame::Concat => None,\n            HirFrame::Expr(expr) => Some(expr),\n            HirFrame::Literal(lit) => Some(Hir::literal(lit)),\n            HirFrame::ClassUnicode(_) => {\n                unreachable!(\"expected expr or concat, got Unicode class\")\n            }\n            HirFrame::ClassBytes(_) => {\n                unreachable!(\"expected expr or concat, got byte class\")\n            }\n            HirFrame::Repetition => {\n                unreachable!(\"expected expr or concat, got repetition\")\n            }\n            HirFrame::Group { .. } => {\n                unreachable!(\"expected expr or concat, got group\")\n            }\n            HirFrame::Alternation => {\n                unreachable!(\"expected expr or concat, got alt marker\")\n            }\n            HirFrame::AlternationBranch => {\n                unreachable!(\"expected expr or concat, got alt branch marker\")\n            }\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::push":["/// Push the given frame on to the call stack.\nfn push(&self, frame: HirFrame){\n        self.trans().stack.borrow_mut().push(frame);\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::push_byte":["/// Push the given literal byte on to the call stack.\n///\n/// If the top-most element of the stack is a literal, then the byte\n/// is appended to the end of that literal. Otherwise, a new literal\n/// containing just the given byte is pushed to the top of the stack.\nfn push_byte(&self, byte: u8){\n        let mut stack = self.trans().stack.borrow_mut();\n        if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {\n            literal.push(byte);\n        } else {\n            stack.push(HirFrame::Literal(vec![byte]));\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::push_char":["/// Push the given literal char on to the call stack.\n///\n/// If the top-most element of the stack is a literal, then the char\n/// is appended to the end of that literal. Otherwise, a new literal\n/// containing just the given char is pushed to the top of the stack.\nfn push_char(&self, ch: char){\n        let mut buf = [0; 4];\n        let bytes = ch.encode_utf8(&mut buf).as_bytes();\n        let mut stack = self.trans().stack.borrow_mut();\n        if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {\n            literal.extend_from_slice(bytes);\n        } else {\n            stack.push(HirFrame::Literal(bytes.to_vec()));\n        }\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::set_flags":["/// Set the flags of this translator from the flags set in the given AST.\n/// Then, return the old flags.\nfn set_flags(&self, ast_flags: &ast::Flags) -> Flags{\n        let old_flags = self.flags();\n        let mut new_flags = Flags::from_ast(ast_flags);\n        new_flags.merge(&old_flags);\n        self.trans().flags.set(new_flags);\n        old_flags\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::trans":["/// Return a reference to the underlying translator.\nfn trans(&self) -> &Translator{\n        &self.trans\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate":["fn unicode_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassUnicode,\n    ) -> Result<()>{\n        // Note that we must apply case folding before negation!\n        // Consider `(?i)[^x]`. If we applied negation first, then\n        // the result would be the character class that matched any\n        // Unicode scalar value.\n        if self.flags().case_insensitive() {\n            class.try_case_fold_simple().map_err(|_| {\n                self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)\n            })?;\n        }\n        if negated {\n            class.negate();\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::ascii_class":["fn ascii_class(kind: &ast::ClassAsciiKind) -> impl Iterator<Item = (u8, u8)>{\n    use crate::ast::ClassAsciiKind::*;\n\n    let slice: &'static [(u8, u8)] = match *kind {\n        Alnum => &[(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')],\n        Alpha => &[(b'A', b'Z'), (b'a', b'z')],\n        Ascii => &[(b'\\x00', b'\\x7F')],\n        Blank => &[(b'\\t', b'\\t'), (b' ', b' ')],\n        Cntrl => &[(b'\\x00', b'\\x1F'), (b'\\x7F', b'\\x7F')],\n        Digit => &[(b'0', b'9')],\n        Graph => &[(b'!', b'~')],\n        Lower => &[(b'a', b'z')],\n        Print => &[(b' ', b'~')],\n        Punct => &[(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')],\n        Space => &[\n            (b'\\t', b'\\t'),\n            (b'\\n', b'\\n'),\n            (b'\\x0B', b'\\x0B'),\n            (b'\\x0C', b'\\x0C'),\n            (b'\\r', b'\\r'),\n            (b' ', b' '),\n        ],\n        Upper => &[(b'A', b'Z')],\n        Word => &[(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')],\n        Xdigit => &[(b'0', b'9'), (b'A', b'F'), (b'a', b'f')],\n    };\n    slice.iter().copied()\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::ascii_class_as_chars":["fn ascii_class_as_chars(\n    kind: &ast::ClassAsciiKind,\n) -> impl Iterator<Item = (char, char)>{\n    ascii_class(kind).map(|(s, e)| (char::from(s), char::from(e)))\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::translate::hir_ascii_class_bytes":["fn hir_ascii_class_bytes(kind: &ast::ClassAsciiKind) -> hir::ClassBytes{\n    let ranges: Vec<_> = ascii_class(kind)\n        .map(|(s, e)| hir::ClassBytesRange::new(s, e))\n        .collect();\n    hir::ClassBytes::new(ranges)\n}","Real(LocalPath(\"src/hir/translate.rs\"))"],"hir::visitor::Frame":["/// Represents a single stack frame while performing structural induction over\n/// an `Hir`.\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a hir::Repetition),\n    /// A stack frame allocated just before descending into a capture's child\n    /// node.\n    Capture(&'a hir::Capture),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Frame::<'a>::child":["/// Perform the next inductive step on this frame and return the next\n/// child HIR node to visit.\nfn child(&self) -> &'a Hir{\n        match *self {\n            Frame::Repetition(rep) => &rep.sub,\n            Frame::Capture(capture) => &capture.sub,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor":["/// HeapVisitor visits every item in an `Hir` recursively using constant stack\n/// size and a heap size proportional to the size of the `Hir`.\nstruct HeapVisitor<'a> {\n    /// A stack of `Hir` nodes. This is roughly analogous to the call stack\n    /// used in a typical recursive visitor.\n    stack: Vec<(&'a Hir, Frame<'a>)>,\n}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor::<'a>::induct":["/// Build a stack frame for the given HIR if one is needed (which occurs if\n/// and only if there are child nodes in the HIR). Otherwise, return None.\nfn induct(&mut self, hir: &'a Hir) -> Option<Frame<'a>>{\n        match *hir.kind() {\n            HirKind::Repetition(ref x) => Some(Frame::Repetition(x)),\n            HirKind::Capture(ref x) => Some(Frame::Capture(x)),\n            HirKind::Concat(ref x) if x.is_empty() => None,\n            HirKind::Concat(ref x) => {\n                Some(Frame::Concat { head: &x[0], tail: &x[1..] })\n            }\n            HirKind::Alternation(ref x) if x.is_empty() => None,\n            HirKind::Alternation(ref x) => {\n                Some(Frame::Alternation { head: &x[0], tail: &x[1..] })\n            }\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor::<'a>::new":["fn new() -> HeapVisitor<'a>{\n        HeapVisitor { stack: vec![] }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor::<'a>::pop":["/// Pops the given frame. If the frame has an additional inductive step,\n/// then return it, otherwise return `None`.\nfn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>>{\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Capture(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::HeapVisitor::<'a>::visit":["fn visit<V: Visitor>(\n        &mut self,\n        mut hir: &'a Hir,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err>{\n        self.stack.clear();\n\n        visitor.start();\n        loop {\n            visitor.visit_pre(hir)?;\n            if let Some(x) = self.induct(hir) {\n                let child = x.child();\n                self.stack.push((hir, x));\n                hir = child;\n                continue;\n            }\n            // No induction means we have a base case, so we can post visit\n            // it now.\n            visitor.visit_post(hir)?;\n\n            // At this point, we now try to pop our call stack until it is\n            // either empty or we hit another inductive case.\n            loop {\n                let (post_hir, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_hir, frame)) => (post_hir, frame),\n                };\n                // If this is a concat/alternate, then we might have additional\n                // inductive steps to process.\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    hir = x.child();\n                    self.stack.push((post_hir, x));\n                    break;\n                }\n                // Otherwise, we've finished visiting all the child nodes for\n                // this HIR, so we can post visit it now.\n                visitor.visit_post(post_hir)?;\n            }\n        }\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor":["/// A trait for visiting the high-level IR (HIR) in depth first order.\n///\n/// The principle aim of this trait is to enable callers to perform case\n/// analysis on a high-level intermediate representation of a regular\n/// expression without necessarily using recursion. In particular, this permits\n/// callers to do case analysis with constant stack usage, which can be\n/// important since the size of an HIR may be proportional to end user input.\n///\n/// Typical usage of this trait involves providing an implementation and then\n/// running it using the [`visit`] function.\npub trait Visitor {\n    /// The result of visiting an HIR.\n    type Output;\n    /// An error that visiting an HIR might return.\n    type Err;\n\n    /// All implementors of `Visitor` must provide a `finish` method, which\n    /// yields the result of visiting the HIR or an error.\n    fn finish(self) -> Result<Self::Output, Self::Err>;\n\n    /// This method is called before beginning traversal of the HIR.\n    fn start(&mut self) {}\n\n    /// This method is called on an `Hir` before descending into child `Hir`\n    /// nodes.\n    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called on an `Hir` after descending all of its child\n    /// `Hir` nodes.\n    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> {\n        Ok(())\n    }\n\n    /// This method is called between child nodes of an alternation.\n    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> {\n        Ok(())\n    }\n}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor::start":["/// This method is called before beginning traversal of the HIR.\nfn start(&mut self){}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor::visit_alternation_in":["/// This method is called between child nodes of an alternation.\nfn visit_alternation_in(&mut self) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor::visit_post":["/// This method is called on an `Hir` after descending all of its child\n/// `Hir` nodes.\nfn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::Visitor::visit_pre":["/// This method is called on an `Hir` before descending into child `Hir`\n/// nodes.\nfn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err>{\n        Ok(())\n    }","Real(LocalPath(\"src/hir/visitor.rs\"))"],"hir::visitor::visit":["/// Executes an implementation of `Visitor` in constant stack space.\n///\n/// This function will visit every node in the given `Hir` while calling\n/// appropriate methods provided by the [`Visitor`] trait.\n///\n/// The primary use case for this method is when one wants to perform case\n/// analysis over an `Hir` without using a stack size proportional to the depth\n/// of the `Hir`. Namely, this method will instead use constant stack space,\n/// but will use heap space proportional to the size of the `Hir`. This may be\n/// desirable in cases where the size of `Hir` is proportional to end user\n/// input.\n///\n/// If the visitor returns an error at any point, then visiting is stopped and\n/// the error is returned.\npub fn visit<V: Visitor>(hir: &Hir, visitor: V) -> Result<V::Output, V::Err>{\n    HeapVisitor::new().visit(hir, visitor)\n}","Real(LocalPath(\"src/hir/visitor.rs\"))"],"is_escapeable_character":["/// Returns true if the given character can be escaped in a regex.\n///\n/// This returns true in all cases that `is_meta_character` returns true, but\n/// also returns true in some cases where `is_meta_character` returns false.\n/// For example, `%` is not a meta character, but it is escapeable. That is,\n/// `%` and `\\%` both match a literal `%` in all contexts.\n///\n/// The purpose of this routine is to provide knowledge about what characters\n/// may be escaped. Namely, most regex engines permit \"superfluous\" escapes\n/// where characters without any special significance may be escaped even\n/// though there is no actual _need_ to do so.\n///\n/// This will return false for some characters. For example, `e` is not\n/// escapeable. Therefore, `\\e` will either result in a parse error (which is\n/// true today), or it could backwards compatibly evolve into a new construct\n/// with its own meaning. Indeed, that is the purpose of banning _some_\n/// superfluous escapes: it provides a way to evolve the syntax in a compatible\n/// manner.\n///\n/// # Example\n///\n/// ```\n/// use regex_syntax::is_escapeable_character;\n///\n/// assert!(is_escapeable_character('?'));\n/// assert!(is_escapeable_character('-'));\n/// assert!(is_escapeable_character('&'));\n/// assert!(is_escapeable_character('#'));\n/// assert!(is_escapeable_character('%'));\n/// assert!(is_escapeable_character('/'));\n/// assert!(is_escapeable_character('!'));\n/// assert!(is_escapeable_character('\"'));\n///\n/// assert!(!is_escapeable_character('e'));\n/// ```\npub fn is_escapeable_character(c: char) -> bool{\n    // Certainly escapeable if it's a meta character.\n    if is_meta_character(c) {\n        return true;\n    }\n    // Any character that isn't ASCII is definitely not escapeable. There's\n    // no real need to allow things like \\☃ right?\n    if !c.is_ascii() {\n        return false;\n    }\n    // Otherwise, we basically say that everything is escapeable unless it's a\n    // letter or digit. Things like \\3 are either octal (when enabled) or an\n    // error, and we should keep it that way. Otherwise, letters are reserved\n    // for adding new syntax in a backwards compatible way.\n    match c {\n        '0'..='9' | 'A'..='Z' | 'a'..='z' => false,\n        // While not currently supported, we keep these as not escapeable to\n        // give us some flexibility with respect to supporting the \\< and\n        // \\> word boundary assertions in the future. By rejecting them as\n        // escapeable, \\< and \\> will result in a parse error. Thus, we can\n        // turn them into something else in the future without it being a\n        // backwards incompatible change.\n        '<' | '>' => false,\n        _ => true,\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"is_meta_character":["/// Returns true if the given character has significance in a regex.\n///\n/// Generally speaking, these are the only characters which _must_ be escaped\n/// in order to match their literal meaning. For example, to match a literal\n/// `|`, one could write `\\|`. Sometimes escaping isn't always necessary. For\n/// example, `-` is treated as a meta character because of its significance\n/// for writing ranges inside of character classes, but the regex `-` will\n/// match a literal `-` because `-` has no special meaning outside of character\n/// classes.\n///\n/// In order to determine whether a character may be escaped at all, the\n/// [`is_escapeable_character`] routine should be used. The difference between\n/// `is_meta_character` and `is_escapeable_character` is that the latter will\n/// return true for some characters that are _not_ meta characters. For\n/// example, `%` and `\\%` both match a literal `%` in all contexts. In other\n/// words, `is_escapeable_character` includes \"superfluous\" escapes.\n///\n/// Note that the set of characters for which this function returns `true` or\n/// `false` is fixed and won't change in a semver compatible release. (In this\n/// case, \"semver compatible release\" actually refers to the `regex` crate\n/// itself, since reducing or expanding the set of meta characters would be a\n/// breaking change for not just `regex-syntax` but also `regex` itself.)\n///\n/// # Example\n///\n/// ```\n/// use regex_syntax::is_meta_character;\n///\n/// assert!(is_meta_character('?'));\n/// assert!(is_meta_character('-'));\n/// assert!(is_meta_character('&'));\n/// assert!(is_meta_character('#'));\n///\n/// assert!(!is_meta_character('%'));\n/// assert!(!is_meta_character('/'));\n/// assert!(!is_meta_character('!'));\n/// assert!(!is_meta_character('\"'));\n/// assert!(!is_meta_character('e'));\n/// ```\npub fn is_meta_character(c: char) -> bool{\n    match c {\n        '\\\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' | '[' | ']' | '{'\n        | '}' | '^' | '$' | '#' | '&' | '-' | '~' => true,\n        _ => false,\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"is_word_byte":["/// Returns true if and only if the given character is an ASCII word character.\n///\n/// An ASCII word character is defined by the following character class:\n/// `[_0-9a-zA-Z]'.\npub fn is_word_byte(c: u8) -> bool{\n    match c {\n        b'_' | b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' => true,\n        _ => false,\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"is_word_character":["/// Returns true if and only if the given character is a Unicode word\n/// character.\n///\n/// A Unicode word character is defined by\n/// [UTS#18 Annex C](https://unicode.org/reports/tr18/#Compatibility_Properties).\n/// In particular, a character\n/// is considered a word character if it is in either of the `Alphabetic` or\n/// `Join_Control` properties, or is in one of the `Decimal_Number`, `Mark`\n/// or `Connector_Punctuation` general categories.\n///\n/// # Panics\n///\n/// If the `unicode-perl` feature is not enabled, then this function\n/// panics. For this reason, it is recommended that callers use\n/// [`try_is_word_character`] instead.\npub fn is_word_character(c: char) -> bool{\n    try_is_word_character(c).expect(\"unicode-perl feature must be enabled\")\n}","Real(LocalPath(\"src/lib.rs\"))"],"parser::Parser":["/// A convenience parser for regular expressions.\n///\n/// This parser takes as input a regular expression pattern string (the\n/// \"concrete syntax\") and returns a high-level intermediate representation\n/// (the HIR) suitable for most types of analysis. In particular, this parser\n/// hides the intermediate state of producing an AST (the \"abstract syntax\").\n/// The AST is itself far more complex than the HIR, so this parser serves as a\n/// convenience for never having to deal with it at all.\n///\n/// If callers have more fine grained use cases that need an AST, then please\n/// see the [`ast::parse`] module.\n///\n/// A `Parser` can be configured in more detail via a [`ParserBuilder`].\npub struct Parser {\n    ast: ast::parse::Parser,\n    hir: hir::translate::Translator,\n}","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::new":["/// Create a new parser with a default configuration.\n///\n/// The parser can be run with `parse` method. The parse method returns\n/// a high level intermediate representation of the given regular\n/// expression.\n///\n/// To set configuration options on the parser, use [`ParserBuilder`].\npub fn new() -> Parser{\n        ParserBuilder::new().build()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::Parser::parse":["/// Parse the regular expression into a high level intermediate\n/// representation.\npub fn parse(&mut self, pattern: &str) -> Result<hir::Hir, Error>{\n        let ast = self.ast.parse(pattern)?;\n        let hir = self.hir.translate(pattern, &ast)?;\n        Ok(hir)\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder":["/// A builder for a regular expression parser.\n///\n/// This builder permits modifying configuration options for the parser.\n///\n/// This type combines the builder options for both the [AST\n/// `ParserBuilder`](ast::parse::ParserBuilder) and the [HIR\n/// `TranslatorBuilder`](hir::translate::TranslatorBuilder).\npub struct ParserBuilder {\n    ast: ast::parse::ParserBuilder,\n    hir: hir::translate::TranslatorBuilder,\n}","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::build":["/// Build a parser from this configuration with the given pattern.\npub fn build(&self) -> Parser{\n        Parser { ast: self.ast.build(), hir: self.hir.build() }\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::case_insensitive":["/// Enable or disable the case insensitive flag by default.\n///\n/// By default this is disabled. It may alternatively be selectively\n/// enabled in the regular expression itself via the `i` flag.\npub fn case_insensitive(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.case_insensitive(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::crlf":["/// Enable or disable the CRLF mode flag by default.\n///\n/// By default this is disabled. It may alternatively be selectively\n/// enabled in the regular expression itself via the `R` flag.\n///\n/// When CRLF mode is enabled, the following happens:\n///\n/// * Unless `dot_matches_new_line` is enabled, `.` will match any character\n/// except for `\\r` and `\\n`.\n/// * When `multi_line` mode is enabled, `^` and `$` will treat `\\r\\n`,\n/// `\\r` and `\\n` as line terminators. And in particular, neither will\n/// match between a `\\r` and a `\\n`.\npub fn crlf(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.crlf(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::dot_matches_new_line":["/// Enable or disable the \"dot matches any character\" flag by default.\n///\n/// By default this is disabled. It may alternatively be selectively\n/// enabled in the regular expression itself via the `s` flag.\npub fn dot_matches_new_line(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.dot_matches_new_line(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::ignore_whitespace":["/// Enable verbose mode in the regular expression.\n///\n/// When enabled, verbose mode permits insignificant whitespace in many\n/// places in the regular expression, as well as comments. Comments are\n/// started using `#` and continue until the end of the line.\n///\n/// By default, this is disabled. It may be selectively enabled in the\n/// regular expression by using the `x` flag regardless of this setting.\npub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.ast.ignore_whitespace(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::multi_line":["/// Enable or disable the multi-line matching flag by default.\n///\n/// By default this is disabled. It may alternatively be selectively\n/// enabled in the regular expression itself via the `m` flag.\npub fn multi_line(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.multi_line(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::nest_limit":["/// Set the nesting limit for this parser.\n///\n/// The nesting limit controls how deep the abstract syntax tree is allowed\n/// to be. If the AST exceeds the given limit (e.g., with too many nested\n/// groups), then an error is returned by the parser.\n///\n/// The purpose of this limit is to act as a heuristic to prevent stack\n/// overflow for consumers that do structural induction on an `Ast` using\n/// explicit recursion. While this crate never does this (instead using\n/// constant stack space and moving the call stack to the heap), other\n/// crates may.\n///\n/// This limit is not checked until the entire Ast is parsed. Therefore,\n/// if callers want to put a limit on the amount of heap space used, then\n/// they should impose a limit on the length, in bytes, of the concrete\n/// pattern string. In particular, this is viable since this parser\n/// implementation will limit itself to heap space proportional to the\n/// length of the pattern string.\n///\n/// Note that a nest limit of `0` will return a nest limit error for most\n/// patterns but not all. For example, a nest limit of `0` permits `a` but\n/// not `ab`, since `ab` requires a concatenation, which results in a nest\n/// depth of `1`. In general, a nest limit is not something that manifests\n/// in an obvious way in the concrete syntax, therefore, it should not be\n/// used in a granular way.\npub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder{\n        self.ast.nest_limit(limit);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::new":["/// Create a new parser builder with a default configuration.\npub fn new() -> ParserBuilder{\n        ParserBuilder::default()\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::octal":["/// Whether to support octal syntax or not.\n///\n/// Octal syntax is a little-known way of uttering Unicode codepoints in\n/// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n/// `\\141` are all equivalent regular expressions, where the last example\n/// shows octal syntax.\n///\n/// While supporting octal syntax isn't in and of itself a problem, it does\n/// make good error messages harder. That is, in PCRE based regex engines,\n/// syntax like `\\0` invokes a backreference, which is explicitly\n/// unsupported in Rust's regex engine. However, many users expect it to\n/// be supported. Therefore, when octal support is disabled, the error\n/// message will explicitly mention that backreferences aren't supported.\n///\n/// Octal syntax is disabled by default.\npub fn octal(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.ast.octal(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::swap_greed":["/// Enable or disable the \"swap greed\" flag by default.\n///\n/// By default this is disabled. It may alternatively be selectively\n/// enabled in the regular expression itself via the `U` flag.\npub fn swap_greed(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.swap_greed(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::unicode":["/// Enable or disable the Unicode flag (`u`) by default.\n///\n/// By default this is **enabled**. It may alternatively be selectively\n/// disabled in the regular expression itself via the `u` flag.\n///\n/// Note that unless `utf8` is disabled (it's enabled by default), a\n/// regular expression will fail to parse if Unicode mode is disabled and a\n/// sub-expression could possibly match invalid UTF-8.\npub fn unicode(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.unicode(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::ParserBuilder::utf8":["/// When disabled, translation will permit the construction of a regular\n/// expression that may match invalid UTF-8.\n///\n/// When enabled (the default), the translator is guaranteed to produce an\n/// expression that, for non-empty matches, will only ever produce spans\n/// that are entirely valid UTF-8 (otherwise, the translator will return an\n/// error).\n///\n/// Perhaps surprisingly, when UTF-8 is enabled, an empty regex or even\n/// a negated ASCII word boundary (uttered as `(?-u:\\B)` in the concrete\n/// syntax) will be allowed even though they can produce matches that split\n/// a UTF-8 encoded codepoint. This only applies to zero-width or \"empty\"\n/// matches, and it is expected that the regex engine itself must handle\n/// these cases if necessary (perhaps by suppressing any zero-width matches\n/// that split a codepoint).\npub fn utf8(&mut self, yes: bool) -> &mut ParserBuilder{\n        self.hir.utf8(yes);\n        self\n    }","Real(LocalPath(\"src/parser.rs\"))"],"parser::parse":["/// A convenience routine for parsing a regex using default options.\n///\n/// This is equivalent to `Parser::new().parse(pattern)`.\n///\n/// If you need to set non-default options, then use a [`ParserBuilder`].\n///\n/// This routine returns an [`Hir`](hir::Hir) value. Namely, it automatically\n/// parses the pattern as an [`Ast`](ast::Ast) and then invokes the translator\n/// to convert the `Ast` into an `Hir`. If you need access to the `Ast`, then\n/// you should use a [`ast::parse::Parser`].\npub fn parse(pattern: &str) -> Result<hir::Hir, Error>{\n    Parser::new().parse(pattern)\n}","Real(LocalPath(\"src/parser.rs\"))"],"try_is_word_character":["/// Returns true if and only if the given character is a Unicode word\n/// character.\n///\n/// A Unicode word character is defined by\n/// [UTS#18 Annex C](https://unicode.org/reports/tr18/#Compatibility_Properties).\n/// In particular, a character\n/// is considered a word character if it is in either of the `Alphabetic` or\n/// `Join_Control` properties, or is in one of the `Decimal_Number`, `Mark`\n/// or `Connector_Punctuation` general categories.\n///\n/// # Errors\n///\n/// If the `unicode-perl` feature is not enabled, then this function always\n/// returns an error.\npub fn try_is_word_character(\n    c: char,\n) -> core::result::Result<bool, UnicodeWordError>{\n    unicode::is_word_character(c)\n}","Real(LocalPath(\"src/lib.rs\"))"],"unicode::CanonicalClassQuery":["/// Like ClassQuery, but its parameters have been canonicalized. This also\n/// differentiates binary properties from flattened general categories and\n/// scripts.\nenum CanonicalClassQuery {\n    /// The canonical binary property name.\n    Binary(&'static str),\n    /// The canonical general category name.\n    GeneralCategory(&'static str),\n    /// The canonical script name.\n    Script(&'static str),\n    /// An arbitrary association between property and value, both of which\n    /// have been canonicalized.\n    ///\n    /// Note that by construction, the property name of ByValue will never\n    /// be General_Category or Script. Those two cases are subsumed by the\n    /// eponymous variants.\n    ByValue {\n        /// The canonical property name.\n        property_name: &'static str,\n        /// The canonical property value.\n        property_value: &'static str,\n    },\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::CaseFoldError":["/// An error that occurs when Unicode-aware simple case folding fails.\n///\n/// This error can occur when the case mapping tables necessary for Unicode\n/// aware case folding are unavailable. This only occurs when the\n/// `unicode-case` feature is disabled. (The feature is enabled by default.)\npub struct CaseFoldError(());","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ClassQuery":["/// A query for finding a character class defined by Unicode. This supports\n/// either use of a property name directly, or lookup by property value. The\n/// former generally refers to Binary properties (see UTS#44, Table 8), but\n/// as a special exception (see UTS#18, Section 1.2) both general categories\n/// (an enumeration) and scripts (a catalog) are supported as if each of their\n/// possible values were a binary property.\n///\n/// In all circumstances, property names and values are normalized and\n/// canonicalized. That is, `GC == gc == GeneralCategory == general_category`.\n///\n/// The lifetime `'a` refers to the shorter of the lifetimes of property name\n/// and property value.\npub enum ClassQuery<'a> {\n    /// Return a class corresponding to a Unicode binary property, named by\n    /// a single letter.\n    OneLetter(char),\n    /// Return a class corresponding to a Unicode binary property.\n    ///\n    /// Note that, by special exception (see UTS#18, Section 1.2), both\n    /// general category values and script values are permitted here as if\n    /// they were a binary property.\n    Binary(&'a str),\n    /// Return a class corresponding to all codepoints whose property\n    /// (identified by `property_name`) corresponds to the given value\n    /// (identified by `property_value`).\n    ByValue {\n        /// A property name.\n        property_name: &'a str,\n        /// A property value.\n        property_value: &'a str,\n    },\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ClassQuery::<'a>::canonical_binary":["fn canonical_binary(\n        &self,\n        name: &str,\n    ) -> Result<CanonicalClassQuery, Error>{\n        let norm = symbolic_name_normalize(name);\n\n        // This is a special case where 'cf' refers to the 'Format' general\n        // category, but where the 'cf' abbreviation is also an abbreviation\n        // for the 'Case_Folding' property. But we want to treat it as\n        // a general category. (Currently, we don't even support the\n        // 'Case_Folding' property. But if we do in the future, users will be\n        // required to spell it out.)\n        //\n        // Also 'sc' refers to the 'Currency_Symbol' general category, but is\n        // also the abbreviation for the 'Script' property. So we avoid calling\n        // 'canonical_prop' for it too, which would erroneously normalize it\n        // to 'Script'.\n        //\n        // Another case: 'lc' is an abbreviation for the 'Cased_Letter'\n        // general category, but is also an abbreviation for the 'Lowercase_Mapping'\n        // property. We don't currently support the latter, so as with 'cf'\n        // above, we treat 'lc' as 'Cased_Letter'.\n        if norm != \"cf\" && norm != \"sc\" && norm != \"lc\" {\n            if let Some(canon) = canonical_prop(&norm)? {\n                return Ok(CanonicalClassQuery::Binary(canon));\n            }\n        }\n        if let Some(canon) = canonical_gencat(&norm)? {\n            return Ok(CanonicalClassQuery::GeneralCategory(canon));\n        }\n        if let Some(canon) = canonical_script(&norm)? {\n            return Ok(CanonicalClassQuery::Script(canon));\n        }\n        Err(Error::PropertyNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ClassQuery::<'a>::canonicalize":["fn canonicalize(&self) -> Result<CanonicalClassQuery, Error>{\n        match *self {\n            ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),\n            ClassQuery::Binary(name) => self.canonical_binary(name),\n            ClassQuery::ByValue { property_name, property_value } => {\n                let property_name = symbolic_name_normalize(property_name);\n                let property_value = symbolic_name_normalize(property_value);\n\n                let canon_name = match canonical_prop(&property_name)? {\n                    None => return Err(Error::PropertyNotFound),\n                    Some(canon_name) => canon_name,\n                };\n                Ok(match canon_name {\n                    \"General_Category\" => {\n                        let canon = match canonical_gencat(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::GeneralCategory(canon)\n                    }\n                    \"Script\" => {\n                        let canon = match canonical_script(&property_value)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(canon) => canon,\n                        };\n                        CanonicalClassQuery::Script(canon)\n                    }\n                    _ => {\n                        let vals = match property_values(canon_name)? {\n                            None => return Err(Error::PropertyValueNotFound),\n                            Some(vals) => vals,\n                        };\n                        let canon_val =\n                            match canonical_value(vals, &property_value) {\n                                None => {\n                                    return Err(Error::PropertyValueNotFound)\n                                }\n                                Some(canon_val) => canon_val,\n                            };\n                        CanonicalClassQuery::ByValue {\n                            property_name: canon_name,\n                            property_value: canon_val,\n                        }\n                    }\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::Error":["/// An error that occurs when dealing with Unicode.\n///\n/// We don't impl the Error trait here because these always get converted\n/// into other public errors. (This error type isn't exported.)\npub enum Error {\n    PropertyNotFound,\n    PropertyValueNotFound,\n    // Not used when unicode-perl is enabled.\n    #[allow(dead_code)]\n    PerlClassNotFound,\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::SimpleCaseFolder":["/// A state oriented traverser of the simple case folding table.\n///\n/// A case folder can be constructed via `SimpleCaseFolder::new()`, which will\n/// return an error if the underlying case folding table is unavailable.\n///\n/// After construction, it is expected that callers will use\n/// `SimpleCaseFolder::mapping` by calling it with codepoints in strictly\n/// increasing order. For example, calling it on `b` and then on `a` is illegal\n/// and will result in a panic.\n///\n/// The main idea of this type is that it tries hard to make mapping lookups\n/// fast by exploiting the structure of the underlying table, and the ordering\n/// assumption enables this.\npub struct SimpleCaseFolder {\n    /// The simple case fold table. It's a sorted association list, where the\n    /// keys are Unicode scalar values and the values are the corresponding\n    /// equivalence class (not including the key) of the \"simple\" case folded\n    /// Unicode scalar values.\n    table: &'static [(char, &'static [char])],\n    /// The last codepoint that was used for a lookup.\n    last: Option<char>,\n    /// The index to the entry in `table` corresponding to the smallest key `k`\n    /// such that `k > k0`, where `k0` is the most recent key lookup. Note that\n    /// in particular, `k0` may not be in the table!\n    next: usize,\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::SimpleCaseFolder::get":["/// Returns the index at which `c` occurs in the simple case fold table. If\n/// `c` does not occur, then this returns an `i` such that `table[i-1].0 <\n/// c` and `table[i].0 > c`.\nfn get(&self, c: char) -> Result<usize, usize>{\n        self.table.binary_search_by_key(&c, |&(c1, _)| c1)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::SimpleCaseFolder::mapping":["/// Return the equivalence class of case folded codepoints for the given\n/// codepoint. The equivalence class returned never includes the codepoint\n/// given. If the given codepoint has no case folded codepoints (i.e.,\n/// no entry in the underlying case folding table), then this returns an\n/// empty slice.\n///\n/// # Panics\n///\n/// This panics when called with a `c` that is less than or equal to the\n/// previous call. In other words, callers need to use this method with\n/// strictly increasing values of `c`.\npub fn mapping(&mut self, c: char) -> &'static [char]{\n        if let Some(last) = self.last {\n            assert!(\n                last < c,\n                \"got codepoint U+{:X} which occurs before \\\n                 last codepoint U+{:X}\",\n                u32::from(c),\n                u32::from(last),\n            );\n        }\n        self.last = Some(c);\n        if self.next >= self.table.len() {\n            return &[];\n        }\n        let (k, v) = self.table[self.next];\n        if k == c {\n            self.next += 1;\n            return v;\n        }\n        match self.get(c) {\n            Err(i) => {\n                self.next = i;\n                &[]\n            }\n            Ok(i) => {\n                // Since we require lookups to proceed\n                // in order, anything we find should be\n                // after whatever we thought might be\n                // next. Otherwise, the caller is either\n                // going out of order or we would have\n                // found our next key at 'self.next'.\n                assert!(i > self.next);\n                self.next = i + 1;\n                self.table[i].1\n            }\n        }\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::SimpleCaseFolder::new":["/// Create a new simple case folder, returning an error if the underlying\n/// case folding table is unavailable.\npub fn new() -> Result<SimpleCaseFolder, CaseFoldError>{\n        #[cfg(not(feature = \"unicode-case\"))]\n        {\n            Err(CaseFoldError(()))\n        }\n        #[cfg(feature = \"unicode-case\")]\n        {\n            Ok(SimpleCaseFolder {\n                table: crate::unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE,\n                last: None,\n                next: 0,\n            })\n        }\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::SimpleCaseFolder::overlaps":["/// Returns true if and only if the given range overlaps with any region\n/// of the underlying case folding table. That is, when true, there exists\n/// at least one codepoint in the inclusive range `[start, end]` that has\n/// a non-trivial equivalence class of case folded codepoints. Conversely,\n/// when this returns false, all codepoints in the range `[start, end]`\n/// correspond to the trivial equivalence class of case folded codepoints,\n/// i.e., itself.\n///\n/// This is useful to call before iterating over the codepoints in the\n/// range and looking up the mapping for each. If you know none of the\n/// mappings will return anything, then you might be able to skip doing it\n/// altogether.\n///\n/// # Panics\n///\n/// This panics when `end < start`.\npub fn overlaps(&self, start: char, end: char) -> bool{\n        use core::cmp::Ordering;\n\n        assert!(start <= end);\n        self.table\n            .binary_search_by(|&(c, _)| {\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if c > end {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok()\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::UnicodeWordError":["/// An error that occurs when the Unicode-aware `\\w` class is unavailable.\n///\n/// This error can occur when the data tables necessary for the Unicode aware\n/// Perl character class `\\w` are unavailable. This only occurs when the\n/// `unicode-perl` feature is disabled. (The feature is enabled by default.)\npub struct UnicodeWordError(());","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ages":["/// Returns an iterator over Unicode Age sets. Each item corresponds to a set\n/// of codepoints that were added in a particular revision of Unicode. The\n/// iterator yields items in chronological order.\n///\n/// If the given age value isn't valid or if the data isn't available, then an\n/// error is returned instead.\nfn ages(canonical_age: &str) -> Result<impl Iterator<Item = Range>, Error>{\n    #[cfg(not(feature = \"unicode-age\"))]\n    fn imp(_: &str) -> Result<impl Iterator<Item = Range>, Error> {\n        use core::option::IntoIter;\n        Err::<IntoIter<Range>, _>(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-age\")]\n    fn imp(canonical_age: &str) -> Result<impl Iterator<Item = Range>, Error> {\n        use crate::unicode_tables::age;\n\n        const AGES: &[(&str, Range)] = &[\n            (\"V1_1\", age::V1_1),\n            (\"V2_0\", age::V2_0),\n            (\"V2_1\", age::V2_1),\n            (\"V3_0\", age::V3_0),\n            (\"V3_1\", age::V3_1),\n            (\"V3_2\", age::V3_2),\n            (\"V4_0\", age::V4_0),\n            (\"V4_1\", age::V4_1),\n            (\"V5_0\", age::V5_0),\n            (\"V5_1\", age::V5_1),\n            (\"V5_2\", age::V5_2),\n            (\"V6_0\", age::V6_0),\n            (\"V6_1\", age::V6_1),\n            (\"V6_2\", age::V6_2),\n            (\"V6_3\", age::V6_3),\n            (\"V7_0\", age::V7_0),\n            (\"V8_0\", age::V8_0),\n            (\"V9_0\", age::V9_0),\n            (\"V10_0\", age::V10_0),\n            (\"V11_0\", age::V11_0),\n            (\"V12_0\", age::V12_0),\n            (\"V12_1\", age::V12_1),\n            (\"V13_0\", age::V13_0),\n            (\"V14_0\", age::V14_0),\n            (\"V15_0\", age::V15_0),\n        ];\n        assert_eq!(AGES.len(), age::BY_NAME.len(), \"ages are out of sync\");\n\n        let pos = AGES.iter().position(|&(age, _)| canonical_age == age);\n        match pos {\n            None => Err(Error::PropertyValueNotFound),\n            Some(i) => Ok(AGES[..=i].iter().map(|&(_, classes)| classes)),\n        }\n    }\n\n    imp(canonical_age)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::ages::imp":["#[cfg(feature = \"unicode-age\")]\nfn imp(canonical_age: &str) -> Result<impl Iterator<Item = Range>, Error>{\n        use crate::unicode_tables::age;\n\n        const AGES: &[(&str, Range)] = &[\n            (\"V1_1\", age::V1_1),\n            (\"V2_0\", age::V2_0),\n            (\"V2_1\", age::V2_1),\n            (\"V3_0\", age::V3_0),\n            (\"V3_1\", age::V3_1),\n            (\"V3_2\", age::V3_2),\n            (\"V4_0\", age::V4_0),\n            (\"V4_1\", age::V4_1),\n            (\"V5_0\", age::V5_0),\n            (\"V5_1\", age::V5_1),\n            (\"V5_2\", age::V5_2),\n            (\"V6_0\", age::V6_0),\n            (\"V6_1\", age::V6_1),\n            (\"V6_2\", age::V6_2),\n            (\"V6_3\", age::V6_3),\n            (\"V7_0\", age::V7_0),\n            (\"V8_0\", age::V8_0),\n            (\"V9_0\", age::V9_0),\n            (\"V10_0\", age::V10_0),\n            (\"V11_0\", age::V11_0),\n            (\"V12_0\", age::V12_0),\n            (\"V12_1\", age::V12_1),\n            (\"V13_0\", age::V13_0),\n            (\"V14_0\", age::V14_0),\n            (\"V15_0\", age::V15_0),\n        ];\n        assert_eq!(AGES.len(), age::BY_NAME.len(), \"ages are out of sync\");\n\n        let pos = AGES.iter().position(|&(age, _)| canonical_age == age);\n        match pos {\n            None => Err(Error::PropertyValueNotFound),\n            Some(i) => Ok(AGES[..=i].iter().map(|&(_, classes)| classes)),\n        }\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::bool_property":["/// Returns the Unicode HIR class corresponding to the given Unicode boolean\n/// property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given boolean property could not be found, or if the boolean\n/// property data is not available, then an error is returned.\nfn bool_property(\n    canonical_name: &'static str,\n) -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(feature = \"unicode-bool\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-bool\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::property_bool::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyNotFound)\n    }\n\n    match canonical_name {\n        \"Decimal_Number\" => perl_digit(),\n        \"White_Space\" => perl_space(),\n        name => imp(name),\n    }\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::bool_property::imp":["#[cfg(feature = \"unicode-bool\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::property_bool::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_gencat":["fn canonical_gencat(\n    normalized_value: &str,\n) -> Result<Option<&'static str>, Error>{\n    Ok(match normalized_value {\n        \"any\" => Some(\"Any\"),\n        \"assigned\" => Some(\"Assigned\"),\n        \"ascii\" => Some(\"ASCII\"),\n        _ => {\n            let gencats = property_values(\"General_Category\")?.unwrap();\n            canonical_value(gencats, normalized_value)\n        }\n    })\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_prop":["/// Find the canonical property name for the given normalized property name.\n///\n/// If no such property exists, then `None` is returned.\n///\n/// The normalized property name must have been normalized according to\n/// UAX44 LM3, which can be done using `symbolic_name_normalize`.\n///\n/// If the property names data is not available, then an error is returned.\nfn canonical_prop(\n    normalized_name: &str,\n) -> Result<Option<&'static str>, Error>{\n    #[cfg(not(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    )))]\n    fn imp(_: &str) -> Result<Option<&'static str>, Error> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\n    fn imp(name: &str) -> Result<Option<&'static str>, Error> {\n        use crate::unicode_tables::property_names::PROPERTY_NAMES;\n\n        Ok(PROPERTY_NAMES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_NAMES[i].1))\n    }\n\n    imp(normalized_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_prop::imp":["#[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\nfn imp(name: &str) -> Result<Option<&'static str>, Error>{\n        use crate::unicode_tables::property_names::PROPERTY_NAMES;\n\n        Ok(PROPERTY_NAMES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_NAMES[i].1))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_script":["fn canonical_script(\n    normalized_value: &str,\n) -> Result<Option<&'static str>, Error>{\n    let scripts = property_values(\"Script\")?.unwrap();\n    Ok(canonical_value(scripts, normalized_value))\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::canonical_value":["/// Find the canonical property value for the given normalized property\n/// value.\n///\n/// The given property values should correspond to the values for the property\n/// under question, which can be found using `property_values`.\n///\n/// If no such property value exists, then `None` is returned.\n///\n/// The normalized property value must have been normalized according to\n/// UAX44 LM3, which can be done using `symbolic_name_normalize`.\nfn canonical_value(\n    vals: PropertyValues,\n    normalized_value: &str,\n) -> Option<&'static str>{\n    vals.binary_search_by_key(&normalized_value, |&(n, _)| n)\n        .ok()\n        .map(|i| vals[i].1)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::class":["/// Looks up a Unicode class given a query. If one doesn't exist, then\n/// `None` is returned.\npub fn class(query: ClassQuery<'_>) -> Result<hir::ClassUnicode, Error>{\n    use self::CanonicalClassQuery::*;\n\n    match query.canonicalize()? {\n        Binary(name) => bool_property(name),\n        GeneralCategory(name) => gencat(name),\n        Script(name) => script(name),\n        ByValue { property_name: \"Age\", property_value } => {\n            let mut class = hir::ClassUnicode::empty();\n            for set in ages(property_value)? {\n                class.union(&hir_class(set));\n            }\n            Ok(class)\n        }\n        ByValue { property_name: \"Script_Extensions\", property_value } => {\n            script_extension(property_value)\n        }\n        ByValue {\n            property_name: \"Grapheme_Cluster_Break\",\n            property_value,\n        } => gcb(property_value),\n        ByValue { property_name: \"Sentence_Break\", property_value } => {\n            sb(property_value)\n        }\n        ByValue { property_name: \"Word_Break\", property_value } => {\n            wb(property_value)\n        }\n        _ => {\n            // What else should we support?\n            Err(Error::PropertyNotFound)\n        }\n    }\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::gcb":["/// Returns the Unicode HIR class corresponding to the given grapheme cluster\n/// break property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given property could not be found, or if the corresponding data is\n/// not available, then an error is returned.\nfn gcb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::grapheme_cluster_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::gcb::imp":["#[cfg(feature = \"unicode-segment\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::grapheme_cluster_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::gencat":["/// Returns the Unicode HIR class corresponding to the given general category.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given general category could not be found, or if the general\n/// category data is not available, then an error is returned.\nfn gencat(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(feature = \"unicode-gencat\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-gencat\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::general_category::BY_NAME;\n        match name {\n            \"ASCII\" => Ok(hir_class(&[('\\0', '\\x7F')])),\n            \"Any\" => Ok(hir_class(&[('\\0', '\\u{10FFFF}')])),\n            \"Assigned\" => {\n                let mut cls = gencat(\"Unassigned\")?;\n                cls.negate();\n                Ok(cls)\n            }\n            name => property_set(BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound),\n        }\n    }\n\n    match canonical_name {\n        \"Decimal_Number\" => perl_digit(),\n        name => imp(name),\n    }\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::gencat::imp":["#[cfg(feature = \"unicode-gencat\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::general_category::BY_NAME;\n        match name {\n            \"ASCII\" => Ok(hir_class(&[('\\0', '\\x7F')])),\n            \"Any\" => Ok(hir_class(&[('\\0', '\\u{10FFFF}')])),\n            \"Assigned\" => {\n                let mut cls = gencat(\"Unassigned\")?;\n                cls.negate();\n                Ok(cls)\n            }\n            name => property_set(BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound),\n        }\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::hir_class":["/// Build a Unicode HIR class from a sequence of Unicode scalar value ranges.\npub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode{\n    let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges\n        .iter()\n        .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))\n        .collect();\n    hir::ClassUnicode::new(hir_ranges)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::is_word_character":["/// Returns true only if the given codepoint is in the `\\w` character class.\n///\n/// If the `unicode-perl` feature is not enabled, then this returns an error.\npub fn is_word_character(c: char) -> Result<bool, UnicodeWordError>{\n    #[cfg(not(feature = \"unicode-perl\"))]\n    fn imp(_: char) -> Result<bool, UnicodeWordError> {\n        Err(UnicodeWordError(()))\n    }\n\n    #[cfg(feature = \"unicode-perl\")]\n    fn imp(c: char) -> Result<bool, UnicodeWordError> {\n        use crate::{is_word_byte, unicode_tables::perl_word::PERL_WORD};\n\n        if u8::try_from(c).map_or(false, is_word_byte) {\n            return Ok(true);\n        }\n        Ok(PERL_WORD\n            .binary_search_by(|&(start, end)| {\n                use core::cmp::Ordering;\n\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if start > c {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok())\n    }\n\n    imp(c)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::is_word_character::imp":["#[cfg(feature = \"unicode-perl\")]\nfn imp(c: char) -> Result<bool, UnicodeWordError>{\n        use crate::{is_word_byte, unicode_tables::perl_word::PERL_WORD};\n\n        if u8::try_from(c).map_or(false, is_word_byte) {\n            return Ok(true);\n        }\n        Ok(PERL_WORD\n            .binary_search_by(|&(start, end)| {\n                use core::cmp::Ordering;\n\n                if start <= c && c <= end {\n                    Ordering::Equal\n                } else if start > c {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            })\n            .is_ok())\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_digit":["/// Returns a Unicode aware class for \\d.\n///\n/// This returns an error if the data is not available for \\d.\npub fn perl_digit() -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(any(feature = \"unicode-perl\", feature = \"unicode-gencat\")))]\n    fn imp() -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PerlClassNotFound)\n    }\n\n    #[cfg(all(feature = \"unicode-perl\", not(feature = \"unicode-gencat\")))]\n    fn imp() -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::perl_decimal::DECIMAL_NUMBER;\n        Ok(hir_class(DECIMAL_NUMBER))\n    }\n\n    #[cfg(feature = \"unicode-gencat\")]\n    fn imp() -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::general_category::DECIMAL_NUMBER;\n        Ok(hir_class(DECIMAL_NUMBER))\n    }\n\n    imp()\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_digit::imp":["#[cfg(feature = \"unicode-gencat\")]\nfn imp() -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::general_category::DECIMAL_NUMBER;\n        Ok(hir_class(DECIMAL_NUMBER))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_space":["/// Returns a Unicode aware class for \\s.\n///\n/// This returns an error if the data is not available for \\s.\npub fn perl_space() -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(any(feature = \"unicode-perl\", feature = \"unicode-bool\")))]\n    fn imp() -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PerlClassNotFound)\n    }\n\n    #[cfg(all(feature = \"unicode-perl\", not(feature = \"unicode-bool\")))]\n    fn imp() -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::perl_space::WHITE_SPACE;\n        Ok(hir_class(WHITE_SPACE))\n    }\n\n    #[cfg(feature = \"unicode-bool\")]\n    fn imp() -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::property_bool::WHITE_SPACE;\n        Ok(hir_class(WHITE_SPACE))\n    }\n\n    imp()\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_space::imp":["#[cfg(feature = \"unicode-bool\")]\nfn imp() -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::property_bool::WHITE_SPACE;\n        Ok(hir_class(WHITE_SPACE))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_word":["/// Returns a Unicode aware class for \\w.\n///\n/// This returns an error if the data is not available for \\w.\npub fn perl_word() -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(feature = \"unicode-perl\"))]\n    fn imp() -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PerlClassNotFound)\n    }\n\n    #[cfg(feature = \"unicode-perl\")]\n    fn imp() -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::perl_word::PERL_WORD;\n        Ok(hir_class(PERL_WORD))\n    }\n\n    imp()\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::perl_word::imp":["#[cfg(feature = \"unicode-perl\")]\nfn imp() -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::perl_word::PERL_WORD;\n        Ok(hir_class(PERL_WORD))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::property_set":["#[allow(dead_code)]\nfn property_set(\n    name_map: &'static [(&'static str, Range)],\n    canonical: &'static str,\n) -> Option<Range>{\n    name_map\n        .binary_search_by_key(&canonical, |x| x.0)\n        .ok()\n        .map(|i| name_map[i].1)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::property_values":["/// Return the table of property values for the given property name.\n///\n/// If the property values data is not available, then an error is returned.\nfn property_values(\n    canonical_property_name: &'static str,\n) -> Result<Option<PropertyValues>, Error>{\n    #[cfg(not(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    )))]\n    fn imp(_: &'static str) -> Result<Option<PropertyValues>, Error> {\n        Err(Error::PropertyValueNotFound)\n    }\n\n    #[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\n    fn imp(name: &'static str) -> Result<Option<PropertyValues>, Error> {\n        use crate::unicode_tables::property_values::PROPERTY_VALUES;\n\n        Ok(PROPERTY_VALUES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_VALUES[i].1))\n    }\n\n    imp(canonical_property_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::property_values::imp":["#[cfg(any(\n        feature = \"unicode-age\",\n        feature = \"unicode-bool\",\n        feature = \"unicode-gencat\",\n        feature = \"unicode-perl\",\n        feature = \"unicode-script\",\n        feature = \"unicode-segment\",\n    ))]\nfn imp(name: &'static str) -> Result<Option<PropertyValues>, Error>{\n        use crate::unicode_tables::property_values::PROPERTY_VALUES;\n\n        Ok(PROPERTY_VALUES\n            .binary_search_by_key(&name, |&(n, _)| n)\n            .ok()\n            .map(|i| PROPERTY_VALUES[i].1))\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::sb":["/// Returns the Unicode HIR class corresponding to the given sentence\n/// break property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given property could not be found, or if the corresponding data is\n/// not available, then an error is returned.\nfn sb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::sentence_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::sb::imp":["#[cfg(feature = \"unicode-segment\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::sentence_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::script":["/// Returns the Unicode HIR class corresponding to the given script.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given script could not be found, or if the script data is not\n/// available, then an error is returned.\nfn script(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(feature = \"unicode-script\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-script\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::script::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::script::imp":["#[cfg(feature = \"unicode-script\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::script::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::script_extension":["/// Returns the Unicode HIR class corresponding to the given script extension.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given script extension could not be found, or if the script data is\n/// not available, then an error is returned.\nfn script_extension(\n    canonical_name: &'static str,\n) -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(feature = \"unicode-script\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-script\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::script_extension::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::script_extension::imp":["#[cfg(feature = \"unicode-script\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::script_extension::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::symbolic_name_normalize":["/// Like symbolic_name_normalize_bytes, but operates on a string.\nfn symbolic_name_normalize(x: &str) -> String{\n    let mut tmp = x.as_bytes().to_vec();\n    let len = symbolic_name_normalize_bytes(&mut tmp).len();\n    tmp.truncate(len);\n    // This should always succeed because `symbolic_name_normalize_bytes`\n    // guarantees that `&tmp[..len]` is always valid UTF-8.\n    //\n    // N.B. We could avoid the additional UTF-8 check here, but it's unlikely\n    // to be worth skipping the additional safety check. A benchmark must\n    // justify it first.\n    String::from_utf8(tmp).unwrap()\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::symbolic_name_normalize_bytes":["/// Normalize the given symbolic name in place according to UAX44-LM3.\n///\n/// A \"symbolic name\" typically corresponds to property names and property\n/// value aliases. Note, though, that it should not be applied to property\n/// string values.\n///\n/// The slice returned is guaranteed to be valid UTF-8 for all possible values\n/// of `slice`.\n///\n/// See: https://unicode.org/reports/tr44/#UAX44-LM3\nfn symbolic_name_normalize_bytes(slice: &mut [u8]) -> &mut [u8]{\n    // I couldn't find a place in the standard that specified that property\n    // names/aliases had a particular structure (unlike character names), but\n    // we assume that it's ASCII only and drop anything that isn't ASCII.\n    let mut start = 0;\n    let mut starts_with_is = false;\n    if slice.len() >= 2 {\n        // Ignore any \"is\" prefix.\n        starts_with_is = slice[0..2] == b\"is\"[..]\n            || slice[0..2] == b\"IS\"[..]\n            || slice[0..2] == b\"iS\"[..]\n            || slice[0..2] == b\"Is\"[..];\n        if starts_with_is {\n            start = 2;\n        }\n    }\n    let mut next_write = 0;\n    for i in start..slice.len() {\n        // VALIDITY ARGUMENT: To guarantee that the resulting slice is valid\n        // UTF-8, we ensure that the slice contains only ASCII bytes. In\n        // particular, we drop every non-ASCII byte from the normalized string.\n        let b = slice[i];\n        if b == b' ' || b == b'_' || b == b'-' {\n            continue;\n        } else if b'A' <= b && b <= b'Z' {\n            slice[next_write] = b + (b'a' - b'A');\n            next_write += 1;\n        } else if b <= 0x7F {\n            slice[next_write] = b;\n            next_write += 1;\n        }\n    }\n    // Special case: ISO_Comment has a 'isc' abbreviation. Since we generally\n    // ignore 'is' prefixes, the 'isc' abbreviation gets caught in the cross\n    // fire and ends up creating an alias for 'c' to 'ISO_Comment', but it\n    // is actually an alias for the 'Other' general category.\n    if starts_with_is && next_write == 1 && slice[0] == b'c' {\n        slice[0] = b'i';\n        slice[1] = b's';\n        slice[2] = b'c';\n        next_write = 3;\n    }\n    &mut slice[..next_write]\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::wb":["/// Returns the Unicode HIR class corresponding to the given word break\n/// property.\n///\n/// Name canonicalization is assumed to be performed by the caller.\n///\n/// If the given property could not be found, or if the corresponding data is\n/// not available, then an error is returned.\nfn wb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>{\n    #[cfg(not(feature = \"unicode-segment\"))]\n    fn imp(_: &'static str) -> Result<hir::ClassUnicode, Error> {\n        Err(Error::PropertyNotFound)\n    }\n\n    #[cfg(feature = \"unicode-segment\")]\n    fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {\n        use crate::unicode_tables::word_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }\n\n    imp(canonical_name)\n}","Real(LocalPath(\"src/unicode.rs\"))"],"unicode::wb::imp":["#[cfg(feature = \"unicode-segment\")]\nfn imp(name: &'static str) -> Result<hir::ClassUnicode, Error>{\n        use crate::unicode_tables::word_break::BY_NAME;\n        property_set(BY_NAME, name)\n            .map(hir_class)\n            .ok_or(Error::PropertyValueNotFound)\n    }","Real(LocalPath(\"src/unicode.rs\"))"],"utf8::ScalarRange":["struct ScalarRange {\n    start: u32,\n    end: u32,\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::as_ascii":["/// as_ascii returns this range as a Utf8Range if and only if all scalar\n/// values in this range can be encoded as a single byte.\nfn as_ascii(&self) -> Option<Utf8Range>{\n        if self.is_ascii() {\n            let start = u8::try_from(self.start).unwrap();\n            let end = u8::try_from(self.end).unwrap();\n            Some(Utf8Range::new(start, end))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::encode":["/// encode writes the UTF-8 encoding of the start and end of this range\n/// to the corresponding destination slices, and returns the number of\n/// bytes written.\n///\n/// The slices should have room for at least `MAX_UTF8_BYTES`.\nfn encode(&self, start: &mut [u8], end: &mut [u8]) -> usize{\n        let cs = char::from_u32(self.start).unwrap();\n        let ce = char::from_u32(self.end).unwrap();\n        let ss = cs.encode_utf8(start);\n        let se = ce.encode_utf8(end);\n        assert_eq!(ss.len(), se.len());\n        ss.len()\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::is_ascii":["/// is_ascii returns true if the range is ASCII only (i.e., takes a single\n/// byte to encode any scalar value).\nfn is_ascii(&self) -> bool{\n        self.is_valid() && self.end <= 0x7f\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::is_valid":["/// is_valid returns true if and only if start <= end.\nfn is_valid(&self) -> bool{\n        self.start <= self.end\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::ScalarRange::split":["/// split splits this range if it overlaps with a surrogate codepoint.\n///\n/// Either or both ranges may be invalid.\nfn split(&self) -> Option<(ScalarRange, ScalarRange)>{\n        if self.start < 0xE000 && self.end > 0xD7FF {\n            Some((\n                ScalarRange { start: self.start, end: 0xD7FF },\n                ScalarRange { start: 0xE000, end: self.end },\n            ))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Range":["/// A single inclusive range of UTF-8 bytes.\npub struct Utf8Range {\n    /// Start of byte range (inclusive).\n    pub start: u8,\n    /// End of byte range (inclusive).\n    pub end: u8,\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Range::matches":["/// Returns true if and only if the given byte is in this range.\npub fn matches(&self, b: u8) -> bool{\n        self.start <= b && b <= self.end\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Range::new":["fn new(start: u8, end: u8) -> Self{\n        Utf8Range { start, end }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence":["/// Utf8Sequence represents a sequence of byte ranges.\n///\n/// To match a Utf8Sequence, a candidate byte sequence must match each\n/// successive range.\n///\n/// For example, if there are two ranges, `[C2-DF][80-BF]`, then the byte\n/// sequence `\\xDD\\x61` would not match because `0x61 < 0x80`.\npub enum Utf8Sequence {\n    /// One byte range.\n    One(Utf8Range),\n    /// Two successive byte ranges.\n    Two([Utf8Range; 2]),\n    /// Three successive byte ranges.\n    Three([Utf8Range; 3]),\n    /// Four successive byte ranges.\n    Four([Utf8Range; 4]),\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::as_slice":["/// Returns the underlying sequence of byte ranges as a slice.\npub fn as_slice(&self) -> &[Utf8Range]{\n        use self::Utf8Sequence::*;\n        match *self {\n            One(ref r) => slice::from_ref(r),\n            Two(ref r) => &r[..],\n            Three(ref r) => &r[..],\n            Four(ref r) => &r[..],\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::from_encoded_range":["/// Creates a new UTF-8 sequence from the encoded bytes of a scalar value\n/// range.\n///\n/// This assumes that `start` and `end` have the same length.\nfn from_encoded_range(start: &[u8], end: &[u8]) -> Self{\n        assert_eq!(start.len(), end.len());\n        match start.len() {\n            2 => Utf8Sequence::Two([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n            ]),\n            3 => Utf8Sequence::Three([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n            ]),\n            4 => Utf8Sequence::Four([\n                Utf8Range::new(start[0], end[0]),\n                Utf8Range::new(start[1], end[1]),\n                Utf8Range::new(start[2], end[2]),\n                Utf8Range::new(start[3], end[3]),\n            ]),\n            n => unreachable!(\"invalid encoded length: {}\", n),\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::len":["/// Returns the number of byte ranges in this sequence.\n///\n/// The length is guaranteed to be in the closed interval `[1, 4]`.\npub fn len(&self) -> usize{\n        self.as_slice().len()\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::matches":["/// Returns true if and only if a prefix of `bytes` matches this sequence\n/// of byte ranges.\npub fn matches(&self, bytes: &[u8]) -> bool{\n        if bytes.len() < self.len() {\n            return false;\n        }\n        for (&b, r) in bytes.iter().zip(self) {\n            if !r.matches(b) {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequence::reverse":["/// Reverses the ranges in this sequence.\n///\n/// For example, if this corresponds to the following sequence:\n///\n/// ```text\n/// [D0-D3][80-BF]\n/// ```\n///\n/// Then after reversal, it will be\n///\n/// ```text\n/// [80-BF][D0-D3]\n/// ```\n///\n/// This is useful when one is constructing a UTF-8 automaton to match\n/// character classes in reverse.\npub fn reverse(&mut self){\n        match *self {\n            Utf8Sequence::One(_) => {}\n            Utf8Sequence::Two(ref mut x) => x.reverse(),\n            Utf8Sequence::Three(ref mut x) => x.reverse(),\n            Utf8Sequence::Four(ref mut x) => x.reverse(),\n        }\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequences":["/// An iterator over ranges of matching UTF-8 byte sequences.\n///\n/// The iteration represents an alternation of comprehensive byte sequences\n/// that match precisely the set of UTF-8 encoded scalar values.\n///\n/// A byte sequence corresponds to one of the scalar values in the range given\n/// if and only if it completely matches exactly one of the sequences of byte\n/// ranges produced by this iterator.\n///\n/// Each sequence of byte ranges matches a unique set of bytes. That is, no two\n/// sequences will match the same bytes.\n///\n/// # Example\n///\n/// This shows how to match an arbitrary byte sequence against a range of\n/// scalar values.\n///\n/// ```rust\n/// use regex_syntax::utf8::{Utf8Sequences, Utf8Sequence};\n///\n/// fn matches(seqs: &[Utf8Sequence], bytes: &[u8]) -> bool {\n///     for range in seqs {\n///         if range.matches(bytes) {\n///             return true;\n///         }\n///     }\n///     false\n/// }\n///\n/// // Test the basic multilingual plane.\n/// let seqs: Vec<_> = Utf8Sequences::new('\\u{0}', '\\u{FFFF}').collect();\n///\n/// // UTF-8 encoding of 'a'.\n/// assert!(matches(&seqs, &[0x61]));\n/// // UTF-8 encoding of '☃' (`\\u{2603}`).\n/// assert!(matches(&seqs, &[0xE2, 0x98, 0x83]));\n/// // UTF-8 encoding of `\\u{10348}` (outside the BMP).\n/// assert!(!matches(&seqs, &[0xF0, 0x90, 0x8D, 0x88]));\n/// // Tries to match against a UTF-8 encoding of a surrogate codepoint,\n/// // which is invalid UTF-8, and therefore fails, despite the fact that\n/// // the corresponding codepoint (0xD800) falls in the range given.\n/// assert!(!matches(&seqs, &[0xED, 0xA0, 0x80]));\n/// // And fails against plain old invalid UTF-8.\n/// assert!(!matches(&seqs, &[0xFF, 0xFF]));\n/// ```\n///\n/// If this example seems circuitous, that's because it is! It's meant to be\n/// illustrative. In practice, you could just try to decode your byte sequence\n/// and compare it with the scalar value range directly. However, this is not\n/// always possible (for example, in a byte based automaton).\npub struct Utf8Sequences {\n    range_stack: Vec<ScalarRange>,\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequences::new":["/// Create a new iterator over UTF-8 byte ranges for the scalar value range\n/// given.\npub fn new(start: char, end: char) -> Self{\n        let mut it = Utf8Sequences { range_stack: vec![] };\n        it.push(u32::from(start), u32::from(end));\n        it\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequences::push":["fn push(&mut self, start: u32, end: u32){\n        self.range_stack.push(ScalarRange { start, end });\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::Utf8Sequences::reset":["/// reset resets the scalar value range.\n/// Any existing state is cleared, but resources may be reused.\n///\n/// N.B. Benchmarks say that this method is dubious.\n#[doc(hidden)]\npub fn reset(&mut self, start: char, end: char){\n        self.range_stack.clear();\n        self.push(u32::from(start), u32::from(end));\n    }","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::max_scalar_value":["fn max_scalar_value(nbytes: usize) -> u32{\n    match nbytes {\n        1 => 0x007F,\n        2 => 0x07FF,\n        3 => 0xFFFF,\n        4 => 0x0010_FFFF,\n        _ => unreachable!(\"invalid UTF-8 byte sequence size\"),\n    }\n}","Real(LocalPath(\"src/utf8.rs\"))"]},"struct_constructor":{"&'a ast::Ast":["child"],"&'a hir::ClassBytesRange":["next"],"&'a hir::ClassUnicodeRange":["next"],"&'a hir::Hir":["child"],"&'static [(&'static str, &'static str)]":["imp","property_values"],"&'static [(char, char)]":["property_set"],"&'static [char]":["mapping"],"&'static str":["canonical_gencat","canonical_prop","canonical_script","canonical_value","imp"],"&[I]":["intervals"],"&[hir::ClassBytesRange]":["ranges"],"&[hir::ClassUnicodeRange]":["ranges"],"&[hir::Hir]":["subs"],"&[hir::literal::Literal]":["literals"],"&[u8]":["as_bytes","as_ref","longest_common_prefix","longest_common_suffix"],"&[utf8::Utf8Range]":["as_slice"],"&ast::ErrorKind":["kind"],"&ast::Flags":["flags"],"&ast::Span":["auxiliary_span","span"],"&ast::parse::Parser":["parser"],"&hir::ErrorKind":["kind"],"&hir::HirKind":["kind"],"&hir::Properties":["properties"],"&hir::translate::Translator":["trans"],"&str":["pattern"],"(&'a mut std::vec::Vec<hir::literal::Literal>, &'a mut std::vec::Vec<hir::literal::Literal>)":["cross_preamble"],"(ast::ClassBracketed, ast::ClassSetUnion)":["parse_set_class_open"],"(hir::HirKind, hir::Properties)":["into_parts"],"(std::option::Option<Self>, std::option::Option<Self>)":["difference","symmetric_difference"],"(utf8::ScalarRange, utf8::ScalarRange)":["split"],"<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::IntoIter":["into_iter"],"<Self as ast::visitor::Visitor>::Output":["finish"],"<Self as hir::interval::Interval>::Bound":["lower","upper"],"<Self as hir::visitor::Visitor>::Output":["finish"],"<V as ast::visitor::Visitor>::Output":["visit"],"<V as hir::visitor::Visitor>::Output":["visit"],"<utf8::Utf8Sequences as std::iter::Iterator>::Item":["next"],"ast::Alternation":["clone"],"ast::Assertion":["clone"],"ast::AssertionKind":["clone"],"ast::Ast":["clone","into_ast","parse","pop_group_end"],"ast::CaptureName":["clone","parse_capture_name"],"ast::Class":["clone","parse_set_class"],"ast::ClassAscii":["clone","maybe_parse_ascii_class"],"ast::ClassAsciiKind":["clone","from_name"],"ast::ClassBracketed":["clone"],"ast::ClassPerl":["clone","parse_perl_class"],"ast::ClassPerlKind":["clone"],"ast::ClassSet":["clone","union"],"ast::ClassSetBinaryOp":["clone"],"ast::ClassSetBinaryOpKind":["clone"],"ast::ClassSetItem":["clone","into_class_set_item","into_item","parse_set_class_range"],"ast::ClassSetRange":["clone"],"ast::ClassSetUnion":["clone"],"ast::ClassUnicode":["clone","parse_unicode_class"],"ast::ClassUnicodeKind":["clone"],"ast::ClassUnicodeOpKind":["clone"],"ast::Comment":["clone"],"ast::Concat":["clone"],"ast::Error":["clone","error","unclosed_class_error"],"ast::ErrorKind":["clone"],"ast::Flag":["clone","parse_flag"],"ast::Flags":["clone","parse_flags"],"ast::FlagsItem":["clone"],"ast::FlagsItemKind":["clone"],"ast::Group":["clone"],"ast::GroupKind":["clone"],"ast::HexLiteralKind":["clone"],"ast::Literal":["clone","into_class_literal","parse_hex","parse_hex_brace","parse_hex_digits","parse_octal"],"ast::LiteralKind":["clone"],"ast::Position":["clone","new","pos"],"ast::Repetition":["clone"],"ast::RepetitionKind":["clone"],"ast::RepetitionOp":["clone"],"ast::RepetitionRange":["clone"],"ast::SetFlags":["clone"],"ast::Span":["clone","new","span","span_char","splat"],"ast::SpecialLiteralKind":["clone"],"ast::WithComments":["clone","parse_with_comments"],"ast::parse::ClassState":["clone"],"ast::parse::GroupState":["clone"],"ast::parse::NestLimiter":["new"],"ast::parse::Parser":["build","clone","new"],"ast::parse::ParserBuilder":["clone","default","new"],"ast::parse::ParserI":["clone","new"],"ast::parse::Primitive":["clone","parse_escape","parse_primitive","parse_set_class_item"],"ast::print::Printer":["build","new"],"ast::print::PrinterBuilder":["clone","default","new"],"ast::visitor::ClassFrame":["induct_class"],"ast::visitor::ClassInduct":["child","from_bracketed","from_set"],"ast::visitor::Frame":["induct"],"ast::visitor::HeapVisitor":["new"],"bool":["bump","bump_and_bump_space","bump_if","case_insensitive","class_over_limit_bytes","class_over_limit_unicode","contains","contains_anchor","contains_anchor_crlf","contains_anchor_haystack","contains_anchor_lf","contains_anchor_line","contains_word","contains_word_ascii","contains_word_unicode","crlf","dot_matches_new_line","eq","flag_state","has_subexprs","ignore_whitespace","imp","is_alternation_literal","is_ascii","is_canonical","is_capturing","is_contiguous","is_empty","is_eof","is_equal","is_escapeable_character","is_exact","is_finite","is_hex","is_inexact","is_intersection_empty","is_literal","is_lookaround_prefix","is_meta_character","is_negated","is_negation","is_one_line","is_poisonous","is_prefix","is_subset","is_suffix","is_utf8","is_valid","is_word_byte","is_word_character","matches","multi_line","overlaps","swap_greed","try_is_word_character","unicode"],"char":["as_char","char","char_at","end","lower","max_value","min_value","peek","peek_space","start","upper","utf8_decode"],"either::Either":["ast_literal_to_scalar","clone","parse_group","pop_class"],"error::Error":["clone","from"],"error::Formatter":["from"],"error::Spans":["from_formatter"],"hir::Capture":["clone"],"hir::Class":["class_bytes","class_chars","clone"],"hir::ClassBytes":["clone","empty","hir_ascii_byte_class","hir_ascii_class_bytes","hir_perl_byte_class","new","to_byte_class","unwrap_class_bytes"],"hir::ClassBytesIter":["iter"],"hir::ClassBytesRange":["clone","default","new"],"hir::ClassUnicode":["bool_property","class","clone","empty","gcb","gencat","hir_ascii_unicode_class","hir_class","hir_perl_unicode_class","hir_unicode_class","imp","new","perl_digit","perl_space","perl_word","sb","script","script_extension","to_unicode_class","unwrap_class_unicode","wb"],"hir::ClassUnicodeIter":["iter"],"hir::ClassUnicodeRange":["clone","default","new"],"hir::Dot":["clone","dot"],"hir::Error":["clone","error"],"hir::ErrorKind":["clone"],"hir::Hir":["alternation","capture","case_fold_char","class","clone","concat","dot","empty","fail","finish","hir_assertion","hir_dot","lift_common_prefix","literal","look","parse","pop_alt_expr","pop_concat_expr","repetition","translate","unwrap_expr"],"hir::HirKind":["clone","into_kind"],"hir::Literal":["clone"],"hir::Look":["clone","from_repr","next"],"hir::LookSet":["clone","default","empty","full","look_set","look_set_prefix","look_set_prefix_any","look_set_suffix","look_set_suffix_any","read_repr","singleton"],"hir::LookSetIter":["clone","iter"],"hir::Properties":["alternation","capture","class","clone","concat","empty","literal","look","repetition","union"],"hir::PropertiesI":["clone"],"hir::Repetition":["clone","with"],"hir::interval::IntervalSet":["clone","new"],"hir::interval::IntervalSetIter":["iter"],"hir::literal::ExtractKind":["clone","default"],"hir::literal::Extractor":["clone","default","new"],"hir::literal::Literal":["clone","exact","from","inexact"],"hir::literal::PreferenceTrie":["default"],"hir::literal::Seq":["clone","empty","extract","extract_alternation","extract_class_bytes","extract_class_unicode","extract_concat","extract_repetition","from_iter","infinite","new","singleton"],"hir::literal::State":["default"],"hir::print::Printer":["build","new"],"hir::print::PrinterBuilder":["clone","default","new"],"hir::translate::Flags":["clone","default","flags","from_ast","set_flags","unwrap_group"],"hir::translate::HirFrame":["clone","pop"],"hir::translate::Translator":["build","clone","new"],"hir::translate::TranslatorBuilder":["clone","default","new"],"hir::translate::TranslatorI":["clone","new"],"hir::visitor::Frame":["induct"],"hir::visitor::HeapVisitor":["new"],"impl std::iter::Iterator<Item = &'static [(char, char)]>":["ages","imp"],"impl std::iter::Iterator<Item = (char, char)>":["ascii_class_as_chars"],"impl std::iter::Iterator<Item = (u8, u8)>":["ascii_class"],"parser::Parser":["build","clone","new"],"parser::ParserBuilder":["clone","default","new"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::string::String":["escape","left_pad_line_number","notate","notate_line","repeat_char","symbolic_name_normalize"],"std::vec::Vec":["into_bytes","literal","singleton_bytes","singleton_chars"],"u16":["as_repr"],"u32":["as_u32","capture_index","digits","max_scalar_value","next_capture_index","parse_decimal"],"u8":["byte","class_literal_byte","end","lower","max_value","min_value","start","upper"],"unicode::CanonicalClassQuery":["canonical_binary","canonicalize"],"unicode::SimpleCaseFolder":["new"],"usize":["add_item","column","create_state","encode","explicit_captures_len","get","insert","len","line","line_number_padding","max_cross_len","max_literal_len","max_union_len","maximum_len","memory_usage","min_literal_len","minimum_len","offset","root","static_explicit_captures_len"],"utf8::Utf8Range":["as_ascii","clone","new"],"utf8::Utf8Sequence":["clone","from_encoded_range"],"utf8::Utf8Sequences":["new"]},"struct_to_trait":{"ast::Alternation":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Assertion":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::AssertionKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Ast":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Drop"],"ast::CaptureName":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Class":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassAscii":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassAsciiKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassBracketed":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassPerl":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassPerlKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSet":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Drop"],"ast::ClassSetBinaryOp":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSetBinaryOpKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSetItem":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSetRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassSetUnion":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassUnicode":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassUnicodeKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ClassUnicodeOpKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Comment":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Concat":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::ErrorKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Flag":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Flags":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::FlagsItem":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::FlagsItemKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Group":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::GroupKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::HexLiteralKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Literal":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::LiteralKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Position":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Repetition":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::RepetitionKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::RepetitionOp":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::RepetitionRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::SetFlags":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::Span":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::SpecialLiteralKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::WithComments":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::parse::ClassState":["std::clone::Clone","std::fmt::Debug"],"ast::parse::GroupState":["std::clone::Clone","std::fmt::Debug"],"ast::parse::NestLimiter":["ast::visitor::Visitor","std::fmt::Debug"],"ast::parse::Parser":["std::clone::Clone","std::fmt::Debug"],"ast::parse::ParserBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"ast::parse::ParserI":["std::clone::Clone","std::fmt::Debug"],"ast::parse::Primitive":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"ast::print::Printer":["std::fmt::Debug"],"ast::print::PrinterBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"ast::print::Writer":["ast::visitor::Visitor","std::fmt::Debug"],"ast::visitor::ClassFrame":["std::fmt::Debug"],"ast::visitor::ClassInduct":["std::fmt::Debug"],"debug::Byte":["std::fmt::Debug"],"debug::Bytes":["std::fmt::Debug"],"either::Either":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::Formatter":["std::convert::From","std::fmt::Debug","std::fmt::Display"],"hir::Capture":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Class":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ClassBytes":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ClassBytesIter":["std::fmt::Debug","std::iter::Iterator"],"hir::ClassBytesRange":["hir::interval::Interval","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ClassUnicode":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ClassUnicodeIter":["std::fmt::Debug","std::iter::Iterator"],"hir::ClassUnicodeRange":["hir::interval::Interval","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Dot":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Error":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::ErrorKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Hir":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Drop"],"hir::HirKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Literal":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Look":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::LookSet":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::LookSetIter":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"hir::Properties":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::PropertiesI":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::Repetition":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::interval::IntervalSet":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"],"hir::interval::IntervalSetIter":["std::fmt::Debug","std::iter::Iterator"],"hir::literal::ExtractKind":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"hir::literal::Extractor":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"hir::literal::Literal":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::literal::PreferenceTrie":["std::default::Default","std::fmt::Debug"],"hir::literal::Seq":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::iter::FromIterator","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"hir::literal::State":["std::default::Default","std::fmt::Debug"],"hir::print::Printer":["std::fmt::Debug"],"hir::print::PrinterBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"hir::print::Writer":["hir::visitor::Visitor","std::fmt::Debug"],"hir::translate::Flags":["std::clone::Clone","std::default::Default","std::fmt::Debug","std::marker::Copy"],"hir::translate::HirFrame":["std::clone::Clone","std::fmt::Debug"],"hir::translate::Translator":["std::clone::Clone","std::fmt::Debug"],"hir::translate::TranslatorBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"hir::translate::TranslatorI":["ast::visitor::Visitor","std::clone::Clone","std::fmt::Debug"],"parser::Parser":["std::clone::Clone","std::fmt::Debug"],"parser::ParserBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"unicode::CanonicalClassQuery":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"unicode::CaseFoldError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"unicode::ClassQuery":["std::fmt::Debug"],"unicode::Error":["std::fmt::Debug"],"unicode::SimpleCaseFolder":["std::fmt::Debug"],"unicode::UnicodeWordError":["std::error::Error","std::fmt::Debug","std::fmt::Display"],"utf8::ScalarRange":["std::fmt::Debug"],"utf8::Utf8Range":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"utf8::Utf8Sequence":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"utf8::Utf8Sequences":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"]},"targets":{"<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/utf8.rs\"))","std::iter::IntoIterator"],"<ast::Ast as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Display"],"<ast::Ast as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/ast/mod.rs\"))","std::ops::Drop"],"<ast::ClassSet as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/ast/mod.rs\"))","std::ops::Drop"],"<ast::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Display"],"<ast::ErrorKind as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Display"],"<ast::Position as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/ast/mod.rs\"))","std::cmp::Ord"],"<ast::Position as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/ast/mod.rs\"))","std::cmp::PartialOrd"],"<ast::Position as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Debug"],"<ast::Span as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/ast/mod.rs\"))","std::cmp::Ord"],"<ast::Span as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/ast/mod.rs\"))","std::cmp::PartialOrd"],"<ast::Span as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ast/mod.rs\"))","std::fmt::Debug"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":["finish","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["visit_class_set_binary_op_post","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["visit_class_set_binary_op_pre","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":["visit_class_set_item_post","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":["visit_class_set_item_pre","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":["visit_post","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":["visit_pre","Real(LocalPath(\"src/ast/parse.rs\"))","ast::visitor::Visitor"],"<ast::parse::ParserBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/ast/parse.rs\"))","std::default::Default"],"<ast::print::PrinterBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/ast/print.rs\"))","std::default::Default"],"<ast::print::Writer<W> as ast::visitor::Visitor>::finish":["finish","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_alternation_in":["visit_alternation_in","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["visit_class_set_binary_op_in","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_post":["visit_class_set_item_post","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_class_set_item_pre":["visit_class_set_item_pre","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_post":["visit_post","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::print::Writer<W> as ast::visitor::Visitor>::visit_pre":["visit_pre","Real(LocalPath(\"src/ast/print.rs\"))","ast::visitor::Visitor"],"<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ast/visitor.rs\"))","std::fmt::Debug"],"<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/ast/visitor.rs\"))","std::fmt::Debug"],"<char as hir::interval::Bound>::as_u32":["as_u32","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<char as hir::interval::Bound>::decrement":["decrement","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<char as hir::interval::Bound>::increment":["increment","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<char as hir::interval::Bound>::max_value":["max_value","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<char as hir::interval::Bound>::min_value":["min_value","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<debug::Byte as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/debug.rs\"))","std::fmt::Debug"],"<debug::Bytes<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/debug.rs\"))","std::fmt::Debug"],"<error::Error as std::convert::From<ast::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::convert::From<hir::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::Formatter<'e, E> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"<hir::Class as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Debug"],"<hir::ClassBytesIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hir/mod.rs\"))","std::iter::Iterator"],"<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as hir::interval::Interval>::lower":["lower","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as hir::interval::Interval>::set_lower":["set_lower","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as hir::interval::Interval>::set_upper":["set_upper","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as hir::interval::Interval>::upper":["upper","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassBytesRange as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Debug"],"<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hir/mod.rs\"))","std::iter::Iterator"],"<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as hir::interval::Interval>::lower":["lower","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower":["set_lower","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper":["set_upper","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as hir::interval::Interval>::upper":["upper","Real(LocalPath(\"src/hir/mod.rs\"))","hir::interval::Interval"],"<hir::ClassUnicodeRange as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Debug"],"<hir::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Display"],"<hir::ErrorKind as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Display"],"<hir::Hir as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Debug"],"<hir::Hir as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Display"],"<hir::Hir as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/hir/mod.rs\"))","std::ops::Drop"],"<hir::Literal as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Debug"],"<hir::LookSet as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/mod.rs\"))","std::fmt::Debug"],"<hir::LookSetIter as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hir/mod.rs\"))","std::iter::Iterator"],"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/hir/interval.rs\"))","std::cmp::PartialEq"],"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/hir/interval.rs\"))","std::iter::Iterator"],"<hir::literal::ExtractKind as std::default::Default>::default":["default","Real(LocalPath(\"src/hir/literal.rs\"))","std::default::Default"],"<hir::literal::Extractor as std::default::Default>::default":["default","Real(LocalPath(\"src/hir/literal.rs\"))","std::default::Default"],"<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref":["as_ref","Real(LocalPath(\"src/hir/literal.rs\"))","std::convert::AsRef"],"<hir::literal::Literal as std::convert::From<char>>::from":["from","Real(LocalPath(\"src/hir/literal.rs\"))","std::convert::From"],"<hir::literal::Literal as std::convert::From<u8>>::from":["from","Real(LocalPath(\"src/hir/literal.rs\"))","std::convert::From"],"<hir::literal::Literal as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/literal.rs\"))","std::fmt::Debug"],"<hir::literal::Seq as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/hir/literal.rs\"))","std::fmt::Debug"],"<hir::literal::Seq as std::iter::FromIterator<hir::literal::Literal>>::from_iter":["from_iter","Real(LocalPath(\"src/hir/literal.rs\"))","std::iter::FromIterator"],"<hir::print::PrinterBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/hir/print.rs\"))","std::default::Default"],"<hir::print::Writer<W> as hir::visitor::Visitor>::finish":["finish","Real(LocalPath(\"src/hir/print.rs\"))","hir::visitor::Visitor"],"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_alternation_in":["visit_alternation_in","Real(LocalPath(\"src/hir/print.rs\"))","hir::visitor::Visitor"],"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_post":["visit_post","Real(LocalPath(\"src/hir/print.rs\"))","hir::visitor::Visitor"],"<hir::print::Writer<W> as hir::visitor::Visitor>::visit_pre":["visit_pre","Real(LocalPath(\"src/hir/print.rs\"))","hir::visitor::Visitor"],"<hir::translate::TranslatorBuilder as std::default::Default>::default":["default","Real(LocalPath(\"src/hir/translate.rs\"))","std::default::Default"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish":["finish","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_alternation_in":["visit_alternation_in","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in":["visit_class_set_binary_op_in","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post":["visit_class_set_binary_op_post","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":["visit_class_set_binary_op_pre","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post":["visit_class_set_item_post","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre":["visit_class_set_item_pre","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post":["visit_post","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre":["visit_pre","Real(LocalPath(\"src/hir/translate.rs\"))","ast::visitor::Visitor"],"<u8 as hir::interval::Bound>::as_u32":["as_u32","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<u8 as hir::interval::Bound>::decrement":["decrement","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<u8 as hir::interval::Bound>::increment":["increment","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<u8 as hir::interval::Bound>::max_value":["max_value","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<u8 as hir::interval::Bound>::min_value":["min_value","Real(LocalPath(\"src/hir/interval.rs\"))","hir::interval::Bound"],"<unicode::CaseFoldError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/unicode.rs\"))","std::fmt::Display"],"<unicode::UnicodeWordError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/unicode.rs\"))","std::fmt::Display"],"<utf8::ScalarRange as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8.rs\"))","std::fmt::Debug"],"<utf8::Utf8Range as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8.rs\"))","std::fmt::Debug"],"<utf8::Utf8Sequence as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/utf8.rs\"))","std::fmt::Debug"],"<utf8::Utf8Sequences as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/utf8.rs\"))","std::iter::Iterator"],"ast::Alternation::into_ast":["into_ast","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Ast::has_subexprs":["has_subexprs","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Ast::is_empty":["is_empty","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Ast::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Class::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassAsciiKind::from_name":["from_name","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSet::is_empty":["is_empty","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSet::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSet::union":["union","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSetItem::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSetRange::is_valid":["is_valid","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSetUnion::into_item":["into_item","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassSetUnion::push":["push","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassUnicode::is_negated":["is_negated","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::ClassUnicodeOpKind::is_equal":["is_equal","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Concat::into_ast":["into_ast","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Error::auxiliary_span":["auxiliary_span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Error::kind":["kind","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Error::pattern":["pattern","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Error::span":["span","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Flags::add_item":["add_item","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Flags::flag_state":["flag_state","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::FlagsItemKind::is_negation":["is_negation","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Group::capture_index":["capture_index","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Group::flags":["flags","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Group::is_capturing":["is_capturing","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::HexLiteralKind::digits":["digits","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Literal::byte":["byte","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Position::new":["new","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::RepetitionRange::is_valid":["is_valid","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::is_empty":["is_empty","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::is_one_line":["is_one_line","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::new":["new","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::splat":["splat","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::with_end":["with_end","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::Span::with_start":["with_start","Real(LocalPath(\"src/ast/mod.rs\"))",""],"ast::parse::NestLimiter::<'p, 's, P>::check":["check","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":["decrement_depth","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":["increment_depth","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::NestLimiter::<'p, 's, P>::new":["new","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Parser::new":["new","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Parser::parse":["parse","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Parser::parse_with_comments":["parse_with_comments","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Parser::reset":["reset","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::build":["build","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::nest_limit":["nest_limit","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::new":["new","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserBuilder::octal":["octal","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::add_capture_name":["add_capture_name","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::bump":["bump","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::bump_and_bump_space":["bump_and_bump_space","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::bump_if":["bump_if","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::bump_space":["bump_space","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::char":["char","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::char_at":["char_at","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::column":["column","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::error":["error","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::is_eof":["is_eof","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":["is_lookaround_prefix","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::line":["line","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":["maybe_parse_ascii_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::new":["new","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::next_capture_index":["next_capture_index","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::offset":["offset","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse":["parse","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_capture_name":["parse_capture_name","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_counted_repetition":["parse_counted_repetition","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_decimal":["parse_decimal","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_escape":["parse_escape","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_flag":["parse_flag","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_flags":["parse_flags","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_group":["parse_group","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_hex":["parse_hex","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_hex_brace":["parse_hex_brace","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_hex_digits":["parse_hex_digits","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_octal":["parse_octal","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_perl_class":["parse_perl_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_primitive":["parse_primitive","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_set_class":["parse_set_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_set_class_item":["parse_set_class_item","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_set_class_open":["parse_set_class_open","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_set_class_range":["parse_set_class_range","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":["parse_uncounted_repetition","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_unicode_class":["parse_unicode_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parse_with_comments":["parse_with_comments","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::parser":["parser","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pattern":["pattern","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::peek":["peek","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::peek_space":["peek_space","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pop_class":["pop_class","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pop_class_op":["pop_class_op","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pop_group":["pop_group","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pop_group_end":["pop_group_end","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::pos":["pos","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_alternate":["push_alternate","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_class_op":["push_class_op","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_class_open":["push_class_open","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_group":["push_group","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::push_or_add_alternation":["push_or_add_alternation","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::span":["span","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::span_char":["span_char","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::ParserI::<'s, P>::unclosed_class_error":["unclosed_class_error","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Primitive::into_ast":["into_ast","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Primitive::into_class_literal":["into_class_literal","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Primitive::into_class_set_item":["into_class_set_item","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::Primitive::span":["span","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::is_capture_char":["is_capture_char","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::is_hex":["is_hex","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::parse::specialize_err":["specialize_err","Real(LocalPath(\"src/ast/parse.rs\"))",""],"ast::print::Printer::new":["new","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Printer::print":["print","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::PrinterBuilder::build":["build","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::PrinterBuilder::new":["new","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_assertion":["fmt_assertion","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_class_ascii":["fmt_class_ascii","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_class_bracketed_post":["fmt_class_bracketed_post","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_class_bracketed_pre":["fmt_class_bracketed_pre","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_class_perl":["fmt_class_perl","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_class_set_binary_op_kind":["fmt_class_set_binary_op_kind","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_class_unicode":["fmt_class_unicode","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_flags":["fmt_flags","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_group_post":["fmt_group_post","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_group_pre":["fmt_group_pre","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_literal":["fmt_literal","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_repetition":["fmt_repetition","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_repetition_range":["fmt_repetition_range","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::print::Writer::<W>::fmt_set_flags":["fmt_set_flags","Real(LocalPath(\"src/ast/print.rs\"))",""],"ast::visitor::ClassFrame::<'a>::child":["child","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::ClassInduct::<'a>::from_bracketed":["from_bracketed","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::ClassInduct::<'a>::from_set":["from_set","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Frame::<'a>::child":["child","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::induct":["induct","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::induct_class":["induct_class","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::new":["new","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::pop":["pop","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::pop_class":["pop_class","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::visit":["visit","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::visit_class":["visit_class","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::visit_class_post":["visit_class_post","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::HeapVisitor::<'a>::visit_class_pre":["visit_class_pre","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::start":["start","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_alternation_in":["visit_alternation_in","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_binary_op_in":["visit_class_set_binary_op_in","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_binary_op_post":["visit_class_set_binary_op_post","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_binary_op_pre":["visit_class_set_binary_op_pre","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_item_post":["visit_class_set_item_post","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_class_set_item_pre":["visit_class_set_item_pre","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_post":["visit_post","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::Visitor::visit_pre":["visit_pre","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"ast::visitor::visit":["visit","Real(LocalPath(\"src/ast/visitor.rs\"))",""],"debug::utf8_decode":["utf8_decode","Real(LocalPath(\"src/debug.rs\"))",""],"debug::utf8_decode::len":["len","Real(LocalPath(\"src/debug.rs\"))",""],"error::Spans::<'p>::add":["add","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::from_formatter":["from_formatter","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::left_pad_line_number":["left_pad_line_number","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::line_number_padding":["line_number_padding","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::notate":["notate","Real(LocalPath(\"src/error.rs\"))",""],"error::Spans::<'p>::notate_line":["notate_line","Real(LocalPath(\"src/error.rs\"))",""],"error::repeat_char":["repeat_char","Real(LocalPath(\"src/error.rs\"))",""],"escape":["escape","Real(LocalPath(\"src/lib.rs\"))",""],"escape_into":["escape_into","Real(LocalPath(\"src/lib.rs\"))",""],"hir::Class::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Class::is_empty":["is_empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Class::is_utf8":["is_utf8","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Class::literal":["literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Class::maximum_len":["maximum_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Class::minimum_len":["minimum_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Class::negate":["negate","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Class::try_case_fold_simple":["try_case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::difference":["difference","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::empty":["empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::intersect":["intersect","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::is_ascii":["is_ascii","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::iter":["iter","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::literal":["literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::maximum_len":["maximum_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::minimum_len":["minimum_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::negate":["negate","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::new":["new","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::push":["push","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::ranges":["ranges","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::to_unicode_class":["to_unicode_class","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytes::union":["union","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytesRange::end":["end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytesRange::len":["len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytesRange::new":["new","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassBytesRange::start":["start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::difference":["difference","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::empty":["empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::intersect":["intersect","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::is_ascii":["is_ascii","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::iter":["iter","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::literal":["literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::maximum_len":["maximum_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::minimum_len":["minimum_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::negate":["negate","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::new":["new","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::push":["push","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::ranges":["ranges","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::to_byte_class":["to_byte_class","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::try_case_fold_simple":["try_case_fold_simple","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicode::union":["union","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicodeRange::end":["end","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicodeRange::len":["len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicodeRange::new":["new","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::ClassUnicodeRange::start":["start","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Error::kind":["kind","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Error::pattern":["pattern","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Error::span":["span","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::alternation":["alternation","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::capture":["capture","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::class":["class","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::concat":["concat","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::dot":["dot","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::empty":["empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::fail":["fail","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::into_kind":["into_kind","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::into_parts":["into_parts","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::kind":["kind","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::literal":["literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::look":["look","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::properties":["properties","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Hir::repetition":["repetition","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::HirKind::subs":["subs","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Look::as_char":["as_char","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Look::as_repr":["as_repr","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Look::from_repr":["from_repr","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Look::reversed":["reversed","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::contains":["contains","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::contains_anchor":["contains_anchor","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::contains_anchor_crlf":["contains_anchor_crlf","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::contains_anchor_haystack":["contains_anchor_haystack","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::contains_anchor_lf":["contains_anchor_lf","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::contains_anchor_line":["contains_anchor_line","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::contains_word":["contains_word","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::contains_word_ascii":["contains_word_ascii","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::contains_word_unicode":["contains_word_unicode","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::empty":["empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::full":["full","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::insert":["insert","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::intersect":["intersect","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::is_empty":["is_empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::iter":["iter","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::len":["len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::read_repr":["read_repr","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::remove":["remove","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::set_insert":["set_insert","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::set_intersect":["set_intersect","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::set_remove":["set_remove","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::set_subtract":["set_subtract","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::set_union":["set_union","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::singleton":["singleton","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::subtract":["subtract","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::union":["union","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::LookSet::write_repr":["write_repr","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::alternation":["alternation","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::capture":["capture","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::class":["class","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::concat":["concat","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::empty":["empty","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::explicit_captures_len":["explicit_captures_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::is_alternation_literal":["is_alternation_literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::is_literal":["is_literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::is_utf8":["is_utf8","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::literal":["literal","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::look":["look","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::look_set":["look_set","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::look_set_prefix":["look_set_prefix","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::look_set_prefix_any":["look_set_prefix_any","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::look_set_suffix":["look_set_suffix","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::look_set_suffix_any":["look_set_suffix_any","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::maximum_len":["maximum_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::memory_usage":["memory_usage","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::minimum_len":["minimum_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::repetition":["repetition","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::static_explicit_captures_len":["static_explicit_captures_len","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Properties::union":["union","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::Repetition::with":["with","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::class_bytes":["class_bytes","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::class_chars":["class_chars","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::interval::Interval::create":["create","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::difference":["difference","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::intersect":["intersect","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::is_contiguous":["is_contiguous","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::is_intersection_empty":["is_intersection_empty","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::is_subset":["is_subset","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::Interval::union":["union","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::canonicalize":["canonicalize","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::case_fold_simple":["case_fold_simple","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::difference":["difference","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::intersect":["intersect","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::intervals":["intervals","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::is_canonical":["is_canonical","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::iter":["iter","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::negate":["negate","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::new":["new","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::push":["push","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::symmetric_difference":["symmetric_difference","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::interval::IntervalSet::<I>::union":["union","Real(LocalPath(\"src/hir/interval.rs\"))",""],"hir::lift_common_prefix":["lift_common_prefix","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::literal::ExtractKind::is_prefix":["is_prefix","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::ExtractKind::is_suffix":["is_suffix","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::class_over_limit_bytes":["class_over_limit_bytes","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::class_over_limit_unicode":["class_over_limit_unicode","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::cross":["cross","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::enforce_literal_len":["enforce_literal_len","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::extract":["extract","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::extract_alternation":["extract_alternation","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::extract_class_bytes":["extract_class_bytes","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::extract_class_unicode":["extract_class_unicode","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::extract_concat":["extract_concat","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::extract_repetition":["extract_repetition","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::kind":["kind","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::limit_class":["limit_class","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::limit_literal_len":["limit_literal_len","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::limit_repeat":["limit_repeat","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::limit_total":["limit_total","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::new":["new","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Extractor::union":["union","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::as_bytes":["as_bytes","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::exact":["exact","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::extend":["extend","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::inexact":["inexact","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::into_bytes":["into_bytes","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::is_empty":["is_empty","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::is_exact":["is_exact","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::is_poisonous":["is_poisonous","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::keep_first_bytes":["keep_first_bytes","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::keep_last_bytes":["keep_last_bytes","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::len":["len","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::make_inexact":["make_inexact","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Literal::reverse":["reverse","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::PreferenceTrie::create_state":["create_state","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::PreferenceTrie::insert":["insert","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::PreferenceTrie::minimize":["minimize","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::PreferenceTrie::root":["root","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::cross_forward":["cross_forward","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::cross_preamble":["cross_preamble","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::cross_reverse":["cross_reverse","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::dedup":["dedup","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::empty":["empty","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::infinite":["infinite","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::is_empty":["is_empty","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::is_exact":["is_exact","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::is_finite":["is_finite","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::is_inexact":["is_inexact","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::keep_first_bytes":["keep_first_bytes","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::keep_last_bytes":["keep_last_bytes","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::len":["len","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::literals":["literals","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::longest_common_prefix":["longest_common_prefix","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::longest_common_suffix":["longest_common_suffix","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::make_inexact":["make_inexact","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::make_infinite":["make_infinite","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::max_cross_len":["max_cross_len","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::max_literal_len":["max_literal_len","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::max_union_len":["max_union_len","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::min_literal_len":["min_literal_len","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::minimize_by_preference":["minimize_by_preference","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::new":["new","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::optimize_by_preference":["optimize_by_preference","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::optimize_for_prefix_by_preference":["optimize_for_prefix_by_preference","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::optimize_for_suffix_by_preference":["optimize_for_suffix_by_preference","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::push":["push","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::reverse_literals":["reverse_literals","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::singleton":["singleton","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::sort":["sort","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::union":["union","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::Seq::union_into_empty":["union_into_empty","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::literal::rank":["rank","Real(LocalPath(\"src/hir/literal.rs\"))",""],"hir::print::Printer::new":["new","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::Printer::print":["print","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::PrinterBuilder::build":["build","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::PrinterBuilder::new":["new","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::Writer::<W>::write_literal_byte":["write_literal_byte","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::Writer::<W>::write_literal_char":["write_literal_char","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::print::Writer::<W>::write_literal_class_byte":["write_literal_class_byte","Real(LocalPath(\"src/hir/print.rs\"))",""],"hir::singleton_bytes":["singleton_bytes","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::singleton_chars":["singleton_chars","Real(LocalPath(\"src/hir/mod.rs\"))",""],"hir::translate::Flags::case_insensitive":["case_insensitive","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::crlf":["crlf","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::dot":["dot","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::from_ast":["from_ast","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::merge":["merge","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::multi_line":["multi_line","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::swap_greed":["swap_greed","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Flags::unicode":["unicode","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_alternation_pipe":["unwrap_alternation_pipe","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_class_bytes":["unwrap_class_bytes","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_class_unicode":["unwrap_class_unicode","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_expr":["unwrap_expr","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_group":["unwrap_group","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::HirFrame::unwrap_repetition":["unwrap_repetition","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Translator::new":["new","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::Translator::translate":["translate","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::build":["build","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::case_insensitive":["case_insensitive","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::crlf":["crlf","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::multi_line":["multi_line","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::new":["new","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::swap_greed":["swap_greed","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::unicode":["unicode","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorBuilder::utf8":["utf8","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::ast_literal_to_scalar":["ast_literal_to_scalar","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate":["bytes_fold_and_negate","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::case_fold_char":["case_fold_char","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::class_literal_byte":["class_literal_byte","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error":["convert_unicode_class_error","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::error":["error","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::flags":["flags","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_ascii_byte_class":["hir_ascii_byte_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_ascii_unicode_class":["hir_ascii_unicode_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_assertion":["hir_assertion","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_capture":["hir_capture","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_dot":["hir_dot","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class":["hir_perl_byte_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class":["hir_perl_unicode_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_repetition":["hir_repetition","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class":["hir_unicode_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::new":["new","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::pop":["pop","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::pop_alt_expr":["pop_alt_expr","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::pop_concat_expr":["pop_concat_expr","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::push":["push","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::push_byte":["push_byte","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::push_char":["push_char","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::set_flags":["set_flags","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::trans":["trans","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate":["unicode_fold_and_negate","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::ascii_class":["ascii_class","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::ascii_class_as_chars":["ascii_class_as_chars","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::translate::hir_ascii_class_bytes":["hir_ascii_class_bytes","Real(LocalPath(\"src/hir/translate.rs\"))",""],"hir::visitor::Frame::<'a>::child":["child","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::HeapVisitor::<'a>::induct":["induct","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::HeapVisitor::<'a>::new":["new","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::HeapVisitor::<'a>::pop":["pop","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::HeapVisitor::<'a>::visit":["visit","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::Visitor::start":["start","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::Visitor::visit_alternation_in":["visit_alternation_in","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::Visitor::visit_post":["visit_post","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::Visitor::visit_pre":["visit_pre","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"hir::visitor::visit":["visit","Real(LocalPath(\"src/hir/visitor.rs\"))",""],"is_escapeable_character":["is_escapeable_character","Real(LocalPath(\"src/lib.rs\"))",""],"is_meta_character":["is_meta_character","Real(LocalPath(\"src/lib.rs\"))",""],"is_word_byte":["is_word_byte","Real(LocalPath(\"src/lib.rs\"))",""],"is_word_character":["is_word_character","Real(LocalPath(\"src/lib.rs\"))",""],"parser::Parser::new":["new","Real(LocalPath(\"src/parser.rs\"))",""],"parser::Parser::parse":["parse","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::build":["build","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::case_insensitive":["case_insensitive","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::crlf":["crlf","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::multi_line":["multi_line","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::nest_limit":["nest_limit","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::new":["new","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::octal":["octal","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::swap_greed":["swap_greed","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::unicode":["unicode","Real(LocalPath(\"src/parser.rs\"))",""],"parser::ParserBuilder::utf8":["utf8","Real(LocalPath(\"src/parser.rs\"))",""],"parser::parse":["parse","Real(LocalPath(\"src/parser.rs\"))",""],"try_is_word_character":["try_is_word_character","Real(LocalPath(\"src/lib.rs\"))",""],"unicode::ClassQuery::<'a>::canonical_binary":["canonical_binary","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::ClassQuery::<'a>::canonicalize":["canonicalize","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::SimpleCaseFolder::get":["get","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::SimpleCaseFolder::mapping":["mapping","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::SimpleCaseFolder::new":["new","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::SimpleCaseFolder::overlaps":["overlaps","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::ages":["ages","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::ages::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::bool_property":["bool_property","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::bool_property::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_gencat":["canonical_gencat","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_prop":["canonical_prop","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_prop::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_script":["canonical_script","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::canonical_value":["canonical_value","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::class":["class","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::gcb":["gcb","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::gcb::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::gencat":["gencat","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::gencat::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::hir_class":["hir_class","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::is_word_character":["is_word_character","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::is_word_character::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_digit":["perl_digit","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_digit::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_space":["perl_space","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_space::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_word":["perl_word","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::perl_word::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::property_set":["property_set","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::property_values":["property_values","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::property_values::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::sb":["sb","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::sb::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::script":["script","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::script::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::script_extension":["script_extension","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::script_extension::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::symbolic_name_normalize":["symbolic_name_normalize","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::symbolic_name_normalize_bytes":["symbolic_name_normalize_bytes","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::wb":["wb","Real(LocalPath(\"src/unicode.rs\"))",""],"unicode::wb::imp":["imp","Real(LocalPath(\"src/unicode.rs\"))",""],"utf8::ScalarRange::as_ascii":["as_ascii","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::ScalarRange::encode":["encode","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::ScalarRange::is_ascii":["is_ascii","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::ScalarRange::is_valid":["is_valid","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::ScalarRange::split":["split","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Range::matches":["matches","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Range::new":["new","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::as_slice":["as_slice","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::from_encoded_range":["from_encoded_range","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::len":["len","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::matches":["matches","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequence::reverse":["reverse","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequences::new":["new","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequences::push":["push","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::Utf8Sequences::reset":["reset","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::max_scalar_value":["max_scalar_value","Real(LocalPath(\"src/utf8.rs\"))",""]},"trait_to_struct":{"ast::visitor::Visitor":["ast::parse::NestLimiter","ast::print::Writer","hir::translate::TranslatorI"],"hir::interval::Interval":["hir::ClassBytesRange","hir::ClassUnicodeRange"],"hir::visitor::Visitor":["hir::print::Writer"],"std::clone::Clone":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::ClassState","ast::parse::GroupState","ast::parse::Parser","ast::parse::ParserBuilder","ast::parse::ParserI","ast::parse::Primitive","ast::print::PrinterBuilder","either::Either","error::Error","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Dot","hir::Error","hir::ErrorKind","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::LookSet","hir::LookSetIter","hir::Properties","hir::PropertiesI","hir::Repetition","hir::interval::IntervalSet","hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Literal","hir::literal::Seq","hir::print::PrinterBuilder","hir::translate::Flags","hir::translate::HirFrame","hir::translate::Translator","hir::translate::TranslatorBuilder","hir::translate::TranslatorI","parser::Parser","parser::ParserBuilder","utf8::Utf8Range","utf8::Utf8Sequence"],"std::cmp::Eq":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::Primitive","either::Either","error::Error","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Dot","hir::Error","hir::ErrorKind","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::LookSet","hir::Properties","hir::PropertiesI","hir::Repetition","hir::interval::IntervalSet","hir::literal::Literal","hir::literal::Seq","unicode::CanonicalClassQuery","utf8::Utf8Range","utf8::Utf8Sequence"],"std::cmp::Ord":["ast::Position","ast::Span","hir::ClassBytesRange","hir::ClassUnicodeRange","hir::literal::Literal","utf8::Utf8Range","utf8::Utf8Sequence"],"std::cmp::PartialEq":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::Primitive","either::Either","error::Error","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Dot","hir::Error","hir::ErrorKind","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::LookSet","hir::Properties","hir::PropertiesI","hir::Repetition","hir::interval::IntervalSet","hir::literal::Literal","hir::literal::Seq","unicode::CanonicalClassQuery","utf8::Utf8Range","utf8::Utf8Sequence"],"std::cmp::PartialOrd":["ast::Position","ast::Span","hir::ClassBytesRange","hir::ClassUnicodeRange","hir::literal::Literal","utf8::Utf8Range","utf8::Utf8Sequence"],"std::convert::AsRef":["hir::literal::Literal"],"std::convert::From":["error::Error","error::Formatter","hir::literal::Literal"],"std::default::Default":["ast::parse::ParserBuilder","ast::print::PrinterBuilder","hir::ClassBytesRange","hir::ClassUnicodeRange","hir::LookSet","hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::PreferenceTrie","hir::literal::State","hir::print::PrinterBuilder","hir::translate::Flags","hir::translate::TranslatorBuilder","parser::ParserBuilder"],"std::error::Error":["ast::Error","error::Error","hir::Error","unicode::CaseFoldError","unicode::UnicodeWordError"],"std::fmt::Debug":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::ClassState","ast::parse::GroupState","ast::parse::NestLimiter","ast::parse::Parser","ast::parse::ParserBuilder","ast::parse::ParserI","ast::parse::Primitive","ast::print::Printer","ast::print::PrinterBuilder","ast::print::Writer","ast::visitor::ClassFrame","ast::visitor::ClassInduct","debug::Byte","debug::Bytes","either::Either","error::Error","error::Formatter","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassBytesIter","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeIter","hir::ClassUnicodeRange","hir::Dot","hir::Error","hir::ErrorKind","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::LookSet","hir::LookSetIter","hir::Properties","hir::PropertiesI","hir::Repetition","hir::interval::IntervalSet","hir::interval::IntervalSetIter","hir::literal::ExtractKind","hir::literal::Extractor","hir::literal::Literal","hir::literal::PreferenceTrie","hir::literal::Seq","hir::literal::State","hir::print::Printer","hir::print::PrinterBuilder","hir::print::Writer","hir::translate::Flags","hir::translate::HirFrame","hir::translate::Translator","hir::translate::TranslatorBuilder","hir::translate::TranslatorI","parser::Parser","parser::ParserBuilder","unicode::CanonicalClassQuery","unicode::CaseFoldError","unicode::ClassQuery","unicode::Error","unicode::SimpleCaseFolder","unicode::UnicodeWordError","utf8::ScalarRange","utf8::Utf8Range","utf8::Utf8Sequence","utf8::Utf8Sequences"],"std::fmt::Display":["ast::Ast","ast::Error","ast::ErrorKind","error::Error","error::Formatter","hir::Error","hir::ErrorKind","hir::Hir","unicode::CaseFoldError","unicode::UnicodeWordError"],"std::iter::FromIterator":["hir::literal::Seq"],"std::iter::FusedIterator":["utf8::Utf8Sequences"],"std::iter::Iterator":["hir::ClassBytesIter","hir::ClassUnicodeIter","hir::LookSetIter","hir::interval::IntervalSetIter","utf8::Utf8Sequences"],"std::marker::Copy":["ast::ClassSetBinaryOpKind","ast::Flag","ast::Position","ast::Span","hir::ClassBytesRange","hir::ClassUnicodeRange","hir::Dot","hir::Look","hir::LookSet","hir::translate::Flags","utf8::Utf8Range","utf8::Utf8Sequence"],"std::marker::StructuralEq":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::Primitive","either::Either","error::Error","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Dot","hir::Error","hir::ErrorKind","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::LookSet","hir::Properties","hir::PropertiesI","hir::Repetition","hir::literal::Literal","hir::literal::Seq","unicode::CanonicalClassQuery","utf8::Utf8Range","utf8::Utf8Sequence"],"std::marker::StructuralPartialEq":["ast::Alternation","ast::Assertion","ast::AssertionKind","ast::Ast","ast::CaptureName","ast::Class","ast::ClassAscii","ast::ClassAsciiKind","ast::ClassBracketed","ast::ClassPerl","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::ClassSetItem","ast::ClassSetRange","ast::ClassSetUnion","ast::ClassUnicode","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Comment","ast::Concat","ast::Error","ast::ErrorKind","ast::Flag","ast::Flags","ast::FlagsItem","ast::FlagsItemKind","ast::Group","ast::GroupKind","ast::HexLiteralKind","ast::Literal","ast::LiteralKind","ast::Position","ast::Repetition","ast::RepetitionKind","ast::RepetitionOp","ast::RepetitionRange","ast::SetFlags","ast::Span","ast::SpecialLiteralKind","ast::WithComments","ast::parse::Primitive","either::Either","error::Error","hir::Capture","hir::Class","hir::ClassBytes","hir::ClassBytesRange","hir::ClassUnicode","hir::ClassUnicodeRange","hir::Dot","hir::Error","hir::ErrorKind","hir::Hir","hir::HirKind","hir::Literal","hir::Look","hir::LookSet","hir::Properties","hir::PropertiesI","hir::Repetition","hir::literal::Literal","hir::literal::Seq","unicode::CanonicalClassQuery","utf8::Utf8Range","utf8::Utf8Sequence"],"std::ops::Drop":["ast::Ast","ast::ClassSet","hir::Hir"]},"type_to_def_path":{"ast::Alternation":"ast::Alternation","ast::Assertion":"ast::Assertion","ast::AssertionKind":"ast::AssertionKind","ast::Ast":"ast::Ast","ast::CaptureName":"ast::CaptureName","ast::Class":"ast::Class","ast::ClassAscii":"ast::ClassAscii","ast::ClassAsciiKind":"ast::ClassAsciiKind","ast::ClassBracketed":"ast::ClassBracketed","ast::ClassPerl":"ast::ClassPerl","ast::ClassPerlKind":"ast::ClassPerlKind","ast::ClassSet":"ast::ClassSet","ast::ClassSetBinaryOp":"ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind":"ast::ClassSetBinaryOpKind","ast::ClassSetItem":"ast::ClassSetItem","ast::ClassSetRange":"ast::ClassSetRange","ast::ClassSetUnion":"ast::ClassSetUnion","ast::ClassUnicode":"ast::ClassUnicode","ast::ClassUnicodeKind":"ast::ClassUnicodeKind","ast::ClassUnicodeOpKind":"ast::ClassUnicodeOpKind","ast::Comment":"ast::Comment","ast::Concat":"ast::Concat","ast::Error":"ast::Error","ast::ErrorKind":"ast::ErrorKind","ast::Flag":"ast::Flag","ast::Flags":"ast::Flags","ast::FlagsItem":"ast::FlagsItem","ast::FlagsItemKind":"ast::FlagsItemKind","ast::Group":"ast::Group","ast::GroupKind":"ast::GroupKind","ast::HexLiteralKind":"ast::HexLiteralKind","ast::Literal":"ast::Literal","ast::LiteralKind":"ast::LiteralKind","ast::Position":"ast::Position","ast::Repetition":"ast::Repetition","ast::RepetitionKind":"ast::RepetitionKind","ast::RepetitionOp":"ast::RepetitionOp","ast::RepetitionRange":"ast::RepetitionRange","ast::SetFlags":"ast::SetFlags","ast::Span":"ast::Span","ast::SpecialLiteralKind":"ast::SpecialLiteralKind","ast::WithComments":"ast::WithComments","ast::parse::ClassState":"ast::parse::ClassState","ast::parse::GroupState":"ast::parse::GroupState","ast::parse::NestLimiter<'p, 's, P>":"ast::parse::NestLimiter","ast::parse::Parser":"ast::parse::Parser","ast::parse::ParserBuilder":"ast::parse::ParserBuilder","ast::parse::ParserI<'s, P>":"ast::parse::ParserI","ast::parse::Primitive":"ast::parse::Primitive","ast::print::Printer":"ast::print::Printer","ast::print::PrinterBuilder":"ast::print::PrinterBuilder","ast::print::Writer<W>":"ast::print::Writer","ast::visitor::ClassFrame<'a>":"ast::visitor::ClassFrame","ast::visitor::ClassInduct<'a>":"ast::visitor::ClassInduct","ast::visitor::Frame<'a>":"ast::visitor::Frame","ast::visitor::HeapVisitor<'a>":"ast::visitor::HeapVisitor","debug::Byte":"debug::Byte","debug::Bytes<'a>":"debug::Bytes","either::Either<Left, Right>":"either::Either","error::Error":"error::Error","error::Formatter<'e, E>":"error::Formatter","error::Spans<'p>":"error::Spans","hir::Capture":"hir::Capture","hir::Class":"hir::Class","hir::ClassBytes":"hir::ClassBytes","hir::ClassBytesIter<'a>":"hir::ClassBytesIter","hir::ClassBytesRange":"hir::ClassBytesRange","hir::ClassUnicode":"hir::ClassUnicode","hir::ClassUnicodeIter<'a>":"hir::ClassUnicodeIter","hir::ClassUnicodeRange":"hir::ClassUnicodeRange","hir::Dot":"hir::Dot","hir::Error":"hir::Error","hir::ErrorKind":"hir::ErrorKind","hir::Hir":"hir::Hir","hir::HirKind":"hir::HirKind","hir::Literal":"hir::Literal","hir::Look":"hir::Look","hir::LookSet":"hir::LookSet","hir::LookSetIter":"hir::LookSetIter","hir::Properties":"hir::Properties","hir::PropertiesI":"hir::PropertiesI","hir::Repetition":"hir::Repetition","hir::interval::IntervalSet<I>":"hir::interval::IntervalSet","hir::interval::IntervalSetIter<'a, I>":"hir::interval::IntervalSetIter","hir::literal::ExtractKind":"hir::literal::ExtractKind","hir::literal::Extractor":"hir::literal::Extractor","hir::literal::Literal":"hir::literal::Literal","hir::literal::PreferenceTrie":"hir::literal::PreferenceTrie","hir::literal::Seq":"hir::literal::Seq","hir::literal::State":"hir::literal::State","hir::print::Printer":"hir::print::Printer","hir::print::PrinterBuilder":"hir::print::PrinterBuilder","hir::print::Writer<W>":"hir::print::Writer","hir::translate::Flags":"hir::translate::Flags","hir::translate::HirFrame":"hir::translate::HirFrame","hir::translate::Translator":"hir::translate::Translator","hir::translate::TranslatorBuilder":"hir::translate::TranslatorBuilder","hir::translate::TranslatorI<'t, 'p>":"hir::translate::TranslatorI","hir::visitor::Frame<'a>":"hir::visitor::Frame","hir::visitor::HeapVisitor<'a>":"hir::visitor::HeapVisitor","parser::Parser":"parser::Parser","parser::ParserBuilder":"parser::ParserBuilder","unicode::CanonicalClassQuery":"unicode::CanonicalClassQuery","unicode::CaseFoldError":"unicode::CaseFoldError","unicode::ClassQuery<'a>":"unicode::ClassQuery","unicode::Error":"unicode::Error","unicode::SimpleCaseFolder":"unicode::SimpleCaseFolder","unicode::UnicodeWordError":"unicode::UnicodeWordError","utf8::ScalarRange":"utf8::ScalarRange","utf8::Utf8Range":"utf8::Utf8Range","utf8::Utf8Sequence":"utf8::Utf8Sequence","utf8::Utf8Sequences":"utf8::Utf8Sequences"}}