-----------------
src/error.rs error::make_error
deps:{"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"error::make_error":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::make_error":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","error::Error","number::Endianness","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","internal::Needed","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+error::make_error(p0, p1);
+crate::error::make_error(p0, p1);
+crate::error::make_error(p0, p1);
-----------------
src/error.rs error::append_error
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::append_error":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::append_error":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","error::Error","internal::Err","number::Endianness","error::VerboseError","internal::Needed","<*const T as std::fmt::Debug>","error::VerboseErrorKind"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+error::append_error(p0, p1, p2);
+crate::error::append_error(p0, p1, p2);
+crate::error::append_error(p0, p1, p2);
-----------------
src/error.rs error::context
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"error::context":{"E":["std::marker::Sized","error::ContextError"],"F":["internal::Parser","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized"],"O":["std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::context":{"E":["error::VerboseError","error::Error"],"F":["internal::Or","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::And","internal::MapRes","internal::Into","internal::Map"],"I":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseErrorKind","internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>","number::Endianness","error::VerboseError","error::Error"],"O":["RUG_ANY"]},"internal::And":{"F":["internal::And","internal::Map","internal::FlatMap","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Or","std::boxed::Box"],"G":["internal::MapOpt","internal::FlatMap","internal::Or","std::boxed::Box","internal::MapRes","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::And"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Into","internal::Map","internal::Or","internal::MapRes","internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt"],"G":["internal::MapRes","internal::Map","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::Into","internal::Or","std::boxed::Box"]},"internal::Err":{"E":["error::VerboseError","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","internal::Needed","error::ErrorKind","number::Endianness","error::Error"]},"internal::FlatMap":{"F":["internal::Map","internal::And","internal::AndThen","internal::MapRes","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::AndThen","std::boxed::Box","internal::And","internal::Or","internal::MapRes","internal::Map","internal::Into","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapOpt","internal::Map","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::AndThen","internal::MapRes","internal::FlatMap","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"]},"internal::MapOpt":{"F":["internal::AndThen","std::boxed::Box","internal::MapOpt","internal::And","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapRes"],"G":["core::str::IsWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::Or","internal::And","internal::Map","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::AndThen","std::boxed::Box"],"G":["core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::Or","internal::FlatMap","internal::MapOpt","internal::And","internal::AndThen","internal::Into"],"G":["<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::Into","internal::MapRes","internal::Map","std::boxed::Box","internal::Or","internal::FlatMap","internal::MapOpt"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+error::context(&p0, p1);
+crate::error::context(&p0, p1);
+crate::error::context(&p0, p1);
-----------------
src/error.rs error::convert_error
deps:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"error::convert_error":{"I":["std::ops::Deref","std::marker::Sized"]}}
candidates:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"error::convert_error":{"I":["<&T as std::ops::Deref>","std::ffi::CString","std::boxed::ThinBox<T>","std::sync::Arc<T>","std::ffi::VaList<'a, 'f>","<&mut T as std::ops::Deref>","std::sync::LazyLock<T, F>","std::sync::MutexGuard<'_, T>","std::io::IoSlice<'a>","std::cell::RefMut<'_, T>","std::sync::mpmc::counter::Sender<C>","std::backtrace_rs::symbolize::gimli::mmap::Mmap","std::sync::RwLockWriteGuard<'_, T>","std::mem::ManuallyDrop<T>","std::ffi::OsString","std::sync::mpmc::counter::Receiver<C>","std::path::PathBuf","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::cell::LazyCell<T, F>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::sys_common::wtf8::Wtf8Buf","std::sync::mpmc::utils::CachePadded<T>","std::borrow::Cow<'_, B>","std::pin::Pin<P>","std::rc::Rc<T>","std::sync::RwLockReadGuard<'_, T>","std::sys_common::lazy_box::LazyBox<T>","std::io::IoSliceMut<'a>","std::collections::binary_heap::PeekMut<'_, T>","std::cell::Ref<'_, T>","std::string::String","std::panic::AssertUnwindSafe<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+error::convert_error(p0, p1);
+crate::error::convert_error(p0, p1);
+crate::error::convert_error(p0, p1);
-----------------
src/error.rs error::error_to_u32
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+error::error_to_u32(p0);
+crate::error::error_to_u32(p0);
+crate::error::error_to_u32(p0);
-----------------
src/error.rs error::dbg_dmp
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"error::dbg_dmp":{"E":["std::fmt::Debug","std::marker::Sized"],"F":["std::ops::Fn","std::marker::Sized"],"O":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::dbg_dmp":{"E":["<*mut T as std::fmt::Debug>","internal::Err","error::VerboseErrorKind","internal::Needed","error::VerboseError","traits::CompareResult","<*const T as std::fmt::Debug>","error::Error","number::Endianness","error::ErrorKind"],"F":["core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsNotEmpty"],"O":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::Error","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","number::Endianness","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = "sample"; // None+&str
+error::dbg_dmp(p0, &p1);
+crate::error::dbg_dmp(p0, &p1);
+crate::error::dbg_dmp(p0, &p1);
-----------------
src/branch/mod.rs branch::alt
deps:{"branch::alt":{"E":["error::ParseError","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized"],"List":["std::marker::Sized","branch::Alt"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"branch::alt":{"E":["error::VerboseError","error::Error"],"I":["error::VerboseErrorKind","error::ErrorKind","number::Endianness","internal::Needed","error::Error","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError"],"List":[],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","internal::Needed","error::VerboseErrorKind","error::VerboseError","error::Error","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // List
+branch::alt(p0);
+crate::branch::alt(p0);
+crate::branch::alt(p0);
-----------------
src/branch/mod.rs branch::permutation
deps:{"branch::permutation":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","std::clone::Clone"],"List":["branch::Permutation","std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"branch::permutation":{"E":["error::VerboseError","error::Error"],"I":["error::Error","error::VerboseErrorKind","error::VerboseError","internal::Err","error::ErrorKind","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for *const T>"],"List":[],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","error::ErrorKind","internal::Err","internal::Needed","error::VerboseError","number::Endianness","error::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // List
+branch::permutation(p0);
+crate::branch::permutation(p0);
+crate::branch::permutation(p0);
-----------------
src/combinator/mod.rs combinator::rest
deps:{"combinator::rest":{"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"combinator::rest":{"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","error::ErrorKind","error::Error","number::Endianness","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+combinator::rest(p0);
+crate::combinator::rest(p0);
+crate::combinator::rest(p0);
-----------------
src/combinator/mod.rs combinator::rest_len
deps:{"combinator::rest_len":{"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputLength","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"combinator::rest_len":{"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","error::VerboseErrorKind","internal::Needed","error::ErrorKind","internal::Err","error::Error","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+combinator::rest_len(p0);
+crate::combinator::rest_len(p0);
+crate::combinator::rest_len(p0);
-----------------
src/combinator/mod.rs combinator::map
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::map":{"E":["std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::map":{"E":["RUG_ANY"],"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Map","internal::And","internal::Or","internal::Into","std::boxed::Box","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Or","internal::MapRes","internal::AndThen","std::boxed::Box","internal::Map","internal::Into","internal::FlatMap"],"G":["internal::Or","internal::MapOpt","internal::AndThen","internal::And","internal::FlatMap","internal::Map","internal::Into","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::FlatMap","internal::MapOpt","internal::Or","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","std::boxed::Box","internal::And"],"G":["internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::Into","internal::Map","internal::MapRes","internal::FlatMap","std::boxed::Box"]},"internal::Err":{"E":["internal::Needed","number::Endianness","error::VerboseError","error::VerboseErrorKind","internal::Err","error::ErrorKind","error::Error","<*mut T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::Into","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Or","std::boxed::Box","internal::MapRes","internal::Map"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::Map","std::boxed::Box","internal::Into","internal::MapOpt","internal::And","internal::FlatMap","internal::Or","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::FlatMap","internal::And","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::Map","internal::AndThen","internal::Or","internal::FlatMap","internal::MapRes","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::Into"],"G":["core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsWhitespace"]},"internal::MapRes":{"F":["internal::And","internal::Into","internal::AndThen","internal::MapRes","internal::Map","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::MapOpt","internal::Or","internal::Into","internal::Map","internal::AndThen","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box"],"G":["internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::And","internal::FlatMap","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::map(p0, p1);
+crate::combinator::map(p0, p1);
+crate::combinator::map(p0, p1);
-----------------
src/combinator/mod.rs combinator::map_res
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::map_res":{"E":["std::marker::Sized","error::FromExternalError"],"E2":["std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"],"I":["std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::map_res":{"E":["error::Error","error::VerboseError"],"E2":["RUG_ANY"],"F":["internal::MapRes","internal::Or","internal::Map","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Into","internal::FlatMap"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"],"I":["number::Endianness","std::clone::impls::<impl std::clone::Clone for &T>","internal::Needed","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>","error::ErrorKind","internal::Err","error::VerboseErrorKind","error::Error"],"O":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::Into","internal::Map","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Or","std::boxed::Box","internal::MapOpt","internal::AndThen"],"G":["internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::And","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Map","internal::Or","internal::FlatMap"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::FlatMap","internal::Into","internal::AndThen","std::boxed::Box","internal::MapRes","internal::And","internal::Or"],"G":["<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::AndThen","internal::Or","internal::And","internal::Map","internal::Into","std::boxed::Box"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","error::ErrorKind","error::Error","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed","internal::Err","error::VerboseError"]},"internal::FlatMap":{"F":["internal::Map","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::FlatMap"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::MapRes","internal::Into","internal::FlatMap","internal::Or","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::MapOpt"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Into","internal::And","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Map"],"G":["core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"internal::MapOpt":{"F":["internal::AndThen","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::And"],"G":["core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::And","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Map","internal::AndThen"],"G":["core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::AndThen","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::Or","internal::And"],"G":["internal::And","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::MapRes"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::map_res(p0, p1);
+crate::combinator::map_res(p0, p1);
+crate::combinator::map_res(p0, p1);
-----------------
src/combinator/mod.rs combinator::map_opt
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::map_opt":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::map_opt":{"E":["error::Error","error::VerboseError"],"F":["internal::FlatMap","internal::And","internal::Map","internal::Or","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"],"I":["internal::Err","error::VerboseError","internal::Needed","error::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","error::VerboseErrorKind"],"O":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Map","internal::Into","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::MapOpt"],"G":["internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Map","internal::And","internal::MapOpt","internal::Or","internal::AndThen","internal::FlatMap"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::And","internal::Map","std::boxed::Box","internal::MapRes","internal::Or"],"G":["internal::MapRes","internal::Map","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::And","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::Into"]},"internal::Err":{"E":["internal::Err","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseError","error::ErrorKind","error::Error","number::Endianness","internal::Needed"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::Or","internal::Into","internal::Map","internal::AndThen","internal::MapRes","internal::MapOpt","internal::FlatMap"],"G":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::MapOpt","internal::Or","internal::Map","internal::And","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Into","std::boxed::Box","internal::Map","internal::MapRes"],"G":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::MapRes","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Map","internal::Or","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::And"],"G":["core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::MapRes","internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapOpt"],"G":["internal::MapOpt","internal::And","internal::Or","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::Map","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::map_opt(p0, p1);
+crate::combinator::map_opt(p0, p1);
+crate::combinator::map_opt(p0, p1);
-----------------
src/combinator/mod.rs combinator::map_parser
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::map_parser":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::map_parser":{"E":["error::VerboseError","error::Error"],"F":["internal::FlatMap","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::And","internal::Into","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::AndThen"],"G":["internal::FlatMap","internal::MapOpt","internal::Map","std::boxed::Box","internal::MapRes","internal::And","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::Or"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::MapRes","internal::And","internal::Into"],"G":["internal::Or","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::Map","internal::AndThen","internal::Into","internal::And","internal::MapOpt","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::AndThen","internal::Into","internal::Map","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Or","internal::And","<F as internal::Parser<I>>"],"G":["internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::AndThen","internal::Or","internal::And","internal::MapOpt","internal::Map","internal::FlatMap"]},"internal::Err":{"E":["error::Error","internal::Needed","internal::Err","<*const T as std::fmt::Debug>","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","number::Endianness"]},"internal::FlatMap":{"F":["internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::Into","internal::MapRes","internal::AndThen","internal::Or","internal::Map","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::Map","internal::AndThen","internal::Or","internal::And","internal::FlatMap","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Into"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapOpt","std::boxed::Box","internal::AndThen","internal::Map","internal::FlatMap","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Or"],"G":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty"]},"internal::MapOpt":{"F":["internal::And","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Map","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::AndThen"],"G":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"internal::MapRes":{"F":["internal::FlatMap","internal::Or","internal::And","internal::MapOpt","internal::Map","internal::MapRes","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::AndThen"],"G":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["std::boxed::Box","internal::AndThen","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::Into","internal::Or","internal::And"],"G":["internal::Map","internal::AndThen","internal::Or","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::MapOpt"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::map_parser(p0, p1);
+crate::combinator::map_parser(p0, p1);
+crate::combinator::map_parser(p0, p1);
-----------------
src/combinator/mod.rs combinator::flat_map
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::flat_map":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::flat_map":{"E":["error::VerboseError","error::Error"],"F":["internal::AndThen","internal::And","internal::FlatMap","internal::Or","internal::MapOpt","std::boxed::Box","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::Map"],"G":["core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte"],"H":["std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Into","internal::MapRes","internal::Or","internal::And","internal::AndThen","internal::Map"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::FlatMap","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::Or","internal::Into","internal::MapOpt"],"G":["internal::Into","internal::AndThen","internal::MapRes","internal::Map","internal::FlatMap","internal::Or","internal::And","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::Into","std::boxed::Box","internal::MapRes","internal::Map","internal::FlatMap","internal::MapOpt","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::And"],"G":["internal::MapRes","std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","error::ErrorKind","number::Endianness","internal::Needed","error::Error","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>"]},"internal::FlatMap":{"F":["internal::AndThen","internal::FlatMap","internal::And","internal::MapRes","std::boxed::Box","internal::Into","internal::MapOpt","internal::Map","internal::Or","<F as internal::Parser<I>>"],"G":["core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::FlatMap","internal::And","internal::MapOpt","internal::Map","internal::Or","std::boxed::Box"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapOpt","internal::FlatMap","internal::Or","std::boxed::Box","internal::MapRes","internal::And","internal::Into"],"G":["core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::Map","internal::And","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::MapRes","internal::MapOpt","internal::AndThen"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::MapRes","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Map","internal::Or","internal::FlatMap","internal::And"],"G":["core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::MapOpt","internal::Map","internal::MapRes","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::AndThen","std::boxed::Box","internal::And"],"G":["internal::Into","internal::Or","internal::Map","internal::And","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::AndThen","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::flat_map(p0, p1);
+crate::combinator::flat_map(p0, p1);
+crate::combinator::flat_map(p0, p1);
-----------------
src/combinator/mod.rs combinator::opt
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::opt":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::opt":{"E":["error::Error","error::VerboseError"],"F":["internal::Map","internal::FlatMap","internal::MapOpt","internal::Or","internal::AndThen","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::And"],"I":["std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseErrorKind","internal::Err","internal::Needed","error::VerboseError","error::Error","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Map","internal::MapRes","internal::Or","internal::AndThen","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::And"],"G":["internal::Map","internal::AndThen","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into","internal::And","internal::MapOpt"]},"internal::AndThen":{"F":["internal::Or","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::Map","internal::And"],"G":["internal::Into","internal::Or","internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::MapOpt"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","number::Endianness","error::VerboseErrorKind","error::VerboseError","error::Error"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Map","internal::And","internal::Into","std::boxed::Box","internal::MapOpt","internal::Or","internal::AndThen"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::Or","std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["std::boxed::Box","internal::And","internal::Into","internal::FlatMap","internal::MapOpt","internal::Map","internal::MapRes","internal::Or","internal::AndThen","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Or","internal::Into","std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["std::boxed::Box","internal::MapOpt","internal::Into","internal::Map","internal::MapRes","internal::And","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I>>"],"G":["core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::FlatMap","internal::Map","internal::And","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::Into","std::boxed::Box"],"G":["internal::FlatMap","internal::MapOpt","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Or","std::boxed::Box","internal::MapRes","internal::Into"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::opt(p0);
+crate::combinator::opt(p0);
+crate::combinator::opt(p0);
-----------------
src/combinator/mod.rs combinator::cond
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::cond":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::cond":{"E":["error::VerboseError","error::Error"],"F":["internal::Into","internal::And","internal::MapRes","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::Map","internal::MapOpt"],"I":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::Map","internal::Into","internal::MapRes","std::boxed::Box"],"G":["internal::And","std::boxed::Box","internal::Or","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::MapOpt","internal::FlatMap"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapRes","internal::MapOpt","internal::Map","internal::AndThen","internal::Into","internal::Or","std::boxed::Box"],"G":["internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::Or","internal::And","internal::Map"]},"internal::Err":{"E":["internal::Err","error::Error","error::VerboseErrorKind","internal::Needed","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError"]},"internal::FlatMap":{"F":["internal::Into","internal::And","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::Or","internal::FlatMap","std::boxed::Box"],"G":["core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"internal::Into":{"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::Map","internal::MapRes","internal::Into","internal::MapOpt","internal::Or","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or","internal::MapRes","internal::MapOpt","internal::And","internal::Into","<F as internal::Parser<I>>","internal::Map"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::And","std::boxed::Box","internal::MapRes"],"G":["core::str::CharEscapeDefault","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"internal::MapRes":{"F":["std::boxed::Box","internal::AndThen","internal::Or","internal::FlatMap","internal::And","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Map"],"G":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::And","internal::Map","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Into","std::boxed::Box","internal::MapOpt"],"G":["std::boxed::Box","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::AndThen","internal::Map","internal::MapOpt","internal::Into"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = true; // None+bool
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+combinator::cond(p0, p1);
+crate::combinator::cond(p0, p1);
+crate::combinator::cond(p0, p1);
-----------------
src/combinator/mod.rs combinator::peek
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::peek":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::peek":{"E":["error::Error","error::VerboseError"],"F":["internal::MapRes","internal::Map","internal::And","internal::AndThen","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","std::boxed::Box"],"I":["error::Error","number::Endianness","error::VerboseError","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","internal::Err","error::ErrorKind"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::And","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::Map"],"G":["internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::Into","std::boxed::Box","internal::AndThen","internal::MapRes","internal::And","internal::FlatMap"]},"internal::AndThen":{"F":["std::boxed::Box","internal::And","internal::Or","internal::AndThen","internal::MapOpt","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Into"],"G":["internal::And","internal::FlatMap","internal::Map","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::AndThen","std::boxed::Box"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseError","internal::Needed","error::VerboseErrorKind","number::Endianness","internal::Err","error::Error"]},"internal::FlatMap":{"F":["internal::Or","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::And","std::boxed::Box","internal::Into","internal::MapRes"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::Or","std::boxed::Box","internal::AndThen","internal::Map"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::MapRes","internal::Or","std::boxed::Box","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapOpt"],"G":["core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::MapRes","std::boxed::Box","internal::Or","internal::MapOpt","internal::FlatMap","internal::Into","internal::And","internal::Map","<F as internal::Parser<I>>","internal::AndThen"],"G":["core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::FlatMap","internal::MapOpt","internal::And","std::boxed::Box","internal::Or","internal::MapRes","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Into","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Map"],"G":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::MapRes","internal::Map","internal::Or","internal::And","internal::MapOpt"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::peek(p0);
+crate::combinator::peek(p0);
+crate::combinator::peek(p0);
-----------------
src/combinator/mod.rs combinator::eof
deps:{"combinator::eof":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"combinator::eof":{"E":["error::VerboseError","error::Error"],"I":["memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","error::VerboseErrorKind","internal::Err","error::Error","internal::Needed","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+combinator::eof(p0);
+crate::combinator::eof(p0);
+crate::combinator::eof(p0);
-----------------
src/combinator/mod.rs combinator::complete
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::complete":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::complete":{"E":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Into","internal::MapRes","internal::Or","internal::And","internal::Map","std::boxed::Box","internal::AndThen"],"I":["std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Err","number::Endianness","internal::Needed","error::VerboseError","error::Error","std::clone::impls::<impl std::clone::Clone for &T>","error::ErrorKind","error::VerboseErrorKind"],"O":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::And","internal::MapRes","std::boxed::Box","internal::Or","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::FlatMap"],"G":["internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Map","internal::Into"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::And","internal::Or","internal::MapOpt","internal::MapRes","internal::Into","internal::Map","internal::AndThen"],"G":["internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::FlatMap","std::boxed::Box","internal::Or","internal::Map","internal::AndThen","internal::MapRes"]},"internal::Err":{"E":["error::VerboseError","internal::Needed","error::Error","error::VerboseErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::Into","std::boxed::Box","internal::Or","internal::Map","internal::AndThen","internal::FlatMap","internal::MapRes"],"G":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::And","internal::MapRes","internal::AndThen","internal::Into","std::boxed::Box","internal::MapOpt","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","internal::Into","internal::And","internal::FlatMap","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Map"],"G":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace"]},"internal::MapOpt":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::MapOpt","internal::Into","internal::And","std::boxed::Box","internal::MapRes","internal::Map"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::Or"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["std::boxed::Box","internal::MapRes","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::FlatMap","internal::Into","internal::Map"],"G":["internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::Into","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Map","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::complete(p0);
+crate::combinator::complete(p0);
+crate::combinator::complete(p0);
-----------------
src/combinator/mod.rs combinator::all_consuming
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::all_consuming":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["traits::InputLength","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::all_consuming":{"E":["error::Error","error::VerboseError"],"F":["internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Map","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Or","internal::FlatMap"],"I":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::And","internal::FlatMap","internal::MapOpt","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::Map"],"G":["internal::AndThen","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::MapRes","std::boxed::Box","internal::Into","internal::And","internal::MapOpt"]},"internal::AndThen":{"F":["std::boxed::Box","internal::MapRes","internal::AndThen","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapOpt","internal::Map"],"G":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::And","internal::AndThen","internal::Map","internal::Into","internal::MapOpt","internal::Or","internal::FlatMap"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","number::Endianness","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseErrorKind","error::Error","error::VerboseError"]},"internal::FlatMap":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::Or","internal::Into","internal::MapOpt","std::boxed::Box","internal::Map","internal::And"],"G":["core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["<F as internal::Parser<I>>","internal::Or","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::And","internal::Map","internal::AndThen","internal::Into"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Or","internal::And","internal::FlatMap","internal::Into","internal::MapOpt","internal::Map","std::boxed::Box","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>"],"G":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::And","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Or","internal::AndThen","internal::Into","internal::MapRes","internal::MapOpt"],"G":["std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::FlatMap","std::boxed::Box","internal::Into","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapOpt","internal::Or"],"G":["core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::Or":{"F":["internal::MapOpt","internal::Or","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::And"],"G":["internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::FlatMap","internal::Or","std::boxed::Box","internal::AndThen","internal::Map","internal::And"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::all_consuming(p0);
+crate::combinator::all_consuming(p0);
+crate::combinator::all_consuming(p0);
-----------------
src/combinator/mod.rs combinator::verify
deps:{"<&A as std::alloc::Allocator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::borrow::Borrow<T>>":{},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::verify":{"<F as internal::Parser<I>>::Output":["std::borrow::Borrow"],"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::borrow::Borrow<T>>":{},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::verify":{"<F as internal::Parser<I>>::Output":["std::string::String","std::ffi::CString","std::ffi::OsString","std::sync::Arc<T>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::vec::Vec<T, A>"],"E":["error::Error","error::VerboseError"],"F":["internal::Map","internal::MapOpt","internal::And","std::boxed::Box","internal::AndThen","internal::MapRes","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::Or"],"G":["core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace"],"I":["internal::Err","error::ErrorKind","number::Endianness","error::Error","error::VerboseError","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Into","internal::FlatMap","internal::Or","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Map","std::boxed::Box","internal::And","<F as internal::Parser<I>>"],"G":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::Into","internal::MapRes","internal::Or","std::boxed::Box","internal::And","internal::Map"]},"internal::AndThen":{"F":["internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","internal::MapOpt","internal::Or","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::And"],"G":["internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::FlatMap","internal::And","internal::MapOpt","internal::AndThen","std::boxed::Box"]},"internal::Err":{"E":["error::VerboseError","number::Endianness","internal::Needed","internal::Err","error::Error","error::VerboseErrorKind","<*mut T as std::fmt::Debug>","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Into","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::Or","internal::And","internal::MapOpt"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::Into","internal::Or","internal::FlatMap","internal::And","std::boxed::Box","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::Map"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","internal::And","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","std::boxed::Box","internal::Map","internal::FlatMap","internal::MapOpt"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace"]},"internal::MapOpt":{"F":["internal::Map","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::MapRes","internal::AndThen","internal::Or","std::boxed::Box","internal::MapOpt","internal::And"],"G":["core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue"]},"internal::MapRes":{"F":["internal::AndThen","internal::Map","internal::MapOpt","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::Into","std::boxed::Box","internal::And"],"G":["core::str::CharEscapeDefault","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"]},"internal::Or":{"F":["internal::Into","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::And","internal::MapRes","internal::Map","internal::AndThen"],"G":["internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Or","internal::Into","internal::And","internal::Map","std::boxed::Box","internal::MapOpt"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::verify(p0, p1);
+crate::combinator::verify(p0, p1);
+crate::combinator::verify(p0, p1);
-----------------
src/combinator/mod.rs combinator::value
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::value":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::value":{"E":["error::Error","error::VerboseError"],"F":["internal::Map","internal::MapRes","internal::And","internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","std::boxed::Box"],"I":["RUG_ANY"],"O1":["number::Endianness","error::VerboseError","internal::Needed","error::ErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","internal::Err"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["std::boxed::Box","internal::AndThen","internal::Map","internal::And","internal::FlatMap","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::MapRes"],"G":["internal::AndThen","internal::MapOpt","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::MapRes","internal::Into","internal::Or","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::Or","std::boxed::Box","internal::AndThen","internal::Map","internal::MapOpt","internal::And","internal::Into","internal::FlatMap"],"G":["internal::Map","internal::FlatMap","internal::AndThen","internal::Or","internal::And","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Into","<F as internal::Parser<I>>"]},"internal::Err":{"E":["error::VerboseError","internal::Needed","error::Error","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseErrorKind","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::And","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::MapRes"],"G":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::Map","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Or","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::And","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapRes","internal::MapOpt","internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I>>"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::And","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::Map","internal::MapRes","internal::MapOpt"],"G":["core::str::IsWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["internal::FlatMap","internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["internal::FlatMap","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::And","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Or"],"G":["internal::MapOpt","std::boxed::Box","internal::Into","internal::FlatMap","internal::AndThen","internal::Map","internal::MapRes","internal::Or","internal::And","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // O1
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+combinator::value(p0, p1);
+crate::combinator::value(p0, p1);
+crate::combinator::value(p0, p1);
-----------------
src/combinator/mod.rs combinator::not
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::not":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::not":{"E":["error::VerboseError","error::Error"],"F":["<F as internal::Parser<I>>","internal::Into","internal::Or","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Map","internal::AndThen","internal::And","internal::MapRes"],"I":["number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","internal::Needed","error::VerboseErrorKind"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::MapRes","internal::Map","internal::Into","std::boxed::Box","internal::AndThen","internal::MapOpt"],"G":["internal::And","internal::Map","internal::FlatMap","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::AndThen","internal::Or"]},"internal::AndThen":{"F":["internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Into"],"G":["internal::MapOpt","internal::AndThen","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::FlatMap","internal::MapRes"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","internal::Err","error::VerboseError","error::Error","internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::MapOpt","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::FlatMap","internal::Into","internal::Or","internal::Map","internal::And","std::boxed::Box"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::And","internal::AndThen","internal::Or","internal::MapRes","internal::Into","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","std::boxed::Box"],"G":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::Into","internal::FlatMap","internal::Map","internal::MapOpt","internal::AndThen","internal::Or"],"G":["core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["internal::MapOpt","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::And","internal::MapRes"],"G":["internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Map","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Or","internal::And"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::not(p0);
+crate::combinator::not(p0);
+crate::combinator::not(p0);
-----------------
src/combinator/mod.rs combinator::recognize
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::recognize":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone","traits::Input","traits::Offset"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::recognize":{"E":["error::Error","error::VerboseError"],"F":["internal::MapOpt","std::boxed::Box","internal::Map","internal::AndThen","internal::Into","internal::Or","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::MapRes"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::MapOpt","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Into","internal::Or","internal::AndThen","internal::FlatMap"],"G":["internal::AndThen","internal::And","internal::MapRes","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","std::boxed::Box","internal::MapOpt"]},"internal::AndThen":{"F":["internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::And","internal::Map","internal::Or","internal::MapOpt","internal::FlatMap"],"G":["internal::MapRes","internal::Map","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Into","internal::Or","internal::FlatMap","internal::And","<F as internal::Parser<I>>"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::Error","error::VerboseError","internal::Err","error::VerboseErrorKind","number::Endianness","internal::Needed","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::Into","internal::MapOpt","std::boxed::Box","internal::Or","internal::FlatMap","internal::And"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::FlatMap","internal::Or","internal::MapRes","internal::Map","internal::Into","internal::MapOpt","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::MapOpt","internal::Into","internal::MapRes","internal::Map","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::MapOpt":{"F":["internal::And","internal::Into","internal::Or","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Map"],"G":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::Map","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::Or","internal::Into","internal::MapRes","internal::FlatMap"],"G":["core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["internal::Or","std::boxed::Box","internal::And","internal::Map","internal::MapOpt","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes"],"G":["internal::MapRes","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::And","internal::FlatMap","internal::MapOpt"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::recognize(p0);
+crate::combinator::recognize(p0);
+crate::combinator::recognize(p0);
-----------------
src/combinator/mod.rs combinator::consumed
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::consumed":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["traits::Offset","std::clone::Clone","std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::consumed":{"E":["error::VerboseError","error::Error"],"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::And","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map","internal::Into","internal::Or"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::MapOpt","internal::And","internal::AndThen","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::MapRes","internal::FlatMap"],"G":["std::boxed::Box","internal::And","internal::Or","internal::Map","internal::FlatMap","internal::AndThen","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt"]},"internal::AndThen":{"F":["internal::MapRes","internal::FlatMap","internal::Or","internal::Map","internal::Into","internal::AndThen","internal::And","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>"],"G":["internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::MapOpt","internal::Map","internal::AndThen","internal::And"]},"internal::Err":{"E":["internal::Needed","number::Endianness","internal::Err","error::Error","error::VerboseError","error::VerboseErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::And","internal::Into","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapRes","internal::FlatMap","internal::AndThen"],"G":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::Into","internal::Or","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Map"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapOpt","internal::Or","internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::And","internal::MapRes","<F as internal::Parser<I>>"],"G":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::Or","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::AndThen","internal::And","internal::MapOpt"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["std::boxed::Box","internal::Into","internal::And","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Map","internal::Or"],"G":["core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::And","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::Map","internal::MapRes","internal::Into","internal::MapOpt"],"G":["<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::And","internal::Or","internal::MapOpt","internal::AndThen","internal::Into","std::boxed::Box","internal::MapRes"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::consumed(p0);
+crate::combinator::consumed(p0);
+crate::combinator::consumed(p0);
-----------------
src/combinator/mod.rs combinator::cut
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::cut":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::cut":{"E":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I>>","internal::Or","internal::Map","internal::AndThen","internal::Into","internal::MapRes","internal::And","std::boxed::Box","internal::FlatMap","internal::MapOpt"],"I":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Or","internal::MapOpt","internal::AndThen","internal::And","internal::Into","internal::Map","internal::MapRes"],"G":["internal::MapOpt","internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::Or","internal::And","internal::Into"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::Or","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::MapRes","internal::AndThen","internal::Map","internal::MapOpt"],"G":["internal::MapRes","internal::FlatMap","internal::Or","internal::And","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::MapOpt"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","number::Endianness","internal::Needed","error::Error","error::VerboseError","error::ErrorKind","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::MapOpt","internal::Map","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Or","internal::FlatMap","internal::Into","internal::And","<F as internal::Parser<I>>"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::And","internal::Into","std::boxed::Box","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::MapOpt","internal::Map"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Map","internal::MapRes","internal::Or","internal::Into","internal::And","std::boxed::Box"],"G":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::Map","internal::MapRes","internal::And","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Or"],"G":["core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::Into","internal::Or","internal::Map","internal::FlatMap","internal::AndThen","internal::And","internal::MapRes","internal::MapOpt","std::boxed::Box"],"G":["internal::Map","internal::And","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::MapRes"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::cut(p0);
+crate::combinator::cut(p0);
+crate::combinator::cut(p0);
-----------------
src/combinator/mod.rs combinator::into
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"combinator::into":{"E1":["std::marker::Sized","std::convert::Into","error::ParseError"],"E2":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O1":["std::marker::Sized","std::convert::Into"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"combinator::into":{"E2":["error::VerboseError","error::Error"],"F":["internal::MapOpt","internal::Map","internal::And","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::FlatMap"],"I":["RUG_ANY"],"O1":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"],"O2":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Or","internal::MapOpt","internal::Into","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::And","internal::AndThen","std::boxed::Box","internal::FlatMap"],"G":["internal::Into","internal::MapOpt","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::And","internal::Map","std::boxed::Box"]},"internal::AndThen":{"F":["internal::AndThen","internal::MapOpt","internal::And","internal::Map","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::MapRes","std::boxed::Box"],"G":["internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::And","internal::FlatMap","internal::Into","internal::AndThen","internal::MapOpt"]},"internal::Err":{"E":["error::Error","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","error::VerboseErrorKind","error::VerboseError","internal::Err","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["internal::Into","std::boxed::Box","internal::MapRes","internal::Map","internal::And","internal::Or","internal::MapOpt","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::MapRes","internal::Into","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::FlatMap","internal::Or","internal::And"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapOpt","std::boxed::Box","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Map","internal::Or","internal::FlatMap"],"G":["core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::Into","internal::AndThen","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Map","internal::Or","internal::MapOpt"],"G":["std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap"]},"internal::MapRes":{"F":["internal::MapRes","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box"],"G":["core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::FlatMap","internal::Or","std::boxed::Box","internal::MapOpt","internal::Into","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map","internal::MapRes"],"G":["internal::MapOpt","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::AndThen","internal::Or","internal::MapRes","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::into(p0);
+crate::combinator::into(p0);
+crate::combinator::into(p0);
-----------------
src/combinator/mod.rs combinator::iterator
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::iterator":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::iterator":{"Error":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapOpt","internal::Into","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::MapRes"],"Input":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::MapRes","internal::FlatMap","internal::Map","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::And"],"G":["std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::MapRes","internal::And","internal::Map","internal::Into","internal::FlatMap"]},"internal::AndThen":{"F":["std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::And","internal::Or","internal::Into","internal::AndThen","internal::Map"],"G":["internal::MapRes","internal::Or","internal::AndThen","internal::Map","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Into"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::VerboseError","error::ErrorKind","error::Error","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness"]},"internal::FlatMap":{"F":["internal::MapOpt","internal::FlatMap","internal::Map","internal::And","std::boxed::Box","internal::MapRes","internal::AndThen","internal::Or","internal::Into","<F as internal::Parser<I>>"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::And","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::AndThen","internal::MapOpt","internal::MapRes","internal::Map","std::boxed::Box"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapOpt","std::boxed::Box","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Into","internal::Or","internal::AndThen","internal::FlatMap"],"G":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"]},"internal::MapOpt":{"F":["internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapRes","internal::Or","internal::MapOpt","internal::AndThen","internal::And"],"G":["core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::MapOpt","internal::Or","internal::Map","internal::MapRes","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::Or","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box"],"G":["<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::And","internal::Into","std::boxed::Box","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Input
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+combinator::iterator(p0, p1);
+crate::combinator::iterator(p0, p1);
+crate::combinator::iterator(p0, p1);
-----------------
src/combinator/mod.rs combinator::success
deps:{"combinator::success":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O":["std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"combinator::success":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O":["std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","error::VerboseErrorKind","number::Endianness","internal::Err","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::Error","error::VerboseError","error::VerboseErrorKind","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","internal::Err","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // O
+combinator::success(p0);
+crate::combinator::success(p0);
+crate::combinator::success(p0);
-----------------
src/combinator/mod.rs combinator::fail
deps:{"combinator::fail":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"combinator::fail":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["number::Endianness","internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","error::VerboseError","internal::Needed","error::Error","error::VerboseErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+combinator::fail(p0);
+crate::combinator::fail(p0);
+crate::combinator::fail(p0);
-----------------
src/multi/mod.rs multi::many0
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::many0":{"F":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","traits::InputLength","std::clone::Clone"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::MapOpt"],"G":["std::boxed::Box","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Map","internal::Or","internal::And","internal::MapOpt"]},"internal::AndThen":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::MapRes","std::boxed::Box","internal::And","internal::MapOpt","internal::Into","internal::Map"],"G":["internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::FlatMap","internal::Map","internal::Into","internal::MapRes","internal::MapOpt","internal::AndThen"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","error::VerboseError","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind","error::Error"]},"internal::FlatMap":{"F":["internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Map","internal::And"],"G":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::And","internal::AndThen","internal::Map","internal::MapRes","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Map","internal::MapOpt","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapRes"],"G":["core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::IsAsciiWhitespace"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::MapOpt","internal::Into","internal::MapRes"],"G":["core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","internal::MapOpt","internal::Or","internal::And","internal::Into"],"G":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsNotEmpty"]},"internal::Or":{"F":["std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::FlatMap","internal::And","internal::Map","internal::AndThen","internal::Into"],"G":["internal::Map","internal::And","internal::Into","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::MapOpt","std::boxed::Box"]},"multi::many0":{"F":["internal::And","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Or","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapOpt"],"I":["memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::many0(p0);
+crate::multi::many0(p0);
+crate::multi::many0(p0);
-----------------
src/multi/mod.rs multi::many1
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::many1":{"F":["internal::Parser","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","std::clone::Clone"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDefault"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Into","std::boxed::Box","internal::AndThen","internal::MapRes","internal::MapOpt","internal::And","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::Map"],"G":["internal::AndThen","internal::Into","internal::Or","std::boxed::Box","internal::MapOpt","internal::And","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Map"]},"internal::AndThen":{"F":["internal::MapRes","internal::And","internal::Into","internal::Or","internal::Map","internal::FlatMap","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box"],"G":["internal::Or","internal::MapOpt","internal::Into","internal::AndThen","internal::FlatMap","internal::Map","internal::And","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box"]},"internal::Err":{"E":["error::Error","internal::Needed","error::ErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::And","internal::Into","internal::MapRes","internal::Or","internal::Map","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::AndThen"],"G":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::And"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapOpt","internal::MapRes","internal::AndThen","internal::And","internal::Or","internal::FlatMap","internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I>>"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::And"],"G":["core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::Or","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::And"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::FlatMap","internal::AndThen","internal::And","internal::MapOpt"],"G":["internal::MapRes","std::boxed::Box","internal::And","internal::FlatMap","internal::Into","internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::MapOpt"]},"multi::many1":{"F":["internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::And","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box"],"I":["memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::many1(p0);
+crate::multi::many1(p0);
+crate::multi::many1(p0);
-----------------
src/multi/mod.rs multi::many_till
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"multi::many_till":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone","traits::InputLength"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::MapRes","internal::Or","internal::MapOpt","internal::And","internal::Map","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen"],"G":["internal::MapRes","internal::FlatMap","internal::MapOpt","internal::Into","std::boxed::Box","internal::And","internal::AndThen","internal::Map","internal::Or","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::Into","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::Map","internal::AndThen","internal::MapRes","internal::Or"],"G":["internal::And","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::AndThen","internal::MapOpt","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapRes"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","error::VerboseErrorKind","internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","number::Endianness","error::Error"]},"internal::FlatMap":{"F":["internal::And","internal::Map","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::Into"],"G":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::And","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Into","internal::Or","internal::MapRes"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::AndThen","internal::Map","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::MapOpt"],"G":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Into","internal::AndThen","internal::Map"],"G":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::AndThen","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","std::boxed::Box","internal::Map","internal::And","internal::MapRes"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Into","internal::Map","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::And"],"G":["internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Or","internal::MapOpt","std::boxed::Box","internal::Into","internal::And","internal::Map"]},"multi::many_till":{"E":["error::Error","error::VerboseError"],"F":["internal::MapRes","internal::Into","internal::Or","internal::Map","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::And"],"G":["internal::Into","internal::Map","internal::And","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::AndThen"],"I":["memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>","memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+multi::many_till(p0, p1);
+crate::multi::many_till(p0, p1);
+crate::multi::many_till(p0, p1);
-----------------
src/multi/mod.rs multi::separated_list0
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"multi::separated_list0":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","std::clone::Clone"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::AndThen","internal::MapRes","internal::And","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::Into","std::boxed::Box"],"G":["internal::FlatMap","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Map","internal::AndThen","internal::Into","std::boxed::Box"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::AndThen","internal::Or","std::boxed::Box","internal::Into","internal::And","internal::MapRes","internal::MapOpt"],"G":["internal::MapOpt","internal::And","internal::MapRes","internal::Or","internal::AndThen","internal::Map","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","error::VerboseError","error::Error","error::ErrorKind","number::Endianness","error::VerboseErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::Or","internal::Into","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::Map","internal::And"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::MapRes","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Into","internal::Or","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::Map"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::MapOpt","internal::Into","internal::FlatMap","internal::AndThen","internal::Or","internal::And","std::boxed::Box"],"G":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::FlatMap","internal::Or","internal::MapRes","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map"],"G":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::FlatMap","internal::Or","internal::Into","internal::MapRes","internal::MapOpt"],"G":["core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::Into","internal::MapRes","internal::Or","std::boxed::Box","internal::And","internal::MapOpt","internal::FlatMap"],"G":["internal::And","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::FlatMap"]},"multi::separated_list0":{"E":["error::VerboseError","error::Error"],"F":["internal::Or","internal::Into","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::And","internal::MapRes"],"G":["internal::Or","std::boxed::Box","internal::And","internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::MapRes"],"I":["memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // G
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+multi::separated_list0(p0, p1);
+crate::multi::separated_list0(p0, p1);
+crate::multi::separated_list0(p0, p1);
-----------------
src/multi/mod.rs multi::separated_list1
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"multi::separated_list1":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"I":["std::clone::Clone","traits::InputLength","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::Into","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::And","internal::MapRes","internal::AndThen","std::boxed::Box","internal::FlatMap"],"G":["std::boxed::Box","internal::Into","internal::AndThen","internal::Map","internal::MapOpt","internal::MapRes","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::And"]},"internal::AndThen":{"F":["internal::MapRes","internal::Or","std::boxed::Box","internal::And","internal::AndThen","internal::Into","internal::MapOpt","internal::Map","internal::FlatMap","<F as internal::Parser<I>>"],"G":["internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::And","internal::MapOpt","std::boxed::Box","internal::MapRes"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","internal::Err","error::VerboseError","error::Error","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::And","internal::Map","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::FlatMap"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::MapRes","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::AndThen","internal::Or","internal::FlatMap","internal::MapOpt","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapOpt","internal::MapRes","internal::Map","internal::And","internal::AndThen","internal::Or","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapOpt","internal::And","internal::AndThen","std::boxed::Box"],"G":["core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::Into","internal::FlatMap","internal::Map","internal::AndThen","internal::Or","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box"],"G":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::Map","<F as internal::Parser<I>>","internal::Into","internal::AndThen","std::boxed::Box","internal::And","internal::MapRes","internal::Or","internal::MapOpt","internal::FlatMap"],"G":["<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Map","internal::Into","internal::FlatMap","internal::And","internal::MapRes","internal::Or","internal::MapOpt"]},"multi::separated_list1":{"E":["error::VerboseError","error::Error"],"F":["internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::MapRes","std::boxed::Box","internal::AndThen","internal::And","internal::Map","internal::MapOpt"],"G":["std::boxed::Box","internal::Into","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Map","internal::And"],"I":["memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // G
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+multi::separated_list1(p0, p1);
+crate::multi::separated_list1(p0, p1);
+crate::multi::separated_list1(p0, p1);
-----------------
src/multi/mod.rs multi::many_m_n
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::many_m_n":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone","traits::InputLength"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Into","internal::FlatMap","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Map","internal::AndThen","internal::Or"],"G":["internal::AndThen","internal::Into","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::MapRes","internal::And","std::boxed::Box"]},"internal::AndThen":{"F":["internal::MapOpt","internal::AndThen","internal::Into","internal::Or","internal::And","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapRes","std::boxed::Box"],"G":["internal::And","internal::Or","internal::Into","internal::Map","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","error::ErrorKind","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error","number::Endianness","error::VerboseError"]},"internal::FlatMap":{"F":["internal::Into","std::boxed::Box","internal::MapOpt","internal::Map","internal::MapRes","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Or"],"G":["core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["<F as internal::Parser<I>>","internal::Map","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::MapRes","internal::Or","internal::And","internal::Into"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::Or","internal::AndThen","internal::Map","std::boxed::Box","internal::MapRes","internal::FlatMap"],"G":["core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte"]},"internal::MapOpt":{"F":["internal::AndThen","internal::And","std::boxed::Box","internal::Or","internal::Into","internal::MapOpt","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::FlatMap"],"G":["core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["internal::Or","internal::MapOpt","internal::And","internal::FlatMap","internal::Map","internal::Into","internal::MapRes","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>"],"G":["core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::LinesAnyMap"]},"internal::Or":{"F":["std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::Into","internal::Or","internal::AndThen","internal::MapRes","internal::FlatMap"],"G":["internal::FlatMap","internal::Into","internal::AndThen","internal::Or","internal::Map","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::MapOpt"]},"multi::many_m_n":{"E":["error::VerboseError","error::Error"],"F":["internal::Or","internal::MapRes","internal::Into","internal::And","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::Map","internal::MapOpt"],"I":["memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+multi::many_m_n(p0, p1, p2);
+crate::multi::many_m_n(p0, p1, p2);
+crate::multi::many_m_n(p0, p1, p2);
-----------------
src/multi/mod.rs multi::many0_count
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"multi::many0_count":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone","traits::InputLength"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::MapRes","std::boxed::Box","internal::Or","internal::AndThen","internal::FlatMap","internal::Map","internal::And","internal::Into","internal::MapOpt","<F as internal::Parser<I>>"],"G":["internal::Into","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::And","internal::FlatMap","internal::MapOpt"]},"internal::AndThen":{"F":["std::boxed::Box","internal::FlatMap","internal::MapRes","internal::AndThen","internal::Map","internal::And","internal::MapOpt","internal::Or","internal::Into","<F as internal::Parser<I>>"],"G":["internal::MapOpt","internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::AndThen","internal::MapRes","internal::Or"]},"internal::Err":{"E":["internal::Needed","error::Error","error::VerboseError","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::VerboseErrorKind","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::MapOpt","internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::And","internal::Or","internal::AndThen","internal::MapRes"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Map"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::Map","internal::FlatMap","internal::MapOpt","internal::And","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::MapRes","internal::Into","internal::AndThen","internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Or","<F as internal::Parser<I>>"],"G":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::MapOpt","internal::And","internal::AndThen","internal::Into","internal::FlatMap","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Or","std::boxed::Box"],"G":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::Map","<F as internal::Parser<I>>","internal::And","internal::Into","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Or"],"G":["internal::Or","<F as internal::Parser<I>>","internal::And","internal::Map","internal::Into","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::MapRes","std::boxed::Box"]},"multi::many0_count":{"E":["error::Error","error::VerboseError"],"F":["internal::And","<F as internal::Parser<I>>","internal::Into","internal::Or","std::boxed::Box","internal::Map","internal::AndThen","internal::MapRes","internal::FlatMap","internal::MapOpt"],"I":["memchr::memmem::FinderRev<'n>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::cow::Imp<'a>"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::many0_count(p0);
+crate::multi::many0_count(p0);
+crate::multi::many0_count(p0);
-----------------
src/multi/mod.rs multi::many1_count
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"multi::many1_count":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","std::clone::Clone"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::MapRes","internal::FlatMap","internal::Or","internal::And","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapOpt","std::boxed::Box"],"G":["internal::And","internal::MapOpt","std::boxed::Box","internal::Map","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::FlatMap"]},"internal::AndThen":{"F":["internal::MapOpt","internal::Or","internal::AndThen","std::boxed::Box","internal::Into","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Map"],"G":["internal::FlatMap","internal::MapRes","internal::Map","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::Into","internal::And"]},"internal::Err":{"E":["error::VerboseError","number::Endianness","error::ErrorKind","<*mut T as std::fmt::Debug>","internal::Needed","error::Error","error::VerboseErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::And","internal::MapOpt","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::Into","internal::FlatMap","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::Into","internal::And","internal::MapRes","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Into","internal::And","internal::MapOpt","internal::Map","internal::Or","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen"],"G":["core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::Or","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Map","internal::Into","internal::MapOpt"],"G":["std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::AndThen","internal::Map","internal::FlatMap","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::Into","std::boxed::Box","internal::MapOpt"],"G":["core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["internal::MapRes","internal::Or","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::Map"],"G":["internal::MapOpt","internal::Into","internal::Or","internal::MapRes","internal::FlatMap","internal::Map","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen"]},"multi::many1_count":{"E":["error::Error","error::VerboseError"],"F":["internal::MapRes","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Or","internal::Into","internal::FlatMap","internal::MapOpt","std::boxed::Box"],"I":["memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::many1_count(p0);
+crate::multi::many1_count(p0);
+crate::multi::many1_count(p0);
-----------------
src/multi/mod.rs multi::count
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::count":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Map","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Into","internal::FlatMap"],"G":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::Map","internal::MapOpt","internal::And","internal::MapRes","internal::Or"]},"internal::AndThen":{"F":["internal::Or","internal::Into","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::And","internal::FlatMap","std::boxed::Box"],"G":["<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::Or","internal::AndThen","internal::Map","internal::And","internal::Into","internal::MapOpt","std::boxed::Box"]},"internal::Err":{"E":["error::VerboseError","error::Error","number::Endianness","internal::Err","internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::And","internal::Or","std::boxed::Box","internal::MapRes","internal::Into","internal::Map","internal::AndThen","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::Map","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::MapRes","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::Map"],"G":["core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::MapRes","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::Map","std::boxed::Box","internal::And"],"G":["core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["internal::AndThen","internal::Into","internal::And","internal::FlatMap","internal::MapRes","internal::Or","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt"],"G":["core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::Or","internal::Map","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Into","internal::MapRes","internal::FlatMap","internal::And"],"G":["internal::And","internal::Map","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Into"]},"multi::count":{"E":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::Into","internal::MapOpt","std::boxed::Box","internal::Or","internal::MapRes","internal::FlatMap","internal::And"],"I":["number::Endianness","internal::Needed","std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","error::Error","error::VerboseErrorKind","internal::Err"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 0usize; // None+usize
+multi::count(p0, p1);
+crate::multi::count(p0, p1);
+crate::multi::count(p0, p1);
-----------------
src/multi/mod.rs multi::fill
'a
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::fill":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Or","internal::MapRes","internal::Map","internal::MapOpt","internal::Into","internal::And","internal::AndThen"],"G":["std::boxed::Box","internal::Or","internal::And","internal::MapRes","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::Into"]},"internal::AndThen":{"F":["std::boxed::Box","internal::MapOpt","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Map","internal::And"],"G":["internal::Into","internal::Or","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Map","internal::AndThen","std::boxed::Box"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","error::ErrorKind","internal::Err","<*mut T as std::fmt::Debug>","error::Error","error::VerboseError","number::Endianness"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::And","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Or"],"G":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::MapRes","internal::And","std::boxed::Box","internal::Map","internal::Into","internal::Or","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::Or","internal::MapOpt","internal::Map","internal::FlatMap","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"internal::MapOpt":{"F":["internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::AndThen","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::And"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::MapRes","internal::AndThen","internal::Map","std::boxed::Box","internal::Into","internal::And"],"G":["core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::And","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::MapOpt","internal::Or"],"G":["internal::Map","internal::MapOpt","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap"]},"multi::fill":{"E":["error::VerboseError","error::Error"],"F":["internal::And","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::AndThen","internal::MapOpt"],"I":["error::VerboseErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>","error::ErrorKind","error::VerboseError","std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>","internal::Needed","number::Endianness"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // [<F as internal::Parser<I>>::Output]
+multi::fill(p0, p1);
+crate::multi::fill(p0, p1);
+crate::multi::fill(p0, p1);
-----------------
src/multi/mod.rs multi::fold_many0
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"multi::fold_many0":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"],"H":["std::ops::FnMut","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","std::clone::Clone"],"R":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::Map","internal::And","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Or","std::boxed::Box"],"G":["internal::MapOpt","internal::MapRes","internal::And","internal::AndThen","internal::Or","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::Into"]},"internal::AndThen":{"F":["internal::AndThen","std::boxed::Box","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::FlatMap","internal::And","internal::Or"],"G":["internal::Or","internal::AndThen","internal::And","std::boxed::Box","internal::Map","internal::Into","internal::MapRes","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>"]},"internal::Err":{"E":["error::Error","internal::Err","error::ErrorKind","error::VerboseErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","internal::Needed"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::MapOpt","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::Or","internal::Into","internal::AndThen","internal::MapRes"],"G":["core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::MapRes","std::boxed::Box","internal::AndThen","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::Into"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","internal::MapOpt","internal::AndThen","internal::And","internal::Or","internal::MapRes"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::Into","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::And","internal::MapRes","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::AndThen"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::LinesAnyMap"]},"internal::MapRes":{"F":["internal::And","internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::MapOpt","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::And","internal::Map","std::boxed::Box","internal::MapRes","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::FlatMap"],"G":["internal::Or","internal::Map","internal::Into","std::boxed::Box","internal::And","internal::MapRes","internal::FlatMap","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>"]},"multi::fold_many0":{"E":["error::VerboseError","error::Error"],"F":["internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::FlatMap","internal::MapRes","internal::Or","internal::And","std::boxed::Box","internal::MapOpt"],"G":["core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"],"H":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"],"I":["memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder"],"R":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // H
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+multi::fold_many0(p0, p1, p2);
+crate::multi::fold_many0(p0, p1, p2);
+crate::multi::fold_many0(p0, p1, p2);
-----------------
src/multi/mod.rs multi::fold_many1
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"multi::fold_many1":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"],"H":["std::ops::FnMut","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","std::clone::Clone"],"R":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::FlatMap","internal::Map","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::Into","internal::MapOpt","internal::Or"],"G":["internal::Or","internal::And","internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Into","std::boxed::Box"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Or","internal::MapOpt","internal::Into","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Map"],"G":["internal::FlatMap","internal::Map","internal::And","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::AndThen","internal::MapRes","std::boxed::Box","internal::MapOpt"]},"internal::Err":{"E":["number::Endianness","error::Error","error::ErrorKind","error::VerboseErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseError","internal::Needed","internal::Err"]},"internal::FlatMap":{"F":["internal::Or","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Map","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I>>","internal::FlatMap"],"G":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::Into","internal::FlatMap","internal::Or","std::boxed::Box","internal::MapRes","internal::And","internal::Map","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","internal::MapOpt","internal::Or","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::Map"],"G":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::MapRes","internal::Into","internal::Or","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box"],"G":["core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::And","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapRes","std::boxed::Box","internal::Or","internal::MapOpt","internal::AndThen","internal::FlatMap"],"G":["core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::Into","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Map","internal::Or","internal::MapOpt","internal::And"],"G":["internal::AndThen","internal::MapRes","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box","internal::Or"]},"multi::fold_many1":{"E":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapRes","internal::AndThen","internal::MapOpt","internal::And","internal::Into","std::boxed::Box","internal::Or"],"G":["core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"],"H":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue"],"I":["memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>","memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder"],"R":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // H
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+multi::fold_many1(p0, p1, p2);
+crate::multi::fold_many1(p0, p1, p2);
+crate::multi::fold_many1(p0, p1, p2);
-----------------
src/multi/mod.rs multi::fold_many_m_n
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::fold_many_m_n":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"],"H":["std::marker::Sized","std::ops::FnMut"],"I":["traits::InputLength","std::marker::Sized","std::clone::Clone"],"R":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["std::boxed::Box","internal::And","internal::Or","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Map","internal::Into","internal::MapRes","<F as internal::Parser<I>>"],"G":["<F as internal::Parser<I>>","internal::Into","internal::Or","std::boxed::Box","internal::FlatMap","internal::Map","internal::AndThen","internal::MapRes","internal::And","internal::MapOpt"]},"internal::AndThen":{"F":["std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::And","internal::FlatMap","internal::Or","internal::MapRes"],"G":["<F as internal::Parser<I>>","internal::Into","internal::Or","internal::And","std::boxed::Box","internal::MapRes","internal::AndThen","internal::Map","internal::MapOpt","internal::FlatMap"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","number::Endianness","internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::Error","internal::Err","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::And","internal::Map","internal::Or","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapOpt","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Or","std::boxed::Box","internal::MapRes","internal::Map","internal::MapOpt","internal::And","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::MapOpt","internal::MapRes","internal::And","internal::Into","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue"]},"internal::MapOpt":{"F":["internal::AndThen","internal::MapRes","internal::Or","internal::MapOpt","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::And","internal::Map"],"G":["core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["std::boxed::Box","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Or","internal::AndThen","internal::Into","internal::MapRes"],"G":["core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap"]},"internal::Or":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::Into","internal::And","internal::Map","internal::AndThen","internal::FlatMap","std::boxed::Box"],"G":["internal::Or","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::Into","internal::AndThen","internal::Map","internal::And","<F as internal::Parser<I>>","internal::MapRes"]},"multi::fold_many_m_n":{"E":["error::VerboseError","error::Error"],"F":["internal::MapRes","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty"],"H":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"],"I":["memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>"],"R":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
let mut p3 = MaybeUninit::uninit().assume_init(); // H
let mut p4 = MaybeUninit::uninit().assume_init(); // G
+multi::fold_many_m_n(p0, p1, p2, p3, p4);
+crate::multi::fold_many_m_n(p0, p1, p2, p3, p4);
+crate::multi::fold_many_m_n(p0, p1, p2, p3, p4);
-----------------
src/multi/mod.rs multi::length_data
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"multi::length_data":{"<F as internal::Parser<I>>::Output":["traits::ToUsize"],"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::And","internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into"],"G":["internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Map","internal::MapOpt","internal::AndThen","internal::Into","internal::Or","internal::And"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::Or","internal::Into","internal::MapOpt","internal::MapRes","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::Map"],"G":["<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::And","internal::FlatMap","internal::MapOpt","internal::Map","internal::Into","internal::AndThen","std::boxed::Box"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Needed","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","error::ErrorKind","internal::Err","number::Endianness"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::MapOpt","internal::MapRes","internal::Map","internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapRes","std::boxed::Box","internal::Or","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::And"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::AndThen","internal::And","internal::MapOpt","internal::FlatMap","internal::MapRes","std::boxed::Box"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"internal::MapOpt":{"F":["internal::AndThen","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Into","internal::And","internal::Or","internal::Map","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::Or","internal::FlatMap","internal::MapOpt","internal::And","std::boxed::Box"],"G":["core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::Into","internal::MapOpt","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::And","internal::AndThen","std::boxed::Box"],"G":["internal::Map","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapOpt","internal::MapRes"]},"multi::length_data":{"<F as internal::Parser<I>>::Output":[],"E":["error::VerboseError","error::Error"],"F":["internal::MapRes","internal::FlatMap","internal::MapOpt","internal::And","internal::AndThen","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::Into"],"I":[]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::length_data(p0);
+crate::multi::length_data(p0);
+crate::multi::length_data(p0);
-----------------
src/multi/mod.rs multi::length_value
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"multi::length_value":{"<F as internal::Parser<I>>::Output":["traits::ToUsize"],"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone","traits::Input"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::And","internal::FlatMap","internal::Into","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Or"],"G":["internal::MapOpt","internal::Or","internal::Map","std::boxed::Box","internal::MapRes","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I>>","internal::FlatMap"]},"internal::AndThen":{"F":["internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Or","internal::Into","std::boxed::Box","internal::And","internal::Map"],"G":["<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::AndThen","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Into","internal::Map","internal::And"]},"internal::Err":{"E":["internal::Needed","number::Endianness","internal::Err","error::VerboseErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","error::Error"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Into","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::Map","internal::Or","internal::And"],"G":["core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Or","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","internal::MapRes","internal::Map","internal::And","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::FlatMap"],"G":["core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Map","internal::Or","internal::FlatMap","internal::Into","internal::And"],"G":["std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","internal::AndThen","internal::And","internal::MapRes","internal::Or"],"G":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::MapRes","internal::And","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap"],"G":["internal::MapRes","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Map","internal::And"]},"multi::length_value":{"<F as internal::Parser<I>>::Output":[],"E":["error::Error","error::VerboseError"],"F":["internal::Into","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","internal::Map"],"G":["internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Or","internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Into"],"I":["memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder","memchr::cow::Imp<'a>","memchr::memmem::Finder<'n>"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+multi::length_value(p0, p1);
+crate::multi::length_value(p0, p1);
+crate::multi::length_value(p0, p1);
-----------------
src/multi/mod.rs multi::length_count
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::length_count":{"<F as internal::Parser<I>>::Output":["traits::ToUsize"],"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::And","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Into","internal::MapRes"],"G":["internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Or","internal::And","internal::Into","internal::AndThen","internal::Map","<F as internal::Parser<I>>","std::boxed::Box"]},"internal::AndThen":{"F":["internal::Map","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::Or","internal::MapOpt","internal::Into","std::boxed::Box","internal::AndThen"],"G":["internal::Or","internal::MapOpt","internal::And","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box"]},"internal::Err":{"E":["error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::Error","error::VerboseError","internal::Err","error::ErrorKind","number::Endianness","internal::Needed"]},"internal::FlatMap":{"F":["internal::Or","internal::And","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Into"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::FlatMap","internal::Into","internal::Map","internal::And","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","internal::AndThen","internal::MapRes","internal::Map","internal::Into","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I>>"],"G":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::And","internal::Or","internal::Map","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Into","internal::AndThen"],"G":["core::str::IsWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Into","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::Or"],"G":["core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap"]},"internal::Or":{"F":["internal::Map","internal::MapRes","internal::Or","internal::FlatMap","internal::Into","internal::AndThen","internal::And","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>"],"G":["<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::FlatMap","internal::Into","internal::And","internal::MapRes","internal::Or","std::boxed::Box","internal::AndThen"]},"multi::length_count":{"<F as internal::Parser<I>>::Output":[],"E":["error::Error","error::VerboseError"],"F":["internal::And","internal::FlatMap","internal::Or","internal::MapRes","internal::AndThen","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Map"],"G":["internal::MapRes","internal::AndThen","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::And","internal::Map","internal::FlatMap"],"I":["internal::Err","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","number::Endianness","error::ErrorKind","error::Error"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+multi::length_count(p0, p1);
+crate::multi::length_count(p0, p1);
+crate::multi::length_count(p0, p1);
-----------------
src/multi/mod.rs multi::many
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::many":{"Collection":["std::marker::Sized","std::iter::Extend","std::default::Default"],"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["traits::NomRange","std::marker::Sized"],"I":["std::marker::Sized","traits::InputLength","std::clone::Clone"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::Range":{"Idx":["std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"std::ops::RangeInclusive":{"Idx":["std::marker::Sized"]},"std::ops::RangeTo":{"Idx":["std::marker::Sized"]},"std::ops::RangeToInclusive":{"Idx":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::And","internal::MapOpt"],"G":["internal::FlatMap","internal::AndThen","internal::Into","internal::And","std::boxed::Box","internal::Map","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::MapRes"]},"internal::AndThen":{"F":["internal::Or","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::MapRes","internal::And","internal::AndThen","internal::FlatMap"],"G":["std::boxed::Box","internal::Into","internal::AndThen","internal::And","internal::FlatMap","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::Or"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","number::Endianness","internal::Needed","error::ErrorKind","<*mut T as std::fmt::Debug>","internal::Err","error::Error"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::And","internal::AndThen","internal::Map","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::And","internal::MapRes","internal::Or","std::boxed::Box","internal::Map","internal::MapOpt"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::FlatMap","internal::And","internal::Into","internal::Or","internal::Map","internal::MapRes","internal::AndThen","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>"],"G":["core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["internal::Into","internal::FlatMap","internal::MapOpt","internal::And","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Map"],"G":["core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::And","internal::Into","internal::Or","internal::Map","internal::AndThen","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap"],"G":["core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::AndThen","internal::Map","internal::And","internal::Or","internal::MapOpt","internal::FlatMap","internal::Into"],"G":["internal::MapRes","internal::Into","internal::MapOpt","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::AndThen"]},"multi::many":{"Collection":["std::collections::BTreeSet<T, A>","std::collections::BTreeMap<K, V, A>","std::path::PathBuf","std::vec::Vec<T, A>","std::collections::VecDeque<T, A>"],"E":["error::Error","error::VerboseError"],"F":["internal::MapRes","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::Map","internal::MapOpt","internal::AndThen"],"G":["std::ops::RangeFull","std::ops::RangeTo","std::ops::Range","std::ops::RangeFrom","std::ops::RangeInclusive","std::ops::RangeToInclusive"],"I":["memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::Range":{"Idx":["RUG_ANY"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"std::ops::RangeInclusive":{"Idx":["RUG_ANY"]},"std::ops::RangeTo":{"Idx":["RUG_ANY"]},"std::ops::RangeToInclusive":{"Idx":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // G
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+multi::many(p0, p1);
+crate::multi::many(p0, p1);
+crate::multi::many(p0, p1);
-----------------
src/multi/mod.rs multi::fold
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::fold":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"],"H":["std::marker::Sized","std::ops::FnMut"],"I":["std::clone::Clone","traits::InputLength","std::marker::Sized"],"J":["std::marker::Sized","traits::NomRange"],"R":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::Range":{"Idx":["std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"std::ops::RangeInclusive":{"Idx":["std::marker::Sized"]},"std::ops::RangeTo":{"Idx":["std::marker::Sized"]},"std::ops::RangeToInclusive":{"Idx":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::And","internal::MapRes","internal::FlatMap","internal::Map","std::boxed::Box"],"G":["internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::Map","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::Or"]},"internal::AndThen":{"F":["internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::Or","internal::MapRes","internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box"],"G":["internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","internal::And","internal::MapRes"]},"internal::Err":{"E":["error::VerboseErrorKind","error::ErrorKind","<*const T as std::fmt::Debug>","error::VerboseError","internal::Needed","error::Error","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["internal::MapOpt","internal::Into","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Or","internal::And"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Map","internal::MapOpt","internal::AndThen","internal::And","internal::MapRes","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::MapOpt","internal::Map","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Or","internal::Into"],"G":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::Or","internal::Into","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Map","std::boxed::Box"],"G":["core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::Into","internal::And","internal::MapRes","internal::Or","internal::Map","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::FlatMap","internal::Or","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Into","internal::AndThen","internal::Map","internal::And","<F as internal::Parser<I>>"],"G":["internal::MapRes","internal::Into","internal::Map","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::MapOpt"]},"multi::fold":{"E":["error::Error","error::VerboseError"],"F":["internal::And","std::boxed::Box","internal::AndThen","internal::MapRes","internal::FlatMap","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::Or"],"G":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty"],"H":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte"],"I":["memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>"],"J":["std::ops::Range","std::ops::RangeToInclusive","std::ops::RangeFull","std::ops::RangeInclusive","std::ops::RangeTo","std::ops::RangeFrom"],"R":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::Range":{"Idx":["RUG_ANY"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"std::ops::RangeInclusive":{"Idx":["RUG_ANY"]},"std::ops::RangeTo":{"Idx":["RUG_ANY"]},"std::ops::RangeToInclusive":{"Idx":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // J
let mut p1 = MaybeUninit::uninit().assume_init(); // F
let mut p2 = MaybeUninit::uninit().assume_init(); // H
let mut p3 = MaybeUninit::uninit().assume_init(); // G
+multi::fold(p0, p1, p2, p3);
+crate::multi::fold(p0, p1, p2, p3);
+crate::multi::fold(p0, p1, p2, p3);
-----------------
src/sequence/mod.rs sequence::pair
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"sequence::pair":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Into","internal::Or","internal::And"],"G":["internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Or","internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::FlatMap"]},"internal::AndThen":{"F":["std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Map","internal::Or","internal::And","internal::AndThen","internal::MapRes","internal::Into","<F as internal::Parser<I>>"],"G":["internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::MapOpt","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Or"]},"internal::Err":{"E":["error::Error","internal::Err","error::VerboseError","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness","error::VerboseErrorKind","error::ErrorKind","internal::Needed"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::AndThen","internal::Map","internal::Into","internal::MapRes","internal::MapOpt","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::And"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::Map","internal::And","internal::Or","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::AndThen"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::FlatMap","internal::Or","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Into"],"G":["core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode"]},"internal::MapOpt":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::And","std::boxed::Box","internal::MapOpt","internal::Into","internal::AndThen","internal::MapRes"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"internal::MapRes":{"F":["internal::MapRes","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into","internal::Map","internal::MapOpt","internal::Or","internal::And","<F as internal::Parser<I>>"],"G":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap"]},"internal::Or":{"F":["internal::MapRes","std::boxed::Box","internal::Into","internal::Map","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::And"],"G":["internal::Map","internal::FlatMap","internal::And","internal::Or","internal::MapRes","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box"]},"sequence::pair":{"E":["error::VerboseError","error::Error"],"F":["<F as internal::Parser<I>>","internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::MapRes","internal::And"],"G":["internal::MapRes","internal::AndThen","internal::Or","internal::Map","internal::And","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::FlatMap"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+sequence::pair(p0, p1);
+crate::sequence::pair(p0, p1);
+crate::sequence::pair(p0, p1);
-----------------
src/sequence/mod.rs sequence::preceded
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"sequence::preceded":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::Or","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::And","internal::AndThen"],"G":["internal::Map","std::boxed::Box","internal::Into","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::And"]},"internal::AndThen":{"F":["internal::Map","internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::AndThen","internal::MapOpt","internal::MapRes"],"G":["internal::Into","std::boxed::Box","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Or","internal::AndThen","internal::MapOpt"]},"internal::Err":{"E":["number::Endianness","error::Error","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::Or","internal::MapRes","internal::And"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::FlatMap","internal::And","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::MapRes","std::boxed::Box","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","internal::Map","internal::Or","internal::Into","internal::MapRes"],"G":["core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::Or","internal::Map","internal::Into","internal::MapRes","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","internal::MapOpt"],"G":["std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::Map","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::And","internal::AndThen","std::boxed::Box","internal::Or"],"G":["core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>"]},"internal::Or":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::Or","internal::And","internal::MapOpt","internal::MapRes","internal::Map","internal::Into","internal::FlatMap"],"G":["<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Map","internal::And","internal::Into","internal::Or","internal::AndThen","std::boxed::Box"]},"sequence::preceded":{"E":["error::VerboseError","error::Error"],"F":["internal::And","internal::AndThen","internal::Or","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Into"],"G":["internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::Or","internal::AndThen","internal::MapRes","internal::And"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+sequence::preceded(p0, p1);
+crate::sequence::preceded(p0, p1);
+crate::sequence::preceded(p0, p1);
-----------------
src/sequence/mod.rs sequence::terminated
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"sequence::terminated":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::And","std::boxed::Box","internal::Or","internal::AndThen"],"G":["internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Map","internal::MapOpt","std::boxed::Box","internal::MapRes"]},"internal::AndThen":{"F":["internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Into","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::Map"],"G":["internal::MapRes","internal::Into","internal::FlatMap","internal::AndThen","internal::Or","internal::MapOpt","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::And"]},"internal::Err":{"E":["error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","error::Error","internal::Err","error::VerboseError","error::ErrorKind","number::Endianness"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::FlatMap","internal::Or","internal::MapOpt","internal::MapRes","internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::And"],"G":["core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::And","internal::Map","internal::Into","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::MapRes","std::boxed::Box","internal::Or","internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>"]},"internal::MapOpt":{"F":["internal::AndThen","internal::MapRes","internal::Or","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Into","internal::And"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::Or","internal::Map","internal::Into","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::AndThen","internal::FlatMap"],"G":["core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"internal::Or":{"F":["std::boxed::Box","internal::Into","internal::MapOpt","internal::AndThen","internal::Map","internal::Or","internal::FlatMap","internal::MapRes","internal::And","<F as internal::Parser<I>>"],"G":["internal::FlatMap","internal::MapOpt","internal::Into","internal::Or","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Map"]},"sequence::terminated":{"E":["error::Error","error::VerboseError"],"F":["internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::Map","internal::AndThen","internal::Or","internal::And","internal::MapRes"],"G":["internal::MapOpt","internal::Into","internal::AndThen","internal::And","internal::Map","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+sequence::terminated(p0, p1);
+crate::sequence::terminated(p0, p1);
+crate::sequence::terminated(p0, p1);
-----------------
src/sequence/mod.rs sequence::separated_pair
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"sequence::separated_pair":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::MapOpt","internal::Or","internal::MapRes","internal::Map","internal::Into","std::boxed::Box"],"G":["internal::MapOpt","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Map"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapOpt","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map","internal::Into","internal::MapRes"],"G":["internal::Into","internal::MapRes","std::boxed::Box","internal::Map","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::AndThen"]},"internal::Err":{"E":["error::VerboseError","<*const T as std::fmt::Debug>","error::VerboseErrorKind","number::Endianness","internal::Needed","internal::Err","error::ErrorKind","error::Error"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Map","internal::And","std::boxed::Box","internal::AndThen","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::And","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Map","internal::Into","std::boxed::Box","internal::MapOpt"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Map","internal::AndThen","internal::Into","internal::And","std::boxed::Box","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Or"],"G":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::And","internal::Into","internal::MapRes","internal::AndThen","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::FlatMap"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["std::boxed::Box","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::And","internal::Map","internal::AndThen","internal::MapOpt"],"G":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::Or","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::Map"],"G":["internal::Into","internal::MapRes","internal::AndThen","internal::Map","internal::MapOpt","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box"]},"sequence::separated_pair":{"E":["error::VerboseError","error::Error"],"F":["internal::MapRes","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::AndThen","internal::MapOpt","internal::Or","internal::And"],"G":["internal::And","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::Map","internal::Or","internal::MapRes","internal::Into","internal::AndThen"],"H":["std::boxed::Box","internal::Into","internal::Map","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::MapOpt","internal::AndThen"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
let mut p2 = MaybeUninit::uninit().assume_init(); // H
+sequence::separated_pair(p0, p1, p2);
+crate::sequence::separated_pair(p0, p1, p2);
+crate::sequence::separated_pair(p0, p1, p2);
-----------------
src/sequence/mod.rs sequence::delimited
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"sequence::delimited":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::MapRes","internal::Map","internal::And","internal::Into","internal::MapOpt","internal::Or","std::boxed::Box"],"G":["std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::And","internal::FlatMap","internal::MapOpt","internal::Or","internal::AndThen","internal::MapRes"]},"internal::AndThen":{"F":["internal::Or","internal::Map","std::boxed::Box","internal::MapRes","internal::And","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::FlatMap"],"G":["internal::Into","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::Or","internal::MapOpt"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","<*const T as std::fmt::Debug>","error::Error","internal::Err","number::Endianness"]},"internal::FlatMap":{"F":["internal::Map","std::boxed::Box","internal::MapRes","internal::Into","internal::Or","internal::FlatMap","internal::And","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>"],"G":["core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::Map","internal::MapRes","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Map","internal::Into","internal::And","internal::AndThen","internal::FlatMap","internal::MapRes","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte"]},"internal::MapOpt":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::FlatMap","internal::AndThen","internal::Or","std::boxed::Box","internal::Into","internal::And"],"G":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["internal::Or","internal::Into","internal::MapRes","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::And","internal::AndThen"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["internal::Map","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::And","internal::AndThen","std::boxed::Box","internal::MapRes","internal::MapOpt"],"G":["internal::Or","internal::MapOpt","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::MapRes","internal::FlatMap","std::boxed::Box"]},"sequence::delimited":{"E":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::FlatMap","internal::Or","internal::And","internal::MapOpt","internal::MapRes","internal::Map","internal::AndThen"],"G":["internal::Map","internal::AndThen","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::And","internal::MapOpt","internal::Into"],"H":["internal::Map","internal::And","internal::MapOpt","internal::AndThen","internal::Into","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::Or","<F as internal::Parser<I>>"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
let mut p2 = MaybeUninit::uninit().assume_init(); // H
+sequence::delimited(p0, p1, p2);
+crate::sequence::delimited(p0, p1, p2);
+crate::sequence::delimited(p0, p1, p2);
-----------------
src/sequence/mod.rs sequence::tuple
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"sequence::tuple":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"List":["sequence::Tuple","std::marker::Sized"],"O":["std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Err","number::Endianness","error::ErrorKind","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::Error","error::VerboseErrorKind","internal::Needed"]},"sequence::tuple":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"List":[],"O":["RUG_ANY"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // List
+sequence::tuple(p0);
+crate::sequence::tuple(p0);
+crate::sequence::tuple(p0);
-----------------
src/traits.rs traits::lowercase_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+traits::lowercase_byte(p0);
+crate::traits::lowercase_byte(p0);
+crate::traits::lowercase_byte(p0);
-----------------
src/bits/complete.rs bits::complete::take
deps:{"bits::complete::take":{"C":["std::marker::Sized","traits::ToUsize"],"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"],"O":["std::ops::Shl","std::ops::Shr","std::convert::From","std::marker::Sized","std::ops::AddAssign"]},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bits::complete::take":{"C":[],"E":["error::VerboseError","error::Error"],"I":[],"O":["std::ffi::CString","std::simd::Mask<i32, LANES>","std::num::NonZeroI32","std::num::NonZeroU128","std::simd::Mask<i16, LANES>","std::simd::Mask<i64, LANES>","std::simd::Mask<isize, LANES>","std::simd::Mask<i8, LANES>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Err","number::Endianness","error::VerboseErrorKind","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // C
+bits::complete::take(p0);
+crate::bits::complete::take(p0);
+crate::bits::complete::take(p0);
-----------------
src/bits/complete.rs bits::complete::tag
deps:{"bits::complete::tag":{"C":["std::marker::Sized","traits::ToUsize"],"E":["std::marker::Sized","error::ParseError"],"I":["std::clone::Clone","std::marker::Sized","traits::Input"],"O":["std::cmp::PartialEq","std::marker::Sized","std::ops::AddAssign","std::ops::Shl","std::ops::Shr","std::convert::From"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bits::complete::tag":{"C":[],"E":["error::VerboseError","error::Error"],"I":["memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>"],"O":["std::process::Stdio","std::num::NonZeroU128","std::net::Ipv6Addr","std::num::NonZeroI32","std::ffi::CString","std::vec::Vec<T>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::Error","internal::Needed","internal::Err","error::VerboseError","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","number::Endianness","error::VerboseErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // O
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+bits::complete::tag(p0, p1);
+crate::bits::complete::tag(p0, p1);
+crate::bits::complete::tag(p0, p1);
-----------------
src/bits/complete.rs bits::complete::bool
deps:{"<*const T as std::fmt::Debug>":{},"bits::complete::bool":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bits::complete::bool":{"E":["error::VerboseError","error::Error"],"I":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","internal::Needed","error::VerboseErrorKind","error::ErrorKind","error::VerboseError","number::Endianness","error::Error","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (I, usize)
+bits::complete::bool(p0);
+crate::bits::complete::bool(p0);
+crate::bits::complete::bool(p0);
-----------------
src/bits/streaming.rs bits::streaming::take
deps:{"<*mut T as std::fmt::Debug>":{},"bits::streaming::take":{"C":["std::marker::Sized","traits::ToUsize"],"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"],"O":["std::marker::Sized","std::ops::Shl","std::ops::AddAssign","std::ops::Shr","std::convert::From"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"bits::streaming::take":{"C":[],"E":["error::VerboseError","error::Error"],"I":[],"O":["std::simd::Mask<isize, LANES>","std::simd::Mask<i8, LANES>","std::ffi::CString","std::simd::Mask<i16, LANES>","std::num::NonZeroI32","std::simd::Mask<i32, LANES>","std::num::NonZeroU128","std::simd::Mask<i64, LANES>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","error::VerboseError","internal::Needed","internal::Err","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // C
+bits::streaming::take(p0);
+crate::bits::streaming::take(p0);
+crate::bits::streaming::take(p0);
-----------------
src/bits/streaming.rs bits::streaming::tag
deps:{"bits::streaming::tag":{"C":["std::marker::Sized","traits::ToUsize"],"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input","std::clone::Clone"],"O":["std::cmp::PartialEq","std::marker::Sized","std::convert::From","std::ops::Shl","std::ops::Shr","std::ops::AddAssign"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"bits::streaming::tag":{"C":[],"E":["error::Error","error::VerboseError"],"I":["memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>"],"O":["std::num::NonZeroU128","std::vec::Vec<T>","std::net::Ipv6Addr","std::process::Stdio","std::ffi::CString","std::num::NonZeroI32"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::VerboseError","internal::Needed","error::ErrorKind","error::VerboseErrorKind","number::Endianness","error::Error","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // O
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+bits::streaming::tag(p0, p1);
+crate::bits::streaming::tag(p0, p1);
+crate::bits::streaming::tag(p0, p1);
-----------------
src/bits/streaming.rs bits::streaming::bool
deps:{"<*const T as std::fmt::Debug>":{},"bits::streaming::bool":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bits::streaming::bool":{"E":["error::VerboseError","error::Error"],"I":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseError","internal::Err","error::VerboseErrorKind","internal::Needed","<*const T as std::fmt::Debug>","number::Endianness","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (I, usize)
+bits::streaming::bool(p0);
+crate::bits::streaming::bool(p0);
+crate::bits::streaming::bool(p0);
-----------------
src/bits/mod.rs bits::bits
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"bits::bits":{"E1":["error::ParseError","std::marker::Sized","traits::ErrorConvert"],"E2":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"],"O":["std::marker::Sized"],"P":["internal::Parser","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"bits::bits":{"E1":["error::VerboseError","error::Error"],"E2":["error::VerboseError","error::Error"],"I":[],"O":["RUG_ANY"],"P":["internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::FlatMap"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Or","internal::FlatMap","internal::And","internal::MapOpt","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::Map","std::boxed::Box"],"G":["<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Or","internal::And","internal::Into"]},"internal::AndThen":{"F":["internal::Map","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapRes","internal::AndThen","internal::And","internal::FlatMap"],"G":["internal::FlatMap","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::And","internal::MapOpt","internal::Or","internal::AndThen","internal::Into"]},"internal::Err":{"E":["internal::Err","error::VerboseErrorKind","error::VerboseError","<*mut T as std::fmt::Debug>","number::Endianness","internal::Needed","error::Error","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::And","internal::MapOpt","std::boxed::Box","internal::Or","internal::Map","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Into"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::FlatMap","internal::Into","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Map","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Into","internal::Or","std::boxed::Box","internal::Map","internal::MapOpt","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::MapOpt":{"F":["internal::Map","std::boxed::Box","internal::Into","internal::And","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Or"],"G":["core::str::IsWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::MapRes","internal::Or","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into"],"G":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr"]},"internal::Or":{"F":["internal::MapRes","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Into","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Or","std::boxed::Box"],"G":["<F as internal::Parser<I>>","internal::Or","internal::Map","internal::MapRes","internal::FlatMap","internal::And","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // P
+bits::bits(p0);
+crate::bits::bits(p0);
+crate::bits::bits(p0);
-----------------
src/bits/mod.rs bits::bytes
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"bits::bytes":{"E1":["std::marker::Sized","traits::ErrorConvert","error::ParseError"],"E2":["std::marker::Sized","error::ParseError"],"I":["std::clone::Clone","std::marker::Sized","traits::Input"],"O":["std::marker::Sized"],"P":["std::marker::Sized","internal::Parser"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"bits::bytes":{"E1":["error::VerboseError","error::Error"],"E2":["error::VerboseError","error::Error"],"I":["memchr::memmem::FinderBuilder","memchr::cow::Imp<'a>","memchr::memmem::Finder<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderRev<'n>"],"O":["RUG_ANY"],"P":["internal::And","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapOpt","internal::MapRes","internal::Into"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::And","internal::Or","internal::Map","internal::FlatMap","internal::MapRes","internal::Into"],"G":["<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Map","internal::MapRes","internal::Or","internal::MapOpt","std::boxed::Box","internal::And","internal::FlatMap"]},"internal::AndThen":{"F":["std::boxed::Box","internal::FlatMap","internal::And","internal::Map","internal::AndThen","internal::MapRes","internal::Into","internal::MapOpt","internal::Or","<F as internal::Parser<I>>"],"G":["internal::And","internal::MapOpt","internal::Into","std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Or"]},"internal::Err":{"E":["internal::Err","internal::Needed","<*mut T as std::fmt::Debug>","error::ErrorKind","error::VerboseErrorKind","error::VerboseError","error::Error","number::Endianness"]},"internal::FlatMap":{"F":["internal::Or","std::boxed::Box","internal::MapRes","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::Map","internal::And"],"G":["core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::And","internal::Map","std::boxed::Box","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::Into"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::And","internal::MapRes","internal::Or","std::boxed::Box","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::And","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapRes","internal::AndThen","internal::Or","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapRes","std::boxed::Box","internal::Or","internal::Into","internal::MapOpt"],"G":["core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Or","internal::MapOpt","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Map","internal::Into"],"G":["internal::Into","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapRes","internal::Or","std::boxed::Box","internal::And"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // P
+bits::bytes(p0);
+crate::bits::bytes(p0);
+crate::bits::bytes(p0);
-----------------
src/bytes/complete.rs bytes::complete::tag
deps:{"bytes::complete::tag":{"Error":["std::marker::Sized","error::ParseError"],"I":["traits::Input","traits::Compare","std::marker::Sized"],"T":["std::clone::Clone","traits::InputLength","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bytes::complete::tag":{"Error":["error::VerboseError","error::Error"],"T":["memchr::memmem::FinderBuilder","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderRev<'n>","memchr::memmem::Finder<'n>"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","error::Error","number::Endianness","error::VerboseErrorKind","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::tag(p0);
+crate::bytes::complete::tag(p0);
+crate::bytes::complete::tag(p0);
-----------------
src/bytes/complete.rs bytes::complete::tag_no_case
deps:{"<*const T as std::fmt::Debug>":{},"bytes::complete::tag_no_case":{"Error":["std::marker::Sized","error::ParseError"],"I":["traits::Input","traits::Compare","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone","traits::InputLength"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::complete::tag_no_case":{"Error":["error::Error","error::VerboseError"],"T":["memchr::memmem::FinderRev<'n>","memchr::memmem::Finder<'n>","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["number::Endianness","internal::Err","error::VerboseErrorKind","error::ErrorKind","error::Error","internal::Needed","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::tag_no_case(p0);
+crate::bytes::complete::tag_no_case(p0);
+crate::bytes::complete::tag_no_case(p0);
-----------------
src/bytes/complete.rs bytes::complete::is_not
deps:{"<*const T as std::fmt::Debug>":{},"bytes::complete::is_not":{"Error":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::complete::is_not":{"Error":["error::Error","error::VerboseError"],"I":[],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::Error","error::VerboseError","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","internal::Err","number::Endianness","error::ErrorKind"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::is_not(p0);
+crate::bytes::complete::is_not(p0);
+crate::bytes::complete::is_not(p0);
-----------------
src/bytes/complete.rs bytes::complete::is_a
deps:{"bytes::complete::is_a":{"Error":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bytes::complete::is_a":{"Error":["error::VerboseError","error::Error"],"I":[],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","error::VerboseError","error::Error","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::is_a(p0);
+crate::bytes::complete::is_a(p0);
+crate::bytes::complete::is_a(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_while
deps:{"bytes::complete::take_while":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","std::ops::Fn"],"I":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"bytes::complete::take_while":{"Error":["error::VerboseError","error::Error"],"F":["core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"],"I":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","number::Endianness","error::Error","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","error::VerboseErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_while(p0);
+crate::bytes::complete::take_while(p0);
+crate::bytes::complete::take_while(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_while1
deps:{"bytes::complete::take_while1":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","std::ops::Fn"],"I":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"bytes::complete::take_while1":{"Error":["error::VerboseError","error::Error"],"F":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode"],"I":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","error::VerboseErrorKind","error::ErrorKind","number::Endianness","internal::Needed","error::Error","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_while1(p0);
+crate::bytes::complete::take_while1(p0);
+crate::bytes::complete::take_while1(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_while_m_n
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"bytes::complete::take_while_m_n":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::ops::Fn","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"bytes::complete::take_while_m_n":{"Error":["error::VerboseError","error::Error"],"F":["core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"],"I":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Err","error::VerboseErrorKind","internal::Needed","error::ErrorKind","error::Error","number::Endianness","<*mut T as std::fmt::Debug>","error::VerboseError"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_while_m_n(p0, p1, p2);
+crate::bytes::complete::take_while_m_n(p0, p1, p2);
+crate::bytes::complete::take_while_m_n(p0, p1, p2);
-----------------
src/bytes/complete.rs bytes::complete::take_till
deps:{"bytes::complete::take_till":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","std::ops::Fn"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"bytes::complete::take_till":{"Error":["error::Error","error::VerboseError"],"F":["core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap"],"I":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness","internal::Needed","internal::Err","error::VerboseErrorKind","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_till(p0);
+crate::bytes::complete::take_till(p0);
+crate::bytes::complete::take_till(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_till1
deps:{"<*mut T as std::fmt::Debug>":{},"bytes::complete::take_till1":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","std::ops::Fn"],"I":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"bytes::complete::take_till1":{"Error":["error::Error","error::VerboseError"],"F":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeUnicode"],"I":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","error::Error","internal::Needed","error::VerboseErrorKind","<*mut T as std::fmt::Debug>","internal::Err","number::Endianness"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_till1(p0);
+crate::bytes::complete::take_till1(p0);
+crate::bytes::complete::take_till1(p0);
-----------------
src/bytes/complete.rs bytes::complete::take
deps:{"bytes::complete::take":{"C":["traits::ToUsize","std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bytes::complete::take":{"C":[],"Error":["error::Error","error::VerboseError"],"I":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","error::Error","internal::Err","error::VerboseError","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // C
+bytes::complete::take(p0);
+crate::bytes::complete::take(p0);
+crate::bytes::complete::take(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_until
deps:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take_until":{"Error":["std::marker::Sized","error::ParseError"],"I":["traits::Input","traits::FindSubstring","std::marker::Sized"],"T":["std::clone::Clone","std::marker::Sized","traits::InputLength"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take_until":{"Error":["error::VerboseError","error::Error"],"I":[],"T":["memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::Error","error::ErrorKind","number::Endianness","internal::Err","error::VerboseErrorKind","internal::Needed","<*const T as std::fmt::Debug>","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::take_until(p0);
+crate::bytes::complete::take_until(p0);
+crate::bytes::complete::take_until(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_until1
deps:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take_until1":{"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input","traits::FindSubstring"],"T":["std::clone::Clone","std::marker::Sized","traits::InputLength"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take_until1":{"Error":["error::VerboseError","error::Error"],"I":[],"T":["memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","number::Endianness","error::ErrorKind","error::VerboseError","internal::Err","error::VerboseErrorKind","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::take_until1(p0);
+crate::bytes::complete::take_until1(p0);
+crate::bytes::complete::take_until1(p0);
-----------------
src/bytes/complete.rs bytes::complete::escaped
'a
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"bytes::complete::escaped":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","traits::Offset","std::clone::Clone","traits::Input"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"bytes::complete::escaped":{"<I as traits::Input>::Item":[],"Error":["error::Error","error::VerboseError"],"F":["internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Map","internal::Or","internal::And","internal::MapOpt","<F as internal::Parser<I>>"],"G":["<F as internal::Parser<I>>","internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","internal::Into","internal::MapOpt","internal::AndThen","internal::And","internal::MapRes"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::Into"],"G":["std::boxed::Box","internal::FlatMap","internal::Into","internal::Map","internal::And","internal::AndThen","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::MapOpt"]},"internal::AndThen":{"F":["internal::MapRes","std::boxed::Box","internal::Into","internal::And","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::FlatMap"],"G":["internal::Into","internal::Map","internal::And","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Or","internal::FlatMap"]},"internal::Err":{"E":["error::Error","internal::Needed","error::VerboseErrorKind","error::ErrorKind","internal::Err","error::VerboseError","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"internal::FlatMap":{"F":["internal::Into","internal::MapRes","std::boxed::Box","internal::And","internal::Map","internal::Or","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::And","internal::Into","internal::FlatMap","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::MapRes","internal::Or","internal::FlatMap","internal::Into","internal::Map"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty"]},"internal::MapOpt":{"F":["internal::MapRes","internal::Into","std::boxed::Box","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapOpt","internal::Or"],"G":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::Into","internal::And","std::boxed::Box","internal::FlatMap","internal::Or"],"G":["std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::Map","internal::AndThen","internal::And","internal::Into","internal::MapOpt"],"G":["internal::Map","internal::FlatMap","internal::And","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 'a'; // None+char
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+bytes::complete::escaped(p0, p1, p2);
+crate::bytes::complete::escaped(p0, p1, p2);
+crate::bytes::complete::escaped(p0, p1, p2);
-----------------
src/bytes/complete.rs bytes::complete::escaped_transform
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"bytes::complete::escaped_transform":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"ExtendItem":["std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"I":["traits::Offset","std::marker::Sized","std::clone::Clone","traits::ExtendInto","traits::Input"],"O1":["std::marker::Sized","traits::ExtendInto"],"O2":["std::marker::Sized","traits::ExtendInto"],"Output":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"bytes::complete::escaped_transform":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"ExtendItem":["RUG_ANY"],"F":["internal::AndThen","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::FlatMap","internal::MapOpt","internal::And","std::boxed::Box"],"G":["internal::FlatMap","internal::MapRes","std::boxed::Box","internal::Or","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::And"],"O1":[],"O2":[],"Output":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::AndThen","std::boxed::Box","internal::Into","internal::MapRes","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::And"],"G":["<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::Into","internal::Or","internal::MapRes","internal::MapOpt"]},"internal::AndThen":{"F":["internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapOpt","internal::AndThen","internal::Or","internal::Map","internal::MapRes","std::boxed::Box"],"G":["internal::Or","std::boxed::Box","internal::Into","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Map","internal::MapRes","internal::FlatMap"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","error::Error","error::VerboseError","error::ErrorKind","internal::Needed","internal::Err","number::Endianness","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::Map","internal::FlatMap","internal::MapOpt","internal::MapRes","std::boxed::Box"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::MapRes","internal::AndThen","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::MapOpt","internal::Into","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::And","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Or","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Into"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::MapRes","internal::AndThen","internal::And","internal::Map","internal::Or","internal::MapOpt","internal::FlatMap"],"G":["core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::Into","internal::MapRes","internal::AndThen","internal::Map","internal::FlatMap"],"G":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::Into"],"G":["internal::FlatMap","internal::Map","internal::Into","internal::MapRes","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 'a'; // None+char
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+bytes::complete::escaped_transform(p0, p1, p2);
+crate::bytes::complete::escaped_transform(p0, p1, p2);
+crate::bytes::complete::escaped_transform(p0, p1, p2);
-----------------
src/bytes/streaming.rs bytes::streaming::tag
deps:{"bytes::streaming::tag":{"Error":["std::marker::Sized","error::ParseError"],"I":["traits::Compare","traits::Input","std::marker::Sized"],"T":["std::marker::Sized","traits::InputLength","std::clone::Clone"]},"error::Error":{"I":["std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"bytes::streaming::tag":{"Error":["error::VerboseError","error::Error"],"T":["memchr::cow::Imp<'a>","memchr::memmem::Finder<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderRev<'n>","memchr::memmem::FinderBuilder"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["number::Endianness","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseError","error::Error","internal::Err","error::VerboseErrorKind","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::tag(p0);
+crate::bytes::streaming::tag(p0);
+crate::bytes::streaming::tag(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::tag_no_case
deps:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::tag_no_case":{"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Compare","traits::Input"],"T":["traits::InputLength","std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::tag_no_case":{"Error":["error::VerboseError","error::Error"],"T":["memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","<*mut T as std::fmt::Debug>","error::Error","error::VerboseErrorKind","internal::Needed","error::VerboseError","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::tag_no_case(p0);
+crate::bytes::streaming::tag_no_case(p0);
+crate::bytes::streaming::tag_no_case(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::is_not
deps:{"<*const T as std::fmt::Debug>":{},"bytes::streaming::is_not":{"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::streaming::is_not":{"Error":["error::Error","error::VerboseError"],"I":[],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","internal::Err","number::Endianness","error::ErrorKind","error::Error","internal::Needed","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::is_not(p0);
+crate::bytes::streaming::is_not(p0);
+crate::bytes::streaming::is_not(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::is_a
deps:{"bytes::streaming::is_a":{"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"],"T":["traits::FindToken","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"bytes::streaming::is_a":{"Error":["error::VerboseError","error::Error"],"I":[],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","error::VerboseError","error::Error","error::VerboseErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::is_a(p0);
+crate::bytes::streaming::is_a(p0);
+crate::bytes::streaming::is_a(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_while
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take_while":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","std::ops::Fn"],"I":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take_while":{"Error":["error::VerboseError","error::Error"],"F":["core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::LinesAnyMap"],"I":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","error::ErrorKind","error::Error","internal::Err","error::VerboseError","<*const T as std::fmt::Debug>","number::Endianness"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_while(p0);
+crate::bytes::streaming::take_while(p0);
+crate::bytes::streaming::take_while(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_while1
deps:{"bytes::streaming::take_while1":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","std::ops::Fn"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bytes::streaming::take_while1":{"Error":["error::Error","error::VerboseError"],"F":["core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue"],"I":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_while1(p0);
+crate::bytes::streaming::take_while1(p0);
+crate::bytes::streaming::take_while1(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_while_m_n
deps:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take_while_m_n":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","std::ops::Fn"],"I":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take_while_m_n":{"Error":["error::VerboseError","error::Error"],"F":["core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue"],"I":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","internal::Err","error::VerboseErrorKind","internal::Needed","number::Endianness","error::Error","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_while_m_n(p0, p1, p2);
+crate::bytes::streaming::take_while_m_n(p0, p1, p2);
+crate::bytes::streaming::take_while_m_n(p0, p1, p2);
-----------------
src/bytes/streaming.rs bytes::streaming::take_till
deps:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take_till":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","std::ops::Fn"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take_till":{"Error":["error::VerboseError","error::Error"],"F":["core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr"],"I":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::Error","internal::Err","number::Endianness","error::VerboseErrorKind","error::VerboseError","internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_till(p0);
+crate::bytes::streaming::take_till(p0);
+crate::bytes::streaming::take_till(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_till1
deps:{"bytes::streaming::take_till1":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","std::ops::Fn"],"I":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bytes::streaming::take_till1":{"Error":["error::Error","error::VerboseError"],"F":["core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::UnsafeBytesToStr"],"I":[]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Err","internal::Needed","number::Endianness","error::Error","error::ErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_till1(p0);
+crate::bytes::streaming::take_till1(p0);
+crate::bytes::streaming::take_till1(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take
deps:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take":{"C":["std::marker::Sized","traits::ToUsize"],"Error":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take":{"C":[],"Error":["error::Error","error::VerboseError"],"I":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","error::ErrorKind","error::VerboseError","number::Endianness","internal::Err","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // C
+bytes::streaming::take(p0);
+crate::bytes::streaming::take(p0);
+crate::bytes::streaming::take(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_until
deps:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take_until":{"Error":["error::ParseError","std::marker::Sized"],"I":["traits::Input","traits::FindSubstring","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"bytes::streaming::take_until":{"Error":["error::VerboseError","error::Error"],"I":[],"T":["error::VerboseError","internal::Needed","error::ErrorKind","internal::Err","error::Error","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","number::Endianness","error::VerboseErrorKind","internal::Needed","error::Error","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::take_until(p0);
+crate::bytes::streaming::take_until(p0);
+crate::bytes::streaming::take_until(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_until1
deps:{"<*const T as std::fmt::Debug>":{},"bytes::streaming::take_until1":{"Error":["std::marker::Sized","error::ParseError"],"I":["traits::Input","traits::FindSubstring","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::streaming::take_until1":{"Error":["error::VerboseError","error::Error"],"I":[],"T":["internal::Err","internal::Needed","error::ErrorKind","error::Error","error::VerboseErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for &mut T>","number::Endianness"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Err","error::VerboseErrorKind","error::Error","internal::Needed","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseError","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::take_until1(p0);
+crate::bytes::streaming::take_until1(p0);
+crate::bytes::streaming::take_until1(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::escaped
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"bytes::streaming::escaped":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"I":["traits::Offset","traits::Input","std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"bytes::streaming::escaped":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"F":["internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::And","internal::MapOpt","internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen"],"G":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::Or","internal::And","internal::Into","internal::AndThen","internal::Map","internal::MapRes","internal::FlatMap"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::And","internal::FlatMap","internal::MapRes","internal::Map"],"G":["internal::AndThen","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into","internal::Map","internal::FlatMap","internal::And"]},"internal::AndThen":{"F":["internal::FlatMap","internal::And","internal::Into","internal::Map","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::Or"],"G":["internal::MapOpt","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Map","internal::Into","internal::AndThen","internal::And"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","error::VerboseErrorKind","error::ErrorKind","error::Error","internal::Err"]},"internal::FlatMap":{"F":["internal::And","internal::AndThen","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::Or","std::boxed::Box","internal::Map","internal::Into","<F as internal::Parser<I>>"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::Or","internal::Into","internal::AndThen","internal::MapRes","internal::Map","internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::And","internal::MapRes","internal::MapOpt","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty"]},"internal::MapOpt":{"F":["internal::Or","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::And","internal::MapOpt"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["internal::FlatMap","internal::Or","internal::MapOpt","internal::And","internal::MapRes","internal::AndThen","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Map"],"G":["core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::Map","internal::MapRes","internal::FlatMap","internal::Or","internal::Into","internal::AndThen"],"G":["internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::Or","internal::Into","std::boxed::Box","internal::And","internal::MapRes","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 'a'; // None+char
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+bytes::streaming::escaped(p0, p1, p2);
+crate::bytes::streaming::escaped(p0, p1, p2);
+crate::bytes::streaming::escaped(p0, p1, p2);
-----------------
src/bytes/streaming.rs bytes::streaming::escaped_transform
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"bytes::streaming::escaped_transform":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"ExtendItem":["std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["traits::ExtendInto","std::clone::Clone","traits::Input","traits::Offset","std::marker::Sized"],"O1":["traits::ExtendInto","std::marker::Sized"],"O2":["traits::ExtendInto","std::marker::Sized"],"Output":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"bytes::streaming::escaped_transform":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"ExtendItem":["RUG_ANY"],"F":["internal::FlatMap","internal::AndThen","internal::MapRes","internal::And","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt"],"G":["internal::Map","std::boxed::Box","internal::MapRes","internal::Into","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::And"],"O1":[],"O2":[],"Output":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Map","internal::And","internal::MapOpt","internal::Or","internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes"],"G":["std::boxed::Box","internal::MapRes","internal::MapOpt","internal::And","internal::Or","internal::Map","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::AndThen"]},"internal::AndThen":{"F":["internal::Or","internal::MapOpt","internal::AndThen","internal::Map","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes"],"G":["internal::And","internal::FlatMap","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::MapRes","internal::Or","std::boxed::Box"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","number::Endianness","error::Error","error::VerboseError","internal::Needed"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","internal::Map","internal::MapRes","internal::Into","internal::MapOpt"],"G":["core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::AndThen","internal::Into","internal::FlatMap","internal::Map","internal::And"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::Or","internal::And","std::boxed::Box","internal::Map"],"G":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::And","internal::AndThen","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::Or"],"G":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["std::boxed::Box","internal::Map","internal::Or","internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::MapRes"],"G":["core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::FlatMap","internal::MapRes","std::boxed::Box","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::Into","internal::AndThen"],"G":["internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::MapOpt","internal::MapRes"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 'a'; // None+char
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+bytes::streaming::escaped_transform(p0, p1, p2);
+crate::bytes::streaming::escaped_transform(p0, p1, p2);
+crate::bytes::streaming::escaped_transform(p0, p1, p2);
-----------------
src/character/complete.rs character::complete::char
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::char":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::char":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"I":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","internal::Needed","number::Endianness","<*mut T as std::fmt::Debug>","error::Error","internal::Err","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = 'a'; // None+char
+character::complete::char(p0);
+crate::character::complete::char(p0);
+crate::character::complete::char(p0);
-----------------
src/character/complete.rs character::complete::satisfy
deps:{"character::complete::satisfy":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::ops::Fn","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::complete::satisfy":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"F":["core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>"],"I":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","error::VerboseError","internal::Err","error::VerboseErrorKind","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::Error","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+character::complete::satisfy(p0);
+crate::character::complete::satisfy(p0);
+crate::character::complete::satisfy(p0);
-----------------
src/character/complete.rs character::complete::one_of
deps:{"character::complete::one_of":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"character::complete::one_of":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"I":[],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::Error","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","error::ErrorKind","internal::Err","number::Endianness","error::VerboseErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::one_of(p0);
+crate::character::complete::one_of(p0);
+crate::character::complete::one_of(p0);
-----------------
src/character/complete.rs character::complete::none_of
deps:{"character::complete::none_of":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"],"T":["traits::FindToken","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::complete::none_of":{"<I as traits::Input>::Item":[],"Error":["error::Error","error::VerboseError"],"I":[],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","error::ErrorKind","error::Error","internal::Err","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::none_of(p0);
+crate::character::complete::none_of(p0);
+crate::character::complete::none_of(p0);
-----------------
src/character/complete.rs character::complete::crlf
deps:{"character::complete::crlf":{"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input","traits::Compare"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::complete::crlf":{"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","internal::Err","error::VerboseError","error::Error","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::crlf(p0);
+crate::character::complete::crlf(p0);
+crate::character::complete::crlf(p0);
-----------------
src/character/complete.rs character::complete::not_line_ending
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::not_line_ending":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Input","std::marker::Sized","traits::Compare"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::not_line_ending":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","internal::Needed","error::ErrorKind","error::Error","error::VerboseErrorKind","number::Endianness","error::VerboseError","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::not_line_ending(p0);
+crate::character::complete::not_line_ending(p0);
+crate::character::complete::not_line_ending(p0);
-----------------
src/character/complete.rs character::complete::line_ending
deps:{"character::complete::line_ending":{"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputLength","std::marker::Sized","traits::Input","traits::Compare"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::complete::line_ending":{"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseError","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","error::VerboseErrorKind","error::Error","internal::Err","number::Endianness","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::line_ending(p0);
+crate::character::complete::line_ending(p0);
+crate::character::complete::line_ending(p0);
-----------------
src/character/complete.rs character::complete::newline
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::newline":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::newline":{"<I as traits::Input>::Item":[],"Error":["error::Error","error::VerboseError"],"I":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","internal::Needed","internal::Err","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","number::Endianness","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+character::complete::newline(p0);
+crate::character::complete::newline(p0);
+crate::character::complete::newline(p0);
-----------------
src/character/complete.rs character::complete::tab
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::tab":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::tab":{"<I as traits::Input>::Item":[],"Error":["error::Error","error::VerboseError"],"I":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseError","error::VerboseErrorKind","number::Endianness","error::Error","internal::Err","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+character::complete::tab(p0);
+crate::character::complete::tab(p0);
+crate::character::complete::tab(p0);
-----------------
src/character/complete.rs character::complete::anychar
deps:{"character::complete::anychar":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::complete::anychar":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","error::VerboseError","number::Endianness","error::Error","error::VerboseErrorKind","internal::Err","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::anychar(p0);
+crate::character::complete::anychar(p0);
+crate::character::complete::anychar(p0);
-----------------
src/character/complete.rs character::complete::alpha0
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::alpha0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::alpha0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","error::Error","error::VerboseErrorKind","error::VerboseError","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","internal::Err","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::alpha0(p0);
+crate::character::complete::alpha0(p0);
+crate::character::complete::alpha0(p0);
-----------------
src/character/complete.rs character::complete::alpha1
deps:{"character::complete::alpha1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::complete::alpha1":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","internal::Needed","error::VerboseErrorKind","number::Endianness","error::ErrorKind","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::alpha1(p0);
+crate::character::complete::alpha1(p0);
+crate::character::complete::alpha1(p0);
-----------------
src/character/complete.rs character::complete::digit0
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::complete::digit0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::complete::digit0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","error::Error","internal::Err","error::VerboseErrorKind","internal::Needed","error::VerboseError","<*const T as std::fmt::Debug>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::digit0(p0);
+crate::character::complete::digit0(p0);
+crate::character::complete::digit0(p0);
-----------------
src/character/complete.rs character::complete::digit1
deps:{"character::complete::digit1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::complete::digit1":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseError","internal::Err","error::VerboseErrorKind","number::Endianness","error::Error","internal::Needed","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::digit1(p0);
+crate::character::complete::digit1(p0);
+crate::character::complete::digit1(p0);
-----------------
src/character/complete.rs character::complete::hex_digit0
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::hex_digit0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::hex_digit0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::Error","error::VerboseErrorKind","number::Endianness","internal::Needed","error::VerboseError","error::ErrorKind","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::hex_digit0(p0);
+crate::character::complete::hex_digit0(p0);
+crate::character::complete::hex_digit0(p0);
-----------------
src/character/complete.rs character::complete::hex_digit1
deps:{"character::complete::hex_digit1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::complete::hex_digit1":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::Error","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","internal::Needed","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::hex_digit1(p0);
+crate::character::complete::hex_digit1(p0);
+crate::character::complete::hex_digit1(p0);
-----------------
src/character/complete.rs character::complete::oct_digit0
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::oct_digit0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::oct_digit0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Err","error::Error","number::Endianness","internal::Needed","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::oct_digit0(p0);
+crate::character::complete::oct_digit0(p0);
+crate::character::complete::oct_digit0(p0);
-----------------
src/character/complete.rs character::complete::oct_digit1
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::oct_digit1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::oct_digit1":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::Error","internal::Err","number::Endianness","error::VerboseError","<*const T as std::fmt::Debug>","error::VerboseErrorKind","internal::Needed","error::ErrorKind"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::oct_digit1(p0);
+crate::character::complete::oct_digit1(p0);
+crate::character::complete::oct_digit1(p0);
-----------------
src/character/complete.rs character::complete::alphanumeric0
deps:{"character::complete::alphanumeric0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::complete::alphanumeric0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","error::Error","internal::Err","internal::Needed","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::alphanumeric0(p0);
+crate::character::complete::alphanumeric0(p0);
+crate::character::complete::alphanumeric0(p0);
-----------------
src/character/complete.rs character::complete::alphanumeric1
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::alphanumeric1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::alphanumeric1":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","error::Error","<*mut T as std::fmt::Debug>","internal::Needed","number::Endianness","error::VerboseError","error::ErrorKind","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::alphanumeric1(p0);
+crate::character::complete::alphanumeric1(p0);
+crate::character::complete::alphanumeric1(p0);
-----------------
src/character/complete.rs character::complete::space0
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::space0":{"<T as traits::Input>::Item":["traits::AsChar","std::clone::Clone"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::space0":{"<T as traits::Input>::Item":["u8","char"],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::Error","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseErrorKind","internal::Err","internal::Needed","error::ErrorKind","number::Endianness","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::space0(p0);
+crate::character::complete::space0(p0);
+crate::character::complete::space0(p0);
-----------------
src/character/complete.rs character::complete::space1
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::space1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::space1":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness","internal::Needed","error::VerboseErrorKind","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::space1(p0);
+crate::character::complete::space1(p0);
+crate::character::complete::space1(p0);
-----------------
src/character/complete.rs character::complete::multispace0
deps:{"character::complete::multispace0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::complete::multispace0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","error::VerboseError","error::ErrorKind","number::Endianness","error::Error","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::multispace0(p0);
+crate::character::complete::multispace0(p0);
+crate::character::complete::multispace0(p0);
-----------------
src/character/complete.rs character::complete::multispace1
deps:{"character::complete::multispace1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::complete::multispace1":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::VerboseErrorKind","internal::Err","error::ErrorKind","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::multispace1(p0);
+crate::character::complete::multispace1(p0);
+crate::character::complete::multispace1(p0);
-----------------
src/character/complete.rs character::complete::sign
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::sign":{"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Compare","traits::Input","std::clone::Clone"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::sign":{"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::VerboseError","internal::Err","error::ErrorKind","internal::Needed","error::VerboseErrorKind","error::Error","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::sign(p0);
+crate::character::complete::sign(p0);
+crate::character::complete::sign(p0);
-----------------
src/character/complete.rs character::complete::i8
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::i8":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::clone::Clone","std::marker::Sized","traits::Input","traits::Compare"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::i8":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","error::VerboseErrorKind","error::VerboseError","internal::Err","error::Error","number::Endianness","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i8(p0);
+crate::character::complete::i8(p0);
+crate::character::complete::i8(p0);
-----------------
src/character/complete.rs character::complete::i16
deps:{"character::complete::i16":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Compare","std::clone::Clone","std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"character::complete::i16":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::VerboseError","error::Error","error::VerboseErrorKind","error::ErrorKind","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i16(p0);
+crate::character::complete::i16(p0);
+crate::character::complete::i16(p0);
-----------------
src/character/complete.rs character::complete::i32
deps:{"character::complete::i32":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::clone::Clone","std::marker::Sized","traits::Input","traits::Compare"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"character::complete::i32":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Needed","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","error::VerboseError","error::Error","error::VerboseErrorKind","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i32(p0);
+crate::character::complete::i32(p0);
+crate::character::complete::i32(p0);
-----------------
src/character/complete.rs character::complete::i64
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::i64":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input","traits::Compare","std::clone::Clone"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::i64":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::Error","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","internal::Err","internal::Needed","<*const T as std::fmt::Debug>","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i64(p0);
+crate::character::complete::i64(p0);
+crate::character::complete::i64(p0);
-----------------
src/character/complete.rs character::complete::i128
deps:{"character::complete::i128":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized","traits::Compare","std::clone::Clone"]},"error::Error":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"character::complete::i128":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","number::Endianness","error::Error","error::ErrorKind","internal::Needed","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i128(p0);
+crate::character::complete::i128(p0);
+crate::character::complete::i128(p0);
-----------------
src/character/complete.rs character::complete::u8
deps:{"character::complete::u8":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::complete::u8":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","error::VerboseErrorKind","error::VerboseError","error::Error","internal::Needed","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u8(p0);
+crate::character::complete::u8(p0);
+crate::character::complete::u8(p0);
-----------------
src/character/complete.rs character::complete::u16
deps:{"character::complete::u16":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::complete::u16":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","number::Endianness","error::ErrorKind","error::Error","error::VerboseError","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u16(p0);
+crate::character::complete::u16(p0);
+crate::character::complete::u16(p0);
-----------------
src/character/complete.rs character::complete::u32
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::u32":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::u32":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","error::VerboseErrorKind","error::VerboseError","<*mut T as std::fmt::Debug>","error::Error","error::ErrorKind","internal::Err","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u32(p0);
+crate::character::complete::u32(p0);
+crate::character::complete::u32(p0);
-----------------
src/character/complete.rs character::complete::u64
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::u64":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::u64":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Err","<*const T as std::fmt::Debug>","error::Error","error::VerboseErrorKind","number::Endianness","error::ErrorKind","internal::Needed","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u64(p0);
+crate::character::complete::u64(p0);
+crate::character::complete::u64(p0);
-----------------
src/character/complete.rs character::complete::u128
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::u128":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::u128":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","internal::Needed","number::Endianness","error::Error","<*mut T as std::fmt::Debug>","error::VerboseError","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u128(p0);
+crate::character::complete::u128(p0);
+crate::character::complete::u128(p0);
-----------------
src/character/streaming.rs character::streaming::char
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::char":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::char":{"<I as traits::Input>::Item":[],"Error":["error::Error","error::VerboseError"],"I":[]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","internal::Needed","error::Error","number::Endianness"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = 'a'; // None+char
+character::streaming::char(p0);
+crate::character::streaming::char(p0);
+crate::character::streaming::char(p0);
-----------------
src/character/streaming.rs character::streaming::satisfy
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::satisfy":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::ops::Fn","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::satisfy":{"<I as traits::Input>::Item":[],"Error":["error::Error","error::VerboseError"],"F":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::boxed::Box<F, A>"],"I":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","error::Error","error::ErrorKind","number::Endianness","internal::Needed","error::VerboseError"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+character::streaming::satisfy(p0);
+crate::character::streaming::satisfy(p0);
+crate::character::streaming::satisfy(p0);
-----------------
src/character/streaming.rs character::streaming::one_of
deps:{"character::streaming::one_of":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"],"T":["traits::FindToken","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::streaming::one_of":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"I":[],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseErrorKind","error::Error","internal::Needed","error::ErrorKind","error::VerboseError","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::one_of(p0);
+crate::character::streaming::one_of(p0);
+crate::character::streaming::one_of(p0);
-----------------
src/character/streaming.rs character::streaming::none_of
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::none_of":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::none_of":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"I":[],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["number::Endianness","internal::Err","error::VerboseError","error::ErrorKind","error::Error","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseErrorKind"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::none_of(p0);
+crate::character::streaming::none_of(p0);
+crate::character::streaming::none_of(p0);
-----------------
src/character/streaming.rs character::streaming::crlf
deps:{"character::streaming::crlf":{"E":["std::marker::Sized","error::ParseError"],"T":["traits::Compare","traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::streaming::crlf":{"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","error::VerboseErrorKind","error::VerboseError","internal::Err","number::Endianness","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::crlf(p0);
+crate::character::streaming::crlf(p0);
+crate::character::streaming::crlf(p0);
-----------------
src/character/streaming.rs character::streaming::not_line_ending
deps:{"character::streaming::not_line_ending":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input","traits::Compare"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"character::streaming::not_line_ending":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","error::Error","error::VerboseError","number::Endianness","error::ErrorKind","internal::Err","error::VerboseErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::not_line_ending(p0);
+crate::character::streaming::not_line_ending(p0);
+crate::character::streaming::not_line_ending(p0);
-----------------
src/character/streaming.rs character::streaming::line_ending
deps:{"character::streaming::line_ending":{"E":["error::ParseError","std::marker::Sized"],"T":["traits::Input","traits::Compare","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::line_ending":{"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::Error","number::Endianness","error::VerboseErrorKind","error::ErrorKind","internal::Err","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::line_ending(p0);
+crate::character::streaming::line_ending(p0);
+crate::character::streaming::line_ending(p0);
-----------------
src/character/streaming.rs character::streaming::newline
deps:{"character::streaming::newline":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::streaming::newline":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"I":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Err","number::Endianness","error::VerboseError","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseErrorKind","error::Error","internal::Needed","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+character::streaming::newline(p0);
+crate::character::streaming::newline(p0);
+crate::character::streaming::newline(p0);
-----------------
src/character/streaming.rs character::streaming::tab
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::tab":{"<I as traits::Input>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::tab":{"<I as traits::Input>::Item":[],"Error":["error::VerboseError","error::Error"],"I":[]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseError","error::VerboseErrorKind","error::Error","number::Endianness","<*const T as std::fmt::Debug>","internal::Needed","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+character::streaming::tab(p0);
+crate::character::streaming::tab(p0);
+crate::character::streaming::tab(p0);
-----------------
src/character/streaming.rs character::streaming::anychar
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::anychar":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::anychar":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","number::Endianness","error::VerboseError","error::Error","error::VerboseErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::anychar(p0);
+crate::character::streaming::anychar(p0);
+crate::character::streaming::anychar(p0);
-----------------
src/character/streaming.rs character::streaming::alpha0
deps:{"character::streaming::alpha0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::alpha0":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Needed","error::VerboseErrorKind","error::VerboseError","error::Error","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::alpha0(p0);
+crate::character::streaming::alpha0(p0);
+crate::character::streaming::alpha0(p0);
-----------------
src/character/streaming.rs character::streaming::alpha1
deps:{"character::streaming::alpha1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::alpha1":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Err","error::Error","number::Endianness","error::ErrorKind","internal::Needed","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::alpha1(p0);
+crate::character::streaming::alpha1(p0);
+crate::character::streaming::alpha1(p0);
-----------------
src/character/streaming.rs character::streaming::digit0
deps:{"character::streaming::digit0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::digit0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","error::ErrorKind","error::VerboseErrorKind","error::VerboseError","error::Error","internal::Err","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::digit0(p0);
+crate::character::streaming::digit0(p0);
+crate::character::streaming::digit0(p0);
-----------------
src/character/streaming.rs character::streaming::digit1
deps:{"character::streaming::digit1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::digit1":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Needed","error::Error","error::VerboseError","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::digit1(p0);
+crate::character::streaming::digit1(p0);
+crate::character::streaming::digit1(p0);
-----------------
src/character/streaming.rs character::streaming::hex_digit0
deps:{"character::streaming::hex_digit0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::streaming::hex_digit0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","internal::Needed","error::ErrorKind","error::Error","error::VerboseError","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::hex_digit0(p0);
+crate::character::streaming::hex_digit0(p0);
+crate::character::streaming::hex_digit0(p0);
-----------------
src/character/streaming.rs character::streaming::hex_digit1
deps:{"<*mut T as std::fmt::Debug>":{},"character::streaming::hex_digit1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::streaming::hex_digit1":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","number::Endianness","error::VerboseErrorKind","internal::Err","error::ErrorKind","internal::Needed","error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::hex_digit1(p0);
+crate::character::streaming::hex_digit1(p0);
+crate::character::streaming::hex_digit1(p0);
-----------------
src/character/streaming.rs character::streaming::oct_digit0
deps:{"character::streaming::oct_digit0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::oct_digit0":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","error::Error","error::ErrorKind","internal::Err","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::oct_digit0(p0);
+crate::character::streaming::oct_digit0(p0);
+crate::character::streaming::oct_digit0(p0);
-----------------
src/character/streaming.rs character::streaming::oct_digit1
deps:{"character::streaming::oct_digit1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::oct_digit1":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::Error","error::VerboseError","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","internal::Err","number::Endianness","error::VerboseErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::oct_digit1(p0);
+crate::character::streaming::oct_digit1(p0);
+crate::character::streaming::oct_digit1(p0);
-----------------
src/character/streaming.rs character::streaming::alphanumeric0
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::alphanumeric0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::alphanumeric0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::ErrorKind","<*const T as std::fmt::Debug>","error::VerboseError","internal::Err","error::Error","internal::Needed","error::VerboseErrorKind","number::Endianness"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::alphanumeric0(p0);
+crate::character::streaming::alphanumeric0(p0);
+crate::character::streaming::alphanumeric0(p0);
-----------------
src/character/streaming.rs character::streaming::alphanumeric1
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::alphanumeric1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::alphanumeric1":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","error::VerboseError","error::ErrorKind","number::Endianness","<*const T as std::fmt::Debug>","internal::Needed","error::Error","error::VerboseErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::alphanumeric1(p0);
+crate::character::streaming::alphanumeric1(p0);
+crate::character::streaming::alphanumeric1(p0);
-----------------
src/character/streaming.rs character::streaming::space0
deps:{"character::streaming::space0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::space0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::Error","error::VerboseErrorKind","number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseError","internal::Err","error::ErrorKind","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::space0(p0);
+crate::character::streaming::space0(p0);
+crate::character::streaming::space0(p0);
-----------------
src/character/streaming.rs character::streaming::space1
deps:{"<*mut T as std::fmt::Debug>":{},"character::streaming::space1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::streaming::space1":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::Error","internal::Err","error::ErrorKind","error::VerboseError","number::Endianness","internal::Needed","error::VerboseErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::space1(p0);
+crate::character::streaming::space1(p0);
+crate::character::streaming::space1(p0);
-----------------
src/character/streaming.rs character::streaming::multispace0
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::multispace0":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::multispace0":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","error::Error","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","error::VerboseErrorKind","internal::Err"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::multispace0(p0);
+crate::character::streaming::multispace0(p0);
+crate::character::streaming::multispace0(p0);
-----------------
src/character/streaming.rs character::streaming::multispace1
deps:{"character::streaming::multispace1":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::multispace1":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::Error","error::VerboseErrorKind","internal::Err","error::ErrorKind","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::multispace1(p0);
+crate::character::streaming::multispace1(p0);
+crate::character::streaming::multispace1(p0);
-----------------
src/character/streaming.rs character::streaming::sign
deps:{"<*mut T as std::fmt::Debug>":{},"character::streaming::sign":{"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Compare","std::clone::Clone","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::streaming::sign":{"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","<*mut T as std::fmt::Debug>","error::VerboseError","error::VerboseErrorKind","number::Endianness","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::sign(p0);
+crate::character::streaming::sign(p0);
+crate::character::streaming::sign(p0);
-----------------
src/character/streaming.rs character::streaming::i8
deps:{"character::streaming::i8":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","std::clone::Clone","traits::Compare","traits::Input"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::streaming::i8":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::Error","number::Endianness","internal::Err","error::ErrorKind","error::VerboseError","internal::Needed","error::VerboseErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i8(p0);
+crate::character::streaming::i8(p0);
+crate::character::streaming::i8(p0);
-----------------
src/character/streaming.rs character::streaming::i16
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::i16":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::clone::Clone","traits::Input","std::marker::Sized","traits::Compare"]},"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::i16":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseError","internal::Needed","internal::Err","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","error::VerboseErrorKind","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i16(p0);
+crate::character::streaming::i16(p0);
+crate::character::streaming::i16(p0);
-----------------
src/character/streaming.rs character::streaming::i32
deps:{"character::streaming::i32":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::clone::Clone","std::marker::Sized","traits::Compare","traits::Input"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::i32":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseErrorKind","error::Error","error::VerboseError","internal::Needed","error::ErrorKind","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i32(p0);
+crate::character::streaming::i32(p0);
+crate::character::streaming::i32(p0);
-----------------
src/character/streaming.rs character::streaming::i64
deps:{"<*mut T as std::fmt::Debug>":{},"character::streaming::i64":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","traits::Compare","std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::streaming::i64":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseError","error::Error","<*mut T as std::fmt::Debug>","internal::Needed","internal::Err","number::Endianness","error::VerboseErrorKind","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i64(p0);
+crate::character::streaming::i64(p0);
+crate::character::streaming::i64(p0);
-----------------
src/character/streaming.rs character::streaming::i128
deps:{"character::streaming::i128":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Compare","std::clone::Clone","traits::Input"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::i128":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","internal::Err","number::Endianness","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i128(p0);
+crate::character::streaming::i128(p0);
+crate::character::streaming::i128(p0);
-----------------
src/character/streaming.rs character::streaming::u8
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::u8":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::u8":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","<*const T as std::fmt::Debug>","error::VerboseError","internal::Err","internal::Needed","number::Endianness","error::VerboseErrorKind","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u8(p0);
+crate::character::streaming::u8(p0);
+crate::character::streaming::u8(p0);
-----------------
src/character/streaming.rs character::streaming::u16
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::streaming::u16":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::streaming::u16":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::Error","internal::Needed","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","number::Endianness","<*mut T as std::fmt::Debug>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u16(p0);
+crate::character::streaming::u16(p0);
+crate::character::streaming::u16(p0);
-----------------
src/character/streaming.rs character::streaming::u32
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::u32":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::u32":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","error::VerboseErrorKind","number::Endianness","error::Error","internal::Needed","internal::Err","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u32(p0);
+crate::character::streaming::u32(p0);
+crate::character::streaming::u32(p0);
-----------------
src/character/streaming.rs character::streaming::u64
deps:{"character::streaming::u64":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Input","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::u64":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Err","number::Endianness","error::VerboseError","internal::Needed","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::Error","error::VerboseErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u64(p0);
+crate::character::streaming::u64(p0);
+crate::character::streaming::u64(p0);
-----------------
src/character/streaming.rs character::streaming::u128
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::streaming::u128":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Input"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::streaming::u128":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","internal::Err","error::VerboseErrorKind","error::ErrorKind","number::Endianness","error::Error","error::VerboseError","internal::Needed"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u128(p0);
+crate::character::streaming::u128(p0);
+crate::character::streaming::u128(p0);
-----------------
src/character/mod.rs character::is_alphabetic
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_alphabetic(p0);
+crate::character::is_alphabetic(p0);
+crate::character::is_alphabetic(p0);
-----------------
src/character/mod.rs character::is_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_digit(p0);
+crate::character::is_digit(p0);
+crate::character::is_digit(p0);
-----------------
src/character/mod.rs character::is_hex_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_hex_digit(p0);
+crate::character::is_hex_digit(p0);
+crate::character::is_hex_digit(p0);
-----------------
src/character/mod.rs character::is_oct_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_oct_digit(p0);
+crate::character::is_oct_digit(p0);
+crate::character::is_oct_digit(p0);
-----------------
src/character/mod.rs character::is_alphanumeric
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_alphanumeric(p0);
+crate::character::is_alphanumeric(p0);
+crate::character::is_alphanumeric(p0);
-----------------
src/character/mod.rs character::is_space
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_space(p0);
+crate::character::is_space(p0);
+crate::character::is_space(p0);
-----------------
src/character/mod.rs character::is_newline
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_newline(p0);
+crate::character::is_newline(p0);
+crate::character::is_newline(p0);
-----------------
src/number/complete.rs number::complete::be_u8
deps:{"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"number::complete::be_u8":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","number::Endianness","error::VerboseErrorKind","error::Error","internal::Needed","error::ErrorKind"]},"number::complete::be_u8":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u8(p0);
+crate::number::complete::be_u8(p0);
+crate::number::complete::be_u8(p0);
-----------------
src/number/complete.rs number::complete::be_u16
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"number::complete::be_u16":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","error::Error","error::VerboseError","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","error::ErrorKind"]},"number::complete::be_u16":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u16(p0);
+crate::number::complete::be_u16(p0);
+crate::number::complete::be_u16(p0);
-----------------
src/number/complete.rs number::complete::be_u24
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"number::complete::be_u24":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseErrorKind","error::ErrorKind","error::Error","error::VerboseError","<*const T as std::fmt::Debug>","internal::Err","number::Endianness","internal::Needed"]},"number::complete::be_u24":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u24(p0);
+crate::number::complete::be_u24(p0);
+crate::number::complete::be_u24(p0);
-----------------
src/number/complete.rs number::complete::be_u32
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::complete::be_u32":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","internal::Err","number::Endianness","error::Error","error::VerboseErrorKind","error::ErrorKind","error::VerboseError"]},"number::complete::be_u32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u32(p0);
+crate::number::complete::be_u32(p0);
+crate::number::complete::be_u32(p0);
-----------------
src/number/complete.rs number::complete::be_u64
deps:{"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"number::complete::be_u64":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","error::Error","error::VerboseError","error::VerboseErrorKind","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err"]},"number::complete::be_u64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u64(p0);
+crate::number::complete::be_u64(p0);
+crate::number::complete::be_u64(p0);
-----------------
src/number/complete.rs number::complete::be_u128
deps:{"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"number::complete::be_u128":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","number::Endianness","error::VerboseErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","internal::Needed","error::Error"]},"number::complete::be_u128":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u128(p0);
+crate::number::complete::be_u128(p0);
+crate::number::complete::be_u128(p0);
-----------------
src/number/complete.rs number::complete::be_uint
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::complete::be_uint":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"],"Uint":["std::convert::From","std::default::Default","std::ops::Shl","std::marker::Sized","std::ops::Add"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","number::Endianness","error::VerboseErrorKind","internal::Err","error::ErrorKind","error::VerboseError","error::Error"]},"number::complete::be_uint":{"E":["error::Error","error::VerboseError"],"I":[],"Uint":["std::simd::Mask<i32, LANES>","std::num::Wrapping<i16>","std::num::Wrapping<usize>","std::num::Wrapping<u32>","std::num::Wrapping<isize>","std::num::Wrapping<u8>","std::num::Wrapping<u64>","std::num::Saturating<u32>","std::boxed::Box<[T]>","std::num::Saturating<isize>","std::num::Wrapping<i32>","std::simd::Mask<isize, LANES>","std::num::Saturating<u128>","std::num::Wrapping<i128>","std::simd::Mask<i8, LANES>","std::simd::Mask<i16, LANES>","std::num::Saturating<u16>","std::num::Saturating<u8>","std::num::Wrapping<i8>","std::boxed::Box<std::ffi::OsStr>","std::num::Saturating<i128>","std::num::Saturating<i8>","std::num::NonZeroU128","std::boxed::Box<str>","std::num::Wrapping<u16>","std::boxed::Box<std::ffi::CStr>","std::simd::Mask<i64, LANES>","std::num::Saturating<i16>","std::num::Wrapping<u128>","std::num::Saturating<usize>","std::num::NonZeroI32","std::num::Saturating<u64>","std::num::Wrapping<i64>","std::num::Saturating<i64>","std::num::Saturating<i32>"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = 0usize; // None+usize
+number::complete::be_uint(p0, p1);
+crate::number::complete::be_uint(p0, p1);
+crate::number::complete::be_uint(p0, p1);
-----------------
src/number/complete.rs number::complete::be_i8
deps:{"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"number::complete::be_i8":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Needed","error::VerboseErrorKind","error::Error","error::VerboseError","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err"]},"number::complete::be_i8":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i8(p0);
+crate::number::complete::be_i8(p0);
+crate::number::complete::be_i8(p0);
-----------------
src/number/complete.rs number::complete::be_i16
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"number::complete::be_i16":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Err","error::VerboseError","error::ErrorKind","number::Endianness","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::Error","error::VerboseErrorKind"]},"number::complete::be_i16":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i16(p0);
+crate::number::complete::be_i16(p0);
+crate::number::complete::be_i16(p0);
-----------------
src/number/complete.rs number::complete::be_i24
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"number::complete::be_i24":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseError","error::Error","<*const T as std::fmt::Debug>","error::VerboseErrorKind","internal::Needed","number::Endianness","error::ErrorKind","internal::Err"]},"number::complete::be_i24":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i24(p0);
+crate::number::complete::be_i24(p0);
+crate::number::complete::be_i24(p0);
-----------------
src/number/complete.rs number::complete::be_i32
deps:{"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"number::complete::be_i32":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","number::Endianness","error::ErrorKind","error::VerboseErrorKind","internal::Needed"]},"number::complete::be_i32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i32(p0);
+crate::number::complete::be_i32(p0);
+crate::number::complete::be_i32(p0);
-----------------
src/number/complete.rs number::complete::be_i64
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::be_i64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","internal::Needed","internal::Err","error::Error","error::ErrorKind","error::VerboseError"]},"number::complete::be_i64":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i64(p0);
+crate::number::complete::be_i64(p0);
+crate::number::complete::be_i64(p0);
-----------------
src/number/complete.rs number::complete::be_i128
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"number::complete::be_i128":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","<*const T as std::fmt::Debug>","error::ErrorKind","error::Error","internal::Err","error::VerboseError","internal::Needed"]},"number::complete::be_i128":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i128(p0);
+crate::number::complete::be_i128(p0);
+crate::number::complete::be_i128(p0);
-----------------
src/number/complete.rs number::complete::le_u8
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"number::complete::le_u8":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::VerboseError","error::Error","error::ErrorKind","internal::Needed","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err"]},"number::complete::le_u8":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u8(p0);
+crate::number::complete::le_u8(p0);
+crate::number::complete::le_u8(p0);
-----------------
src/number/complete.rs number::complete::le_u16
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"number::complete::le_u16":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::ErrorKind","internal::Needed","error::Error","number::Endianness"]},"number::complete::le_u16":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u16(p0);
+crate::number::complete::le_u16(p0);
+crate::number::complete::le_u16(p0);
-----------------
src/number/complete.rs number::complete::le_u24
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"number::complete::le_u24":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseError","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::Error","error::VerboseErrorKind","internal::Err","internal::Needed","number::Endianness"]},"number::complete::le_u24":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u24(p0);
+crate::number::complete::le_u24(p0);
+crate::number::complete::le_u24(p0);
-----------------
src/number/complete.rs number::complete::le_u32
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"number::complete::le_u32":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","internal::Err","internal::Needed","number::Endianness","error::Error"]},"number::complete::le_u32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u32(p0);
+crate::number::complete::le_u32(p0);
+crate::number::complete::le_u32(p0);
-----------------
src/number/complete.rs number::complete::le_u64
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"number::complete::le_u64":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseErrorKind","error::ErrorKind","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","number::Endianness","error::VerboseError","error::Error"]},"number::complete::le_u64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u64(p0);
+crate::number::complete::le_u64(p0);
+crate::number::complete::le_u64(p0);
-----------------
src/number/complete.rs number::complete::le_u128
deps:{"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"number::complete::le_u128":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","number::Endianness","internal::Needed","internal::Err","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error"]},"number::complete::le_u128":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u128(p0);
+crate::number::complete::le_u128(p0);
+crate::number::complete::le_u128(p0);
-----------------
src/number/complete.rs number::complete::le_uint
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"number::complete::le_uint":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"],"Uint":["std::ops::Add","std::marker::Sized","std::default::Default","std::ops::Shl","std::convert::From"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseError","error::VerboseErrorKind","error::Error","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::ErrorKind","internal::Err"]},"number::complete::le_uint":{"E":["error::VerboseError","error::Error"],"I":[],"Uint":["std::num::Wrapping<u128>","std::num::Wrapping<i32>","std::boxed::Box<str>","std::num::Saturating<i8>","std::num::Saturating<u16>","std::simd::Mask<i32, LANES>","std::num::Wrapping<u16>","std::boxed::Box<std::ffi::CStr>","std::num::Saturating<u32>","std::num::Wrapping<isize>","std::boxed::Box<std::ffi::OsStr>","std::simd::Mask<i64, LANES>","std::simd::Mask<isize, LANES>","std::num::Wrapping<usize>","std::num::Saturating<u8>","std::num::Saturating<usize>","std::num::Wrapping<u8>","std::num::Wrapping<i8>","std::num::Saturating<u128>","std::num::Saturating<isize>","std::num::Saturating<i16>","std::simd::Mask<i16, LANES>","std::num::Saturating<u64>","std::num::Saturating<i64>","std::simd::Mask<i8, LANES>","std::num::Saturating<i32>","std::num::Wrapping<i16>","std::num::NonZeroI32","std::num::Saturating<i128>","std::boxed::Box<[T]>","std::num::Wrapping<i128>","std::num::Wrapping<u32>","std::num::NonZeroU128","std::num::Wrapping<u64>","std::num::Wrapping<i64>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = 0usize; // None+usize
+number::complete::le_uint(p0, p1);
+crate::number::complete::le_uint(p0, p1);
+crate::number::complete::le_uint(p0, p1);
-----------------
src/number/complete.rs number::complete::le_i8
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"number::complete::le_i8":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","error::VerboseErrorKind","internal::Err","error::ErrorKind","error::Error","internal::Needed"]},"number::complete::le_i8":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i8(p0);
+crate::number::complete::le_i8(p0);
+crate::number::complete::le_i8(p0);
-----------------
src/number/complete.rs number::complete::le_i16
deps:{"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"number::complete::le_i16":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::Error","number::Endianness","error::VerboseError","error::ErrorKind","internal::Needed","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"number::complete::le_i16":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i16(p0);
+crate::number::complete::le_i16(p0);
+crate::number::complete::le_i16(p0);
-----------------
src/number/complete.rs number::complete::le_i24
deps:{"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"number::complete::le_i24":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::Error","internal::Needed","error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","internal::Err","error::VerboseError"]},"number::complete::le_i24":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i24(p0);
+crate::number::complete::le_i24(p0);
+crate::number::complete::le_i24(p0);
-----------------
src/number/complete.rs number::complete::le_i32
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"number::complete::le_i32":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","<*mut T as std::fmt::Debug>","internal::Needed","error::VerboseErrorKind","error::VerboseError","internal::Err","number::Endianness","error::Error"]},"number::complete::le_i32":{"E":["error::Error","error::VerboseError"],"I":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i32(p0);
+crate::number::complete::le_i32(p0);
+crate::number::complete::le_i32(p0);
-----------------
src/number/complete.rs number::complete::le_i64
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"number::complete::le_i64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","number::Endianness","internal::Needed","error::ErrorKind","internal::Err","error::Error","error::VerboseErrorKind","error::VerboseError"]},"number::complete::le_i64":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i64(p0);
+crate::number::complete::le_i64(p0);
+crate::number::complete::le_i64(p0);
-----------------
src/number/complete.rs number::complete::le_i128
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::le_i128":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::VerboseErrorKind","<*mut T as std::fmt::Debug>","internal::Err","internal::Needed","error::Error","error::ErrorKind","error::VerboseError"]},"number::complete::le_i128":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i128(p0);
+crate::number::complete::le_i128(p0);
+crate::number::complete::le_i128(p0);
-----------------
src/number/complete.rs number::complete::u8
deps:{"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"number::complete::u8":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","internal::Err","error::ErrorKind","number::Endianness","error::VerboseError","internal::Needed","error::Error"]},"number::complete::u8":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::u8(p0);
+crate::number::complete::u8(p0);
+crate::number::complete::u8(p0);
-----------------
src/number/complete.rs number::complete::u16
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"number::complete::u16":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::Error","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseError","internal::Err","number::Endianness","error::VerboseErrorKind","internal::Needed","error::ErrorKind"]},"number::complete::u16":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u16(p0);
+crate::number::complete::u16(p0);
+crate::number::complete::u16(p0);
-----------------
src/number/complete.rs number::complete::u24
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"number::complete::u24":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Needed","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error","number::Endianness","error::ErrorKind","internal::Err"]},"number::complete::u24":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u24(p0);
+crate::number::complete::u24(p0);
+crate::number::complete::u24(p0);
-----------------
src/number/complete.rs number::complete::u32
deps:{"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::u32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Err","error::Error","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","error::ErrorKind","number::Endianness"]},"number::complete::u32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u32(p0);
+crate::number::complete::u32(p0);
+crate::number::complete::u32(p0);
-----------------
src/number/complete.rs number::complete::u64
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::complete::u64":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","error::VerboseError","internal::Err","error::Error","number::Endianness","error::ErrorKind","<*const T as std::fmt::Debug>"]},"number::complete::u64":{"E":["error::Error","error::VerboseError"],"I":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u64(p0);
+crate::number::complete::u64(p0);
+crate::number::complete::u64(p0);
-----------------
src/number/complete.rs number::complete::u128
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"number::complete::u128":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["internal::Err","error::VerboseError","error::Error","error::ErrorKind","internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","error::VerboseErrorKind"]},"number::complete::u128":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u128(p0);
+crate::number::complete::u128(p0);
+crate::number::complete::u128(p0);
-----------------
src/number/complete.rs number::complete::i8
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"number::complete::i8":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","<*mut T as std::fmt::Debug>","internal::Err","error::VerboseError","error::Error","number::Endianness","error::VerboseErrorKind","error::ErrorKind"]},"number::complete::i8":{"E":["error::Error","error::VerboseError"],"I":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::i8(p0);
+crate::number::complete::i8(p0);
+crate::number::complete::i8(p0);
-----------------
src/number/complete.rs number::complete::i16
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"number::complete::i16":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Err","error::Error","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","number::Endianness","error::VerboseErrorKind","error::VerboseError","error::ErrorKind"]},"number::complete::i16":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i16(p0);
+crate::number::complete::i16(p0);
+crate::number::complete::i16(p0);
-----------------
src/number/complete.rs number::complete::i24
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::i24":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error","internal::Err","error::VerboseError","internal::Needed","number::Endianness"]},"number::complete::i24":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i24(p0);
+crate::number::complete::i24(p0);
+crate::number::complete::i24(p0);
-----------------
src/number/complete.rs number::complete::i32
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"number::complete::i32":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::VerboseErrorKind","error::Error"]},"number::complete::i32":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i32(p0);
+crate::number::complete::i32(p0);
+crate::number::complete::i32(p0);
-----------------
src/number/complete.rs number::complete::i64
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"number::complete::i64":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","<*mut T as std::fmt::Debug>","error::VerboseError","error::VerboseErrorKind","internal::Needed","internal::Err","number::Endianness","error::Error"]},"number::complete::i64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i64(p0);
+crate::number::complete::i64(p0);
+crate::number::complete::i64(p0);
-----------------
src/number/complete.rs number::complete::i128
deps:{"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"number::complete::i128":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","error::Error","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","internal::Err","number::Endianness"]},"number::complete::i128":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i128(p0);
+crate::number::complete::i128(p0);
+crate::number::complete::i128(p0);
-----------------
src/number/complete.rs number::complete::be_f32
deps:{"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"number::complete::be_f32":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness","error::ErrorKind","error::VerboseError","internal::Err","error::Error","error::VerboseErrorKind","internal::Needed"]},"number::complete::be_f32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_f32(p0);
+crate::number::complete::be_f32(p0);
+crate::number::complete::be_f32(p0);
-----------------
src/number/complete.rs number::complete::be_f64
deps:{"error::Error":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::complete::be_f64":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::Error","error::VerboseErrorKind","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind","error::VerboseError","number::Endianness","internal::Needed"]},"number::complete::be_f64":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_f64(p0);
+crate::number::complete::be_f64(p0);
+crate::number::complete::be_f64(p0);
-----------------
src/number/complete.rs number::complete::le_f32
deps:{"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"number::complete::le_f32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Needed","number::Endianness","internal::Err","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error","error::ErrorKind"]},"number::complete::le_f32":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_f32(p0);
+crate::number::complete::le_f32(p0);
+crate::number::complete::le_f32(p0);
-----------------
src/number/complete.rs number::complete::le_f64
deps:{"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"number::complete::le_f64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","error::VerboseErrorKind","error::VerboseError","error::Error"]},"number::complete::le_f64":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_f64(p0);
+crate::number::complete::le_f64(p0);
+crate::number::complete::le_f64(p0);
-----------------
src/number/complete.rs number::complete::f32
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"number::complete::f32":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::Error","error::VerboseErrorKind","<*mut T as std::fmt::Debug>","error::VerboseError","error::ErrorKind","internal::Err","number::Endianness","internal::Needed"]},"number::complete::f32":{"E":["error::VerboseError","error::Error"],"I":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::f32(p0);
+crate::number::complete::f32(p0);
+crate::number::complete::f32(p0);
-----------------
src/number/complete.rs number::complete::f64
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"number::complete::f64":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Needed","internal::Err","error::ErrorKind","number::Endianness","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::Error","error::VerboseError"]},"number::complete::f64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::f64(p0);
+crate::number::complete::f64(p0);
+crate::number::complete::f64(p0);
-----------------
src/number/complete.rs number::complete::hex_u32
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"number::complete::hex_u32":{"<I as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","traits::AsBytes","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","error::VerboseError","internal::Err","number::Endianness","error::Error","error::VerboseErrorKind"]},"number::complete::hex_u32":{"<I as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::hex_u32(p0);
+crate::number::complete::hex_u32(p0);
+crate::number::complete::hex_u32(p0);
-----------------
src/number/complete.rs number::complete::recognize_float
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"number::complete::recognize_float":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone","traits::Input","traits::Offset"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","error::Error","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","internal::Needed","internal::Err","error::VerboseErrorKind"]},"number::complete::recognize_float":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::recognize_float(p0);
+crate::number::complete::recognize_float(p0);
+crate::number::complete::recognize_float(p0);
-----------------
src/number/complete.rs number::complete::recognize_float_or_exceptions
deps:{"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"number::complete::recognize_float_or_exceptions":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone","traits::Input","traits::Compare","traits::Offset"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseError","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","error::Error","error::VerboseErrorKind","error::ErrorKind","number::Endianness"]},"number::complete::recognize_float_or_exceptions":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::recognize_float_or_exceptions(p0);
+crate::number::complete::recognize_float_or_exceptions(p0);
+crate::number::complete::recognize_float_or_exceptions(p0);
-----------------
src/number/complete.rs number::complete::recognize_float_parts
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"number::complete::recognize_float_parts":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Compare","std::marker::Sized","std::clone::Clone","traits::Offset","traits::AsBytes","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","error::ErrorKind","error::Error","error::VerboseErrorKind","internal::Err","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"number::complete::recognize_float_parts":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::recognize_float_parts(p0);
+crate::number::complete::recognize_float_parts(p0);
+crate::number::complete::recognize_float_parts(p0);
-----------------
src/number/complete.rs number::complete::float
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"number::complete::float":{"<T as traits::Input>::Item":["traits::AsChar"],"<T as traits::Input>::Iter":["std::clone::Clone"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::AsBytes","traits::Input","traits::Offset","std::marker::Sized","std::clone::Clone","traits::ParseTo","traits::Compare"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","internal::Err","error::Error","number::Endianness","error::VerboseErrorKind","error::ErrorKind","error::VerboseError","internal::Needed"]},"number::complete::float":{"<T as traits::Input>::Item":[],"<T as traits::Input>::Iter":["error::VerboseError","error::ErrorKind","internal::Needed","error::Error","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","number::Endianness"],"E":["error::VerboseError","error::Error"],"T":[]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::float(p0);
+crate::number::complete::float(p0);
+crate::number::complete::float(p0);
-----------------
src/number/complete.rs number::complete::double
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"number::complete::double":{"<T as traits::Input>::Item":["traits::AsChar"],"<T as traits::Input>::Iter":["std::clone::Clone"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::AsBytes","std::clone::Clone","traits::ParseTo","std::marker::Sized","traits::Offset","traits::Compare","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::Error","number::Endianness","error::VerboseError","error::ErrorKind","<*const T as std::fmt::Debug>","internal::Needed","error::VerboseErrorKind","internal::Err"]},"number::complete::double":{"<T as traits::Input>::Item":[],"<T as traits::Input>::Iter":["error::ErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","error::VerboseErrorKind","internal::Needed","error::Error","number::Endianness"],"E":["error::Error","error::VerboseError"],"T":[]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::double(p0);
+crate::number::complete::double(p0);
+crate::number::complete::double(p0);
-----------------
src/number/streaming.rs number::streaming::be_u8
deps:{"error::Error":{"I":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::be_u8":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","error::VerboseErrorKind","error::Error","internal::Err"]},"number::streaming::be_u8":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u8(p0);
+crate::number::streaming::be_u8(p0);
+crate::number::streaming::be_u8(p0);
-----------------
src/number/streaming.rs number::streaming::be_u16
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::streaming::be_u16":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Needed","number::Endianness","error::ErrorKind","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseErrorKind","error::Error","internal::Err"]},"number::streaming::be_u16":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u16(p0);
+crate::number::streaming::be_u16(p0);
+crate::number::streaming::be_u16(p0);
-----------------
src/number/streaming.rs number::streaming::be_u24
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"number::streaming::be_u24":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::VerboseError","internal::Err","<*mut T as std::fmt::Debug>","number::Endianness","error::Error","error::ErrorKind","error::VerboseErrorKind","internal::Needed"]},"number::streaming::be_u24":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u24(p0);
+crate::number::streaming::be_u24(p0);
+crate::number::streaming::be_u24(p0);
-----------------
src/number/streaming.rs number::streaming::be_u32
deps:{"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::be_u32":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::Error","internal::Needed","error::ErrorKind","internal::Err","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","error::VerboseError"]},"number::streaming::be_u32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u32(p0);
+crate::number::streaming::be_u32(p0);
+crate::number::streaming::be_u32(p0);
-----------------
src/number/streaming.rs number::streaming::be_u64
deps:{"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::streaming::be_u64":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseError","internal::Needed","error::VerboseErrorKind","number::Endianness","error::ErrorKind","error::Error","internal::Err"]},"number::streaming::be_u64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u64(p0);
+crate::number::streaming::be_u64(p0);
+crate::number::streaming::be_u64(p0);
-----------------
src/number/streaming.rs number::streaming::be_u128
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::streaming::be_u128":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","error::Error","internal::Needed","number::Endianness","<*const T as std::fmt::Debug>"]},"number::streaming::be_u128":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u128(p0);
+crate::number::streaming::be_u128(p0);
+crate::number::streaming::be_u128(p0);
-----------------
src/number/streaming.rs number::streaming::be_uint
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::streaming::be_uint":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"],"Uint":["std::default::Default","std::ops::Add","std::convert::From","std::ops::Shl","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["number::Endianness","error::Error","internal::Err","internal::Needed","error::VerboseError","<*const T as std::fmt::Debug>","error::ErrorKind","error::VerboseErrorKind"]},"number::streaming::be_uint":{"E":["error::VerboseError","error::Error"],"I":[],"Uint":["std::num::Saturating<u128>","std::num::Wrapping<u128>","std::num::Saturating<u8>","std::num::Saturating<u16>","std::num::Wrapping<u32>","std::num::Wrapping<u64>","std::num::Wrapping<i64>","std::simd::Mask<i16, LANES>","std::simd::Mask<i8, LANES>","std::num::Saturating<i32>","std::num::NonZeroU128","std::num::Wrapping<isize>","std::num::Saturating<i8>","std::boxed::Box<std::ffi::OsStr>","std::simd::Mask<i64, LANES>","std::num::Wrapping<i8>","std::num::Saturating<i64>","std::simd::Mask<i32, LANES>","std::num::Saturating<u32>","std::boxed::Box<str>","std::num::Saturating<u64>","std::num::Wrapping<i32>","std::num::Saturating<isize>","std::num::NonZeroI32","std::boxed::Box<std::ffi::CStr>","std::num::Wrapping<u16>","std::num::Wrapping<i16>","std::num::Saturating<i128>","std::simd::Mask<isize, LANES>","std::num::Saturating<i16>","std::boxed::Box<[T]>","std::num::Wrapping<i128>","std::num::Wrapping<usize>","std::num::Saturating<usize>","std::num::Wrapping<u8>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = 0usize; // None+usize
+number::streaming::be_uint(p0, p1);
+crate::number::streaming::be_uint(p0, p1);
+crate::number::streaming::be_uint(p0, p1);
-----------------
src/number/streaming.rs number::streaming::be_i8
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"number::streaming::be_i8":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","internal::Err","number::Endianness","error::VerboseError","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error"]},"number::streaming::be_i8":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i8(p0);
+crate::number::streaming::be_i8(p0);
+crate::number::streaming::be_i8(p0);
-----------------
src/number/streaming.rs number::streaming::be_i16
deps:{"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"number::streaming::be_i16":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","error::Error","internal::Needed","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","internal::Err","error::VerboseError"]},"number::streaming::be_i16":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i16(p0);
+crate::number::streaming::be_i16(p0);
+crate::number::streaming::be_i16(p0);
-----------------
src/number/streaming.rs number::streaming::be_i24
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"number::streaming::be_i24":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","error::Error","number::Endianness","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"number::streaming::be_i24":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i24(p0);
+crate::number::streaming::be_i24(p0);
+crate::number::streaming::be_i24(p0);
-----------------
src/number/streaming.rs number::streaming::be_i32
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::be_i32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Needed","error::Error","error::VerboseErrorKind","internal::Err","error::VerboseError","number::Endianness","error::ErrorKind","<*mut T as std::fmt::Debug>"]},"number::streaming::be_i32":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i32(p0);
+crate::number::streaming::be_i32(p0);
+crate::number::streaming::be_i32(p0);
-----------------
src/number/streaming.rs number::streaming::be_i64
deps:{"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"number::streaming::be_i64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::Error","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","number::Endianness","error::ErrorKind","internal::Needed","error::VerboseErrorKind"]},"number::streaming::be_i64":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i64(p0);
+crate::number::streaming::be_i64(p0);
+crate::number::streaming::be_i64(p0);
-----------------
src/number/streaming.rs number::streaming::be_i128
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"number::streaming::be_i128":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","error::ErrorKind","error::VerboseError","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","error::Error"]},"number::streaming::be_i128":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i128(p0);
+crate::number::streaming::be_i128(p0);
+crate::number::streaming::be_i128(p0);
-----------------
src/number/streaming.rs number::streaming::le_u8
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"number::streaming::le_u8":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","error::Error","error::VerboseError","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Err","error::VerboseErrorKind"]},"number::streaming::le_u8":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u8(p0);
+crate::number::streaming::le_u8(p0);
+crate::number::streaming::le_u8(p0);
-----------------
src/number/streaming.rs number::streaming::le_u16
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"number::streaming::le_u16":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","error::VerboseErrorKind","internal::Needed","error::Error","error::VerboseError","<*const T as std::fmt::Debug>","number::Endianness"]},"number::streaming::le_u16":{"E":["error::VerboseError","error::Error"],"I":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u16(p0);
+crate::number::streaming::le_u16(p0);
+crate::number::streaming::le_u16(p0);
-----------------
src/number/streaming.rs number::streaming::le_u24
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::le_u24":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Needed","internal::Err","number::Endianness","error::Error","error::VerboseError","error::ErrorKind","<*mut T as std::fmt::Debug>","error::VerboseErrorKind"]},"number::streaming::le_u24":{"E":["error::VerboseError","error::Error"],"I":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u24(p0);
+crate::number::streaming::le_u24(p0);
+crate::number::streaming::le_u24(p0);
-----------------
src/number/streaming.rs number::streaming::le_u32
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"number::streaming::le_u32":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","error::VerboseErrorKind","error::VerboseError","error::Error","internal::Err","internal::Needed"]},"number::streaming::le_u32":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u32(p0);
+crate::number::streaming::le_u32(p0);
+crate::number::streaming::le_u32(p0);
-----------------
src/number/streaming.rs number::streaming::le_u64
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"number::streaming::le_u64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::VerboseErrorKind","number::Endianness","internal::Err","error::VerboseError","internal::Needed","error::Error","error::ErrorKind"]},"number::streaming::le_u64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u64(p0);
+crate::number::streaming::le_u64(p0);
+crate::number::streaming::le_u64(p0);
-----------------
src/number/streaming.rs number::streaming::le_u128
deps:{"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"number::streaming::le_u128":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","internal::Err","error::VerboseError","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","error::Error","internal::Needed"]},"number::streaming::le_u128":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u128(p0);
+crate::number::streaming::le_u128(p0);
+crate::number::streaming::le_u128(p0);
-----------------
src/number/streaming.rs number::streaming::le_uint
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"number::streaming::le_uint":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"],"Uint":["std::convert::From","std::ops::Add","std::marker::Sized","std::ops::Shl","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","<*mut T as std::fmt::Debug>","number::Endianness","internal::Err","error::Error","error::VerboseError","internal::Needed","error::VerboseErrorKind"]},"number::streaming::le_uint":{"E":["error::VerboseError","error::Error"],"I":[],"Uint":["std::num::Saturating<u128>","std::simd::Mask<isize, LANES>","std::num::Wrapping<usize>","std::num::Wrapping<i8>","std::num::Wrapping<i16>","std::boxed::Box<str>","std::num::Wrapping<u32>","std::num::Wrapping<u64>","std::num::Saturating<u64>","std::num::Saturating<usize>","std::num::Saturating<i32>","std::num::Saturating<i16>","std::simd::Mask<i8, LANES>","std::num::Wrapping<i32>","std::num::Wrapping<u16>","std::num::Saturating<i8>","std::boxed::Box<[T]>","std::num::Saturating<u8>","std::boxed::Box<std::ffi::OsStr>","std::simd::Mask<i32, LANES>","std::num::Wrapping<u128>","std::num::Wrapping<i128>","std::num::Saturating<i64>","std::num::Wrapping<i64>","std::num::Wrapping<isize>","std::num::Saturating<u16>","std::num::Saturating<u32>","std::num::Saturating<isize>","std::num::NonZeroI32","std::simd::Mask<i16, LANES>","std::boxed::Box<std::ffi::CStr>","std::num::Saturating<i128>","std::num::Wrapping<u8>","std::simd::Mask<i64, LANES>","std::num::NonZeroU128"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = 0usize; // None+usize
+number::streaming::le_uint(p0, p1);
+crate::number::streaming::le_uint(p0, p1);
+crate::number::streaming::le_uint(p0, p1);
-----------------
src/number/streaming.rs number::streaming::le_i8
deps:{"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"number::streaming::le_i8":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseError","internal::Err","number::Endianness","error::VerboseErrorKind","error::Error","internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"number::streaming::le_i8":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i8(p0);
+crate::number::streaming::le_i8(p0);
+crate::number::streaming::le_i8(p0);
-----------------
src/number/streaming.rs number::streaming::le_i16
deps:{"error::Error":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"number::streaming::le_i16":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::Error","error::VerboseError","error::ErrorKind","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","internal::Err","error::VerboseErrorKind"]},"number::streaming::le_i16":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i16(p0);
+crate::number::streaming::le_i16(p0);
+crate::number::streaming::le_i16(p0);
-----------------
src/number/streaming.rs number::streaming::le_i24
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"number::streaming::le_i24":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::VerboseError","internal::Err","error::Error","error::ErrorKind","<*mut T as std::fmt::Debug>","error::VerboseErrorKind","number::Endianness","internal::Needed"]},"number::streaming::le_i24":{"E":["error::VerboseError","error::Error"],"I":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i24(p0);
+crate::number::streaming::le_i24(p0);
+crate::number::streaming::le_i24(p0);
-----------------
src/number/streaming.rs number::streaming::le_i32
deps:{"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::streaming::le_i32":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","error::ErrorKind","internal::Needed","error::Error","internal::Err","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseError"]},"number::streaming::le_i32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i32(p0);
+crate::number::streaming::le_i32(p0);
+crate::number::streaming::le_i32(p0);
-----------------
src/number/streaming.rs number::streaming::le_i64
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"number::streaming::le_i64":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseErrorKind","error::VerboseError","internal::Err","error::Error"]},"number::streaming::le_i64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i64(p0);
+crate::number::streaming::le_i64(p0);
+crate::number::streaming::le_i64(p0);
-----------------
src/number/streaming.rs number::streaming::le_i128
deps:{"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"number::streaming::le_i128":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::Error","error::ErrorKind","error::VerboseError","internal::Needed","number::Endianness"]},"number::streaming::le_i128":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i128(p0);
+crate::number::streaming::le_i128(p0);
+crate::number::streaming::le_i128(p0);
-----------------
src/number/streaming.rs number::streaming::u8
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"number::streaming::u8":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::VerboseError","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::VerboseErrorKind","error::Error"]},"number::streaming::u8":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::u8(p0);
+crate::number::streaming::u8(p0);
+crate::number::streaming::u8(p0);
-----------------
src/number/streaming.rs number::streaming::u16
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"number::streaming::u16":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseErrorKind","internal::Needed","error::VerboseError","number::Endianness","error::Error","internal::Err"]},"number::streaming::u16":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u16(p0);
+crate::number::streaming::u16(p0);
+crate::number::streaming::u16(p0);
-----------------
src/number/streaming.rs number::streaming::u24
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"number::streaming::u24":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","error::VerboseErrorKind","internal::Needed","error::Error","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","number::Endianness"]},"number::streaming::u24":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u24(p0);
+crate::number::streaming::u24(p0);
+crate::number::streaming::u24(p0);
-----------------
src/number/streaming.rs number::streaming::u32
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"number::streaming::u32":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","internal::Needed","internal::Err","error::Error","number::Endianness","error::VerboseErrorKind","<*const T as std::fmt::Debug>"]},"number::streaming::u32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u32(p0);
+crate::number::streaming::u32(p0);
+crate::number::streaming::u32(p0);
-----------------
src/number/streaming.rs number::streaming::u64
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"number::streaming::u64":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseError","error::VerboseErrorKind","number::Endianness","error::Error","error::ErrorKind"]},"number::streaming::u64":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u64(p0);
+crate::number::streaming::u64(p0);
+crate::number::streaming::u64(p0);
-----------------
src/number/streaming.rs number::streaming::u128
deps:{"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"number::streaming::u128":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","error::Error","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Err","number::Endianness","error::VerboseError"]},"number::streaming::u128":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u128(p0);
+crate::number::streaming::u128(p0);
+crate::number::streaming::u128(p0);
-----------------
src/number/streaming.rs number::streaming::i8
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"number::streaming::i8":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::Error","error::VerboseError","error::VerboseErrorKind","internal::Needed","error::ErrorKind","number::Endianness"]},"number::streaming::i8":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::i8(p0);
+crate::number::streaming::i8(p0);
+crate::number::streaming::i8(p0);
-----------------
src/number/streaming.rs number::streaming::i16
deps:{"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::i16":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","error::ErrorKind","error::Error","error::VerboseError","internal::Err","number::Endianness"]},"number::streaming::i16":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i16(p0);
+crate::number::streaming::i16(p0);
+crate::number::streaming::i16(p0);
-----------------
src/number/streaming.rs number::streaming::i24
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"number::streaming::i24":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","error::Error","error::VerboseError","internal::Err","error::ErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness"]},"number::streaming::i24":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i24(p0);
+crate::number::streaming::i24(p0);
+crate::number::streaming::i24(p0);
-----------------
src/number/streaming.rs number::streaming::i32
deps:{"error::Error":{"I":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"number::streaming::i32":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","internal::Needed","error::Error","error::VerboseErrorKind","internal::Err","number::Endianness"]},"number::streaming::i32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i32(p0);
+crate::number::streaming::i32(p0);
+crate::number::streaming::i32(p0);
-----------------
src/number/streaming.rs number::streaming::i64
deps:{"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"number::streaming::i64":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","error::Error","error::VerboseError","number::Endianness","internal::Err","error::ErrorKind","internal::Needed"]},"number::streaming::i64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i64(p0);
+crate::number::streaming::i64(p0);
+crate::number::streaming::i64(p0);
-----------------
src/number/streaming.rs number::streaming::i128
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"number::streaming::i128":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Needed","error::Error","error::VerboseError","error::VerboseErrorKind","internal::Err","number::Endianness","<*const T as std::fmt::Debug>","error::ErrorKind"]},"number::streaming::i128":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i128(p0);
+crate::number::streaming::i128(p0);
+crate::number::streaming::i128(p0);
-----------------
src/number/streaming.rs number::streaming::be_f32
deps:{"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"number::streaming::be_f32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseError","internal::Needed","error::ErrorKind","internal::Err","error::VerboseErrorKind","error::Error","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness"]},"number::streaming::be_f32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_f32(p0);
+crate::number::streaming::be_f32(p0);
+crate::number::streaming::be_f32(p0);
-----------------
src/number/streaming.rs number::streaming::be_f64
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"number::streaming::be_f64":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::Error","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","error::VerboseErrorKind","internal::Err","error::ErrorKind","error::VerboseError"]},"number::streaming::be_f64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_f64(p0);
+crate::number::streaming::be_f64(p0);
+crate::number::streaming::be_f64(p0);
-----------------
src/number/streaming.rs number::streaming::le_f32
deps:{"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"number::streaming::le_f32":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","error::ErrorKind","number::Endianness","error::VerboseError","internal::Needed","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err"]},"number::streaming::le_f32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_f32(p0);
+crate::number::streaming::le_f32(p0);
+crate::number::streaming::le_f32(p0);
-----------------
src/number/streaming.rs number::streaming::le_f64
deps:{"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"number::streaming::le_f64":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed","internal::Err","number::Endianness","error::VerboseErrorKind","error::Error"]},"number::streaming::le_f64":{"E":["error::VerboseError","error::Error"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_f64(p0);
+crate::number::streaming::le_f64(p0);
+crate::number::streaming::le_f64(p0);
-----------------
src/number/streaming.rs number::streaming::f32
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"number::streaming::f32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Input","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::Error","internal::Needed","error::VerboseErrorKind","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","error::VerboseError","internal::Err"]},"number::streaming::f32":{"E":["error::Error","error::VerboseError"],"I":[]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::f32(p0);
+crate::number::streaming::f32(p0);
+crate::number::streaming::f32(p0);
-----------------
src/number/streaming.rs number::streaming::f64
deps:{"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::streaming::f64":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Needed","error::VerboseErrorKind","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","error::Error","error::VerboseError","internal::Err"]},"number::streaming::f64":{"E":["error::Error","error::VerboseError"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::f64(p0);
+crate::number::streaming::f64(p0);
+crate::number::streaming::f64(p0);
-----------------
src/number/streaming.rs number::streaming::hex_u32
deps:{"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::streaming::hex_u32":{"<I as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"I":["traits::Input","traits::AsBytes","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","error::ErrorKind","number::Endianness","error::VerboseError","error::VerboseErrorKind","internal::Err","error::Error"]},"number::streaming::hex_u32":{"<I as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"I":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::hex_u32(p0);
+crate::number::streaming::hex_u32(p0);
+crate::number::streaming::hex_u32(p0);
-----------------
src/number/streaming.rs number::streaming::recognize_float
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::recognize_float":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Input","traits::Offset","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Needed","internal::Err","error::Error","error::VerboseError","<*mut T as std::fmt::Debug>","number::Endianness","error::VerboseErrorKind","error::ErrorKind"]},"number::streaming::recognize_float":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::recognize_float(p0);
+crate::number::streaming::recognize_float(p0);
+crate::number::streaming::recognize_float(p0);
-----------------
src/number/streaming.rs number::streaming::recognize_float_or_exceptions
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"number::streaming::recognize_float_or_exceptions":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone","traits::Input","traits::Compare","traits::Offset"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind","number::Endianness","error::VerboseErrorKind","error::Error","internal::Needed","error::VerboseError"]},"number::streaming::recognize_float_or_exceptions":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::recognize_float_or_exceptions(p0);
+crate::number::streaming::recognize_float_or_exceptions(p0);
+crate::number::streaming::recognize_float_or_exceptions(p0);
-----------------
src/number/streaming.rs number::streaming::recognize_float_parts
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::recognize_float_parts":{"<T as traits::Input>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Offset","traits::AsBytes","traits::Compare","std::clone::Clone","traits::Input"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseErrorKind","error::Error","internal::Err","internal::Needed","error::VerboseError","number::Endianness"]},"number::streaming::recognize_float_parts":{"<T as traits::Input>::Item":[],"E":["error::Error","error::VerboseError"],"T":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::recognize_float_parts(p0);
+crate::number::streaming::recognize_float_parts(p0);
+crate::number::streaming::recognize_float_parts(p0);
-----------------
src/number/streaming.rs number::streaming::float
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"number::streaming::float":{"<T as traits::Input>::Item":["std::clone::Clone","traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::clone::Clone","std::marker::Sized","traits::Offset","traits::Input","traits::ParseTo","traits::Compare","traits::AsBytes"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::Error","error::VerboseErrorKind","internal::Err","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Needed","number::Endianness"]},"number::streaming::float":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::float(p0);
+crate::number::streaming::float(p0);
+crate::number::streaming::float(p0);
-----------------
src/number/streaming.rs number::streaming::double
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"number::streaming::double":{"<T as traits::Input>::Item":["std::clone::Clone","traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Offset","traits::Input","std::marker::Sized","traits::ParseTo","traits::AsBytes","traits::Compare","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::Error","internal::Err","<*mut T as std::fmt::Debug>","internal::Needed","error::VerboseErrorKind","error::ErrorKind","number::Endianness","error::VerboseError"]},"number::streaming::double":{"<T as traits::Input>::Item":[],"E":["error::VerboseError","error::Error"],"T":[]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::double(p0);
+crate::number::streaming::double(p0);
+crate::number::streaming::double(p0);
-----------------
src/error.rs error::ParseError::from_error_kind
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"error::ParseError::from_error_kind":{"I":["std::marker::Sized"],"Self":["std::marker::Sized","error::ParseError"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::ParseError::from_error_kind":{"I":["RUG_ANY"],"Self":["error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","error::ErrorKind","error::Error","error::VerboseErrorKind","<*const T as std::fmt::Debug>","error::VerboseError"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+error::ParseError::from_error_kind(p0, p1);
+crate::error::ParseError::from_error_kind(p0, p1);
+crate::error::ParseError::from_error_kind(p0, p1);
-----------------
src/error.rs error::ParseError::append
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::fmt::Debug"]},"error::ParseError::append":{"I":["std::marker::Sized"],"Self":["std::marker::Sized","error::ParseError"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::ParseError::append":{"I":["RUG_ANY"],"Self":["error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["internal::Err","error::VerboseError","number::Endianness","<*mut T as std::fmt::Debug>","error::Error","error::ErrorKind","internal::Needed","error::VerboseErrorKind"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // Self
+error::ParseError::append(p0, p1, p2);
+crate::error::ParseError::append(p0, p1, p2);
+crate::error::ParseError::append(p0, p1, p2);
-----------------
src/error.rs error::ParseError::from_char
deps:{"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"error::ParseError::from_char":{"I":["std::marker::Sized"],"Self":["std::marker::Sized","error::ParseError"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::ParseError::from_char":{"I":["RUG_ANY"],"Self":["error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::Error","error::VerboseErrorKind","error::VerboseError","internal::Err","number::Endianness","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = 'a'; // None+char
+error::ParseError::from_char(p0, p1);
+crate::error::ParseError::from_char(p0, p1);
+crate::error::ParseError::from_char(p0, p1);
-----------------
src/error.rs error::ParseError::or
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Display","std::fmt::Debug"]},"error::ParseError::or":{"I":["std::marker::Sized"],"Self":["std::marker::Sized","error::ParseError"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::ParseError::or":{"I":["RUG_ANY"],"Self":["error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","internal::Needed","internal::Err","error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.or(p1);
+error::ParseError::or(p0, p1);
+crate::error::ParseError::or(p0, p1);
+crate::error::ParseError::or(p0, p1);
-----------------
src/error.rs error::ContextError::add_context
deps:{"error::ContextError::add_context":{"I":["std::marker::Sized"],"Self":["error::ContextError","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::ContextError::add_context":{"I":["RUG_ANY"],"Self":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["number::Endianness","error::VerboseErrorKind","error::Error","internal::Err","internal::Needed","error::VerboseError","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // Self
+error::ContextError::add_context(p0, &p1, p2);
+crate::error::ContextError::add_context(p0, &p1, p2);
+crate::error::ContextError::add_context(p0, &p1, p2);
-----------------
src/error.rs error::FromExternalError::from_external_error
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"error::FromExternalError::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"Self":["error::FromExternalError"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::FromExternalError::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"],"Self":["error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","error::Error","error::ErrorKind","internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","error::VerboseError","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+error::FromExternalError::from_external_error(p0, p1, p2);
+crate::error::FromExternalError::from_external_error(p0, p1, p2);
+crate::error::FromExternalError::from_external_error(p0, p1, p2);
-----------------
src/branch/mod.rs branch::Alt::choice
deps:{"branch::Alt::choice":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["branch::Alt"]}}
candidates:{"branch::Alt::choice":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":[]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.choice(p1);
+branch::Alt::choice(p0, p1);
+crate::branch::Alt::choice(p0, p1);
+crate::branch::Alt::choice(p0, p1);
-----------------
src/branch/mod.rs branch::Permutation::permutation
deps:{"branch::Permutation::permutation":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["branch::Permutation"]}}
candidates:{"branch::Permutation::permutation":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":[]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.permutation(p1);
+branch::Permutation::permutation(p0, p1);
+crate::branch::Permutation::permutation(p0, p1);
+crate::branch::Permutation::permutation(p0, p1);
-----------------
src/internal.rs internal::Finish::finish
deps:{"internal::Finish::finish":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["internal::Finish"]},"internal::IResult":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]}}
candidates:{"internal::Finish::finish":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":["internal::IResult"]},"internal::IResult":{"E":["RUG_ANY","error::Error<I>"],"I":["RUG_ANY"],"O":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.finish();
+internal::Finish::finish(p0);
+crate::internal::Finish::finish(p0);
+crate::internal::Finish::finish(p0);
-----------------
src/internal.rs internal::Parser::parse
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Parser::parse":{"Input":["std::marker::Sized"],"Self":["internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","internal::FlatMap","internal::Or","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::Into","internal::MapOpt"],"G":["internal::FlatMap","internal::And","internal::MapOpt","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","std::boxed::Box","internal::Into"]},"internal::AndThen":{"F":["internal::MapOpt","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into","internal::And"],"G":["internal::MapRes","internal::Map","internal::Or","internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Into"]},"internal::Err":{"E":["internal::Needed","internal::Err","number::Endianness","error::VerboseError","error::ErrorKind","error::Error","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Map","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::Or","internal::MapRes","internal::And","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::FlatMap","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::FlatMap","internal::Map","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::And","internal::AndThen"],"G":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::And","internal::MapRes","internal::Map"],"G":["core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["internal::Map","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Into","internal::And","std::boxed::Box","internal::MapOpt"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["internal::MapOpt","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","std::boxed::Box","internal::MapRes","internal::And","internal::Or"],"G":["internal::Into","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::And","internal::Map","internal::FlatMap","internal::AndThen"]},"internal::Parser::parse":{"Input":["RUG_ANY"],"Self":["internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::And","internal::Or","internal::MapRes","std::boxed::Box","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+internal::Parser::parse(p0, p1);
+crate::internal::Parser::parse(p0, p1);
+crate::internal::Parser::parse(p0, p1);
-----------------
src/internal.rs internal::Parser::map
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Parser::map":{"G":["std::marker::Sized","std::ops::FnMut"],"Input":["std::marker::Sized"],"O2":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::AndThen"],"G":["internal::FlatMap","internal::Into","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::MapRes","std::boxed::Box","internal::AndThen","internal::Map"]},"internal::AndThen":{"F":["internal::Into","internal::FlatMap","internal::MapOpt","internal::And","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::MapRes"],"G":["internal::FlatMap","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::Map","internal::And","internal::Into","<F as internal::Parser<I>>","internal::Or"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","<*const T as std::fmt::Debug>","error::VerboseErrorKind","number::Endianness","error::Error","error::VerboseError"]},"internal::FlatMap":{"F":["internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Into","internal::MapOpt","internal::Map","internal::Or"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Into","internal::MapOpt","internal::And"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapRes","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::Or","internal::And"],"G":["core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::AndThen","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::Map","internal::And","internal::MapRes"],"G":["core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapRes","internal::Map","internal::And","internal::MapOpt","internal::Into"],"G":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::And","std::boxed::Box","internal::MapOpt","internal::Map","internal::MapRes","internal::Into","internal::FlatMap"],"G":["internal::FlatMap","internal::And","internal::Map","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::Into","std::boxed::Box","internal::MapOpt"]},"internal::Parser::map":{"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"],"Input":["RUG_ANY"],"O2":["RUG_ANY"],"Self":["internal::MapRes","internal::Map","std::boxed::Box","internal::Or","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::Into","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.map(p1);
+internal::Parser::map(p0, p1);
+crate::internal::Parser::map(p0, p1);
+crate::internal::Parser::map(p0, p1);
-----------------
src/internal.rs internal::Parser::map_res
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Parser::map_res":{"<Self as internal::Parser<Input>>::Error":["error::FromExternalError"],"E2":["std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"Input":["std::marker::Sized"],"O2":["std::marker::Sized"],"Self":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Map","internal::MapOpt","internal::Into","internal::And","std::boxed::Box","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Or"],"G":["internal::AndThen","internal::MapRes","internal::Into","internal::Map","internal::And","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::MapOpt"]},"internal::AndThen":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Map","internal::MapOpt","internal::And"],"G":["internal::Into","internal::MapRes","internal::And","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::Or"]},"internal::Err":{"E":["error::VerboseErrorKind","error::ErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","number::Endianness","internal::Needed","internal::Err"]},"internal::FlatMap":{"F":["internal::Into","internal::AndThen","std::boxed::Box","internal::Map","internal::Or","internal::FlatMap","internal::MapRes","internal::And","internal::MapOpt","<F as internal::Parser<I>>"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::MapRes","internal::MapOpt","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Map","internal::Into","internal::And","<F as internal::Parser<I>>"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Map","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::And","internal::Or","internal::FlatMap","internal::MapRes","internal::Into","<F as internal::Parser<I>>"],"G":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::Map","internal::Into","internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Or","std::boxed::Box"],"G":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::AndThen","internal::MapRes","internal::FlatMap","internal::Map","internal::And","internal::Or","internal::Into","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>"],"G":["core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty"]},"internal::Or":{"F":["std::boxed::Box","internal::AndThen","internal::Or","internal::MapRes","internal::Into","internal::Map","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap"],"G":["internal::And","internal::MapOpt","internal::AndThen","internal::MapRes","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Or"]},"internal::Parser::map_res":{"<Self as internal::Parser<Input>>::Error":["error::Error","error::VerboseError"],"E2":["RUG_ANY"],"G":["core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace","std::boxed::Box<F, A>"],"Input":["RUG_ANY"],"O2":["RUG_ANY"],"Self":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into","internal::MapOpt","internal::AndThen","internal::And","internal::Map","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.map_res(p1);
+internal::Parser::map_res(p0, p1);
+crate::internal::Parser::map_res(p0, p1);
+crate::internal::Parser::map_res(p0, p1);
-----------------
src/internal.rs internal::Parser::map_opt
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Parser::map_opt":{"G":["std::ops::Fn","std::marker::Sized"],"Input":["std::marker::Sized"],"O2":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Into","std::boxed::Box","internal::MapRes","internal::Or","internal::AndThen","internal::Map","internal::And"],"G":["internal::Or","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::AndThen","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Into"]},"internal::AndThen":{"F":["internal::AndThen","internal::MapRes","internal::Into","internal::Or","internal::Map","std::boxed::Box","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap"],"G":["<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::Or","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Map","std::boxed::Box","internal::And"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","error::VerboseErrorKind","internal::Err","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","internal::Needed"]},"internal::FlatMap":{"F":["internal::Map","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::And","internal::AndThen","std::boxed::Box"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::FlatMap","internal::Or","internal::And","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::Into","std::boxed::Box"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::MapOpt","internal::Into","internal::AndThen","internal::MapRes"],"G":["core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"internal::MapOpt":{"F":["internal::AndThen","internal::FlatMap","internal::And","internal::MapRes","std::boxed::Box","internal::Map","internal::MapOpt","internal::Into","internal::Or","<F as internal::Parser<I>>"],"G":["core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::Into","internal::Map","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Or"],"G":["std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["internal::AndThen","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::Map","internal::And","internal::Into","std::boxed::Box"],"G":["internal::MapRes","internal::FlatMap","internal::Map","internal::AndThen","internal::Or","internal::MapOpt","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I>>"]},"internal::Parser::map_opt":{"G":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"],"Input":["RUG_ANY"],"O2":["RUG_ANY"],"Self":["internal::AndThen","internal::MapRes","internal::And","internal::FlatMap","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.map_opt(p1);
+internal::Parser::map_opt(p0, p1);
+crate::internal::Parser::map_opt(p0, p1);
+crate::internal::Parser::map_opt(p0, p1);
-----------------
src/internal.rs internal::Parser::flat_map
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Parser::flat_map":{"G":["std::ops::FnMut","std::marker::Sized"],"H":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Map","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Into","internal::MapOpt","internal::MapRes"],"G":["internal::AndThen","internal::Map","internal::And","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::MapOpt","internal::Into"]},"internal::AndThen":{"F":["internal::Or","internal::And","internal::Map","internal::MapRes","internal::AndThen","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box"],"G":["<F as internal::Parser<I>>","internal::Or","internal::And","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen","internal::Into"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","error::ErrorKind","internal::Needed","error::Error","error::VerboseError","internal::Err","<*const T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::Into","internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map","internal::Or","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::MapRes","internal::And","internal::MapOpt","internal::AndThen","internal::Into","internal::FlatMap","internal::Map","internal::Or","<F as internal::Parser<I>>","std::boxed::Box"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::FlatMap","internal::Or","internal::AndThen","std::boxed::Box","internal::Into","internal::MapOpt","internal::And"],"G":["core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::And","internal::MapRes","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsWhitespace"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Map","internal::And","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Into","internal::Or"],"G":["core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr"]},"internal::Or":{"F":["internal::Map","internal::And","internal::Or","internal::MapRes","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Into"],"G":["internal::MapRes","internal::Or","internal::And","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::AndThen"]},"internal::Parser::flat_map":{"G":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::IsWhitespace"],"H":["internal::MapRes","internal::AndThen","internal::MapOpt","internal::And","internal::Into","internal::Map","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap"],"Input":["RUG_ANY"],"Self":["internal::AndThen","internal::Map","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Or","internal::Into","internal::And","<F as internal::Parser<I>>","internal::MapRes"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.flat_map(p1);
+internal::Parser::flat_map(p0, p1);
+crate::internal::Parser::flat_map(p0, p1);
+crate::internal::Parser::flat_map(p0, p1);
-----------------
src/internal.rs internal::Parser::and_then
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Parser::and_then":{"G":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Map","internal::Into"],"G":["internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Or","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box","internal::And"]},"internal::AndThen":{"F":["internal::Map","internal::Into","internal::And","internal::MapOpt","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Or"],"G":["<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box","internal::Or","internal::And","internal::FlatMap","internal::Into","internal::AndThen"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","error::VerboseErrorKind","error::Error","<*const T as std::fmt::Debug>","number::Endianness","error::VerboseError","internal::Needed"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::Into","internal::And","internal::MapRes","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Map","internal::Or","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::Map","internal::MapRes","internal::Or","internal::Into","internal::AndThen","internal::And"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Map","internal::MapOpt","internal::Or","internal::Into","internal::MapRes","internal::AndThen","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::boxed::Box<F, A>"]},"internal::MapOpt":{"F":["internal::FlatMap","std::boxed::Box","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::Map","internal::And","internal::MapRes"],"G":["core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::Map","internal::MapRes","internal::And","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Or"],"G":["core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap"]},"internal::Or":{"F":["std::boxed::Box","internal::Map","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Into","internal::And","internal::MapRes"],"G":["<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::AndThen","internal::And","internal::Or","internal::Map","std::boxed::Box","internal::Into"]},"internal::Parser::and_then":{"G":["internal::MapOpt","internal::MapRes","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::Into","internal::FlatMap","internal::AndThen"],"Input":["RUG_ANY"],"Self":["internal::Into","internal::AndThen","internal::MapOpt","internal::Or","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::And","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.and_then(p1);
+internal::Parser::and_then(p0, p1);
+crate::internal::Parser::and_then(p0, p1);
+crate::internal::Parser::and_then(p0, p1);
-----------------
src/internal.rs internal::Parser::and
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Parser::and":{"G":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized"],"O2":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::Or","internal::Into","internal::FlatMap","internal::MapRes","internal::And","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::AndThen"],"G":["internal::MapOpt","internal::Or","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Into","std::boxed::Box","internal::AndThen"]},"internal::AndThen":{"F":["std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Or","internal::And","internal::MapRes","internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I>>"],"G":["internal::And","internal::AndThen","internal::FlatMap","internal::Into","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::MapOpt"]},"internal::Err":{"E":["number::Endianness","internal::Err","internal::Needed","error::ErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","error::Error"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Or","internal::FlatMap","internal::Map","internal::MapRes","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::Into","std::boxed::Box"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::AndThen","internal::MapOpt","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Map","std::boxed::Box","internal::MapRes","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or","internal::Map","internal::MapRes","internal::MapOpt","internal::And"],"G":["core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::MapOpt":{"F":["internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapRes","internal::FlatMap","internal::Into","internal::MapOpt","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::Map","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::AndThen","std::boxed::Box","internal::And","internal::Into","<F as internal::Parser<I>>","internal::Or"],"G":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::Into","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::MapRes","std::boxed::Box"],"G":["internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::AndThen","internal::Map","internal::MapOpt","internal::Into","internal::MapRes"]},"internal::Parser::and":{"G":["internal::And","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Map"],"Input":["RUG_ANY"],"O2":["RUG_ANY"],"Self":["internal::MapOpt","internal::Map","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::Or","std::boxed::Box","internal::And","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.and(p1);
+internal::Parser::and(p0, p1);
+crate::internal::Parser::and(p0, p1);
+crate::internal::Parser::and(p0, p1);
-----------------
src/internal.rs internal::Parser::or
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Parser::or":{"G":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Into","internal::Or","internal::AndThen","internal::Map","internal::MapOpt","internal::FlatMap","std::boxed::Box"],"G":["internal::Or","internal::Map","internal::MapRes","internal::Into","internal::FlatMap","internal::And","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt"]},"internal::AndThen":{"F":["internal::Map","std::boxed::Box","internal::AndThen","internal::And","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::Into","internal::Or","<F as internal::Parser<I>>"],"G":["internal::Into","internal::MapOpt","internal::MapRes","internal::Map","internal::FlatMap","internal::Or","internal::AndThen","std::boxed::Box","internal::And","<F as internal::Parser<I>>"]},"internal::Err":{"E":["error::VerboseErrorKind","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness","error::Error","error::VerboseError","internal::Needed"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Or","internal::MapRes","internal::Map","internal::Into","internal::AndThen","internal::MapOpt","internal::And","std::boxed::Box","<F as internal::Parser<I>>"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::MapOpt","internal::AndThen","std::boxed::Box","internal::And","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::FlatMap","internal::Map"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Map","internal::Into","std::boxed::Box","internal::And"],"G":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"internal::MapOpt":{"F":["internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Or","internal::MapRes","internal::And","internal::Into"],"G":["core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::MapRes","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Into","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::And"],"G":["core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::And","internal::MapOpt","internal::FlatMap","internal::AndThen"],"G":["internal::Or","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::And","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes"]},"internal::Parser::or":{"G":["internal::MapRes","internal::MapOpt","internal::AndThen","internal::Map","internal::Or","internal::Into","std::boxed::Box","internal::And","internal::FlatMap","<F as internal::Parser<I>>"],"Input":["RUG_ANY"],"Self":["std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::MapRes","internal::Into","internal::AndThen","internal::And","internal::Map","internal::MapOpt"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.or(p1);
+internal::Parser::or(p0, p1);
+crate::internal::Parser::or(p0, p1);
+crate::internal::Parser::or(p0, p1);
-----------------
src/internal.rs internal::Parser::into
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Parser::into":{"E2":["std::convert::From","std::marker::Sized"],"Input":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"],"Self":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Map","<F as internal::Parser<I>>","internal::Or","internal::And","internal::FlatMap","internal::Into","internal::MapOpt","internal::MapRes","internal::AndThen","std::boxed::Box"],"G":["internal::Map","internal::FlatMap","internal::And","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Into","internal::Or"]},"internal::AndThen":{"F":["std::boxed::Box","internal::MapRes","internal::And","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::AndThen","internal::FlatMap","internal::MapOpt"],"G":["<F as internal::Parser<I>>","internal::Map","internal::Or","std::boxed::Box","internal::MapOpt","internal::Into","internal::MapRes","internal::FlatMap","internal::And","internal::AndThen"]},"internal::Err":{"E":["internal::Err","error::Error","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","error::VerboseErrorKind","error::VerboseError","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::MapRes","internal::Into","internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap","internal::Or"],"G":["core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::Into","internal::FlatMap","internal::Or","internal::MapOpt"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Or","internal::AndThen","internal::Into","internal::Map","internal::MapOpt","std::boxed::Box","internal::And","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::Map","std::boxed::Box","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::Into","internal::And","internal::MapRes"],"G":["core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::FlatMap","internal::Or","internal::Into","internal::MapOpt","internal::MapRes","internal::Map","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::And"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::MapOpt","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::Into","internal::And","internal::FlatMap","std::boxed::Box"],"G":["internal::MapOpt","internal::Map","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::Or","internal::MapRes","internal::FlatMap"]},"internal::Parser::into":{"E2":["error::VerboseError","error::Error"],"Input":["RUG_ANY"],"O2":["error::Error","error::VerboseError"],"Self":["internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::And","internal::AndThen","std::boxed::Box","internal::Or","internal::MapRes","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.into();
+internal::Parser::into(p0);
+crate::internal::Parser::into(p0);
+crate::internal::Parser::into(p0);
-----------------
src/sequence/mod.rs sequence::Tuple::parse
deps:{"sequence::Tuple::parse":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["sequence::Tuple"]}}
candidates:{"sequence::Tuple::parse":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":[]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+sequence::Tuple::parse(p0, p1);
+crate::sequence::Tuple::parse(p0, p1);
+crate::sequence::Tuple::parse(p0, p1);
-----------------
src/traits.rs traits::Input::input_len
deps:{"traits::Input::input_len":{"Self":["traits::Input","std::marker::Sized","std::clone::Clone"]}}
candidates:{"traits::Input::input_len":{"Self":["memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.input_len();
+traits::Input::input_len(p0);
+crate::traits::Input::input_len(p0);
+crate::traits::Input::input_len(p0);
-----------------
src/traits.rs traits::Input::take
deps:{"traits::Input::take":{"Self":["traits::Input","std::clone::Clone","std::marker::Sized"]}}
candidates:{"traits::Input::take":{"Self":["memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::memmem::FinderBuilder","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.take(p1);
+traits::Input::take(p0, p1);
+crate::traits::Input::take(p0, p1);
+crate::traits::Input::take(p0, p1);
-----------------
src/traits.rs traits::Input::take_from
deps:{"traits::Input::take_from":{"Self":["traits::Input","std::clone::Clone","std::marker::Sized"]}}
candidates:{"traits::Input::take_from":{"Self":["memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderRev<'n>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.take_from(p1);
+traits::Input::take_from(p0, p1);
+crate::traits::Input::take_from(p0, p1);
+crate::traits::Input::take_from(p0, p1);
-----------------
src/traits.rs traits::Input::take_split
deps:{"traits::Input::take_split":{"Self":["traits::Input","std::marker::Sized","std::clone::Clone"]}}
candidates:{"traits::Input::take_split":{"Self":["memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.take_split(p1);
+traits::Input::take_split(p0, p1);
+crate::traits::Input::take_split(p0, p1);
+crate::traits::Input::take_split(p0, p1);
-----------------
src/traits.rs traits::Input::position
deps:{"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"traits::Input::position":{"P":["std::ops::Fn","std::marker::Sized"],"Self":["std::marker::Sized","traits::Input","std::clone::Clone"]}}
candidates:{"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"traits::Input::position":{"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace"],"Self":["memchr::memmem::FinderBuilder","memchr::cow::Imp<'a>","memchr::memmem::Finder<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderRev<'n>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+traits::Input::position(p0, p1);
+crate::traits::Input::position(p0, p1);
+crate::traits::Input::position(p0, p1);
-----------------
src/traits.rs traits::Input::iter_elements
deps:{"traits::Input::iter_elements":{"Self":["std::clone::Clone","std::marker::Sized","traits::Input"]}}
candidates:{"traits::Input::iter_elements":{"Self":["memchr::memmem::FinderRev<'n>","memchr::memmem::Finder<'n>","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.iter_elements();
+traits::Input::iter_elements(p0);
+crate::traits::Input::iter_elements(p0);
+crate::traits::Input::iter_elements(p0);
-----------------
src/traits.rs traits::Input::iter_indices
deps:{"traits::Input::iter_indices":{"Self":["std::clone::Clone","traits::Input","std::marker::Sized"]}}
candidates:{"traits::Input::iter_indices":{"Self":["memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>","memchr::memmem::Finder<'n>","memchr::cow::CowBytes<'a>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.iter_indices();
+traits::Input::iter_indices(p0);
+crate::traits::Input::iter_indices(p0);
+crate::traits::Input::iter_indices(p0);
-----------------
src/traits.rs traits::Input::slice_index
deps:{"traits::Input::slice_index":{"Self":["std::marker::Sized","std::clone::Clone","traits::Input"]}}
candidates:{"traits::Input::slice_index":{"Self":["memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+traits::Input::slice_index(p0, p1);
+crate::traits::Input::slice_index(p0, p1);
+crate::traits::Input::slice_index(p0, p1);
-----------------
src/traits.rs traits::Input::split_at_position
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::Input::split_at_position":{"E":["std::marker::Sized","error::ParseError"],"P":["std::ops::Fn","std::marker::Sized"],"Self":["traits::Input","std::clone::Clone","std::marker::Sized"]}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Err","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","error::VerboseError","number::Endianness","error::ErrorKind","error::Error"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::Input::split_at_position":{"E":["error::VerboseError","error::Error"],"P":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode"],"Self":["memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position(p1);
+traits::Input::split_at_position(p0, p1);
+crate::traits::Input::split_at_position(p0, p1);
+crate::traits::Input::split_at_position(p0, p1);
-----------------
src/traits.rs traits::Input::split_at_position1
deps:{"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"traits::Input::split_at_position1":{"E":["std::marker::Sized","error::ParseError"],"P":["std::ops::Fn","std::marker::Sized"],"Self":["std::marker::Sized","traits::Input","std::clone::Clone"]}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Needed","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","internal::Err","error::ErrorKind","error::VerboseError","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"traits::Input::split_at_position1":{"E":["error::Error","error::VerboseError"],"P":["core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"],"Self":["memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>","memchr::memmem::Finder<'n>","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1(p1, p2);
+traits::Input::split_at_position1(p0, p1, p2);
+crate::traits::Input::split_at_position1(p0, p1, p2);
+crate::traits::Input::split_at_position1(p0, p1, p2);
-----------------
src/traits.rs traits::Input::split_at_position_complete
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"traits::Input::split_at_position_complete":{"E":["std::marker::Sized","error::ParseError"],"P":["std::ops::Fn","std::marker::Sized"],"Self":["std::marker::Sized","traits::Input","std::clone::Clone"]}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","error::ErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","internal::Err","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"traits::Input::split_at_position_complete":{"E":["error::Error","error::VerboseError"],"P":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"Self":["memchr::cow::Imp<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position_complete(p1);
+traits::Input::split_at_position_complete(p0, p1);
+crate::traits::Input::split_at_position_complete(p0, p1);
+crate::traits::Input::split_at_position_complete(p0, p1);
-----------------
src/traits.rs traits::Input::split_at_position1_complete
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::Input::split_at_position1_complete":{"E":["error::ParseError","std::marker::Sized"],"P":["std::ops::Fn","std::marker::Sized"],"Self":["std::marker::Sized","std::clone::Clone","traits::Input"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","internal::Needed","error::VerboseError","<*const T as std::fmt::Debug>","error::Error","number::Endianness","internal::Err"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::Input::split_at_position1_complete":{"E":["error::Error","error::VerboseError"],"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault"],"Self":["memchr::cow::Imp<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1_complete(p1, p2);
+traits::Input::split_at_position1_complete(p0, p1, p2);
+crate::traits::Input::split_at_position1_complete(p0, p1, p2);
+crate::traits::Input::split_at_position1_complete(p0, p1, p2);
-----------------
src/traits.rs traits::InputLength::input_len
deps:{"traits::InputLength::input_len":{"Self":["traits::InputLength"]}}
candidates:{"traits::InputLength::input_len":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.input_len();
+traits::InputLength::input_len(p0);
+crate::traits::InputLength::input_len(p0);
+crate::traits::InputLength::input_len(p0);
-----------------
src/traits.rs traits::Offset::offset
deps:{"traits::Offset::offset":{"Self":["traits::Offset"]}}
candidates:{"traits::Offset::offset":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.offset(p1);
+traits::Offset::offset(p0, p1);
+crate::traits::Offset::offset(p0, p1);
+crate::traits::Offset::offset(p0, p1);
-----------------
src/traits.rs traits::AsBytes::as_bytes
deps:{"traits::AsBytes::as_bytes":{"Self":["traits::AsBytes"]}}
candidates:{"traits::AsBytes::as_bytes":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.as_bytes();
+traits::AsBytes::as_bytes(p0);
+crate::traits::AsBytes::as_bytes(p0);
+crate::traits::AsBytes::as_bytes(p0);
-----------------
src/traits.rs traits::AsChar::as_char
deps:{"traits::AsChar::as_char":{"Self":["std::marker::Copy","traits::AsChar"]}}
candidates:{"traits::AsChar::as_char":{"Self":["u8","char"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.as_char();
+traits::AsChar::as_char(p0);
+crate::traits::AsChar::as_char(p0);
+crate::traits::AsChar::as_char(p0);
-----------------
src/traits.rs traits::AsChar::is_alpha
deps:{"traits::AsChar::is_alpha":{"Self":["std::marker::Copy","traits::AsChar"]}}
candidates:{"traits::AsChar::is_alpha":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_alpha();
+traits::AsChar::is_alpha(p0);
+crate::traits::AsChar::is_alpha(p0);
+crate::traits::AsChar::is_alpha(p0);
-----------------
src/traits.rs traits::AsChar::is_alphanum
deps:{"traits::AsChar::is_alphanum":{"Self":["std::marker::Copy","traits::AsChar"]}}
candidates:{"traits::AsChar::is_alphanum":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_alphanum();
+traits::AsChar::is_alphanum(p0);
+crate::traits::AsChar::is_alphanum(p0);
+crate::traits::AsChar::is_alphanum(p0);
-----------------
src/traits.rs traits::AsChar::is_dec_digit
deps:{"traits::AsChar::is_dec_digit":{"Self":["std::marker::Copy","traits::AsChar"]}}
candidates:{"traits::AsChar::is_dec_digit":{"Self":["char","u8"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_dec_digit();
+traits::AsChar::is_dec_digit(p0);
+crate::traits::AsChar::is_dec_digit(p0);
+crate::traits::AsChar::is_dec_digit(p0);
-----------------
src/traits.rs traits::AsChar::is_hex_digit
deps:{"traits::AsChar::is_hex_digit":{"Self":["traits::AsChar","std::marker::Copy"]}}
candidates:{"traits::AsChar::is_hex_digit":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_hex_digit();
+traits::AsChar::is_hex_digit(p0);
+crate::traits::AsChar::is_hex_digit(p0);
+crate::traits::AsChar::is_hex_digit(p0);
-----------------
src/traits.rs traits::AsChar::is_oct_digit
deps:{"traits::AsChar::is_oct_digit":{"Self":["std::marker::Copy","traits::AsChar"]}}
candidates:{"traits::AsChar::is_oct_digit":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_oct_digit();
+traits::AsChar::is_oct_digit(p0);
+crate::traits::AsChar::is_oct_digit(p0);
+crate::traits::AsChar::is_oct_digit(p0);
-----------------
src/traits.rs traits::AsChar::len
deps:{"traits::AsChar::len":{"Self":["std::marker::Copy","traits::AsChar"]}}
candidates:{"traits::AsChar::len":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.len();
+traits::AsChar::len(p0);
+crate::traits::AsChar::len(p0);
+crate::traits::AsChar::len(p0);
-----------------
src/traits.rs traits::Compare::compare
deps:{"traits::Compare::compare":{"Self":["traits::Compare"],"T":["std::marker::Sized"]}}
candidates:{"traits::Compare::compare":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.compare(p1);
+traits::Compare::compare(p0, p1);
+crate::traits::Compare::compare(p0, p1);
+crate::traits::Compare::compare(p0, p1);
-----------------
src/traits.rs traits::Compare::compare_no_case
deps:{"traits::Compare::compare_no_case":{"Self":["traits::Compare"],"T":["std::marker::Sized"]}}
candidates:{"traits::Compare::compare_no_case":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.compare_no_case(p1);
+traits::Compare::compare_no_case(p0, p1);
+crate::traits::Compare::compare_no_case(p0, p1);
+crate::traits::Compare::compare_no_case(p0, p1);
-----------------
src/traits.rs traits::FindToken::find_token
deps:{"traits::FindToken::find_token":{"Self":["traits::FindToken"],"T":["std::marker::Sized"]}}
candidates:{"traits::FindToken::find_token":{"Self":[],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.find_token(p1);
+traits::FindToken::find_token(p0, p1);
+crate::traits::FindToken::find_token(p0, p1);
+crate::traits::FindToken::find_token(p0, p1);
-----------------
src/traits.rs traits::FindSubstring::find_substring
deps:{"traits::FindSubstring::find_substring":{"Self":["traits::FindSubstring"],"T":["std::marker::Sized"]}}
candidates:{"traits::FindSubstring::find_substring":{"Self":[],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.find_substring(p1);
+traits::FindSubstring::find_substring(p0, p1);
+crate::traits::FindSubstring::find_substring(p0, p1);
+crate::traits::FindSubstring::find_substring(p0, p1);
-----------------
src/traits.rs traits::ParseTo::parse_to
deps:{"traits::ParseTo::parse_to":{"R":["std::marker::Sized"],"Self":["traits::ParseTo"]}}
candidates:{"traits::ParseTo::parse_to":{"R":["RUG_ANY"],"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.parse_to();
+traits::ParseTo::parse_to(p0);
+crate::traits::ParseTo::parse_to(p0);
+crate::traits::ParseTo::parse_to(p0);
-----------------
src/traits.rs traits::ExtendInto::new_builder
deps:{"traits::ExtendInto::new_builder":{"Self":["traits::ExtendInto"]}}
candidates:{"traits::ExtendInto::new_builder":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.new_builder();
+traits::ExtendInto::new_builder(p0);
+crate::traits::ExtendInto::new_builder(p0);
+crate::traits::ExtendInto::new_builder(p0);
-----------------
src/traits.rs traits::ExtendInto::extend_into
deps:{"traits::ExtendInto::extend_into":{"Self":["traits::ExtendInto"]}}
candidates:{"traits::ExtendInto::extend_into":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // <Self as traits::ExtendInto>::Extender
+p0.extend_into(p1);
+traits::ExtendInto::extend_into(p0, p1);
+crate::traits::ExtendInto::extend_into(p0, p1);
+crate::traits::ExtendInto::extend_into(p0, p1);
-----------------
src/traits.rs traits::ToUsize::to_usize
deps:{"traits::ToUsize::to_usize":{"Self":["traits::ToUsize"]}}
candidates:{"traits::ToUsize::to_usize":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_usize();
+traits::ToUsize::to_usize(p0);
+crate::traits::ToUsize::to_usize(p0);
+crate::traits::ToUsize::to_usize(p0);
-----------------
src/traits.rs traits::ErrorConvert::convert
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"traits::ErrorConvert::convert":{"E":["std::marker::Sized"],"Self":["traits::ErrorConvert"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","error::Error","internal::Needed","internal::Err","error::VerboseError","<*mut T as std::fmt::Debug>","error::ErrorKind"]},"traits::ErrorConvert::convert":{"E":["RUG_ANY"],"Self":["error::VerboseError","error::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.convert();
+traits::ErrorConvert::convert(p0);
+crate::traits::ErrorConvert::convert(p0);
+crate::traits::ErrorConvert::convert(p0);
-----------------
src/traits.rs traits::HexDisplay::to_hex
deps:{"traits::HexDisplay::to_hex":{"Self":["traits::HexDisplay"]}}
candidates:{"traits::HexDisplay::to_hex":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.to_hex(p1);
+traits::HexDisplay::to_hex(p0, p1);
+crate::traits::HexDisplay::to_hex(p0, p1);
+crate::traits::HexDisplay::to_hex(p0, p1);
-----------------
src/traits.rs traits::HexDisplay::to_hex_from
deps:{"traits::HexDisplay::to_hex_from":{"Self":["traits::HexDisplay"]}}
candidates:{"traits::HexDisplay::to_hex_from":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.to_hex_from(p1, p2);
+traits::HexDisplay::to_hex_from(p0, p1, p2);
+crate::traits::HexDisplay::to_hex_from(p0, p1, p2);
+crate::traits::HexDisplay::to_hex_from(p0, p1, p2);
-----------------
src/traits.rs traits::NomRange::contains
deps:{"std::ops::Range":{"Idx":["std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"std::ops::RangeInclusive":{"Idx":["std::marker::Sized"]},"std::ops::RangeTo":{"Idx":["std::marker::Sized"]},"std::ops::RangeToInclusive":{"Idx":["std::marker::Sized"]},"traits::NomRange::contains":{"Idx":["std::marker::Sized"],"Self":["traits::NomRange"]}}
candidates:{"std::ops::Range":{"Idx":["RUG_ANY"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"std::ops::RangeInclusive":{"Idx":["RUG_ANY"]},"std::ops::RangeTo":{"Idx":["RUG_ANY"]},"std::ops::RangeToInclusive":{"Idx":["RUG_ANY"]},"traits::NomRange::contains":{"Idx":["RUG_ANY"],"Self":["std::ops::RangeToInclusive","std::ops::RangeInclusive","std::ops::Range","std::ops::RangeFull","std::ops::RangeFrom","std::ops::RangeTo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Idx
+p0.contains(p1);
+traits::NomRange::contains(p0, p1);
+crate::traits::NomRange::contains(p0, p1);
+crate::traits::NomRange::contains(p0, p1);
-----------------
src/traits.rs traits::NomRange::bounds
deps:{"std::ops::Range":{"Idx":["std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"std::ops::RangeInclusive":{"Idx":["std::marker::Sized"]},"std::ops::RangeTo":{"Idx":["std::marker::Sized"]},"std::ops::RangeToInclusive":{"Idx":["std::marker::Sized"]},"traits::NomRange::bounds":{"Idx":["std::marker::Sized"],"Self":["traits::NomRange"]}}
candidates:{"std::ops::Range":{"Idx":["RUG_ANY"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"std::ops::RangeInclusive":{"Idx":["RUG_ANY"]},"std::ops::RangeTo":{"Idx":["RUG_ANY"]},"std::ops::RangeToInclusive":{"Idx":["RUG_ANY"]},"traits::NomRange::bounds":{"Idx":["RUG_ANY"],"Self":["std::ops::RangeFrom","std::ops::RangeToInclusive","std::ops::RangeInclusive","std::ops::RangeFull","std::ops::Range","std::ops::RangeTo"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.bounds();
+traits::NomRange::bounds(p0);
+crate::traits::NomRange::bounds(p0);
+crate::traits::NomRange::bounds(p0);
-----------------
src/traits.rs traits::NomRange::is_inverted
deps:{"std::ops::Range":{"Idx":["std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"std::ops::RangeInclusive":{"Idx":["std::marker::Sized"]},"std::ops::RangeTo":{"Idx":["std::marker::Sized"]},"std::ops::RangeToInclusive":{"Idx":["std::marker::Sized"]},"traits::NomRange::is_inverted":{"Idx":["std::marker::Sized"],"Self":["traits::NomRange"]}}
candidates:{"std::ops::Range":{"Idx":["RUG_ANY"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"std::ops::RangeInclusive":{"Idx":["RUG_ANY"]},"std::ops::RangeTo":{"Idx":["RUG_ANY"]},"std::ops::RangeToInclusive":{"Idx":["RUG_ANY"]},"traits::NomRange::is_inverted":{"Idx":["RUG_ANY"],"Self":["std::ops::RangeTo","std::ops::Range","std::ops::RangeFrom","std::ops::RangeInclusive","std::ops::RangeFull","std::ops::RangeToInclusive"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_inverted();
+traits::NomRange::is_inverted(p0);
+crate::traits::NomRange::is_inverted(p0);
+crate::traits::NomRange::is_inverted(p0);
-----------------
src/traits.rs traits::NomRange::saturating_iter
deps:{"std::ops::Range":{"Idx":["std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"std::ops::RangeInclusive":{"Idx":["std::marker::Sized"]},"std::ops::RangeTo":{"Idx":["std::marker::Sized"]},"std::ops::RangeToInclusive":{"Idx":["std::marker::Sized"]},"traits::NomRange::saturating_iter":{"Idx":["std::marker::Sized"],"Self":["traits::NomRange"]}}
candidates:{"std::ops::Range":{"Idx":["RUG_ANY"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"std::ops::RangeInclusive":{"Idx":["RUG_ANY"]},"std::ops::RangeTo":{"Idx":["RUG_ANY"]},"std::ops::RangeToInclusive":{"Idx":["RUG_ANY"]},"traits::NomRange::saturating_iter":{"Idx":["RUG_ANY"],"Self":["std::ops::RangeInclusive","std::ops::RangeFull","std::ops::RangeTo","std::ops::Range","std::ops::RangeToInclusive","std::ops::RangeFrom"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.saturating_iter();
+traits::NomRange::saturating_iter(p0);
+crate::traits::NomRange::saturating_iter(p0);
+crate::traits::NomRange::saturating_iter(p0);
-----------------
src/traits.rs traits::NomRange::bounded_iter
deps:{"std::ops::Range":{"Idx":["std::marker::Sized"]},"std::ops::RangeFrom":{"Idx":["std::marker::Sized"]},"std::ops::RangeInclusive":{"Idx":["std::marker::Sized"]},"std::ops::RangeTo":{"Idx":["std::marker::Sized"]},"std::ops::RangeToInclusive":{"Idx":["std::marker::Sized"]},"traits::NomRange::bounded_iter":{"Idx":["std::marker::Sized"],"Self":["traits::NomRange"]}}
candidates:{"std::ops::Range":{"Idx":["RUG_ANY"]},"std::ops::RangeFrom":{"Idx":["RUG_ANY"]},"std::ops::RangeInclusive":{"Idx":["RUG_ANY"]},"std::ops::RangeTo":{"Idx":["RUG_ANY"]},"std::ops::RangeToInclusive":{"Idx":["RUG_ANY"]},"traits::NomRange::bounded_iter":{"Idx":["RUG_ANY"],"Self":["std::ops::RangeInclusive","std::ops::RangeTo","std::ops::RangeFrom","std::ops::Range","std::ops::RangeFull","std::ops::RangeToInclusive"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.bounded_iter();
+traits::NomRange::bounded_iter(p0);
+crate::traits::NomRange::bounded_iter(p0);
+crate::traits::NomRange::bounded_iter(p0);
-----------------
src/error.rs <error::Error<I> as std::clone::Clone>::clone
deps:{"<*const T as std::fmt::Debug>":{},"<error::Error<I> as std::clone::Clone>::clone":{"I":["std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<error::Error<I> as std::clone::Clone>::clone":{"I":["error::VerboseError","internal::Needed","internal::Err","number::Endianness","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::Error","error::ErrorKind"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","error::Error","internal::Err","internal::Needed","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
+p0.clone();
+<error::Error<I> as std::clone::Clone>::clone(p0);
+crate::<error::Error<I> as std::clone::Clone>::clone(p0);
+<error::Error<I>>::clone(p0);
-----------------
src/error.rs <error::Error<I> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Error<I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Error<I> as std::fmt::Debug>::fmt":{"I":["error::VerboseError","error::VerboseErrorKind","number::Endianness","error::Error","traits::CompareResult","internal::Needed","<&T as std::fmt::Debug>","<*const T as std::fmt::Debug>","error::ErrorKind","internal::Err"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Needed","internal::Err","number::Endianness","error::VerboseError","error::ErrorKind","error::VerboseErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error<I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error<I> as std::fmt::Debug>::fmt(p0, p1);
+<error::Error<I>>::fmt(p0, p1);
-----------------
src/error.rs <error::Error<I> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<error::Error<I> as std::cmp::Eq>::assert_receiver_is_total_eq":{"I":["std::marker::Sized","std::cmp::Eq"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<error::Error<I> as std::cmp::Eq>::assert_receiver_is_total_eq":{"I":["std::cmp::impls::<impl std::cmp::Eq for &mut A>","error::ErrorKind","number::Endianness","internal::Err","traits::CompareResult","error::VerboseErrorKind","error::Error","internal::Needed","std::cmp::impls::<impl std::cmp::Eq for &A>","error::VerboseError"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","internal::Needed","internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseError","error::Error","error::ErrorKind"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
+p0.assert_receiver_is_total_eq();
+<error::Error<I> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::Error<I> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::Error<I>>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs <error::Error<I> as std::cmp::PartialEq>::eq
deps:{"<error::Error<I> as std::cmp::PartialEq>::eq":{"I":["std::cmp::PartialEq","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<error::Error<I> as std::cmp::PartialEq>::eq":{"I":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseError","error::ErrorKind","traits::CompareResult","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::Error","error::VerboseErrorKind","internal::Needed","internal::Err","number::Endianness"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","error::Error","internal::Needed","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
+p0.eq(p1);
+<error::Error<I> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::Error<I> as std::cmp::PartialEq>::eq(p0, p1);
+<error::Error<I>>::eq(p0, p1);
-----------------
src/error.rs error::Error::<I>::new
deps:{"error::Error::<I>::new":{"I":["std::marker::Sized"]}}
candidates:{"error::Error::<I>::new":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+error::Error::<I>::new(p0, p1);
+crate::error::Error::<I>::new(p0, p1);
+<error::Error<I>>::new(p0, p1);
-----------------
src/error.rs <error::Error<I> as error::ParseError<I>>::from_error_kind
deps:{"<error::Error<I> as error::ParseError<I>>::from_error_kind":{"I":["std::marker::Sized"]}}
candidates:{"<error::Error<I> as error::ParseError<I>>::from_error_kind":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+<error::Error<I> as error::ParseError<I>>::from_error_kind(p0, p1);
+crate::<error::Error<I> as error::ParseError<I>>::from_error_kind(p0, p1);
+<error::Error<I>>::from_error_kind(p0, p1);
-----------------
src/error.rs <error::Error<I> as error::ParseError<I>>::append
deps:{"<error::Error<I> as error::ParseError<I>>::append":{"I":["std::marker::Sized"]}}
candidates:{"<error::Error<I> as error::ParseError<I>>::append":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // error::Error<I>
+<error::Error<I> as error::ParseError<I>>::append(p0, p1, p2);
+crate::<error::Error<I> as error::ParseError<I>>::append(p0, p1, p2);
+<error::Error<I>>::append(p0, p1, p2);
-----------------
src/error.rs <error::Error<I> as error::FromExternalError<I, E>>::from_external_error
deps:{"<error::Error<I> as error::FromExternalError<I, E>>::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"]}}
candidates:{"<error::Error<I> as error::FromExternalError<I, E>>::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<error::Error<I> as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+crate::<error::Error<I> as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+<error::Error<I>>::from_external_error(p0, p1, p2);
-----------------
src/error.rs <error::Error<I> as std::fmt::Display>::fmt
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<*mut T as std::fmt::Debug>":{},"<error::Error<I> as std::fmt::Display>::fmt":{"I":["std::marker::Sized","std::fmt::Display"]},"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<*mut T as std::fmt::Debug>":{},"<error::Error<I> as std::fmt::Display>::fmt":{"I":["<&T as std::fmt::Display>","error::Error","error::VerboseError","internal::Err"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed","error::Error","error::VerboseError","number::Endianness","error::ErrorKind","internal::Err","error::VerboseErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error<I> as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error<I> as std::fmt::Display>::fmt(p0, p1);
+<error::Error<I>>::fmt(p0, p1);
-----------------
src/error.rs <error::Error<std::vec::Vec<u8>> as std::convert::From<error::Error<&[u8]>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error<&[u8]>
+<error::Error<std::vec::Vec<u8>> as std::convert::From<error::Error<&[u8]>>>::from(p0);
+crate::<error::Error<std::vec::Vec<u8>> as std::convert::From<error::Error<&[u8]>>>::from(p0);
+<error::Error<std::vec::Vec<u8>>>::from(p0);
-----------------
src/error.rs <error::Error<std::string::String> as std::convert::From<error::Error<&str>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error<&str>
+<error::Error<std::string::String> as std::convert::From<error::Error<&str>>>::from(p0);
+crate::<error::Error<std::string::String> as std::convert::From<error::Error<&str>>>::from(p0);
+<error::Error<std::string::String>>::from(p0);
-----------------
src/error.rs <(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind
deps:{"<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind":{"I":["std::marker::Sized"]}}
candidates:{"<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind(p0, p1);
+crate::<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind(p0, p1);
+<(I, error::ErrorKind)>::from_error_kind(p0, p1);
-----------------
src/error.rs <(I, error::ErrorKind) as error::ParseError<I>>::append
deps:{"<(I, error::ErrorKind) as error::ParseError<I>>::append":{"I":["std::marker::Sized"]}}
candidates:{"<(I, error::ErrorKind) as error::ParseError<I>>::append":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // (I, error::ErrorKind)
+<(I, error::ErrorKind) as error::ParseError<I>>::append(p0, p1, p2);
+crate::<(I, error::ErrorKind) as error::ParseError<I>>::append(p0, p1, p2);
+<(I, error::ErrorKind)>::append(p0, p1, p2);
-----------------
src/error.rs <(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error
deps:{"<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"]}}
candidates:{"<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+crate::<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+<(I, error::ErrorKind)>::from_external_error(p0, p1, p2);
-----------------
src/error.rs <() as error::ParseError<I>>::from_error_kind
deps:{"<() as error::ParseError<I>>::from_error_kind":{"I":["std::marker::Sized"]}}
candidates:{"<() as error::ParseError<I>>::from_error_kind":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+<() as error::ParseError<I>>::from_error_kind(p0, p1);
+crate::<() as error::ParseError<I>>::from_error_kind(p0, p1);
+<()>::from_error_kind(p0, p1);
-----------------
src/error.rs <() as error::ParseError<I>>::append
deps:{"<() as error::ParseError<I>>::append":{"I":["std::marker::Sized"]}}
candidates:{"<() as error::ParseError<I>>::append":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = (); // None+()
+<() as error::ParseError<I>>::append(p0, p1, p2);
+crate::<() as error::ParseError<I>>::append(p0, p1, p2);
+<()>::append(p0, p1, p2);
-----------------
src/error.rs <() as error::FromExternalError<I, E>>::from_external_error
deps:{"<() as error::FromExternalError<I, E>>::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"]}}
candidates:{"<() as error::FromExternalError<I, E>>::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<() as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+crate::<() as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+<()>::from_external_error(p0, p1, p2);
-----------------
src/error.rs <error::VerboseError<I> as std::clone::Clone>::clone
deps:{"<error::VerboseError<I> as std::clone::Clone>::clone":{"I":["std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<error::VerboseError<I> as std::clone::Clone>::clone":{"I":["error::VerboseErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","internal::Err","error::ErrorKind","number::Endianness","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","internal::Needed","error::Error","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+p0.clone();
+<error::VerboseError<I> as std::clone::Clone>::clone(p0);
+crate::<error::VerboseError<I> as std::clone::Clone>::clone(p0);
+<error::VerboseError<I>>::clone(p0);
-----------------
src/error.rs <error::VerboseError<I> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::fmt::Debug>::fmt":{"I":["error::Error","<&T as std::fmt::Debug>","internal::Err","<*const T as std::fmt::Debug>","error::ErrorKind","number::Endianness","traits::CompareResult","error::VerboseError","internal::Needed","error::VerboseErrorKind"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","internal::Needed","error::ErrorKind","error::Error","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::VerboseError<I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::VerboseError<I> as std::fmt::Debug>::fmt(p0, p1);
+<error::VerboseError<I>>::fmt(p0, p1);
-----------------
src/error.rs <error::VerboseError<I> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<error::VerboseError<I> as std::cmp::Eq>::assert_receiver_is_total_eq":{"I":["std::cmp::Eq","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<error::VerboseError<I> as std::cmp::Eq>::assert_receiver_is_total_eq":{"I":["error::ErrorKind","error::VerboseErrorKind","number::Endianness","internal::Err","std::cmp::impls::<impl std::cmp::Eq for &A>","internal::Needed","traits::CompareResult","error::Error","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseError"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","error::VerboseErrorKind","internal::Needed","error::VerboseError","error::ErrorKind","internal::Err","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+p0.assert_receiver_is_total_eq();
+<error::VerboseError<I> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::VerboseError<I> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::VerboseError<I>>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs <error::VerboseError<I> as std::cmp::PartialEq>::eq
deps:{"<*const T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::cmp::PartialEq>::eq":{"I":["std::cmp::PartialEq","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::cmp::PartialEq>::eq":{"I":["error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness","internal::Err","error::ErrorKind","traits::CompareResult","internal::Needed","error::Error","error::VerboseErrorKind"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::Err":{"E":["error::VerboseErrorKind","error::Error","error::VerboseError","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind","internal::Needed","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+p0.eq(p1);
+<error::VerboseError<I> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::VerboseError<I> as std::cmp::PartialEq>::eq(p0, p1);
+<error::VerboseError<I>>::eq(p0, p1);
-----------------
src/error.rs <error::VerboseErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseErrorKind
+p0.clone();
+<error::VerboseErrorKind as std::clone::Clone>::clone(p0);
+crate::<error::VerboseErrorKind as std::clone::Clone>::clone(p0);
+<error::VerboseErrorKind>::clone(p0);
-----------------
src/error.rs <error::VerboseErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::VerboseErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::VerboseErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<error::VerboseErrorKind>::fmt(p0, p1);
-----------------
src/error.rs <error::VerboseErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseErrorKind
+p0.assert_receiver_is_total_eq();
+<error::VerboseErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::VerboseErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::VerboseErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs <error::VerboseErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::VerboseErrorKind
+p0.eq(p1);
+<error::VerboseErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::VerboseErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<error::VerboseErrorKind>::eq(p0, p1);
-----------------
src/error.rs <error::VerboseError<I> as error::ParseError<I>>::from_error_kind
deps:{"<error::VerboseError<I> as error::ParseError<I>>::from_error_kind":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::ParseError<I>>::from_error_kind":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+<error::VerboseError<I> as error::ParseError<I>>::from_error_kind(p0, p1);
+crate::<error::VerboseError<I> as error::ParseError<I>>::from_error_kind(p0, p1);
+<error::VerboseError<I>>::from_error_kind(p0, p1);
-----------------
src/error.rs <error::VerboseError<I> as error::ParseError<I>>::append
deps:{"<error::VerboseError<I> as error::ParseError<I>>::append":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::ParseError<I>>::append":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+<error::VerboseError<I> as error::ParseError<I>>::append(p0, p1, p2);
+crate::<error::VerboseError<I> as error::ParseError<I>>::append(p0, p1, p2);
+<error::VerboseError<I>>::append(p0, p1, p2);
-----------------
src/error.rs <error::VerboseError<I> as error::ParseError<I>>::from_char
deps:{"<error::VerboseError<I> as error::ParseError<I>>::from_char":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::ParseError<I>>::from_char":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = 'a'; // None+char
+<error::VerboseError<I> as error::ParseError<I>>::from_char(p0, p1);
+crate::<error::VerboseError<I> as error::ParseError<I>>::from_char(p0, p1);
+<error::VerboseError<I>>::from_char(p0, p1);
-----------------
src/error.rs <error::VerboseError<I> as error::ContextError<I>>::add_context
deps:{"<error::VerboseError<I> as error::ContextError<I>>::add_context":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::ContextError<I>>::add_context":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+<error::VerboseError<I> as error::ContextError<I>>::add_context(p0, &p1, p2);
+crate::<error::VerboseError<I> as error::ContextError<I>>::add_context(p0, &p1, p2);
+<error::VerboseError<I>>::add_context(p0, &p1, p2);
-----------------
src/error.rs <error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error
deps:{"<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+crate::<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+<error::VerboseError<I>>::from_external_error(p0, p1, p2);
-----------------
src/error.rs <error::VerboseError<I> as std::fmt::Display>::fmt
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::fmt::Display>::fmt":{"I":["std::fmt::Display","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::fmt::Display>::fmt":{"I":["error::VerboseError","internal::Err","<&mut T as std::fmt::Display>","error::Error"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["error::Error","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","number::Endianness","error::ErrorKind","internal::Needed","error::VerboseError"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::VerboseError<I> as std::fmt::Display>::fmt(p0, p1);
+crate::<error::VerboseError<I> as std::fmt::Display>::fmt(p0, p1);
+<error::VerboseError<I>>::fmt(p0, p1);
-----------------
src/error.rs <error::VerboseError<std::vec::Vec<u8>> as std::convert::From<error::VerboseError<&[u8]>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::VerboseError<&[u8]>
+<error::VerboseError<std::vec::Vec<u8>> as std::convert::From<error::VerboseError<&[u8]>>>::from(p0);
+crate::<error::VerboseError<std::vec::Vec<u8>> as std::convert::From<error::VerboseError<&[u8]>>>::from(p0);
+<error::VerboseError<std::vec::Vec<u8>>>::from(p0);
-----------------
src/error.rs <error::VerboseError<std::string::String> as std::convert::From<error::VerboseError<&str>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::VerboseError<&str>
+<error::VerboseError<std::string::String> as std::convert::From<error::VerboseError<&str>>>::from(p0);
+crate::<error::VerboseError<std::string::String> as std::convert::From<error::VerboseError<&str>>>::from(p0);
+<error::VerboseError<std::string::String>>::from(p0);
-----------------
src/error.rs <error::ErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<error::ErrorKind>::fmt(p0, p1);
-----------------
src/error.rs <error::ErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.eq(p1);
+<error::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<error::ErrorKind>::eq(p0, p1);
-----------------
src/error.rs <error::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.assert_receiver_is_total_eq();
+<error::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::ErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs <error::ErrorKind as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<error::ErrorKind as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<error::ErrorKind as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<error::ErrorKind as std::hash::Hash>::hash(p0, p1);
+crate::<error::ErrorKind as std::hash::Hash>::hash(p0, p1);
+<error::ErrorKind>::hash(p0, p1);
-----------------
src/error.rs <error::ErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.clone();
+<error::ErrorKind as std::clone::Clone>::clone(p0);
+crate::<error::ErrorKind as std::clone::Clone>::clone(p0);
+<error::ErrorKind>::clone(p0);
-----------------
src/error.rs error::ErrorKind::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.description();
+error::ErrorKind::description(p0);
+crate::error::ErrorKind::description(p0);
+<error::ErrorKind>::description(p0);
-----------------
src/branch/mod.rs <(A, B) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B) as branch::Alt<Input, Output, Error>>::choice":{"A":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::And","internal::Map","internal::AndThen","internal::Into","internal::MapRes","internal::Or"],"B":["internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Map","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::And"],"Error":["error::Error","error::VerboseError"],"Input":["error::VerboseError","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::VerboseErrorKind"],"Output":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::And","internal::AndThen","internal::Or","internal::MapOpt","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::FlatMap"],"G":["internal::Map","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Or","internal::MapOpt","internal::And","internal::MapRes"]},"internal::AndThen":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::And","internal::Or","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::Into"],"G":["internal::Map","internal::FlatMap","internal::And","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::Into","internal::AndThen","internal::Or"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","internal::Err","error::VerboseError","number::Endianness","error::ErrorKind","internal::Needed","error::Error","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Map","internal::And","internal::Into","std::boxed::Box","internal::Or","internal::AndThen","internal::FlatMap"],"G":["core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::And","internal::Map","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Into","internal::AndThen","internal::FlatMap","internal::Map","internal::And","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"]},"internal::MapOpt":{"F":["internal::Map","<F as internal::Parser<I>>","internal::Or","internal::Into","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::And","internal::MapOpt","internal::AndThen"],"G":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::AndThen","internal::And","std::boxed::Box","internal::Or","internal::MapOpt","internal::MapRes"],"G":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap"]},"internal::Or":{"F":["internal::Map","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Or","internal::AndThen","internal::Into","internal::FlatMap","internal::And","<F as internal::Parser<I>>"],"G":["internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::MapRes","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"C":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"Output":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::AndThen","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::And","std::boxed::Box","internal::Or","internal::Map"],"B":["internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::MapOpt","internal::Or","internal::AndThen","std::boxed::Box","internal::Map"],"C":["internal::Map","internal::Into","internal::FlatMap","std::boxed::Box","internal::And","internal::MapOpt","internal::Or","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>"],"Error":["error::Error","error::VerboseError"],"Input":["internal::Err","error::VerboseErrorKind","number::Endianness","error::VerboseError","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>"],"Output":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Into","internal::Or","internal::And","std::boxed::Box","internal::AndThen","internal::Map","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap"],"G":["internal::Into","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::And","internal::MapOpt","internal::Or","internal::MapRes"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Map","internal::And","internal::Into","internal::AndThen","internal::Or","internal::MapRes"],"G":["std::boxed::Box","internal::Or","internal::MapOpt","internal::AndThen","internal::Into","internal::MapRes","internal::FlatMap","internal::Map","internal::And","<F as internal::Parser<I>>"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","number::Endianness","error::VerboseError","internal::Err","internal::Needed","error::VerboseErrorKind","error::Error","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::And","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapOpt","internal::MapRes","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::AndThen"],"G":["core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::FlatMap","internal::Map","internal::Into","internal::And","internal::MapRes","internal::Or","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box","internal::Or","internal::AndThen"],"G":["std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapRes","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Map","internal::FlatMap","internal::Into","internal::Or","std::boxed::Box","internal::And","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"]},"internal::Or":{"F":["internal::And","internal::FlatMap","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::Or","std::boxed::Box","internal::MapOpt","internal::Map"],"G":["internal::And","internal::MapOpt","internal::FlatMap","internal::Into","internal::AndThen","std::boxed::Box","internal::Map","internal::Or","internal::MapRes","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::FlatMap","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::And","internal::Into","internal::Or"],"B":["std::boxed::Box","internal::Or","internal::Map","internal::Into","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::FlatMap"],"C":["internal::FlatMap","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::Into","internal::MapOpt","internal::Map","internal::MapRes","<F as internal::Parser<I>>"],"D":["internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","internal::Into","internal::And","std::boxed::Box","internal::MapRes"],"Error":["error::VerboseError","error::Error"],"Input":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","error::VerboseErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>","error::Error","internal::Needed","number::Endianness"],"Output":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Map","internal::MapRes","internal::Into","std::boxed::Box","internal::MapOpt","internal::FlatMap"],"G":["internal::Map","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::Into"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::MapRes","internal::Map","internal::Or","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapOpt"],"G":["internal::Map","internal::Into","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapOpt","std::boxed::Box","internal::AndThen"]},"internal::Err":{"E":["error::VerboseErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","error::ErrorKind","number::Endianness","internal::Needed","internal::Err"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::Map","internal::Or","internal::And","std::boxed::Box","internal::Into","internal::AndThen","internal::MapRes","internal::FlatMap","internal::MapOpt"],"G":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::Map","internal::AndThen","internal::FlatMap","internal::And","internal::MapRes","internal::Into","std::boxed::Box","internal::MapOpt","internal::Or","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::Into","internal::Or","internal::MapOpt","internal::AndThen","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box"],"G":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::Map","internal::MapRes","internal::AndThen","internal::Or","internal::MapOpt"],"G":["core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::Map","std::boxed::Box","internal::And","internal::Or","internal::MapOpt","internal::FlatMap","internal::AndThen"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["std::boxed::Box","internal::MapRes","internal::Into","internal::Or","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::AndThen"],"G":["internal::Map","internal::Or","internal::MapOpt","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::And","std::boxed::Box","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["std::marker::Sized","internal::Parser"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"Input":["std::clone::Clone","std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::And","internal::Or","internal::AndThen","internal::MapOpt","std::boxed::Box"],"B":["internal::Into","internal::Or","internal::MapOpt","internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","<F as internal::Parser<I>>"],"C":["internal::AndThen","internal::Map","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap","internal::Or"],"D":["internal::MapOpt","internal::AndThen","internal::And","internal::FlatMap","internal::Into","std::boxed::Box","internal::Or","internal::Map","internal::MapRes","<F as internal::Parser<I>>"],"E":["internal::FlatMap","internal::MapOpt","internal::And","internal::MapRes","internal::Into","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::AndThen"],"Error":["error::Error","error::VerboseError"],"Input":["error::ErrorKind","internal::Needed","error::VerboseErrorKind","error::Error","number::Endianness","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Err","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>"],"Output":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::And","internal::Into","internal::MapRes","internal::Map","std::boxed::Box"],"G":["internal::AndThen","internal::FlatMap","internal::Into","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I>>","internal::Map"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Map","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Into","internal::And","std::boxed::Box"],"G":["<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::Map","internal::Into","internal::And","internal::AndThen","internal::MapOpt","internal::Or","internal::FlatMap"]},"internal::Err":{"E":["internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","error::Error","number::Endianness","error::VerboseErrorKind","internal::Err","error::VerboseError"]},"internal::FlatMap":{"F":["internal::MapRes","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::And","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::MapOpt","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::Into","internal::Map","internal::MapRes","internal::Or","internal::FlatMap"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapRes","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::And","internal::AndThen","internal::Map","internal::MapOpt"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"]},"internal::MapOpt":{"F":["internal::MapRes","internal::Or","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Into","internal::And"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace"]},"internal::MapRes":{"F":["internal::FlatMap","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::MapRes","internal::MapOpt","internal::Map","internal::AndThen","internal::And"],"G":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","internal::Or","internal::Into","internal::And","internal::MapOpt","<F as internal::Parser<I>>"],"G":["internal::And","internal::Or","internal::MapOpt","internal::Map","internal::FlatMap","std::boxed::Box","internal::Into","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["internal::Parser","std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"Output":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::And","internal::Into","internal::FlatMap","internal::Or","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Map"],"B":["internal::Map","std::boxed::Box","internal::Or","internal::MapOpt","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::AndThen"],"C":["internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Or","internal::And","internal::Map","internal::Into","internal::MapRes","internal::FlatMap"],"D":["internal::AndThen","internal::Or","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Map","internal::And","internal::Into"],"E":["internal::Into","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::And","internal::MapOpt","internal::MapRes","internal::AndThen","std::boxed::Box"],"Error":["error::VerboseError","error::Error"],"F":["internal::MapOpt","internal::MapRes","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::And","<F as internal::Parser<I>>"],"Input":["number::Endianness","error::VerboseError","internal::Err","error::ErrorKind","internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::Error","std::clone::impls::<impl std::clone::Clone for &mut T>"],"Output":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::AndThen","internal::And","internal::Into","internal::MapOpt","std::boxed::Box","internal::Map"],"G":["internal::AndThen","internal::MapOpt","internal::Into","internal::MapRes","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::And"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Into","internal::And","internal::MapOpt","internal::MapRes","internal::Or","internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>"],"G":["internal::Into","internal::MapOpt","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::And","internal::AndThen","internal::Or"]},"internal::Err":{"E":["error::Error","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseError","error::ErrorKind","internal::Needed","error::VerboseErrorKind","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["internal::MapRes","internal::MapOpt","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::Or"],"G":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::AndThen","internal::Map","internal::FlatMap","std::boxed::Box","internal::Into","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","internal::MapOpt","internal::FlatMap","internal::And","internal::Into","internal::Map","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Or","internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::And"],"G":["core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::AndThen","internal::Or","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapRes","internal::Into","internal::MapOpt"],"G":["core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::MapRes","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Map","internal::FlatMap","internal::Into","internal::And","internal::Or","<F as internal::Parser<I>>"],"G":["internal::Or","internal::And","internal::Map","internal::Into","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["internal::Parser","std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice":{"A":["<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::Or","internal::AndThen","internal::Into","internal::And","internal::FlatMap","internal::MapRes","internal::MapOpt"],"B":["std::boxed::Box","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::AndThen","internal::MapOpt","internal::And","internal::MapRes"],"C":["internal::Into","internal::FlatMap","internal::Or","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::AndThen","std::boxed::Box"],"D":["internal::Map","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Into","internal::FlatMap","internal::And"],"E":["internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::Into"],"Error":["error::Error","error::VerboseError"],"F":["internal::Or","internal::MapRes","std::boxed::Box","internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::FlatMap"],"G":["internal::FlatMap","internal::MapOpt","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::And"],"Input":["internal::Needed","error::Error","internal::Err","number::Endianness","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>"],"Output":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::Into","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::FlatMap","internal::Map","internal::MapOpt","internal::MapRes","internal::Or"],"G":["std::boxed::Box","internal::MapRes","internal::Or","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapOpt","internal::Into"]},"internal::AndThen":{"F":["internal::Map","internal::Into","internal::Or","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::MapRes","internal::AndThen"],"G":["internal::Into","internal::MapRes","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::Map"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::VerboseErrorKind","error::VerboseError","number::Endianness","internal::Err","error::ErrorKind","internal::Needed","error::Error"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapOpt","internal::Into","internal::AndThen","internal::And","internal::MapRes","std::boxed::Box","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::AndThen","internal::Or","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapOpt","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::Map","internal::Into","internal::Or","internal::FlatMap","internal::AndThen"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace"]},"internal::MapOpt":{"F":["internal::Into","internal::FlatMap","std::boxed::Box","internal::And","internal::MapOpt","internal::MapRes","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::Map"],"G":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::MapRes","internal::Or","internal::Map","std::boxed::Box","internal::Into"],"G":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::MapRes","internal::Or","internal::Map","internal::Into","internal::AndThen","internal::FlatMap"],"G":["internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::Or","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["std::marker::Sized","internal::Parser"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Map","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::And","internal::MapOpt","internal::Or"],"B":["<F as internal::Parser<I>>","internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::And","internal::Or","internal::AndThen","internal::MapOpt"],"C":["internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::Map","internal::And","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::AndThen"],"D":["internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Or","internal::Into","internal::Map","internal::And","std::boxed::Box"],"E":["<F as internal::Parser<I>>","internal::Into","internal::Or","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Map","internal::MapRes"],"Error":["error::VerboseError","error::Error"],"F":["internal::AndThen","internal::MapOpt","internal::Into","internal::Map","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::And"],"G":["internal::Map","internal::And","internal::FlatMap","internal::Or","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::Into"],"H":["<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap","internal::Map"],"Input":["error::ErrorKind","internal::Needed","error::VerboseError","internal::Err","error::VerboseErrorKind","number::Endianness","error::Error","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>"],"Output":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::And","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::AndThen","internal::Or"],"G":["internal::Or","internal::FlatMap","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::And","internal::AndThen","std::boxed::Box"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Or","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Map","internal::MapRes","internal::FlatMap"],"G":["std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::And","internal::Into","internal::MapRes","internal::MapOpt","internal::FlatMap"]},"internal::Err":{"E":["number::Endianness","internal::Needed","error::VerboseError","error::ErrorKind","error::Error","<*mut T as std::fmt::Debug>","error::VerboseErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::MapRes","internal::And","internal::FlatMap","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::AndThen","std::boxed::Box","internal::Map"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["std::boxed::Box","internal::AndThen","internal::Map","internal::MapOpt","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::Into","internal::And","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Or","internal::AndThen"],"G":["core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::And","internal::MapOpt","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"]},"internal::MapRes":{"F":["internal::Map","internal::Or","internal::MapOpt","internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::MapRes"],"G":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["internal::MapOpt","internal::AndThen","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::And","std::boxed::Box","internal::Into"],"G":["internal::Or","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["std::marker::Sized","internal::Parser"],"C":["std::marker::Sized","internal::Parser"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::AndThen","internal::MapRes","internal::Or","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Into","internal::Map"],"B":["internal::AndThen","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::Or","internal::MapRes","internal::MapOpt"],"C":["internal::And","internal::AndThen","internal::MapRes","internal::Map","internal::MapOpt","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I>>"],"D":["internal::MapOpt","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Or","internal::FlatMap","internal::MapRes","internal::And"],"E":["internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::FlatMap","internal::MapOpt","internal::Into","std::boxed::Box","internal::Map"],"Error":["error::Error","error::VerboseError"],"F":["internal::Into","internal::Or","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Map","internal::MapRes","internal::AndThen"],"G":["internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::And","internal::Or","internal::Map","internal::Into","internal::FlatMap"],"H":["internal::AndThen","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Into","internal::And","internal::MapRes","internal::Or"],"I":["internal::Map","std::boxed::Box","internal::MapRes","internal::And","internal::Or","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::FlatMap"],"Input":["number::Endianness","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Err","error::Error","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>"],"Output":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::Map","internal::MapOpt","internal::AndThen","internal::And","internal::Into"],"G":["internal::MapOpt","internal::Map","internal::Or","internal::And","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::MapRes"]},"internal::AndThen":{"F":["std::boxed::Box","internal::MapOpt","internal::Or","internal::AndThen","internal::Map","internal::And","internal::FlatMap","internal::MapRes","internal::Into","<F as internal::Parser<I>>"],"G":["internal::FlatMap","std::boxed::Box","internal::Into","internal::MapOpt","internal::Or","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapRes"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseErrorKind","number::Endianness","error::Error","internal::Err","error::ErrorKind","error::VerboseError","internal::Needed"]},"internal::FlatMap":{"F":["internal::AndThen","internal::And","std::boxed::Box","internal::Map","internal::FlatMap","internal::Or","internal::MapRes","internal::MapOpt","internal::Into","<F as internal::Parser<I>>"],"G":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::Or","internal::MapRes","internal::FlatMap","internal::And","internal::Into","internal::AndThen"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Into","internal::And","internal::Or","internal::Map","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>"],"G":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"]},"internal::MapOpt":{"F":["internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Map","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Into"],"G":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["internal::MapRes","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::FlatMap","std::boxed::Box","internal::Into","internal::Or"],"G":["core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::And","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map"],"G":["internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::Into","internal::MapRes"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"H":["std::marker::Sized","internal::Parser"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Map","internal::Into","internal::And","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen"],"B":["internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::MapOpt","internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::And"],"C":["internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapRes","internal::AndThen","internal::Or","internal::MapOpt","std::boxed::Box"],"D":["internal::Or","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::And","internal::AndThen","internal::FlatMap","std::boxed::Box"],"E":["internal::Or","internal::Map","internal::And","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into"],"Error":["error::Error","error::VerboseError"],"F":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::MapOpt","internal::Into","internal::FlatMap","internal::Map","internal::Or"],"G":["<F as internal::Parser<I>>","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::Map","internal::AndThen","internal::And"],"H":["internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Into","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Or"],"I":["internal::AndThen","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::FlatMap","internal::And","internal::MapOpt","internal::Into"],"Input":["internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","error::Error","number::Endianness"],"J":["internal::MapOpt","internal::MapRes","internal::And","std::boxed::Box","internal::Map","internal::AndThen","internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I>>"],"Output":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDefault"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["std::boxed::Box","internal::MapRes","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Or","internal::FlatMap","internal::MapOpt","internal::Map"],"G":["internal::MapRes","internal::Into","internal::And","internal::FlatMap","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt"]},"internal::AndThen":{"F":["internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Or","internal::AndThen","internal::Into","internal::MapRes","std::boxed::Box"],"G":["internal::AndThen","internal::And","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map","internal::FlatMap"]},"internal::Err":{"E":["number::Endianness","internal::Needed","error::VerboseError","error::VerboseErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","error::Error"]},"internal::FlatMap":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::Into","internal::And","internal::MapOpt","internal::Map","internal::FlatMap","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["std::boxed::Box","internal::Map","internal::MapOpt","internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Map","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::MapOpt":{"F":["internal::Map","std::boxed::Box","internal::Or","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::And"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["internal::MapOpt","internal::Or","internal::Into","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::And","internal::MapRes"],"G":["core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::Or","internal::Map","internal::MapOpt","internal::Into"],"G":["internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapOpt","internal::Or","internal::MapRes","internal::And","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["std::marker::Sized","internal::Parser"],"C":["std::marker::Sized","internal::Parser"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["std::marker::Sized","internal::Parser"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["internal::Parser","std::marker::Sized"],"K":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Or","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Map","internal::Into"],"B":["<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","internal::MapRes","internal::And","internal::MapOpt","internal::Or","internal::Map"],"C":["std::boxed::Box","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::Into","internal::AndThen","internal::And","internal::MapOpt"],"D":["<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Into","internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box","internal::Map","internal::MapOpt"],"E":["internal::Into","internal::AndThen","internal::Map","internal::And","internal::Or","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>"],"Error":["error::Error","error::VerboseError"],"F":["internal::MapRes","internal::Map","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::And","internal::AndThen","internal::Or"],"G":["<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","internal::AndThen","internal::MapOpt","internal::Or","internal::MapRes"],"H":["internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Into","internal::MapOpt","internal::Or","std::boxed::Box","internal::Map","internal::FlatMap"],"I":["internal::And","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::MapOpt"],"Input":["internal::Needed","number::Endianness","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","error::ErrorKind","error::VerboseError","error::Error","internal::Err"],"J":["internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap","internal::Or","internal::MapRes","internal::Into","internal::And"],"K":["<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::AndThen","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Map","internal::Into","internal::Or"],"Output":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::Map","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::And","internal::MapOpt"],"G":["internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::And","std::boxed::Box","internal::Map","internal::Into","internal::AndThen","internal::MapRes","internal::FlatMap"]},"internal::AndThen":{"F":["internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Into","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::MapRes"],"G":["internal::AndThen","internal::Into","std::boxed::Box","internal::Map","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Or"]},"internal::Err":{"E":["error::VerboseError","error::VerboseErrorKind","number::Endianness","error::ErrorKind","internal::Needed","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::Error"]},"internal::FlatMap":{"F":["internal::MapOpt","internal::Or","internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::And","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::Map","internal::Into","internal::MapRes","internal::MapOpt","internal::Or","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I>>"],"G":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::MapRes","internal::AndThen","internal::And","internal::Or","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::AndThen","internal::Or","internal::MapOpt","std::boxed::Box","internal::And","internal::Into"],"G":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::FlatMap","internal::And","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::AndThen","internal::Map","internal::Or"],"G":["internal::Or","std::boxed::Box","internal::Map","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Into","internal::MapOpt","internal::MapRes"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["internal::Parser","std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["internal::Parser","std::marker::Sized"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["internal::Parser","std::marker::Sized"],"K":["internal::Parser","std::marker::Sized"],"L":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::AndThen","internal::MapRes","internal::And","internal::MapOpt","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Map"],"B":["internal::MapRes","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Or","internal::MapOpt","std::boxed::Box","internal::Map"],"C":["<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Into","internal::Or","internal::And","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Map"],"D":["internal::FlatMap","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::And","internal::Map","std::boxed::Box"],"E":["internal::MapRes","internal::Into","std::boxed::Box","internal::Map","internal::FlatMap","internal::AndThen","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::And"],"Error":["error::VerboseError","error::Error"],"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Map","internal::MapOpt","internal::Into","internal::AndThen","internal::FlatMap","internal::Or","internal::And"],"G":["internal::MapRes","internal::AndThen","std::boxed::Box","internal::And","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::FlatMap"],"H":["internal::AndThen","internal::And","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Map","<F as internal::Parser<I>>"],"I":["internal::Or","internal::And","internal::MapRes","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap"],"Input":["number::Endianness","error::ErrorKind","error::Error","error::VerboseError","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed"],"J":["internal::Or","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::And"],"K":["internal::MapRes","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::Or"],"L":["internal::MapRes","internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::Into","internal::FlatMap","internal::AndThen"],"Output":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::Or","internal::AndThen","std::boxed::Box","internal::Map","internal::And","internal::Into"],"G":["<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::And","internal::MapRes","internal::Map","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Or"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::And","internal::AndThen","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Into","internal::Map"],"G":["internal::FlatMap","internal::MapRes","internal::Or","internal::AndThen","internal::And","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapOpt"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","error::VerboseError","internal::Needed","error::ErrorKind","error::Error"]},"internal::FlatMap":{"F":["internal::Into","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::And","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::FlatMap"],"G":["core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::MapOpt","internal::Map","std::boxed::Box","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into","internal::AndThen"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::AndThen","internal::Or","internal::Into","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::And"],"G":["core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::Map","internal::Or","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::And","internal::FlatMap","internal::Into"],"G":["core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsWhitespace"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen","internal::Into","internal::Or"],"G":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"]},"internal::Or":{"F":["internal::Map","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapRes"],"G":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::And","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Or","internal::Into"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized","internal::Parser"],"K":["internal::Parser","std::marker::Sized"],"L":["std::marker::Sized","internal::Parser"],"M":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice":{"A":["<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Or","internal::FlatMap","internal::Into","internal::Map","internal::MapRes","internal::AndThen","std::boxed::Box"],"B":["internal::Into","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::And","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::AndThen"],"C":["internal::AndThen","internal::Or","internal::Map","internal::Into","internal::And","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::MapRes"],"D":["internal::MapRes","internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Or","internal::Map","<F as internal::Parser<I>>"],"E":["<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::And","internal::Or","internal::Into","internal::Map"],"Error":["error::VerboseError","error::Error"],"F":["internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::Into","internal::And","internal::Or","internal::Map","internal::MapOpt"],"G":["internal::Into","internal::AndThen","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::And","internal::FlatMap","internal::Map"],"H":["internal::Or","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::Map"],"I":["internal::FlatMap","std::boxed::Box","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::AndThen","internal::And","internal::Map"],"Input":["std::clone::impls::<impl std::clone::Clone for &mut T>","number::Endianness","error::ErrorKind","error::Error","internal::Needed","error::VerboseErrorKind","internal::Err","error::VerboseError"],"J":["<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Into","internal::MapOpt","internal::Or","internal::And"],"K":["<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::MapOpt","internal::Or","internal::And","internal::Map","internal::MapRes"],"L":["internal::Map","internal::MapOpt","internal::Into","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","std::boxed::Box","internal::Or"],"M":["internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","internal::Into","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::Map"],"Output":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::And","internal::AndThen","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Or"],"G":["internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Or","std::boxed::Box","internal::Map","internal::MapRes","internal::FlatMap","internal::Into","internal::MapOpt"]},"internal::AndThen":{"F":["internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::And"],"G":["std::boxed::Box","internal::MapRes","internal::Map","internal::AndThen","internal::Into","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Or"]},"internal::Err":{"E":["internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseErrorKind","error::Error","number::Endianness","error::ErrorKind","internal::Err","error::VerboseError"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::And","internal::Map","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::MapRes"],"G":["std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["<F as internal::Parser<I>>","internal::Or","internal::Map","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::AndThen","internal::Into","internal::And","std::boxed::Box"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map","internal::And","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Or","internal::FlatMap"],"G":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::Map","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Or"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["internal::Into","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::Or","internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box"],"G":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::Map","internal::AndThen","internal::Or","internal::FlatMap","internal::Into"],"G":["<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Into","std::boxed::Box","internal::MapOpt","internal::Or","internal::Map","internal::AndThen","internal::MapRes"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["std::marker::Sized","internal::Parser"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["internal::Parser","std::marker::Sized"],"K":["std::marker::Sized","internal::Parser"],"L":["internal::Parser","std::marker::Sized"],"M":["std::marker::Sized","internal::Parser"],"N":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::MapRes","internal::Into","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Or","internal::Map"],"B":["internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::AndThen","internal::Or","internal::Map"],"C":["<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::Map","internal::Or","internal::FlatMap","internal::And","internal::MapOpt","internal::Into","std::boxed::Box"],"D":["internal::FlatMap","internal::Or","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Into","internal::And"],"E":["internal::MapRes","internal::Into","internal::Or","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Map"],"Error":["error::VerboseError","error::Error"],"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::FlatMap","internal::Map","internal::MapRes","internal::Into","internal::AndThen","internal::And","internal::MapOpt"],"G":["internal::MapRes","internal::Into","internal::MapOpt","internal::And","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box"],"H":["<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::And","internal::MapOpt","internal::Into","internal::MapRes","internal::AndThen"],"I":["internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::And"],"Input":["std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","error::VerboseErrorKind","error::ErrorKind","internal::Needed","internal::Err","number::Endianness","error::VerboseError"],"J":["internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Or","internal::Map","internal::Into","internal::MapRes","<F as internal::Parser<I>>"],"K":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Into","internal::And","internal::Map","internal::FlatMap","internal::MapOpt","internal::Or","internal::AndThen"],"L":["<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::Map","internal::And","internal::AndThen","internal::MapRes","std::boxed::Box","internal::Into","internal::FlatMap"],"M":["<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::Map","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::And"],"N":["std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapOpt","internal::AndThen","internal::Into","internal::MapRes"],"Output":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::AndThen","internal::FlatMap","internal::Into","internal::MapOpt","internal::And","internal::Or","internal::MapRes","internal::Map","<F as internal::Parser<I>>","std::boxed::Box"],"G":["internal::MapOpt","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::MapRes","internal::FlatMap","internal::Map","internal::And"]},"internal::AndThen":{"F":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapOpt","internal::Into","internal::And","internal::MapRes","internal::Or"],"G":["internal::Into","internal::MapRes","internal::FlatMap","internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Or","<F as internal::Parser<I>>"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","error::Error","number::Endianness","internal::Err","error::VerboseErrorKind","internal::Needed","error::VerboseError"]},"internal::FlatMap":{"F":["internal::Into","internal::And","internal::AndThen","internal::Map","internal::MapRes","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::Into","internal::FlatMap","internal::Map","internal::AndThen","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::And","internal::Or","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::And","internal::Map","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Or","internal::MapRes","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapRes","internal::AndThen","internal::Map","internal::Or"],"G":["core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace"]},"internal::MapRes":{"F":["std::boxed::Box","internal::MapOpt","internal::MapRes","internal::Map","internal::AndThen","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::FlatMap","internal::And","internal::MapOpt","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Or","std::boxed::Box","internal::Into"],"G":["internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::Or","internal::And","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["std::marker::Sized","internal::Parser"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["internal::Parser","std::marker::Sized"],"K":["std::marker::Sized","internal::Parser"],"L":["std::marker::Sized","internal::Parser"],"M":["std::marker::Sized","internal::Parser"],"N":["internal::Parser","std::marker::Sized"],"O":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Map","internal::Or","internal::Into","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::MapRes"],"B":["internal::Into","internal::MapRes","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::And","internal::MapOpt"],"C":["internal::Or","internal::MapRes","internal::Map","internal::FlatMap","internal::MapOpt","internal::Into","std::boxed::Box","internal::AndThen","internal::And","<F as internal::Parser<I>>"],"D":["internal::Map","internal::Into","internal::AndThen","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::And","std::boxed::Box","internal::FlatMap"],"E":["<F as internal::Parser<I>>","internal::Or","internal::And","internal::Map","std::boxed::Box","internal::MapOpt","internal::Into","internal::FlatMap","internal::MapRes","internal::AndThen"],"Error":["error::Error","error::VerboseError"],"F":["std::boxed::Box","internal::Into","internal::Map","internal::MapOpt","internal::FlatMap","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen"],"G":["std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapOpt","internal::Into","internal::MapRes","internal::Map","internal::FlatMap","internal::AndThen"],"H":["std::boxed::Box","internal::Or","internal::And","internal::FlatMap","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::AndThen"],"I":["<F as internal::Parser<I>>","internal::Into","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Map","internal::Or","internal::And","internal::FlatMap","internal::MapRes"],"Input":["error::ErrorKind","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for &T>","error::Error","error::VerboseError","internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>"],"J":["internal::And","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Into"],"K":["internal::FlatMap","internal::Map","internal::And","internal::MapRes","internal::Into","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Or","<F as internal::Parser<I>>"],"L":["<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::And","std::boxed::Box","internal::MapRes","internal::Into","internal::Or","internal::FlatMap","internal::MapOpt"],"M":["internal::AndThen","internal::FlatMap","internal::Map","internal::Into","internal::MapRes","std::boxed::Box","internal::Or","internal::MapOpt","internal::And","<F as internal::Parser<I>>"],"N":["internal::FlatMap","internal::MapRes","internal::Map","internal::Or","internal::Into","std::boxed::Box","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::AndThen"],"O":["internal::Map","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::And","internal::MapRes","std::boxed::Box","internal::Or","internal::FlatMap","internal::AndThen"],"Output":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Map","std::boxed::Box","internal::MapOpt","internal::And","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::MapRes","internal::FlatMap"],"G":["internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::And","internal::Or","internal::MapRes","internal::Map"]},"internal::AndThen":{"F":["internal::Or","internal::Map","internal::And","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Into","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>"],"G":["internal::MapRes","internal::MapOpt","internal::Or","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::And","internal::AndThen","internal::Map"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","error::VerboseError","number::Endianness","error::ErrorKind","internal::Needed","error::Error","error::VerboseErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::Map","internal::Into","internal::MapOpt","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::AndThen","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::FlatMap","internal::AndThen","internal::And","internal::Into","std::boxed::Box","internal::Or","internal::MapOpt"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Into","internal::Map","internal::Or","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::AndThen","internal::And"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::CharEscapeDefault"]},"internal::MapOpt":{"F":["internal::AndThen","internal::MapRes","internal::Or","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::And","internal::Map"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Into","internal::And","internal::Map","internal::MapOpt","internal::AndThen","internal::FlatMap"],"G":["core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::Map","internal::And","internal::AndThen","internal::MapRes","internal::Into","internal::MapOpt","std::boxed::Box","internal::Or","internal::FlatMap","<F as internal::Parser<I>>"],"G":["internal::Into","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Or","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["internal::Parser","std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"H":["internal::Parser","std::marker::Sized"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized","internal::Parser"],"K":["std::marker::Sized","internal::Parser"],"L":["internal::Parser","std::marker::Sized"],"M":["std::marker::Sized","internal::Parser"],"N":["internal::Parser","std::marker::Sized"],"O":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"],"P":["std::marker::Sized","internal::Parser"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::MapOpt","std::boxed::Box","internal::And","internal::FlatMap","internal::Or","internal::MapRes"],"B":["internal::Map","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::And","internal::Or","internal::MapOpt","internal::MapRes"],"C":["<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::Map","internal::AndThen","internal::And","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::Into"],"D":["internal::Or","internal::FlatMap","internal::MapOpt","internal::And","internal::Into","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::Map"],"E":["internal::Into","internal::And","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes"],"Error":["error::VerboseError","error::Error"],"F":["std::boxed::Box","internal::Or","internal::FlatMap","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::AndThen","internal::And"],"G":["internal::MapOpt","internal::And","internal::MapRes","internal::Map","internal::Or","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>"],"H":["internal::Or","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::MapOpt","internal::Map","internal::FlatMap","internal::AndThen"],"I":["internal::And","internal::Or","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::MapOpt"],"Input":["error::Error","error::VerboseError","internal::Needed","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseErrorKind","error::ErrorKind"],"J":["internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::And"],"K":["internal::And","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::Map","internal::MapOpt","internal::MapRes"],"L":["internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Or"],"M":["internal::MapRes","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::And","internal::Or","internal::AndThen"],"N":["internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::MapRes","internal::And","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap"],"O":["internal::FlatMap","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Or","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::Into"],"Output":["RUG_ANY"],"P":["internal::MapRes","internal::FlatMap","internal::MapOpt","internal::Or","internal::Into","internal::And","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Map"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::And","internal::FlatMap","internal::MapOpt","internal::Into","internal::MapRes","internal::Map","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box"],"G":["internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Map","internal::MapOpt","internal::Into","internal::MapRes","internal::And","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::AndThen","internal::Into","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::And","internal::MapOpt","internal::FlatMap"],"G":["internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box","internal::Or","internal::FlatMap"]},"internal::Err":{"E":["number::Endianness","error::Error","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","<*mut T as std::fmt::Debug>","internal::Err","internal::Needed"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::Into","internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::AndThen","internal::MapRes"],"G":["core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::FlatMap","internal::And","internal::MapOpt","internal::Into","internal::Map","internal::AndThen","std::boxed::Box"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::Into","internal::MapOpt","internal::Map","internal::AndThen","std::boxed::Box"],"G":["core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["internal::And","internal::Into","internal::Or","internal::AndThen","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::MapOpt"],"G":["core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["std::boxed::Box","internal::Into","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::MapRes","internal::And","internal::Or","<F as internal::Parser<I>>","internal::Map"],"G":["core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::Map","internal::MapRes","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Into","internal::Or","internal::And","<F as internal::Parser<I>>"],"G":["internal::FlatMap","internal::MapRes","internal::AndThen","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::Or","internal::MapOpt"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["std::marker::Sized","internal::Parser"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized","internal::Parser"],"K":["internal::Parser","std::marker::Sized"],"L":["internal::Parser","std::marker::Sized"],"M":["std::marker::Sized","internal::Parser"],"N":["std::marker::Sized","internal::Parser"],"O":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"],"P":["internal::Parser","std::marker::Sized"],"Q":["internal::Parser","std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::boxed::Box","internal::Or","internal::AndThen","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::MapRes"],"B":["internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::Into","internal::And","internal::Or","internal::MapRes"],"C":["internal::MapRes","internal::Or","internal::FlatMap","internal::AndThen","internal::And","internal::Into","std::boxed::Box","internal::Map","internal::MapOpt","<F as internal::Parser<I>>"],"D":["internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::Or","internal::Map","internal::Into","internal::MapOpt"],"E":["<F as internal::Parser<I>>","internal::Or","internal::Map","internal::MapOpt","internal::FlatMap","internal::Into","internal::MapRes","internal::And","internal::AndThen","std::boxed::Box"],"Error":["error::VerboseError","error::Error"],"F":["internal::AndThen","internal::And","internal::Into","internal::FlatMap","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::MapOpt"],"G":["internal::MapRes","std::boxed::Box","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::MapOpt","internal::Into","internal::Map"],"H":["internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Map","internal::FlatMap","internal::AndThen","internal::Or","internal::Into"],"I":["internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","internal::MapOpt","internal::And","internal::AndThen","internal::MapRes"],"Input":["internal::Err","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","error::Error","internal::Needed","number::Endianness","error::VerboseErrorKind"],"J":["internal::Or","internal::Map","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::Into","internal::And","<F as internal::Parser<I>>"],"K":["internal::Or","std::boxed::Box","internal::And","internal::MapRes","internal::Into","internal::Map","internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt"],"L":["internal::And","internal::Or","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::MapOpt"],"M":["<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::FlatMap","internal::Map","internal::MapRes","internal::Into","std::boxed::Box","internal::MapOpt","internal::And"],"N":["<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Into","internal::And","internal::Or","internal::AndThen"],"O":["internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::Into","internal::And"],"Output":["RUG_ANY"],"P":["internal::Map","internal::Or","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::And","internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","internal::Into"],"Q":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Map","internal::Into","internal::Or","internal::And","internal::AndThen","internal::MapOpt","internal::FlatMap"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Or","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Into"],"G":["<F as internal::Parser<I>>","internal::Into","internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Or"]},"internal::AndThen":{"F":["internal::Map","internal::MapOpt","std::boxed::Box","internal::Into","internal::MapRes","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen"],"G":["internal::Into","internal::FlatMap","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Map"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","error::VerboseError","internal::Err","error::VerboseErrorKind","number::Endianness","error::Error","<*const T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::Into","internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::Into","internal::Or","internal::AndThen","internal::And","internal::MapRes","internal::FlatMap","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","std::boxed::Box"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::MapRes","internal::Map","internal::FlatMap","internal::And","internal::Or","internal::Into"],"G":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Into","internal::AndThen","internal::Map","internal::MapRes","internal::MapOpt"],"G":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::Or","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::Map","internal::Into","internal::AndThen","internal::And"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::Map","internal::Or","internal::Into","internal::MapOpt","internal::FlatMap","internal::And","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen"],"G":["internal::Into","std::boxed::Box","internal::Or","internal::MapRes","internal::And","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Map","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["std::marker::Sized","internal::Parser"],"C":["internal::Parser","std::marker::Sized"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["internal::Parser","std::marker::Sized"],"K":["std::marker::Sized","internal::Parser"],"L":["std::marker::Sized","internal::Parser"],"M":["internal::Parser","std::marker::Sized"],"N":["std::marker::Sized","internal::Parser"],"O":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"],"P":["internal::Parser","std::marker::Sized"],"Q":["std::marker::Sized","internal::Parser"],"R":["std::marker::Sized","internal::Parser"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::And","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Map","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen"],"B":["internal::MapRes","internal::And","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::Map"],"C":["internal::Map","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::And","internal::FlatMap","internal::MapRes","internal::Or"],"D":["internal::Into","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapOpt","internal::Map","internal::And","internal::AndThen","internal::FlatMap"],"E":["internal::Map","internal::MapRes","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Into","internal::FlatMap","internal::MapOpt","std::boxed::Box"],"Error":["error::Error","error::VerboseError"],"F":["internal::MapOpt","internal::FlatMap","internal::MapRes","internal::Map","internal::Into","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::AndThen"],"G":["internal::MapOpt","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::MapRes","internal::AndThen","internal::And","internal::FlatMap","internal::Into","internal::Map"],"H":["internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::And","internal::MapRes","internal::Map","internal::Or"],"I":["internal::Into","internal::And","internal::Or","internal::FlatMap","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Map","internal::MapRes","<F as internal::Parser<I>>"],"Input":["internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","internal::Err","error::VerboseErrorKind","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","error::Error"],"J":["std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::And","internal::AndThen","internal::Into","internal::FlatMap","internal::Or"],"K":["std::boxed::Box","internal::Or","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Into","internal::AndThen","internal::And"],"L":["internal::Into","internal::MapRes","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Map"],"M":["internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Map","internal::MapRes","internal::Into","internal::And","internal::Or"],"N":["internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Into","std::boxed::Box","internal::MapRes","internal::Map","internal::MapOpt"],"O":["internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Into"],"Output":["RUG_ANY"],"P":["internal::And","internal::Map","internal::Into","internal::MapOpt","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen"],"Q":["internal::MapOpt","internal::Or","internal::Map","internal::And","internal::MapRes","internal::AndThen","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap"],"R":["<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapRes","std::boxed::Box","internal::Into","internal::Or","internal::FlatMap","internal::MapOpt","internal::AndThen"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::Into","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Or"],"G":["internal::MapOpt","internal::FlatMap","internal::And","internal::MapRes","internal::Into","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::Or"]},"internal::AndThen":{"F":["internal::MapOpt","internal::Into","internal::AndThen","internal::And","std::boxed::Box","internal::MapRes","internal::Map","internal::FlatMap","internal::Or","<F as internal::Parser<I>>"],"G":["<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::And","internal::MapRes","internal::FlatMap","internal::Into","internal::AndThen","internal::Map","internal::MapOpt"]},"internal::Err":{"E":["number::Endianness","internal::Needed","error::Error","error::VerboseError","<*const T as std::fmt::Debug>","error::VerboseErrorKind","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::FlatMap","internal::Map","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::Into","internal::MapOpt"],"G":["core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::And","internal::Or","internal::MapRes","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Map","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::MapRes","internal::FlatMap","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::And"],"G":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"]},"internal::MapOpt":{"F":["internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Or","internal::MapRes","internal::And","internal::AndThen","internal::Map"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::MapRes","internal::Map","internal::Into","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I>>"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap"]},"internal::Or":{"F":["internal::AndThen","internal::And","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapRes","std::boxed::Box","internal::Map"],"G":["std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapRes","internal::Into","internal::MapOpt"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["std::marker::Sized","internal::Parser"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["internal::Parser","std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized","internal::Parser"],"K":["std::marker::Sized","internal::Parser"],"L":["internal::Parser","std::marker::Sized"],"M":["std::marker::Sized","internal::Parser"],"N":["std::marker::Sized","internal::Parser"],"O":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"],"P":["std::marker::Sized","internal::Parser"],"Q":["std::marker::Sized","internal::Parser"],"R":["internal::Parser","std::marker::Sized"],"S":["internal::Parser","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Into","std::boxed::Box","internal::AndThen","internal::Or","internal::Map","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes"],"B":["<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::MapRes","std::boxed::Box","internal::And","internal::Map","internal::FlatMap","internal::Into","internal::MapOpt"],"C":["internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Map","internal::Into","internal::MapOpt","internal::And","internal::FlatMap","internal::AndThen"],"D":["internal::Into","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I>>","internal::Or"],"E":["internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Map"],"Error":["error::Error","error::VerboseError"],"F":["internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::Into"],"G":["internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::MapOpt","internal::Or","internal::MapRes","internal::FlatMap"],"H":["internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::MapOpt","internal::MapRes","internal::And","internal::Into","internal::AndThen"],"I":["internal::Into","internal::MapOpt","internal::AndThen","internal::Or","internal::And","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","std::boxed::Box","internal::MapRes"],"Input":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","internal::Err","number::Endianness","error::Error","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind"],"J":["internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Or","internal::Into","internal::And","internal::MapRes"],"K":["internal::AndThen","internal::And","internal::FlatMap","internal::MapOpt","internal::Or","internal::Map","internal::Into","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>"],"L":["<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Into","internal::Or","internal::FlatMap","internal::MapRes","internal::Map","internal::AndThen","std::boxed::Box"],"M":["internal::MapRes","internal::Into","internal::MapOpt","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::Or","internal::FlatMap"],"N":["internal::AndThen","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::And","internal::MapRes","internal::Map","internal::MapOpt"],"O":["internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::And","std::boxed::Box","internal::Or","internal::Map","internal::MapRes","internal::MapOpt"],"Output":["RUG_ANY"],"P":["internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Into","internal::Or","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::AndThen"],"Q":["internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapRes"],"R":["internal::Map","internal::AndThen","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::Or","<F as internal::Parser<I>>"],"S":["internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::Or","std::boxed::Box","internal::AndThen","internal::MapRes"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::And","internal::Into","internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::AndThen","internal::MapOpt"],"G":["internal::And","internal::MapRes","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Into"]},"internal::AndThen":{"F":["internal::Into","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::Map","internal::MapOpt","std::boxed::Box","internal::Or"],"G":["std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::FlatMap","internal::MapOpt","internal::Into","internal::And","internal::AndThen"]},"internal::Err":{"E":["number::Endianness","<*mut T as std::fmt::Debug>","error::VerboseErrorKind","error::ErrorKind","internal::Needed","error::Error","internal::Err","error::VerboseError"]},"internal::FlatMap":{"F":["internal::MapRes","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::And","internal::MapOpt","internal::AndThen","internal::Map","internal::Or"],"G":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::And","internal::Or","internal::MapRes","internal::MapOpt","internal::Map","internal::AndThen","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::FlatMap","internal::MapRes","internal::And","internal::Into","internal::Or"],"G":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::And","internal::Map","internal::MapRes","internal::Into","internal::FlatMap","internal::Or"],"G":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::MapOpt","internal::And","internal::Map"],"G":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map","internal::And","internal::Into"],"G":["internal::MapOpt","internal::MapRes","internal::Map","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::Or","internal::AndThen","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["std::marker::Sized","internal::Parser"],"D":["std::marker::Sized","internal::Parser"],"E":["internal::Parser","std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized","internal::Parser"],"K":["internal::Parser","std::marker::Sized"],"L":["internal::Parser","std::marker::Sized"],"M":["std::marker::Sized","internal::Parser"],"N":["std::marker::Sized","internal::Parser"],"O":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"],"P":["internal::Parser","std::marker::Sized"],"Q":["std::marker::Sized","internal::Parser"],"R":["std::marker::Sized","internal::Parser"],"S":["internal::Parser","std::marker::Sized"],"T":["internal::Parser","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Or","internal::MapRes","internal::And","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen"],"B":["internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::MapOpt","internal::AndThen","internal::Into","internal::FlatMap"],"C":["internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::FlatMap","internal::MapOpt","internal::And","internal::Into","std::boxed::Box","internal::MapRes"],"D":["internal::Into","internal::Or","std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::And"],"E":["internal::Or","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::And","internal::Into"],"Error":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::Or","internal::Map","internal::And","std::boxed::Box","internal::Into","internal::AndThen"],"G":["std::boxed::Box","internal::Map","internal::AndThen","internal::Or","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::Into"],"H":["internal::Into","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Map","internal::AndThen"],"I":["internal::AndThen","internal::FlatMap","internal::Or","internal::Into","internal::And","internal::MapRes","internal::Map","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>"],"Input":["error::VerboseError","number::Endianness","std::clone::impls::<impl std::clone::Clone for &mut T>","error::ErrorKind","error::VerboseErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","error::Error","internal::Err"],"J":["internal::Into","internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Or"],"K":["internal::Or","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Into","internal::And","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Map"],"L":["internal::Into","internal::MapRes","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::Or"],"M":["internal::Or","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::Into","std::boxed::Box"],"N":["internal::MapOpt","internal::FlatMap","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::AndThen","internal::And","internal::Into"],"O":["internal::Or","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::And","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::AndThen"],"Output":["RUG_ANY"],"P":["internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map","internal::Into","internal::Or"],"Q":["<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Or","internal::AndThen","internal::FlatMap","internal::MapRes","internal::Into","std::boxed::Box","internal::Map"],"R":["internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::AndThen","internal::MapRes","internal::Or","internal::And","internal::FlatMap"],"S":["internal::Map","internal::Or","internal::MapOpt","internal::Into","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I>>"],"T":["std::boxed::Box","internal::AndThen","internal::MapRes","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Into","internal::MapOpt","internal::Or"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::AndThen","internal::Map","std::boxed::Box","internal::Into","internal::MapOpt"],"G":["internal::MapRes","internal::MapOpt","internal::AndThen","internal::Into","internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::And"]},"internal::AndThen":{"F":["internal::AndThen","internal::FlatMap","internal::MapRes","internal::Map","internal::Or","internal::MapOpt","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::Into"],"G":["internal::Into","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Or","internal::Map","internal::And"]},"internal::Err":{"E":["error::Error","internal::Needed","number::Endianness","error::ErrorKind","error::VerboseErrorKind","<*mut T as std::fmt::Debug>","internal::Err","error::VerboseError"]},"internal::FlatMap":{"F":["internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::And","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen"],"G":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::FlatMap","std::boxed::Box","internal::MapRes","internal::And","internal::AndThen","internal::Map","internal::Or","internal::MapOpt","internal::Into","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::Or","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::And","std::boxed::Box","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"internal::MapOpt":{"F":["internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::And","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Or","internal::Map"],"G":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Into","std::boxed::Box","internal::MapRes","internal::Map","internal::And","internal::Or","internal::FlatMap"],"G":["core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into","internal::MapOpt","internal::Map","internal::AndThen","std::boxed::Box","internal::FlatMap"],"G":["internal::FlatMap","internal::Or","internal::And","internal::MapOpt","internal::MapRes","internal::Into","internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["std::marker::Sized","internal::Parser"],"E":["internal::Parser","std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["internal::Parser","std::marker::Sized"],"K":["std::marker::Sized","internal::Parser"],"L":["internal::Parser","std::marker::Sized"],"M":["std::marker::Sized","internal::Parser"],"N":["std::marker::Sized","internal::Parser"],"O":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"],"P":["internal::Parser","std::marker::Sized"],"Q":["std::marker::Sized","internal::Parser"],"R":["std::marker::Sized","internal::Parser"],"S":["std::marker::Sized","internal::Parser"],"T":["std::marker::Sized","internal::Parser"],"U":["std::marker::Sized","internal::Parser"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::Into","std::boxed::Box","internal::FlatMap","internal::Or","internal::And","internal::MapOpt"],"B":["internal::And","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::Into"],"C":["internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::And","internal::MapRes","internal::Map","internal::MapOpt"],"D":["internal::MapRes","internal::And","internal::Map","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Into"],"E":["internal::And","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::Map","internal::MapOpt","internal::FlatMap","std::boxed::Box"],"Error":["error::VerboseError","error::Error"],"F":["internal::Or","internal::MapOpt","internal::FlatMap","internal::And","internal::MapRes","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::Into"],"G":["internal::Or","std::boxed::Box","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::And","internal::AndThen","internal::Map"],"H":["internal::MapOpt","internal::AndThen","internal::MapRes","internal::Into","std::boxed::Box","internal::And","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::FlatMap"],"I":["internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::And","internal::FlatMap"],"Input":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","error::Error","internal::Err","number::Endianness","error::VerboseErrorKind","internal::Needed"],"J":["internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::And","std::boxed::Box","internal::MapOpt","internal::Map","internal::AndThen","internal::MapRes","internal::Or"],"K":["internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Into","internal::And","internal::AndThen","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::Or"],"L":["internal::AndThen","internal::MapOpt","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Into","std::boxed::Box","internal::Or"],"M":["internal::Into","std::boxed::Box","internal::Or","internal::MapRes","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::FlatMap"],"N":["internal::Or","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::Into","internal::Map","internal::AndThen","internal::FlatMap","internal::MapRes","internal::And"],"O":["internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::MapRes","internal::And","internal::MapOpt","internal::Into"],"Output":["RUG_ANY"],"P":["internal::FlatMap","internal::Into","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::Map","internal::AndThen","internal::MapRes"],"Q":["internal::AndThen","internal::Map","internal::And","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::Or"],"R":["<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::MapRes","internal::Or","internal::Map","internal::AndThen","std::boxed::Box","internal::Into","internal::FlatMap"],"S":["internal::Into","internal::Or","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Map"],"T":["internal::MapOpt","std::boxed::Box","internal::And","internal::Or","internal::MapRes","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::FlatMap"],"U":["internal::And","internal::MapRes","internal::Map","internal::Into","std::boxed::Box","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::CharEscapeUnicode"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::Or","internal::MapRes","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::MapOpt","internal::Into","internal::AndThen"],"G":["internal::MapRes","internal::Into","internal::Map","internal::And","internal::FlatMap","internal::AndThen","internal::Or","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::Into","internal::FlatMap","internal::Map","internal::Or","internal::MapRes","internal::And","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt"],"G":["internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::And","internal::Or","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Map"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Needed","internal::Err","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","error::Error","error::ErrorKind"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::Or","internal::MapRes","internal::And","internal::Map","internal::FlatMap","internal::AndThen","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::And","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Into","internal::Or","internal::AndThen"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::MapRes","internal::And","internal::Into","internal::AndThen","internal::Or","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::MapOpt":{"F":["internal::Into","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Or"],"G":["core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::MapOpt","internal::FlatMap","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Map","std::boxed::Box","internal::Into","internal::Or"],"G":["core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::And","internal::AndThen","internal::Into"],"G":["internal::FlatMap","internal::Into","internal::MapOpt","internal::Or","internal::MapRes","internal::And","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A,) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A,) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A,) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::And","internal::MapRes"],"Error":["error::VerboseError","error::Error"],"Input":["RUG_ANY"],"Output":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Into","std::boxed::Box","internal::And","internal::Map","internal::Or","internal::MapRes","internal::FlatMap"],"G":["internal::FlatMap","internal::Into","internal::MapOpt","internal::Or","internal::And","std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::Or","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::AndThen","internal::Into","internal::And","<F as internal::Parser<I>>","internal::Map"],"G":["internal::MapRes","internal::Into","internal::FlatMap","std::boxed::Box","internal::Map","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::And"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","number::Endianness","error::VerboseErrorKind","error::Error","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::And","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Into","internal::Or"],"G":["core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::MapRes","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::And","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","internal::Map","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>"]},"internal::MapOpt":{"F":["internal::And","internal::MapRes","internal::Into","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","std::boxed::Box"],"G":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapRes","internal::MapOpt","internal::Or","std::boxed::Box","internal::FlatMap"],"G":["core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"]},"internal::Or":{"F":["internal::AndThen","internal::Into","internal::Map","internal::Or","internal::FlatMap","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box"],"G":["internal::Into","internal::And","internal::FlatMap","internal::MapRes","internal::AndThen","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A,)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A,) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A,) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A,)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"FnA":["internal::FlatMap","internal::And","internal::Or","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::Map"],"FnB":["internal::MapRes","internal::Into","internal::And","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::Map"],"Input":["internal::Needed","internal::Err","error::VerboseError","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","error::Error","error::VerboseErrorKind","number::Endianness"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::MapRes","internal::Map","internal::MapOpt","internal::FlatMap","internal::Into","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::AndThen"],"G":["internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::FlatMap","internal::And","internal::Into","internal::MapRes","internal::Map"]},"internal::AndThen":{"F":["internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::MapOpt","std::boxed::Box","internal::Map","internal::FlatMap","internal::MapRes","internal::And"],"G":["internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::MapOpt","internal::And","internal::Or","internal::Map"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","number::Endianness","internal::Needed","error::Error","error::VerboseError","internal::Err","<*const T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::Map","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Into"],"G":["core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::Or","internal::And","internal::FlatMap","internal::Map","internal::MapRes","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::Into","internal::MapOpt","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::And"],"G":["core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::Or","internal::AndThen","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::And","internal::Into","std::boxed::Box","internal::MapOpt"],"G":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Or","internal::And","std::boxed::Box","internal::Into","internal::AndThen"],"G":["core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr"]},"internal::Or":{"F":["internal::AndThen","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::Or","internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::And"],"G":["internal::Or","internal::MapRes","internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::And","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation(p0, p1);
+<(FnA, FnB)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"FnA":["std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::And","internal::MapOpt","internal::Map","internal::Or","internal::FlatMap","internal::AndThen"],"FnB":["<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::Or","std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::MapOpt","internal::Map"],"FnC":["internal::Or","std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Map","internal::Into","internal::MapOpt"],"Input":["error::VerboseError","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","error::ErrorKind","internal::Needed","internal::Err","number::Endianness"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::FlatMap","internal::MapOpt","internal::Into","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen"],"G":["internal::MapRes","internal::Into","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Map"]},"internal::AndThen":{"F":["internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Into","internal::MapRes","internal::FlatMap","internal::Map","std::boxed::Box"],"G":["internal::And","internal::AndThen","internal::Map","internal::Or","internal::MapRes","internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","error::VerboseError","internal::Needed","error::Error","number::Endianness","error::VerboseErrorKind","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Map","internal::Or","internal::MapOpt","internal::MapRes","internal::Into","internal::And"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::And","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Or","internal::MapRes","internal::Map","std::boxed::Box"],"G":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty"]},"internal::MapOpt":{"F":["internal::Or","internal::Map","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>"],"G":["core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::Into","internal::Or","std::boxed::Box","internal::And","internal::MapRes","internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>"],"G":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["std::boxed::Box","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::Map","internal::Into","internal::And","internal::AndThen"],"G":["internal::MapOpt","internal::Into","internal::And","std::boxed::Box","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"FnA":["internal::MapRes","internal::Or","internal::AndThen","internal::Into","internal::FlatMap","internal::MapOpt","internal::Map","internal::And","std::boxed::Box","<F as internal::Parser<I>>"],"FnB":["internal::FlatMap","internal::AndThen","internal::And","internal::Or","internal::Map","std::boxed::Box","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::MapOpt"],"FnC":["internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Map","internal::AndThen","std::boxed::Box","internal::Or","internal::And"],"FnD":["<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::Into","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::And","internal::AndThen","internal::Map"],"Input":["internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::ErrorKind","error::Error","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","internal::Err"]},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::AndThen","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::Into","internal::Or"],"G":["internal::Into","internal::FlatMap","internal::Map","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Or","internal::And"]},"internal::AndThen":{"F":["internal::Into","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapRes","internal::Or","std::boxed::Box","internal::MapOpt"],"G":["internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::MapRes","internal::Into","internal::AndThen"]},"internal::Err":{"E":["error::VerboseError","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","internal::Err","error::Error","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::MapOpt","internal::Into","internal::MapRes","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::Or"],"G":["core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::And","internal::MapOpt","internal::Into","internal::FlatMap","std::boxed::Box"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Map","internal::Or","std::boxed::Box","internal::MapOpt","internal::Into","internal::AndThen"],"G":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::And","internal::AndThen"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["internal::Map","internal::FlatMap","internal::AndThen","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::And","std::boxed::Box"],"G":["core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::Map","internal::AndThen","internal::Into","internal::MapRes","internal::MapOpt","internal::And","std::boxed::Box"],"G":["internal::Or","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::And"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"FnA":["internal::Into","internal::Or","internal::MapRes","internal::AndThen","internal::Map","std::boxed::Box","internal::And","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>"],"FnB":["std::boxed::Box","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Map","internal::Or","internal::FlatMap","internal::And"],"FnC":["<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::AndThen","internal::Into","internal::MapOpt","internal::Map","internal::MapRes","internal::Or","std::boxed::Box"],"FnD":["internal::Or","internal::And","std::boxed::Box","internal::MapRes","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::FlatMap"],"FnE":["internal::MapRes","internal::MapOpt","internal::Into","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Map"],"Input":["error::VerboseError","internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","error::Error"]},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::FlatMap","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Or","internal::MapOpt","internal::AndThen","internal::Into","internal::Map"],"G":["std::boxed::Box","internal::MapRes","internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::MapOpt","internal::Into"]},"internal::AndThen":{"F":["internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Map","std::boxed::Box","internal::Or","internal::Into","internal::MapRes","internal::And","<F as internal::Parser<I>>"],"G":["internal::FlatMap","internal::Into","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::Or"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","number::Endianness","error::Error","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::Into","internal::And","internal::AndThen","internal::MapRes"],"G":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::And"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::AndThen","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::FlatMap"],"G":["core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::MapOpt","internal::MapRes","internal::AndThen","internal::Into","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Map"],"G":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::And","internal::Or","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapOpt","internal::MapRes"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::AndThen","internal::Or","internal::MapRes","internal::Map","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::And"],"G":["internal::AndThen","internal::MapRes","internal::And","internal::Into","std::boxed::Box","internal::Or","internal::FlatMap","internal::Map","internal::MapOpt","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::And","std::boxed::Box","internal::MapRes","internal::AndThen","internal::Into","internal::Map"],"FnB":["std::boxed::Box","internal::Or","internal::MapOpt","internal::And","internal::AndThen","internal::Map","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap"],"FnC":["internal::AndThen","std::boxed::Box","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Or","internal::Into","internal::Map"],"FnD":["internal::FlatMap","internal::MapRes","internal::Or","internal::And","internal::Into","internal::Map","internal::MapOpt","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>"],"FnE":["<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Or","internal::FlatMap","internal::MapOpt","internal::Into","internal::Map","std::boxed::Box","internal::AndThen"],"FnF":["std::boxed::Box","internal::And","internal::FlatMap","internal::Map","internal::MapRes","internal::MapOpt","internal::Into","internal::Or","internal::AndThen","<F as internal::Parser<I>>"],"Input":["number::Endianness","error::VerboseErrorKind","error::VerboseError","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>"]},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::Or","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I>>","internal::Map"],"G":["std::boxed::Box","internal::And","internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::MapOpt","internal::MapRes"]},"internal::AndThen":{"F":["internal::MapOpt","internal::And","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::MapRes"],"G":["<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::MapRes","internal::Into","internal::AndThen","internal::And","internal::Or","std::boxed::Box","internal::FlatMap"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","error::VerboseErrorKind","number::Endianness","error::VerboseError","internal::Err","internal::Needed","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::And","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::MapOpt","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::Map","internal::And","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::And","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace"]},"internal::MapOpt":{"F":["internal::Into","internal::MapOpt","internal::FlatMap","internal::Map","internal::AndThen","internal::Or","internal::And","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>"],"G":["core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue"]},"internal::MapRes":{"F":["internal::And","internal::MapRes","std::boxed::Box","internal::Map","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::Or"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::Into","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen","internal::Or"],"G":["internal::AndThen","internal::Or","internal::Map","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::MapOpt","internal::And"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::FlatMap","internal::And","internal::Or","internal::MapOpt","std::boxed::Box","internal::Map"],"FnB":["internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Map","internal::Into","internal::AndThen","std::boxed::Box","internal::And","internal::Or"],"FnC":["<F as internal::Parser<I>>","internal::Or","internal::And","std::boxed::Box","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Into","internal::Map","internal::FlatMap"],"FnD":["internal::And","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Into","internal::FlatMap","internal::Map"],"FnE":["internal::Or","internal::And","internal::Map","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::MapRes","internal::AndThen"],"FnF":["internal::Or","internal::AndThen","internal::MapOpt","internal::Into","internal::Map","internal::MapRes","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::And"],"FnG":["<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Map","internal::MapRes","internal::Or","internal::AndThen","std::boxed::Box","internal::And","internal::Into"],"G":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","internal::Needed","number::Endianness","error::ErrorKind","internal::Err","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","error::Error"]},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::And","internal::Or","internal::MapOpt","internal::Map","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::MapRes"],"G":["internal::AndThen","internal::Or","internal::Map","internal::And","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::Into"]},"internal::AndThen":{"F":["std::boxed::Box","internal::AndThen","internal::And","internal::MapOpt","internal::Map","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::Or"],"G":["internal::And","internal::FlatMap","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::Map","internal::Into","internal::MapOpt"]},"internal::Err":{"E":["internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error","number::Endianness","error::VerboseErrorKind","internal::Err","error::ErrorKind","error::VerboseError"]},"internal::FlatMap":{"F":["internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::Or","internal::Into","internal::FlatMap","internal::AndThen","std::boxed::Box"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::And","internal::Map","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::MapRes","std::boxed::Box"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::FlatMap","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::Map","internal::Or","internal::MapOpt","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"]},"internal::MapOpt":{"F":["internal::Or","internal::MapOpt","internal::Map","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into","internal::MapRes"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::Or","internal::And","internal::MapOpt","internal::MapRes","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>"],"G":["core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::And","internal::Map","internal::Or","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::AndThen"],"G":["internal::And","internal::FlatMap","internal::Map","internal::MapRes","internal::Or","internal::Into","internal::AndThen","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["std::boxed::Box","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::And","internal::Map","internal::FlatMap"],"FnB":["internal::Into","internal::MapRes","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::And","internal::Or","internal::AndThen","internal::MapOpt"],"FnC":["internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapOpt","internal::Map","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Into"],"FnD":["internal::AndThen","internal::MapOpt","internal::MapRes","internal::Map","std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::And","internal::Into"],"FnE":["internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::And","internal::Map","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::Into"],"FnF":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapRes","internal::Or","internal::And","internal::MapOpt","internal::Into"],"FnG":["internal::Or","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::AndThen","internal::MapRes","std::boxed::Box","internal::And","internal::FlatMap"],"FnH":["internal::Map","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::AndThen","internal::Or","internal::MapOpt","internal::Into","internal::MapRes"],"G":["RUG_ANY"],"H":["RUG_ANY"],"Input":["error::ErrorKind","internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::VerboseError","internal::Err","error::Error"]},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::AndThen","internal::And","std::boxed::Box","internal::Map","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::Or"],"G":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::AndThen","internal::And","internal::FlatMap","internal::Into","internal::Or","internal::MapOpt","internal::Map"]},"internal::AndThen":{"F":["internal::AndThen","internal::Map","std::boxed::Box","internal::And","internal::Or","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap"],"G":["internal::Or","internal::Map","internal::MapOpt","internal::FlatMap","internal::And","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::AndThen"]},"internal::Err":{"E":["error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","number::Endianness","internal::Needed","error::VerboseError","internal::Err","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Or","internal::MapRes","internal::And"],"G":["core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::Or","std::boxed::Box","internal::AndThen","internal::And","internal::FlatMap","internal::Into","internal::MapRes","internal::Map","internal::MapOpt","<F as internal::Parser<I>>"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::AndThen","internal::Or","internal::And","std::boxed::Box","internal::Map"],"G":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode"]},"internal::MapOpt":{"F":["internal::AndThen","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::And","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::Map"],"G":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::Or","internal::Into","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Map","std::boxed::Box","internal::MapRes","internal::FlatMap"],"G":["core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["internal::MapRes","internal::Map","internal::MapOpt","internal::AndThen","internal::And","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into","<F as internal::Parser<I>>"],"G":["internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::Or","internal::And","internal::MapRes","internal::AndThen","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::AndThen","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Into","internal::MapOpt","internal::FlatMap"],"FnB":["internal::MapOpt","internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Or"],"FnC":["internal::Or","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Map","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::AndThen"],"FnD":["internal::Map","internal::FlatMap","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::And","internal::Or","internal::MapOpt","std::boxed::Box"],"FnE":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::MapRes","internal::And"],"FnF":["internal::Map","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Into","internal::MapOpt","internal::And","internal::AndThen","internal::FlatMap"],"FnG":["internal::AndThen","std::boxed::Box","internal::Map","internal::MapOpt","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Into"],"FnH":["internal::Or","internal::MapRes","internal::Map","internal::Into","internal::And","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap"],"FnI":["internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Map","internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::And","internal::Into"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseError","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","internal::Needed","error::ErrorKind","error::VerboseErrorKind","number::Endianness"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::Or","internal::And","internal::MapOpt","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::Map"],"G":["internal::AndThen","internal::Into","internal::MapRes","internal::FlatMap","internal::Or","internal::MapOpt","std::boxed::Box","internal::Map","internal::And","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Or","internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::MapRes","internal::Map"],"G":["internal::Or","internal::And","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::FlatMap"]},"internal::Err":{"E":["error::VerboseError","error::Error","internal::Err","error::ErrorKind","number::Endianness","error::VerboseErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed"]},"internal::FlatMap":{"F":["internal::Or","internal::MapRes","internal::Map","std::boxed::Box","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::Into","internal::MapOpt","internal::AndThen","internal::And","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::And","std::boxed::Box","internal::Or","internal::AndThen","internal::MapRes","internal::Map","internal::MapOpt"],"G":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::FlatMap","internal::And","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::AndThen","std::boxed::Box","internal::Or"],"G":["std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::Into","internal::MapRes","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::AndThen","internal::Map","internal::Or"],"G":["core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::Into","internal::MapRes","internal::Map","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt"],"G":["internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::And","internal::MapOpt","std::boxed::Box","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map","internal::Into","internal::FlatMap","internal::And"],"FnB":["<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","internal::MapRes","internal::Map","internal::MapOpt"],"FnC":["internal::MapRes","internal::Map","internal::AndThen","internal::Or","internal::MapOpt","internal::Into","internal::And","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box"],"FnD":["internal::MapRes","std::boxed::Box","internal::And","internal::Into","internal::MapOpt","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::FlatMap"],"FnE":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::And","internal::Or","internal::Into","internal::MapRes","internal::FlatMap","internal::Map","internal::AndThen"],"FnF":["<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapOpt","internal::Or","internal::FlatMap","internal::MapRes","internal::And","internal::Into","std::boxed::Box"],"FnG":["internal::FlatMap","internal::Into","internal::AndThen","internal::MapOpt","internal::Map","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Or"],"FnH":["<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Map","std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::Or","internal::AndThen"],"FnI":["internal::Map","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Or","std::boxed::Box","internal::And","internal::MapOpt"],"FnJ":["internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Or","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::Map","internal::Into"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::VerboseError","error::Error","error::VerboseErrorKind","number::Endianness","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>"],"J":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::Into","internal::Map","std::boxed::Box","internal::MapOpt","internal::And","internal::FlatMap"],"G":["internal::And","internal::AndThen","internal::Into","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::FlatMap"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Into","internal::MapOpt","internal::Map","internal::MapRes","internal::And","std::boxed::Box","internal::Or"],"G":["internal::AndThen","internal::And","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapRes","internal::Map","std::boxed::Box"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Err","<*const T as std::fmt::Debug>","error::VerboseError","number::Endianness","internal::Needed","error::Error","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","internal::AndThen","internal::FlatMap","internal::Map","internal::And","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::Or","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Map","internal::And","internal::MapRes"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::FlatMap","internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::Into","internal::MapRes","internal::MapOpt"],"G":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::BytesIsNotEmpty"]},"internal::MapOpt":{"F":["internal::Into","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::And"],"G":["core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Map","internal::MapOpt","internal::And","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["std::boxed::Box","internal::Into","internal::Map","internal::And","internal::MapOpt","internal::Or","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap"],"G":["<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::MapRes","internal::Or","internal::MapOpt","internal::Map","internal::Into","internal::And"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Or","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Into","internal::Map"],"FnB":["internal::MapOpt","internal::Or","internal::MapRes","internal::AndThen","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Into","internal::Map"],"FnC":["<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::MapOpt","internal::AndThen","internal::Map","internal::And","internal::Into","std::boxed::Box","internal::FlatMap"],"FnD":["<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::FlatMap","internal::Map","internal::MapRes","internal::AndThen","internal::And","internal::Or","std::boxed::Box"],"FnE":["<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Or","internal::MapRes","internal::Into","internal::And"],"FnF":["internal::And","internal::Into","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Or","internal::Map","internal::MapRes","<F as internal::Parser<I>>"],"FnG":["std::boxed::Box","internal::FlatMap","internal::MapRes","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::AndThen","internal::And"],"FnH":["internal::MapOpt","internal::Into","internal::Or","internal::Map","internal::And","internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes"],"FnI":["internal::AndThen","std::boxed::Box","internal::Into","internal::Map","internal::MapOpt","internal::MapRes","internal::Or","internal::And","<F as internal::Parser<I>>","internal::FlatMap"],"FnJ":["internal::MapOpt","internal::FlatMap","internal::MapRes","internal::Or","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","internal::And","<F as internal::Parser<I>>"],"FnK":["std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::MapRes","internal::AndThen","internal::Into","internal::FlatMap","internal::Or"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","error::VerboseError","internal::Needed","internal::Err","error::ErrorKind","error::Error"],"J":["RUG_ANY"],"K":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Map","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapRes"],"G":["<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::And","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or","internal::MapRes","internal::MapOpt"]},"internal::AndThen":{"F":["internal::Or","internal::MapOpt","internal::And","std::boxed::Box","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::AndThen"],"G":["internal::Map","internal::And","internal::Or","internal::Into","std::boxed::Box","internal::MapRes","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap"]},"internal::Err":{"E":["internal::Err","error::VerboseError","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","number::Endianness","internal::Needed","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::Or","internal::Into","internal::MapRes"],"G":["core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::AndThen","internal::MapOpt","internal::Into","internal::Map","internal::Or","internal::MapRes","internal::And","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Or","internal::MapOpt","internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Into"],"G":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::Into","internal::Map","internal::And","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::Or","internal::MapRes"],"G":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::Or","internal::And","internal::MapRes","internal::Map","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::AndThen"],"G":["core::str::IsWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::MapRes","internal::FlatMap","internal::MapOpt","internal::Into","internal::AndThen","internal::Map","internal::Or","std::boxed::Box","internal::And","<F as internal::Parser<I>>"],"G":["internal::FlatMap","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::Map","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::MapOpt","internal::AndThen","internal::And","internal::FlatMap","internal::Or","internal::Map"],"FnB":["internal::MapOpt","internal::MapRes","internal::And","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Map","internal::FlatMap"],"FnC":["internal::MapOpt","internal::FlatMap","internal::And","internal::Map","internal::MapRes","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Or","std::boxed::Box"],"FnD":["internal::Or","internal::AndThen","internal::Into","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Map","internal::MapRes"],"FnE":["internal::Map","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::Or","std::boxed::Box","internal::And"],"FnF":["internal::MapOpt","internal::FlatMap","internal::Into","internal::AndThen","internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::MapRes"],"FnG":["std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::FlatMap","internal::MapRes"],"FnH":["internal::MapOpt","internal::And","internal::Into","internal::Map","internal::FlatMap","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::AndThen"],"FnI":["internal::Map","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::MapOpt","internal::Or"],"FnJ":["internal::And","std::boxed::Box","internal::Map","internal::Into","internal::AndThen","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::MapOpt"],"FnK":["internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::Map","internal::Into","internal::AndThen","internal::Or","internal::And"],"FnL":["internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapOpt","internal::MapRes","internal::And","internal::AndThen"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Needed","error::Error","error::VerboseErrorKind","number::Endianness","internal::Err","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["std::boxed::Box","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Or","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::Map"],"G":["<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::AndThen","std::boxed::Box","internal::Or","internal::FlatMap","internal::Into","internal::MapOpt","internal::Map"]},"internal::AndThen":{"F":["internal::Map","std::boxed::Box","internal::AndThen","internal::Into","internal::Or","internal::MapRes","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt"],"G":["internal::FlatMap","internal::AndThen","internal::MapRes","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Map","std::boxed::Box"]},"internal::Err":{"E":["internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","error::ErrorKind","internal::Needed","error::VerboseError","error::Error","number::Endianness"]},"internal::FlatMap":{"F":["internal::Map","internal::Or","internal::Into","internal::And","std::boxed::Box","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen"],"G":["core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::Into","internal::MapRes","internal::AndThen","internal::And","internal::FlatMap","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::MapOpt"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map","internal::AndThen","internal::Or","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Into","internal::MapRes","internal::And","internal::AndThen","internal::Map","std::boxed::Box","internal::Or"],"G":["core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::And","internal::Or","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::MapRes"],"G":["core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["internal::And","internal::Map","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::MapRes","internal::Or"],"G":["<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::Map","internal::And","internal::Or","internal::AndThen","internal::MapRes","std::boxed::Box","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::FlatMap","internal::AndThen","internal::Or","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::MapOpt","internal::And"],"FnB":["internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen"],"FnC":["internal::AndThen","internal::MapRes","internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapOpt","internal::Or"],"FnD":["internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::AndThen","internal::And"],"FnE":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::Into","internal::Or","internal::Map","internal::MapRes","internal::And"],"FnF":["internal::Into","internal::Or","internal::MapOpt","std::boxed::Box","internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap"],"FnG":["internal::And","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::AndThen","internal::MapOpt","internal::Into","internal::Or"],"FnH":["<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::MapOpt","internal::Or","internal::MapRes","internal::Map","internal::AndThen"],"FnI":["std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::FlatMap","internal::Into","internal::And","internal::Map","internal::AndThen"],"FnJ":["<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::And","internal::MapRes"],"FnK":["internal::MapRes","internal::MapOpt","internal::AndThen","internal::Or","std::boxed::Box","internal::FlatMap","internal::And","internal::Into","internal::Map","<F as internal::Parser<I>>"],"FnL":["internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::Into","internal::Map","internal::MapRes","std::boxed::Box","internal::And"],"FnM":["internal::Map","internal::MapOpt","std::boxed::Box","internal::And","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Or"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Needed","error::VerboseErrorKind","error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","internal::Err","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::And","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::MapRes","std::boxed::Box"],"G":["<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::Into","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box","internal::FlatMap","internal::And"]},"internal::AndThen":{"F":["std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::Or","internal::Map","internal::MapRes","internal::And"],"G":["internal::MapOpt","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::Map","internal::AndThen","internal::MapRes","internal::And"]},"internal::Err":{"E":["internal::Needed","number::Endianness","error::Error","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err"]},"internal::FlatMap":{"F":["internal::Into","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::MapRes","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::MapOpt","internal::Map","internal::AndThen","internal::Into"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Into","internal::MapRes","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::Or","std::boxed::Box","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty"]},"internal::MapOpt":{"F":["internal::Into","std::boxed::Box","internal::FlatMap","internal::Or","internal::MapRes","internal::AndThen","internal::MapOpt","internal::And","internal::Map","<F as internal::Parser<I>>"],"G":["std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::Or","internal::And","internal::Into","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen","internal::MapRes","internal::MapOpt"],"G":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::FlatMap","internal::Into","internal::And","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Map"],"G":["<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Into","internal::Or","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Map","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::Or","std::boxed::Box","internal::And","internal::Map","internal::MapOpt"],"FnB":["internal::MapOpt","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","internal::And","internal::Or","internal::MapRes"],"FnC":["<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Into","internal::Or","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::MapRes","internal::And"],"FnD":["internal::MapOpt","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::Map","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Into","internal::Or"],"FnE":["internal::AndThen","internal::Map","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Or","internal::FlatMap","internal::Into"],"FnF":["internal::Map","internal::AndThen","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap"],"FnG":["<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Map","internal::MapOpt","internal::Into","std::boxed::Box","internal::Or","internal::And"],"FnH":["internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Or","internal::Into","internal::Map","internal::AndThen","std::boxed::Box","internal::FlatMap"],"FnI":["internal::Or","internal::Into","internal::And","internal::AndThen","internal::Map","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes"],"FnJ":["internal::Map","internal::Into","std::boxed::Box","internal::And","internal::Or","internal::FlatMap","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen"],"FnK":["internal::Map","internal::Into","std::boxed::Box","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::And","internal::AndThen","internal::FlatMap"],"FnL":["internal::Into","internal::MapOpt","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::And","std::boxed::Box","internal::AndThen"],"FnM":["internal::MapRes","internal::AndThen","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Map","internal::Or","internal::Into"],"FnN":["internal::FlatMap","internal::And","internal::MapRes","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::MapOpt","internal::Map"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::Error","internal::Err","error::VerboseErrorKind","error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","error::VerboseError"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::FlatMap","internal::Or","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::And","internal::Into"],"G":["internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::And","std::boxed::Box","internal::Into","internal::FlatMap","internal::AndThen","internal::Map"]},"internal::AndThen":{"F":["internal::Into","internal::FlatMap","internal::MapOpt","internal::And","internal::Or","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map"],"G":["internal::MapOpt","internal::Or","internal::FlatMap","internal::Map","internal::AndThen","internal::MapRes","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::And"]},"internal::Err":{"E":["internal::Needed","internal::Err","error::VerboseError","error::ErrorKind","error::Error","error::VerboseErrorKind","number::Endianness","<*const T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::MapRes","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::And","internal::Or","internal::AndThen","internal::FlatMap","std::boxed::Box"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Map","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Or","internal::MapOpt"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::AndThen","internal::MapRes","internal::Map","internal::FlatMap","internal::And","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["internal::Or","internal::MapRes","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::AndThen","internal::Into","std::boxed::Box"],"G":["core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap"]},"internal::MapRes":{"F":["internal::Or","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::MapRes","internal::FlatMap","internal::Map"],"G":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["std::boxed::Box","internal::MapOpt","internal::And","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Map","internal::MapRes","internal::Or"],"G":["internal::Map","internal::MapRes","internal::Into","std::boxed::Box","internal::FlatMap","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::Or","internal::FlatMap","internal::Into","std::boxed::Box","internal::And","internal::MapRes","internal::MapOpt"],"FnB":["internal::And","internal::Map","internal::FlatMap","internal::AndThen","internal::MapRes","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","std::boxed::Box"],"FnC":["<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::MapOpt","internal::Into","internal::And","internal::MapRes","internal::AndThen","std::boxed::Box","internal::Map"],"FnD":["internal::AndThen","internal::Map","internal::Or","internal::Into","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::And","internal::FlatMap","<F as internal::Parser<I>>"],"FnE":["internal::Or","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::And"],"FnF":["internal::MapOpt","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::MapRes"],"FnG":["internal::AndThen","internal::Or","internal::Into","internal::MapRes","internal::And","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap"],"FnH":["internal::Or","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into"],"FnI":["internal::Into","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::MapRes"],"FnJ":["internal::MapOpt","internal::MapRes","internal::And","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::Map"],"FnK":["std::boxed::Box","internal::MapRes","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapOpt","internal::Into","internal::Or"],"FnL":["internal::Map","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::AndThen","internal::Into","internal::Or","internal::And","internal::MapOpt"],"FnM":["internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::And","internal::Into","internal::MapOpt","internal::Map"],"FnN":["std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::Or","internal::Into","internal::MapRes","internal::FlatMap","internal::Map","internal::MapOpt"],"FnO":["internal::And","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::AndThen","internal::MapRes","std::boxed::Box","internal::Map","internal::MapOpt"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","number::Endianness","error::ErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","internal::Err","internal::Needed"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::Map","internal::MapOpt","std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::Or"],"G":["internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Into","internal::Map","internal::Or","std::boxed::Box"]},"internal::AndThen":{"F":["internal::And","internal::MapOpt","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Map","internal::Or","internal::Into","<F as internal::Parser<I>>"],"G":["internal::Or","internal::FlatMap","internal::MapOpt","internal::Map","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::Into","std::boxed::Box"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","error::VerboseErrorKind","internal::Err","internal::Needed","number::Endianness","error::Error","error::ErrorKind","error::VerboseError"]},"internal::FlatMap":{"F":["internal::And","internal::FlatMap","internal::Map","std::boxed::Box","internal::Into","internal::MapOpt","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Or","internal::Map","internal::MapOpt","internal::Into","internal::FlatMap"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::AndThen","internal::And","internal::MapOpt","internal::Into","std::boxed::Box","internal::Map"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::MapOpt","internal::Or","internal::Map"],"G":["core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["internal::And","std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::Map","internal::MapRes"],"G":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::Or","internal::And","internal::Map","std::boxed::Box","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Into"],"G":["<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::And","internal::MapRes","internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::FlatMap","internal::MapOpt","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::Or","internal::And","std::boxed::Box"],"FnB":["internal::FlatMap","internal::MapOpt","internal::And","internal::Or","internal::Map","std::boxed::Box","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes"],"FnC":["internal::Map","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Into","internal::MapRes"],"FnD":["internal::AndThen","internal::Map","internal::MapRes","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::And"],"FnE":["internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::AndThen","internal::Map","internal::And","internal::Into","std::boxed::Box"],"FnF":["internal::MapRes","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::And","internal::MapOpt","internal::Or","std::boxed::Box","internal::AndThen"],"FnG":["<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::Map","internal::FlatMap","internal::And","internal::Into","internal::AndThen","internal::MapRes","internal::MapOpt"],"FnH":["<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::Or","internal::Map","internal::Into","internal::And","std::boxed::Box"],"FnI":["internal::MapOpt","internal::FlatMap","internal::Map","internal::AndThen","internal::Into","internal::And","internal::MapRes","internal::Or","<F as internal::Parser<I>>","std::boxed::Box"],"FnJ":["internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::And","std::boxed::Box","internal::MapRes","internal::Map","internal::AndThen","internal::Or"],"FnK":["internal::Into","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::MapRes"],"FnL":["internal::Into","internal::MapOpt","internal::FlatMap","internal::Map","internal::And","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Or"],"FnM":["<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::And","internal::Into","internal::Map","internal::MapOpt","internal::Or","internal::MapRes","std::boxed::Box"],"FnN":["<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::And","internal::MapOpt","internal::Into","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Map"],"FnO":["internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into","internal::And","std::boxed::Box","internal::MapOpt"],"FnP":["internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Or","internal::MapRes","internal::Map"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseError","error::Error","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","error::ErrorKind","internal::Needed"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Or","internal::AndThen","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map"],"G":["internal::MapRes","internal::And","std::boxed::Box","internal::MapOpt","internal::Into","internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::AndThen"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::FlatMap","internal::Into","internal::Or","internal::And","std::boxed::Box","internal::AndThen","internal::MapRes"],"G":["<F as internal::Parser<I>>","internal::Into","internal::Map","internal::MapOpt","internal::AndThen","internal::Or","internal::FlatMap","internal::MapRes","internal::And","std::boxed::Box"]},"internal::Err":{"E":["error::Error","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","internal::Needed","internal::Err","error::VerboseError","number::Endianness"]},"internal::FlatMap":{"F":["internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Or","internal::Into","internal::And","internal::AndThen","internal::MapRes"],"G":["core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::MapRes","internal::And","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::And","std::boxed::Box","internal::Or","internal::Into","internal::MapOpt","internal::Map","internal::MapRes"],"G":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::MapRes","internal::Or","internal::Into","std::boxed::Box","internal::Map"],"G":["core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::Map","internal::FlatMap","internal::Or","internal::AndThen","internal::MapRes","internal::And","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt"],"G":["core::str::CharEscapeDefault","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Map","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::Or","internal::Into"],"G":["<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapRes","internal::FlatMap","internal::Into","internal::MapOpt","internal::Or","internal::And","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::AndThen","internal::Into","internal::MapOpt","internal::FlatMap","internal::Map","internal::And","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes"],"FnB":["internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::AndThen","internal::And"],"FnC":["internal::FlatMap","internal::And","internal::MapOpt","internal::Map","std::boxed::Box","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen"],"FnD":["<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::Map","internal::MapOpt"],"FnE":["std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::Map","internal::AndThen","internal::Into","internal::MapOpt","internal::MapRes","internal::And"],"FnF":["internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box","internal::Or","internal::AndThen"],"FnG":["internal::Map","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::And","std::boxed::Box","internal::FlatMap","internal::Or"],"FnH":["internal::FlatMap","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::AndThen","internal::And","internal::MapRes","std::boxed::Box"],"FnI":["internal::Map","internal::And","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Into","internal::AndThen","internal::FlatMap"],"FnJ":["internal::And","internal::AndThen","internal::MapOpt","internal::Map","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::Or","std::boxed::Box"],"FnK":["internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::MapRes","internal::FlatMap","internal::Map","std::boxed::Box","internal::Into"],"FnL":["internal::FlatMap","internal::Or","std::boxed::Box","internal::Into","internal::MapRes","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::And"],"FnM":["internal::AndThen","internal::Into","internal::Map","internal::FlatMap","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::MapOpt"],"FnN":["internal::Map","internal::Into","internal::MapRes","internal::And","std::boxed::Box","internal::Or","internal::AndThen","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>"],"FnO":["<F as internal::Parser<I>>","internal::Into","internal::Or","internal::And","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::Map"],"FnP":["internal::MapOpt","internal::AndThen","internal::And","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::Or"],"FnQ":["internal::AndThen","internal::Or","internal::Into","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::And","internal::Map"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::ErrorKind","internal::Needed","number::Endianness","internal::Err","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::Error"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::AndThen","internal::Or","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::And","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::FlatMap"],"G":["internal::FlatMap","internal::Map","internal::AndThen","internal::And","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::MapRes","std::boxed::Box"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Into","internal::And","internal::MapRes","internal::AndThen","std::boxed::Box","internal::Map","internal::Or"],"G":["<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapOpt","internal::Into","internal::Or","internal::Map","internal::MapRes","std::boxed::Box","internal::AndThen"]},"internal::Err":{"E":["internal::Err","error::Error","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","error::VerboseErrorKind","error::ErrorKind","error::VerboseError"]},"internal::FlatMap":{"F":["internal::AndThen","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::And","internal::Into"],"G":["core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::Map","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::Or","std::boxed::Box","internal::AndThen","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","internal::MapOpt","internal::MapRes","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::Into","internal::And"],"G":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace"]},"internal::MapOpt":{"F":["internal::And","internal::Into","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::MapRes","internal::FlatMap","internal::AndThen"],"G":["core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::And","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Map","internal::Or","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::AndThen","internal::FlatMap","internal::And","internal::Into","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::MapRes","internal::Or","internal::MapOpt"],"G":["internal::FlatMap","internal::And","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Map","internal::MapRes","internal::Into","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["internal::Parser","std::marker::Sized"],"FnQ":["internal::Parser","std::marker::Sized"],"FnR":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::AndThen","internal::Or","internal::FlatMap","std::boxed::Box","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::MapOpt"],"FnB":["<F as internal::Parser<I>>","internal::MapRes","internal::Or","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Map","internal::FlatMap","internal::Into","internal::And"],"FnC":["internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::And","internal::Map","internal::FlatMap","internal::MapOpt","internal::Into","std::boxed::Box"],"FnD":["internal::FlatMap","internal::Into","internal::Map","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::And","internal::MapRes"],"FnE":["internal::Map","internal::Or","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::And","std::boxed::Box","internal::MapRes","internal::Into"],"FnF":["internal::FlatMap","internal::Or","std::boxed::Box","internal::Map","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::AndThen"],"FnG":["internal::AndThen","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::Into"],"FnH":["internal::Map","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::AndThen","internal::FlatMap","internal::MapRes","internal::Into"],"FnI":["internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Map","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapRes"],"FnJ":["internal::MapOpt","internal::Or","internal::And","internal::FlatMap","internal::Into","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::MapRes"],"FnK":["internal::And","internal::AndThen","internal::Or","internal::MapOpt","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapRes"],"FnL":["<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","internal::Or","internal::MapRes","internal::And","internal::Map"],"FnM":["internal::Map","internal::MapOpt","internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapRes","std::boxed::Box"],"FnN":["internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Or","internal::And","internal::Map","internal::Into"],"FnO":["std::boxed::Box","internal::Map","internal::Into","internal::Or","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes"],"FnP":["internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Into","internal::MapOpt","internal::Or","internal::AndThen"],"FnQ":["<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::AndThen","internal::Or","std::boxed::Box","internal::MapOpt","internal::Into","internal::FlatMap","internal::And"],"FnR":["std::boxed::Box","internal::MapOpt","internal::And","internal::Or","internal::FlatMap","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapRes"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseErrorKind","internal::Needed","error::VerboseError","internal::Err","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","error::Error"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::MapRes","internal::Map","internal::And","internal::AndThen","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap"],"G":["internal::And","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::AndThen"]},"internal::AndThen":{"F":["internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapOpt","internal::MapRes","internal::Or","std::boxed::Box"],"G":["internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::And","internal::FlatMap","internal::Map","internal::Into","std::boxed::Box","internal::MapOpt"]},"internal::Err":{"E":["internal::Err","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::VerboseError","error::ErrorKind","error::Error","number::Endianness"]},"internal::FlatMap":{"F":["internal::Map","internal::FlatMap","internal::AndThen","internal::Or","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Into","std::boxed::Box"],"G":["core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["std::boxed::Box","internal::And","internal::AndThen","internal::FlatMap","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Map","internal::And","std::boxed::Box","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace"]},"internal::MapOpt":{"F":["internal::MapOpt","std::boxed::Box","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::And","internal::MapRes","internal::FlatMap"],"G":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["internal::MapRes","internal::Or","internal::MapOpt","internal::FlatMap","internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::And"],"G":["core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::And","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Map","internal::Or","std::boxed::Box"],"G":["internal::Map","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::Or","internal::AndThen","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["internal::Parser","std::marker::Sized"],"FnQ":["std::marker::Sized","internal::Parser"],"FnR":["std::marker::Sized","internal::Parser"],"FnS":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::FlatMap","internal::Map","internal::And","internal::MapRes","internal::MapOpt"],"FnB":["internal::Map","internal::AndThen","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::Into"],"FnC":["internal::MapOpt","internal::AndThen","internal::Into","internal::Or","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::And"],"FnD":["internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box","internal::Or","internal::Into","internal::And"],"FnE":["internal::Into","internal::And","internal::AndThen","internal::Or","internal::FlatMap","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Map","std::boxed::Box"],"FnF":["internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::And","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box"],"FnG":["internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::MapOpt","internal::Map","std::boxed::Box","internal::And","internal::FlatMap"],"FnH":["internal::Or","internal::Map","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::AndThen","internal::FlatMap","internal::And"],"FnI":["internal::AndThen","internal::Or","internal::And","internal::Map","internal::MapOpt","internal::FlatMap","internal::Into","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box"],"FnJ":["internal::Into","internal::And","internal::Or","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::MapRes"],"FnK":["std::boxed::Box","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Or","internal::Map","internal::AndThen","internal::MapRes","internal::Into"],"FnL":["internal::Map","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Or"],"FnM":["internal::And","internal::AndThen","internal::FlatMap","internal::Into","internal::MapRes","std::boxed::Box","internal::Or","internal::MapOpt","internal::Map","<F as internal::Parser<I>>"],"FnN":["internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::And","internal::Map","internal::MapOpt","internal::FlatMap","internal::Or","std::boxed::Box"],"FnO":["internal::AndThen","internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapOpt","internal::Or","internal::MapRes"],"FnP":["internal::MapOpt","internal::Or","internal::Map","internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::And","internal::MapRes"],"FnQ":["internal::AndThen","internal::MapRes","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::MapOpt","internal::Into","internal::Or","internal::FlatMap"],"FnR":["internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Into","internal::Or","internal::And"],"FnS":["internal::AndThen","internal::And","internal::MapOpt","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::MapRes","internal::Into"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Err","error::Error","error::VerboseErrorKind","number::Endianness","error::VerboseError","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","internal::Into","std::boxed::Box","internal::Map","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::MapOpt"],"G":["std::boxed::Box","internal::Or","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::MapOpt","internal::Into"]},"internal::AndThen":{"F":["internal::AndThen","internal::And","internal::MapOpt","internal::Map","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::FlatMap"],"G":["internal::FlatMap","internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::MapRes","internal::MapOpt","internal::And"]},"internal::Err":{"E":["number::Endianness","internal::Err","error::VerboseError","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind","error::VerboseErrorKind","error::Error"]},"internal::FlatMap":{"F":["internal::FlatMap","std::boxed::Box","internal::And","internal::MapOpt","internal::Into","internal::MapRes","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Or"],"G":["core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["std::boxed::Box","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Or","internal::AndThen","internal::Into","internal::MapOpt","internal::FlatMap"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","internal::And","internal::MapRes","internal::Into","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"]},"internal::MapOpt":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::Map","internal::AndThen","internal::Or","internal::MapOpt","internal::And"],"G":["core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::AndThen","internal::And","internal::MapRes","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::MapOpt"],"G":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::AndThen","std::boxed::Box","internal::Map","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::And","internal::FlatMap","internal::MapRes"],"G":["<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Into","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["internal::Parser","std::marker::Sized"],"FnQ":["internal::Parser","std::marker::Sized"],"FnR":["std::marker::Sized","internal::Parser"],"FnS":["std::marker::Sized","internal::Parser"],"FnT":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"],"T":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::FlatMap","internal::Into","internal::Or","internal::MapOpt","internal::AndThen","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::Map","std::boxed::Box"],"FnB":["internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::Map","internal::FlatMap","internal::MapRes","internal::Into","internal::MapOpt"],"FnC":["internal::AndThen","internal::Into","internal::And","internal::MapOpt","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::MapRes","std::boxed::Box"],"FnD":["internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::Or","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::MapRes","internal::Into"],"FnE":["internal::Into","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Or","internal::MapRes","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::And"],"FnF":["internal::Map","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::And"],"FnG":["std::boxed::Box","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Into","internal::Map","internal::MapOpt","internal::AndThen"],"FnH":["internal::Or","internal::AndThen","internal::FlatMap","internal::Map","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::And"],"FnI":["internal::Or","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::Into"],"FnJ":["internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::And","internal::FlatMap","internal::Into","internal::MapRes","internal::AndThen","internal::Map"],"FnK":["internal::AndThen","internal::Map","internal::MapOpt","internal::Into","internal::Or","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::And","<F as internal::Parser<I>>"],"FnL":["internal::AndThen","internal::And","std::boxed::Box","internal::Or","internal::Map","internal::MapRes","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::FlatMap"],"FnM":["std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Or","internal::Map","internal::Into","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::MapRes"],"FnN":["internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::Map","internal::And","internal::MapRes","internal::FlatMap","internal::MapOpt","internal::AndThen"],"FnO":["internal::MapRes","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Into","internal::MapOpt","internal::Map","internal::FlatMap","internal::AndThen"],"FnP":["<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapRes","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Into","internal::Or","internal::And"],"FnQ":["internal::And","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapRes","internal::Map"],"FnR":["std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::AndThen","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or"],"FnS":["<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::MapRes","internal::Or","internal::Map","internal::AndThen","internal::MapOpt","internal::Into","internal::FlatMap"],"FnT":["internal::MapRes","internal::Into","internal::FlatMap","internal::Map","internal::And","internal::MapOpt","internal::AndThen","internal::Or","<F as internal::Parser<I>>","std::boxed::Box"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Needed","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseErrorKind","error::ErrorKind","error::Error","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"],"T":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::And","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::AndThen","internal::FlatMap","internal::MapRes","internal::Or","std::boxed::Box"],"G":["internal::MapOpt","internal::Map","internal::Into","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","std::boxed::Box","internal::And"]},"internal::AndThen":{"F":["internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::And","internal::AndThen","internal::Map"],"G":["<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::Or","internal::AndThen","internal::Into","internal::And","internal::Map","std::boxed::Box"]},"internal::Err":{"E":["number::Endianness","internal::Needed","error::VerboseErrorKind","error::ErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","internal::Err"]},"internal::FlatMap":{"F":["internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::Map","internal::MapOpt","internal::FlatMap","internal::Or","internal::Into","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::And","internal::FlatMap","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::Map","std::boxed::Box","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::MapRes","internal::And","internal::Into","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::Into","internal::And","internal::MapOpt","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::Or","internal::Map"],"G":["core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::Into","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::MapOpt","internal::MapRes","internal::And","<F as internal::Parser<I>>"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::Or","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::AndThen","internal::MapRes","internal::And","internal::FlatMap","internal::Into","std::boxed::Box"],"G":["internal::And","internal::FlatMap","internal::Into","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Map","internal::MapRes"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["internal::Parser","std::marker::Sized"],"FnQ":["std::marker::Sized","internal::Parser"],"FnR":["std::marker::Sized","internal::Parser"],"FnS":["std::marker::Sized","internal::Parser"],"FnT":["std::marker::Sized","internal::Parser"],"FnU":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::FlatMap","internal::MapRes","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Map","internal::AndThen","internal::Into","internal::MapOpt"],"FnB":["internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Map","internal::Into","internal::Or","internal::MapOpt","internal::And","internal::MapRes","<F as internal::Parser<I>>"],"FnC":["internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::And","internal::FlatMap","internal::Into","std::boxed::Box","internal::MapOpt","internal::Map"],"FnD":["internal::MapOpt","internal::FlatMap","internal::Into","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::AndThen","internal::Or","internal::And"],"FnE":["internal::MapRes","internal::MapOpt","internal::And","internal::Map","internal::Or","internal::AndThen","internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>"],"FnF":["internal::Or","internal::MapOpt","internal::And","internal::Into","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>"],"FnG":["internal::MapOpt","internal::And","internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","internal::Into","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>"],"FnH":["internal::MapOpt","internal::Or","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::FlatMap","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>"],"FnI":["internal::MapRes","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::Map"],"FnJ":["<F as internal::Parser<I>>","internal::Into","internal::Map","internal::And","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Or","internal::FlatMap","internal::AndThen"],"FnK":["std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapOpt","internal::AndThen","internal::MapRes","internal::Into","internal::FlatMap"],"FnL":["internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::MapOpt","internal::Map","internal::Into","std::boxed::Box","internal::Or"],"FnM":["<F as internal::Parser<I>>","internal::Map","internal::Or","internal::And","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Into"],"FnN":["internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::MapRes","internal::Map","std::boxed::Box","internal::And","internal::MapOpt"],"FnO":["internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::MapRes","internal::Into","internal::Or","internal::Map","std::boxed::Box"],"FnP":["internal::FlatMap","internal::MapOpt","internal::Or","internal::Map","internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::MapRes","<F as internal::Parser<I>>"],"FnQ":["internal::And","internal::MapOpt","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::Into","internal::FlatMap","internal::MapRes"],"FnR":["internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","std::boxed::Box","internal::Map","internal::MapOpt","internal::FlatMap","internal::Or","internal::And"],"FnS":["internal::Into","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Map","internal::MapOpt","internal::AndThen","std::boxed::Box"],"FnT":["internal::MapRes","internal::Map","internal::Or","std::boxed::Box","internal::MapOpt","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::AndThen"],"FnU":["std::boxed::Box","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::MapRes","internal::Or","internal::Map","internal::And"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::ErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::VerboseErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","internal::Err"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Into","internal::Map","internal::And","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Or"],"G":["std::boxed::Box","internal::AndThen","internal::Into","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::FlatMap","internal::Or"]},"internal::AndThen":{"F":["internal::MapOpt","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","internal::MapRes"],"G":["internal::And","internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::MapRes","internal::MapOpt","std::boxed::Box"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","error::VerboseError","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness","error::Error","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::And","internal::MapRes","internal::FlatMap","internal::MapOpt","internal::Or","internal::AndThen","internal::Map","internal::Into","<F as internal::Parser<I>>","std::boxed::Box"],"G":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::UnsafeBytesToStr"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::FlatMap","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::Into","std::boxed::Box","internal::And","internal::MapRes","internal::AndThen"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Into","internal::Map","internal::AndThen","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::And"],"G":["core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Or","internal::Map","internal::And"],"G":["core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace"]},"internal::MapRes":{"F":["std::boxed::Box","internal::FlatMap","internal::Or","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::MapOpt","internal::MapRes","internal::AndThen"],"G":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::MapRes","internal::MapOpt","internal::FlatMap","internal::And","internal::Map","internal::AndThen","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::Or"],"G":["internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU)>::permutation(p0, p1);
-----------------
src/combinator/mod.rs combinator::ParserIterator::<I, E, F>::finish
deps:{"combinator::ParserIterator::<I, E, F>::finish":{"E":["std::marker::Sized"],"F":["std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"combinator::ParserIterator::<I, E, F>::finish":{"E":["RUG_ANY"],"F":["RUG_ANY"],"I":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *const T>","error::Error","error::VerboseErrorKind","internal::Err","number::Endianness","error::VerboseError","internal::Needed"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","error::ErrorKind","internal::Needed","number::Endianness","error::Error","error::VerboseErrorKind","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // combinator::ParserIterator<I, E, F>
+p0.finish();
+combinator::ParserIterator::<I, E, F>::finish(p0);
+crate::combinator::ParserIterator::<I, E, F>::finish(p0);
+<combinator::ParserIterator<I, E, F>>::finish(p0);
-----------------
src/combinator/mod.rs <&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next
'a
deps:{"<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next":{"Error":["std::marker::Sized"],"F":["std::ops::FnMut","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"Output":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next":{"Error":["RUG_ANY"],"F":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDefault"],"Input":["error::VerboseError","number::Endianness","error::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Err","internal::Needed","error::VerboseErrorKind","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>"],"Output":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::Error","error::VerboseError","error::VerboseErrorKind","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","error::ErrorKind","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // combinator::ParserIterator<Input, Error, F>
+p0.next();
+<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next(p0);
+crate::<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next(p0);
+<&'a mut combinator::ParserIterator<Input, Error, F>>::next(p0);
-----------------
src/internal.rs <std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish
deps:{"<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]}}
candidates:{"<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<(I, O), internal::Err<E>>
+p0.finish();
+<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish(p0);
+crate::<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish(p0);
+<std::result::Result<(I, O), internal::Err<E>>>::finish(p0);
-----------------
src/internal.rs <internal::Needed as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<internal::Needed as std::fmt::Debug>::fmt(p0, p1);
+crate::<internal::Needed as std::fmt::Debug>::fmt(p0, p1);
+<internal::Needed>::fmt(p0, p1);
-----------------
src/internal.rs <internal::Needed as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal::Needed
+p0.eq(p1);
+<internal::Needed as std::cmp::PartialEq>::eq(p0, p1);
+crate::<internal::Needed as std::cmp::PartialEq>::eq(p0, p1);
+<internal::Needed>::eq(p0, p1);
-----------------
src/internal.rs <internal::Needed as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
+p0.assert_receiver_is_total_eq();
+<internal::Needed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<internal::Needed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<internal::Needed>::assert_receiver_is_total_eq(p0);
-----------------
src/internal.rs <internal::Needed as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
+p0.clone();
+<internal::Needed as std::clone::Clone>::clone(p0);
+crate::<internal::Needed as std::clone::Clone>::clone(p0);
+<internal::Needed>::clone(p0);
-----------------
src/internal.rs internal::Needed::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+internal::Needed::new(p0);
+crate::internal::Needed::new(p0);
+<internal::Needed>::new(p0);
-----------------
src/internal.rs internal::Needed::is_known
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
+p0.is_known();
+internal::Needed::is_known(p0);
+crate::internal::Needed::is_known(p0);
+<internal::Needed>::is_known(p0);
-----------------
src/internal.rs internal::Needed::map
deps:{"internal::Needed::map":{"F":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"internal::Needed::map":{"F":["core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Needed
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+internal::Needed::map(p0, p1);
+crate::internal::Needed::map(p0, p1);
+<internal::Needed>::map(p0, p1);
-----------------
src/internal.rs <internal::Err<E> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::fmt::Debug>::fmt":{"E":["std::fmt::Debug","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::fmt::Debug>::fmt":{"E":["internal::Err","error::VerboseErrorKind","error::Error","<&mut T as std::fmt::Debug>","error::ErrorKind","traits::CompareResult","error::VerboseError","<*mut T as std::fmt::Debug>","number::Endianness","internal::Needed"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::Error","number::Endianness","internal::Needed","error::VerboseError","error::VerboseErrorKind"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<internal::Err<E> as std::fmt::Debug>::fmt(p0, p1);
+crate::<internal::Err<E> as std::fmt::Debug>::fmt(p0, p1);
+<internal::Err<E>>::fmt(p0, p1);
-----------------
src/internal.rs <internal::Err<E> as std::clone::Clone>::clone
deps:{"<internal::Err<E> as std::clone::Clone>::clone":{"E":["std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<internal::Err<E> as std::clone::Clone>::clone":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::Error","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","internal::Needed","error::ErrorKind","error::VerboseErrorKind","internal::Err"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","error::VerboseError","internal::Needed","error::Error","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
+p0.clone();
+<internal::Err<E> as std::clone::Clone>::clone(p0);
+crate::<internal::Err<E> as std::clone::Clone>::clone(p0);
+<internal::Err<E>>::clone(p0);
-----------------
src/internal.rs <internal::Err<E> as std::cmp::PartialEq>::eq
deps:{"<internal::Err<E> as std::cmp::PartialEq>::eq":{"E":["std::cmp::PartialEq","std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<internal::Err<E> as std::cmp::PartialEq>::eq":{"E":["internal::Needed","number::Endianness","internal::Err","error::VerboseError","error::Error","error::VerboseErrorKind","traits::CompareResult","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Err","error::ErrorKind","internal::Needed","error::VerboseError","error::VerboseErrorKind","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
+p0.eq(p1);
+<internal::Err<E> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<internal::Err<E> as std::cmp::PartialEq>::eq(p0, p1);
+<internal::Err<E>>::eq(p0, p1);
-----------------
src/internal.rs internal::Err::<E>::is_incomplete
deps:{"internal::Err::<E>::is_incomplete":{"E":["std::marker::Sized"]}}
candidates:{"internal::Err::<E>::is_incomplete":{"E":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
+p0.is_incomplete();
+internal::Err::<E>::is_incomplete(p0);
+crate::internal::Err::<E>::is_incomplete(p0);
+<internal::Err<E>>::is_incomplete(p0);
-----------------
src/internal.rs internal::Err::<E>::map
deps:{"internal::Err::<E>::map":{"E":["std::marker::Sized"],"E2":["std::marker::Sized"],"F":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"internal::Err::<E>::map":{"E":["RUG_ANY"],"E2":["RUG_ANY"],"F":["std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<E>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+internal::Err::<E>::map(p0, p1);
+crate::internal::Err::<E>::map(p0, p1);
+<internal::Err<E>>::map(p0, p1);
-----------------
src/internal.rs internal::Err::<E>::convert
deps:{"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::Err::<E>::convert":{"E":["std::marker::Sized","std::convert::From"],"F":["std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::Error","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","number::Endianness","internal::Needed"]},"internal::Err::<E>::convert":{"E":["error::VerboseError","error::Error"],"F":["RUG_ANY"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<F>
+internal::Err::<E>::convert(p0);
+crate::internal::Err::<E>::convert(p0);
+<internal::Err<E>>::convert(p0);
-----------------
src/internal.rs internal::Err::<(T, error::ErrorKind)>::map_input
deps:{"internal::Err::<(T, error::ErrorKind)>::map_input":{"F":["std::marker::Sized","std::ops::FnOnce"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"internal::Err::<(T, error::ErrorKind)>::map_input":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::panic::AssertUnwindSafe<F>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<(T, error::ErrorKind)>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map_input(p1);
+internal::Err::<(T, error::ErrorKind)>::map_input(p0, p1);
+crate::internal::Err::<(T, error::ErrorKind)>::map_input(p0, p1);
+<internal::Err<(T, error::ErrorKind)>>::map_input(p0, p1);
-----------------
src/internal.rs internal::Err::<error::Error<T>>::map_input
deps:{"internal::Err::<error::Error<T>>::map_input":{"F":["std::ops::FnOnce","std::marker::Sized"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"internal::Err::<error::Error<T>>::map_input":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<error::Error<T>>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map_input(p1);
+internal::Err::<error::Error<T>>::map_input(p0, p1);
+crate::internal::Err::<error::Error<T>>::map_input(p0, p1);
+<internal::Err<error::Error<T>>>::map_input(p0, p1);
-----------------
src/internal.rs internal::Err::<(&[u8], error::ErrorKind)>::to_owned
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<(&[u8], error::ErrorKind)>
+p0.to_owned();
+internal::Err::<(&[u8], error::ErrorKind)>::to_owned(p0);
+crate::internal::Err::<(&[u8], error::ErrorKind)>::to_owned(p0);
+<internal::Err<(&[u8], error::ErrorKind)>>::to_owned(p0);
-----------------
src/internal.rs internal::Err::<(&str, error::ErrorKind)>::to_owned
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<(&str, error::ErrorKind)>
+p0.to_owned();
+internal::Err::<(&str, error::ErrorKind)>::to_owned(p0);
+crate::internal::Err::<(&str, error::ErrorKind)>::to_owned(p0);
+<internal::Err<(&str, error::ErrorKind)>>::to_owned(p0);
-----------------
src/internal.rs internal::Err::<error::Error<&[u8]>>::to_owned
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<error::Error<&[u8]>>
+p0.to_owned();
+internal::Err::<error::Error<&[u8]>>::to_owned(p0);
+crate::internal::Err::<error::Error<&[u8]>>::to_owned(p0);
+<internal::Err<error::Error<&[u8]>>>::to_owned(p0);
-----------------
src/internal.rs internal::Err::<error::Error<&str>>::to_owned
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<error::Error<&str>>
+p0.to_owned();
+internal::Err::<error::Error<&str>>::to_owned(p0);
+crate::internal::Err::<error::Error<&str>>::to_owned(p0);
+<internal::Err<error::Error<&str>>>::to_owned(p0);
-----------------
src/internal.rs <internal::Err<E> as std::fmt::Display>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::fmt::Display>::fmt":{"E":["std::marker::Sized","std::fmt::Debug"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::fmt::Display>::fmt":{"E":["error::ErrorKind","error::VerboseError","error::Error","internal::Needed","error::VerboseErrorKind","traits::CompareResult","number::Endianness","<*mut T as std::fmt::Debug>","internal::Err","<&mut T as std::fmt::Debug>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseError","internal::Needed","error::Error","internal::Err","error::ErrorKind","number::Endianness","error::VerboseErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<internal::Err<E> as std::fmt::Display>::fmt(p0, p1);
+crate::<internal::Err<E> as std::fmt::Display>::fmt(p0, p1);
+<internal::Err<E>>::fmt(p0, p1);
-----------------
src/internal.rs <internal::Err<E> as std::error::Error>::source
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::error::Error>::source":{"E":["std::marker::Sized","std::fmt::Debug"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::error::Error>::source":{"E":["traits::CompareResult","internal::Err","error::Error","error::VerboseError","number::Endianness","<*const T as std::fmt::Debug>","error::VerboseErrorKind","internal::Needed","<&mut T as std::fmt::Debug>","error::ErrorKind"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","internal::Err","internal::Needed","error::VerboseError","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
+p0.source();
+<internal::Err<E> as std::error::Error>::source(p0);
+crate::<internal::Err<E> as std::error::Error>::source(p0);
+<internal::Err<E>>::source(p0);
-----------------
src/internal.rs <F as internal::Parser<I>>::parse
deps:{"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","std::ops::FnMut"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::VerboseError","error::Error","internal::Err","number::Endianness","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","error::ErrorKind"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<F as internal::Parser<I>>::parse(p0, p1);
+crate::<F as internal::Parser<I>>::parse(p0, p1);
+<F>::parse(p0, p1);
-----------------
src/internal.rs <(P1,) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1,) as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"P1":["internal::Parser","std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1,) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"P1":["internal::FlatMap","internal::Or","internal::AndThen","internal::Map","internal::Into","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::And"]},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","internal::AndThen","internal::MapOpt","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::FlatMap"],"G":["internal::Into","internal::FlatMap","internal::And","internal::MapRes","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Map"]},"internal::AndThen":{"F":["internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::And","internal::Or","internal::Into","internal::AndThen","internal::MapRes","internal::MapOpt"],"G":["internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Into","internal::MapRes","internal::Map","internal::Or","std::boxed::Box"]},"internal::Err":{"E":["internal::Err","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","number::Endianness","error::Error","error::VerboseError","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::Into","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::AndThen","internal::MapRes"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::MapRes","internal::Into","internal::AndThen","internal::And","internal::FlatMap","internal::MapOpt"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::Or","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapOpt","internal::MapRes","std::boxed::Box"],"G":["core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Into","internal::And"],"G":["core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::Or","std::boxed::Box","internal::MapRes","internal::Map","internal::AndThen","internal::And","internal::MapOpt"],"G":["core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::Map","<F as internal::Parser<I>>","internal::And","internal::Into","internal::Or","internal::MapOpt","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::AndThen"],"G":["<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Or","internal::AndThen","internal::MapOpt","internal::And","internal::Into","internal::Map","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1,)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1,) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1,) as internal::Parser<I>>::parse(p0, p1);
+<(P1,)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"P1":["internal::Parser","std::marker::Sized"],"P2":["internal::Parser","std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"P1":["internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::And","internal::Into","internal::MapRes","internal::MapOpt"],"P2":["internal::And","internal::FlatMap","std::boxed::Box","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::MapOpt"]},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::Into","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::MapRes","internal::MapOpt","internal::Map"],"G":["internal::MapOpt","internal::And","internal::Into","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::FlatMap","internal::MapRes"]},"internal::AndThen":{"F":["internal::Or","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::FlatMap","internal::And","internal::MapRes","internal::AndThen","internal::Map"],"G":["internal::Or","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Into"]},"internal::Err":{"E":["error::VerboseError","internal::Needed","error::ErrorKind","error::Error","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","error::VerboseErrorKind","number::Endianness"]},"internal::FlatMap":{"F":["internal::Into","internal::AndThen","internal::Map","internal::MapRes","internal::FlatMap","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapOpt"],"G":["core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::Map","internal::FlatMap","internal::Or","internal::Into","internal::And","internal::AndThen","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::FlatMap","internal::MapOpt","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::Into","internal::MapRes","std::boxed::Box"],"G":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"internal::MapOpt":{"F":["internal::And","internal::Into","internal::FlatMap","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::Map"],"G":["core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::And","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Map","internal::FlatMap","internal::Into","internal::MapOpt","internal::Or"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::MapRes","internal::Map"],"G":["internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Map","internal::Or","internal::MapRes","internal::FlatMap","internal::And"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3) as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P2":["std::marker::Sized","internal::Parser"],"P3":["std::marker::Sized","internal::Parser"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3) as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"P1":["internal::Map","internal::Into","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Or","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::AndThen"],"P2":["internal::MapRes","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Or","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::And"],"P3":["internal::MapOpt","internal::And","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into","internal::MapRes","internal::AndThen"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::And","internal::Map","internal::MapOpt","internal::FlatMap","internal::Or"],"G":["<F as internal::Parser<I>>","internal::Into","internal::And","internal::FlatMap","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Or","std::boxed::Box","internal::Map"]},"internal::AndThen":{"F":["internal::Map","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::And","internal::Or","internal::Into","internal::FlatMap","internal::MapOpt"],"G":["std::boxed::Box","internal::Or","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::And","internal::Map","internal::FlatMap"]},"internal::Err":{"E":["error::VerboseError","<*mut T as std::fmt::Debug>","number::Endianness","error::ErrorKind","error::VerboseErrorKind","internal::Needed","internal::Err","error::Error"]},"internal::FlatMap":{"F":["internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::Map","internal::Into","std::boxed::Box","internal::MapRes","internal::Or","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::Or","internal::MapRes","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::And","internal::AndThen","internal::Map"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::Or","std::boxed::Box"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::AndThen","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::And","internal::Or","std::boxed::Box"],"G":["core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::AndThen","internal::Map","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::FlatMap","internal::Into","std::boxed::Box"],"G":["core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["std::boxed::Box","internal::Map","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::Or","internal::AndThen","internal::MapOpt"],"G":["internal::AndThen","internal::Into","internal::Or","std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4) as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P2":["internal::Parser","std::marker::Sized"],"P3":["std::marker::Sized","internal::Parser"],"P4":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"P1":["internal::Into","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or","std::boxed::Box","internal::FlatMap","internal::And","internal::Map"],"P2":["internal::Into","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::And"],"P3":["<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Into","internal::And","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::AndThen","internal::Or"],"P4":["<F as internal::Parser<I>>","internal::And","internal::MapOpt","std::boxed::Box","internal::Map","internal::Into","internal::Or","internal::MapRes","internal::FlatMap","internal::AndThen"]},"<F as internal::Parser<I>>":{"F":["core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["std::boxed::Box","internal::Or","internal::FlatMap","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::MapOpt","internal::And"],"G":["internal::AndThen","internal::Map","std::boxed::Box","internal::And","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::MapOpt"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::Map","internal::And","std::boxed::Box","internal::Or","internal::MapRes","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::Into"],"G":["internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::And","internal::MapRes","internal::Or","internal::FlatMap","internal::AndThen","internal::MapOpt"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseError","internal::Err","internal::Needed","error::Error","number::Endianness","error::VerboseErrorKind","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Into","<F as internal::Parser<I>>","internal::And","internal::Map","internal::FlatMap","internal::Or","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::MapRes"],"G":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::And","internal::Or","std::boxed::Box","internal::Map","internal::AndThen","internal::MapOpt"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapOpt","internal::And","internal::Or","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::Map","internal::FlatMap","internal::AndThen","internal::MapRes"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::Map","internal::Or","internal::MapOpt","internal::And","internal::AndThen","std::boxed::Box","internal::MapRes"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Map"],"G":["core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::And","internal::FlatMap"],"G":["internal::MapRes","internal::MapOpt","internal::Map","internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::Or","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"P1":["internal::Parser","std::marker::Sized"],"P2":["std::marker::Sized","internal::Parser"],"P3":["internal::Parser","std::marker::Sized"],"P4":["std::marker::Sized","internal::Parser"],"P5":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5) as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"P1":["internal::FlatMap","internal::And","internal::AndThen","internal::Map","internal::Or","std::boxed::Box","internal::MapOpt","internal::Into","internal::MapRes","<F as internal::Parser<I>>"],"P2":["internal::Into","internal::And","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::AndThen","internal::MapOpt","std::boxed::Box"],"P3":["internal::MapOpt","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::MapRes","internal::Into","internal::Map","internal::FlatMap"],"P4":["internal::Map","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::And","internal::FlatMap","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::MapRes"],"P5":["internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Or","internal::Into","internal::And","internal::MapRes","internal::Map","internal::FlatMap","<F as internal::Parser<I>>"]},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::FlatMap","internal::AndThen","internal::MapOpt","internal::And","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::Into"],"G":["internal::And","std::boxed::Box","internal::Or","internal::Map","internal::FlatMap","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::AndThen"]},"internal::AndThen":{"F":["internal::Map","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapRes","internal::FlatMap","internal::And","std::boxed::Box"],"G":["internal::MapRes","internal::And","internal::Or","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Into","<F as internal::Parser<I>>"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Needed","error::VerboseError","error::ErrorKind","error::Error","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","number::Endianness"]},"internal::FlatMap":{"F":["internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::And","internal::MapOpt","internal::Map","internal::FlatMap","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::Or","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapRes","internal::MapOpt"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::And","internal::AndThen","internal::MapOpt","internal::Map","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapRes"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::And","internal::AndThen","internal::MapOpt","internal::Into","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Map","internal::FlatMap"],"G":["core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::FlatMap","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::And","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes"],"G":["core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap"]},"internal::Or":{"F":["internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::And"],"G":["std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Into","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6) as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P2":["std::marker::Sized","internal::Parser"],"P3":["std::marker::Sized","internal::Parser"],"P4":["internal::Parser","std::marker::Sized"],"P5":["std::marker::Sized","internal::Parser"],"P6":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6) as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"P1":["internal::AndThen","internal::And","internal::MapRes","internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::MapOpt"],"P2":["internal::And","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Or","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapRes"],"P3":["internal::And","internal::Map","internal::FlatMap","internal::AndThen","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapRes"],"P4":["internal::MapRes","internal::MapOpt","internal::Or","internal::Into","internal::And","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box"],"P5":["internal::Map","internal::FlatMap","internal::MapOpt","internal::And","std::boxed::Box","internal::Into","internal::Or","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>"],"P6":["internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::AndThen","internal::And","internal::Map","internal::MapRes","internal::Into","std::boxed::Box"]},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Map","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::And","std::boxed::Box","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I>>"],"G":["internal::AndThen","std::boxed::Box","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::And","internal::FlatMap","internal::Or","internal::Map"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Map","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into","internal::FlatMap","internal::And"],"G":["internal::MapRes","internal::And","internal::AndThen","internal::Map","internal::MapOpt","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::Or"]},"internal::Err":{"E":["number::Endianness","error::Error","error::ErrorKind","error::VerboseErrorKind","error::VerboseError","internal::Err","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::MapOpt","internal::Map","internal::Into","internal::Or","internal::MapRes","std::boxed::Box","internal::AndThen"],"G":["core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::MapOpt","internal::Map","internal::MapRes","std::boxed::Box","internal::Into","internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","internal::MapOpt","internal::Or","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::And"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::AndThen","internal::Into","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Or","internal::Map"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into","std::boxed::Box","internal::And","internal::FlatMap","internal::AndThen"],"G":["core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["internal::Into","internal::And","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::AndThen"],"G":["internal::MapOpt","internal::And","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::Into","internal::Or","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"P1":["internal::Parser","std::marker::Sized"],"P2":["internal::Parser","std::marker::Sized"],"P3":["std::marker::Sized","internal::Parser"],"P4":["std::marker::Sized","internal::Parser"],"P5":["std::marker::Sized","internal::Parser"],"P6":["internal::Parser","std::marker::Sized"],"P7":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7) as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"P1":["internal::AndThen","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::And"],"P2":["internal::MapRes","internal::Map","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","std::boxed::Box","internal::AndThen"],"P3":["internal::Into","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::And","internal::Map"],"P4":["internal::Or","internal::Map","internal::Into","internal::AndThen","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::And","internal::MapOpt","<F as internal::Parser<I>>"],"P5":["internal::Or","internal::MapRes","internal::Into","internal::Map","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::FlatMap"],"P6":["internal::FlatMap","internal::Map","std::boxed::Box","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::MapOpt","internal::AndThen"],"P7":["std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into","internal::Or","internal::MapRes","internal::And","internal::Map","<F as internal::Parser<I>>","internal::MapOpt"]},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::Into","internal::AndThen","internal::Or","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Map"],"G":["internal::MapRes","internal::Map","internal::And","internal::Or","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::AndThen"]},"internal::AndThen":{"F":["internal::Or","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::AndThen"],"G":["internal::MapOpt","internal::Or","internal::FlatMap","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::And","internal::AndThen"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error","internal::Err","internal::Needed","number::Endianness","error::VerboseError","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","internal::FlatMap","std::boxed::Box","internal::And","internal::Or","internal::Map","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::Or","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::And","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::FlatMap","internal::Into","internal::AndThen","internal::MapOpt","internal::Map"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::MapRes","internal::And","internal::Map","internal::Or","internal::FlatMap","internal::Into"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::AndThen","internal::And","internal::Into","internal::Map","internal::Or","internal::FlatMap","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt"],"G":["core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::And","std::boxed::Box","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::Or","internal::MapRes","internal::AndThen"],"G":["internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8) as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P2":["std::marker::Sized","internal::Parser"],"P3":["std::marker::Sized","internal::Parser"],"P4":["std::marker::Sized","internal::Parser"],"P5":["internal::Parser","std::marker::Sized"],"P6":["std::marker::Sized","internal::Parser"],"P7":["std::marker::Sized","internal::Parser"],"P8":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8) as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"P1":["<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::MapRes","internal::Map","std::boxed::Box","internal::Or","internal::Into","internal::AndThen","internal::FlatMap"],"P2":["internal::Or","internal::MapOpt","internal::And","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map","internal::Into"],"P3":["<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::Map","internal::Into","internal::Or","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::AndThen"],"P4":["<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::Into","internal::MapOpt","internal::And","internal::AndThen","internal::Map","internal::Or"],"P5":["std::boxed::Box","internal::MapOpt","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::Or","internal::FlatMap","internal::Into"],"P6":["internal::And","internal::MapRes","internal::Map","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Or","internal::FlatMap","internal::MapOpt"],"P7":["internal::MapRes","internal::Into","internal::MapOpt","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::AndThen","internal::And"],"P8":["internal::FlatMap","internal::Into","internal::MapOpt","internal::Or","internal::MapRes","internal::AndThen","internal::Map","internal::And","std::boxed::Box","<F as internal::Parser<I>>"]},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Or","std::boxed::Box","internal::Map","internal::MapOpt","internal::AndThen","internal::Into","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap"],"G":["internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Map","std::boxed::Box","internal::And","internal::Into","internal::FlatMap","internal::AndThen"]},"internal::AndThen":{"F":["internal::Into","internal::And","internal::Or","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes"],"G":["internal::MapRes","internal::FlatMap","internal::Into","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::And","internal::AndThen","std::boxed::Box"]},"internal::Err":{"E":["internal::Err","number::Endianness","error::VerboseErrorKind","error::Error","error::VerboseError","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::Or","std::boxed::Box"],"G":["core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::MapOpt","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::And","internal::Or","internal::Map","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapOpt","internal::Into","std::boxed::Box","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::FlatMap","internal::AndThen"],"G":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::MapOpt":{"F":["internal::AndThen","std::boxed::Box","internal::MapOpt","internal::And","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Or"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::MapRes","internal::AndThen","std::boxed::Box","internal::Map","internal::Into","internal::And","internal::FlatMap","internal::MapOpt","internal::Or","<F as internal::Parser<I>>"],"G":["core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["internal::Or","std::boxed::Box","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::And","internal::FlatMap","internal::MapRes","internal::Map"],"G":["internal::AndThen","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::MapRes","std::boxed::Box","internal::Or","internal::MapOpt"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P2":["internal::Parser","std::marker::Sized"],"P3":["internal::Parser","std::marker::Sized"],"P4":["std::marker::Sized","internal::Parser"],"P5":["internal::Parser","std::marker::Sized"],"P6":["std::marker::Sized","internal::Parser"],"P7":["internal::Parser","std::marker::Sized"],"P8":["std::marker::Sized","internal::Parser"],"P9":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::AndThen","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Into","internal::Map","internal::And","internal::FlatMap"],"P2":["internal::AndThen","internal::Or","internal::And","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::Into","std::boxed::Box","internal::MapRes"],"P3":["internal::MapRes","internal::MapOpt","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::Or","internal::Into","internal::And"],"P4":["internal::Or","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::FlatMap","internal::MapRes","internal::And","internal::Into"],"P5":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::Into","internal::And","internal::MapOpt","internal::Map","internal::AndThen"],"P6":["internal::FlatMap","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Or","internal::Map","std::boxed::Box","internal::AndThen"],"P7":["internal::Map","internal::AndThen","internal::MapOpt","internal::And","internal::Into","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes"],"P8":["internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::AndThen","std::boxed::Box","internal::Map","internal::And","internal::MapOpt","internal::Into"],"P9":["internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Or","internal::Into","internal::MapRes"]},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::AndThen","internal::And","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::Map"],"G":["internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Map","std::boxed::Box","internal::Or","internal::MapRes","internal::MapOpt","internal::Into","internal::FlatMap"]},"internal::AndThen":{"F":["internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::Into","internal::MapRes"],"G":["internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Into","internal::Map"]},"internal::Err":{"E":["internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::VerboseErrorKind","error::ErrorKind","error::VerboseError","error::Error","internal::Needed"]},"internal::FlatMap":{"F":["internal::MapRes","std::boxed::Box","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::Or","internal::FlatMap"],"G":["core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::Map","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Into"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"internal::MapOpt":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::Map","internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap"],"G":["core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::Map","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Into","internal::Or","internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>"],"G":["core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["internal::Into","internal::FlatMap","internal::And","internal::MapOpt","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::MapRes","std::boxed::Box"],"G":["<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::Map","internal::Into","internal::FlatMap","internal::Or","internal::AndThen","internal::MapRes","internal::MapOpt"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["internal::Parser","std::marker::Sized"],"P10":["internal::Parser","std::marker::Sized"],"P2":["std::marker::Sized","internal::Parser"],"P3":["std::marker::Sized","internal::Parser"],"P4":["internal::Parser","std::marker::Sized"],"P5":["std::marker::Sized","internal::Parser"],"P6":["internal::Parser","std::marker::Sized"],"P7":["internal::Parser","std::marker::Sized"],"P8":["std::marker::Sized","internal::Parser"],"P9":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::And","internal::FlatMap","internal::Or","internal::Map","internal::MapOpt"],"P10":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::FlatMap","internal::Into","internal::MapRes","internal::And","internal::Map"],"P2":["internal::AndThen","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::And","internal::MapOpt","internal::Into","internal::Or"],"P3":["internal::MapOpt","internal::MapRes","internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::And","internal::Into"],"P4":["internal::Or","std::boxed::Box","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::And","internal::AndThen","internal::FlatMap"],"P5":["internal::Or","internal::MapOpt","internal::FlatMap","internal::And","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::AndThen","std::boxed::Box"],"P6":["<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Or","internal::And","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","internal::Into"],"P7":["internal::MapRes","internal::AndThen","internal::And","internal::Into","internal::MapOpt","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","std::boxed::Box"],"P8":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::Map","internal::MapRes","internal::Or"],"P9":["internal::Into","std::boxed::Box","internal::FlatMap","internal::Map","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::AndThen"]},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::FlatMap","internal::MapOpt","internal::Map","internal::MapRes","internal::And","std::boxed::Box","internal::Or"],"G":["<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::AndThen","internal::Into","internal::MapOpt","std::boxed::Box","internal::Map","internal::FlatMap","internal::And"]},"internal::AndThen":{"F":["internal::MapOpt","internal::FlatMap","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::Map","std::boxed::Box","internal::Into","internal::And"],"G":["<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Or","internal::AndThen","internal::FlatMap","internal::And","internal::Into","internal::Map","internal::MapOpt"]},"internal::Err":{"E":["internal::Needed","error::Error","number::Endianness","error::VerboseError","error::VerboseErrorKind","internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::And","std::boxed::Box","internal::MapRes","internal::Map","internal::FlatMap","internal::Into","internal::AndThen","internal::MapOpt","internal::Or","<F as internal::Parser<I>>"],"G":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::Into","internal::And","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","internal::Or"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Or","internal::Into","internal::AndThen","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Map","internal::FlatMap"],"G":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::AndThen","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::Into","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes"],"G":["core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::MapRes","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::MapOpt","internal::And","internal::AndThen","internal::FlatMap"],"G":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Map","internal::Into","internal::Or","internal::AndThen","internal::And","internal::MapRes","std::boxed::Box"],"G":["internal::Into","internal::MapOpt","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::FlatMap","internal::Map","internal::MapRes","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P10":["std::marker::Sized","internal::Parser"],"P11":["std::marker::Sized","internal::Parser"],"P2":["std::marker::Sized","internal::Parser"],"P3":["internal::Parser","std::marker::Sized"],"P4":["std::marker::Sized","internal::Parser"],"P5":["std::marker::Sized","internal::Parser"],"P6":["std::marker::Sized","internal::Parser"],"P7":["internal::Parser","std::marker::Sized"],"P8":["internal::Parser","std::marker::Sized"],"P9":["internal::Parser","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::cmp::Eq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::And","internal::Map","internal::MapRes","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::AndThen","internal::FlatMap","internal::MapOpt"],"P10":["internal::And","internal::Map","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box"],"P11":["internal::Or","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","internal::And","internal::Into"],"P2":["<F as internal::Parser<I>>","internal::MapRes","internal::Into","std::boxed::Box","internal::MapOpt","internal::Or","internal::FlatMap","internal::Map","internal::AndThen","internal::And"],"P3":["std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapOpt"],"P4":["internal::Map","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Into","internal::AndThen","internal::MapOpt"],"P5":["internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::Into","internal::MapRes","internal::MapOpt","internal::Map","std::boxed::Box"],"P6":["internal::And","internal::Into","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::Or"],"P7":["internal::MapOpt","internal::Or","std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::AndThen","internal::FlatMap"],"P8":["internal::Map","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapRes","internal::Or"],"P9":["internal::AndThen","internal::MapRes","internal::Or","std::boxed::Box","internal::Map","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Into"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Or","internal::AndThen","internal::And","internal::Map","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Into"],"G":["internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Or","std::boxed::Box","internal::Into","internal::MapRes","internal::FlatMap","internal::And"]},"internal::AndThen":{"F":["internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::And","internal::Into","internal::FlatMap","internal::MapRes"],"G":["<F as internal::Parser<I>>","internal::And","internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","internal::MapOpt","internal::Into","internal::AndThen","internal::MapRes"]},"internal::Err":{"E":["error::VerboseError","number::Endianness","internal::Needed","internal::Err","error::ErrorKind","<*mut T as std::fmt::Debug>","error::Error","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::Map","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::MapRes","std::boxed::Box","internal::MapOpt"],"G":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::MapRes","internal::Or","internal::MapOpt","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapRes","internal::And","internal::Into","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt"],"G":["core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::AndThen","internal::MapRes","internal::FlatMap","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::And","internal::MapOpt"],"G":["core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsWhitespace"]},"internal::MapRes":{"F":["internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::Map","internal::FlatMap","internal::MapRes","internal::And","std::boxed::Box"],"G":["std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::Into"],"G":["internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::MapOpt","internal::MapRes","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P10":["internal::Parser","std::marker::Sized"],"P11":["internal::Parser","std::marker::Sized"],"P12":["internal::Parser","std::marker::Sized"],"P2":["std::marker::Sized","internal::Parser"],"P3":["internal::Parser","std::marker::Sized"],"P4":["internal::Parser","std::marker::Sized"],"P5":["internal::Parser","std::marker::Sized"],"P6":["std::marker::Sized","internal::Parser"],"P7":["std::marker::Sized","internal::Parser"],"P8":["internal::Parser","std::marker::Sized"],"P9":["internal::Parser","std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::Map","std::boxed::Box","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::And","internal::Into","internal::MapRes"],"P10":["std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Or","internal::And","internal::Into","internal::MapRes","internal::Map"],"P11":["internal::Into","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Or","internal::And","<F as internal::Parser<I>>","internal::Map"],"P12":["internal::And","internal::Map","std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap"],"P2":["internal::Map","internal::Into","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Or"],"P3":["<F as internal::Parser<I>>","internal::AndThen","internal::And","std::boxed::Box","internal::MapRes","internal::Into","internal::Or","internal::FlatMap","internal::Map","internal::MapOpt"],"P4":["std::boxed::Box","internal::And","internal::FlatMap","internal::Or","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::Map"],"P5":["std::boxed::Box","internal::And","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Into","internal::Or","internal::FlatMap","internal::Map","<F as internal::Parser<I>>"],"P6":["internal::Map","internal::FlatMap","internal::Or","internal::And","internal::Into","internal::MapRes","internal::AndThen","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>"],"P7":["internal::MapRes","internal::MapOpt","internal::Map","internal::Or","internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::And"],"P8":["<F as internal::Parser<I>>","internal::Map","internal::MapRes","std::boxed::Box","internal::Or","internal::AndThen","internal::MapOpt","internal::And","internal::Into","internal::FlatMap"],"P9":["internal::AndThen","internal::Into","internal::MapRes","internal::And","internal::MapOpt","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::FlatMap"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::FlatMap","std::boxed::Box","internal::Or","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::Into","internal::And"],"G":["internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::And","internal::MapOpt","internal::Map","internal::AndThen","internal::Or","internal::Into"]},"internal::AndThen":{"F":["internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::And","internal::Map","internal::MapRes","internal::MapOpt"],"G":["std::boxed::Box","internal::Map","internal::AndThen","internal::And","internal::Into","internal::FlatMap","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","number::Endianness","error::Error","internal::Err","<*const T as std::fmt::Debug>","error::VerboseErrorKind","internal::Needed"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::FlatMap","internal::And","internal::Into","std::boxed::Box","internal::MapRes","internal::AndThen","internal::Map"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::Map","internal::And","std::boxed::Box","internal::MapOpt","internal::Into","internal::Or","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::AndThen","internal::MapOpt"],"G":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::And","internal::Into","internal::AndThen","internal::Map"],"G":["core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap"]},"internal::MapRes":{"F":["internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapRes","internal::Or","std::boxed::Box","internal::MapOpt","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::MapRes","internal::MapOpt"],"G":["internal::Into","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::FlatMap","internal::And","internal::Or","internal::MapRes"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O13":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["internal::Parser","std::marker::Sized"],"P10":["internal::Parser","std::marker::Sized"],"P11":["internal::Parser","std::marker::Sized"],"P12":["std::marker::Sized","internal::Parser"],"P13":["std::marker::Sized","internal::Parser"],"P2":["std::marker::Sized","internal::Parser"],"P3":["std::marker::Sized","internal::Parser"],"P4":["std::marker::Sized","internal::Parser"],"P5":["internal::Parser","std::marker::Sized"],"P6":["internal::Parser","std::marker::Sized"],"P7":["std::marker::Sized","internal::Parser"],"P8":["internal::Parser","std::marker::Sized"],"P9":["internal::Parser","std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O13":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::Or","internal::Into","internal::MapOpt","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box"],"P10":["internal::AndThen","internal::Map","internal::MapOpt","internal::Into","internal::Or","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::And"],"P11":["internal::Map","internal::MapOpt","internal::Into","internal::And","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","std::boxed::Box"],"P12":["std::boxed::Box","internal::Or","internal::AndThen","internal::Into","internal::And","internal::MapOpt","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::FlatMap"],"P13":["std::boxed::Box","internal::AndThen","internal::MapRes","internal::Or","internal::MapOpt","internal::FlatMap","internal::And","internal::Into","internal::Map","<F as internal::Parser<I>>"],"P2":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::AndThen","internal::Map","internal::MapOpt","std::boxed::Box","internal::And","internal::Into"],"P3":["internal::FlatMap","internal::MapOpt","internal::Into","internal::AndThen","internal::And","internal::Or","internal::MapRes","internal::Map","std::boxed::Box","<F as internal::Parser<I>>"],"P4":["<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::Map","internal::And","internal::Or","internal::Into","std::boxed::Box","internal::AndThen"],"P5":["std::boxed::Box","internal::MapRes","internal::Map","internal::Into","internal::And","internal::Or","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap"],"P6":["internal::MapRes","std::boxed::Box","internal::AndThen","internal::Map","internal::MapOpt","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Or"],"P7":["internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::And","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::FlatMap"],"P8":["internal::And","internal::Map","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::Or"],"P9":["internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Or"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::MapRes","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::And"],"G":["internal::FlatMap","internal::Or","internal::MapOpt","internal::AndThen","internal::And","internal::MapRes","internal::Into","internal::Map","<F as internal::Parser<I>>","std::boxed::Box"]},"internal::AndThen":{"F":["internal::MapRes","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Or","internal::And","internal::FlatMap","internal::Map"],"G":["<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::Map","internal::Or","internal::And","std::boxed::Box","internal::MapRes","internal::AndThen","internal::FlatMap"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Needed","error::Error","number::Endianness","<*const T as std::fmt::Debug>","error::VerboseError","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::Or","internal::MapRes","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box"],"G":["core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::AndThen","internal::Map","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::Into"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::And","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Map","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"]},"internal::MapOpt":{"F":["internal::And","internal::Or","internal::FlatMap","internal::Into","internal::MapRes","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt"],"G":["core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::And","internal::Or","std::boxed::Box","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapOpt","internal::Into"],"G":["core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"]},"internal::Or":{"F":["internal::MapRes","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::And","internal::FlatMap","std::boxed::Box","internal::Map"],"G":["internal::Map","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::MapOpt","internal::Or","internal::AndThen","internal::Into","std::boxed::Box","internal::MapRes"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O13":["std::marker::Sized"],"O14":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["internal::Parser","std::marker::Sized"],"P10":["internal::Parser","std::marker::Sized"],"P11":["std::marker::Sized","internal::Parser"],"P12":["internal::Parser","std::marker::Sized"],"P13":["internal::Parser","std::marker::Sized"],"P14":["std::marker::Sized","internal::Parser"],"P2":["internal::Parser","std::marker::Sized"],"P3":["std::marker::Sized","internal::Parser"],"P4":["internal::Parser","std::marker::Sized"],"P5":["internal::Parser","std::marker::Sized"],"P6":["std::marker::Sized","internal::Parser"],"P7":["internal::Parser","std::marker::Sized"],"P8":["internal::Parser","std::marker::Sized"],"P9":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O13":["RUG_ANY"],"O14":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Or","internal::AndThen","internal::And"],"P10":["internal::MapOpt","internal::Into","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Or","internal::Map","internal::AndThen"],"P11":["internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Map","internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::MapRes","internal::MapOpt"],"P12":["internal::Or","internal::MapRes","internal::Into","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::And","internal::MapOpt","std::boxed::Box"],"P13":["internal::And","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen","internal::Or"],"P14":["internal::FlatMap","internal::AndThen","internal::MapOpt","internal::Map","internal::Or","internal::And","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::Into"],"P2":["<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::MapRes","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::And"],"P3":["std::boxed::Box","internal::MapOpt","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::FlatMap","internal::Map","internal::Into"],"P4":["internal::And","internal::Into","internal::MapRes","internal::MapOpt","internal::Or","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box"],"P5":["internal::Or","internal::And","internal::MapRes","internal::Map","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I>>"],"P6":["internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::MapRes","internal::Or"],"P7":["internal::Into","std::boxed::Box","internal::AndThen","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Map"],"P8":["<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Map","internal::AndThen","internal::MapOpt","internal::Into","internal::And","internal::Or"],"P9":["internal::Into","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::And","internal::Or","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::Map"]},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["std::boxed::Box","internal::Map","internal::Or","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Into"],"G":["std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::AndThen","internal::And","internal::Into","internal::Or","internal::Map"]},"internal::AndThen":{"F":["internal::AndThen","internal::MapRes","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapOpt"],"G":["internal::Or","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::And","internal::Into"]},"internal::Err":{"E":["error::VerboseError","internal::Needed","error::ErrorKind","internal::Err","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","number::Endianness"]},"internal::FlatMap":{"F":["internal::AndThen","internal::FlatMap","internal::And","internal::MapRes","internal::Or","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Map"],"G":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::MapRes","internal::Into","internal::MapOpt","internal::Map","internal::FlatMap","internal::AndThen","internal::And","internal::Or","std::boxed::Box","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Into","std::boxed::Box","internal::Map","internal::MapRes","internal::FlatMap","internal::Or","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt"],"G":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>"]},"internal::MapOpt":{"F":["internal::MapRes","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Map","internal::And","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::FlatMap"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","internal::MapRes"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","internal::And"],"G":["internal::MapOpt","internal::Into","internal::MapRes","internal::And","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O13":["std::marker::Sized"],"O14":["std::marker::Sized"],"O15":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P10":["std::marker::Sized","internal::Parser"],"P11":["std::marker::Sized","internal::Parser"],"P12":["internal::Parser","std::marker::Sized"],"P13":["internal::Parser","std::marker::Sized"],"P14":["internal::Parser","std::marker::Sized"],"P15":["std::marker::Sized","internal::Parser"],"P2":["internal::Parser","std::marker::Sized"],"P3":["std::marker::Sized","internal::Parser"],"P4":["internal::Parser","std::marker::Sized"],"P5":["std::marker::Sized","internal::Parser"],"P6":["internal::Parser","std::marker::Sized"],"P7":["std::marker::Sized","internal::Parser"],"P8":["std::marker::Sized","internal::Parser"],"P9":["internal::Parser","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O13":["RUG_ANY"],"O14":["RUG_ANY"],"O15":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::AndThen","internal::And","internal::Or","internal::Into","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::MapRes"],"P10":["internal::And","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap"],"P11":["internal::MapRes","internal::And","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::Into","internal::AndThen","internal::Map"],"P12":["internal::FlatMap","internal::Or","internal::MapOpt","internal::AndThen","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Map","std::boxed::Box"],"P13":["<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::MapRes","internal::And"],"P14":["internal::FlatMap","internal::Or","internal::Into","internal::Map","internal::And","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box"],"P15":["internal::AndThen","std::boxed::Box","internal::Into","internal::MapRes","internal::Map","internal::And","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::FlatMap"],"P2":["internal::FlatMap","std::boxed::Box","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Into","internal::Or","internal::AndThen"],"P3":["internal::Or","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::MapRes","internal::Map","internal::MapOpt"],"P4":["internal::Or","internal::And","internal::MapRes","internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::AndThen"],"P5":["internal::Or","internal::MapOpt","internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","std::boxed::Box","internal::MapRes"],"P6":["internal::Into","internal::And","internal::MapOpt","internal::MapRes","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Map"],"P7":["internal::MapOpt","internal::Into","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Or","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Map"],"P8":["internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::AndThen","internal::FlatMap","internal::Or","internal::MapRes","std::boxed::Box","internal::Into"],"P9":["internal::And","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Or","internal::MapRes","internal::Into","internal::Map"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapRes","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Into","internal::And"],"G":["internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::And","internal::Into"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::Map","internal::MapRes","internal::FlatMap","internal::And","internal::Or","std::boxed::Box","internal::AndThen"],"G":["std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::AndThen","internal::FlatMap","internal::MapRes","internal::And","internal::Map","internal::MapOpt"]},"internal::Err":{"E":["internal::Needed","number::Endianness","internal::Err","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::Error"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::Or","internal::Map","internal::AndThen","internal::And","internal::MapOpt","std::boxed::Box","internal::FlatMap"],"G":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::MapOpt","std::boxed::Box","internal::Into","internal::AndThen","internal::Map","internal::MapRes","internal::And","internal::Or","<F as internal::Parser<I>>","internal::FlatMap"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::FlatMap","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::And","internal::MapOpt","internal::Or","std::boxed::Box","internal::AndThen","internal::MapRes"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::Into","internal::FlatMap","internal::MapRes","internal::And","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::Or"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::Map","internal::And","std::boxed::Box","internal::Or","internal::MapOpt","internal::MapRes"],"G":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::MapOpt","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","internal::And"],"G":["internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::AndThen","internal::Into","internal::And","std::boxed::Box","internal::Map","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O13":["std::marker::Sized"],"O14":["std::marker::Sized"],"O15":["std::marker::Sized"],"O16":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P10":["internal::Parser","std::marker::Sized"],"P11":["internal::Parser","std::marker::Sized"],"P12":["std::marker::Sized","internal::Parser"],"P13":["internal::Parser","std::marker::Sized"],"P14":["std::marker::Sized","internal::Parser"],"P15":["std::marker::Sized","internal::Parser"],"P16":["std::marker::Sized","internal::Parser"],"P2":["internal::Parser","std::marker::Sized"],"P3":["internal::Parser","std::marker::Sized"],"P4":["internal::Parser","std::marker::Sized"],"P5":["std::marker::Sized","internal::Parser"],"P6":["internal::Parser","std::marker::Sized"],"P7":["internal::Parser","std::marker::Sized"],"P8":["std::marker::Sized","internal::Parser"],"P9":["internal::Parser","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O13":["RUG_ANY"],"O14":["RUG_ANY"],"O15":["RUG_ANY"],"O16":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::Or","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::FlatMap","internal::MapOpt","internal::MapRes"],"P10":["internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Map","internal::And","internal::MapOpt","internal::Into","std::boxed::Box"],"P11":["<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::AndThen","internal::Into","internal::Or","internal::MapRes","std::boxed::Box","internal::And","internal::MapOpt"],"P12":["internal::Map","internal::MapRes","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::And","internal::FlatMap","std::boxed::Box","internal::Or","internal::AndThen"],"P13":["<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::Or","internal::Into","internal::AndThen","internal::MapRes","internal::And","std::boxed::Box","internal::MapOpt"],"P14":["internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Or","internal::Map","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Into"],"P15":["internal::And","internal::Into","internal::AndThen","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::Or"],"P16":["<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Map","internal::And","internal::MapRes","internal::Into","std::boxed::Box","internal::Or"],"P2":["internal::AndThen","internal::Into","internal::Map","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","std::boxed::Box","internal::And"],"P3":["internal::AndThen","internal::Or","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Map","internal::Into","std::boxed::Box"],"P4":["internal::FlatMap","std::boxed::Box","internal::Or","internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Into"],"P5":["internal::Or","internal::MapOpt","internal::Into","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I>>"],"P6":["internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::And","internal::Into","std::boxed::Box","internal::FlatMap"],"P7":["internal::Map","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::MapOpt","internal::Into","internal::Or"],"P8":["internal::Map","internal::MapOpt","internal::MapRes","internal::Into","internal::FlatMap","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I>>","std::boxed::Box"],"P9":["internal::Or","internal::Into","internal::And","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::MapRes"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapRes","internal::MapOpt","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map"],"G":["internal::MapOpt","internal::And","internal::MapRes","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::FlatMap","internal::Into"]},"internal::AndThen":{"F":["internal::AndThen","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::MapRes"],"G":["internal::And","internal::Map","internal::Into","internal::FlatMap","internal::Or","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed","error::Error","number::Endianness","error::VerboseErrorKind","error::VerboseError","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Into","internal::MapRes","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::Map","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::MapOpt","internal::And","std::boxed::Box","internal::MapRes","internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::AndThen"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Map","internal::Or","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","internal::And","internal::MapOpt","<F as internal::Parser<I>>"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace"]},"internal::MapOpt":{"F":["internal::Map","internal::And","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap"],"G":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::And","internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::MapRes","internal::AndThen","internal::Or"],"G":["core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap"]},"internal::Or":{"F":["std::boxed::Box","internal::Or","internal::And","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::FlatMap"],"G":["internal::Or","internal::MapOpt","internal::MapRes","internal::Into","std::boxed::Box","internal::FlatMap","internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O13":["std::marker::Sized"],"O14":["std::marker::Sized"],"O15":["std::marker::Sized"],"O16":["std::marker::Sized"],"O17":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P10":["std::marker::Sized","internal::Parser"],"P11":["std::marker::Sized","internal::Parser"],"P12":["std::marker::Sized","internal::Parser"],"P13":["internal::Parser","std::marker::Sized"],"P14":["std::marker::Sized","internal::Parser"],"P15":["internal::Parser","std::marker::Sized"],"P16":["std::marker::Sized","internal::Parser"],"P17":["internal::Parser","std::marker::Sized"],"P2":["std::marker::Sized","internal::Parser"],"P3":["internal::Parser","std::marker::Sized"],"P4":["internal::Parser","std::marker::Sized"],"P5":["std::marker::Sized","internal::Parser"],"P6":["internal::Parser","std::marker::Sized"],"P7":["std::marker::Sized","internal::Parser"],"P8":["std::marker::Sized","internal::Parser"],"P9":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O13":["RUG_ANY"],"O14":["RUG_ANY"],"O15":["RUG_ANY"],"O16":["RUG_ANY"],"O17":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::Into","std::boxed::Box","internal::Map","internal::MapRes","internal::FlatMap","internal::MapOpt","internal::And","internal::AndThen","internal::Or","<F as internal::Parser<I>>"],"P10":["<F as internal::Parser<I>>","internal::Or","internal::FlatMap","std::boxed::Box","internal::Map","internal::MapRes","internal::Into","internal::AndThen","internal::And","internal::MapOpt"],"P11":["<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Or","internal::Map","internal::Into","internal::AndThen","internal::And"],"P12":["internal::MapOpt","internal::And","internal::MapRes","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::AndThen"],"P13":["internal::MapOpt","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapRes","internal::AndThen","std::boxed::Box","internal::FlatMap"],"P14":["internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","std::boxed::Box","internal::And","internal::FlatMap","internal::MapRes","internal::Into","internal::Or"],"P15":["std::boxed::Box","internal::MapOpt","internal::And","internal::Map","internal::Into","internal::FlatMap","internal::MapRes","internal::Or","internal::AndThen","<F as internal::Parser<I>>"],"P16":["internal::AndThen","internal::Map","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Or","internal::And","internal::MapOpt"],"P17":["internal::Map","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::Into","internal::And","<F as internal::Parser<I>>","internal::Or","internal::FlatMap"],"P2":["internal::Or","internal::MapOpt","internal::Map","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::And"],"P3":["internal::MapOpt","internal::Or","std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Into","internal::FlatMap"],"P4":["internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap","internal::MapOpt","internal::Or","internal::MapRes","internal::Into","internal::And","<F as internal::Parser<I>>"],"P5":["internal::MapOpt","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::MapRes","internal::AndThen","internal::And","internal::Into"],"P6":["internal::FlatMap","internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::MapOpt"],"P7":["internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::FlatMap","internal::MapRes","internal::And"],"P8":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::Map","internal::MapRes"],"P9":["<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::Or","internal::MapRes","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Map","internal::Into"]},"<F as internal::Parser<I>>":{"F":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::AndThen","internal::MapOpt","internal::Map","internal::MapRes","internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Or"],"G":["internal::MapRes","std::boxed::Box","internal::Or","internal::AndThen","internal::Into","internal::FlatMap","internal::MapOpt","internal::Map","internal::And","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::Map","internal::And","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::MapRes","internal::FlatMap"],"G":["internal::Map","internal::AndThen","internal::MapRes","internal::Or","internal::FlatMap","internal::Into","std::boxed::Box","internal::And","internal::MapOpt","<F as internal::Parser<I>>"]},"internal::Err":{"E":["error::VerboseError","error::ErrorKind","internal::Needed","number::Endianness","internal::Err","error::VerboseErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::Error"]},"internal::FlatMap":{"F":["internal::And","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::Map","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::FlatMap","std::boxed::Box","internal::Map","internal::MapRes","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Or","internal::MapOpt","internal::And","internal::Map","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","<F as internal::Parser<I>>"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty"]},"internal::MapOpt":{"F":["internal::AndThen","internal::Into","internal::MapRes","internal::Map","internal::Or","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::And","<F as internal::Parser<I>>"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::Into","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Or","internal::Map","internal::MapOpt"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::Or","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::AndThen","internal::MapRes","internal::And","internal::FlatMap"],"G":["internal::AndThen","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::Or","internal::Map","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O13":["std::marker::Sized"],"O14":["std::marker::Sized"],"O15":["std::marker::Sized"],"O16":["std::marker::Sized"],"O17":["std::marker::Sized"],"O18":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["internal::Parser","std::marker::Sized"],"P10":["std::marker::Sized","internal::Parser"],"P11":["std::marker::Sized","internal::Parser"],"P12":["internal::Parser","std::marker::Sized"],"P13":["internal::Parser","std::marker::Sized"],"P14":["std::marker::Sized","internal::Parser"],"P15":["internal::Parser","std::marker::Sized"],"P16":["std::marker::Sized","internal::Parser"],"P17":["internal::Parser","std::marker::Sized"],"P18":["std::marker::Sized","internal::Parser"],"P2":["internal::Parser","std::marker::Sized"],"P3":["std::marker::Sized","internal::Parser"],"P4":["internal::Parser","std::marker::Sized"],"P5":["internal::Parser","std::marker::Sized"],"P6":["std::marker::Sized","internal::Parser"],"P7":["std::marker::Sized","internal::Parser"],"P8":["internal::Parser","std::marker::Sized"],"P9":["internal::Parser","std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18) as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O13":["RUG_ANY"],"O14":["RUG_ANY"],"O15":["RUG_ANY"],"O16":["RUG_ANY"],"O17":["RUG_ANY"],"O18":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::MapOpt","internal::FlatMap","internal::Map","internal::And","internal::Or","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::AndThen"],"P10":["std::boxed::Box","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::MapOpt","internal::Into","internal::Map","internal::FlatMap"],"P11":["internal::Map","std::boxed::Box","internal::MapOpt","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::FlatMap","internal::Into"],"P12":["internal::AndThen","internal::Map","internal::MapRes","internal::FlatMap","internal::And","internal::MapOpt","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Into"],"P13":["internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::FlatMap","internal::And","internal::Into","std::boxed::Box","internal::Map","internal::MapRes"],"P14":["internal::Map","internal::MapRes","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::Into"],"P15":["internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::And","internal::MapRes","internal::FlatMap","internal::Into","std::boxed::Box"],"P16":["internal::FlatMap","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapOpt","internal::MapRes","internal::Map","std::boxed::Box"],"P17":["internal::And","internal::Map","internal::FlatMap","internal::MapRes","internal::Into","std::boxed::Box","internal::Or","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>"],"P18":["internal::MapRes","internal::MapOpt","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::Into","internal::FlatMap","internal::Map"],"P2":["internal::MapOpt","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box","internal::Into","internal::Map"],"P3":["internal::MapRes","internal::AndThen","internal::And","internal::FlatMap","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::Or"],"P4":["internal::AndThen","std::boxed::Box","internal::Map","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Into","internal::MapRes"],"P5":["std::boxed::Box","internal::Into","internal::MapOpt","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::And","internal::AndThen"],"P6":["internal::AndThen","internal::MapRes","internal::Into","internal::Map","std::boxed::Box","internal::Or","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::And"],"P7":["internal::FlatMap","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Map","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::And"],"P8":["internal::AndThen","internal::Map","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::MapOpt","std::boxed::Box","internal::FlatMap"],"P9":["internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::And","internal::Or","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Into"]},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Into","internal::And","internal::MapOpt","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::MapRes","std::boxed::Box","internal::AndThen"],"G":["internal::Map","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::And","internal::Into","internal::AndThen","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::And","internal::Or","internal::MapRes","internal::MapOpt","internal::FlatMap"],"G":["internal::Or","internal::And","internal::Map","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Into"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","internal::Needed","error::Error","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Map","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::AndThen","internal::And","internal::MapOpt","internal::Or"],"G":["core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::And","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapRes","internal::MapOpt"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::And","internal::Into","internal::MapOpt","internal::AndThen","internal::Map","internal::MapRes","internal::FlatMap","internal::Or","<F as internal::Parser<I>>"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::MapRes","internal::Or","internal::Map"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsWhitespace"]},"internal::MapRes":{"F":["internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["internal::FlatMap","internal::Map","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::AndThen","internal::Or","std::boxed::Box"],"G":["std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","internal::MapOpt","internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::And"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19) as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O13":["std::marker::Sized"],"O14":["std::marker::Sized"],"O15":["std::marker::Sized"],"O16":["std::marker::Sized"],"O17":["std::marker::Sized"],"O18":["std::marker::Sized"],"O19":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P10":["std::marker::Sized","internal::Parser"],"P11":["std::marker::Sized","internal::Parser"],"P12":["std::marker::Sized","internal::Parser"],"P13":["internal::Parser","std::marker::Sized"],"P14":["std::marker::Sized","internal::Parser"],"P15":["std::marker::Sized","internal::Parser"],"P16":["std::marker::Sized","internal::Parser"],"P17":["std::marker::Sized","internal::Parser"],"P18":["internal::Parser","std::marker::Sized"],"P19":["std::marker::Sized","internal::Parser"],"P2":["internal::Parser","std::marker::Sized"],"P3":["internal::Parser","std::marker::Sized"],"P4":["internal::Parser","std::marker::Sized"],"P5":["std::marker::Sized","internal::Parser"],"P6":["internal::Parser","std::marker::Sized"],"P7":["internal::Parser","std::marker::Sized"],"P8":["std::marker::Sized","internal::Parser"],"P9":["internal::Parser","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O13":["RUG_ANY"],"O14":["RUG_ANY"],"O15":["RUG_ANY"],"O16":["RUG_ANY"],"O17":["RUG_ANY"],"O18":["RUG_ANY"],"O19":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::MapRes","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::Into"],"P10":["internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Into","internal::Map","std::boxed::Box"],"P11":["internal::FlatMap","internal::And","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapRes","internal::MapOpt","std::boxed::Box"],"P12":["internal::AndThen","internal::MapRes","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::Map","internal::Into","internal::MapOpt"],"P13":["internal::Into","internal::And","internal::Map","internal::MapRes","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::MapOpt"],"P14":["<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::AndThen","internal::And","internal::MapOpt","std::boxed::Box","internal::Map","internal::Or","internal::MapRes"],"P15":["<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Or","internal::MapRes","std::boxed::Box","internal::Into","internal::Map","internal::And"],"P16":["internal::Into","internal::FlatMap","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::And","internal::Map","std::boxed::Box","internal::MapRes"],"P17":["internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::And"],"P18":["std::boxed::Box","internal::Or","internal::MapOpt","internal::Into","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapRes"],"P19":["internal::MapOpt","internal::MapRes","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::And"],"P2":["internal::MapRes","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","internal::Or","internal::And","internal::MapOpt"],"P3":["internal::And","std::boxed::Box","internal::Map","internal::FlatMap","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes"],"P4":["<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::And","internal::MapRes","internal::FlatMap"],"P5":["internal::MapOpt","internal::And","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::FlatMap","internal::Map"],"P6":["internal::Map","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Or","internal::MapOpt","internal::And","std::boxed::Box"],"P7":["internal::AndThen","std::boxed::Box","internal::Or","internal::MapRes","internal::FlatMap","internal::Into","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::Map"],"P8":["internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::And","internal::Map","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Or"],"P9":["internal::Or","internal::MapOpt","internal::AndThen","internal::MapRes","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::Map","std::boxed::Box"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Into","internal::And","internal::FlatMap","internal::MapRes","internal::Map","internal::MapOpt","internal::AndThen","internal::Or","std::boxed::Box","<F as internal::Parser<I>>"],"G":["internal::And","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box","internal::MapRes"]},"internal::AndThen":{"F":["internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Or","internal::Map","internal::And","internal::AndThen","internal::MapRes"],"G":["internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::MapOpt"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","error::ErrorKind","internal::Needed","number::Endianness","<*mut T as std::fmt::Debug>","internal::Err","error::Error"]},"internal::FlatMap":{"F":["internal::Map","std::boxed::Box","internal::FlatMap","internal::And","internal::MapOpt","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapRes"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::And","internal::FlatMap","internal::Map","internal::MapRes","internal::AndThen","internal::Into"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","internal::Map","internal::And","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Or","std::boxed::Box"],"G":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["internal::MapRes","internal::Map","internal::MapOpt","internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::AndThen"],"G":["core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::AndThen","internal::Or","internal::FlatMap","internal::MapRes","internal::And","std::boxed::Box","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::Map"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::MapRes","internal::And","internal::Into","internal::Map"],"G":["internal::AndThen","internal::MapRes","internal::And","internal::Or","internal::Map","internal::FlatMap","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20) as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O13":["std::marker::Sized"],"O14":["std::marker::Sized"],"O15":["std::marker::Sized"],"O16":["std::marker::Sized"],"O17":["std::marker::Sized"],"O18":["std::marker::Sized"],"O19":["std::marker::Sized"],"O2":["std::marker::Sized"],"O20":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["internal::Parser","std::marker::Sized"],"P10":["std::marker::Sized","internal::Parser"],"P11":["std::marker::Sized","internal::Parser"],"P12":["std::marker::Sized","internal::Parser"],"P13":["internal::Parser","std::marker::Sized"],"P14":["internal::Parser","std::marker::Sized"],"P15":["std::marker::Sized","internal::Parser"],"P16":["internal::Parser","std::marker::Sized"],"P17":["internal::Parser","std::marker::Sized"],"P18":["internal::Parser","std::marker::Sized"],"P19":["internal::Parser","std::marker::Sized"],"P2":["internal::Parser","std::marker::Sized"],"P20":["std::marker::Sized","internal::Parser"],"P3":["internal::Parser","std::marker::Sized"],"P4":["internal::Parser","std::marker::Sized"],"P5":["std::marker::Sized","internal::Parser"],"P6":["std::marker::Sized","internal::Parser"],"P7":["std::marker::Sized","internal::Parser"],"P8":["internal::Parser","std::marker::Sized"],"P9":["std::marker::Sized","internal::Parser"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O13":["RUG_ANY"],"O14":["RUG_ANY"],"O15":["RUG_ANY"],"O16":["RUG_ANY"],"O17":["RUG_ANY"],"O18":["RUG_ANY"],"O19":["RUG_ANY"],"O2":["RUG_ANY"],"O20":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Into","internal::FlatMap","internal::MapRes","internal::Or"],"P10":["internal::MapRes","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::And"],"P11":["internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","std::boxed::Box","internal::Map","internal::Or","internal::MapRes","internal::AndThen","internal::MapOpt"],"P12":["internal::Into","internal::Map","internal::MapRes","std::boxed::Box","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::AndThen"],"P13":["internal::Or","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::Map","internal::MapOpt"],"P14":["internal::And","internal::MapOpt","internal::Into","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::Or"],"P15":["std::boxed::Box","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Into","internal::MapOpt","internal::AndThen","internal::Map"],"P16":["internal::Or","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::And","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap"],"P17":["internal::MapOpt","internal::FlatMap","internal::Map","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::And","internal::AndThen","std::boxed::Box","internal::Or"],"P18":["internal::AndThen","internal::Into","internal::Or","internal::Map","internal::And","internal::MapOpt","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap"],"P19":["internal::And","internal::MapOpt","internal::MapRes","internal::Map","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::Into"],"P2":["internal::Into","std::boxed::Box","internal::MapRes","internal::And","internal::FlatMap","internal::Or","internal::Map","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>"],"P20":["internal::Into","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Or","internal::FlatMap"],"P3":["std::boxed::Box","internal::And","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Map","internal::MapRes","internal::Into","internal::AndThen"],"P4":["internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::And","internal::Or","internal::AndThen","internal::Map","internal::FlatMap","internal::MapRes"],"P5":["std::boxed::Box","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Map"],"P6":["internal::MapOpt","internal::MapRes","internal::And","internal::AndThen","internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I>>"],"P7":["internal::MapOpt","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap"],"P8":["internal::AndThen","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::Or","internal::MapRes","internal::FlatMap","internal::And"],"P9":["internal::Or","internal::And","internal::Map","internal::MapOpt","internal::AndThen","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapRes"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapRes","internal::FlatMap"],"G":["internal::Map","internal::Into","std::boxed::Box","internal::Or","internal::FlatMap","internal::AndThen","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::MapOpt"]},"internal::AndThen":{"F":["internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","internal::Into","internal::Map","internal::MapRes","internal::And","<F as internal::Parser<I>>"],"G":["internal::And","internal::MapOpt","internal::Or","std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","internal::Into","internal::FlatMap","<F as internal::Parser<I>>"]},"internal::Err":{"E":["internal::Err","error::VerboseError","error::Error","error::ErrorKind","error::VerboseErrorKind","internal::Needed","<*const T as std::fmt::Debug>","number::Endianness"]},"internal::FlatMap":{"F":["internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::Or","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::AndThen"],"G":["core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::AndThen","internal::Or","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","internal::MapRes","internal::MapOpt"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::Into","internal::Map","internal::And","internal::Or","internal::AndThen","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::MapRes"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Into","internal::FlatMap","internal::And","internal::Or"],"G":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::And","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Map","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::Or","std::boxed::Box","internal::Map","internal::MapOpt","internal::And","internal::MapRes","internal::Into","internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>"],"G":["internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::Map","std::boxed::Box","internal::Into","internal::MapRes","internal::MapOpt"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20)>::parse(p0, p1);
-----------------
src/internal.rs <(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21) as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21) as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O10":["std::marker::Sized"],"O11":["std::marker::Sized"],"O12":["std::marker::Sized"],"O13":["std::marker::Sized"],"O14":["std::marker::Sized"],"O15":["std::marker::Sized"],"O16":["std::marker::Sized"],"O17":["std::marker::Sized"],"O18":["std::marker::Sized"],"O19":["std::marker::Sized"],"O2":["std::marker::Sized"],"O20":["std::marker::Sized"],"O21":["std::marker::Sized"],"O3":["std::marker::Sized"],"O4":["std::marker::Sized"],"O5":["std::marker::Sized"],"O6":["std::marker::Sized"],"O7":["std::marker::Sized"],"O8":["std::marker::Sized"],"O9":["std::marker::Sized"],"P1":["std::marker::Sized","internal::Parser"],"P10":["std::marker::Sized","internal::Parser"],"P11":["std::marker::Sized","internal::Parser"],"P12":["internal::Parser","std::marker::Sized"],"P13":["internal::Parser","std::marker::Sized"],"P14":["internal::Parser","std::marker::Sized"],"P15":["std::marker::Sized","internal::Parser"],"P16":["internal::Parser","std::marker::Sized"],"P17":["std::marker::Sized","internal::Parser"],"P18":["internal::Parser","std::marker::Sized"],"P19":["internal::Parser","std::marker::Sized"],"P2":["internal::Parser","std::marker::Sized"],"P20":["std::marker::Sized","internal::Parser"],"P21":["std::marker::Sized","internal::Parser"],"P3":["internal::Parser","std::marker::Sized"],"P4":["internal::Parser","std::marker::Sized"],"P5":["std::marker::Sized","internal::Parser"],"P6":["internal::Parser","std::marker::Sized"],"P7":["std::marker::Sized","internal::Parser"],"P8":["internal::Parser","std::marker::Sized"],"P9":["std::marker::Sized","internal::Parser"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21) as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O10":["RUG_ANY"],"O11":["RUG_ANY"],"O12":["RUG_ANY"],"O13":["RUG_ANY"],"O14":["RUG_ANY"],"O15":["RUG_ANY"],"O16":["RUG_ANY"],"O17":["RUG_ANY"],"O18":["RUG_ANY"],"O19":["RUG_ANY"],"O2":["RUG_ANY"],"O20":["RUG_ANY"],"O21":["RUG_ANY"],"O3":["RUG_ANY"],"O4":["RUG_ANY"],"O5":["RUG_ANY"],"O6":["RUG_ANY"],"O7":["RUG_ANY"],"O8":["RUG_ANY"],"O9":["RUG_ANY"],"P1":["internal::MapOpt","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::Into","std::boxed::Box","internal::FlatMap","internal::Map"],"P10":["internal::Or","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::Map","internal::MapRes","internal::And","internal::AndThen"],"P11":["internal::FlatMap","internal::Or","internal::Map","internal::AndThen","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Into","internal::And","<F as internal::Parser<I>>"],"P12":["<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Map","internal::MapOpt","internal::Or","internal::And","internal::MapRes","std::boxed::Box","internal::Into"],"P13":["internal::MapRes","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::And","internal::Map","internal::Into","std::boxed::Box","internal::FlatMap","internal::MapOpt"],"P14":["internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::MapOpt","internal::And"],"P15":["internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapRes","internal::Or","internal::FlatMap","internal::Into","std::boxed::Box"],"P16":["internal::Map","internal::FlatMap","internal::AndThen","internal::And","std::boxed::Box","internal::Or","internal::Into","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>"],"P17":["<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap","internal::And","internal::Map","internal::MapRes","internal::AndThen"],"P18":["internal::Map","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::AndThen"],"P19":["internal::And","internal::Map","internal::MapOpt","internal::Into","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Or"],"P2":["internal::MapOpt","internal::Map","internal::MapRes","internal::Into","internal::And","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box"],"P20":["internal::FlatMap","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::And","internal::MapRes","internal::AndThen","internal::Map"],"P21":["internal::MapOpt","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::And","internal::Map","std::boxed::Box","internal::AndThen"],"P3":["internal::MapOpt","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Into","internal::And","internal::AndThen","internal::Or"],"P4":["internal::MapRes","internal::Into","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::And"],"P5":["internal::Or","internal::Map","internal::MapOpt","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Into","internal::MapRes"],"P6":["internal::MapRes","internal::FlatMap","internal::AndThen","internal::Into","internal::And","internal::Map","internal::Or","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>"],"P7":["std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::FlatMap","internal::Into"],"P8":["internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapOpt","std::boxed::Box","internal::Or","internal::AndThen","internal::MapRes","internal::Into"],"P9":["internal::Or","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::MapRes","internal::FlatMap","internal::Map","internal::And"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["std::boxed::Box","internal::Map","internal::AndThen","internal::MapRes","internal::Into","internal::Or","internal::FlatMap","internal::MapOpt","internal::And","<F as internal::Parser<I>>"],"G":["internal::And","internal::AndThen","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::Or","internal::Into","std::boxed::Box"]},"internal::AndThen":{"F":["std::boxed::Box","internal::AndThen","internal::Or","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Map"],"G":["internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::MapOpt"]},"internal::Err":{"E":["error::VerboseError","<*const T as std::fmt::Debug>","internal::Err","error::VerboseErrorKind","error::Error","error::ErrorKind","number::Endianness","internal::Needed"]},"internal::FlatMap":{"F":["internal::MapOpt","internal::And","internal::Map","internal::FlatMap","internal::AndThen","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::Into","std::boxed::Box"],"G":["core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault"]},"internal::Into":{"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Into","internal::FlatMap","internal::Or","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into","internal::AndThen"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::MapOpt":{"F":["internal::Map","internal::MapRes","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::FlatMap","internal::MapOpt","std::boxed::Box"],"G":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::Map","internal::AndThen","internal::And","internal::FlatMap","internal::MapOpt","internal::Or","std::boxed::Box","internal::MapRes","internal::Into","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::And","internal::Or","internal::AndThen","internal::MapOpt","internal::MapRes","internal::Map","internal::FlatMap","internal::Into","std::boxed::Box"],"G":["internal::And","internal::Or","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Into","internal::MapRes","internal::Map","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21)
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21) as internal::Parser<I>>::parse(p0, p1);
+crate::<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21) as internal::Parser<I>>::parse(p0, p1);
+<(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21)>::parse(p0, p1);
-----------------
src/internal.rs <std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)> as internal::Parser<I>>::parse
deps:{"<std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)> as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)> as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","internal::Err","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)> as internal::Parser<I>>::parse(p0, p1);
+crate::<std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)> as internal::Parser<I>>::parse(p0, p1);
+<std::boxed::Box<(dyn internal::Parser<I, Error = E, Output = O> + 'static)>>::parse(p0, p1);
-----------------
src/internal.rs <internal::Map<F, G> as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::Map<F, G> as internal::Parser<I>>::parse":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"],"I":["std::marker::Sized"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::Map<F, G> as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"F":["internal::MapRes","internal::Map","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Or","std::boxed::Box","internal::MapOpt","internal::And"],"G":["core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap"],"I":["RUG_ANY"],"O2":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::And","internal::Or","std::boxed::Box","internal::Map","internal::MapOpt","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes"],"G":["internal::Into","<F as internal::Parser<I>>","internal::Or","internal::And","internal::Map","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::MapRes","internal::FlatMap"]},"internal::AndThen":{"F":["internal::And","internal::Map","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::FlatMap","internal::Or","std::boxed::Box"],"G":["internal::Or","internal::AndThen","std::boxed::Box","internal::Into","internal::MapOpt","internal::MapRes","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::And"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","<*const T as std::fmt::Debug>","error::VerboseErrorKind","internal::Err","error::Error","error::VerboseError","internal::Needed"]},"internal::FlatMap":{"F":["internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Or","internal::Into","internal::And","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsNotEmpty"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::MapRes","internal::Or","internal::And","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::Map","internal::FlatMap"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::And","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Into","std::boxed::Box","internal::Map","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::And","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::Into","internal::MapOpt","internal::FlatMap"],"G":["core::str::CharEscapeUnicode","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue"]},"internal::MapRes":{"F":["internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Or","internal::AndThen","internal::Into","internal::Map"],"G":["core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::Or","internal::MapRes","internal::And","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","std::boxed::Box","internal::MapOpt","internal::AndThen"],"G":["internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Or","internal::Into","internal::MapRes","internal::Map","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::Map<F, G>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::Map<F, G> as internal::Parser<I>>::parse(p0, p1);
+crate::<internal::Map<F, G> as internal::Parser<I>>::parse(p0, p1);
+<internal::Map<F, G>>::parse(p0, p1);
-----------------
src/internal.rs <internal::MapRes<F, G> as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::MapRes<F, G> as internal::Parser<I>>::parse":{"<F as internal::Parser<I>>::Error":["error::FromExternalError"],"E2":["std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"I":["std::clone::Clone","std::marker::Sized"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::MapRes<F, G> as internal::Parser<I>>::parse":{"<F as internal::Parser<I>>::Error":["error::VerboseError","error::Error"],"E2":["RUG_ANY"],"F":["<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::And","internal::Map","internal::AndThen","internal::Or","internal::Into"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>"],"I":["error::VerboseErrorKind","internal::Needed","number::Endianness","internal::Err","error::VerboseError","error::Error","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>"],"O2":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::MapRes","internal::FlatMap","internal::And","internal::MapOpt","internal::AndThen","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Into"],"G":["internal::And","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","internal::MapRes","internal::Or"]},"internal::AndThen":{"F":["internal::Into","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::MapOpt","internal::Map","internal::And"],"G":["internal::Into","internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt"]},"internal::Err":{"E":["error::Error","error::VerboseError","internal::Needed","error::ErrorKind","error::VerboseErrorKind","number::Endianness","<*mut T as std::fmt::Debug>","internal::Err"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Map","internal::And","internal::Into","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I>>"],"G":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::Into","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::And","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapRes"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::FlatMap","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::MapRes","internal::Into","std::boxed::Box"],"G":["core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["internal::Or","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::MapOpt","internal::MapRes"],"G":["core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::MapRes","std::boxed::Box","internal::Into","internal::Or","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::AndThen"],"G":["core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"internal::Or":{"F":["internal::AndThen","internal::Map","internal::Into","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::And"],"G":["internal::FlatMap","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapOpt","std::boxed::Box","internal::Or","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::MapRes<F, G>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::MapRes<F, G> as internal::Parser<I>>::parse(p0, p1);
+crate::<internal::MapRes<F, G> as internal::Parser<I>>::parse(p0, p1);
+<internal::MapRes<F, G>>::parse(p0, p1);
-----------------
src/internal.rs <internal::MapOpt<F, G> as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::MapOpt<F, G> as internal::Parser<I>>::parse":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"I":["std::marker::Sized","std::clone::Clone"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::MapOpt<F, G> as internal::Parser<I>>::parse":{"F":["internal::FlatMap","internal::Into","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::MapRes","std::boxed::Box","internal::Or"],"G":["core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::LinesAnyMap"],"I":["error::Error","number::Endianness","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","internal::Needed","internal::Err","error::ErrorKind"],"O2":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::AndThen","internal::MapRes","internal::MapOpt","internal::And","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::Into","std::boxed::Box"],"G":["internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::Into"]},"internal::AndThen":{"F":["internal::Into","internal::MapRes","internal::Or","internal::Map","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::And","internal::AndThen","<F as internal::Parser<I>>"],"G":["internal::AndThen","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Or","internal::MapRes","internal::And","internal::Into"]},"internal::Err":{"E":["error::Error","number::Endianness","error::VerboseError","internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","internal::Needed","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Into","internal::AndThen","internal::MapOpt","internal::Or","internal::And","internal::Map"],"G":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map","internal::MapOpt","internal::MapRes","internal::Or","internal::And"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","internal::AndThen","internal::MapRes","internal::Or","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::And","std::boxed::Box"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue"]},"internal::MapOpt":{"F":["internal::And","std::boxed::Box","internal::Or","internal::Into","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::MapOpt"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["internal::Into","internal::And","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::Map"],"G":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::And","internal::Map","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Into","internal::FlatMap"],"G":["internal::Map","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::And","internal::MapRes","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::MapOpt<F, G>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::MapOpt<F, G> as internal::Parser<I>>::parse(p0, p1);
+crate::<internal::MapOpt<F, G> as internal::Parser<I>>::parse(p0, p1);
+<internal::MapOpt<F, G>>::parse(p0, p1);
-----------------
src/internal.rs <internal::FlatMap<F, G> as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::FlatMap<F, G> as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::FlatMap<F, G> as internal::Parser<I>>::parse":{"E":["error::VerboseError","error::Error"],"F":["internal::AndThen","internal::MapRes","internal::Map","std::boxed::Box","internal::MapOpt","internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::And"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr"],"H":["internal::Map","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::Into","internal::AndThen","internal::And","internal::MapOpt"],"I":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Into","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::Or","internal::MapRes","internal::FlatMap","internal::And"],"G":["internal::Or","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map","internal::MapRes"]},"internal::AndThen":{"F":["internal::FlatMap","internal::And","internal::MapOpt","internal::Or","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::MapRes","internal::Map"],"G":["internal::Or","internal::MapRes","internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::MapOpt","std::boxed::Box","internal::Into","internal::Map"]},"internal::Err":{"E":["error::Error","internal::Needed","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","internal::Err","<*mut T as std::fmt::Debug>","number::Endianness"]},"internal::FlatMap":{"F":["internal::And","internal::AndThen","internal::Map","std::boxed::Box","internal::Into","internal::Or","internal::MapRes","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::Or","internal::FlatMap","internal::MapOpt","internal::Into","internal::And","std::boxed::Box","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Map","internal::Into","internal::And","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap"],"G":["core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["internal::AndThen","internal::MapRes","internal::Map","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Or","std::boxed::Box"],"G":["core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["std::boxed::Box","internal::Map","internal::Into","internal::Or","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::FlatMap"],"G":["core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::FlatMap","internal::And","internal::AndThen","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Or","std::boxed::Box","internal::Into"],"G":["internal::Into","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box","internal::And","internal::Or","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::FlatMap<F, G>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::FlatMap<F, G> as internal::Parser<I>>::parse(p0, p1);
+crate::<internal::FlatMap<F, G> as internal::Parser<I>>::parse(p0, p1);
+<internal::FlatMap<F, G>>::parse(p0, p1);
-----------------
src/internal.rs <internal::AndThen<F, G> as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<internal::AndThen<F, G> as internal::Parser<I>>::parse":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<internal::AndThen<F, G> as internal::Parser<I>>::parse":{"F":["internal::Map","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Into","internal::Or","internal::FlatMap","internal::MapRes","internal::And","<F as internal::Parser<I>>"],"G":["std::boxed::Box","internal::Into","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Map","internal::And","internal::Or"],"I":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::And","internal::FlatMap","internal::Or","internal::Map","internal::MapRes","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into","std::boxed::Box"],"G":["internal::Into","internal::MapRes","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::And"]},"internal::AndThen":{"F":["internal::MapOpt","internal::Or","std::boxed::Box","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::Map","internal::FlatMap"],"G":["internal::Or","internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::And"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","error::VerboseError","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::AndThen","internal::And","internal::Map","internal::Into","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Or"],"G":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::MapRes","internal::FlatMap","internal::Into","internal::Or","internal::MapOpt","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I>>","std::boxed::Box"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["std::boxed::Box","internal::And","internal::MapRes","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Into","internal::Or"],"G":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::MapRes","internal::MapOpt","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::And","internal::Into","internal::Map","internal::Or"],"G":["std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::Map","internal::And","internal::FlatMap","internal::Into","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Or","internal::AndThen"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::Into","internal::Or","internal::Map","internal::MapRes","std::boxed::Box","internal::And","internal::MapOpt","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>"],"G":["internal::MapOpt","internal::FlatMap","internal::Into","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Map","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::AndThen<F, G>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::AndThen<F, G> as internal::Parser<I>>::parse(p0, p1);
+crate::<internal::AndThen<F, G> as internal::Parser<I>>::parse(p0, p1);
+<internal::AndThen<F, G>>::parse(p0, p1);
-----------------
src/internal.rs <internal::And<F, G> as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::And<F, G> as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::And<F, G> as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"F":["internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::FlatMap","internal::Or","internal::And","internal::MapOpt","internal::AndThen","std::boxed::Box"],"G":["internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Or","internal::MapOpt","internal::And","internal::Into","std::boxed::Box"],"I":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::AndThen","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapRes"],"G":["internal::Or","internal::MapOpt","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::And","internal::Map","std::boxed::Box"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::MapRes","internal::And","internal::FlatMap","internal::Map","internal::Or","internal::Into"],"G":["internal::MapOpt","internal::FlatMap","internal::AndThen","internal::MapRes","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::And","std::boxed::Box"]},"internal::Err":{"E":["error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","error::ErrorKind","error::Error","error::VerboseErrorKind","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["internal::MapRes","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::And"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::AndThen","internal::Or","internal::Map","internal::Into","internal::And"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::MapRes","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::And","internal::MapOpt"],"G":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::Map","internal::Into","internal::FlatMap","internal::MapRes","internal::Or"],"G":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace"]},"internal::MapRes":{"F":["internal::Map","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Or","internal::AndThen","internal::Into","internal::And"],"G":["core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["internal::Into","internal::MapRes","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::And","internal::FlatMap"],"G":["<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::FlatMap","internal::And","internal::MapOpt","internal::Map","std::boxed::Box","internal::Or","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::And<F, G>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::And<F, G> as internal::Parser<I>>::parse(p0, p1);
+crate::<internal::And<F, G> as internal::Parser<I>>::parse(p0, p1);
+<internal::And<F, G>>::parse(p0, p1);
-----------------
src/internal.rs <internal::Or<F, G> as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::Or<F, G> as internal::Parser<I>>::parse":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::Or<F, G> as internal::Parser<I>>::parse":{"E":["error::Error","error::VerboseError"],"F":["internal::Into","std::boxed::Box","internal::And","internal::Or","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::AndThen"],"G":["internal::AndThen","internal::FlatMap","internal::And","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::Into","internal::Or","internal::MapOpt"],"I":["error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","number::Endianness","error::ErrorKind","error::Error","internal::Needed","internal::Err"],"O":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Or","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::And","internal::MapRes","internal::Into","internal::AndThen","internal::Map","<F as internal::Parser<I>>"],"G":["internal::FlatMap","std::boxed::Box","internal::Map","internal::MapRes","internal::Or","internal::And","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::AndThen"]},"internal::AndThen":{"F":["std::boxed::Box","internal::MapRes","internal::And","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::Into"],"G":["internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","std::boxed::Box","internal::AndThen","internal::Map","internal::MapRes","internal::And"]},"internal::Err":{"E":["number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","internal::Needed","error::ErrorKind","error::Error","internal::Err","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapOpt","internal::Or","internal::Map","internal::FlatMap","internal::MapRes","internal::AndThen","internal::And"],"G":["core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::Into","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::AndThen","internal::And"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::And","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Or","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::Into"],"G":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::Into","internal::MapOpt","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Map","internal::Or"],"G":["core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Or","internal::Map","internal::MapRes","internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap"],"G":["core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::Into","internal::Or","internal::And","internal::MapOpt","internal::Map","std::boxed::Box","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap"],"G":["internal::FlatMap","internal::MapRes","internal::Map","std::boxed::Box","internal::Into","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::And"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::Or<F, G>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::Or<F, G> as internal::Parser<I>>::parse(p0, p1);
+crate::<internal::Or<F, G> as internal::Parser<I>>::parse(p0, p1);
+<internal::Or<F, G>>::parse(p0, p1);
-----------------
src/internal.rs <internal::Into<F, O2, E2> as internal::Parser<I>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::Into<F, O2, E2> as internal::Parser<I>>::parse":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::Into<F, O2, E2> as internal::Parser<I>>::parse":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::MapRes","internal::FlatMap","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::And","std::boxed::Box","internal::Map"],"I":["std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","error::Error","error::ErrorKind","internal::Needed"],"O2":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Or","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::MapRes","internal::MapOpt","std::boxed::Box"],"G":["<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::And","internal::Map","internal::Into","internal::AndThen"]},"internal::AndThen":{"F":["internal::And","internal::Or","internal::Map","internal::FlatMap","internal::Into","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen"],"G":["internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Into","internal::Or","internal::And","internal::Map","internal::MapRes","std::boxed::Box"]},"internal::Err":{"E":["internal::Needed","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::VerboseErrorKind","error::ErrorKind","error::VerboseError","error::Error","number::Endianness"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map","internal::And","internal::MapRes","internal::Or","internal::MapOpt"],"G":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["<F as internal::Parser<I>>","internal::MapRes","internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::Map","internal::MapOpt","internal::Or","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Or","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Into","internal::And"],"G":["core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Into","internal::Or","internal::MapOpt","internal::MapRes","internal::Map","internal::AndThen","internal::And"],"G":["core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["internal::And","internal::Or","internal::Into","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Map","internal::FlatMap","std::boxed::Box"],"G":["core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::MapOpt","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::Into"],"G":["<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::And","internal::AndThen","internal::MapRes","std::boxed::Box","internal::Or","internal::Map","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::Into<F, O2, E2>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::Into<F, O2, E2> as internal::Parser<I>>::parse(p0, p1);
+crate::<internal::Into<F, O2, E2> as internal::Parser<I>>::parse(p0, p1);
+<internal::Into<F, O2, E2>>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(F,) as sequence::Tuple<Input, (Output,), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse":{"Error":["error::Error","error::VerboseError"],"F":["std::boxed::Box","internal::And","internal::Or","internal::FlatMap","internal::Into","internal::MapRes","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Map"],"Input":["RUG_ANY"],"Output":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeUnicode"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::Or","internal::FlatMap","internal::MapOpt","internal::Map","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Into","internal::And","<F as internal::Parser<I>>"],"G":["internal::AndThen","internal::Or","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapRes","internal::And","internal::MapOpt"]},"internal::AndThen":{"F":["internal::Or","internal::Into","internal::MapOpt","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Map","internal::AndThen","std::boxed::Box"],"G":["internal::AndThen","internal::FlatMap","internal::Into","internal::MapRes","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I>>","internal::Map","internal::MapOpt"]},"internal::Err":{"E":["error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::Error","error::ErrorKind","number::Endianness","internal::Needed","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapRes","internal::MapOpt","internal::Into","internal::FlatMap","internal::Or","std::boxed::Box"],"G":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Map","internal::Or","internal::Into","internal::AndThen","internal::And","std::boxed::Box","internal::MapRes"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","internal::MapRes","internal::Map","internal::Into","internal::AndThen","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::And"],"G":["core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty"]},"internal::MapOpt":{"F":["internal::Map","internal::Or","internal::AndThen","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::MapOpt"],"G":["core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::Or","internal::Map","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::Into","internal::AndThen"],"G":["core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["internal::Map","std::boxed::Box","internal::AndThen","internal::Into","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::MapRes","internal::MapOpt"],"G":["internal::Map","internal::And","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::Or","internal::AndThen","internal::MapRes","internal::MapOpt","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (F,)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse(p0, p1);
+crate::<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse(p0, p1);
+<(F,)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"FnA":["internal::MapOpt","internal::AndThen","internal::MapRes","internal::FlatMap","internal::Or","internal::Map","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::And"],"FnB":["internal::MapRes","std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::MapOpt"],"Input":["internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","error::Error","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError"]},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::MapOpt","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen"],"G":["<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::FlatMap","internal::AndThen","internal::Map","internal::And","internal::Or","std::boxed::Box","internal::MapOpt"]},"internal::AndThen":{"F":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Or","internal::MapRes","internal::AndThen","internal::Map","internal::Into","internal::And"],"G":["<F as internal::Parser<I>>","internal::Map","internal::Or","internal::Into","internal::AndThen","internal::MapRes","internal::And","std::boxed::Box","internal::FlatMap","internal::MapOpt"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","error::VerboseErrorKind","error::VerboseError","error::Error","internal::Needed","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::MapRes","internal::And","std::boxed::Box","internal::AndThen","internal::Or","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::Map"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::FlatMap","internal::AndThen","internal::Map","internal::And","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::AndThen","std::boxed::Box","internal::Or","internal::MapRes","internal::Into","internal::And"],"G":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>"]},"internal::MapOpt":{"F":["internal::Map","internal::Or","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::MapOpt","internal::AndThen","internal::FlatMap"],"G":["core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte"]},"internal::MapRes":{"F":["internal::AndThen","internal::MapRes","internal::Or","internal::Map","internal::Into","internal::And","std::boxed::Box","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::Map","internal::Into","internal::And","internal::Or","internal::MapOpt","internal::AndThen","internal::MapRes","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>"],"G":["internal::And","internal::MapRes","internal::Into","internal::AndThen","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse(p0, p1);
+crate::<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse(p0, p1);
+<(FnA, FnB)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"FnA":["std::boxed::Box","internal::Map","internal::AndThen","internal::Or","internal::And","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap"],"FnB":["internal::MapRes","internal::MapOpt","std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::Into","internal::FlatMap","internal::Or"],"FnC":["<F as internal::Parser<I>>","internal::Map","internal::And","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::MapRes","internal::Or"],"Input":["error::Error","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","error::ErrorKind","internal::Err"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::Into","internal::And","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Map","internal::MapRes","internal::Or"],"G":["internal::Or","internal::And","internal::MapOpt","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Into","internal::FlatMap"]},"internal::AndThen":{"F":["internal::AndThen","internal::Or","internal::Map","internal::And","internal::MapRes","internal::FlatMap","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box"],"G":["internal::MapRes","internal::Map","internal::Or","internal::MapOpt","internal::FlatMap","internal::And","internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","error::VerboseError","error::Error","error::ErrorKind","internal::Needed","internal::Err","number::Endianness","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::And","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box","internal::Map"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::And","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapRes","internal::Or","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::MapRes","internal::And","internal::FlatMap","std::boxed::Box","internal::Or","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr"]},"internal::MapOpt":{"F":["internal::And","internal::MapOpt","std::boxed::Box","internal::AndThen","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Into"],"G":["core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr"]},"internal::MapRes":{"F":["internal::MapRes","std::boxed::Box","internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::MapOpt","internal::And","internal::AndThen","<F as internal::Parser<I>>"],"G":["core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::Or","internal::MapOpt","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::AndThen","internal::MapRes","internal::Into"],"G":["std::boxed::Box","internal::Map","internal::Into","internal::MapOpt","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"FnA":["internal::And","internal::Map","internal::MapRes","internal::Or","internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Into"],"FnB":["internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::And","internal::MapOpt","internal::Or","std::boxed::Box","internal::Map","internal::FlatMap"],"FnC":["internal::Into","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::And","internal::MapRes","internal::Map"],"FnD":["internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Into","internal::Or","internal::And","internal::MapRes","internal::Map","internal::FlatMap","<F as internal::Parser<I>>"],"Input":["error::Error","number::Endianness","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","error::VerboseErrorKind","internal::Err","error::ErrorKind"]},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Or","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::And","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Into","internal::FlatMap"],"G":["internal::Or","internal::And","internal::FlatMap","internal::Into","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::Map"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","internal::Into","internal::Or","internal::And","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","internal::MapRes","internal::MapOpt"],"G":["internal::MapOpt","internal::Into","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::Map","internal::FlatMap","internal::AndThen"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","number::Endianness","internal::Needed","internal::Err"]},"internal::FlatMap":{"F":["internal::MapOpt","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::And"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::MapRes","internal::Map","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::Or"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::Into","internal::Map","internal::Or","internal::MapRes","internal::MapOpt"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte"]},"internal::MapOpt":{"F":["internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::AndThen","internal::Or","internal::MapRes","internal::And","std::boxed::Box"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsWhitespace"]},"internal::MapRes":{"F":["internal::MapOpt","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::Into","internal::FlatMap","internal::And","internal::MapRes"],"G":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::MapRes","std::boxed::Box","internal::AndThen","internal::Into","internal::MapOpt","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::Or"],"G":["internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::And","internal::MapRes","internal::Into","std::boxed::Box","internal::AndThen","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"FnA":["internal::AndThen","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::And"],"FnB":["internal::Or","internal::Into","internal::MapRes","internal::Map","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::FlatMap"],"FnC":["internal::Map","internal::MapOpt","internal::And","internal::AndThen","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::Into"],"FnD":["internal::AndThen","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::MapRes","internal::And","internal::MapOpt","internal::Into"],"FnE":["internal::And","internal::AndThen","internal::Or","internal::MapOpt","std::boxed::Box","internal::Map","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap"],"Input":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","internal::Needed","internal::Err","error::VerboseErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","error::Error"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::Map","internal::Into","internal::MapOpt","internal::Or","internal::And","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap"],"G":["internal::MapRes","internal::Into","internal::Map","internal::FlatMap","internal::And","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","std::boxed::Box"]},"internal::AndThen":{"F":["internal::And","std::boxed::Box","internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::MapRes","internal::Map"],"G":["internal::And","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::Into","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapRes"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness","error::ErrorKind","internal::Err","error::VerboseError","internal::Needed","error::Error","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::AndThen","internal::Or","internal::MapRes","internal::And","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapOpt"],"G":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::MapRes","internal::Map","std::boxed::Box","internal::Or","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapOpt","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::Or"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"internal::MapOpt":{"F":["internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::MapOpt","internal::Map","internal::Or"],"G":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::Or","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::Into","internal::And","internal::AndThen","internal::FlatMap","internal::MapRes","internal::MapOpt"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::Or":{"F":["internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapRes","std::boxed::Box","internal::AndThen","internal::Or","internal::And"],"G":["<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Into","internal::And","internal::AndThen","internal::MapRes","internal::Or","std::boxed::Box","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::AndThen","internal::And","internal::Or","internal::FlatMap","internal::MapRes","internal::Into","internal::MapOpt"],"FnB":["internal::Into","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::Map","std::boxed::Box","internal::AndThen","internal::And","internal::FlatMap"],"FnC":["internal::MapOpt","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::Into","std::boxed::Box","internal::MapRes","internal::FlatMap"],"FnD":["internal::MapRes","internal::And","internal::Into","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::AndThen","internal::Or"],"FnE":["internal::AndThen","std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::Or","internal::Map","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>"],"FnF":["std::boxed::Box","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::AndThen","internal::Map","internal::And","internal::Or"],"Input":["error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","number::Endianness","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","internal::Needed","error::VerboseErrorKind"]},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Map","internal::Into","std::boxed::Box","internal::MapOpt","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::And"],"G":["<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::MapRes","internal::Or","internal::AndThen","internal::And","internal::MapOpt"]},"internal::AndThen":{"F":["internal::MapRes","internal::And","std::boxed::Box","internal::Map","internal::Into","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Or","<F as internal::Parser<I>>"],"G":["internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::AndThen","internal::Map","internal::Or","internal::Into","internal::And"]},"internal::Err":{"E":["internal::Needed","error::Error","number::Endianness","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","error::VerboseError","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::MapRes","internal::Map","internal::Or","internal::And","internal::Into","internal::FlatMap","internal::MapOpt"],"G":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::And","std::boxed::Box","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::Or","internal::MapRes","internal::FlatMap"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::MapOpt","internal::And","internal::Or","internal::FlatMap","internal::Into","std::boxed::Box","internal::Map"],"G":["core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode"]},"internal::MapOpt":{"F":["internal::Into","internal::Map","std::boxed::Box","internal::MapOpt","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Or","internal::MapRes"],"G":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::AndThen","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::Into"],"G":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["internal::AndThen","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::And","std::boxed::Box","internal::Map","internal::MapRes","internal::Or"],"G":["internal::And","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Or","internal::MapRes"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["<F as internal::Parser<I>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or","internal::MapRes","internal::MapOpt","internal::Map","internal::And"],"FnB":["internal::FlatMap","internal::Map","internal::MapRes","internal::AndThen","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::And","internal::MapOpt"],"FnC":["internal::MapRes","internal::And","internal::Map","internal::MapOpt","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::AndThen"],"FnD":["internal::Or","internal::Into","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::FlatMap"],"FnE":["internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::Into","internal::MapOpt","internal::Map","internal::And","internal::AndThen"],"FnF":["internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Map","internal::MapOpt","internal::Or","internal::AndThen","internal::FlatMap","internal::And"],"FnG":["internal::And","internal::Or","internal::Into","internal::Map","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::MapRes"],"G":["RUG_ANY"],"Input":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","number::Endianness","internal::Err","error::Error","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Into","internal::Or","internal::MapOpt","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And"],"G":["internal::FlatMap","internal::Into","internal::And","internal::MapRes","std::boxed::Box","internal::Or","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Into","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Or","internal::MapRes","internal::MapOpt"],"G":["internal::AndThen","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::FlatMap","internal::And","internal::Into","internal::MapOpt"]},"internal::Err":{"E":["error::Error","<*mut T as std::fmt::Debug>","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","number::Endianness","internal::Err","internal::Needed"]},"internal::FlatMap":{"F":["internal::Or","internal::And","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::MapRes"],"G":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap"]},"internal::Into":{"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::And","internal::Map","internal::MapRes","internal::MapOpt","internal::Or","internal::FlatMap","std::boxed::Box"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["std::boxed::Box","internal::MapRes","internal::Into","internal::MapOpt","internal::Or","internal::And","internal::Map","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace"]},"internal::MapOpt":{"F":["internal::MapRes","internal::AndThen","internal::Map","internal::Into","internal::And","internal::Or","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box"],"G":["core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["std::boxed::Box","internal::FlatMap","internal::MapRes","internal::Or","internal::Into","internal::MapOpt","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue"]},"internal::Or":{"F":["internal::Map","internal::AndThen","internal::MapRes","internal::Or","internal::And","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","std::boxed::Box"],"G":["internal::AndThen","internal::MapOpt","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Map","internal::MapRes","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::Into","internal::MapOpt","internal::And","internal::AndThen","internal::MapRes","std::boxed::Box"],"FnB":["internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::MapOpt","internal::MapRes","internal::And","internal::Or"],"FnC":["std::boxed::Box","internal::And","internal::Map","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::MapRes","internal::MapOpt"],"FnD":["internal::MapRes","internal::Map","internal::Into","internal::Or","internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt"],"FnE":["internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::AndThen","std::boxed::Box","internal::MapRes","internal::MapOpt","internal::And"],"FnF":["internal::And","std::boxed::Box","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::MapOpt","internal::Into","internal::Map"],"FnG":["std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::AndThen","internal::FlatMap","internal::And","internal::MapOpt","internal::Into"],"FnH":["internal::Or","internal::Into","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::And","internal::MapOpt"],"G":["RUG_ANY"],"H":["RUG_ANY"],"Input":["internal::Needed","number::Endianness","std::clone::impls::<impl std::clone::Clone for &T>","error::Error","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","internal::Err"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::MapRes","internal::And","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::Or","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I>>"],"G":["internal::FlatMap","internal::And","internal::Into","internal::Or","internal::MapRes","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Map"]},"internal::AndThen":{"F":["internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::AndThen"],"G":["<F as internal::Parser<I>>","internal::Map","internal::Into","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::MapRes","internal::And","internal::Or"]},"internal::Err":{"E":["internal::Needed","internal::Err","error::ErrorKind","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseErrorKind","number::Endianness","error::Error"]},"internal::FlatMap":{"F":["internal::And","internal::MapOpt","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::And","internal::Or","internal::FlatMap","internal::Map","internal::Into","internal::MapRes","internal::AndThen","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Into","std::boxed::Box","internal::And","internal::FlatMap","internal::MapRes","internal::AndThen","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault"]},"internal::MapOpt":{"F":["internal::Map","internal::And","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::Into","internal::Or","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>"],"G":["core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::MapRes":{"F":["internal::AndThen","internal::Map","internal::MapRes","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Into","internal::Map"],"G":["internal::MapOpt","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Into"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Or","internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::AndThen","internal::Into","internal::And"],"FnB":["internal::AndThen","internal::Into","internal::Or","internal::Map","internal::MapRes","internal::And","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap"],"FnC":["internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Into","internal::And","internal::Or","internal::Map"],"FnD":["internal::Or","<F as internal::Parser<I>>","internal::Map","internal::And","internal::MapRes","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","internal::MapOpt"],"FnE":["internal::AndThen","internal::Map","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Into"],"FnF":["<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::AndThen","internal::And","internal::MapOpt","internal::Into","std::boxed::Box","internal::FlatMap","internal::Map"],"FnG":["internal::Or","internal::AndThen","internal::MapRes","internal::Into","std::boxed::Box","internal::And","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::FlatMap"],"FnH":["internal::MapRes","internal::And","internal::Into","std::boxed::Box","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::Or"],"FnI":["internal::Or","internal::AndThen","internal::MapOpt","internal::MapRes","internal::Into","internal::Map","internal::And","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["number::Endianness","error::ErrorKind","error::VerboseErrorKind","internal::Err","error::VerboseError","internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for &T>","error::Error"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::FlatMap","internal::And","internal::Into","internal::MapRes","internal::MapOpt"],"G":["internal::MapRes","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::And","internal::Or","internal::Map","internal::Into"]},"internal::AndThen":{"F":["internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Or","internal::Map"],"G":["internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::And","internal::Map","internal::MapOpt","internal::Into","internal::FlatMap","internal::Or"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","internal::Err","<*mut T as std::fmt::Debug>","number::Endianness","error::ErrorKind","error::Error","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","internal::FlatMap","internal::Map","internal::Or","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Into"],"G":["core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>"]},"internal::Into":{"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::FlatMap","internal::Map","internal::AndThen","internal::Into","internal::And","internal::Or","internal::MapOpt","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::MapRes","internal::And","internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::AndThen","internal::Or"],"G":["core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::And","internal::MapRes","internal::MapOpt","internal::Map"],"G":["core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::Or","internal::And","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::Into"],"G":["core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::Or":{"F":["internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Map","internal::Or","internal::Into","internal::MapRes"],"G":["std::boxed::Box","internal::Or","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Map","internal::And","internal::Into","internal::MapOpt","<F as internal::Parser<I>>"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::And","internal::FlatMap","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::Into","internal::AndThen","internal::MapRes"],"FnB":["internal::And","internal::Map","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::Into","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::MapRes"],"FnC":["internal::And","internal::MapRes","std::boxed::Box","internal::Or","internal::MapOpt","internal::FlatMap","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Into"],"FnD":["internal::MapOpt","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::Map","internal::Or","std::boxed::Box","internal::MapRes"],"FnE":["std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::Into","internal::And","internal::MapRes","internal::FlatMap","internal::Or","internal::AndThen"],"FnF":["internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::Or","internal::AndThen","internal::MapRes","internal::MapOpt"],"FnG":["std::boxed::Box","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::AndThen","internal::MapRes","internal::And","internal::Into"],"FnH":["internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::FlatMap","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::MapRes","internal::Map"],"FnI":["internal::Map","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::MapRes","internal::MapOpt","internal::Into","std::boxed::Box","internal::And"],"FnJ":["<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::Into","internal::FlatMap","internal::Or","internal::MapOpt","internal::And","internal::MapRes","std::boxed::Box"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","internal::Needed","number::Endianness","internal::Err","error::VerboseError","error::Error","error::ErrorKind"],"J":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::And":{"F":["internal::Map","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::And","internal::AndThen","internal::Into","internal::MapRes"],"G":["internal::And","internal::FlatMap","internal::Or","std::boxed::Box","internal::MapRes","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::MapOpt"]},"internal::AndThen":{"F":["std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Or","internal::And","internal::FlatMap","internal::Map","internal::Into","internal::AndThen"],"G":["internal::Or","internal::Map","internal::And","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::Into","std::boxed::Box"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::VerboseErrorKind","error::Error","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::And","internal::Into","internal::Or","std::boxed::Box","internal::Map","internal::MapOpt","internal::AndThen"],"G":["core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::AndThen","internal::MapRes","internal::Or","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::FlatMap","internal::MapOpt","internal::Map"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::Into","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::Or","internal::MapOpt","internal::And"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::Into","internal::Map","internal::And","internal::AndThen"],"G":["core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsWhitespace"]},"internal::MapRes":{"F":["internal::AndThen","std::boxed::Box","internal::Map","internal::Or","internal::MapOpt","internal::Into","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::And"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::MapRes","<F as internal::Parser<I>>","internal::Map","internal::And","std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","internal::Or","internal::MapOpt"],"G":["internal::Into","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::Map","internal::And","internal::Or","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Or","internal::MapRes","internal::And","internal::Map","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::FlatMap"],"FnB":["internal::Map","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapRes","internal::AndThen","internal::FlatMap","std::boxed::Box"],"FnC":["internal::MapOpt","internal::FlatMap","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Map","internal::Into"],"FnD":["internal::Map","internal::AndThen","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Into","internal::Or","internal::MapOpt","std::boxed::Box"],"FnE":["internal::AndThen","internal::Into","internal::Map","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::And","internal::MapRes","std::boxed::Box"],"FnF":["internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::MapOpt","internal::FlatMap","internal::Into","internal::Or"],"FnG":["internal::MapOpt","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::Into","internal::FlatMap","internal::MapRes","internal::Map","internal::And","internal::AndThen"],"FnH":["internal::MapOpt","internal::Into","internal::AndThen","internal::FlatMap","internal::Or","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::And","std::boxed::Box"],"FnI":["internal::MapRes","internal::FlatMap","internal::Into","internal::MapOpt","std::boxed::Box","internal::Or","internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I>>"],"FnJ":["internal::AndThen","internal::MapOpt","internal::Or","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::Into","std::boxed::Box"],"FnK":["internal::FlatMap","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::MapRes","internal::AndThen","internal::Map","internal::MapOpt","internal::Or","internal::Into"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseErrorKind","error::ErrorKind","error::Error","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Err","internal::Needed"],"J":["RUG_ANY"],"K":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::MapRes","internal::MapOpt","internal::Into","internal::Or"],"G":["internal::AndThen","internal::Into","internal::MapOpt","std::boxed::Box","internal::Map","internal::And","internal::MapRes","internal::Or","internal::FlatMap","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::Map","internal::And","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::Or"],"G":["<F as internal::Parser<I>>","internal::Or","internal::MapOpt","std::boxed::Box","internal::And","internal::MapRes","internal::AndThen","internal::FlatMap","internal::Map","internal::Into"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","error::VerboseError","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","number::Endianness","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","internal::Map","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::And","internal::Map","internal::MapRes","internal::Or","internal::Into","internal::MapOpt","std::boxed::Box"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Into","internal::AndThen","internal::Or","std::boxed::Box","internal::Map"],"G":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"internal::MapOpt":{"F":["internal::Into","internal::FlatMap","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::And","internal::Map","std::boxed::Box","internal::MapOpt"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"]},"internal::MapRes":{"F":["internal::MapRes","std::boxed::Box","internal::FlatMap","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::Into","internal::And"],"G":["core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::IsWhitespace"]},"internal::Or":{"F":["internal::And","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::Or"],"G":["std::boxed::Box","internal::And","internal::MapOpt","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::FlatMap","internal::MapRes","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::Or","internal::And","internal::FlatMap","internal::MapRes","internal::Into"],"FnB":["std::boxed::Box","internal::MapRes","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::And","internal::Map","internal::Into"],"FnC":["internal::And","internal::MapRes","internal::Into","internal::FlatMap","internal::Map","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Or"],"FnD":["internal::Or","internal::FlatMap","std::boxed::Box","internal::Into","internal::And","internal::MapRes","internal::Map","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>"],"FnE":["<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::MapRes","internal::MapOpt","internal::And","internal::Or","internal::Map","internal::FlatMap","internal::AndThen"],"FnF":["internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::Or"],"FnG":["<F as internal::Parser<I>>","internal::FlatMap","internal::Or","internal::MapOpt","internal::Into","internal::MapRes","internal::Map","internal::AndThen","internal::And","std::boxed::Box"],"FnH":["internal::MapOpt","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::Map","internal::Or","internal::MapRes","internal::And"],"FnI":["internal::MapRes","internal::Or","internal::Into","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","internal::Map","internal::And","std::boxed::Box"],"FnJ":["internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::And","std::boxed::Box","internal::Map","internal::Into"],"FnK":["internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::Or","internal::And","internal::AndThen","internal::Into","internal::FlatMap"],"FnL":["internal::Map","internal::Into","internal::Or","std::boxed::Box","internal::And","internal::AndThen","internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","internal::Needed","error::VerboseErrorKind","number::Endianness","internal::Err","error::Error","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::And":{"F":["internal::FlatMap","internal::MapOpt","internal::Map","internal::AndThen","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::Into"],"G":["internal::Or","internal::Into","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Map","internal::And","internal::MapRes","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::Or","internal::Into","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::And","internal::Map"],"G":["std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::Into","internal::MapOpt","internal::And","internal::Or","internal::FlatMap"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","error::VerboseError","error::Error"]},"internal::FlatMap":{"F":["<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::MapRes","internal::MapOpt","internal::Or","internal::Into","internal::AndThen","internal::Map","std::boxed::Box"],"G":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::MapRes","internal::And","internal::Map","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","internal::MapOpt","<F as internal::Parser<I>>"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["std::boxed::Box","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::Or","internal::AndThen","internal::Map","internal::MapRes","internal::And","internal::Into"],"G":["core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::MapOpt":{"F":["internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::And","internal::MapRes","internal::MapOpt"],"G":["core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsWhitespace"]},"internal::MapRes":{"F":["internal::Map","std::boxed::Box","internal::MapRes","internal::FlatMap","internal::And","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt"],"G":["core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["internal::Or","internal::And","internal::Into","internal::MapOpt","internal::Map","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes"],"G":["internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Into","internal::Or","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::MapRes","internal::Into","internal::Map","std::boxed::Box","internal::MapOpt","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::FlatMap"],"FnB":["std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::And","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::Map"],"FnC":["internal::Or","std::boxed::Box","internal::Map","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::And","internal::AndThen"],"FnD":["<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::FlatMap","internal::Into","internal::Map","internal::MapOpt","internal::Or","internal::MapRes","internal::AndThen"],"FnE":["internal::Into","internal::MapOpt","internal::Or","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::MapRes","internal::FlatMap","internal::AndThen"],"FnF":["internal::MapOpt","internal::AndThen","internal::Map","internal::And","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::Into"],"FnG":["internal::FlatMap","internal::MapRes","internal::AndThen","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::Into","internal::Map","internal::And"],"FnH":["internal::Into","internal::And","internal::FlatMap","internal::MapOpt","internal::Map","internal::AndThen","internal::MapRes","internal::Or","<F as internal::Parser<I>>","std::boxed::Box"],"FnI":["internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::And","internal::Into"],"FnJ":["internal::Map","internal::MapRes","internal::Or","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Into"],"FnK":["internal::Or","internal::And","internal::Into","internal::Map","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>"],"FnL":["internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Into","internal::AndThen","internal::Or","internal::And","std::boxed::Box","internal::FlatMap"],"FnM":["internal::MapRes","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::MapOpt","internal::Into","internal::And","internal::AndThen"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseErrorKind","error::ErrorKind","number::Endianness","error::VerboseError","internal::Err","error::Error","internal::Needed"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::And","internal::Or","internal::MapOpt","internal::Map","internal::MapRes","std::boxed::Box","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::Into"],"G":["internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::MapRes","internal::Map","internal::Into","internal::And"]},"internal::AndThen":{"F":["internal::MapOpt","internal::Into","internal::And","<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::FlatMap","internal::Map","internal::MapRes","std::boxed::Box"],"G":["internal::MapOpt","std::boxed::Box","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::FlatMap","internal::And","internal::Map","internal::Or"]},"internal::Err":{"E":["internal::Err","error::VerboseError","error::ErrorKind","number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::Error","internal::Needed","error::VerboseErrorKind"]},"internal::FlatMap":{"F":["internal::Map","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::And","internal::MapOpt","internal::AndThen","internal::MapRes","internal::Or"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsAsciiWhitespace"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::MapRes","internal::Into","internal::Map"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Or","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","internal::And"],"G":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty"]},"internal::MapOpt":{"F":["internal::Map","internal::MapOpt","internal::Into","internal::MapRes","internal::FlatMap","internal::And","internal::AndThen","std::boxed::Box","internal::Or","<F as internal::Parser<I>>"],"G":["core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::And","internal::Into","internal::AndThen","internal::Map"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"]},"internal::Or":{"F":["internal::Or","internal::Map","internal::MapRes","internal::AndThen","internal::And","internal::Into","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap"],"G":["internal::MapOpt","internal::FlatMap","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::AndThen","internal::Into","internal::And"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::AndThen","internal::Or","internal::MapRes","std::boxed::Box","internal::Into","internal::Map","internal::And"],"FnB":["internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::Or","internal::Into"],"FnC":["internal::AndThen","internal::Or","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapOpt","std::boxed::Box","internal::Map"],"FnD":["internal::And","std::boxed::Box","internal::Into","internal::MapRes","internal::MapOpt","internal::Map","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen"],"FnE":["internal::And","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::FlatMap","internal::AndThen","internal::Into","internal::Or"],"FnF":["internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapRes","internal::Or","std::boxed::Box","internal::And","internal::FlatMap"],"FnG":["internal::FlatMap","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::AndThen","internal::Or","internal::And","internal::Map","std::boxed::Box","internal::MapOpt"],"FnH":["<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Or","internal::And","internal::MapRes","internal::AndThen","std::boxed::Box","internal::Map","internal::Into"],"FnI":["internal::MapOpt","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","internal::Into","internal::MapRes"],"FnJ":["internal::FlatMap","internal::Or","internal::Map","internal::And","internal::AndThen","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Into","<F as internal::Parser<I>>"],"FnK":["<F as internal::Parser<I>>","internal::Or","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::MapRes","internal::Into","internal::And","internal::Map","std::boxed::Box"],"FnL":["std::boxed::Box","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::Map","internal::Or","internal::Into","internal::FlatMap"],"FnM":["internal::Or","internal::MapRes","internal::AndThen","internal::Map","internal::And","std::boxed::Box","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::Into"],"FnN":["internal::MapOpt","std::boxed::Box","internal::MapRes","internal::Map","internal::Or","internal::FlatMap","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::And"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["number::Endianness","internal::Err","error::VerboseErrorKind","error::Error","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","internal::Needed","error::ErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","std::boxed::Box<F, A>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::MapRes","internal::MapOpt","internal::AndThen","internal::And"],"G":["internal::And","internal::Or","internal::MapRes","internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::MapOpt","internal::Into"]},"internal::AndThen":{"F":["internal::And","internal::Map","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::Or","internal::FlatMap","std::boxed::Box"],"G":["internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::Into"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","internal::Err","internal::Needed","number::Endianness","error::Error","error::VerboseError","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::MapRes","internal::MapOpt","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::Map","internal::FlatMap","internal::And"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"internal::Into":{"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::Into","internal::FlatMap","std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::MapOpt","internal::AndThen"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::And","internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::MapOpt"],"G":["core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace"]},"internal::MapOpt":{"F":["internal::FlatMap","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Or","internal::Into","internal::And","internal::Map","std::boxed::Box"],"G":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"internal::MapRes":{"F":["internal::AndThen","internal::FlatMap","internal::MapRes","internal::Into","internal::Or","internal::Map","internal::And","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::Into","internal::Map","internal::FlatMap","internal::And","internal::Or","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::AndThen"],"G":["internal::MapRes","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::And"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","internal::And","internal::Into","std::boxed::Box","internal::MapRes"],"FnB":["internal::MapOpt","internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::Into"],"FnC":["internal::MapOpt","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::AndThen","internal::FlatMap","internal::MapRes","internal::Map","internal::And"],"FnD":["std::boxed::Box","internal::Map","internal::FlatMap","internal::And","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapRes"],"FnE":["internal::AndThen","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","internal::Or","internal::MapRes","internal::MapOpt","internal::And","<F as internal::Parser<I>>"],"FnF":["internal::Map","internal::AndThen","internal::Into","internal::MapRes","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::And","internal::MapOpt"],"FnG":["internal::Into","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::And","internal::Or","internal::Map","internal::MapRes","internal::AndThen"],"FnH":["internal::Or","std::boxed::Box","internal::Map","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::Into","internal::AndThen","internal::MapRes"],"FnI":["internal::Into","internal::MapRes","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::MapOpt","internal::Map"],"FnJ":["<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","internal::MapOpt","internal::And","internal::Into","internal::MapRes","internal::Map"],"FnK":["internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::Or","internal::Into","internal::And","internal::MapOpt","internal::AndThen","std::boxed::Box"],"FnL":["std::boxed::Box","internal::AndThen","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::MapRes","internal::MapOpt"],"FnM":["internal::MapRes","std::boxed::Box","internal::Map","internal::AndThen","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::Or","internal::FlatMap"],"FnN":["internal::MapOpt","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::And","internal::AndThen","internal::Map","internal::FlatMap","internal::MapRes","std::boxed::Box"],"FnO":["internal::MapOpt","internal::AndThen","std::boxed::Box","internal::Into","internal::MapRes","internal::And","internal::Or","internal::Map","internal::FlatMap","<F as internal::Parser<I>>"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","error::ErrorKind","internal::Err","error::Error","internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Or","internal::And","internal::Map","internal::FlatMap","internal::MapRes","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::AndThen"],"G":["internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapOpt","internal::And","internal::MapRes","internal::Map","std::boxed::Box"]},"internal::AndThen":{"F":["internal::FlatMap","<F as internal::Parser<I>>","internal::MapOpt","std::boxed::Box","internal::MapRes","internal::And","internal::Into","internal::AndThen","internal::Map","internal::Or"],"G":["internal::AndThen","internal::MapRes","internal::And","internal::MapOpt","internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","std::boxed::Box"]},"internal::Err":{"E":["error::ErrorKind","error::VerboseErrorKind","internal::Err","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","error::Error","number::Endianness","error::VerboseError"]},"internal::FlatMap":{"F":["internal::Or","internal::MapRes","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::FlatMap","internal::Into","internal::MapOpt"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty"]},"internal::Into":{"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::And","internal::Map","internal::Into","internal::AndThen","internal::MapOpt","internal::Or","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::And","internal::MapRes","internal::MapOpt","internal::Map","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::MapOpt":{"F":["internal::MapRes","internal::Into","internal::And","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Or","internal::Map"],"G":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty"]},"internal::MapRes":{"F":["internal::Or","internal::Map","internal::FlatMap","internal::And","std::boxed::Box","internal::Into","internal::MapRes","internal::MapOpt","internal::AndThen","<F as internal::Parser<I>>"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Into","internal::And","internal::FlatMap","internal::MapRes","internal::Map","internal::Or"],"G":["internal::Into","internal::And","internal::Map","internal::MapOpt","internal::Or","std::boxed::Box","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Map","internal::FlatMap","internal::Or","internal::AndThen","internal::Into","std::boxed::Box","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes"],"FnB":["internal::AndThen","internal::Map","internal::MapOpt","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::FlatMap","internal::And","internal::MapRes"],"FnC":["std::boxed::Box","internal::AndThen","internal::Or","internal::MapRes","internal::Map","internal::Into","internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::FlatMap"],"FnD":["internal::AndThen","internal::MapOpt","internal::Into","internal::Map","internal::And","<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::FlatMap","internal::MapRes"],"FnE":["internal::MapRes","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::And","internal::Map"],"FnF":["internal::Map","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::FlatMap","internal::Or","internal::Into","internal::MapOpt"],"FnG":["std::boxed::Box","internal::AndThen","internal::MapRes","internal::Into","internal::MapOpt","internal::And","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::FlatMap"],"FnH":["internal::MapOpt","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::Or","internal::And","internal::Into","std::boxed::Box"],"FnI":["<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::And","internal::Into","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Or","internal::AndThen"],"FnJ":["internal::Map","std::boxed::Box","internal::Or","internal::And","internal::Into","internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes"],"FnK":["internal::AndThen","internal::MapOpt","internal::Or","internal::MapRes","internal::And","internal::Map","internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>"],"FnL":["internal::AndThen","internal::And","internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::Map","internal::MapOpt","std::boxed::Box","internal::MapRes"],"FnM":["internal::Into","std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::MapRes","internal::FlatMap","internal::MapOpt"],"FnN":["internal::MapRes","internal::Map","internal::And","internal::FlatMap","internal::Into","internal::AndThen","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::MapOpt"],"FnO":["internal::MapRes","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::FlatMap","internal::Map","std::boxed::Box","internal::MapOpt"],"FnP":["internal::And","internal::MapRes","internal::Or","internal::FlatMap","internal::Into","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::AndThen","internal::MapOpt"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","internal::Err","error::ErrorKind","number::Endianness","error::VerboseError","error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["std::boxed::Box","internal::AndThen","internal::Or","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::FlatMap","internal::Map","internal::And","internal::MapOpt"],"G":["internal::Into","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Map","internal::Or","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::And"]},"internal::AndThen":{"F":["std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::And","internal::Map","internal::MapOpt","internal::Into","internal::MapRes","internal::Or"],"G":["internal::Or","internal::FlatMap","internal::And","internal::Into","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Map","<F as internal::Parser<I>>","std::boxed::Box"]},"internal::Err":{"E":["internal::Needed","number::Endianness","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseErrorKind","error::Error","internal::Err","error::VerboseError"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::AndThen","internal::MapOpt","internal::MapRes","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::Map","internal::And"],"G":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::MapRes","internal::Map","internal::And","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::MapOpt","internal::FlatMap"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Or","internal::MapOpt","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into","internal::Map"],"G":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::Into","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::MapOpt","internal::Or","internal::Map","internal::FlatMap"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap"]},"internal::MapRes":{"F":["internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box","internal::And","internal::MapRes","internal::MapOpt","internal::Map","internal::Or","internal::Into"],"G":["core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"]},"internal::Or":{"F":["<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Or","internal::AndThen","internal::FlatMap","internal::And","internal::Into"],"G":["<F as internal::Parser<I>>","internal::Map","internal::Into","internal::MapOpt","internal::And","internal::Or","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["internal::Parser","std::marker::Sized"],"FnQ":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::cmp::Eq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::Into":{"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::AndThen","internal::Or","internal::FlatMap","internal::MapOpt","internal::Into","std::boxed::Box","internal::Map","internal::MapRes","internal::And","<F as internal::Parser<I>>"],"FnB":["internal::MapRes","internal::Or","internal::Map","internal::And","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::AndThen"],"FnC":["internal::MapOpt","internal::FlatMap","internal::AndThen","internal::And","internal::MapRes","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::Or","internal::Map"],"FnD":["internal::MapOpt","internal::MapRes","internal::Map","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::AndThen"],"FnE":["internal::Into","internal::FlatMap","internal::Map","internal::MapOpt","internal::AndThen","internal::Or","std::boxed::Box","internal::MapRes","internal::And","<F as internal::Parser<I>>"],"FnF":["internal::MapRes","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Into","internal::Or","internal::AndThen","internal::Map","internal::MapOpt","std::boxed::Box"],"FnG":["internal::Map","internal::FlatMap","<F as internal::Parser<I>>","internal::MapRes","internal::Or","std::boxed::Box","internal::Into","internal::AndThen","internal::And","internal::MapOpt"],"FnH":["internal::Or","std::boxed::Box","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::AndThen","internal::FlatMap","internal::And"],"FnI":["internal::MapRes","internal::AndThen","internal::Map","internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::MapOpt"],"FnJ":["internal::MapOpt","std::boxed::Box","internal::Into","internal::Or","internal::FlatMap","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::And"],"FnK":["std::boxed::Box","internal::AndThen","internal::MapRes","internal::Map","internal::Or","internal::MapOpt","internal::And","internal::FlatMap","<F as internal::Parser<I>>","internal::Into"],"FnL":["internal::AndThen","internal::Or","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::Into","internal::MapRes","internal::FlatMap","internal::Map"],"FnM":["std::boxed::Box","internal::FlatMap","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::AndThen","internal::Map","internal::MapRes","internal::And"],"FnN":["<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Into","internal::And","internal::Or"],"FnO":["internal::Map","std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","internal::And","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt"],"FnP":["internal::Map","internal::AndThen","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or","internal::And"],"FnQ":["internal::FlatMap","internal::Into","internal::Or","internal::Map","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I>>"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","error::ErrorKind","internal::Needed","error::VerboseError","error::Error","number::Endianness"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Map","internal::And","internal::MapOpt","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","std::boxed::Box","internal::Or","internal::AndThen","internal::MapRes"],"G":["internal::Map","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::And","internal::MapRes","internal::Or"]},"internal::AndThen":{"F":["internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap","internal::And","internal::MapRes","internal::Into","internal::MapOpt"],"G":["internal::FlatMap","internal::Or","internal::AndThen","internal::Into","internal::Map","std::boxed::Box","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::And"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","internal::Err","number::Endianness","error::ErrorKind","error::Error"]},"internal::FlatMap":{"F":["internal::Or","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::And","internal::MapRes","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::Into","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::And","std::boxed::Box"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::AndThen","internal::MapRes","std::boxed::Box","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::MapOpt","internal::Into"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault"]},"internal::MapOpt":{"F":["internal::MapOpt","std::boxed::Box","internal::And","internal::Or","internal::FlatMap","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::Map"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"]},"internal::MapRes":{"F":["std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::Map","internal::AndThen","internal::And","internal::Into"],"G":["core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"]},"internal::Or":{"F":["internal::Or","internal::MapRes","internal::MapOpt","internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I>>","internal::And","internal::FlatMap","std::boxed::Box"],"G":["internal::AndThen","internal::Or","internal::And","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapRes","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["internal::Parser","std::marker::Sized"],"FnQ":["internal::Parser","std::marker::Sized"],"FnR":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::Eq","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Into","internal::And","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::Map"],"FnB":["internal::Into","internal::And","internal::Map","internal::Or","<F as internal::Parser<I>>","internal::MapOpt","internal::MapRes","internal::AndThen","std::boxed::Box","internal::FlatMap"],"FnC":["internal::MapRes","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::MapOpt"],"FnD":["internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Or","internal::Into","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::Map","internal::MapOpt"],"FnE":["internal::AndThen","internal::And","internal::Map","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Or","internal::Into"],"FnF":["internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::AndThen","internal::MapOpt","internal::And","internal::Into","internal::Or"],"FnG":["internal::Into","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::Or","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::And"],"FnH":["std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::FlatMap","internal::Or","internal::Map","internal::MapRes","internal::Into","internal::And"],"FnI":["internal::AndThen","internal::FlatMap","internal::Or","internal::Map","internal::Into","std::boxed::Box","internal::MapOpt","internal::And","internal::MapRes","<F as internal::Parser<I>>"],"FnJ":["internal::Into","internal::Map","internal::Or","internal::And","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::AndThen"],"FnK":["internal::Or","internal::AndThen","internal::Map","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::Into","<F as internal::Parser<I>>","internal::And","std::boxed::Box"],"FnL":["internal::MapOpt","internal::Map","internal::Into","internal::MapRes","internal::Or","internal::And","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen"],"FnM":["internal::MapOpt","internal::Into","internal::MapRes","internal::Or","internal::And","internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>"],"FnN":["internal::Or","internal::And","internal::MapRes","internal::Map","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>"],"FnO":["internal::MapOpt","internal::Map","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::And","internal::FlatMap","internal::Or","internal::MapRes"],"FnP":["<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::MapOpt","internal::Into","internal::MapRes","internal::And","internal::FlatMap","internal::Map","internal::AndThen"],"FnQ":["internal::Or","internal::And","internal::FlatMap","internal::Map","internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::Into"],"FnR":["internal::Into","internal::And","std::boxed::Box","internal::AndThen","internal::MapOpt","internal::Map","internal::MapRes","<F as internal::Parser<I>>","internal::Or","internal::FlatMap"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::Error","error::ErrorKind","internal::Err","internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","error::VerboseError"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::And","internal::Or","<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","std::boxed::Box","internal::Map","internal::Into","internal::MapRes","internal::FlatMap"],"G":["<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::Map","internal::Or","internal::MapRes","internal::MapOpt","internal::Into","std::boxed::Box","internal::And"]},"internal::AndThen":{"F":["internal::Or","internal::Map","internal::MapRes","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::AndThen","internal::And"],"G":["internal::FlatMap","internal::MapRes","internal::Into","internal::Or","internal::And","internal::AndThen","internal::Map","internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>"]},"internal::Err":{"E":["error::VerboseErrorKind","internal::Needed","error::VerboseError","error::Error","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","number::Endianness"]},"internal::FlatMap":{"F":["internal::Or","internal::Into","internal::Map","internal::MapRes","internal::And","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::And","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::Or","std::boxed::Box","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::Map"],"O2":["error::Error","error::VerboseError"]},"internal::Map":{"F":["internal::Map","<F as internal::Parser<I>>","internal::MapRes","internal::And","internal::Or","internal::Into","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::AndThen"],"G":["core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"]},"internal::MapOpt":{"F":["internal::Into","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::MapRes"],"G":["core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue"]},"internal::MapRes":{"F":["internal::FlatMap","internal::MapOpt","internal::AndThen","internal::And","internal::Map","internal::Into","std::boxed::Box","<F as internal::Parser<I>>","internal::MapRes","internal::Or"],"G":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace"]},"internal::Or":{"F":["internal::Or","internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::MapRes","internal::MapOpt"],"G":["internal::MapOpt","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::Or","internal::Into","internal::FlatMap","internal::MapRes"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["internal::Parser","std::marker::Sized"],"FnR":["std::marker::Sized","internal::Parser"],"FnS":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["<F as internal::Parser<I>>","internal::MapRes","internal::Into","internal::AndThen","internal::Or","internal::Map","internal::MapOpt","internal::And","internal::FlatMap","std::boxed::Box"],"FnB":["internal::AndThen","internal::Map","internal::And","internal::Or","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::MapRes","internal::MapOpt"],"FnC":["internal::Map","internal::And","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Into","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I>>"],"FnD":["internal::And","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::MapRes","internal::Into","internal::Or","internal::AndThen","internal::MapOpt"],"FnE":["internal::MapRes","internal::Or","internal::AndThen","std::boxed::Box","internal::Map","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::And","internal::FlatMap"],"FnF":["std::boxed::Box","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::Or","internal::Into","internal::And","internal::Map"],"FnG":["internal::MapOpt","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::Into","internal::FlatMap","internal::MapRes","internal::AndThen","internal::And"],"FnH":["internal::MapRes","internal::Or","internal::And","internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::MapOpt"],"FnI":["internal::MapOpt","internal::Into","internal::MapRes","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::FlatMap"],"FnJ":["internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Or","internal::Into","internal::Map","internal::MapOpt","internal::And","std::boxed::Box"],"FnK":["internal::Map","internal::Or","<F as internal::Parser<I>>","internal::Into","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::And","internal::MapRes","internal::FlatMap"],"FnL":["internal::And","<F as internal::Parser<I>>","internal::AndThen","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Into","internal::Map","internal::Or","internal::FlatMap"],"FnM":["internal::AndThen","internal::And","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::MapRes","internal::Or","internal::MapOpt"],"FnN":["internal::MapOpt","std::boxed::Box","internal::AndThen","internal::Or","internal::Map","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapRes"],"FnO":["internal::Or","<F as internal::Parser<I>>","internal::And","internal::Map","internal::MapOpt","internal::FlatMap","internal::MapRes","std::boxed::Box","internal::AndThen","internal::Into"],"FnP":["std::boxed::Box","internal::FlatMap","internal::Or","internal::And","internal::MapRes","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::MapOpt","internal::Into"],"FnQ":["<F as internal::Parser<I>>","internal::Map","internal::MapOpt","internal::And","std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","internal::MapRes","internal::Or"],"FnR":["internal::Map","internal::FlatMap","std::boxed::Box","internal::MapRes","internal::And","internal::AndThen","internal::MapOpt","internal::Or","internal::Into","<F as internal::Parser<I>>"],"FnS":["internal::MapOpt","<F as internal::Parser<I>>","internal::Into","std::boxed::Box","internal::And","internal::FlatMap","internal::AndThen","internal::Or","internal::MapRes","internal::Map"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::Error","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","number::Endianness","error::VerboseErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","internal::Needed"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError","error::Error"]},"internal::And":{"F":["internal::Into","internal::And","internal::Map","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>","internal::MapOpt","internal::Or"],"G":["internal::Map","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Or","internal::FlatMap","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::And"]},"internal::AndThen":{"F":["internal::And","std::boxed::Box","internal::MapRes","internal::Or","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::FlatMap","internal::AndThen","internal::Map"],"G":["<F as internal::Parser<I>>","internal::MapRes","internal::AndThen","internal::And","internal::Or","internal::MapOpt","internal::Map","internal::FlatMap","internal::Into","std::boxed::Box"]},"internal::Err":{"E":["error::Error","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness","error::VerboseErrorKind","internal::Needed","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::AndThen","internal::MapRes","internal::And","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::Or","internal::FlatMap"],"G":["core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"internal::Into":{"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::Map","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::And","internal::Or","internal::FlatMap","internal::Into","internal::AndThen","internal::MapOpt"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::Or","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","internal::Map","std::boxed::Box","internal::MapRes","internal::And","internal::Into","internal::MapOpt"],"G":["core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"internal::MapOpt":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::MapRes","std::boxed::Box","internal::Or","internal::And","internal::FlatMap","internal::AndThen"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode"]},"internal::MapRes":{"F":["internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapOpt","internal::FlatMap","internal::And","internal::MapRes","internal::Map","std::boxed::Box","internal::Or"],"G":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"internal::Or":{"F":["internal::Into","internal::MapOpt","internal::FlatMap","internal::Or","std::boxed::Box","internal::MapRes","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::And"],"G":["<F as internal::Parser<I>>","internal::Or","std::boxed::Box","internal::MapRes","internal::Into","internal::FlatMap","internal::And","internal::MapOpt","internal::Map","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["internal::Parser","std::marker::Sized"],"FnR":["internal::Parser","std::marker::Sized"],"FnS":["std::marker::Sized","internal::Parser"],"FnT":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"],"T":["std::marker::Sized"]},"<F as internal::Parser<I>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"]},"internal::MapRes":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Or","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::And","internal::MapRes"],"FnB":["internal::MapRes","std::boxed::Box","internal::MapOpt","<F as internal::Parser<I>>","internal::Map","internal::FlatMap","internal::Into","internal::AndThen","internal::And","internal::Or"],"FnC":["internal::And","internal::FlatMap","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Into","internal::Map","internal::Or","internal::AndThen"],"FnD":["internal::Into","internal::FlatMap","internal::MapOpt","internal::And","internal::Map","<F as internal::Parser<I>>","std::boxed::Box","internal::MapRes","internal::Or","internal::AndThen"],"FnE":["internal::MapRes","internal::AndThen","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::And","internal::Or","internal::FlatMap","internal::MapOpt","internal::Into"],"FnF":["internal::FlatMap","internal::AndThen","internal::MapOpt","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::Or","std::boxed::Box","internal::Into","internal::Map"],"FnG":["internal::Or","internal::MapOpt","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::MapRes","internal::And","internal::Into","internal::AndThen","internal::FlatMap"],"FnH":["internal::Map","internal::AndThen","internal::Or","std::boxed::Box","internal::And","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Into"],"FnI":["internal::AndThen","internal::And","internal::Map","internal::Into","internal::Or","internal::FlatMap","internal::MapOpt","std::boxed::Box","internal::MapRes","<F as internal::Parser<I>>"],"FnJ":["internal::Into","internal::And","internal::AndThen","internal::MapRes","internal::Map","internal::Or","internal::MapOpt","internal::FlatMap","<F as internal::Parser<I>>","std::boxed::Box"],"FnK":["internal::MapOpt","internal::Into","internal::Or","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::FlatMap","internal::And"],"FnL":["internal::Or","internal::Into","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::MapOpt","internal::Map"],"FnM":["internal::Into","internal::Or","internal::MapRes","<F as internal::Parser<I>>","internal::And","internal::MapOpt","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen"],"FnN":["internal::AndThen","internal::And","internal::Into","internal::Map","internal::Or","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>"],"FnO":["internal::And","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I>>","internal::Into","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::MapOpt"],"FnP":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::Into","internal::AndThen","internal::Map","internal::MapRes","internal::And","internal::MapOpt"],"FnQ":["<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::Into","internal::Map","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Or","internal::And"],"FnR":["internal::AndThen","internal::Into","internal::MapOpt","internal::MapRes","internal::And","<F as internal::Parser<I>>","internal::Map","internal::Or","internal::FlatMap","std::boxed::Box"],"FnS":["internal::MapRes","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapOpt","internal::Or","internal::And"],"FnT":["internal::FlatMap","internal::MapRes","internal::Map","std::boxed::Box","internal::Or","internal::AndThen","<F as internal::Parser<I>>","internal::And","internal::Into","internal::MapOpt"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["number::Endianness","internal::Needed","error::VerboseError","error::ErrorKind","error::Error","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Err"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"],"T":["RUG_ANY"]},"<F as internal::Parser<I>>":{"F":["core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::MapOpt","internal::And"],"G":["internal::Map","internal::FlatMap","internal::Or","internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes"]},"internal::AndThen":{"F":["<F as internal::Parser<I>>","std::boxed::Box","internal::FlatMap","internal::Into","internal::Map","internal::AndThen","internal::MapOpt","internal::MapRes","internal::Or","internal::And"],"G":["<F as internal::Parser<I>>","internal::AndThen","internal::MapOpt","internal::Map","internal::MapRes","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","internal::Into"]},"internal::Err":{"E":["error::VerboseErrorKind","error::VerboseError","number::Endianness","error::Error","internal::Err","internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"internal::FlatMap":{"F":["internal::And","internal::MapOpt","internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::Map"],"G":["core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::slice::ascii::EscapeByte"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::AndThen","internal::MapOpt","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::Or","internal::Map","internal::Into","internal::FlatMap","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::And","internal::Into","internal::MapOpt","internal::Or","internal::MapRes","std::boxed::Box","internal::FlatMap"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::MapRes","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::Map","internal::MapOpt","internal::Into","std::boxed::Box","internal::AndThen","internal::And"],"G":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>"]},"internal::MapRes":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::Or","internal::And","internal::Map","internal::MapRes","internal::MapOpt","internal::FlatMap","std::boxed::Box","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr"]},"internal::Or":{"F":["internal::MapOpt","internal::And","internal::Or","internal::AndThen","internal::MapRes","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into"],"G":["internal::Into","internal::MapOpt","internal::MapRes","internal::FlatMap","internal::AndThen","internal::And","std::boxed::Box","internal::Map","<F as internal::Parser<I>>","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["internal::Parser","std::marker::Sized"],"FnQ":["std::marker::Sized","internal::Parser"],"FnR":["std::marker::Sized","internal::Parser"],"FnS":["internal::Parser","std::marker::Sized"],"FnT":["internal::Parser","std::marker::Sized"],"FnU":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"]},"internal::Into":{"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"]},"internal::MapOpt":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::MapRes":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Or","internal::And","std::boxed::Box","internal::MapOpt","internal::Map","internal::FlatMap","internal::MapRes","internal::Into","<F as internal::Parser<I>>","internal::AndThen"],"FnB":["internal::AndThen","internal::Or","internal::FlatMap","internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","internal::Map","std::boxed::Box","internal::Into","internal::And"],"FnC":["std::boxed::Box","internal::MapOpt","internal::Or","internal::MapRes","internal::AndThen","<F as internal::Parser<I>>","internal::Into","internal::Map","internal::And","internal::FlatMap"],"FnD":["internal::FlatMap","internal::Or","internal::AndThen","internal::MapOpt","internal::Into","std::boxed::Box","internal::MapRes","internal::Map","<F as internal::Parser<I>>","internal::And"],"FnE":["internal::AndThen","internal::Or","internal::Map","internal::Into","internal::MapRes","std::boxed::Box","internal::And","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt"],"FnF":["internal::And","internal::Or","internal::MapRes","std::boxed::Box","<F as internal::Parser<I>>","internal::AndThen","internal::Map","internal::Into","internal::FlatMap","internal::MapOpt"],"FnG":["internal::MapRes","internal::FlatMap","internal::And","<F as internal::Parser<I>>","internal::Map","std::boxed::Box","internal::MapOpt","internal::AndThen","internal::Or","internal::Into"],"FnH":["<F as internal::Parser<I>>","internal::AndThen","std::boxed::Box","internal::MapRes","internal::Map","internal::And","internal::FlatMap","internal::MapOpt","internal::Into","internal::Or"],"FnI":["internal::MapOpt","<F as internal::Parser<I>>","internal::MapRes","std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","internal::Or","internal::And","internal::Map"],"FnJ":["internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I>>","internal::Or","internal::MapOpt","internal::And","internal::MapRes"],"FnK":["internal::MapRes","internal::FlatMap","internal::Or","<F as internal::Parser<I>>","std::boxed::Box","internal::Map","internal::AndThen","internal::And","internal::Into","internal::MapOpt"],"FnL":["internal::AndThen","internal::Map","internal::FlatMap","internal::MapOpt","internal::Into","<F as internal::Parser<I>>","internal::And","std::boxed::Box","internal::MapRes","internal::Or"],"FnM":["<F as internal::Parser<I>>","internal::MapOpt","internal::AndThen","internal::Or","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","internal::And","internal::MapRes"],"FnN":["internal::Or","internal::And","std::boxed::Box","<F as internal::Parser<I>>","internal::Map","internal::AndThen","internal::MapOpt","internal::Into","internal::MapRes","internal::FlatMap"],"FnO":["internal::And","internal::Into","internal::MapOpt","internal::MapRes","std::boxed::Box","internal::Map","internal::AndThen","internal::FlatMap","<F as internal::Parser<I>>","internal::Or"],"FnP":["std::boxed::Box","internal::MapOpt","internal::And","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::Or","internal::Map","internal::FlatMap","internal::Into"],"FnQ":["internal::Into","internal::MapRes","std::boxed::Box","internal::Or","internal::FlatMap","internal::And","internal::MapOpt","internal::AndThen","internal::Map","<F as internal::Parser<I>>"],"FnR":["internal::MapOpt","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I>>","internal::Into","internal::Or","internal::And","internal::AndThen","internal::MapRes","internal::Map"],"FnS":["<F as internal::Parser<I>>","internal::FlatMap","internal::Map","internal::MapRes","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","internal::MapOpt"],"FnT":["internal::Map","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::Or","<F as internal::Parser<I>>","internal::FlatMap","internal::And","internal::Into","internal::AndThen"],"FnU":["internal::Into","internal::AndThen","internal::MapRes","internal::MapOpt","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I>>","internal::Or","internal::And","internal::Map"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::Error","internal::Err","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","error::ErrorKind","internal::Needed","number::Endianness"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::And":{"F":["internal::Map","std::boxed::Box","internal::Or","internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I>>","internal::MapRes","internal::FlatMap","internal::MapOpt"],"G":["std::boxed::Box","internal::And","internal::MapOpt","internal::AndThen","internal::FlatMap","internal::MapRes","internal::Map","internal::Or","internal::Into","<F as internal::Parser<I>>"]},"internal::AndThen":{"F":["internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","internal::MapRes","internal::Or","internal::And","<F as internal::Parser<I>>","internal::MapOpt","internal::Map"],"G":["<F as internal::Parser<I>>","internal::And","internal::Or","internal::MapOpt","internal::MapRes","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","internal::Map"]},"internal::Err":{"E":["error::Error","number::Endianness","error::ErrorKind","<*mut T as std::fmt::Debug>","internal::Needed","internal::Err","error::VerboseErrorKind","error::VerboseError"]},"internal::FlatMap":{"F":["internal::AndThen","<F as internal::Parser<I>>","internal::FlatMap","internal::MapOpt","internal::MapRes","internal::And","std::boxed::Box","internal::Or","internal::Into","internal::Map"],"G":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue"]},"internal::Into":{"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["std::boxed::Box","internal::Into","internal::And","internal::Or","internal::Map","<F as internal::Parser<I>>","internal::AndThen","internal::FlatMap","internal::MapOpt","internal::MapRes"],"O2":["error::VerboseError","error::Error"]},"internal::Map":{"F":["internal::MapRes","internal::AndThen","internal::Map","internal::MapOpt","std::boxed::Box","internal::Into","internal::FlatMap","<F as internal::Parser<I>>","internal::And","internal::Or"],"G":["core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap"]},"internal::MapOpt":{"F":["internal::And","<F as internal::Parser<I>>","internal::MapRes","internal::MapOpt","internal::Or","internal::AndThen","std::boxed::Box","internal::Map","internal::Into","internal::FlatMap"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"]},"internal::MapRes":{"F":["internal::MapOpt","internal::Or","internal::FlatMap","internal::MapRes","internal::Map","std::boxed::Box","internal::AndThen","internal::And","<F as internal::Parser<I>>","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode"]},"internal::Or":{"F":["internal::MapOpt","<F as internal::Parser<I>>","internal::And","internal::Map","internal::Into","std::boxed::Box","internal::Or","internal::FlatMap","internal::AndThen","internal::MapRes"],"G":["internal::And","internal::AndThen","std::boxed::Box","internal::MapOpt","internal::Map","<F as internal::Parser<I>>","internal::FlatMap","internal::Into","internal::MapRes","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <() as sequence::Tuple<I, (), E>>::parse
deps:{"<() as sequence::Tuple<I, (), E>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<() as sequence::Tuple<I, (), E>>::parse":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::VerboseError","error::Error","number::Endianness","<*const T as std::fmt::Debug>","error::ErrorKind","error::VerboseErrorKind","internal::Err"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut (); // None+()
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<() as sequence::Tuple<I, (), E>>::parse(p0, p1);
+crate::<() as sequence::Tuple<I, (), E>>::parse(p0, p1);
+<()>::parse(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.input_len();
+<&'a [u8] as traits::Input>::input_len(p0);
+crate::<&'a [u8] as traits::Input>::input_len(p0);
+<&'a [u8]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::take
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 0usize; // None+usize
+p0.take(p1);
+<&'a [u8] as traits::Input>::take(p0, p1);
+crate::<&'a [u8] as traits::Input>::take(p0, p1);
+<&'a [u8]>::take(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::take_from
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 0usize; // None+usize
+p0.take_from(p1);
+<&'a [u8] as traits::Input>::take_from(p0, p1);
+crate::<&'a [u8] as traits::Input>::take_from(p0, p1);
+<&'a [u8]>::take_from(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::take_split
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 0usize; // None+usize
+p0.take_split(p1);
+<&'a [u8] as traits::Input>::take_split(p0, p1);
+crate::<&'a [u8] as traits::Input>::take_split(p0, p1);
+<&'a [u8]>::take_split(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::position
'a
deps:{"<&'a [u8] as traits::Input>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8] as traits::Input>::position":{"P":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8] as traits::Input>::position(p0, p1);
+crate::<&'a [u8] as traits::Input>::position(p0, p1);
+<&'a [u8]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.iter_elements();
+<&'a [u8] as traits::Input>::iter_elements(p0);
+crate::<&'a [u8] as traits::Input>::iter_elements(p0);
+<&'a [u8]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.iter_indices();
+<&'a [u8] as traits::Input>::iter_indices(p0);
+crate::<&'a [u8] as traits::Input>::iter_indices(p0);
+<&'a [u8]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8] as traits::Input>::slice_index(p0, p1);
+crate::<&'a [u8] as traits::Input>::slice_index(p0, p1);
+<&'a [u8]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::split_at_position
'a
deps:{"<&'a [u8] as traits::Input>::split_at_position":{"E":["error::ParseError","std::marker::Sized"],"P":["std::marker::Sized","std::ops::Fn"]},"error::Error":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&'a [u8] as traits::Input>::split_at_position":{"E":["error::Error","error::VerboseError"],"P":["core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed","error::VerboseError","internal::Err","error::VerboseErrorKind","number::Endianness","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position(p1);
+<&'a [u8] as traits::Input>::split_at_position(p0, p1);
+crate::<&'a [u8] as traits::Input>::split_at_position(p0, p1);
+<&'a [u8]>::split_at_position(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::split_at_position1
'a
deps:{"<&'a [u8] as traits::Input>::split_at_position1":{"E":["error::ParseError","std::marker::Sized"],"P":["std::marker::Sized","std::ops::Fn"]},"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::cmp::Eq"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&'a [u8] as traits::Input>::split_at_position1":{"E":["error::Error","error::VerboseError"],"P":["core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeUnicode"]},"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err","error::Error"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::ErrorKind","internal::Needed","error::Error","error::VerboseErrorKind","internal::Err","error::VerboseError","number::Endianness"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1(p1, p2);
+<&'a [u8] as traits::Input>::split_at_position1(p0, p1, p2);
+crate::<&'a [u8] as traits::Input>::split_at_position1(p0, p1, p2);
+<&'a [u8]>::split_at_position1(p0, p1, p2);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::split_at_position_complete
'a
deps:{"<&'a [u8] as traits::Input>::split_at_position_complete":{"E":["std::marker::Sized","error::ParseError"],"P":["std::ops::Fn","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8] as traits::Input>::split_at_position_complete":{"E":["error::Error","error::VerboseError"],"P":["core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","internal::Needed","internal::Err","error::Error","error::VerboseErrorKind","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position_complete(p1);
+<&'a [u8] as traits::Input>::split_at_position_complete(p0, p1);
+crate::<&'a [u8] as traits::Input>::split_at_position_complete(p0, p1);
+<&'a [u8]>::split_at_position_complete(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Input>::split_at_position1_complete
'a
deps:{"<&'a [u8] as traits::Input>::split_at_position1_complete":{"E":["error::ParseError","std::marker::Sized"],"P":["std::marker::Sized","std::ops::Fn"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&'a [u8] as traits::Input>::split_at_position1_complete":{"E":["error::VerboseError","error::Error"],"P":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","error::Error","internal::Err"]},"internal::Err":{"E":["error::VerboseError","internal::Err","number::Endianness","error::VerboseErrorKind","error::Error","error::ErrorKind","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1_complete(p1, p2);
+<&'a [u8] as traits::Input>::split_at_position1_complete(p0, p1, p2);
+crate::<&'a [u8] as traits::Input>::split_at_position1_complete(p0, p1, p2);
+<&'a [u8]>::split_at_position1_complete(p0, p1, p2);
-----------------
src/traits.rs <&'a str as traits::Input>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.input_len();
+<&'a str as traits::Input>::input_len(p0);
+crate::<&'a str as traits::Input>::input_len(p0);
+<&'a str>::input_len(p0);
-----------------
src/traits.rs <&'a str as traits::Input>::take
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 0usize; // None+usize
+p0.take(p1);
+<&'a str as traits::Input>::take(p0, p1);
+crate::<&'a str as traits::Input>::take(p0, p1);
+<&'a str>::take(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Input>::take_from
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 0usize; // None+usize
+p0.take_from(p1);
+<&'a str as traits::Input>::take_from(p0, p1);
+crate::<&'a str as traits::Input>::take_from(p0, p1);
+<&'a str>::take_from(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Input>::take_split
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 0usize; // None+usize
+p0.take_split(p1);
+<&'a str as traits::Input>::take_split(p0, p1);
+crate::<&'a str as traits::Input>::take_split(p0, p1);
+<&'a str>::take_split(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Input>::position
'a
deps:{"<&'a str as traits::Input>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a str as traits::Input>::position":{"P":["core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsAsciiWhitespace"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a str as traits::Input>::position(p0, p1);
+crate::<&'a str as traits::Input>::position(p0, p1);
+<&'a str>::position(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Input>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.iter_elements();
+<&'a str as traits::Input>::iter_elements(p0);
+crate::<&'a str as traits::Input>::iter_elements(p0);
+<&'a str>::iter_elements(p0);
-----------------
src/traits.rs <&'a str as traits::Input>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.iter_indices();
+<&'a str as traits::Input>::iter_indices(p0);
+crate::<&'a str as traits::Input>::iter_indices(p0);
+<&'a str>::iter_indices(p0);
-----------------
src/traits.rs <&'a str as traits::Input>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a str as traits::Input>::slice_index(p0, p1);
+crate::<&'a str as traits::Input>::slice_index(p0, p1);
+<&'a str>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Input>::split_at_position
'a
deps:{"<&'a str as traits::Input>::split_at_position":{"E":["std::marker::Sized","error::ParseError"],"P":["std::marker::Sized","std::ops::Fn"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::Eq","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&'a str as traits::Input>::split_at_position":{"E":["error::VerboseError","error::Error"],"P":["std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsNotEmpty"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::Error","error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::VerboseErrorKind","number::Endianness","error::Error","internal::Err","error::ErrorKind","<*mut T as std::fmt::Debug>","internal::Needed","error::VerboseError"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position(p1);
+<&'a str as traits::Input>::split_at_position(p0, p1);
+crate::<&'a str as traits::Input>::split_at_position(p0, p1);
+<&'a str>::split_at_position(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Input>::split_at_position1
'a
deps:{"<&'a str as traits::Input>::split_at_position1":{"E":["error::ParseError","std::marker::Sized"],"P":["std::marker::Sized","std::ops::Fn"]},"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::cmp::Eq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&'a str as traits::Input>::split_at_position1":{"E":["error::Error","error::VerboseError"],"P":["core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue"]},"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::Error","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::VerboseErrorKind","error::ErrorKind","error::VerboseError","error::Error","internal::Err","number::Endianness"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1(p1, p2);
+<&'a str as traits::Input>::split_at_position1(p0, p1, p2);
+crate::<&'a str as traits::Input>::split_at_position1(p0, p1, p2);
+<&'a str>::split_at_position1(p0, p1, p2);
-----------------
src/traits.rs <&'a str as traits::Input>::split_at_position_complete
'a
deps:{"<&'a str as traits::Input>::split_at_position_complete":{"E":["error::ParseError","std::marker::Sized"],"P":["std::ops::Fn","std::marker::Sized"]},"error::Error":{"I":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&'a str as traits::Input>::split_at_position_complete":{"E":["error::Error","error::VerboseError"],"P":["core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","internal::Needed","error::VerboseErrorKind","error::VerboseError","error::Error","number::Endianness","internal::Err"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position_complete(p1);
+<&'a str as traits::Input>::split_at_position_complete(p0, p1);
+crate::<&'a str as traits::Input>::split_at_position_complete(p0, p1);
+<&'a str>::split_at_position_complete(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Input>::split_at_position1_complete
'a
deps:{"<&'a str as traits::Input>::split_at_position1_complete":{"E":["error::ParseError","std::marker::Sized"],"P":["std::ops::Fn","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Display","std::clone::Clone"]},"error::VerboseError":{"I":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&'a str as traits::Input>::split_at_position1_complete":{"E":["error::VerboseError","error::Error"],"P":["core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::Error","internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","<*mut T as std::fmt::Debug>","number::Endianness","error::VerboseErrorKind","internal::Err","internal::Needed","error::Error","error::VerboseError"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1_complete(p1, p2);
+<&'a str as traits::Input>::split_at_position1_complete(p0, p1, p2);
+crate::<&'a str as traits::Input>::split_at_position1_complete(p0, p1, p2);
+<&'a str>::split_at_position1_complete(p0, p1, p2);
-----------------
src/traits.rs <&'a [T] as traits::InputLength>::input_len
'a
deps:{"<&'a [T] as traits::InputLength>::input_len":{"T":["std::marker::Sized"]}}
candidates:{"<&'a [T] as traits::InputLength>::input_len":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [T]
+p0.input_len();
+<&'a [T] as traits::InputLength>::input_len(p0);
+crate::<&'a [T] as traits::InputLength>::input_len(p0);
+<&'a [T]>::input_len(p0);
-----------------
src/traits.rs <&'a str as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.input_len();
+<&'a str as traits::InputLength>::input_len(p0);
+crate::<&'a str as traits::InputLength>::input_len(p0);
+<&'a str>::input_len(p0);
-----------------
src/traits.rs <(&'a [u8], usize) as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (&'a [u8], usize)
+p0.input_len();
+<(&'a [u8], usize) as traits::InputLength>::input_len(p0);
+crate::<(&'a [u8], usize) as traits::InputLength>::input_len(p0);
+<(&'a [u8], usize)>::input_len(p0);
-----------------
src/traits.rs <[u8] as traits::Offset>::offset
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.offset(p1);
+<[u8] as traits::Offset>::offset(p0, p1);
+crate::<[u8] as traits::Offset>::offset(p0, p1);
+<[u8]>::offset(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Offset>::offset
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.offset(p1);
+<&'a [u8] as traits::Offset>::offset(p0, p1);
+crate::<&'a [u8] as traits::Offset>::offset(p0, p1);
+<&'a [u8]>::offset(p0, p1);
-----------------
src/traits.rs <str as traits::Offset>::offset
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = "sample"; // None+&str
+p0.offset(&p1);
+<str as traits::Offset>::offset(&p0, &p1);
+crate::<str as traits::Offset>::offset(&p0, &p1);
+<str>::offset(&p0, &p1);
-----------------
src/traits.rs <&'a str as traits::Offset>::offset
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & "a"; // None+&'a str
+p0.offset(p1);
+<&'a str as traits::Offset>::offset(p0, p1);
+crate::<&'a str as traits::Offset>::offset(p0, p1);
+<&'a str>::offset(p0, p1);
-----------------
src/traits.rs <&'a str as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.as_bytes();
+<&'a str as traits::AsBytes>::as_bytes(p0);
+crate::<&'a str as traits::AsBytes>::as_bytes(p0);
+<&'a str>::as_bytes(p0);
-----------------
src/traits.rs <str as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+p0.as_bytes();
+<str as traits::AsBytes>::as_bytes(&p0);
+crate::<str as traits::AsBytes>::as_bytes(&p0);
+<str>::as_bytes(&p0);
-----------------
src/traits.rs <&'a [u8] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.as_bytes();
+<&'a [u8] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8]>::as_bytes(p0);
-----------------
src/traits.rs <[u8] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.as_bytes();
+<[u8] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8] as traits::AsBytes>::as_bytes(p0);
+<[u8]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; N] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; N]
+p0.as_bytes();
+<&'a [u8; N] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; N] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; N]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; N] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; N]
+p0.as_bytes();
+<[u8; N] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; N] as traits::AsBytes>::as_bytes(p0);
+<[u8; N]>::as_bytes(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::as_char
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_char();
+<u8 as traits::AsChar>::as_char(p0);
+crate::<u8 as traits::AsChar>::as_char(p0);
+<u8>::as_char(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_alpha
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_alpha();
+<u8 as traits::AsChar>::is_alpha(p0);
+crate::<u8 as traits::AsChar>::is_alpha(p0);
+<u8>::is_alpha(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_alphanum
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_alphanum();
+<u8 as traits::AsChar>::is_alphanum(p0);
+crate::<u8 as traits::AsChar>::is_alphanum(p0);
+<u8>::is_alphanum(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_dec_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_dec_digit();
+<u8 as traits::AsChar>::is_dec_digit(p0);
+crate::<u8 as traits::AsChar>::is_dec_digit(p0);
+<u8>::is_dec_digit(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_hex_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_hex_digit();
+<u8 as traits::AsChar>::is_hex_digit(p0);
+crate::<u8 as traits::AsChar>::is_hex_digit(p0);
+<u8>::is_hex_digit(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_oct_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_oct_digit();
+<u8 as traits::AsChar>::is_oct_digit(p0);
+crate::<u8 as traits::AsChar>::is_oct_digit(p0);
+<u8>::is_oct_digit(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::len
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.len();
+<u8 as traits::AsChar>::len(p0);
+crate::<u8 as traits::AsChar>::len(p0);
+<u8>::len(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::as_char
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.as_char();
+<&'a u8 as traits::AsChar>::as_char(p0);
+crate::<&'a u8 as traits::AsChar>::as_char(p0);
+<&'a u8>::as_char(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_alpha
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_alpha();
+<&'a u8 as traits::AsChar>::is_alpha(p0);
+crate::<&'a u8 as traits::AsChar>::is_alpha(p0);
+<&'a u8>::is_alpha(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_alphanum
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_alphanum();
+<&'a u8 as traits::AsChar>::is_alphanum(p0);
+crate::<&'a u8 as traits::AsChar>::is_alphanum(p0);
+<&'a u8>::is_alphanum(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_dec_digit
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_dec_digit();
+<&'a u8 as traits::AsChar>::is_dec_digit(p0);
+crate::<&'a u8 as traits::AsChar>::is_dec_digit(p0);
+<&'a u8>::is_dec_digit(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_hex_digit
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_hex_digit();
+<&'a u8 as traits::AsChar>::is_hex_digit(p0);
+crate::<&'a u8 as traits::AsChar>::is_hex_digit(p0);
+<&'a u8>::is_hex_digit(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_oct_digit
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_oct_digit();
+<&'a u8 as traits::AsChar>::is_oct_digit(p0);
+crate::<&'a u8 as traits::AsChar>::is_oct_digit(p0);
+<&'a u8>::is_oct_digit(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::len
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.len();
+<&'a u8 as traits::AsChar>::len(p0);
+crate::<&'a u8 as traits::AsChar>::len(p0);
+<&'a u8>::len(p0);
-----------------
src/traits.rs <char as traits::AsChar>::as_char
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_char();
+<char as traits::AsChar>::as_char(p0);
+crate::<char as traits::AsChar>::as_char(p0);
+<char>::as_char(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_alpha
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_alpha();
+<char as traits::AsChar>::is_alpha(p0);
+crate::<char as traits::AsChar>::is_alpha(p0);
+<char>::is_alpha(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_alphanum
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_alphanum();
+<char as traits::AsChar>::is_alphanum(p0);
+crate::<char as traits::AsChar>::is_alphanum(p0);
+<char>::is_alphanum(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_dec_digit
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_dec_digit();
+<char as traits::AsChar>::is_dec_digit(p0);
+crate::<char as traits::AsChar>::is_dec_digit(p0);
+<char>::is_dec_digit(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_hex_digit
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_hex_digit();
+<char as traits::AsChar>::is_hex_digit(p0);
+crate::<char as traits::AsChar>::is_hex_digit(p0);
+<char>::is_hex_digit(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_oct_digit
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_oct_digit();
+<char as traits::AsChar>::is_oct_digit(p0);
+crate::<char as traits::AsChar>::is_oct_digit(p0);
+<char>::is_oct_digit(p0);
-----------------
src/traits.rs <char as traits::AsChar>::len
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.len();
+<char as traits::AsChar>::len(p0);
+crate::<char as traits::AsChar>::len(p0);
+<char>::len(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::as_char
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.as_char();
+<&'a char as traits::AsChar>::as_char(p0);
+crate::<&'a char as traits::AsChar>::as_char(p0);
+<&'a char>::as_char(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_alpha
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_alpha();
+<&'a char as traits::AsChar>::is_alpha(p0);
+crate::<&'a char as traits::AsChar>::is_alpha(p0);
+<&'a char>::is_alpha(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_alphanum
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_alphanum();
+<&'a char as traits::AsChar>::is_alphanum(p0);
+crate::<&'a char as traits::AsChar>::is_alphanum(p0);
+<&'a char>::is_alphanum(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_dec_digit
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_dec_digit();
+<&'a char as traits::AsChar>::is_dec_digit(p0);
+crate::<&'a char as traits::AsChar>::is_dec_digit(p0);
+<&'a char>::is_dec_digit(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_hex_digit
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_hex_digit();
+<&'a char as traits::AsChar>::is_hex_digit(p0);
+crate::<&'a char as traits::AsChar>::is_hex_digit(p0);
+<&'a char>::is_hex_digit(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_oct_digit
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_oct_digit();
+<&'a char as traits::AsChar>::is_oct_digit(p0);
+crate::<&'a char as traits::AsChar>::is_oct_digit(p0);
+<&'a char>::is_oct_digit(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::len
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.len();
+<&'a char as traits::AsChar>::len(p0);
+crate::<&'a char as traits::AsChar>::len(p0);
+<&'a char>::len(p0);
-----------------
src/traits.rs <traits::CompareResult as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // traits::CompareResult
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<traits::CompareResult as std::fmt::Debug>::fmt(p0, p1);
+crate::<traits::CompareResult as std::fmt::Debug>::fmt(p0, p1);
+<traits::CompareResult>::fmt(p0, p1);
-----------------
src/traits.rs <traits::CompareResult as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // traits::CompareResult
+p0.assert_receiver_is_total_eq();
+<traits::CompareResult as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<traits::CompareResult as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<traits::CompareResult>::assert_receiver_is_total_eq(p0);
-----------------
src/traits.rs <traits::CompareResult as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // traits::CompareResult
let mut p1 = & MaybeUninit::uninit().assume_init(); // traits::CompareResult
+p0.eq(p1);
+<traits::CompareResult as std::cmp::PartialEq>::eq(p0, p1);
+crate::<traits::CompareResult as std::cmp::PartialEq>::eq(p0, p1);
+<traits::CompareResult>::eq(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b str>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = "sample"; // None+&str
+p0.compare(&p1);
+<&'a [u8] as traits::Compare<&'b str>>::compare(p0, &p1);
+crate::<&'a [u8] as traits::Compare<&'b str>>::compare(p0, &p1);
+<&'a [u8]>::compare(p0, &p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b str>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = "sample"; // None+&str
+p0.compare_no_case(&p1);
+<&'a [u8] as traits::Compare<&'b str>>::compare_no_case(p0, &p1);
+crate::<&'a [u8] as traits::Compare<&'b str>>::compare_no_case(p0, &p1);
+<&'a [u8]>::compare_no_case(p0, &p1);
-----------------
src/traits.rs <&'a str as traits::Compare<&'b str>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = "sample"; // None+&str
+p0.compare(&p1);
+<&'a str as traits::Compare<&'b str>>::compare(p0, &p1);
+crate::<&'a str as traits::Compare<&'b str>>::compare(p0, &p1);
+<&'a str>::compare(p0, &p1);
-----------------
src/traits.rs <&'a str as traits::Compare<&'b str>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = "sample"; // None+&str
+p0.compare_no_case(&p1);
+<&'a str as traits::Compare<&'b str>>::compare_no_case(p0, &p1);
+crate::<&'a str as traits::Compare<&'b str>>::compare_no_case(p0, &p1);
+<&'a str>::compare_no_case(p0, &p1);
-----------------
src/traits.rs <&'a str as traits::Compare<&'b [u8]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.compare(p1);
+<&'a str as traits::Compare<&'b [u8]>>::compare(p0, p1);
+crate::<&'a str as traits::Compare<&'b [u8]>>::compare(p0, p1);
+<&'a str>::compare(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Compare<&'b [u8]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.compare_no_case(p1);
+<&'a str as traits::Compare<&'b [u8]>>::compare_no_case(p0, p1);
+crate::<&'a str as traits::Compare<&'b [u8]>>::compare_no_case(p0, p1);
+<&'a str>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::FindToken<u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<&'a [u8] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<&'a [u8] as traits::FindToken<u8>>::find_token(p0, p1);
+<&'a [u8]>::find_token(p0, p1);
-----------------
src/traits.rs <&'a str as traits::FindToken<u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<&'a str as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<&'a str as traits::FindToken<u8>>::find_token(p0, p1);
+<&'a str>::find_token(p0, p1);
-----------------
src/traits.rs <&'b [u8] as traits::FindToken<&'a u8>>::find_token
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'b [u8]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<&'b [u8] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<&'b [u8] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<&'b [u8]>::find_token(p0, p1);
-----------------
src/traits.rs <&'b str as traits::FindToken<&'a u8>>::find_token
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'b str
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<&'b str as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<&'b str as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<&'b str>::find_token(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::FindToken<char>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 'a'; // None+char
+p0.find_token(p1);
+<&'a [u8] as traits::FindToken<char>>::find_token(p0, p1);
+crate::<&'a [u8] as traits::FindToken<char>>::find_token(p0, p1);
+<&'a [u8]>::find_token(p0, p1);
-----------------
src/traits.rs <&'a str as traits::FindToken<char>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 'a'; // None+char
+p0.find_token(p1);
+<&'a str as traits::FindToken<char>>::find_token(p0, p1);
+crate::<&'a str as traits::FindToken<char>>::find_token(p0, p1);
+<&'a str>::find_token(p0, p1);
-----------------
src/traits.rs <&'a [char] as traits::FindToken<char>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & ['a'].as_mut_slice(); // None+&'a [char]
let mut p1 = 'a'; // None+char
+p0.find_token(p1);
+<&'a [char] as traits::FindToken<char>>::find_token(p0, p1);
+crate::<&'a [char] as traits::FindToken<char>>::find_token(p0, p1);
+<&'a [char]>::find_token(p0, p1);
-----------------
src/traits.rs <&'b [char] as traits::FindToken<&'a char>>::find_token
'a,'b
deps:{}
candidates:{}
let mut p0 = & ['a'].as_mut_slice(); // None+&'b [char]
let mut p1 = & 'a'; // None+char
+p0.find_token(p1);
+<&'b [char] as traits::FindToken<&'a char>>::find_token(p0, p1);
+crate::<&'b [char] as traits::FindToken<&'a char>>::find_token(p0, p1);
+<&'b [char]>::find_token(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::FindSubstring<&'b [u8]>>::find_substring
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find_substring(p1);
+<&'a [u8] as traits::FindSubstring<&'b [u8]>>::find_substring(p0, p1);
+crate::<&'a [u8] as traits::FindSubstring<&'b [u8]>>::find_substring(p0, p1);
+<&'a [u8]>::find_substring(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::FindSubstring<&'b str>>::find_substring
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = "sample"; // None+&str
+p0.find_substring(&p1);
+<&'a [u8] as traits::FindSubstring<&'b str>>::find_substring(p0, &p1);
+crate::<&'a [u8] as traits::FindSubstring<&'b str>>::find_substring(p0, &p1);
+<&'a [u8]>::find_substring(p0, &p1);
-----------------
src/traits.rs <&'a str as traits::FindSubstring<&'b str>>::find_substring
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = "sample"; // None+&str
+p0.find_substring(&p1);
+<&'a str as traits::FindSubstring<&'b str>>::find_substring(p0, &p1);
+crate::<&'a str as traits::FindSubstring<&'b str>>::find_substring(p0, &p1);
+<&'a str>::find_substring(p0, &p1);
-----------------
src/traits.rs <&'a [u8] as traits::ParseTo<R>>::parse_to
'a
deps:{"<&'a [u8] as traits::ParseTo<R>>::parse_to":{"R":["std::marker::Sized","std::str::FromStr"]}}
candidates:{"<&'a [u8] as traits::ParseTo<R>>::parse_to":{"R":["bool","u64","i32","i8","i16","i64","char","usize","u32","u16","u8"]}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.parse_to();
+<&'a [u8] as traits::ParseTo<R>>::parse_to(p0);
+crate::<&'a [u8] as traits::ParseTo<R>>::parse_to(p0);
+<&'a [u8]>::parse_to(p0);
-----------------
src/traits.rs <&'a str as traits::ParseTo<R>>::parse_to
'a
deps:{"<&'a str as traits::ParseTo<R>>::parse_to":{"R":["std::marker::Sized","std::str::FromStr"]}}
candidates:{"<&'a str as traits::ParseTo<R>>::parse_to":{"R":["u32","char","i16","usize","u16","i32","u8","u64","i8","i64","bool"]}}
let mut p0 = & "a"; // None+&'a str
+p0.parse_to();
+<&'a str as traits::ParseTo<R>>::parse_to(p0);
+crate::<&'a str as traits::ParseTo<R>>::parse_to(p0);
+<&'a str>::parse_to(p0);
-----------------
src/traits.rs <[u8; N] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; N]
+p0.input_len();
+<[u8; N] as traits::InputLength>::input_len(p0);
+crate::<[u8; N] as traits::InputLength>::input_len(p0);
+<[u8; N]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; N] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; N]
+p0.input_len();
+<&'a [u8; N] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; N] as traits::InputLength>::input_len(p0);
+<&'a [u8; N]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; N]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; N]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; N]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; N]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; N]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; N]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; N]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; N]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; N]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; N]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; N]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; N]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; N]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; N] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; N]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; N] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; N] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; N]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; N] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; N]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; N] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; N] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; N]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8] as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.new_builder();
+<[u8] as traits::ExtendInto>::new_builder(p0);
+crate::<[u8] as traits::ExtendInto>::new_builder(p0);
+<[u8]>::new_builder(p0);
-----------------
src/traits.rs <[u8] as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.extend_into(p1);
+<[u8] as traits::ExtendInto>::extend_into(p0, p1);
+crate::<[u8] as traits::ExtendInto>::extend_into(p0, p1);
+<[u8]>::extend_into(p0, p1);
-----------------
src/traits.rs <&[u8] as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&[u8]
+p0.new_builder();
+<&[u8] as traits::ExtendInto>::new_builder(p0);
+crate::<&[u8] as traits::ExtendInto>::new_builder(p0);
+<&[u8]>::new_builder(p0);
-----------------
src/traits.rs <&[u8] as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&[u8]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.extend_into(p1);
+<&[u8] as traits::ExtendInto>::extend_into(p0, p1);
+crate::<&[u8] as traits::ExtendInto>::extend_into(p0, p1);
+<&[u8]>::extend_into(p0, p1);
-----------------
src/traits.rs <str as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+p0.new_builder();
+<str as traits::ExtendInto>::new_builder(&p0);
+crate::<str as traits::ExtendInto>::new_builder(&p0);
+<str>::new_builder(&p0);
-----------------
src/traits.rs <str as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+p0.extend_into(p1);
+<str as traits::ExtendInto>::extend_into(&p0, p1);
+crate::<str as traits::ExtendInto>::extend_into(&p0, p1);
+<str>::extend_into(&p0, p1);
-----------------
src/traits.rs <&str as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&str
+p0.new_builder();
+<&str as traits::ExtendInto>::new_builder(p0);
+crate::<&str as traits::ExtendInto>::new_builder(p0);
+<&str>::new_builder(p0);
-----------------
src/traits.rs <&str as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&str
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+p0.extend_into(p1);
+<&str as traits::ExtendInto>::extend_into(p0, p1);
+crate::<&str as traits::ExtendInto>::extend_into(p0, p1);
+<&str>::extend_into(p0, p1);
-----------------
src/traits.rs <char as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.new_builder();
+<char as traits::ExtendInto>::new_builder(p0);
+crate::<char as traits::ExtendInto>::new_builder(p0);
+<char>::new_builder(p0);
-----------------
src/traits.rs <char as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+p0.extend_into(p1);
+<char as traits::ExtendInto>::extend_into(p0, p1);
+crate::<char as traits::ExtendInto>::extend_into(p0, p1);
+<char>::extend_into(p0, p1);
-----------------
src/traits.rs <u8 as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_usize();
+<u8 as traits::ToUsize>::to_usize(p0);
+crate::<u8 as traits::ToUsize>::to_usize(p0);
+<u8>::to_usize(p0);
-----------------
src/traits.rs <u16 as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_usize();
+<u16 as traits::ToUsize>::to_usize(p0);
+crate::<u16 as traits::ToUsize>::to_usize(p0);
+<u16>::to_usize(p0);
-----------------
src/traits.rs <usize as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_usize();
+<usize as traits::ToUsize>::to_usize(p0);
+crate::<usize as traits::ToUsize>::to_usize(p0);
+<usize>::to_usize(p0);
-----------------
src/traits.rs <u32 as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_usize();
+<u32 as traits::ToUsize>::to_usize(p0);
+crate::<u32 as traits::ToUsize>::to_usize(p0);
+<u32>::to_usize(p0);
-----------------
src/traits.rs <u64 as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_usize();
+<u64 as traits::ToUsize>::to_usize(p0);
+crate::<u64 as traits::ToUsize>::to_usize(p0);
+<u64>::to_usize(p0);
-----------------
src/traits.rs <((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert
deps:{"<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ((I, usize), error::ErrorKind)
+p0.convert();
+<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert(p0);
+crate::<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert(p0);
+<((I, usize), error::ErrorKind)>::convert(p0);
-----------------
src/traits.rs <(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert
deps:{"<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (I, error::ErrorKind)
+p0.convert();
+<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert(p0);
+crate::<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert(p0);
+<(I, error::ErrorKind)>::convert(p0);
-----------------
src/traits.rs <error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert
deps:{"<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error<(I, usize)>
+p0.convert();
+<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert(p0);
+crate::<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert(p0);
+<error::Error<(I, usize)>>::convert(p0);
-----------------
src/traits.rs <error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert
deps:{"<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error<I>
+p0.convert();
+<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert(p0);
+crate::<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert(p0);
+<error::Error<I>>::convert(p0);
-----------------
src/traits.rs <error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert
deps:{"<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::VerboseError<(I, usize)>
+p0.convert();
+<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert(p0);
+crate::<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert(p0);
+<error::VerboseError<(I, usize)>>::convert(p0);
-----------------
src/traits.rs <error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert
deps:{"<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+p0.convert();
+<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert(p0);
+crate::<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert(p0);
+<error::VerboseError<I>>::convert(p0);
-----------------
src/traits.rs <() as traits::ErrorConvert<()>>::convert
deps:{}
candidates:{}
let mut p0 = (); // None+()
+p0.convert();
+<() as traits::ErrorConvert<()>>::convert(p0);
+crate::<() as traits::ErrorConvert<()>>::convert(p0);
+<()>::convert(p0);
-----------------
src/traits.rs <[u8] as traits::HexDisplay>::to_hex
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
+p0.to_hex(p1);
+<[u8] as traits::HexDisplay>::to_hex(p0, p1);
+crate::<[u8] as traits::HexDisplay>::to_hex(p0, p1);
+<[u8]>::to_hex(p0, p1);
-----------------
src/traits.rs <[u8] as traits::HexDisplay>::to_hex_from
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.to_hex_from(p1, p2);
+<[u8] as traits::HexDisplay>::to_hex_from(p0, p1, p2);
+crate::<[u8] as traits::HexDisplay>::to_hex_from(p0, p1, p2);
+<[u8]>::to_hex_from(p0, p1, p2);
-----------------
src/traits.rs <str as traits::HexDisplay>::to_hex
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
+p0.to_hex(p1);
+<str as traits::HexDisplay>::to_hex(&p0, p1);
+crate::<str as traits::HexDisplay>::to_hex(&p0, p1);
+<str>::to_hex(&p0, p1);
-----------------
src/traits.rs <str as traits::HexDisplay>::to_hex_from
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.to_hex_from(p1, p2);
+<str as traits::HexDisplay>::to_hex_from(&p0, p1, p2);
+crate::<str as traits::HexDisplay>::to_hex_from(&p0, p1, p2);
+<str>::to_hex_from(&p0, p1, p2);
-----------------
src/traits.rs <traits::SaturatingIterator as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // traits::SaturatingIterator
+p0.next();
+<traits::SaturatingIterator as std::iter::Iterator>::next(p0);
+crate::<traits::SaturatingIterator as std::iter::Iterator>::next(p0);
+<traits::SaturatingIterator>::next(p0);
-----------------
src/traits.rs <std::ops::Range<usize> as traits::NomRange<usize>>::bounds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.bounds();
+<std::ops::Range<usize> as traits::NomRange<usize>>::bounds(p0);
+crate::<std::ops::Range<usize> as traits::NomRange<usize>>::bounds(p0);
+<std::ops::Range<usize>>::bounds(p0);
-----------------
src/traits.rs <std::ops::Range<usize> as traits::NomRange<usize>>::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
let mut p1 = & 0usize; // None+usize
+p0.contains(p1);
+<std::ops::Range<usize> as traits::NomRange<usize>>::contains(p0, p1);
+crate::<std::ops::Range<usize> as traits::NomRange<usize>>::contains(p0, p1);
+<std::ops::Range<usize>>::contains(p0, p1);
-----------------
src/traits.rs <std::ops::Range<usize> as traits::NomRange<usize>>::is_inverted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.is_inverted();
+<std::ops::Range<usize> as traits::NomRange<usize>>::is_inverted(p0);
+crate::<std::ops::Range<usize> as traits::NomRange<usize>>::is_inverted(p0);
+<std::ops::Range<usize>>::is_inverted(p0);
-----------------
src/traits.rs <std::ops::Range<usize> as traits::NomRange<usize>>::saturating_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.saturating_iter();
+<std::ops::Range<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+crate::<std::ops::Range<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+<std::ops::Range<usize>>::saturating_iter(p0);
-----------------
src/traits.rs <std::ops::Range<usize> as traits::NomRange<usize>>::bounded_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.bounded_iter();
+<std::ops::Range<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+crate::<std::ops::Range<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+<std::ops::Range<usize>>::bounded_iter(p0);
-----------------
src/traits.rs <std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeInclusive<usize>
+p0.bounds();
+<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounds(p0);
+crate::<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounds(p0);
+<std::ops::RangeInclusive<usize>>::bounds(p0);
-----------------
src/traits.rs <std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeInclusive<usize>
let mut p1 = & 0usize; // None+usize
+p0.contains(p1);
+<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::contains(p0, p1);
+crate::<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::contains(p0, p1);
+<std::ops::RangeInclusive<usize>>::contains(p0, p1);
-----------------
src/traits.rs <std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::is_inverted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeInclusive<usize>
+p0.is_inverted();
+<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::is_inverted(p0);
+crate::<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::is_inverted(p0);
+<std::ops::RangeInclusive<usize>>::is_inverted(p0);
-----------------
src/traits.rs <std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::saturating_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeInclusive<usize>
+p0.saturating_iter();
+<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+crate::<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+<std::ops::RangeInclusive<usize>>::saturating_iter(p0);
-----------------
src/traits.rs <std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounded_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeInclusive<usize>
+p0.bounded_iter();
+<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+crate::<std::ops::RangeInclusive<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+<std::ops::RangeInclusive<usize>>::bounded_iter(p0);
-----------------
src/traits.rs <std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFrom<usize>
+p0.bounds();
+<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounds(p0);
+crate::<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounds(p0);
+<std::ops::RangeFrom<usize>>::bounds(p0);
-----------------
src/traits.rs <std::ops::RangeFrom<usize> as traits::NomRange<usize>>::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFrom<usize>
let mut p1 = & 0usize; // None+usize
+p0.contains(p1);
+<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::contains(p0, p1);
+crate::<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::contains(p0, p1);
+<std::ops::RangeFrom<usize>>::contains(p0, p1);
-----------------
src/traits.rs <std::ops::RangeFrom<usize> as traits::NomRange<usize>>::is_inverted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFrom<usize>
+p0.is_inverted();
+<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::is_inverted(p0);
+crate::<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::is_inverted(p0);
+<std::ops::RangeFrom<usize>>::is_inverted(p0);
-----------------
src/traits.rs <std::ops::RangeFrom<usize> as traits::NomRange<usize>>::saturating_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFrom<usize>
+p0.saturating_iter();
+<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+crate::<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+<std::ops::RangeFrom<usize>>::saturating_iter(p0);
-----------------
src/traits.rs <std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounded_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFrom<usize>
+p0.bounded_iter();
+<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+crate::<std::ops::RangeFrom<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+<std::ops::RangeFrom<usize>>::bounded_iter(p0);
-----------------
src/traits.rs <std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeTo<usize>
+p0.bounds();
+<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounds(p0);
+crate::<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounds(p0);
+<std::ops::RangeTo<usize>>::bounds(p0);
-----------------
src/traits.rs <std::ops::RangeTo<usize> as traits::NomRange<usize>>::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeTo<usize>
let mut p1 = & 0usize; // None+usize
+p0.contains(p1);
+<std::ops::RangeTo<usize> as traits::NomRange<usize>>::contains(p0, p1);
+crate::<std::ops::RangeTo<usize> as traits::NomRange<usize>>::contains(p0, p1);
+<std::ops::RangeTo<usize>>::contains(p0, p1);
-----------------
src/traits.rs <std::ops::RangeTo<usize> as traits::NomRange<usize>>::is_inverted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeTo<usize>
+p0.is_inverted();
+<std::ops::RangeTo<usize> as traits::NomRange<usize>>::is_inverted(p0);
+crate::<std::ops::RangeTo<usize> as traits::NomRange<usize>>::is_inverted(p0);
+<std::ops::RangeTo<usize>>::is_inverted(p0);
-----------------
src/traits.rs <std::ops::RangeTo<usize> as traits::NomRange<usize>>::saturating_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeTo<usize>
+p0.saturating_iter();
+<std::ops::RangeTo<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+crate::<std::ops::RangeTo<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+<std::ops::RangeTo<usize>>::saturating_iter(p0);
-----------------
src/traits.rs <std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounded_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeTo<usize>
+p0.bounded_iter();
+<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+crate::<std::ops::RangeTo<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+<std::ops::RangeTo<usize>>::bounded_iter(p0);
-----------------
src/traits.rs <std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeToInclusive<usize>
+p0.bounds();
+<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounds(p0);
+crate::<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounds(p0);
+<std::ops::RangeToInclusive<usize>>::bounds(p0);
-----------------
src/traits.rs <std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeToInclusive<usize>
let mut p1 = & 0usize; // None+usize
+p0.contains(p1);
+<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::contains(p0, p1);
+crate::<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::contains(p0, p1);
+<std::ops::RangeToInclusive<usize>>::contains(p0, p1);
-----------------
src/traits.rs <std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::is_inverted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeToInclusive<usize>
+p0.is_inverted();
+<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::is_inverted(p0);
+crate::<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::is_inverted(p0);
+<std::ops::RangeToInclusive<usize>>::is_inverted(p0);
-----------------
src/traits.rs <std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::saturating_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeToInclusive<usize>
+p0.saturating_iter();
+<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+crate::<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::saturating_iter(p0);
+<std::ops::RangeToInclusive<usize>>::saturating_iter(p0);
-----------------
src/traits.rs <std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounded_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeToInclusive<usize>
+p0.bounded_iter();
+<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+crate::<std::ops::RangeToInclusive<usize> as traits::NomRange<usize>>::bounded_iter(p0);
+<std::ops::RangeToInclusive<usize>>::bounded_iter(p0);
-----------------
src/traits.rs <std::ops::RangeFull as traits::NomRange<usize>>::bounds
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFull
+p0.bounds();
+<std::ops::RangeFull as traits::NomRange<usize>>::bounds(p0);
+crate::<std::ops::RangeFull as traits::NomRange<usize>>::bounds(p0);
+<std::ops::RangeFull>::bounds(p0);
-----------------
src/traits.rs <std::ops::RangeFull as traits::NomRange<usize>>::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFull
let mut p1 = & 0usize; // None+usize
+p0.contains(p1);
+<std::ops::RangeFull as traits::NomRange<usize>>::contains(p0, p1);
+crate::<std::ops::RangeFull as traits::NomRange<usize>>::contains(p0, p1);
+<std::ops::RangeFull>::contains(p0, p1);
-----------------
src/traits.rs <std::ops::RangeFull as traits::NomRange<usize>>::is_inverted
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFull
+p0.is_inverted();
+<std::ops::RangeFull as traits::NomRange<usize>>::is_inverted(p0);
+crate::<std::ops::RangeFull as traits::NomRange<usize>>::is_inverted(p0);
+<std::ops::RangeFull>::is_inverted(p0);
-----------------
src/traits.rs <std::ops::RangeFull as traits::NomRange<usize>>::saturating_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFull
+p0.saturating_iter();
+<std::ops::RangeFull as traits::NomRange<usize>>::saturating_iter(p0);
+crate::<std::ops::RangeFull as traits::NomRange<usize>>::saturating_iter(p0);
+<std::ops::RangeFull>::saturating_iter(p0);
-----------------
src/traits.rs <std::ops::RangeFull as traits::NomRange<usize>>::bounded_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::ops::RangeFull
+p0.bounded_iter();
+<std::ops::RangeFull as traits::NomRange<usize>>::bounded_iter(p0);
+crate::<std::ops::RangeFull as traits::NomRange<usize>>::bounded_iter(p0);
+<std::ops::RangeFull>::bounded_iter(p0);
-----------------
src/traits.rs <usize as traits::NomRange<usize>>::bounds
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.bounds();
+<usize as traits::NomRange<usize>>::bounds(p0);
+crate::<usize as traits::NomRange<usize>>::bounds(p0);
+<usize>::bounds(p0);
-----------------
src/traits.rs <usize as traits::NomRange<usize>>::contains
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & 0usize; // None+usize
+p0.contains(p1);
+<usize as traits::NomRange<usize>>::contains(p0, p1);
+crate::<usize as traits::NomRange<usize>>::contains(p0, p1);
+<usize>::contains(p0, p1);
-----------------
src/traits.rs <usize as traits::NomRange<usize>>::is_inverted
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.is_inverted();
+<usize as traits::NomRange<usize>>::is_inverted(p0);
+crate::<usize as traits::NomRange<usize>>::is_inverted(p0);
+<usize>::is_inverted(p0);
-----------------
src/traits.rs <usize as traits::NomRange<usize>>::saturating_iter
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.saturating_iter();
+<usize as traits::NomRange<usize>>::saturating_iter(p0);
+crate::<usize as traits::NomRange<usize>>::saturating_iter(p0);
+<usize>::saturating_iter(p0);
-----------------
src/traits.rs <usize as traits::NomRange<usize>>::bounded_iter
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.bounded_iter();
+<usize as traits::NomRange<usize>>::bounded_iter(p0);
+crate::<usize as traits::NomRange<usize>>::bounded_iter(p0);
+<usize>::bounded_iter(p0);
-----------------
src/number/mod.rs <number::Endianness as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Endianness
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<number::Endianness as std::fmt::Debug>::fmt(p0, p1);
+crate::<number::Endianness as std::fmt::Debug>::fmt(p0, p1);
+<number::Endianness>::fmt(p0, p1);
-----------------
src/number/mod.rs <number::Endianness as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Endianness
let mut p1 = & MaybeUninit::uninit().assume_init(); // number::Endianness
+p0.eq(p1);
+<number::Endianness as std::cmp::PartialEq>::eq(p0, p1);
+crate::<number::Endianness as std::cmp::PartialEq>::eq(p0, p1);
+<number::Endianness>::eq(p0, p1);
-----------------
src/number/mod.rs <number::Endianness as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Endianness
+p0.assert_receiver_is_total_eq();
+<number::Endianness as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<number::Endianness as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<number::Endianness>::assert_receiver_is_total_eq(p0);
-----------------
src/number/mod.rs <number::Endianness as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Endianness
+p0.clone();
+<number::Endianness as std::clone::Clone>::clone(p0);
+crate::<number::Endianness as std::clone::Clone>::clone(p0);
+<number::Endianness>::clone(p0);