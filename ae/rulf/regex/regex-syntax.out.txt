-----------------
regex-syntax/src/ast/parse.rs ast::parse::is_hex
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+ast::parse::is_hex(p0);
+crate::ast::parse::is_hex(p0);
+crate::ast::parse::is_hex(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::is_capture_char
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = true; // None+bool
+ast::parse::is_capture_char(p0, p1);
+crate::ast::parse::is_capture_char(p0, p1);
+crate::ast::parse::is_capture_char(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::specialize_err
deps:{"ast::parse::specialize_err":{"T":["std::marker::Sized"]}}
candidates:{"ast::parse::specialize_err":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<T, ast::Error>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+ast::parse::specialize_err(p0, p1, p2);
+crate::ast::parse::specialize_err(p0, p1, p2);
+crate::ast::parse::specialize_err(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::visit
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::visit":{"V":["ast::visitor::Visitor","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["<&T as std::fmt::Debug>","std::sync::Arc<T>","std::ffi::OsString","std::vec::Vec<T, A>","std::ffi::CString","std::boxed::Box<T, A>","std::string::String","std::path::PathBuf","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::visit":{"V":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+ast::visitor::visit(p0, p1);
+crate::ast::visitor::visit(p0, p1);
+crate::ast::visitor::visit(p0, p1);
-----------------
regex-syntax/src/error.rs error::repeat_char
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 0usize; // None+usize
+error::repeat_char(p0, p1);
+crate::error::repeat_char(p0, p1);
+crate::error::repeat_char(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+hir::literal::prefixes(p0, p1);
+crate::hir::literal::prefixes(p0, p1);
+crate::hir::literal::prefixes(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+hir::literal::suffixes(p0, p1);
+crate::hir::literal::suffixes(p0, p1);
+crate::hir::literal::suffixes(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::repeat_zero_or_one_literals
deps:{"hir::literal::repeat_zero_or_one_literals":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::repeat_zero_or_one_literals":{"F":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::repeat_zero_or_one_literals(p0, p1, p2);
+crate::hir::literal::repeat_zero_or_one_literals(p0, p1, p2);
+crate::hir::literal::repeat_zero_or_one_literals(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::repeat_zero_or_more_literals
deps:{"hir::literal::repeat_zero_or_more_literals":{"F":["std::ops::FnMut","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::repeat_zero_or_more_literals":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::repeat_zero_or_more_literals(p0, p1, p2);
+crate::hir::literal::repeat_zero_or_more_literals(p0, p1, p2);
+crate::hir::literal::repeat_zero_or_more_literals(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::repeat_one_or_more_literals
deps:{"hir::literal::repeat_one_or_more_literals":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::repeat_one_or_more_literals":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::repeat_one_or_more_literals(p0, p1, p2);
+crate::hir::literal::repeat_one_or_more_literals(p0, p1, p2);
+crate::hir::literal::repeat_one_or_more_literals(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::repeat_range_literals
deps:{"hir::literal::repeat_range_literals":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::repeat_range_literals":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = 0u32; // None+u32
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<u32>
let mut p3 = true; // None+bool
let mut p4 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p5 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::repeat_range_literals(p0, p1, p2, p3, p4, p5);
+crate::hir::literal::repeat_range_literals(p0, p1, p2, p3, p4, p5);
+crate::hir::literal::repeat_range_literals(p0, p1, p2, p3, p4, p5);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::alternate_literals
deps:{"hir::literal::alternate_literals":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::alternate_literals":{"F":["core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [hir::Hir]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::alternate_literals(p0, p1, p2);
+crate::hir::literal::alternate_literals(p0, p1, p2);
+crate::hir::literal::alternate_literals(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::position
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+hir::literal::position(p0, p1);
+crate::hir::literal::position(p0, p1);
+crate::hir::literal::position(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::escape_unicode
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+hir::literal::escape_unicode(p0);
+crate::hir::literal::escape_unicode(p0);
+crate::hir::literal::escape_unicode(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::escape_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+hir::literal::escape_bytes(p0);
+crate::hir::literal::escape_bytes(p0);
+crate::hir::literal::escape_bytes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::escape_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+hir::literal::escape_byte(p0);
+crate::hir::literal::escape_byte(p0);
+crate::hir::literal::escape_byte(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::cls_char_count
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+hir::literal::cls_char_count(p0);
+crate::hir::literal::cls_char_count(p0);
+crate::hir::literal::cls_char_count(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::cls_byte_count
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+hir::literal::cls_byte_count(p0);
+crate::hir::literal::cls_byte_count(p0);
+crate::hir::literal::cls_byte_count(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::hir_ascii_class_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+hir::translate::hir_ascii_class_bytes(p0);
+crate::hir::translate::hir_ascii_class_bytes(p0);
+crate::hir::translate::hir_ascii_class_bytes(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::ascii_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+hir::translate::ascii_class(p0);
+crate::hir::translate::ascii_class(p0);
+crate::hir::translate::ascii_class(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::visit
deps:{"hir::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"hir::visitor::visit":{"V":["hir::visitor::Visitor","std::marker::Sized"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::visit":{"V":["hir::print::Writer"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+hir::visitor::visit(p0, p1);
+crate::hir::visitor::visit(p0, p1);
+crate::hir::visitor::visit(p0, p1);
-----------------
regex-syntax/src/unicode.rs unicode::simple_fold
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::simple_fold(p0);
+crate::unicode::simple_fold(p0);
+crate::unicode::simple_fold(p0);
-----------------
regex-syntax/src/unicode.rs unicode::simple_fold::imp
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::simple_fold::imp(p0);
+crate::unicode::simple_fold::imp(p0);
+crate::unicode::simple_fold::imp(p0);
-----------------
regex-syntax/src/unicode.rs unicode::contains_simple_case_mapping
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+unicode::contains_simple_case_mapping(p0, p1);
+crate::unicode::contains_simple_case_mapping(p0, p1);
+crate::unicode::contains_simple_case_mapping(p0, p1);
-----------------
regex-syntax/src/unicode.rs unicode::contains_simple_case_mapping::imp
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+unicode::contains_simple_case_mapping::imp(p0, p1);
+crate::unicode::contains_simple_case_mapping::imp(p0, p1);
+crate::unicode::contains_simple_case_mapping::imp(p0, p1);
-----------------
regex-syntax/src/unicode.rs unicode::class
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'_>
+unicode::class(p0);
+crate::unicode::class(p0);
+crate::unicode::class(p0);
-----------------
regex-syntax/src/unicode.rs unicode::perl_word
deps:{}
candidates:{}
+unicode::perl_word();
+crate::unicode::perl_word();
+crate::unicode::perl_word();
-----------------
regex-syntax/src/unicode.rs unicode::perl_word::imp
deps:{}
candidates:{}
+unicode::perl_word::imp();
+crate::unicode::perl_word::imp();
+crate::unicode::perl_word::imp();
-----------------
regex-syntax/src/unicode.rs unicode::perl_space
deps:{}
candidates:{}
+unicode::perl_space();
+crate::unicode::perl_space();
+crate::unicode::perl_space();
-----------------
regex-syntax/src/unicode.rs unicode::perl_space::imp
deps:{}
candidates:{}
+unicode::perl_space::imp();
+crate::unicode::perl_space::imp();
+crate::unicode::perl_space::imp();
-----------------
regex-syntax/src/unicode.rs unicode::perl_digit
deps:{}
candidates:{}
+unicode::perl_digit();
+crate::unicode::perl_digit();
+crate::unicode::perl_digit();
-----------------
regex-syntax/src/unicode.rs unicode::perl_digit::imp
deps:{}
candidates:{}
+unicode::perl_digit::imp();
+crate::unicode::perl_digit::imp();
+crate::unicode::perl_digit::imp();
-----------------
regex-syntax/src/unicode.rs unicode::hir_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(char, char)]
+unicode::hir_class(p0);
+crate::unicode::hir_class(p0);
+crate::unicode::hir_class(p0);
-----------------
regex-syntax/src/unicode.rs unicode::is_word_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::is_word_character(p0);
+crate::unicode::is_word_character(p0);
+crate::unicode::is_word_character(p0);
-----------------
regex-syntax/src/unicode.rs unicode::is_word_character::imp
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::is_word_character::imp(p0);
+crate::unicode::is_word_character::imp(p0);
+crate::unicode::is_word_character::imp(p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_gencat
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_gencat(&p0);
+crate::unicode::canonical_gencat(&p0);
+crate::unicode::canonical_gencat(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_script
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_script(&p0);
+crate::unicode::canonical_script(&p0);
+crate::unicode::canonical_script(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_prop
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_prop(&p0);
+crate::unicode::canonical_prop(&p0);
+crate::unicode::canonical_prop(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_prop::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_prop::imp(&p0);
+crate::unicode::canonical_prop::imp(&p0);
+crate::unicode::canonical_prop::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(&'static str, &'static str)]
let mut p1 = "sample"; // None+&str
+unicode::canonical_value(p0, &p1);
+crate::unicode::canonical_value(p0, &p1);
+crate::unicode::canonical_value(p0, &p1);
-----------------
regex-syntax/src/unicode.rs unicode::property_values
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::property_values(&p0);
+crate::unicode::property_values(&p0);
+crate::unicode::property_values(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::property_values::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::property_values::imp(&p0);
+crate::unicode::property_values::imp(&p0);
+crate::unicode::property_values::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::property_set
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(&'static str, &'static [(char, char)])]
let mut p1 = "sample"; // None+&str
+unicode::property_set(p0, &p1);
+crate::unicode::property_set(p0, &p1);
+crate::unicode::property_set(p0, &p1);
-----------------
regex-syntax/src/unicode.rs unicode::ages
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::ages(&p0);
+crate::unicode::ages(&p0);
+crate::unicode::ages(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::ages::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::ages::imp(&p0);
+crate::unicode::ages::imp(&p0);
+crate::unicode::ages::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::gencat
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gencat(&p0);
+crate::unicode::gencat(&p0);
+crate::unicode::gencat(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::gencat::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gencat::imp(&p0);
+crate::unicode::gencat::imp(&p0);
+crate::unicode::gencat::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::script
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script(&p0);
+crate::unicode::script(&p0);
+crate::unicode::script(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::script::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script::imp(&p0);
+crate::unicode::script::imp(&p0);
+crate::unicode::script::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::script_extension
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script_extension(&p0);
+crate::unicode::script_extension(&p0);
+crate::unicode::script_extension(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::script_extension::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script_extension::imp(&p0);
+crate::unicode::script_extension::imp(&p0);
+crate::unicode::script_extension::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::bool_property
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::bool_property(&p0);
+crate::unicode::bool_property(&p0);
+crate::unicode::bool_property(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::bool_property::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::bool_property::imp(&p0);
+crate::unicode::bool_property::imp(&p0);
+crate::unicode::bool_property::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::gcb
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gcb(&p0);
+crate::unicode::gcb(&p0);
+crate::unicode::gcb(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::gcb::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gcb::imp(&p0);
+crate::unicode::gcb::imp(&p0);
+crate::unicode::gcb::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::wb
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::wb(&p0);
+crate::unicode::wb(&p0);
+crate::unicode::wb(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::wb::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::wb::imp(&p0);
+crate::unicode::wb::imp(&p0);
+crate::unicode::wb::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::sb
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::sb(&p0);
+crate::unicode::sb(&p0);
+crate::unicode::sb(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::sb::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::sb::imp(&p0);
+crate::unicode::sb::imp(&p0);
+crate::unicode::sb::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::symbolic_name_normalize
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::symbolic_name_normalize(&p0);
+crate::unicode::symbolic_name_normalize(&p0);
+crate::unicode::symbolic_name_normalize(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::symbolic_name_normalize_bytes
deps:{}
candidates:{}
let mut p0 = &mut [0u8].as_mut_slice(); // None+[u8]
+unicode::symbolic_name_normalize_bytes(p0);
+crate::unicode::symbolic_name_normalize_bytes(p0);
+crate::unicode::symbolic_name_normalize_bytes(p0);
-----------------
regex-syntax/src/utf8.rs utf8::max_scalar_value
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+utf8::max_scalar_value(p0);
+crate::utf8::max_scalar_value(p0);
+crate::utf8::max_scalar_value(p0);
-----------------
regex-syntax/src/lib.rs escape
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+escape(&p0);
+crate::escape(&p0);
+crate::escape(&p0);
-----------------
regex-syntax/src/lib.rs escape_into
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+escape_into(&p0, p1);
+crate::escape_into(&p0, p1);
+crate::escape_into(&p0, p1);
-----------------
regex-syntax/src/lib.rs is_meta_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+is_meta_character(p0);
+crate::is_meta_character(p0);
+crate::is_meta_character(p0);
-----------------
regex-syntax/src/lib.rs is_word_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+is_word_character(p0);
+crate::is_word_character(p0);
+crate::is_word_character(p0);
-----------------
regex-syntax/src/lib.rs try_is_word_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+try_is_word_character(p0);
+crate::try_is_word_character(p0);
+crate::try_is_word_character(p0);
-----------------
regex-syntax/src/lib.rs is_word_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+is_word_byte(p0);
+crate::is_word_byte(p0);
+crate::is_word_byte(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::finish
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"ast::visitor::Visitor::finish":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::sync::Arc<T>","std::vec::Vec<T, A>","std::path::PathBuf","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::finish":{"Self":["hir::translate::TranslatorI","ast::print::Writer","ast::parse::NestLimiter"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.finish();
+ast::visitor::Visitor::finish(p0);
+crate::ast::visitor::Visitor::finish(p0);
+crate::ast::visitor::Visitor::finish(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::start
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::Visitor::start":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::string::String","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::path::PathBuf","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","std::vec::Vec<T, A>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::start":{"Self":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.start();
+ast::visitor::Visitor::start(p0);
+crate::ast::visitor::Visitor::start(p0);
+crate::ast::visitor::Visitor::start(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_pre
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"ast::visitor::Visitor::visit_pre":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::ffi::CString","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String","<&T as std::fmt::Debug>","std::rc::Rc<T>","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_pre":{"Self":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+ast::visitor::Visitor::visit_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_pre(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_post
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"ast::visitor::Visitor::visit_post":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::string::String","std::ffi::OsString","std::ffi::CString","<&mut T as std::fmt::Debug>","std::path::PathBuf","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::visit_post":{"Self":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+ast::visitor::Visitor::visit_post(p0, p1);
+crate::ast::visitor::Visitor::visit_post(p0, p1);
+crate::ast::visitor::Visitor::visit_post(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_alternation_in
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::Visitor::visit_alternation_in":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::vec::Vec<T, A>","<&mut T as std::fmt::Debug>","std::boxed::Box<T, A>","std::ffi::CString","std::path::PathBuf","std::string::String","std::rc::Rc<T>","std::sync::Arc<T>","std::ffi::OsString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_alternation_in":{"Self":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.visit_alternation_in();
+ast::visitor::Visitor::visit_alternation_in(p0);
+crate::ast::visitor::Visitor::visit_alternation_in(p0);
+crate::ast::visitor::Visitor::visit_alternation_in(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_item_pre
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"ast::visitor::Visitor::visit_class_set_item_pre":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::vec::Vec<T, A>","std::path::PathBuf","std::string::String","std::ffi::OsString","std::sync::Arc<T>","<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::ffi::CString","std::boxed::Box<T, A>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_item_pre":{"Self":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+ast::visitor::Visitor::visit_class_set_item_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_pre(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_item_post
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"ast::visitor::Visitor::visit_class_set_item_post":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::string::String","std::vec::Vec<T, A>","std::rc::Rc<T>","std::path::PathBuf","std::ffi::OsString","<&mut T as std::fmt::Debug>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_item_post":{"Self":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+ast::visitor::Visitor::visit_class_set_item_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_post(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_binary_op_pre
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::Visitor::visit_class_set_binary_op_pre":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::string::String","std::rc::Rc<T>","std::sync::Arc<T>","std::ffi::OsString","std::boxed::Box<T, A>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_binary_op_pre":{"Self":["ast::print::Writer","hir::translate::TranslatorI","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_pre(p1);
+ast::visitor::Visitor::visit_class_set_binary_op_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_pre(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_binary_op_post
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::Visitor::visit_class_set_binary_op_post":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::CString","std::string::String","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_binary_op_post":{"Self":["ast::parse::NestLimiter","ast::print::Writer","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_post(p1);
+ast::visitor::Visitor::visit_class_set_binary_op_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_post(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_binary_op_in
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"ast::visitor::Visitor::visit_class_set_binary_op_in":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","std::vec::Vec<T, A>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::visit_class_set_binary_op_in":{"Self":["ast::print::Writer","hir::translate::TranslatorI","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_in(p1);
+ast::visitor::Visitor::visit_class_set_binary_op_in(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_in(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_in(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::lower
deps:{"hir::interval::Interval::lower":{"Self":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Ord","std::cmp::Eq","std::clone::Clone","hir::interval::Interval","std::marker::Copy","std::default::Default"]}}
candidates:{"hir::interval::Interval::lower":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.lower();
+hir::interval::Interval::lower(p0);
+crate::hir::interval::Interval::lower(p0);
+crate::hir::interval::Interval::lower(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::upper
deps:{"hir::interval::Interval::upper":{"Self":["std::marker::Copy","hir::interval::Interval","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::default::Default","std::cmp::PartialEq","std::cmp::Ord"]}}
candidates:{"hir::interval::Interval::upper":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.upper();
+hir::interval::Interval::upper(p0);
+crate::hir::interval::Interval::upper(p0);
+crate::hir::interval::Interval::upper(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::set_lower
deps:{"hir::interval::Interval::set_lower":{"Self":["std::cmp::Eq","std::default::Default","std::cmp::Ord","hir::interval::Interval","std::cmp::PartialOrd","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Copy"]}}
candidates:{"hir::interval::Interval::set_lower":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
+p0.set_lower(p1);
+hir::interval::Interval::set_lower(p0, p1);
+crate::hir::interval::Interval::set_lower(p0, p1);
+crate::hir::interval::Interval::set_lower(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::set_upper
deps:{"hir::interval::Interval::set_upper":{"Self":["std::cmp::PartialOrd","std::marker::Copy","std::default::Default","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Ord","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::set_upper":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
+p0.set_upper(p1);
+hir::interval::Interval::set_upper(p0, p1);
+crate::hir::interval::Interval::set_upper(p0, p1);
+crate::hir::interval::Interval::set_upper(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::case_fold_simple
deps:{"hir::interval::Interval::case_fold_simple":{"Self":["std::default::Default","std::cmp::Eq","std::cmp::PartialOrd","std::cmp::PartialEq","std::cmp::Ord","std::fmt::Debug","std::marker::Copy","std::clone::Clone","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::case_fold_simple":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<Self>
+p0.case_fold_simple(p1);
+hir::interval::Interval::case_fold_simple(p0, p1);
+crate::hir::interval::Interval::case_fold_simple(p0, p1);
+crate::hir::interval::Interval::case_fold_simple(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::create
deps:{"hir::interval::Interval::create":{"Self":["std::cmp::PartialOrd","std::cmp::Ord","std::clone::Clone","std::cmp::PartialEq","std::marker::Copy","std::cmp::Eq","std::default::Default","std::fmt::Debug","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::create":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
let mut p1 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
+hir::interval::Interval::create(p0, p1);
+crate::hir::interval::Interval::create(p0, p1);
+crate::hir::interval::Interval::create(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::union
deps:{"hir::interval::Interval::union":{"Self":["std::marker::Copy","std::default::Default","std::cmp::Eq","hir::interval::Interval","std::clone::Clone","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::PartialEq","std::cmp::Ord"]}}
candidates:{"hir::interval::Interval::union":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.union(p1);
+hir::interval::Interval::union(p0, p1);
+crate::hir::interval::Interval::union(p0, p1);
+crate::hir::interval::Interval::union(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::intersect
deps:{"hir::interval::Interval::intersect":{"Self":["std::cmp::PartialOrd","std::cmp::Ord","std::default::Default","std::cmp::Eq","std::clone::Clone","hir::interval::Interval","std::fmt::Debug","std::cmp::PartialEq","std::marker::Copy"]}}
candidates:{"hir::interval::Interval::intersect":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.intersect(p1);
+hir::interval::Interval::intersect(p0, p1);
+crate::hir::interval::Interval::intersect(p0, p1);
+crate::hir::interval::Interval::intersect(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::difference
deps:{"hir::interval::Interval::difference":{"Self":["std::cmp::Ord","std::clone::Clone","std::cmp::PartialEq","std::default::Default","std::cmp::PartialOrd","std::cmp::Eq","std::marker::Copy","std::fmt::Debug","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::difference":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.difference(p1);
+hir::interval::Interval::difference(p0, p1);
+crate::hir::interval::Interval::difference(p0, p1);
+crate::hir::interval::Interval::difference(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::symmetric_difference
deps:{"hir::interval::Interval::symmetric_difference":{"Self":["std::cmp::PartialOrd","std::marker::Copy","std::fmt::Debug","hir::interval::Interval","std::clone::Clone","std::default::Default","std::cmp::Ord","std::cmp::Eq","std::cmp::PartialEq"]}}
candidates:{"hir::interval::Interval::symmetric_difference":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.symmetric_difference(p1);
+hir::interval::Interval::symmetric_difference(p0, p1);
+crate::hir::interval::Interval::symmetric_difference(p0, p1);
+crate::hir::interval::Interval::symmetric_difference(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::is_contiguous
deps:{"hir::interval::Interval::is_contiguous":{"Self":["std::clone::Clone","std::fmt::Debug","std::default::Default","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","hir::interval::Interval","std::marker::Copy","std::cmp::PartialOrd"]}}
candidates:{"hir::interval::Interval::is_contiguous":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_contiguous(p1);
+hir::interval::Interval::is_contiguous(p0, p1);
+crate::hir::interval::Interval::is_contiguous(p0, p1);
+crate::hir::interval::Interval::is_contiguous(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::is_intersection_empty
deps:{"hir::interval::Interval::is_intersection_empty":{"Self":["std::cmp::Eq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::clone::Clone","std::cmp::Ord","std::default::Default","std::cmp::PartialEq","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::is_intersection_empty":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_intersection_empty(p1);
+hir::interval::Interval::is_intersection_empty(p0, p1);
+crate::hir::interval::Interval::is_intersection_empty(p0, p1);
+crate::hir::interval::Interval::is_intersection_empty(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::is_subset
deps:{"hir::interval::Interval::is_subset":{"Self":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialOrd","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","hir::interval::Interval","std::cmp::Ord","std::marker::Copy"]}}
candidates:{"hir::interval::Interval::is_subset":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_subset(p1);
+hir::interval::Interval::is_subset(p0, p1);
+crate::hir::interval::Interval::is_subset(p0, p1);
+crate::hir::interval::Interval::is_subset(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::min_value
deps:{"hir::interval::Bound::min_value":{"Self":["hir::interval::Bound","std::cmp::PartialOrd","std::marker::Copy","std::cmp::Ord","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]}}
candidates:{"hir::interval::Bound::min_value":{"Self":["char","u8"]}}
+hir::interval::Bound::min_value();
+crate::hir::interval::Bound::min_value();
+crate::hir::interval::Bound::min_value();
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::max_value
deps:{"hir::interval::Bound::max_value":{"Self":["std::cmp::PartialEq","std::marker::Copy","std::cmp::Eq","std::cmp::PartialOrd","std::cmp::Ord","hir::interval::Bound","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"hir::interval::Bound::max_value":{"Self":["char","u8"]}}
+hir::interval::Bound::max_value();
+crate::hir::interval::Bound::max_value();
+crate::hir::interval::Bound::max_value();
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::as_u32
deps:{"hir::interval::Bound::as_u32":{"Self":["hir::interval::Bound","std::cmp::PartialEq","std::cmp::PartialOrd","std::cmp::Ord","std::cmp::Eq","std::fmt::Debug","std::marker::Copy","std::clone::Clone"]}}
candidates:{"hir::interval::Bound::as_u32":{"Self":["char","u8"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.as_u32();
+hir::interval::Bound::as_u32(p0);
+crate::hir::interval::Bound::as_u32(p0);
+crate::hir::interval::Bound::as_u32(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::increment
deps:{"hir::interval::Bound::increment":{"Self":["std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","hir::interval::Bound","std::cmp::Ord"]}}
candidates:{"hir::interval::Bound::increment":{"Self":["char","u8"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.increment();
+hir::interval::Bound::increment(p0);
+crate::hir::interval::Bound::increment(p0);
+crate::hir::interval::Bound::increment(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::decrement
deps:{"hir::interval::Bound::decrement":{"Self":["std::cmp::PartialOrd","std::marker::Copy","hir::interval::Bound","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Ord"]}}
candidates:{"hir::interval::Bound::decrement":{"Self":["char","u8"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.decrement();
+hir::interval::Bound::decrement(p0);
+crate::hir::interval::Bound::decrement(p0);
+crate::hir::interval::Bound::decrement(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::finish
deps:{"hir::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"hir::visitor::Visitor::finish":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::finish":{"Self":["hir::print::Writer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.finish();
+hir::visitor::Visitor::finish(p0);
+crate::hir::visitor::Visitor::finish(p0);
+crate::hir::visitor::Visitor::finish(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::start
deps:{"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"hir::visitor::Visitor::start":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::start":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.start();
+hir::visitor::Visitor::start(p0);
+crate::hir::visitor::Visitor::start(p0);
+crate::hir::visitor::Visitor::start(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::visit_pre
deps:{"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"hir::visitor::Visitor::visit_pre":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"hir::visitor::Visitor::visit_pre":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_pre(p1);
+hir::visitor::Visitor::visit_pre(p0, p1);
+crate::hir::visitor::Visitor::visit_pre(p0, p1);
+crate::hir::visitor::Visitor::visit_pre(p0, p1);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::visit_post
deps:{"hir::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"hir::visitor::Visitor::visit_post":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::visit_post":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_post(p1);
+hir::visitor::Visitor::visit_post(p0, p1);
+crate::hir::visitor::Visitor::visit_post(p0, p1);
+crate::hir::visitor::Visitor::visit_post(p0, p1);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::visit_alternation_in
deps:{"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"hir::visitor::Visitor::visit_alternation_in":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::visit_alternation_in":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.visit_alternation_in();
+hir::visitor::Visitor::visit_alternation_in(p0);
+crate::hir::visitor::Visitor::visit_alternation_in(p0);
+crate::hir::visitor::Visitor::visit_alternation_in(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Primitive as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.clone();
+<ast::parse::Primitive as std::clone::Clone>::clone(p0);
+crate::<ast::parse::Primitive as std::clone::Clone>::clone(p0);
+<ast::parse::Primitive>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Primitive as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::Primitive as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::Primitive as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::Primitive>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.assert_receiver_is_total_eq();
+<ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::parse::Primitive>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Primitive as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.eq(p1);
+<ast::parse::Primitive as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::parse::Primitive as std::cmp::PartialEq>::eq(p0, p1);
+<ast::parse::Primitive>::eq(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Primitive::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.span();
+ast::parse::Primitive::span(p0);
+crate::ast::parse::Primitive::span(p0);
+<ast::parse::Primitive>::span(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Primitive::into_ast
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.into_ast();
+ast::parse::Primitive::into_ast(p0);
+crate::ast::parse::Primitive::into_ast(p0);
+<ast::parse::Primitive>::into_ast(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Primitive::into_class_set_item
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_set_item":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_set_item":{"P":["std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::path::PathBuf","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'_, P>
+p0.into_class_set_item(p1);
+ast::parse::Primitive::into_class_set_item(p0, p1);
+crate::ast::parse::Primitive::into_class_set_item(p0, p1);
+<ast::parse::Primitive>::into_class_set_item(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Primitive::into_class_literal
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_literal":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_literal":{"P":["std::vec::Vec<T, A>","std::ffi::OsString","std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String","std::rc::Rc<T>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'_, P>
+p0.into_class_literal(p1);
+ast::parse::Primitive::into_class_literal(p0, p1);
+crate::ast::parse::Primitive::into_class_literal(p0, p1);
+<ast::parse::Primitive>::into_class_literal(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
+p0.clone();
+<ast::parse::ParserBuilder as std::clone::Clone>::clone(p0);
+crate::<ast::parse::ParserBuilder as std::clone::Clone>::clone(p0);
+<ast::parse::ParserBuilder>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::ParserBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<ast::parse::ParserBuilder as std::default::Default>::default();
+crate::<ast::parse::ParserBuilder as std::default::Default>::default();
+<ast::parse::ParserBuilder>::default();
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::new
deps:{}
candidates:{}
+ast::parse::ParserBuilder::new();
+crate::ast::parse::ParserBuilder::new();
+<ast::parse::ParserBuilder>::new();
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
+p0.build();
+ast::parse::ParserBuilder::build(p0);
+crate::ast::parse::ParserBuilder::build(p0);
+<ast::parse::ParserBuilder>::build(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+ast::parse::ParserBuilder::nest_limit(p0, p1);
+crate::ast::parse::ParserBuilder::nest_limit(p0, p1);
+<ast::parse::ParserBuilder>::nest_limit(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+ast::parse::ParserBuilder::octal(p0, p1);
+crate::ast::parse::ParserBuilder::octal(p0, p1);
+<ast::parse::ParserBuilder>::octal(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+ast::parse::ParserBuilder::ignore_whitespace(p0, p1);
+crate::ast::parse::ParserBuilder::ignore_whitespace(p0, p1);
+<ast::parse::ParserBuilder>::ignore_whitespace(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Parser as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Parser
+p0.clone();
+<ast::parse::Parser as std::clone::Clone>::clone(p0);
+crate::<ast::parse::Parser as std::clone::Clone>::clone(p0);
+<ast::parse::Parser>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Parser as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Parser
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::Parser as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::Parser as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::Parser>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserI<'s, P> as std::clone::Clone>::clone
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<*const T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone":{"P":["std::clone::Clone","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"either::Either":{"Left":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"],"Right":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","hir::interval::Interval","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<*const T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone":{"P":["ast::ClassPerlKind","hir::translate::Flags","ast::Group","hir::ClassUnicodeRange","hir::literal::Literal","ast::GroupKind","hir::interval::IntervalSet","ast::parse::ClassState","hir::Anchor","ast::FlagsItemKind","hir::Literal","ast::parse::Parser","hir::HirKind","hir::translate::TranslatorBuilder","utf8::Utf8Range","ast::parse::ParserI","ast::Flags","ast::Concat","ast::parse::ParserBuilder","ast::Repetition","ast::ClassUnicodeKind","hir::translate::HirFrame","hir::RepetitionKind","hir::ClassUnicode","ast::Ast","std::clone::impls::<impl std::clone::Clone for &T>","ast::Literal","hir::ClassBytesRange","ast::ClassSetBinaryOpKind","hir::Error","utf8::Utf8Sequence","hir::translate::TranslatorI","ast::SetFlags","hir::Hir","hir::ErrorKind","hir::Group","ast::RepetitionKind","ast::SpecialLiteralKind","ast::FlagsItem","ast::CaptureName","ast::ClassAsciiKind","ast::ClassSetUnion","ast::Position","hir::Class","hir::print::PrinterBuilder","hir::RepetitionRange","parser::ParserBuilder","ast::RepetitionRange","hir::literal::Literals","ast::Comment","hir::GroupKind","ast::RepetitionOp","hir::Repetition","hir::HirInfo","ast::Assertion","ast::parse::GroupState","ast::Class","ast::Flag","ast::print::PrinterBuilder","hir::WordBoundary","ast::AssertionKind","ast::ClassSetBinaryOp","hir::ClassBytes","ast::WithComments","ast::Error","ast::ClassSet","ast::HexLiteralKind","ast::LiteralKind","ast::Span","ast::ClassSetItem","ast::parse::Primitive","ast::Alternation","ast::ClassAscii","ast::ClassPerl","error::Error","ast::ErrorKind","ast::ClassSetRange","parser::Parser","either::Either","hir::translate::Translator","ast::ClassBracketed","ast::ClassUnicodeOpKind","ast::ClassUnicode"]},"ast::parse::ParserI":{"P":["std::clone::impls::<impl std::clone::Clone for &mut T>","std::ffi::CString","std::string::String","std::rc::Rc<T>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::ffi::OsString","std::sync::Arc<T>","std::path::PathBuf"]},"either::Either":{"Left":["ast::ClassSetRange","ast::ClassPerlKind","ast::ClassSet","ast::ClassSetItem","ast::Flag","hir::HirKind","ast::Assertion","ast::SetFlags","hir::Hir","ast::FlagsItemKind","hir::Literal","hir::literal::Literals","ast::Position","ast::ClassAscii","hir::ClassUnicode","ast::LiteralKind","ast::ClassPerl","ast::SpecialLiteralKind","hir::ClassBytes","ast::Class","ast::ClassSetBinaryOpKind","ast::Span","ast::RepetitionRange","ast::ClassBracketed","hir::RepetitionRange","ast::FlagsItem","hir::Repetition","hir::HirInfo","ast::Repetition","ast::Flags","hir::Class","ast::parse::Primitive","ast::ErrorKind","hir::Error","hir::Group","ast::Ast","ast::ClassUnicode","hir::RepetitionKind","ast::Comment","hir::literal::Literal","utf8::Utf8Range","utf8::Utf8Sequence","ast::RepetitionKind","ast::ClassAsciiKind","ast::GroupKind","ast::CaptureName","ast::HexLiteralKind","ast::AssertionKind","ast::Group","hir::ClassUnicodeRange","hir::interval::IntervalSet","ast::ClassUnicodeKind","ast::WithComments","hir::GroupKind","ast::Literal","ast::Alternation","hir::ErrorKind","error::Error","ast::Concat","<*const T as std::fmt::Debug>","ast::ClassSetUnion","hir::WordBoundary","ast::ClassUnicodeOpKind","either::Either","ast::Error","hir::ClassBytesRange","ast::RepetitionOp","ast::ClassSetBinaryOp","hir::Anchor"],"Right":["ast::AssertionKind","hir::Error","either::Either","ast::LiteralKind","ast::Literal","ast::Position","hir::Class","error::Error","ast::RepetitionOp","hir::ErrorKind","ast::FlagsItemKind","hir::GroupKind","ast::Group","hir::Hir","ast::WithComments","hir::ClassUnicodeRange","ast::ClassSet","ast::SpecialLiteralKind","ast::ClassUnicode","hir::interval::IntervalSet","ast::FlagsItem","ast::ClassAscii","utf8::Utf8Sequence","ast::ErrorKind","hir::Repetition","hir::literal::Literals","hir::WordBoundary","ast::SetFlags","hir::HirInfo","ast::Concat","ast::RepetitionKind","ast::Span","hir::HirKind","utf8::Utf8Range","hir::RepetitionRange","ast::parse::Primitive","ast::ClassSetBinaryOpKind","ast::ClassUnicodeKind","ast::GroupKind","ast::HexLiteralKind","ast::ClassUnicodeOpKind","ast::Assertion","ast::CaptureName","hir::ClassBytes","ast::Repetition","ast::Alternation","hir::literal::Literal","hir::Anchor","hir::ClassUnicode","hir::RepetitionKind","ast::Ast","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::ClassSetRange","ast::ClassPerlKind","ast::ClassSetUnion","ast::Flags","hir::ClassBytesRange","ast::Flag","ast::ClassSetBinaryOp","ast::Comment","ast::ClassAsciiKind","ast::Class","hir::Group","ast::RepetitionRange","hir::Literal","ast::ClassBracketed","ast::Error","ast::ClassSetItem","ast::ClassPerl"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.clone();
+<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone(p0);
+crate::<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone(p0);
+<ast::parse::ParserI<'s, P>>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt":{"P":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"either::Either":{"Left":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"],"Right":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"error::Formatter":{"E":["std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","hir::interval::Interval","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt":{"P":["utf8::Utf8Range","ast::visitor::ClassFrame","hir::ErrorKind","ast::ClassSetRange","ast::SpecialLiteralKind","error::Error","hir::Anchor","ast::ClassSet","ast::LiteralKind","ast::parse::NestLimiter","ast::ClassBracketed","ast::RepetitionOp","ast::ClassUnicodeOpKind","parser::Parser","ast::WithComments","unicode::ClassQuery","hir::Group","hir::GroupKind","hir::print::PrinterBuilder","hir::interval::IntervalSet","hir::Literal","hir::Repetition","hir::print::Printer","hir::print::Writer","hir::ClassUnicodeRange","ast::Class","ast::print::Writer","ast::Repetition","hir::WordBoundary","hir::translate::HirFrame","ast::ClassSetItem","hir::RepetitionRange","ast::AssertionKind","ast::FlagsItem","hir::ClassBytesIter","hir::translate::TranslatorBuilder","error::Formatter","hir::translate::Translator","unicode::CanonicalClassQuery","hir::Hir","hir::Class","ast::SetFlags","hir::translate::TranslatorI","utf8::ScalarRange","hir::translate::Flags","ast::ClassSetUnion","ast::ClassPerl","ast::parse::ClassState","ast::parse::ParserBuilder","ast::Concat","ast::RepetitionRange","ast::Flag","ast::GroupKind","hir::RepetitionKind","hir::ClassUnicodeIter","ast::ClassAsciiKind","ast::ErrorKind","ast::Literal","ast::print::PrinterBuilder","ast::parse::ParserI","<&mut T as std::fmt::Debug>","ast::FlagsItemKind","hir::ClassBytesRange","ast::Alternation","ast::HexLiteralKind","ast::Comment","utf8::Utf8Sequences","hir::literal::Literals","ast::parse::Primitive","unicode::Error","parser::ParserBuilder","ast::parse::Parser","unicode::CaseFoldError","ast::Assertion","hir::literal::Literal","ast::Error","ast::ClassUnicode","ast::parse::GroupState","ast::Flags","hir::ClassUnicode","<*const T as std::fmt::Debug>","hir::HirInfo","ast::CaptureName","hir::interval::IntervalSetIter","ast::Position","ast::RepetitionKind","unicode::UnicodeWordError","ast::print::Printer","ast::Group","hir::HirKind","ast::visitor::ClassInduct","utf8::Utf8Sequence","ast::ClassUnicodeKind","either::Either","ast::ClassAscii","ast::Ast","hir::Error","ast::ClassPerlKind","hir::ClassBytes","ast::ClassSetBinaryOpKind","ast::Span","ast::ClassSetBinaryOp"]},"ast::parse::NestLimiter":{"P":["<&T as std::fmt::Debug>","std::ffi::CString","std::ffi::OsString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::string::String","std::rc::Rc<T>","std::boxed::Box<T, A>","std::path::PathBuf"]},"ast::parse::ParserI":{"P":["std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf","std::string::String","std::boxed::Box<T, A>","std::ffi::OsString","std::vec::Vec<T, A>","std::ffi::CString","<&mut T as std::fmt::Debug>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::ClassPerlKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","hir::Anchor","ast::Class","ast::ClassSetRange","hir::ClassUnicodeRange","hir::ClassUnicode","ast::HexLiteralKind","hir::Group","hir::Class","ast::RepetitionOp","hir::GroupKind","ast::FlagsItemKind","ast::ClassPerl","utf8::Utf8Sequence","hir::interval::IntervalSet","ast::Error","ast::ClassSetBinaryOpKind","hir::HirKind","ast::AssertionKind","ast::Alternation","ast::Flag","hir::literal::Literal","hir::RepetitionKind","ast::LiteralKind","ast::SpecialLiteralKind","ast::ClassUnicode","hir::literal::Literals","hir::Error","ast::ClassAsciiKind","utf8::Utf8Range","ast::RepetitionKind","ast::ClassSetUnion","ast::Group","either::Either","hir::Literal","ast::Flags","ast::WithComments","ast::Comment","ast::ClassUnicodeKind","hir::Repetition","ast::ClassAscii","ast::GroupKind","hir::ClassBytesRange","hir::WordBoundary","ast::Position","ast::ClassSet","hir::ClassBytes","ast::ErrorKind","ast::Literal","error::Error","hir::Hir","ast::ClassUnicodeOpKind","ast::Ast","ast::ClassSetBinaryOp","ast::Repetition","ast::ClassBracketed","ast::RepetitionRange","hir::RepetitionRange","ast::SetFlags","ast::FlagsItem","ast::Assertion","ast::parse::Primitive","hir::ErrorKind","ast::ClassSetItem","ast::Concat","hir::HirInfo","ast::CaptureName","ast::Span"],"Right":["ast::FlagsItem","hir::RepetitionKind","ast::Alternation","ast::Ast","ast::parse::Primitive","ast::RepetitionKind","ast::ClassBracketed","hir::Repetition","hir::ErrorKind","ast::AssertionKind","ast::Repetition","ast::ClassAsciiKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::Error","ast::Position","ast::Group","utf8::Utf8Sequence","hir::ClassBytes","ast::SpecialLiteralKind","hir::Anchor","ast::ClassSetItem","utf8::Utf8Range","ast::Assertion","ast::Comment","ast::Class","hir::Literal","ast::LiteralKind","ast::ClassSetBinaryOpKind","hir::GroupKind","hir::literal::Literal","either::Either","hir::ClassBytesRange","ast::ClassSet","ast::FlagsItemKind","ast::WithComments","ast::GroupKind","ast::CaptureName","hir::ClassUnicodeRange","ast::SetFlags","ast::ClassSetBinaryOp","ast::ClassUnicode","ast::Flag","ast::Flags","ast::ClassPerl","ast::ClassUnicodeKind","ast::RepetitionOp","ast::Span","ast::ClassSetRange","hir::Hir","ast::Concat","hir::HirInfo","hir::ClassUnicode","hir::literal::Literals","ast::ClassAscii","error::Error","hir::interval::IntervalSet","ast::RepetitionRange","hir::HirKind","hir::RepetitionRange","hir::Class","ast::ClassPerlKind","ast::ClassSetUnion","ast::ClassUnicodeOpKind","hir::WordBoundary","ast::HexLiteralKind","ast::Literal","hir::Error","ast::ErrorKind","hir::Group"]},"error::Formatter":{"E":["<&T as std::fmt::Debug>","hir::ErrorKind","hir::Error","unicode::CaseFoldError","hir::Hir","ast::ErrorKind","error::Error","ast::Ast","ast::Error","unicode::UnicodeWordError","error::Formatter"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::visitor::ClassInduct","hir::Error","error::Error","ast::GroupKind","ast::FlagsItem","ast::SpecialLiteralKind","ast::parse::ClassState","ast::WithComments","hir::ClassUnicodeIter","hir::translate::TranslatorBuilder","hir::literal::Literal","ast::Error","hir::HirKind","hir::Repetition","ast::parse::NestLimiter","hir::Anchor","hir::interval::IntervalSetIter","hir::GroupKind","ast::AssertionKind","ast::Literal","ast::FlagsItemKind","error::Formatter","hir::translate::TranslatorI","ast::Ast","ast::ClassPerlKind","ast::HexLiteralKind","parser::ParserBuilder","hir::interval::IntervalSet","ast::Concat","hir::Class","hir::Group","ast::ErrorKind","hir::translate::Translator","ast::print::Writer","parser::Parser","ast::ClassBracketed","ast::visitor::ClassFrame","ast::SetFlags","ast::ClassUnicode","hir::literal::Literals","hir::ClassUnicode","ast::Group","ast::ClassSetRange","ast::ClassSetBinaryOp","ast::ClassSetUnion","unicode::CanonicalClassQuery","hir::print::Printer","hir::ClassUnicodeRange","ast::ClassUnicodeKind","utf8::Utf8Sequence","ast::parse::Primitive","ast::Comment","ast::RepetitionOp","ast::CaptureName","hir::translate::Flags","hir::WordBoundary","ast::parse::Parser","ast::ClassSetItem","unicode::ClassQuery","ast::ClassSetBinaryOpKind","ast::Repetition","ast::ClassAscii","ast::Span","hir::Literal","either::Either","ast::print::Printer","<*mut T as std::fmt::Debug>","hir::RepetitionKind","unicode::Error","hir::ClassBytesRange","ast::RepetitionKind","ast::parse::ParserI","ast::ClassPerl","ast::Flag","utf8::ScalarRange","ast::Class","unicode::UnicodeWordError","hir::ClassBytes","unicode::CaseFoldError","hir::print::PrinterBuilder","hir::print::Writer","hir::HirInfo","ast::print::PrinterBuilder","utf8::Utf8Sequences","hir::ErrorKind","ast::parse::ParserBuilder","ast::parse::GroupState","ast::ClassAsciiKind","ast::Position","hir::Hir","ast::Flags","ast::ClassUnicodeOpKind","hir::RepetitionRange","ast::ClassSet","hir::ClassBytesIter","hir::translate::HirFrame","ast::RepetitionRange","ast::Alternation","ast::LiteralKind","ast::Assertion","utf8::Utf8Range"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::ParserI<'s, P>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::GroupState as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::GroupState
+p0.clone();
+<ast::parse::GroupState as std::clone::Clone>::clone(p0);
+crate::<ast::parse::GroupState as std::clone::Clone>::clone(p0);
+<ast::parse::GroupState>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::GroupState as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::GroupState
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::GroupState as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::GroupState as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::GroupState>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ClassState as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ClassState
+p0.clone();
+<ast::parse::ClassState as std::clone::Clone>::clone(p0);
+crate::<ast::parse::ClassState as std::clone::Clone>::clone(p0);
+<ast::parse::ClassState>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ClassState as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ClassState
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::ClassState as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::ClassState as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::ClassState>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Parser::new
deps:{}
candidates:{}
+ast::parse::Parser::new();
+crate::ast::parse::Parser::new();
+<ast::parse::Parser>::new();
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Parser::parse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::Parser
let mut p1 = "sample"; // None+&str
+p0.parse(&p1);
+ast::parse::Parser::parse(p0, &p1);
+crate::ast::parse::Parser::parse(p0, &p1);
+<ast::parse::Parser>::parse(p0, &p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Parser::parse_with_comments
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::Parser
let mut p1 = "sample"; // None+&str
+p0.parse_with_comments(&p1);
+ast::parse::Parser::parse_with_comments(p0, &p1);
+crate::ast::parse::Parser::parse_with_comments(p0, &p1);
+<ast::parse::Parser>::parse_with_comments(p0, &p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Parser::reset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Parser
+p0.reset();
+ast::parse::Parser::reset(p0);
+crate::ast::parse::Parser::reset(p0);
+<ast::parse::Parser>::reset(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::new
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::new":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::new":{"P":["<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::string::String","std::path::PathBuf","std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::OsString","std::vec::Vec<T, A>","std::ffi::CString"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // P
let mut p1 = "sample"; // None+&str
+ast::parse::ParserI::<'s, P>::new(p0, &p1);
+crate::ast::parse::ParserI::<'s, P>::new(p0, &p1);
+<ast::parse::ParserI<'s, P>>::new(p0, &p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parser
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parser":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parser":{"P":["std::path::PathBuf","std::rc::Rc<T>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::ffi::CString","<&T as std::borrow::Borrow<T>>","<T as std::borrow::Borrow<T>>","std::ffi::OsString","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parser();
+ast::parse::ParserI::<'s, P>::parser(p0);
+crate::ast::parse::ParserI::<'s, P>::parser(p0);
+<ast::parse::ParserI<'s, P>>::parser(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pattern
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pattern":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pattern":{"P":["std::string::String","std::boxed::Box<T, A>","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::sync::Arc<T>","std::path::PathBuf","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.pattern();
+ast::parse::ParserI::<'s, P>::pattern(p0);
+crate::ast::parse::ParserI::<'s, P>::pattern(p0);
+<ast::parse::ParserI<'s, P>>::pattern(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::error
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::error":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::error":{"P":["std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::string::String","std::ffi::CString","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.error(p1, p2);
+ast::parse::ParserI::<'s, P>::error(p0, p1, p2);
+crate::ast::parse::ParserI::<'s, P>::error(p0, p1, p2);
+<ast::parse::ParserI<'s, P>>::error(p0, p1, p2);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::offset
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::offset":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::offset":{"P":["std::vec::Vec<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","std::string::String","std::borrow::Cow<'a, B>","std::path::PathBuf","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.offset();
+ast::parse::ParserI::<'s, P>::offset(p0);
+crate::ast::parse::ParserI::<'s, P>::offset(p0);
+<ast::parse::ParserI<'s, P>>::offset(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::line
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::line":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::line":{"P":["std::path::PathBuf","std::vec::Vec<T, A>","std::rc::Rc<T>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.line();
+ast::parse::ParserI::<'s, P>::line(p0);
+crate::ast::parse::ParserI::<'s, P>::line(p0);
+<ast::parse::ParserI<'s, P>>::line(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::column
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::column":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::column":{"P":["std::sync::Arc<T>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::ffi::CString","std::borrow::Cow<'a, B>","std::ffi::OsString","std::path::PathBuf","std::boxed::Box<T, A>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.column();
+ast::parse::ParserI::<'s, P>::column(p0);
+crate::ast::parse::ParserI::<'s, P>::column(p0);
+<ast::parse::ParserI<'s, P>>::column(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::next_capture_index
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::next_capture_index":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::next_capture_index":{"P":["std::ffi::OsString","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::string::String","std::path::PathBuf","std::vec::Vec<T, A>","std::rc::Rc<T>","std::ffi::CString","std::borrow::Cow<'a, B>","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
+p0.next_capture_index(p1);
+ast::parse::ParserI::<'s, P>::next_capture_index(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::next_capture_index(p0, p1);
+<ast::parse::ParserI<'s, P>>::next_capture_index(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::add_capture_name
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::add_capture_name":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::add_capture_name":{"P":["<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::string::String","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","std::path::PathBuf","std::ffi::OsString","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.add_capture_name(p1);
+ast::parse::ParserI::<'s, P>::add_capture_name(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::add_capture_name(p0, p1);
+<ast::parse::ParserI<'s, P>>::add_capture_name(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::ignore_whitespace
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::ignore_whitespace":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::ignore_whitespace":{"P":["<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::sync::Arc<T>","std::string::String","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::ffi::CString","std::ffi::OsString","std::path::PathBuf","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.ignore_whitespace();
+ast::parse::ParserI::<'s, P>::ignore_whitespace(p0);
+crate::ast::parse::ParserI::<'s, P>::ignore_whitespace(p0);
+<ast::parse::ParserI<'s, P>>::ignore_whitespace(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::char
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char":{"P":["<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::ffi::CString","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::ffi::OsString","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::string::String","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.char();
+ast::parse::ParserI::<'s, P>::char(p0);
+crate::ast::parse::ParserI::<'s, P>::char(p0);
+<ast::parse::ParserI<'s, P>>::char(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::char_at
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char_at":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char_at":{"P":["std::path::PathBuf","std::boxed::Box<T, A>","std::sync::Arc<T>","std::ffi::OsString","std::borrow::Cow<'a, B>","std::string::String","std::ffi::CString","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = 0usize; // None+usize
+p0.char_at(p1);
+ast::parse::ParserI::<'s, P>::char_at(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::char_at(p0, p1);
+<ast::parse::ParserI<'s, P>>::char_at(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump":{"P":["<T as std::borrow::Borrow<T>>","std::ffi::OsString","std::sync::Arc<T>","std::ffi::CString","std::vec::Vec<T, A>","std::string::String","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::path::PathBuf","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.bump();
+ast::parse::ParserI::<'s, P>::bump(p0);
+crate::ast::parse::ParserI::<'s, P>::bump(p0);
+<ast::parse::ParserI<'s, P>>::bump(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump_if
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_if":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_if":{"P":["std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::ffi::OsString","std::path::PathBuf","std::rc::Rc<T>","std::string::String","std::vec::Vec<T, A>","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = "sample"; // None+&str
+p0.bump_if(&p1);
+ast::parse::ParserI::<'s, P>::bump_if(p0, &p1);
+crate::ast::parse::ParserI::<'s, P>::bump_if(p0, &p1);
+<ast::parse::ParserI<'s, P>>::bump_if(p0, &p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::is_lookaround_prefix
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":{"P":["std::sync::Arc<T>","std::vec::Vec<T, A>","std::string::String","std::ffi::CString","std::path::PathBuf","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.is_lookaround_prefix();
+ast::parse::ParserI::<'s, P>::is_lookaround_prefix(p0);
+crate::ast::parse::ParserI::<'s, P>::is_lookaround_prefix(p0);
+<ast::parse::ParserI<'s, P>>::is_lookaround_prefix(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump_and_bump_space
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_and_bump_space":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_and_bump_space":{"P":["std::rc::Rc<T>","std::boxed::Box<T, A>","std::string::String","std::ffi::OsString","std::ffi::CString","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.bump_and_bump_space();
+ast::parse::ParserI::<'s, P>::bump_and_bump_space(p0);
+crate::ast::parse::ParserI::<'s, P>::bump_and_bump_space(p0);
+<ast::parse::ParserI<'s, P>>::bump_and_bump_space(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump_space
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_space":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_space":{"P":["std::ffi::CString","std::ffi::OsString","std::path::PathBuf","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::string::String","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.bump_space();
+ast::parse::ParserI::<'s, P>::bump_space(p0);
+crate::ast::parse::ParserI::<'s, P>::bump_space(p0);
+<ast::parse::ParserI<'s, P>>::bump_space(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::peek
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek":{"P":["std::sync::Arc<T>","std::string::String","std::path::PathBuf","std::rc::Rc<T>","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::ffi::OsString","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.peek();
+ast::parse::ParserI::<'s, P>::peek(p0);
+crate::ast::parse::ParserI::<'s, P>::peek(p0);
+<ast::parse::ParserI<'s, P>>::peek(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::peek_space
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek_space":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek_space":{"P":["std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","std::path::PathBuf","std::vec::Vec<T, A>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.peek_space();
+ast::parse::ParserI::<'s, P>::peek_space(p0);
+crate::ast::parse::ParserI::<'s, P>::peek_space(p0);
+<ast::parse::ParserI<'s, P>>::peek_space(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::is_eof
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_eof":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_eof":{"P":["std::vec::Vec<T, A>","std::string::String","std::ffi::CString","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::OsString","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.is_eof();
+ast::parse::ParserI::<'s, P>::is_eof(p0);
+crate::ast::parse::ParserI::<'s, P>::is_eof(p0);
+<ast::parse::ParserI<'s, P>>::is_eof(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pos
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pos":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pos":{"P":["std::ffi::OsString","std::boxed::Box<T, A>","std::sync::Arc<T>","std::ffi::CString","std::vec::Vec<T, A>","std::string::String","std::path::PathBuf","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.pos();
+ast::parse::ParserI::<'s, P>::pos(p0);
+crate::ast::parse::ParserI::<'s, P>::pos(p0);
+<ast::parse::ParserI<'s, P>>::pos(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::span
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span":{"P":["<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::ffi::OsString","std::ffi::CString","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.span();
+ast::parse::ParserI::<'s, P>::span(p0);
+crate::ast::parse::ParserI::<'s, P>::span(p0);
+<ast::parse::ParserI<'s, P>>::span(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::span_char
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span_char":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span_char":{"P":["std::string::String","<T as std::borrow::Borrow<T>>","std::ffi::OsString","std::sync::Arc<T>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::ffi::CString","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.span_char();
+ast::parse::ParserI::<'s, P>::span_char(p0);
+crate::ast::parse::ParserI::<'s, P>::span_char(p0);
+<ast::parse::ParserI<'s, P>>::span_char(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_alternate
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_alternate":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_alternate":{"P":["<&T as std::borrow::Borrow<T>>","<T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::ffi::CString","std::string::String","std::boxed::Box<T, A>","std::ffi::OsString","std::rc::Rc<T>","std::vec::Vec<T, A>","std::path::PathBuf","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.push_alternate(p1);
+ast::parse::ParserI::<'s, P>::push_alternate(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_alternate(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_alternate(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_or_add_alternation
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_or_add_alternation":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_or_add_alternation":{"P":["<T as std::borrow::Borrow<T>>","std::string::String","std::sync::Arc<T>","std::ffi::CString","std::ffi::OsString","std::borrow::Cow<'a, B>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.push_or_add_alternation(p1);
+ast::parse::ParserI::<'s, P>::push_or_add_alternation(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_or_add_alternation(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_or_add_alternation(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_group
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_group":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_group":{"P":["std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::ffi::OsString","std::ffi::CString","std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf","std::borrow::Cow<'a, B>","std::string::String","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.push_group(p1);
+ast::parse::ParserI::<'s, P>::push_group(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_group(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_group(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_group
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group":{"P":["std::sync::Arc<T>","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::boxed::Box<T, A>","std::string::String","std::path::PathBuf","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.pop_group(p1);
+ast::parse::ParserI::<'s, P>::pop_group(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_group(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_group(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_group_end
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group_end":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group_end":{"P":["<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::borrow::Cow<'a, B>","std::string::String","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","std::ffi::OsString","std::boxed::Box<T, A>","std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.pop_group_end(p1);
+ast::parse::ParserI::<'s, P>::pop_group_end(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_group_end(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_group_end(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_class_open
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_open":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_open":{"P":["std::ffi::OsString","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::string::String","<&T as std::borrow::Borrow<T>>","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::sync::Arc<T>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.push_class_open(p1);
+ast::parse::ParserI::<'s, P>::push_class_open(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_class_open(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_class_open(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class":{"P":["std::path::PathBuf","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::OsString","std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::CString","<T as std::borrow::Borrow<T>>","std::string::String","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.pop_class(p1);
+ast::parse::ParserI::<'s, P>::pop_class(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_class(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_class(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::unclosed_class_error
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::unclosed_class_error":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::unclosed_class_error":{"P":["std::boxed::Box<T, A>","std::string::String","std::sync::Arc<T>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::CString","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.unclosed_class_error();
+ast::parse::ParserI::<'s, P>::unclosed_class_error(p0);
+crate::ast::parse::ParserI::<'s, P>::unclosed_class_error(p0);
+<ast::parse::ParserI<'s, P>>::unclosed_class_error(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_class_op
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_op":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_op":{"P":["std::vec::Vec<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::ffi::CString","std::ffi::OsString","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.push_class_op(p1, p2);
+ast::parse::ParserI::<'s, P>::push_class_op(p0, p1, p2);
+crate::ast::parse::ParserI::<'s, P>::push_class_op(p0, p1, p2);
+<ast::parse::ParserI<'s, P>>::push_class_op(p0, p1, p2);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_class_op
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class_op":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class_op":{"P":["std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::string::String","std::path::PathBuf","std::sync::Arc<T>","std::ffi::OsString","<T as std::borrow::Borrow<T>>","std::ffi::CString","std::vec::Vec<T, A>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.pop_class_op(p1);
+ast::parse::ParserI::<'s, P>::pop_class_op(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_class_op(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_class_op(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse":{"P":["std::string::String","std::rc::Rc<T>","std::sync::Arc<T>","std::ffi::CString","std::ffi::OsString","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse();
+ast::parse::ParserI::<'s, P>::parse(p0);
+crate::ast::parse::ParserI::<'s, P>::parse(p0);
+<ast::parse::ParserI<'s, P>>::parse(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_with_comments
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_with_comments":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_with_comments":{"P":["std::borrow::Cow<'a, B>","std::string::String","std::path::PathBuf","std::ffi::OsString","std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::CString","std::vec::Vec<T, A>","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","<&T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_with_comments();
+ast::parse::ParserI::<'s, P>::parse_with_comments(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_with_comments(p0);
+<ast::parse::ParserI<'s, P>>::parse_with_comments(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_uncounted_repetition
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":{"P":["std::string::String","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::CString","std::ffi::OsString","std::borrow::Cow<'a, B>","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.parse_uncounted_repetition(p1, p2);
+ast::parse::ParserI::<'s, P>::parse_uncounted_repetition(p0, p1, p2);
+crate::ast::parse::ParserI::<'s, P>::parse_uncounted_repetition(p0, p1, p2);
+<ast::parse::ParserI<'s, P>>::parse_uncounted_repetition(p0, p1, p2);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_counted_repetition
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_counted_repetition":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_counted_repetition":{"P":["<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::sync::Arc<T>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::ffi::CString","std::string::String","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.parse_counted_repetition(p1);
+ast::parse::ParserI::<'s, P>::parse_counted_repetition(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_counted_repetition(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_counted_repetition(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_group
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_group":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_group":{"P":["std::ffi::OsString","std::ffi::CString","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_group();
+ast::parse::ParserI::<'s, P>::parse_group(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_group(p0);
+<ast::parse::ParserI<'s, P>>::parse_group(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_capture_name
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_capture_name":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_capture_name":{"P":["std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::rc::Rc<T>","std::string::String","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = 0u32; // None+u32
+p0.parse_capture_name(p1);
+ast::parse::ParserI::<'s, P>::parse_capture_name(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_capture_name(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_capture_name(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_flags
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flags":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flags":{"P":["std::vec::Vec<T, A>","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_flags();
+ast::parse::ParserI::<'s, P>::parse_flags(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_flags(p0);
+<ast::parse::ParserI<'s, P>>::parse_flags(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_flag
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flag":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flag":{"P":["std::sync::Arc<T>","std::ffi::OsString","std::ffi::CString","std::borrow::Cow<'a, B>","<&T as std::borrow::Borrow<T>>","std::string::String","std::boxed::Box<T, A>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_flag();
+ast::parse::ParserI::<'s, P>::parse_flag(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_flag(p0);
+<ast::parse::ParserI<'s, P>>::parse_flag(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_primitive
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_primitive":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_primitive":{"P":["std::sync::Arc<T>","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::string::String","std::vec::Vec<T, A>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_primitive();
+ast::parse::ParserI::<'s, P>::parse_primitive(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_primitive(p0);
+<ast::parse::ParserI<'s, P>>::parse_primitive(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_escape
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_escape":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_escape":{"P":["std::rc::Rc<T>","std::string::String","<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::borrow::Cow<'a, B>","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::ffi::CString","std::ffi::OsString","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_escape();
+ast::parse::ParserI::<'s, P>::parse_escape(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_escape(p0);
+<ast::parse::ParserI<'s, P>>::parse_escape(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_octal
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_octal":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_octal":{"P":["std::string::String","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::OsString","std::ffi::CString","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_octal();
+ast::parse::ParserI::<'s, P>::parse_octal(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_octal(p0);
+<ast::parse::ParserI<'s, P>>::parse_octal(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_hex
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex":{"P":["std::boxed::Box<T, A>","std::path::PathBuf","std::ffi::CString","std::rc::Rc<T>","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_hex();
+ast::parse::ParserI::<'s, P>::parse_hex(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_hex(p0);
+<ast::parse::ParserI<'s, P>>::parse_hex(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_hex_digits
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_digits":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_digits":{"P":["std::vec::Vec<T, A>","std::rc::Rc<T>","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::ffi::OsString","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.parse_hex_digits(p1);
+ast::parse::ParserI::<'s, P>::parse_hex_digits(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_hex_digits(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_hex_digits(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_hex_brace
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_brace":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_brace":{"P":["std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::path::PathBuf","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::string::String","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.parse_hex_brace(p1);
+ast::parse::ParserI::<'s, P>::parse_hex_brace(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_hex_brace(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_hex_brace(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_decimal
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_decimal":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_decimal":{"P":["<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::ffi::CString","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::string::String","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_decimal();
+ast::parse::ParserI::<'s, P>::parse_decimal(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_decimal(p0);
+<ast::parse::ParserI<'s, P>>::parse_decimal(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class":{"P":["std::ffi::CString","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class();
+ast::parse::ParserI::<'s, P>::parse_set_class(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class_range
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_range":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_range":{"P":["<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","std::path::PathBuf","std::vec::Vec<T, A>","std::rc::Rc<T>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class_range();
+ast::parse::ParserI::<'s, P>::parse_set_class_range(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class_range(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class_range(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class_item
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_item":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_item":{"P":["<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::OsString","std::vec::Vec<T, A>","std::ffi::CString","std::boxed::Box<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::string::String","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class_item();
+ast::parse::ParserI::<'s, P>::parse_set_class_item(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class_item(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class_item(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class_open
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_open":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_open":{"P":["<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::ffi::OsString","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::string::String","std::rc::Rc<T>","std::boxed::Box<T, A>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class_open();
+ast::parse::ParserI::<'s, P>::parse_set_class_open(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class_open(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class_open(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":{"P":["std::string::String","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::path::PathBuf","std::rc::Rc<T>","std::ffi::CString","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.maybe_parse_ascii_class();
+ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class(p0);
+crate::ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class(p0);
+<ast::parse::ParserI<'s, P>>::maybe_parse_ascii_class(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_unicode_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_unicode_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_unicode_class":{"P":["std::ffi::OsString","std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::string::String","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_unicode_class();
+ast::parse::ParserI::<'s, P>::parse_unicode_class(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_unicode_class(p0);
+<ast::parse::ParserI<'s, P>>::parse_unicode_class(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_perl_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_perl_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_perl_class":{"P":["std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::string::String","std::path::PathBuf","std::rc::Rc<T>","std::ffi::CString","std::boxed::Box<T, A>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_perl_class();
+ast::parse::ParserI::<'s, P>::parse_perl_class(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_perl_class(p0);
+<ast::parse::ParserI<'s, P>>::parse_perl_class(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt":{"P":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"either::Either":{"Left":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"],"Right":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["hir::interval::Interval","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt":{"P":["ast::ClassPerlKind","hir::translate::Flags","ast::Comment","hir::print::Printer","ast::ClassUnicode","ast::print::PrinterBuilder","hir::ClassUnicodeIter","ast::Literal","ast::Ast","ast::visitor::ClassInduct","ast::ClassSetRange","<*mut T as std::fmt::Debug>","hir::Group","ast::Span","hir::Hir","hir::RepetitionRange","ast::ClassPerl","ast::SetFlags","hir::translate::Translator","hir::translate::TranslatorI","unicode::ClassQuery","ast::parse::Primitive","ast::ClassAsciiKind","ast::parse::ParserI","ast::ClassUnicodeKind","hir::GroupKind","ast::parse::Parser","ast::ClassSetItem","ast::Alternation","hir::WordBoundary","utf8::Utf8Sequences","ast::Flags","ast::WithComments","hir::ClassUnicode","unicode::Error","ast::GroupKind","ast::parse::ClassState","hir::ClassUnicodeRange","parser::Parser","ast::ClassUnicodeOpKind","hir::translate::TranslatorBuilder","ast::RepetitionKind","ast::RepetitionRange","hir::ErrorKind","ast::Group","unicode::UnicodeWordError","ast::HexLiteralKind","ast::ClassAscii","hir::Literal","hir::Class","ast::parse::NestLimiter","ast::CaptureName","utf8::ScalarRange","hir::translate::HirFrame","ast::Class","hir::Repetition","error::Error","hir::ClassBytes","ast::Concat","unicode::CanonicalClassQuery","hir::HirKind","hir::print::PrinterBuilder","hir::interval::IntervalSetIter","ast::Assertion","ast::ClassSetUnion","ast::Error","ast::ClassSetBinaryOp","ast::parse::ParserBuilder","ast::visitor::ClassFrame","error::Formatter","hir::RepetitionKind","hir::literal::Literals","ast::ClassBracketed","hir::interval::IntervalSet","hir::print::Writer","ast::ClassSet","hir::ClassBytesIter","parser::ParserBuilder","ast::SpecialLiteralKind","either::Either","ast::Flag","ast::print::Writer","ast::FlagsItem","hir::Anchor","ast::Repetition","ast::LiteralKind","ast::FlagsItemKind","unicode::CaseFoldError","hir::HirInfo","ast::Position","utf8::Utf8Range","utf8::Utf8Sequence","ast::ClassSetBinaryOpKind","ast::ErrorKind","ast::AssertionKind","hir::ClassBytesRange","ast::print::Printer","hir::literal::Literal","ast::RepetitionOp","hir::Error","ast::parse::GroupState"]},"ast::parse::NestLimiter":{"P":["std::rc::Rc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::string::String","std::ffi::OsString","std::path::PathBuf","<&T as std::fmt::Debug>","std::ffi::CString"]},"ast::parse::ParserI":{"P":["std::ffi::CString","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","std::path::PathBuf","std::vec::Vec<T, A>","std::string::String","std::sync::Arc<T>","std::boxed::Box<T, A>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::ClassSetItem","utf8::Utf8Range","ast::ClassSet","ast::ClassSetBinaryOp","hir::Repetition","hir::HirKind","hir::HirInfo","ast::SpecialLiteralKind","ast::ClassUnicode","ast::CaptureName","hir::RepetitionKind","ast::Group","ast::ClassSetUnion","hir::ClassUnicode","ast::HexLiteralKind","hir::Hir","ast::Span","ast::ClassPerl","ast::ClassSetBinaryOpKind","ast::ClassPerlKind","hir::ClassBytesRange","ast::Position","hir::ClassBytes","hir::Error","hir::literal::Literals","hir::ClassUnicodeRange","ast::Concat","ast::RepetitionRange","ast::Ast","hir::Anchor","ast::ClassSetRange","ast::ClassAsciiKind","ast::Error","ast::FlagsItemKind","ast::ClassUnicodeOpKind","hir::GroupKind","ast::parse::Primitive","ast::Alternation","ast::Flags","ast::Comment","ast::SetFlags","either::Either","ast::Assertion","ast::GroupKind","ast::RepetitionKind","hir::WordBoundary","ast::Literal","ast::Flag","ast::WithComments","ast::Repetition","error::Error","ast::ClassAscii","ast::ClassUnicodeKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","hir::Literal","ast::AssertionKind","hir::Group","utf8::Utf8Sequence","hir::RepetitionRange","hir::ErrorKind","hir::Class","hir::interval::IntervalSet","ast::FlagsItem","ast::ClassBracketed","ast::Class","hir::literal::Literal","ast::RepetitionOp","ast::LiteralKind","ast::ErrorKind"],"Right":["ast::Group","hir::literal::Literal","ast::ClassSet","ast::Flags","hir::ClassBytes","utf8::Utf8Sequence","ast::LiteralKind","hir::Literal","ast::ErrorKind","hir::Repetition","hir::ClassUnicode","hir::RepetitionRange","hir::literal::Literals","ast::Ast","hir::RepetitionKind","ast::ClassAsciiKind","ast::Span","error::Error","hir::Error","hir::Hir","ast::SpecialLiteralKind","hir::Group","ast::Class","ast::ClassBracketed","ast::ClassUnicodeKind","ast::RepetitionKind","ast::Assertion","ast::ClassSetRange","either::Either","ast::ClassUnicodeOpKind","ast::Repetition","std::clone::impls::<impl std::clone::Clone for *mut T>","hir::Anchor","hir::ErrorKind","ast::Literal","hir::ClassUnicodeRange","hir::WordBoundary","ast::FlagsItem","ast::ClassPerl","ast::Position","ast::ClassUnicode","ast::Concat","hir::GroupKind","ast::ClassAscii","ast::GroupKind","ast::ClassSetBinaryOpKind","ast::Error","ast::AssertionKind","ast::Alternation","ast::ClassSetItem","utf8::Utf8Range","ast::Flag","ast::HexLiteralKind","hir::interval::IntervalSet","ast::ClassSetBinaryOp","hir::ClassBytesRange","ast::RepetitionRange","ast::parse::Primitive","ast::ClassSetUnion","hir::HirInfo","hir::HirKind","ast::WithComments","ast::FlagsItemKind","ast::CaptureName","ast::ClassPerlKind","hir::Class","ast::RepetitionOp","ast::SetFlags","ast::Comment"]},"error::Formatter":{"E":["ast::Ast","hir::Hir","ast::Error","hir::Error","<&T as std::fmt::Debug>","hir::ErrorKind","error::Formatter","error::Error","unicode::UnicodeWordError","unicode::CaseFoldError","ast::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::Ast","error::Error","ast::parse::ParserBuilder","hir::ClassUnicode","hir::Group","ast::visitor::ClassInduct","ast::ClassAsciiKind","ast::ClassSetItem","unicode::CaseFoldError","ast::ClassUnicode","utf8::Utf8Sequence","hir::ClassBytesIter","ast::ClassSetBinaryOpKind","hir::literal::Literal","hir::print::Writer","ast::Flag","hir::HirKind","ast::Group","ast::parse::ParserI","hir::interval::IntervalSetIter","ast::Concat","ast::ClassBracketed","ast::ClassSetUnion","ast::FlagsItemKind","ast::ClassSetRange","hir::RepetitionRange","ast::Position","ast::RepetitionRange","unicode::Error","ast::Error","ast::Class","hir::translate::Translator","hir::WordBoundary","ast::Flags","hir::translate::Flags","ast::parse::Parser","unicode::CanonicalClassQuery","ast::parse::ClassState","ast::ClassPerl","ast::WithComments","hir::ClassBytes","ast::RepetitionKind","parser::ParserBuilder","ast::SetFlags","ast::visitor::ClassFrame","hir::translate::TranslatorBuilder","ast::AssertionKind","hir::Error","hir::literal::Literals","ast::ClassUnicodeOpKind","hir::translate::TranslatorI","ast::LiteralKind","ast::SpecialLiteralKind","ast::Literal","hir::print::PrinterBuilder","hir::ClassUnicodeRange","hir::Anchor","ast::print::Printer","hir::translate::HirFrame","hir::ClassUnicodeIter","either::Either","ast::ClassPerlKind","ast::ErrorKind","ast::RepetitionOp","ast::ClassSet","ast::Assertion","ast::print::Writer","ast::print::PrinterBuilder","hir::RepetitionKind","hir::HirInfo","parser::Parser","ast::FlagsItem","hir::GroupKind","ast::GroupKind","ast::HexLiteralKind","hir::Repetition","ast::ClassUnicodeKind","hir::print::Printer","unicode::ClassQuery","ast::ClassSetBinaryOp","hir::Class","ast::Alternation","unicode::UnicodeWordError","ast::parse::NestLimiter","hir::interval::IntervalSet","ast::Repetition","ast::parse::Primitive","ast::CaptureName","hir::ClassBytesRange","hir::Literal","<*const T as std::fmt::Debug>","utf8::Utf8Sequences","hir::Hir","hir::ErrorKind","ast::ClassAscii","ast::Comment","ast::parse::GroupState","utf8::Utf8Range","utf8::ScalarRange","error::Formatter","ast::Span"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::new
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::new":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::new":{"P":["std::sync::Arc<T>","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","std::rc::Rc<T>","std::vec::Vec<T, A>","std::ffi::CString","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","<&mut T as std::borrow::Borrow<T>>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+ast::parse::NestLimiter::<'p, 's, P>::new(p0);
+crate::ast::parse::NestLimiter::<'p, 's, P>::new(p0);
+<ast::parse::NestLimiter<'p, 's, P>>::new(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::check
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::check":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::check":{"P":["std::sync::Arc<T>","std::boxed::Box<T, A>","std::string::String","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::ffi::OsString","<T as std::borrow::Borrow<T>>","std::ffi::CString","std::vec::Vec<T, A>","std::path::PathBuf"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.check(p1);
+ast::parse::NestLimiter::<'p, 's, P>::check(p0, p1);
+crate::ast::parse::NestLimiter::<'p, 's, P>::check(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::check(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::increment_depth
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":{"P":["std::sync::Arc<T>","std::path::PathBuf","std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::string::String","std::borrow::Cow<'a, B>","std::ffi::CString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.increment_depth(p1);
+ast::parse::NestLimiter::<'p, 's, P>::increment_depth(p0, p1);
+crate::ast::parse::NestLimiter::<'p, 's, P>::increment_depth(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::increment_depth(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::decrement_depth
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":{"P":["<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::ffi::OsString","std::rc::Rc<T>","std::ffi::CString","std::borrow::Cow<'a, B>","std::string::String","std::path::PathBuf","std::boxed::Box<T, A>","std::vec::Vec<T, A>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
+p0.decrement_depth();
+ast::parse::NestLimiter::<'p, 's, P>::decrement_depth(p0);
+crate::ast::parse::NestLimiter::<'p, 's, P>::decrement_depth(p0);
+<ast::parse::NestLimiter<'p, 's, P>>::decrement_depth(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":{"P":["std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String","std::vec::Vec<T, A>","std::ffi::CString","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::path::PathBuf"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
+p0.finish();
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish(p0);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish(p0);
+<ast::parse::NestLimiter<'p, 's, P>>::finish(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":{"P":["std::borrow::Cow<'a, B>","std::ffi::CString","std::boxed::Box<T, A>","std::ffi::OsString","std::sync::Arc<T>","std::rc::Rc<T>","std::string::String","std::path::PathBuf","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_pre(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":{"P":["std::string::String","std::ffi::OsString","std::sync::Arc<T>","std::rc::Rc<T>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::ffi::CString","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_post(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":{"P":["std::vec::Vec<T, A>","std::ffi::CString","std::string::String","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::OsString","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_item_pre(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":{"P":["<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::OsString","<T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::CString","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_item_post(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":{"P":["std::path::PathBuf","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::ffi::OsString","std::ffi::CString","<T as std::borrow::Borrow<T>>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_pre(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_binary_op_pre(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":{"P":["std::ffi::CString","std::path::PathBuf","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::string::String","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::rc::Rc<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_post(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_binary_op_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::PrinterBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::PrinterBuilder
+p0.clone();
+<ast::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+crate::<ast::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+<ast::print::PrinterBuilder>::clone(p0);
-----------------
regex-syntax/src/ast/print.rs <ast::print::PrinterBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::PrinterBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+<ast::print::PrinterBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::PrinterBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<ast::print::PrinterBuilder as std::default::Default>::default();
+crate::<ast::print::PrinterBuilder as std::default::Default>::default();
+<ast::print::PrinterBuilder>::default();
-----------------
regex-syntax/src/ast/print.rs ast::print::PrinterBuilder::new
deps:{}
candidates:{}
+ast::print::PrinterBuilder::new();
+crate::ast::print::PrinterBuilder::new();
+<ast::print::PrinterBuilder>::new();
-----------------
regex-syntax/src/ast/print.rs ast::print::PrinterBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::PrinterBuilder
+p0.build();
+ast::print::PrinterBuilder::build(p0);
+crate::ast::print::PrinterBuilder::build(p0);
+<ast::print::PrinterBuilder>::build(p0);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Printer as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::Printer
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+<ast::print::Printer>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Printer::new
deps:{}
candidates:{}
+ast::print::Printer::new();
+crate::ast::print::Printer::new();
+<ast::print::Printer>::new();
-----------------
regex-syntax/src/ast/print.rs ast::print::Printer::print
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Printer::print":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Printer::print":{"W":["std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::ffi::OsString","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Printer
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p2 = MaybeUninit::uninit().assume_init(); // W
+p0.print(p1, p2);
+ast::print::Printer::print(p0, p1, p2);
+crate::ast::print::Printer::print(p0, p1, p2);
+<ast::print::Printer>::print(p0, p1, p2);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as std::fmt::Debug>::fmt
'p
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::print::Writer<'p, W> as std::fmt::Debug>::fmt":{"W":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::clone::Clone","std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"],"Right":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::cmp::PartialEq","std::clone::Clone","hir::interval::Interval","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::print::Writer<'p, W> as std::fmt::Debug>::fmt":{"W":["ast::ClassUnicodeKind","ast::Span","ast::ClassSetUnion","ast::RepetitionOp","ast::ClassUnicode","hir::interval::IntervalSet","ast::Assertion","hir::Literal","hir::ClassBytesRange","ast::ErrorKind","ast::Flag","ast::WithComments","ast::Group","ast::ClassBracketed","hir::print::Writer","ast::parse::ParserBuilder","ast::FlagsItem","utf8::Utf8Range","ast::ClassSet","unicode::UnicodeWordError","ast::RepetitionKind","hir::translate::TranslatorBuilder","ast::FlagsItemKind","ast::GroupKind","ast::parse::NestLimiter","hir::print::PrinterBuilder","ast::Position","ast::Flags","ast::parse::Parser","ast::visitor::ClassFrame","unicode::CanonicalClassQuery","ast::visitor::ClassInduct","unicode::Error","ast::HexLiteralKind","hir::ClassBytesIter","ast::ClassUnicodeOpKind","either::Either","hir::ClassBytes","parser::Parser","hir::ClassUnicode","<*const T as std::fmt::Debug>","hir::Error","hir::HirInfo","hir::translate::Flags","hir::Group","ast::parse::GroupState","ast::Alternation","ast::SetFlags","hir::ClassUnicodeIter","hir::ErrorKind","ast::Repetition","hir::literal::Literal","utf8::Utf8Sequence","ast::Ast","ast::print::Printer","hir::translate::Translator","ast::ClassSetRange","<&T as std::fmt::Debug>","hir::literal::Literals","unicode::ClassQuery","ast::ClassSetItem","error::Error","hir::HirKind","ast::print::Writer","utf8::ScalarRange","error::Formatter","hir::print::Printer","ast::ClassPerlKind","unicode::CaseFoldError","ast::SpecialLiteralKind","parser::ParserBuilder","hir::interval::IntervalSetIter","hir::Anchor","ast::CaptureName","ast::parse::Primitive","ast::Concat","ast::AssertionKind","hir::Repetition","ast::ClassSetBinaryOp","ast::Class","ast::Comment","hir::RepetitionRange","hir::WordBoundary","ast::ClassSetBinaryOpKind","ast::Error","hir::ClassUnicodeRange","ast::parse::ParserI","ast::ClassAscii","utf8::Utf8Sequences","ast::Literal","hir::GroupKind","hir::Class","ast::print::PrinterBuilder","hir::RepetitionKind","hir::Hir","hir::translate::HirFrame","ast::parse::ClassState","ast::LiteralKind","ast::ClassAsciiKind","ast::RepetitionRange","ast::ClassPerl","hir::translate::TranslatorI"]},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::vec::Vec<T, A>","std::rc::Rc<T>","std::path::PathBuf","std::ffi::CString","std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String","<&mut T as std::fmt::Debug>"]},"ast::parse::ParserI":{"P":["std::ffi::CString","std::string::String","std::path::PathBuf","std::clone::impls::<impl std::clone::Clone for &T>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::OsString","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["hir::RepetitionKind","hir::ClassUnicode","ast::LiteralKind","hir::literal::Literals","hir::GroupKind","ast::ClassSet","hir::RepetitionRange","error::Error","ast::AssertionKind","hir::Repetition","hir::ClassUnicodeRange","hir::Class","ast::ClassSetRange","ast::GroupKind","ast::Literal","ast::ClassPerl","ast::Repetition","ast::parse::Primitive","ast::ClassPerlKind","ast::Group","<*mut T as std::fmt::Debug>","hir::WordBoundary","ast::ClassBracketed","ast::ClassSetUnion","ast::RepetitionOp","ast::ClassUnicodeOpKind","ast::ClassAscii","ast::FlagsItemKind","ast::SpecialLiteralKind","utf8::Utf8Sequence","ast::HexLiteralKind","hir::Group","ast::RepetitionKind","hir::ClassBytesRange","ast::ClassSetBinaryOpKind","ast::Ast","ast::Concat","ast::SetFlags","ast::ClassAsciiKind","hir::ErrorKind","hir::Literal","ast::ErrorKind","ast::Span","ast::WithComments","ast::RepetitionRange","ast::Comment","ast::ClassUnicode","ast::ClassSetBinaryOp","ast::Class","hir::ClassBytes","hir::HirInfo","ast::Assertion","hir::literal::Literal","ast::Error","hir::Hir","ast::Flags","hir::interval::IntervalSet","either::Either","ast::ClassSetItem","ast::ClassUnicodeKind","hir::Error","ast::CaptureName","hir::Anchor","ast::Alternation","ast::Flag","hir::HirKind","ast::Position","ast::FlagsItem","utf8::Utf8Range"],"Right":["hir::HirInfo","ast::Comment","ast::ClassUnicodeOpKind","ast::RepetitionKind","ast::ClassSetUnion","ast::Class","hir::literal::Literals","hir::ClassUnicodeRange","ast::SetFlags","utf8::Utf8Range","ast::Repetition","ast::ClassSetItem","ast::LiteralKind","utf8::Utf8Sequence","either::Either","ast::ClassSet","hir::GroupKind","hir::ClassBytes","hir::WordBoundary","ast::Alternation","hir::Literal","ast::Assertion","ast::Flags","ast::Literal","hir::interval::IntervalSet","hir::Group","ast::HexLiteralKind","hir::Hir","ast::Group","ast::ClassUnicode","ast::ErrorKind","hir::ClassBytesRange","ast::Position","hir::RepetitionKind","ast::ClassPerlKind","ast::RepetitionOp","ast::FlagsItem","ast::Error","ast::SpecialLiteralKind","hir::Repetition","hir::ErrorKind","ast::Span","hir::RepetitionRange","ast::WithComments","ast::ClassAsciiKind","hir::Class","ast::AssertionKind","ast::ClassAscii","ast::ClassSetRange","ast::ClassSetBinaryOpKind","error::Error","hir::literal::Literal","ast::Ast","ast::ClassUnicodeKind","ast::FlagsItemKind","ast::Concat","ast::RepetitionRange","hir::Anchor","ast::GroupKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","hir::ClassUnicode","ast::parse::Primitive","ast::ClassPerl","ast::Flag","hir::HirKind","ast::ClassBracketed","hir::Error","ast::ClassSetBinaryOp","ast::CaptureName"]},"error::Formatter":{"E":["error::Formatter","error::Error","hir::ErrorKind","hir::Error","unicode::CaseFoldError","unicode::UnicodeWordError","ast::ErrorKind","ast::Ast","ast::Error","<&T as std::fmt::Debug>","hir::Hir"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::parse::ParserI","ast::HexLiteralKind","ast::ClassPerl","ast::Alternation","hir::translate::TranslatorBuilder","ast::SetFlags","ast::LiteralKind","hir::ClassUnicodeIter","ast::ClassAscii","ast::print::Printer","ast::print::Writer","ast::ClassUnicode","hir::Class","ast::parse::Primitive","ast::RepetitionRange","hir::print::PrinterBuilder","ast::Literal","ast::Concat","error::Formatter","ast::ClassSetBinaryOp","ast::ClassBracketed","ast::parse::NestLimiter","hir::RepetitionRange","either::Either","unicode::UnicodeWordError","hir::interval::IntervalSetIter","hir::HirKind","hir::HirInfo","utf8::Utf8Sequence","hir::ClassUnicodeRange","ast::Class","ast::ClassSetRange","ast::ClassSetItem","hir::ClassBytesIter","ast::FlagsItemKind","hir::ErrorKind","ast::RepetitionOp","hir::translate::TranslatorI","hir::print::Writer","hir::Repetition","ast::Assertion","ast::Flags","hir::Literal","unicode::CanonicalClassQuery","ast::parse::Parser","parser::Parser","ast::Ast","hir::literal::Literal","utf8::Utf8Range","ast::Comment","utf8::Utf8Sequences","hir::translate::Translator","hir::Error","ast::WithComments","ast::Error","ast::SpecialLiteralKind","ast::GroupKind","ast::parse::GroupState","hir::translate::Flags","ast::ErrorKind","hir::ClassBytesRange","hir::GroupKind","ast::parse::ClassState","ast::visitor::ClassFrame","hir::Anchor","hir::Hir","ast::RepetitionKind","hir::translate::HirFrame","ast::FlagsItem","hir::RepetitionKind","ast::ClassUnicodeOpKind","ast::ClassSet","hir::print::Printer","<&T as std::fmt::Debug>","ast::AssertionKind","ast::parse::ParserBuilder","ast::Group","hir::Group","hir::WordBoundary","ast::ClassSetBinaryOpKind","utf8::ScalarRange","parser::ParserBuilder","ast::CaptureName","hir::ClassBytes","error::Error","ast::ClassAsciiKind","unicode::CaseFoldError","unicode::ClassQuery","ast::Span","hir::ClassUnicode","ast::ClassSetUnion","ast::visitor::ClassInduct","hir::literal::Literals","ast::Repetition","ast::Position","ast::ClassPerlKind","ast::print::PrinterBuilder","hir::interval::IntervalSet","unicode::Error","ast::ClassUnicodeKind","ast::Flag"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::print::Writer<'p, W> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::print::Writer<'p, W> as std::fmt::Debug>::fmt(p0, p1);
+<ast::print::Writer<'p, W>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::ffi::OsString","std::fmt::Formatter<'_>","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
+p0.finish();
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish(p0);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish(p0);
+<ast::print::Writer<'p, W>>::finish(p0);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre":{"W":["std::ffi::OsString","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>","std::string::String","std::net::display_buffer::DisplayBuffer<SIZE>","std::io::Write::write_fmt::Adapter<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre(p0, p1);
+<ast::print::Writer<'p, W>>::visit_pre(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::fmt::Formatter<'_>","std::ffi::OsString","std::string::String","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post(p0, p1);
+<ast::print::Writer<'p, W>>::visit_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in":{"W":["std::error::Indented<'_, T>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
+p0.visit_alternation_in();
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in(p0);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in(p0);
+<ast::print::Writer<'p, W>>::visit_alternation_in(p0);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre":{"W":["std::ffi::OsString","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>","std::string::String","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+<ast::print::Writer<'p, W>>::visit_class_set_item_pre(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>","std::error::Indented<'_, T>","std::ffi::OsString","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+<ast::print::Writer<'p, W>>::visit_class_set_item_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":{"W":["std::fmt::Formatter<'_>","std::ffi::OsString","std::error::Indented<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","<&mut W as std::fmt::Write>","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_in(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+<ast::print::Writer<'p, W>>::visit_class_set_binary_op_in(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_group_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_group_pre":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_group_pre":{"W":["std::string::String","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.fmt_group_pre(p1);
+ast::print::Writer::<'p, W>::fmt_group_pre(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_group_pre(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_group_pre(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_group_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_group_post":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_group_post":{"W":["std::error::Indented<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","std::string::String","std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.fmt_group_post(p1);
+ast::print::Writer::<'p, W>::fmt_group_post(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_group_post(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_group_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_repetition
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_repetition":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_repetition":{"W":["<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::fmt::Formatter<'_>","std::string::String","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.fmt_repetition(p1);
+ast::print::Writer::<'p, W>::fmt_repetition(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_repetition(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_repetition(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_repetition_range
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_repetition_range":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_repetition_range":{"W":["<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::error::Indented<'_, T>","std::fmt::Formatter<'_>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.fmt_repetition_range(p1);
+ast::print::Writer::<'p, W>::fmt_repetition_range(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_repetition_range(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_repetition_range(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_literal
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_literal":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_literal":{"W":["<&mut W as std::fmt::Write>","std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","std::ffi::OsString","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.fmt_literal(p1);
+ast::print::Writer::<'p, W>::fmt_literal(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_literal(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_literal(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_assertion
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_assertion":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_assertion":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::string::String","std::fmt::Formatter<'_>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.fmt_assertion(p1);
+ast::print::Writer::<'p, W>::fmt_assertion(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_assertion(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_assertion(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_set_flags
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_set_flags":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_set_flags":{"W":["std::error::Indented<'_, T>","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.fmt_set_flags(p1);
+ast::print::Writer::<'p, W>::fmt_set_flags(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_set_flags(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_set_flags(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_flags
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_flags":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_flags":{"W":["std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.fmt_flags(p1);
+ast::print::Writer::<'p, W>::fmt_flags(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_flags(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_flags(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_bracketed_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_bracketed_pre":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_bracketed_pre":{"W":["std::fmt::Formatter<'_>","std::error::Indented<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::string::String","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.fmt_class_bracketed_pre(p1);
+ast::print::Writer::<'p, W>::fmt_class_bracketed_pre(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_bracketed_pre(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_bracketed_pre(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_bracketed_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_bracketed_post":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_bracketed_post":{"W":["std::fmt::Formatter<'_>","std::ffi::OsString","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.fmt_class_bracketed_post(p1);
+ast::print::Writer::<'p, W>::fmt_class_bracketed_post(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_bracketed_post(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_bracketed_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind":{"W":["<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.fmt_class_set_binary_op_kind(p1);
+ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_set_binary_op_kind(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_perl
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_perl":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_perl":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>","std::ffi::OsString","std::string::String","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.fmt_class_perl(p1);
+ast::print::Writer::<'p, W>::fmt_class_perl(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_perl(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_perl(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_ascii
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_ascii":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_ascii":{"W":["core::fmt::builders::PadAdapter<'_, '_>","std::string::String","std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.fmt_class_ascii(p1);
+ast::print::Writer::<'p, W>::fmt_class_ascii(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_ascii(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_ascii(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_unicode
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_unicode":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_unicode":{"W":["std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.fmt_class_unicode(p1);
+ast::print::Writer::<'p, W>::fmt_class_unicode(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_unicode(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_unicode(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::new
'a
deps:{}
candidates:{}
+ast::visitor::HeapVisitor::<'a>::new();
+crate::ast::visitor::HeapVisitor::<'a>::new();
+<ast::visitor::HeapVisitor<'a>>::new();
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::HeapVisitor::<'a>::visit":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::ffi::CString","std::ffi::OsString","std::rc::Rc<T>","std::string::String","std::path::PathBuf","<&T as std::fmt::Debug>","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::HeapVisitor::<'a>::visit":{"V":["hir::translate::TranslatorI","ast::parse::NestLimiter","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.visit(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::induct
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"ast::visitor::HeapVisitor::<'a>::induct":{"V":["ast::visitor::Visitor","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::string::String","std::path::PathBuf","std::sync::Arc<T>","std::ffi::CString","std::boxed::Box<T, A>","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::HeapVisitor::<'a>::induct":{"V":["hir::translate::TranslatorI","ast::parse::NestLimiter","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.induct(p1, p2);
+ast::visitor::HeapVisitor::<'a>::induct(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::induct(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::induct(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::pop
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::visitor::Frame<'a>
+p0.pop(p1);
+ast::visitor::HeapVisitor::<'a>::pop(p0, p1);
+crate::ast::visitor::HeapVisitor::<'a>::pop(p0, p1);
+<ast::visitor::HeapVisitor<'a>>::pop(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit_class
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"ast::visitor::HeapVisitor::<'a>::visit_class":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","std::string::String","<&T as std::fmt::Debug>","std::rc::Rc<T>","std::ffi::OsString","std::sync::Arc<T>","std::vec::Vec<T, A>","std::path::PathBuf","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::HeapVisitor::<'a>::visit_class":{"V":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.visit_class(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit_class(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit_class(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit_class(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit_class_pre
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::HeapVisitor::<'a>::visit_class_pre":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::rc::Rc<T>","std::path::PathBuf","std::sync::Arc<T>","std::ffi::CString","std::string::String","std::boxed::Box<T, A>","std::ffi::OsString","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::HeapVisitor::<'a>::visit_class_pre":{"V":["hir::translate::TranslatorI","ast::parse::NestLimiter","ast::print::Writer"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.visit_class_pre(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit_class_pre(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit_class_pre(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit_class_pre(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit_class_post
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::HeapVisitor::<'a>::visit_class_post":{"V":["ast::visitor::Visitor","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::OsString","std::rc::Rc<T>","std::string::String","<&T as std::fmt::Debug>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::HeapVisitor::<'a>::visit_class_post":{"V":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.visit_class_post(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit_class_post(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit_class_post(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit_class_post(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::induct_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
+p0.induct_class(p1);
+ast::visitor::HeapVisitor::<'a>::induct_class(p0, p1);
+crate::ast::visitor::HeapVisitor::<'a>::induct_class(p0, p1);
+<ast::visitor::HeapVisitor<'a>>::induct_class(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::pop_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::visitor::ClassFrame<'a>
+p0.pop_class(p1);
+ast::visitor::HeapVisitor::<'a>::pop_class(p0, p1);
+crate::ast::visitor::HeapVisitor::<'a>::pop_class(p0, p1);
+<ast::visitor::HeapVisitor<'a>>::pop_class(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Frame::<'a>::child
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::Frame<'a>
+p0.child();
+ast::visitor::Frame::<'a>::child(p0);
+crate::ast::visitor::Frame::<'a>::child(p0);
+<ast::visitor::Frame<'a>>::child(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::ClassFrame::<'a>::child
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassFrame<'a>
+p0.child();
+ast::visitor::ClassFrame::<'a>::child(p0);
+crate::ast::visitor::ClassFrame::<'a>::child(p0);
+<ast::visitor::ClassFrame<'a>>::child(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::ClassInduct::<'a>::from_bracketed
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+ast::visitor::ClassInduct::<'a>::from_bracketed(p0);
+crate::ast::visitor::ClassInduct::<'a>::from_bracketed(p0);
+<ast::visitor::ClassInduct<'a>>::from_bracketed(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::ClassInduct::<'a>::from_set
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+ast::visitor::ClassInduct::<'a>::from_set(p0);
+crate::ast::visitor::ClassInduct::<'a>::from_set(p0);
+<ast::visitor::ClassInduct<'a>>::from_set(p0);
-----------------
regex-syntax/src/ast/visitor.rs <ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassFrame<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt(p0, p1);
+<ast::visitor::ClassFrame<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs <ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt(p0, p1);
+<ast::visitor::ClassInduct<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.clone();
+<ast::Error as std::clone::Clone>::clone(p0);
+crate::<ast::Error as std::clone::Clone>::clone(p0);
+<ast::Error>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Error as std::fmt::Debug>::fmt(p0, p1);
+<ast::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.assert_receiver_is_total_eq();
+<ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Error>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.eq(p1);
+<ast::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Error as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Error>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Error::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.kind();
+ast::Error::kind(p0);
+crate::ast::Error::kind(p0);
+<ast::Error>::kind(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Error::pattern
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.pattern();
+ast::Error::pattern(p0);
+crate::ast::Error::pattern(p0);
+<ast::Error>::pattern(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Error::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.span();
+ast::Error::span(p0);
+crate::ast::Error::span(p0);
+<ast::Error>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Error::auxiliary_span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.auxiliary_span();
+ast::Error::auxiliary_span(p0);
+crate::ast::Error::auxiliary_span(p0);
+<ast::Error>::auxiliary_span(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.clone();
+<ast::ErrorKind as std::clone::Clone>::clone(p0);
+crate::<ast::ErrorKind as std::clone::Clone>::clone(p0);
+<ast::ErrorKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ErrorKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.assert_receiver_is_total_eq();
+<ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.eq(p1);
+<ast::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ErrorKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.description();
+<ast::Error as std::error::Error>::description(p0);
+crate::<ast::Error as std::error::Error>::description(p0);
+<ast::Error>::description(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ast::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<ast::Error as std::fmt::Display>::fmt(p0, p1);
+<ast::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ast::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+crate::<ast::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+<ast::ErrorKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.clone();
+<ast::Span as std::clone::Clone>::clone(p0);
+crate::<ast::Span as std::clone::Clone>::clone(p0);
+<ast::Span>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.assert_receiver_is_total_eq();
+<ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Span>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.eq(p1);
+<ast::Span as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Span as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Span>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Span as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Span as std::fmt::Debug>::fmt(p0, p1);
+<ast::Span>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.cmp(p1);
+<ast::Span as std::cmp::Ord>::cmp(p0, p1);
+crate::<ast::Span as std::cmp::Ord>::cmp(p0, p1);
+<ast::Span>::cmp(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.partial_cmp(p1);
+<ast::Span as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<ast::Span as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<ast::Span>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.clone();
+<ast::Position as std::clone::Clone>::clone(p0);
+crate::<ast::Position as std::clone::Clone>::clone(p0);
+<ast::Position>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.assert_receiver_is_total_eq();
+<ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Position>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.eq(p1);
+<ast::Position as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Position as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Position>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Position as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Position as std::fmt::Debug>::fmt(p0, p1);
+<ast::Position>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.cmp(p1);
+<ast::Position as std::cmp::Ord>::cmp(p0, p1);
+crate::<ast::Position as std::cmp::Ord>::cmp(p0, p1);
+<ast::Position>::cmp(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.partial_cmp(p1);
+<ast::Position as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<ast::Position as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<ast::Position>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Position
+ast::Span::new(p0, p1);
+crate::ast::Span::new(p0, p1);
+<ast::Span>::new(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::splat
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Position
+ast::Span::splat(p0);
+crate::ast::Span::splat(p0);
+<ast::Span>::splat(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::with_start
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Position
+p0.with_start(p1);
+ast::Span::with_start(p0, p1);
+crate::ast::Span::with_start(p0, p1);
+<ast::Span>::with_start(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::with_end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Position
+p0.with_end(p1);
+ast::Span::with_end(p0, p1);
+crate::ast::Span::with_end(p0, p1);
+<ast::Span>::with_end(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::is_one_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.is_one_line();
+ast::Span::is_one_line(p0);
+crate::ast::Span::is_one_line(p0);
+<ast::Span>::is_one_line(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.is_empty();
+ast::Span::is_empty(p0);
+crate::ast::Span::is_empty(p0);
+<ast::Span>::is_empty(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Position::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+ast::Position::new(p0, p1, p2);
+crate::ast::Position::new(p0, p1, p2);
+<ast::Position>::new(p0, p1, p2);
-----------------
regex-syntax/src/ast/mod.rs <ast::WithComments as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
+p0.clone();
+<ast::WithComments as std::clone::Clone>::clone(p0);
+crate::<ast::WithComments as std::clone::Clone>::clone(p0);
+<ast::WithComments>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::WithComments as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::WithComments as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::WithComments as std::fmt::Debug>::fmt(p0, p1);
+<ast::WithComments>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
+p0.assert_receiver_is_total_eq();
+<ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::WithComments>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::WithComments as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
+p0.eq(p1);
+<ast::WithComments as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::WithComments as std::cmp::PartialEq>::eq(p0, p1);
+<ast::WithComments>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Comment as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
+p0.clone();
+<ast::Comment as std::clone::Clone>::clone(p0);
+crate::<ast::Comment as std::clone::Clone>::clone(p0);
+<ast::Comment>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Comment as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Comment as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Comment as std::fmt::Debug>::fmt(p0, p1);
+<ast::Comment>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
+p0.assert_receiver_is_total_eq();
+<ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Comment>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Comment as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Comment
+p0.eq(p1);
+<ast::Comment as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Comment as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Comment>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.clone();
+<ast::Ast as std::clone::Clone>::clone(p0);
+crate::<ast::Ast as std::clone::Clone>::clone(p0);
+<ast::Ast>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Ast as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Ast as std::fmt::Debug>::fmt(p0, p1);
+<ast::Ast>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.assert_receiver_is_total_eq();
+<ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Ast>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.eq(p1);
+<ast::Ast as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Ast as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Ast>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Ast::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.span();
+ast::Ast::span(p0);
+crate::ast::Ast::span(p0);
+<ast::Ast>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Ast::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.is_empty();
+ast::Ast::is_empty(p0);
+crate::ast::Ast::is_empty(p0);
+<ast::Ast>::is_empty(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Ast::has_subexprs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.has_subexprs();
+ast::Ast::has_subexprs(p0);
+crate::ast::Ast::has_subexprs(p0);
+<ast::Ast>::has_subexprs(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ast::Ast as std::fmt::Display>::fmt(p0, p1);
+crate::<ast::Ast as std::fmt::Display>::fmt(p0, p1);
+<ast::Ast>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Alternation as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.clone();
+<ast::Alternation as std::clone::Clone>::clone(p0);
+crate::<ast::Alternation as std::clone::Clone>::clone(p0);
+<ast::Alternation>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Alternation as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Alternation as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Alternation as std::fmt::Debug>::fmt(p0, p1);
+<ast::Alternation>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.assert_receiver_is_total_eq();
+<ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Alternation>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Alternation as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.eq(p1);
+<ast::Alternation as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Alternation as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Alternation>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Alternation::into_ast
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.into_ast();
+ast::Alternation::into_ast(p0);
+crate::ast::Alternation::into_ast(p0);
+<ast::Alternation>::into_ast(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Concat as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.clone();
+<ast::Concat as std::clone::Clone>::clone(p0);
+crate::<ast::Concat as std::clone::Clone>::clone(p0);
+<ast::Concat>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Concat as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Concat as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Concat as std::fmt::Debug>::fmt(p0, p1);
+<ast::Concat>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.assert_receiver_is_total_eq();
+<ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Concat>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Concat as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.eq(p1);
+<ast::Concat as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Concat as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Concat>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Concat::into_ast
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.into_ast();
+ast::Concat::into_ast(p0);
+crate::ast::Concat::into_ast(p0);
+<ast::Concat>::into_ast(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Literal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.clone();
+<ast::Literal as std::clone::Clone>::clone(p0);
+crate::<ast::Literal as std::clone::Clone>::clone(p0);
+<ast::Literal>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Literal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Literal as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Literal as std::fmt::Debug>::fmt(p0, p1);
+<ast::Literal>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.assert_receiver_is_total_eq();
+<ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Literal>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Literal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.eq(p1);
+<ast::Literal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Literal as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Literal>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Literal::byte
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.byte();
+ast::Literal::byte(p0);
+crate::ast::Literal::byte(p0);
+<ast::Literal>::byte(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::LiteralKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
+p0.clone();
+<ast::LiteralKind as std::clone::Clone>::clone(p0);
+crate::<ast::LiteralKind as std::clone::Clone>::clone(p0);
+<ast::LiteralKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::LiteralKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::LiteralKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::LiteralKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::LiteralKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
+p0.assert_receiver_is_total_eq();
+<ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::LiteralKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::LiteralKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
+p0.eq(p1);
+<ast::LiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::LiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::LiteralKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::SpecialLiteralKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
+p0.clone();
+<ast::SpecialLiteralKind as std::clone::Clone>::clone(p0);
+crate::<ast::SpecialLiteralKind as std::clone::Clone>::clone(p0);
+<ast::SpecialLiteralKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::SpecialLiteralKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::SpecialLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::SpecialLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::SpecialLiteralKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
+p0.assert_receiver_is_total_eq();
+<ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::SpecialLiteralKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::SpecialLiteralKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
+p0.eq(p1);
+<ast::SpecialLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::SpecialLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::SpecialLiteralKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::HexLiteralKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.clone();
+<ast::HexLiteralKind as std::clone::Clone>::clone(p0);
+crate::<ast::HexLiteralKind as std::clone::Clone>::clone(p0);
+<ast::HexLiteralKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::HexLiteralKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::HexLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::HexLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::HexLiteralKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.assert_receiver_is_total_eq();
+<ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::HexLiteralKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::HexLiteralKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.eq(p1);
+<ast::HexLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::HexLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::HexLiteralKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::HexLiteralKind::digits
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.digits();
+ast::HexLiteralKind::digits(p0);
+crate::ast::HexLiteralKind::digits(p0);
+<ast::HexLiteralKind>::digits(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Class as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.clone();
+<ast::Class as std::clone::Clone>::clone(p0);
+crate::<ast::Class as std::clone::Clone>::clone(p0);
+<ast::Class>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Class as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Class as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Class as std::fmt::Debug>::fmt(p0, p1);
+<ast::Class>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.assert_receiver_is_total_eq();
+<ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Class>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Class as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.eq(p1);
+<ast::Class as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Class as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Class>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Class::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.span();
+ast::Class::span(p0);
+crate::ast::Class::span(p0);
+<ast::Class>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerl as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.clone();
+<ast::ClassPerl as std::clone::Clone>::clone(p0);
+crate::<ast::ClassPerl as std::clone::Clone>::clone(p0);
+<ast::ClassPerl>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerl as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassPerl as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassPerl as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassPerl>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.assert_receiver_is_total_eq();
+<ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassPerl>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerl as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.eq(p1);
+<ast::ClassPerl as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassPerl as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassPerl>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerlKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
+p0.clone();
+<ast::ClassPerlKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassPerlKind as std::clone::Clone>::clone(p0);
+<ast::ClassPerlKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerlKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassPerlKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassPerlKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassPerlKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassPerlKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerlKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
+p0.eq(p1);
+<ast::ClassPerlKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassPerlKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassPerlKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAscii as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.clone();
+<ast::ClassAscii as std::clone::Clone>::clone(p0);
+crate::<ast::ClassAscii as std::clone::Clone>::clone(p0);
+<ast::ClassAscii>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAscii as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassAscii as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassAscii as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassAscii>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.assert_receiver_is_total_eq();
+<ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassAscii>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAscii as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.eq(p1);
+<ast::ClassAscii as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassAscii as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassAscii>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAsciiKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+p0.clone();
+<ast::ClassAsciiKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassAsciiKind as std::clone::Clone>::clone(p0);
+<ast::ClassAsciiKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAsciiKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassAsciiKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassAsciiKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassAsciiKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassAsciiKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAsciiKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+p0.eq(p1);
+<ast::ClassAsciiKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassAsciiKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassAsciiKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassAsciiKind::from_name
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+ast::ClassAsciiKind::from_name(&p0);
+crate::ast::ClassAsciiKind::from_name(&p0);
+<ast::ClassAsciiKind>::from_name(&p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicode as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.clone();
+<ast::ClassUnicode as std::clone::Clone>::clone(p0);
+crate::<ast::ClassUnicode as std::clone::Clone>::clone(p0);
+<ast::ClassUnicode>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicode as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassUnicode>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.assert_receiver_is_total_eq();
+<ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassUnicode>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicode as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.eq(p1);
+<ast::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassUnicode>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassUnicode::is_negated
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.is_negated();
+ast::ClassUnicode::is_negated(p0);
+crate::ast::ClassUnicode::is_negated(p0);
+<ast::ClassUnicode>::is_negated(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
+p0.clone();
+<ast::ClassUnicodeKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassUnicodeKind as std::clone::Clone>::clone(p0);
+<ast::ClassUnicodeKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassUnicodeKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassUnicodeKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassUnicodeKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassUnicodeKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
+p0.eq(p1);
+<ast::ClassUnicodeKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassUnicodeKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassUnicodeKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeOpKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.clone();
+<ast::ClassUnicodeOpKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassUnicodeOpKind as std::clone::Clone>::clone(p0);
+<ast::ClassUnicodeOpKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassUnicodeOpKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassUnicodeOpKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.eq(p1);
+<ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassUnicodeOpKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassUnicodeOpKind::is_equal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.is_equal();
+ast::ClassUnicodeOpKind::is_equal(p0);
+crate::ast::ClassUnicodeOpKind::is_equal(p0);
+<ast::ClassUnicodeOpKind>::is_equal(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassBracketed as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.clone();
+<ast::ClassBracketed as std::clone::Clone>::clone(p0);
+crate::<ast::ClassBracketed as std::clone::Clone>::clone(p0);
+<ast::ClassBracketed>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassBracketed as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassBracketed as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassBracketed as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassBracketed>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.assert_receiver_is_total_eq();
+<ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassBracketed>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassBracketed as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.eq(p1);
+<ast::ClassBracketed as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassBracketed as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassBracketed>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.clone();
+<ast::ClassSet as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSet as std::clone::Clone>::clone(p0);
+<ast::ClassSet>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSet as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSet>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.assert_receiver_is_total_eq();
+<ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSet>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.eq(p1);
+<ast::ClassSet as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSet as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSet>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSet::union
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+ast::ClassSet::union(p0);
+crate::ast::ClassSet::union(p0);
+<ast::ClassSet>::union(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSet::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.span();
+ast::ClassSet::span(p0);
+crate::ast::ClassSet::span(p0);
+<ast::ClassSet>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSet::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.is_empty();
+ast::ClassSet::is_empty(p0);
+crate::ast::ClassSet::is_empty(p0);
+<ast::ClassSet>::is_empty(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetItem as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.clone();
+<ast::ClassSetItem as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetItem as std::clone::Clone>::clone(p0);
+<ast::ClassSetItem>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetItem as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetItem as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetItem as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetItem>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetItem>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetItem as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.eq(p1);
+<ast::ClassSetItem as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetItem as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetItem>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSetItem::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.span();
+ast::ClassSetItem::span(p0);
+crate::ast::ClassSetItem::span(p0);
+<ast::ClassSetItem>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.clone();
+<ast::ClassSetRange as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetRange as std::clone::Clone>::clone(p0);
+<ast::ClassSetRange>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetRange as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetRange>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.eq(p1);
+<ast::ClassSetRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetRange as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetRange>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSetRange::is_valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.is_valid();
+ast::ClassSetRange::is_valid(p0);
+crate::ast::ClassSetRange::is_valid(p0);
+<ast::ClassSetRange>::is_valid(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetUnion as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.clone();
+<ast::ClassSetUnion as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetUnion as std::clone::Clone>::clone(p0);
+<ast::ClassSetUnion>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetUnion as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetUnion as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetUnion as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetUnion>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetUnion>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetUnion as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.eq(p1);
+<ast::ClassSetUnion as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetUnion as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetUnion>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSetUnion::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.push(p1);
+ast::ClassSetUnion::push(p0, p1);
+crate::ast::ClassSetUnion::push(p0, p1);
+<ast::ClassSetUnion>::push(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSetUnion::into_item
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.into_item();
+ast::ClassSetUnion::into_item(p0);
+crate::ast::ClassSetUnion::into_item(p0);
+<ast::ClassSetUnion>::into_item(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.clone();
+<ast::ClassSetBinaryOp as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetBinaryOp as std::clone::Clone>::clone(p0);
+<ast::ClassSetBinaryOp>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetBinaryOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetBinaryOp as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetBinaryOp>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetBinaryOp>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.eq(p1);
+<ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetBinaryOp>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.clone();
+<ast::ClassSetBinaryOpKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetBinaryOpKind as std::clone::Clone>::clone(p0);
+<ast::ClassSetBinaryOpKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetBinaryOpKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetBinaryOpKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.eq(p1);
+<ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetBinaryOpKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Assertion as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.clone();
+<ast::Assertion as std::clone::Clone>::clone(p0);
+crate::<ast::Assertion as std::clone::Clone>::clone(p0);
+<ast::Assertion>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Assertion as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Assertion as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Assertion as std::fmt::Debug>::fmt(p0, p1);
+<ast::Assertion>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.assert_receiver_is_total_eq();
+<ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Assertion>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Assertion as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.eq(p1);
+<ast::Assertion as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Assertion as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Assertion>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::AssertionKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
+p0.clone();
+<ast::AssertionKind as std::clone::Clone>::clone(p0);
+crate::<ast::AssertionKind as std::clone::Clone>::clone(p0);
+<ast::AssertionKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::AssertionKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::AssertionKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::AssertionKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::AssertionKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
+p0.assert_receiver_is_total_eq();
+<ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::AssertionKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::AssertionKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
+p0.eq(p1);
+<ast::AssertionKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::AssertionKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::AssertionKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Repetition as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.clone();
+<ast::Repetition as std::clone::Clone>::clone(p0);
+crate::<ast::Repetition as std::clone::Clone>::clone(p0);
+<ast::Repetition>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Repetition as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Repetition as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Repetition as std::fmt::Debug>::fmt(p0, p1);
+<ast::Repetition>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.assert_receiver_is_total_eq();
+<ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Repetition>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Repetition as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.eq(p1);
+<ast::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Repetition>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
+p0.clone();
+<ast::RepetitionOp as std::clone::Clone>::clone(p0);
+crate::<ast::RepetitionOp as std::clone::Clone>::clone(p0);
+<ast::RepetitionOp>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::RepetitionOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::RepetitionOp as std::fmt::Debug>::fmt(p0, p1);
+<ast::RepetitionOp>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
+p0.assert_receiver_is_total_eq();
+<ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::RepetitionOp>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionOp as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
+p0.eq(p1);
+<ast::RepetitionOp as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::RepetitionOp as std::cmp::PartialEq>::eq(p0, p1);
+<ast::RepetitionOp>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.clone();
+<ast::RepetitionKind as std::clone::Clone>::clone(p0);
+crate::<ast::RepetitionKind as std::clone::Clone>::clone(p0);
+<ast::RepetitionKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::RepetitionKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.assert_receiver_is_total_eq();
+<ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::RepetitionKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.eq(p1);
+<ast::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::RepetitionKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.clone();
+<ast::RepetitionRange as std::clone::Clone>::clone(p0);
+crate::<ast::RepetitionRange as std::clone::Clone>::clone(p0);
+<ast::RepetitionRange>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+<ast::RepetitionRange>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.assert_receiver_is_total_eq();
+<ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::RepetitionRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.eq(p1);
+<ast::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+<ast::RepetitionRange>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::RepetitionRange::is_valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.is_valid();
+ast::RepetitionRange::is_valid(p0);
+crate::ast::RepetitionRange::is_valid(p0);
+<ast::RepetitionRange>::is_valid(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Group as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.clone();
+<ast::Group as std::clone::Clone>::clone(p0);
+crate::<ast::Group as std::clone::Clone>::clone(p0);
+<ast::Group>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Group as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Group as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Group as std::fmt::Debug>::fmt(p0, p1);
+<ast::Group>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.assert_receiver_is_total_eq();
+<ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Group>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Group as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.eq(p1);
+<ast::Group as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Group as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Group>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Group::flags
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.flags();
+ast::Group::flags(p0);
+crate::ast::Group::flags(p0);
+<ast::Group>::flags(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Group::is_capturing
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.is_capturing();
+ast::Group::is_capturing(p0);
+crate::ast::Group::is_capturing(p0);
+<ast::Group>::is_capturing(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Group::capture_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.capture_index();
+ast::Group::capture_index(p0);
+crate::ast::Group::capture_index(p0);
+<ast::Group>::capture_index(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::GroupKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
+p0.clone();
+<ast::GroupKind as std::clone::Clone>::clone(p0);
+crate::<ast::GroupKind as std::clone::Clone>::clone(p0);
+<ast::GroupKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::GroupKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::GroupKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
+p0.assert_receiver_is_total_eq();
+<ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::GroupKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::GroupKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
+p0.eq(p1);
+<ast::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::GroupKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::CaptureName as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.clone();
+<ast::CaptureName as std::clone::Clone>::clone(p0);
+crate::<ast::CaptureName as std::clone::Clone>::clone(p0);
+<ast::CaptureName>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::CaptureName as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::CaptureName as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::CaptureName as std::fmt::Debug>::fmt(p0, p1);
+<ast::CaptureName>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.assert_receiver_is_total_eq();
+<ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::CaptureName>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::CaptureName as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.eq(p1);
+<ast::CaptureName as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::CaptureName as std::cmp::PartialEq>::eq(p0, p1);
+<ast::CaptureName>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::SetFlags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.clone();
+<ast::SetFlags as std::clone::Clone>::clone(p0);
+crate::<ast::SetFlags as std::clone::Clone>::clone(p0);
+<ast::SetFlags>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::SetFlags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::SetFlags as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::SetFlags as std::fmt::Debug>::fmt(p0, p1);
+<ast::SetFlags>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.assert_receiver_is_total_eq();
+<ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::SetFlags>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::SetFlags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.eq(p1);
+<ast::SetFlags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::SetFlags as std::cmp::PartialEq>::eq(p0, p1);
+<ast::SetFlags>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.clone();
+<ast::Flags as std::clone::Clone>::clone(p0);
+crate::<ast::Flags as std::clone::Clone>::clone(p0);
+<ast::Flags>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Flags as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Flags as std::fmt::Debug>::fmt(p0, p1);
+<ast::Flags>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.assert_receiver_is_total_eq();
+<ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Flags>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.eq(p1);
+<ast::Flags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Flags as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Flags>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Flags::add_item
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.add_item(p1);
+ast::Flags::add_item(p0, p1);
+crate::ast::Flags::add_item(p0, p1);
+<ast::Flags>::add_item(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Flags::flag_state
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.flag_state(p1);
+ast::Flags::flag_state(p0, p1);
+crate::ast::Flags::flag_state(p0, p1);
+<ast::Flags>::flag_state(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItem as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.clone();
+<ast::FlagsItem as std::clone::Clone>::clone(p0);
+crate::<ast::FlagsItem as std::clone::Clone>::clone(p0);
+<ast::FlagsItem>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItem as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::FlagsItem as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::FlagsItem as std::fmt::Debug>::fmt(p0, p1);
+<ast::FlagsItem>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.assert_receiver_is_total_eq();
+<ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::FlagsItem>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItem as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.eq(p1);
+<ast::FlagsItem as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::FlagsItem as std::cmp::PartialEq>::eq(p0, p1);
+<ast::FlagsItem>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItemKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.clone();
+<ast::FlagsItemKind as std::clone::Clone>::clone(p0);
+crate::<ast::FlagsItemKind as std::clone::Clone>::clone(p0);
+<ast::FlagsItemKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItemKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::FlagsItemKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::FlagsItemKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::FlagsItemKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.assert_receiver_is_total_eq();
+<ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::FlagsItemKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItemKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.eq(p1);
+<ast::FlagsItemKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::FlagsItemKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::FlagsItemKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::FlagsItemKind::is_negation
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.is_negation();
+ast::FlagsItemKind::is_negation(p0);
+crate::ast::FlagsItemKind::is_negation(p0);
+<ast::FlagsItemKind>::is_negation(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flag as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.clone();
+<ast::Flag as std::clone::Clone>::clone(p0);
+crate::<ast::Flag as std::clone::Clone>::clone(p0);
+<ast::Flag>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flag as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Flag as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Flag as std::fmt::Debug>::fmt(p0, p1);
+<ast::Flag>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.assert_receiver_is_total_eq();
+<ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Flag>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flag as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.eq(p1);
+<ast::Flag as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Flag as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Flag>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.drop();
+<ast::Ast as std::ops::Drop>::drop(p0);
+crate::<ast::Ast as std::ops::Drop>::drop(p0);
+<ast::Ast>::drop(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.drop();
+<ast::ClassSet as std::ops::Drop>::drop(p0);
+crate::<ast::ClassSet as std::ops::Drop>::drop(p0);
+<ast::ClassSet>::drop(p0);
-----------------
regex-syntax/src/either.rs <either::Either<Left, Right> as std::clone::Clone>::clone
deps:{"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::clone::Clone>::clone":{"Left":["std::marker::Sized","std::clone::Clone"],"Right":["std::marker::Sized","std::clone::Clone"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow","std::clone::Clone"]},"either::Either":{"Left":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"],"Right":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","hir::interval::Interval","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::clone::Clone>::clone":{"Left":["hir::translate::TranslatorI","hir::Repetition","ast::Literal","ast::ClassSetBinaryOpKind","ast::HexLiteralKind","ast::Flags","hir::Hir","ast::FlagsItem","ast::AssertionKind","ast::ClassPerlKind","hir::interval::IntervalSet","ast::Alternation","hir::ClassBytes","either::Either","hir::Class","hir::Literal","hir::translate::TranslatorBuilder","hir::RepetitionRange","ast::ClassSetRange","ast::ClassPerl","hir::Anchor","ast::Flag","ast::parse::Parser","ast::Assertion","ast::ClassAsciiKind","ast::Ast","ast::Class","ast::Span","hir::translate::HirFrame","ast::Group","ast::RepetitionOp","hir::ClassUnicodeRange","ast::SetFlags","hir::ClassBytesRange","utf8::Utf8Range","ast::ClassUnicodeOpKind","hir::Error","std::clone::impls::<impl std::clone::Clone for *const T>","ast::ClassAscii","ast::ClassUnicodeKind","ast::LiteralKind","hir::literal::Literal","ast::ClassBracketed","ast::Comment","hir::GroupKind","hir::ClassUnicode","ast::parse::ClassState","ast::Repetition","ast::Concat","ast::ClassSetBinaryOp","utf8::Utf8Sequence","ast::ClassSetItem","ast::WithComments","ast::ClassUnicode","ast::parse::Primitive","hir::translate::Flags","hir::print::PrinterBuilder","hir::HirKind","hir::HirInfo","ast::parse::ParserBuilder","ast::print::PrinterBuilder","ast::Position","ast::parse::ParserI","hir::Group","hir::RepetitionKind","ast::RepetitionKind","error::Error","parser::Parser","ast::FlagsItemKind","ast::Error","ast::GroupKind","ast::RepetitionRange","hir::ErrorKind","ast::SpecialLiteralKind","ast::CaptureName","parser::ParserBuilder","hir::literal::Literals","hir::WordBoundary","ast::ClassSet","ast::ClassSetUnion","ast::parse::GroupState","hir::translate::Translator","ast::ErrorKind"],"Right":["ast::parse::ParserBuilder","hir::HirKind","hir::Class","ast::ClassAscii","hir::translate::HirFrame","ast::ClassPerlKind","ast::Ast","ast::AssertionKind","ast::ClassSetItem","hir::GroupKind","hir::Literal","hir::translate::TranslatorBuilder","ast::ErrorKind","ast::ClassSet","ast::RepetitionOp","hir::ClassBytesRange","parser::ParserBuilder","ast::ClassSetRange","parser::Parser","hir::ClassUnicode","ast::SetFlags","ast::Alternation","ast::Comment","ast::parse::Primitive","hir::translate::Flags","ast::parse::GroupState","hir::ClassBytes","ast::Error","ast::ClassAsciiKind","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::Position","hir::WordBoundary","ast::ClassSetBinaryOpKind","ast::Class","ast::Repetition","hir::print::PrinterBuilder","ast::parse::ClassState","error::Error","ast::ClassSetBinaryOp","hir::ClassUnicodeRange","utf8::Utf8Sequence","hir::Error","ast::parse::Parser","hir::ErrorKind","hir::interval::IntervalSet","ast::HexLiteralKind","ast::Literal","ast::Flags","hir::literal::Literals","ast::SpecialLiteralKind","ast::ClassSetUnion","ast::ClassPerl","ast::FlagsItem","hir::literal::Literal","hir::RepetitionRange","ast::ClassBracketed","ast::LiteralKind","ast::Concat","ast::Span","ast::Group","hir::RepetitionKind","ast::ClassUnicodeKind","ast::GroupKind","hir::translate::Translator","ast::ClassUnicodeOpKind","hir::Group","hir::Repetition","utf8::Utf8Range","ast::parse::ParserI","ast::print::PrinterBuilder","ast::Flag","either::Either","ast::Assertion","hir::Anchor","hir::HirInfo","ast::RepetitionRange","hir::translate::TranslatorI","ast::FlagsItemKind","ast::WithComments","ast::ClassUnicode","hir::Hir","std::clone::impls::<impl std::clone::Clone for &T>","ast::CaptureName","ast::RepetitionKind"]},"ast::parse::ParserI":{"P":["std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String","std::ffi::CString","std::rc::Rc<T>","std::path::PathBuf","std::clone::impls::<impl std::clone::Clone for &T>","std::vec::Vec<T, A>","std::ffi::OsString"]},"either::Either":{"Left":["ast::RepetitionKind","ast::Concat","ast::Class","hir::Hir","error::Error","hir::interval::IntervalSet","ast::GroupKind","ast::AssertionKind","hir::Literal","ast::ClassUnicodeOpKind","ast::HexLiteralKind","hir::RepetitionRange","hir::GroupKind","ast::RepetitionRange","ast::parse::Primitive","ast::Ast","ast::FlagsItem","ast::ClassBracketed","ast::ClassSetItem","ast::Assertion","ast::Error","ast::ClassSetUnion","ast::ClassSetRange","hir::Anchor","hir::ClassBytes","hir::literal::Literal","ast::ClassAsciiKind","utf8::Utf8Range","ast::ErrorKind","hir::ClassBytesRange","either::Either","hir::literal::Literals","ast::WithComments","ast::SpecialLiteralKind","hir::HirInfo","ast::ClassPerl","ast::ClassAscii","hir::ErrorKind","hir::HirKind","hir::Error","hir::ClassUnicodeRange","ast::ClassUnicode","ast::CaptureName","ast::Alternation","ast::RepetitionOp","hir::WordBoundary","ast::ClassUnicodeKind","ast::ClassPerlKind","ast::Literal","ast::Flags","hir::Repetition","ast::Flag","hir::Class","ast::LiteralKind","hir::RepetitionKind","ast::Span","ast::Repetition","ast::Position","ast::FlagsItemKind","ast::Comment","hir::Group","ast::Group","ast::ClassSet","ast::ClassSetBinaryOpKind","utf8::Utf8Sequence","ast::SetFlags","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","hir::ClassUnicode","ast::ClassSetBinaryOp"],"Right":["ast::Repetition","ast::ClassBracketed","ast::Ast","hir::RepetitionRange","ast::ClassPerlKind","error::Error","ast::SetFlags","hir::Hir","hir::interval::IntervalSet","ast::ClassPerl","hir::literal::Literals","ast::ClassUnicodeKind","hir::GroupKind","ast::ClassSetItem","ast::Group","hir::Class","hir::ClassUnicode","ast::ClassAscii","<*const T as std::fmt::Debug>","ast::ClassUnicodeOpKind","ast::Flags","ast::FlagsItemKind","ast::Span","utf8::Utf8Range","ast::LiteralKind","utf8::Utf8Sequence","ast::ClassSetRange","hir::ClassBytesRange","hir::WordBoundary","hir::RepetitionKind","ast::Comment","hir::HirInfo","ast::Error","hir::Repetition","ast::Concat","ast::ClassUnicode","ast::ErrorKind","hir::Literal","ast::RepetitionRange","hir::ErrorKind","ast::ClassSetBinaryOpKind","ast::ClassSetBinaryOp","ast::parse::Primitive","hir::HirKind","hir::ClassUnicodeRange","ast::Flag","either::Either","hir::Anchor","ast::Position","hir::Group","ast::Alternation","ast::RepetitionKind","ast::FlagsItem","ast::Literal","ast::ClassAsciiKind","hir::Error","ast::GroupKind","ast::ClassSetUnion","ast::WithComments","ast::SpecialLiteralKind","ast::AssertionKind","ast::Assertion","ast::ClassSet","ast::RepetitionOp","hir::literal::Literal","ast::CaptureName","ast::HexLiteralKind","ast::Class","hir::ClassBytes"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
+p0.clone();
+<either::Either<Left, Right> as std::clone::Clone>::clone(p0);
+crate::<either::Either<Left, Right> as std::clone::Clone>::clone(p0);
+<either::Either<Left, Right>>::clone(p0);
-----------------
regex-syntax/src/either.rs <either::Either<Left, Right> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::fmt::Debug>::fmt":{"Left":["std::marker::Sized","std::fmt::Debug"],"Right":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::clone::Clone","std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"either::Either":{"Left":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"],"Right":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"error::Formatter":{"E":["std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::cmp::Eq","std::fmt::Debug","hir::interval::Interval","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::fmt::Debug>::fmt":{"Left":["hir::Hir","ast::visitor::ClassInduct","ast::Position","hir::translate::TranslatorI","hir::GroupKind","ast::Concat","ast::ClassPerlKind","hir::ClassBytesRange","ast::ClassSet","ast::Comment","ast::Alternation","ast::print::Writer","ast::Repetition","error::Error","hir::Literal","utf8::Utf8Sequences","ast::ClassUnicodeKind","ast::parse::ClassState","unicode::CaseFoldError","<*const T as std::fmt::Debug>","ast::ClassSetItem","ast::CaptureName","ast::HexLiteralKind","ast::LiteralKind","ast::Flags","hir::translate::Translator","ast::Flag","ast::ClassBracketed","ast::Assertion","ast::WithComments","hir::HirKind","ast::ClassAsciiKind","hir::translate::Flags","hir::ClassUnicode","ast::Ast","hir::ClassBytes","parser::Parser","ast::parse::ParserBuilder","ast::ClassSetBinaryOpKind","hir::Class","ast::FlagsItem","ast::Group","ast::SetFlags","hir::literal::Literals","hir::translate::HirFrame","ast::FlagsItemKind","hir::interval::IntervalSetIter","ast::RepetitionRange","ast::ClassPerl","ast::ClassSetBinaryOp","ast::visitor::ClassFrame","hir::Repetition","hir::ClassUnicodeRange","utf8::Utf8Sequence","ast::print::Printer","ast::SpecialLiteralKind","ast::parse::NestLimiter","ast::ClassUnicode","unicode::CanonicalClassQuery","ast::Span","unicode::Error","ast::Class","error::Formatter","ast::RepetitionKind","ast::parse::Primitive","hir::print::Writer","ast::RepetitionOp","hir::translate::TranslatorBuilder","ast::ClassAscii","parser::ParserBuilder","hir::RepetitionKind","ast::print::PrinterBuilder","hir::HirInfo","hir::print::PrinterBuilder","ast::parse::Parser","hir::interval::IntervalSet","<&mut T as std::fmt::Debug>","utf8::ScalarRange","hir::ErrorKind","ast::parse::GroupState","ast::GroupKind","hir::ClassUnicodeIter","hir::ClassBytesIter","ast::Literal","ast::ClassSetRange","ast::ClassSetUnion","hir::Error","hir::Anchor","unicode::UnicodeWordError","hir::RepetitionRange","ast::ClassUnicodeOpKind","ast::AssertionKind","hir::print::Printer","ast::Error","utf8::Utf8Range","hir::Group","hir::literal::Literal","unicode::ClassQuery","ast::parse::ParserI","hir::WordBoundary","ast::ErrorKind","either::Either"],"Right":["hir::ErrorKind","unicode::Error","hir::interval::IntervalSetIter","hir::ClassUnicode","ast::Class","hir::ClassBytesRange","utf8::ScalarRange","ast::SetFlags","ast::ClassAsciiKind","ast::ClassSetItem","ast::parse::ParserI","hir::interval::IntervalSet","ast::ClassSetBinaryOp","ast::ClassSetUnion","hir::Error","ast::print::PrinterBuilder","ast::ClassUnicodeKind","hir::translate::TranslatorBuilder","hir::ClassUnicodeIter","ast::RepetitionOp","hir::RepetitionRange","ast::LiteralKind","hir::Group","unicode::ClassQuery","utf8::Utf8Sequences","unicode::CaseFoldError","ast::parse::Parser","ast::Repetition","ast::FlagsItemKind","hir::ClassBytesIter","hir::print::Writer","ast::Span","ast::CaptureName","ast::Concat","hir::literal::Literal","ast::ClassSet","either::Either","ast::Position","hir::RepetitionKind","ast::parse::NestLimiter","ast::Comment","ast::Flag","ast::Group","ast::ClassSetBinaryOpKind","utf8::Utf8Sequence","hir::HirInfo","ast::visitor::ClassFrame","hir::print::PrinterBuilder","ast::WithComments","hir::ClassBytes","hir::translate::HirFrame","hir::translate::Flags","ast::Ast","ast::ClassUnicodeOpKind","hir::Hir","ast::ClassAscii","ast::ClassSetRange","ast::RepetitionKind","ast::ClassPerl","ast::parse::GroupState","ast::RepetitionRange","ast::Literal","parser::Parser","hir::translate::TranslatorI","unicode::CanonicalClassQuery","ast::Error","ast::ClassUnicode","ast::ClassBracketed","ast::SpecialLiteralKind","ast::ErrorKind","hir::Anchor","ast::print::Writer","hir::Class","ast::ClassPerlKind","ast::visitor::ClassInduct","parser::ParserBuilder","hir::GroupKind","ast::parse::ParserBuilder","hir::WordBoundary","hir::literal::Literals","error::Formatter","ast::HexLiteralKind","ast::parse::ClassState","ast::Flags","hir::translate::Translator","hir::Repetition","hir::print::Printer","ast::AssertionKind","utf8::Utf8Range","ast::GroupKind","hir::ClassUnicodeRange","ast::Alternation","ast::parse::Primitive","ast::print::Printer","hir::HirKind","unicode::UnicodeWordError","error::Error","ast::FlagsItem","<*const T as std::fmt::Debug>","ast::Assertion","hir::Literal"]},"ast::parse::NestLimiter":{"P":["std::sync::Arc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","<&T as std::fmt::Debug>","std::ffi::CString","std::path::PathBuf","std::string::String","std::ffi::OsString","std::rc::Rc<T>"]},"ast::parse::ParserI":{"P":["std::boxed::Box<T, A>","std::clone::impls::<impl std::clone::Clone for &T>","std::sync::Arc<T>","std::rc::Rc<T>","std::ffi::OsString","std::vec::Vec<T, A>","std::string::String","std::path::PathBuf","std::ffi::CString"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["hir::HirKind","ast::ClassSetBinaryOp","hir::literal::Literals","ast::Error","ast::ClassUnicodeOpKind","hir::GroupKind","ast::ClassUnicodeKind","ast::ErrorKind","ast::ClassBracketed","hir::interval::IntervalSet","ast::Class","ast::Comment","hir::RepetitionRange","hir::literal::Literal","hir::Error","ast::HexLiteralKind","ast::GroupKind","hir::Anchor","hir::RepetitionKind","ast::Repetition","ast::ClassPerl","hir::ClassUnicode","ast::parse::Primitive","ast::ClassAsciiKind","ast::ClassSet","hir::Group","ast::Literal","hir::ClassUnicodeRange","ast::Ast","hir::WordBoundary","ast::Span","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::Flag","ast::ClassSetBinaryOpKind","hir::Literal","hir::Class","utf8::Utf8Sequence","ast::Flags","ast::AssertionKind","ast::Alternation","ast::CaptureName","ast::Concat","ast::ClassAscii","ast::Group","error::Error","hir::HirInfo","ast::RepetitionKind","ast::SpecialLiteralKind","ast::ClassPerlKind","ast::Position","ast::SetFlags","ast::ClassSetRange","ast::WithComments","ast::FlagsItem","ast::ClassSetItem","ast::FlagsItemKind","ast::ClassSetUnion","ast::Assertion","hir::ClassBytesRange","ast::LiteralKind","ast::ClassUnicode","hir::Repetition","either::Either","hir::Hir","ast::RepetitionOp","ast::RepetitionRange","utf8::Utf8Range","hir::ClassBytes","hir::ErrorKind"],"Right":["hir::literal::Literal","hir::RepetitionRange","ast::ClassBracketed","hir::Repetition","ast::GroupKind","hir::literal::Literals","ast::Flags","ast::AssertionKind","ast::parse::Primitive","ast::Repetition","ast::ClassSet","ast::SpecialLiteralKind","either::Either","ast::Span","ast::LiteralKind","hir::Literal","ast::Literal","utf8::Utf8Sequence","ast::CaptureName","ast::Ast","hir::ClassBytes","hir::HirKind","ast::Flag","ast::Position","ast::Error","ast::ClassPerl","ast::RepetitionKind","ast::RepetitionRange","hir::interval::IntervalSet","ast::FlagsItem","ast::ClassSetBinaryOp","ast::ClassPerlKind","hir::Group","hir::Error","hir::HirInfo","ast::Class","hir::WordBoundary","ast::ErrorKind","hir::Anchor","ast::HexLiteralKind","hir::ClassUnicodeRange","ast::ClassSetItem","hir::GroupKind","error::Error","ast::ClassSetUnion","ast::WithComments","hir::RepetitionKind","hir::Hir","utf8::Utf8Range","ast::Group","ast::ClassUnicodeOpKind","ast::ClassAsciiKind","ast::RepetitionOp","ast::SetFlags","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::ClassUnicode","hir::Class","ast::ClassAscii","hir::ClassBytesRange","ast::FlagsItemKind","hir::ClassUnicode","ast::Alternation","ast::ClassSetBinaryOpKind","ast::Comment","ast::ClassUnicodeKind","ast::Assertion","ast::ClassSetRange","ast::Concat","hir::ErrorKind"]},"error::Formatter":{"E":["<&mut T as std::fmt::Display>","hir::Hir","error::Error","ast::Error","unicode::UnicodeWordError","ast::Ast","error::Formatter","ast::ErrorKind","hir::ErrorKind","unicode::CaseFoldError","hir::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["hir::translate::TranslatorI","ast::HexLiteralKind","hir::print::PrinterBuilder","ast::Literal","ast::parse::NestLimiter","ast::ClassUnicodeOpKind","error::Formatter","ast::LiteralKind","ast::ClassSetRange","hir::ClassBytesRange","ast::visitor::ClassInduct","hir::print::Writer","ast::visitor::ClassFrame","hir::ClassBytesIter","hir::ClassUnicodeIter","ast::Comment","hir::Class","hir::HirKind","hir::GroupKind","hir::Repetition","ast::SpecialLiteralKind","ast::AssertionKind","hir::RepetitionRange","ast::parse::ParserI","hir::interval::IntervalSetIter","hir::literal::Literal","ast::parse::ParserBuilder","ast::ClassAscii","either::Either","ast::ClassUnicodeKind","ast::ClassSetBinaryOp","hir::translate::Translator","utf8::Utf8Sequence","hir::WordBoundary","ast::WithComments","ast::Assertion","hir::ClassBytes","ast::ClassPerl","parser::ParserBuilder","ast::ErrorKind","hir::ClassUnicode","hir::print::Printer","unicode::CaseFoldError","ast::Flags","ast::FlagsItem","unicode::UnicodeWordError","ast::ClassUnicode","utf8::Utf8Sequences","ast::Alternation","hir::interval::IntervalSet","hir::ClassUnicodeRange","ast::parse::Primitive","unicode::CanonicalClassQuery","hir::literal::Literals","hir::Group","ast::SetFlags","utf8::Utf8Range","ast::Error","ast::ClassSetUnion","hir::Literal","hir::translate::Flags","ast::Class","ast::Repetition","ast::ClassPerlKind","ast::RepetitionOp","parser::Parser","error::Error","ast::FlagsItemKind","unicode::ClassQuery","ast::ClassSetItem","hir::RepetitionKind","ast::print::Writer","ast::ClassSetBinaryOpKind","<&T as std::fmt::Debug>","ast::RepetitionRange","ast::Span","utf8::ScalarRange","hir::HirInfo","ast::Concat","ast::parse::GroupState","ast::ClassAsciiKind","ast::CaptureName","hir::Error","hir::Hir","ast::Group","ast::GroupKind","ast::ClassBracketed","ast::RepetitionKind","hir::translate::HirFrame","ast::print::Printer","ast::parse::ClassState","ast::Position","hir::translate::TranslatorBuilder","ast::parse::Parser","hir::ErrorKind","ast::ClassSet","ast::Ast","ast::print::PrinterBuilder","ast::Flag","hir::Anchor","unicode::Error"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<either::Either<Left, Right> as std::fmt::Debug>::fmt(p0, p1);
+crate::<either::Either<Left, Right> as std::fmt::Debug>::fmt(p0, p1);
+<either::Either<Left, Right>>::fmt(p0, p1);
-----------------
regex-syntax/src/either.rs <either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq":{"Left":["std::marker::Sized","std::cmp::Eq"],"Right":["std::cmp::Eq","std::marker::Sized"]},"either::Either":{"Left":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"],"Right":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","hir::interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq":{"Left":["ast::ClassAsciiKind","hir::Class","ast::AssertionKind","std::cmp::impls::<impl std::cmp::Eq for &A>","unicode::CanonicalClassQuery","ast::ClassUnicodeKind","hir::Repetition","hir::WordBoundary","hir::ClassUnicode","ast::ClassSet","hir::HirInfo","utf8::Utf8Range","ast::Assertion","ast::ClassSetUnion","ast::Alternation","ast::FlagsItemKind","hir::Literal","hir::Hir","ast::Flag","ast::FlagsItem","hir::Anchor","ast::ClassSetBinaryOp","utf8::Utf8Sequence","hir::ClassBytes","ast::WithComments","hir::HirKind","ast::Span","ast::Concat","ast::Group","ast::parse::Primitive","hir::ClassBytesRange","ast::ErrorKind","hir::Error","ast::ClassPerl","ast::ClassAscii","ast::HexLiteralKind","ast::Error","ast::ClassSetBinaryOpKind","ast::RepetitionKind","ast::LiteralKind","ast::SpecialLiteralKind","hir::RepetitionRange","ast::Position","ast::ClassSetItem","hir::GroupKind","ast::CaptureName","hir::Group","ast::Flags","ast::ClassBracketed","error::Error","hir::literal::Literal","ast::Ast","ast::ClassUnicodeOpKind","ast::Literal","ast::ClassUnicode","hir::ClassUnicodeRange","ast::ClassSetRange","ast::GroupKind","hir::interval::IntervalSet","hir::literal::Literals","ast::RepetitionOp","ast::Class","ast::RepetitionRange","either::Either","ast::Repetition","ast::ClassPerlKind","ast::SetFlags","hir::ErrorKind","ast::Comment","hir::RepetitionKind"],"Right":["ast::RepetitionKind","ast::ClassAscii","ast::HexLiteralKind","hir::ClassBytes","ast::ClassUnicodeKind","ast::FlagsItemKind","ast::ClassBracketed","ast::ClassUnicodeOpKind","hir::Error","hir::literal::Literal","ast::Literal","ast::Comment","ast::ClassUnicode","ast::CaptureName","hir::Hir","ast::ErrorKind","ast::Concat","utf8::Utf8Range","ast::FlagsItem","hir::interval::IntervalSet","ast::ClassSetBinaryOpKind","ast::GroupKind","ast::Repetition","ast::ClassSetBinaryOp","hir::Anchor","ast::parse::Primitive","ast::RepetitionRange","ast::RepetitionOp","unicode::CanonicalClassQuery","hir::literal::Literals","ast::AssertionKind","ast::WithComments","hir::RepetitionRange","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","ast::Position","std::cmp::impls::<impl std::cmp::Eq for &A>","ast::Error","utf8::Utf8Sequence","ast::ClassSetRange","ast::Flag","hir::ClassUnicodeRange","ast::ClassPerlKind","ast::Span","ast::ClassSet","ast::ClassSetItem","hir::GroupKind","either::Either","hir::Repetition","hir::ClassBytesRange","ast::Class","hir::Literal","ast::Ast","hir::ClassUnicode","hir::Group","ast::ClassSetUnion","hir::Class","ast::LiteralKind","error::Error","ast::Flags","hir::HirKind","ast::SpecialLiteralKind","ast::Assertion","ast::Alternation","hir::WordBoundary","hir::HirInfo","hir::ErrorKind","ast::SetFlags","hir::RepetitionKind","ast::ClassPerl","ast::ClassAsciiKind","ast::Group"]},"either::Either":{"Left":["ast::ErrorKind","hir::HirKind","hir::ClassUnicode","ast::FlagsItemKind","hir::Class","hir::literal::Literals","hir::HirInfo","hir::ErrorKind","ast::RepetitionKind","error::Error","ast::CaptureName","ast::ClassUnicodeOpKind","ast::RepetitionRange","utf8::Utf8Sequence","ast::ClassPerl","ast::ClassBracketed","ast::GroupKind","hir::literal::Literal","ast::Group","hir::Hir","ast::LiteralKind","ast::Class","ast::ClassUnicodeKind","ast::ClassAsciiKind","either::Either","ast::Position","ast::Concat","ast::ClassSetUnion","ast::ClassPerlKind","hir::ClassUnicodeRange","hir::WordBoundary","ast::Comment","hir::interval::IntervalSet","hir::Anchor","ast::ClassSetRange","ast::Flags","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::Literal","hir::Repetition","hir::GroupKind","utf8::Utf8Range","ast::HexLiteralKind","hir::ClassBytesRange","ast::Ast","ast::AssertionKind","ast::ClassSetBinaryOpKind","hir::Literal","ast::ClassSetItem","hir::Error","ast::Assertion","hir::RepetitionKind","ast::Repetition","ast::Alternation","ast::parse::Primitive","ast::ClassSet","ast::Span","ast::WithComments","ast::ClassSetBinaryOp","hir::ClassBytes","ast::RepetitionOp","ast::ClassUnicode","ast::FlagsItem","ast::Flag","ast::ClassAscii","ast::SetFlags","ast::Error","ast::SpecialLiteralKind","hir::Group","hir::RepetitionRange"],"Right":["hir::RepetitionKind","ast::SetFlags","hir::HirKind","ast::ClassAscii","ast::Span","ast::Flags","ast::ClassSetBinaryOpKind","hir::Literal","hir::literal::Literals","hir::RepetitionRange","ast::parse::Primitive","ast::ClassPerl","hir::Repetition","ast::ClassSetItem","utf8::Utf8Range","utf8::Utf8Sequence","hir::Group","ast::RepetitionRange","ast::AssertionKind","ast::FlagsItem","ast::ClassPerlKind","error::Error","hir::interval::IntervalSet","ast::Alternation","ast::ClassBracketed","ast::ClassAsciiKind","ast::ClassSetBinaryOp","ast::WithComments","hir::Anchor","ast::FlagsItemKind","hir::WordBoundary","ast::ClassSet","ast::Group","ast::Class","ast::ErrorKind","ast::RepetitionOp","hir::Hir","ast::CaptureName","hir::GroupKind","ast::LiteralKind","ast::Concat","ast::ClassUnicodeOpKind","ast::ClassSetUnion","ast::ClassUnicode","ast::Ast","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::Literal","either::Either","ast::Assertion","hir::Class","ast::Comment","hir::literal::Literal","ast::ClassUnicodeKind","ast::SpecialLiteralKind","hir::Error","ast::Flag","ast::ClassSetRange","ast::HexLiteralKind","hir::HirInfo","hir::ClassUnicodeRange","hir::ClassBytesRange","ast::RepetitionKind","hir::ClassUnicode","hir::ErrorKind","ast::Repetition","ast::Position","hir::ClassBytes","ast::Error","ast::GroupKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
+p0.assert_receiver_is_total_eq();
+<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<either::Either<Left, Right>>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/either.rs <either::Either<Left, Right> as std::cmp::PartialEq>::eq
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::PartialEq>::eq":{"Left":["std::marker::Sized","std::cmp::PartialEq"],"Right":["std::cmp::PartialEq","std::marker::Sized"]},"either::Either":{"Left":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"],"Right":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"hir::interval::IntervalSet":{"I":["std::cmp::Eq","std::cmp::PartialEq","hir::interval::Interval","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::PartialEq>::eq":{"Left":["hir::Literal","ast::WithComments","hir::Error","ast::parse::Primitive","ast::ClassPerlKind","hir::ClassBytesRange","hir::Repetition","ast::Ast","hir::Group","ast::Alternation","ast::ClassUnicodeKind","ast::Literal","unicode::CanonicalClassQuery","ast::ClassSetUnion","ast::ClassSet","hir::literal::Literals","hir::WordBoundary","ast::HexLiteralKind","ast::FlagsItemKind","ast::FlagsItem","ast::Group","utf8::Utf8Sequence","ast::GroupKind","error::Error","hir::ErrorKind","ast::CaptureName","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","hir::RepetitionRange","ast::SpecialLiteralKind","ast::AssertionKind","ast::Assertion","hir::ClassBytes","ast::ClassSetBinaryOp","ast::LiteralKind","either::Either","ast::Error","hir::RepetitionKind","ast::Position","ast::Class","ast::ClassPerl","ast::ClassUnicode","hir::interval::IntervalSet","hir::GroupKind","ast::Concat","ast::Flags","utf8::Utf8Range","ast::SetFlags","hir::literal::Literal","ast::ClassBracketed","hir::Class","ast::ClassAscii","hir::Anchor","ast::RepetitionRange","ast::ClassSetBinaryOpKind","ast::RepetitionKind","ast::ClassAsciiKind","ast::RepetitionOp","hir::HirInfo","ast::Span","ast::Repetition","ast::ErrorKind","ast::Flag","ast::ClassSetRange","ast::ClassUnicodeOpKind","ast::Comment","hir::ClassUnicode","hir::HirKind","ast::ClassSetItem","hir::Hir","hir::ClassUnicodeRange"],"Right":["ast::ClassSetItem","ast::ClassAsciiKind","ast::ClassUnicode","ast::RepetitionRange","ast::FlagsItem","hir::ClassUnicode","hir::ClassBytesRange","ast::ClassUnicodeOpKind","ast::WithComments","hir::GroupKind","ast::GroupKind","ast::SpecialLiteralKind","ast::ClassPerlKind","ast::RepetitionKind","ast::AssertionKind","hir::WordBoundary","ast::ClassBracketed","ast::ClassAscii","ast::Class","ast::Flags","error::Error","ast::ClassPerl","ast::Error","ast::SetFlags","ast::parse::Primitive","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::Flag","hir::Anchor","hir::ErrorKind","hir::HirInfo","ast::FlagsItemKind","ast::HexLiteralKind","utf8::Utf8Sequence","either::Either","ast::Position","ast::ClassSetBinaryOp","hir::Repetition","hir::interval::IntervalSet","hir::Literal","ast::ClassUnicodeKind","hir::Class","hir::ClassUnicodeRange","ast::Group","ast::Assertion","ast::ClassSetRange","hir::HirKind","hir::Error","ast::Ast","ast::ClassSetUnion","ast::RepetitionOp","ast::Span","hir::Hir","ast::Comment","hir::RepetitionRange","hir::RepetitionKind","hir::Group","ast::LiteralKind","ast::Repetition","hir::literal::Literals","ast::Concat","utf8::Utf8Range","hir::literal::Literal","ast::Literal","ast::CaptureName","ast::ClassSet","ast::Alternation","unicode::CanonicalClassQuery","ast::ClassSetBinaryOpKind","ast::ErrorKind","hir::ClassBytes"]},"either::Either":{"Left":["ast::AssertionKind","ast::Alternation","ast::ClassUnicodeKind","hir::WordBoundary","ast::Literal","ast::Repetition","utf8::Utf8Range","hir::HirInfo","hir::RepetitionKind","ast::Assertion","ast::ClassUnicodeOpKind","<*const T as std::fmt::Debug>","ast::WithComments","hir::Class","hir::ClassBytesRange","ast::ClassSetRange","ast::FlagsItem","hir::literal::Literal","ast::ClassUnicode","hir::Group","ast::ClassSetItem","ast::Position","hir::ClassBytes","hir::Literal","ast::Ast","ast::ClassAscii","ast::ClassSetBinaryOp","hir::Repetition","hir::interval::IntervalSet","ast::HexLiteralKind","hir::Error","ast::RepetitionOp","ast::ClassAsciiKind","ast::RepetitionRange","ast::CaptureName","hir::ClassUnicode","ast::LiteralKind","ast::ErrorKind","ast::FlagsItemKind","ast::ClassSetUnion","ast::ClassSet","hir::RepetitionRange","ast::ClassPerl","ast::SpecialLiteralKind","ast::SetFlags","hir::ClassUnicodeRange","utf8::Utf8Sequence","hir::Anchor","either::Either","ast::Flag","hir::HirKind","ast::ClassBracketed","ast::Group","error::Error","ast::Flags","ast::RepetitionKind","ast::ClassPerlKind","ast::Span","hir::Hir","hir::ErrorKind","ast::Error","ast::Comment","ast::ClassSetBinaryOpKind","ast::Concat","ast::GroupKind","ast::Class","hir::literal::Literals","hir::GroupKind","ast::parse::Primitive"],"Right":["ast::Span","hir::HirKind","ast::ClassSetItem","ast::Literal","hir::Anchor","ast::CaptureName","ast::RepetitionKind","ast::RepetitionOp","ast::GroupKind","hir::Repetition","ast::Position","ast::Assertion","utf8::Utf8Sequence","ast::Repetition","hir::Error","ast::Ast","ast::ClassSetBinaryOp","hir::Group","hir::RepetitionRange","hir::interval::IntervalSet","ast::ClassAsciiKind","error::Error","ast::WithComments","ast::ClassUnicodeKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::ClassBracketed","ast::LiteralKind","ast::parse::Primitive","hir::ClassUnicode","hir::ClassBytesRange","ast::ClassUnicodeOpKind","either::Either","hir::HirInfo","ast::ClassPerl","ast::ClassSetBinaryOpKind","hir::ClassUnicodeRange","hir::RepetitionKind","ast::ClassAscii","ast::Class","hir::WordBoundary","ast::Comment","ast::ClassSetUnion","utf8::Utf8Range","ast::ClassUnicode","hir::ErrorKind","hir::literal::Literal","ast::ClassSetRange","ast::ClassPerlKind","ast::Flags","ast::ClassSet","hir::Literal","hir::Hir","ast::Flag","ast::SetFlags","ast::Error","ast::Alternation","ast::FlagsItem","ast::AssertionKind","ast::ErrorKind","hir::Class","hir::ClassBytes","ast::FlagsItemKind","hir::literal::Literals","ast::HexLiteralKind","ast::SpecialLiteralKind","ast::Group","hir::GroupKind","ast::RepetitionRange","ast::Concat"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
let mut p1 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
+p0.eq(p1);
+<either::Either<Left, Right> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<either::Either<Left, Right> as std::cmp::PartialEq>::eq(p0, p1);
+<either::Either<Left, Right>>::eq(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.clone();
+<error::Error as std::clone::Clone>::clone(p0);
+crate::<error::Error as std::clone::Clone>::clone(p0);
+<error::Error>::clone(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Debug>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.assert_receiver_is_total_eq();
+<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::Error>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.eq(p1);
+<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+<error::Error>::eq(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Error as std::convert::From<ast::Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Error
+<error::Error as std::convert::From<ast::Error>>::from(p0);
+crate::<error::Error as std::convert::From<ast::Error>>::from(p0);
+<error::Error>::from(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::convert::From<hir::Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Error
+<error::Error as std::convert::From<hir::Error>>::from(p0);
+crate::<error::Error as std::convert::From<hir::Error>>::from(p0);
+<error::Error>::from(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.description();
+<error::Error as std::error::Error>::description(p0);
+crate::<error::Error as std::error::Error>::description(p0);
+<error::Error>::description(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Display>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Formatter<'e, E> as std::fmt::Debug>::fmt
'e
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Formatter<'e, E> as std::fmt::Debug>::fmt":{"E":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"],"Right":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"error::Formatter":{"E":["std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Formatter<'e, E> as std::fmt::Debug>::fmt":{"E":["hir::translate::TranslatorI","hir::WordBoundary","ast::RepetitionOp","ast::RepetitionRange","ast::ErrorKind","hir::HirInfo","ast::Class","unicode::CanonicalClassQuery","ast::parse::Parser","ast::AssertionKind","ast::print::PrinterBuilder","ast::SpecialLiteralKind","ast::ClassAsciiKind","hir::ClassBytesRange","error::Error","hir::Class","ast::print::Printer","hir::Literal","hir::interval::IntervalSet","ast::ClassUnicodeKind","ast::ClassBracketed","hir::Anchor","hir::print::Printer","ast::parse::GroupState","ast::visitor::ClassFrame","utf8::Utf8Range","hir::GroupKind","hir::Error","hir::ClassBytes","ast::ClassSetBinaryOpKind","ast::Error","ast::GroupKind","ast::parse::NestLimiter","hir::literal::Literals","utf8::ScalarRange","ast::parse::ParserI","ast::parse::ClassState","ast::Span","parser::Parser","ast::FlagsItem","parser::ParserBuilder","hir::ClassUnicodeRange","either::Either","ast::print::Writer","hir::Repetition","ast::Flag","ast::ClassSetBinaryOp","ast::LiteralKind","ast::Literal","ast::parse::ParserBuilder","ast::FlagsItemKind","unicode::Error","hir::ClassUnicode","ast::ClassPerl","hir::translate::TranslatorBuilder","ast::Comment","ast::Concat","ast::ClassAscii","ast::Group","ast::ClassSet","ast::ClassUnicodeOpKind","ast::ClassSetRange","hir::ClassUnicodeIter","hir::interval::IntervalSetIter","utf8::Utf8Sequences","ast::CaptureName","hir::literal::Literal","hir::print::PrinterBuilder","ast::Repetition","ast::parse::Primitive","ast::HexLiteralKind","hir::ErrorKind","ast::visitor::ClassInduct","ast::Alternation","hir::translate::HirFrame","utf8::Utf8Sequence","ast::SetFlags","hir::Hir","unicode::ClassQuery","ast::Assertion","hir::Group","ast::Flags","unicode::CaseFoldError","ast::RepetitionKind","unicode::UnicodeWordError","ast::WithComments","<*mut T as std::fmt::Debug>","error::Formatter","ast::ClassSetItem","ast::Ast","hir::RepetitionKind","ast::Position","hir::HirKind","hir::translate::Translator","ast::ClassUnicode","hir::ClassBytesIter","ast::ClassSetUnion","hir::translate::Flags","hir::print::Writer","ast::ClassPerlKind","hir::RepetitionRange"]},"ast::parse::NestLimiter":{"P":["<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::path::PathBuf","std::ffi::OsString","std::string::String","std::rc::Rc<T>","std::boxed::Box<T, A>"]},"ast::parse::ParserI":{"P":["std::path::PathBuf","std::vec::Vec<T, A>","std::string::String","std::rc::Rc<T>","std::boxed::Box<T, A>","std::sync::Arc<T>","<&T as std::fmt::Debug>","std::ffi::OsString","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::FlagsItemKind","ast::Concat","hir::HirInfo","ast::Comment","ast::ClassSetItem","ast::WithComments","ast::RepetitionOp","utf8::Utf8Sequence","ast::ClassSetRange","hir::interval::IntervalSet","ast::LiteralKind","ast::GroupKind","ast::Error","ast::ClassAscii","hir::HirKind","ast::ClassUnicode","ast::ErrorKind","ast::AssertionKind","ast::Alternation","ast::Class","hir::RepetitionKind","hir::Class","hir::Anchor","<*const T as std::fmt::Debug>","hir::ClassUnicode","ast::CaptureName","ast::ClassSetUnion","ast::ClassBracketed","either::Either","ast::ClassPerl","ast::Flags","ast::SetFlags","ast::ClassAsciiKind","ast::ClassPerlKind","hir::RepetitionRange","ast::HexLiteralKind","utf8::Utf8Range","hir::literal::Literals","hir::Hir","ast::Flag","ast::parse::Primitive","hir::WordBoundary","ast::Group","ast::ClassUnicodeOpKind","ast::Span","hir::GroupKind","ast::Ast","hir::ClassUnicodeRange","ast::Assertion","ast::SpecialLiteralKind","ast::ClassUnicodeKind","hir::literal::Literal","ast::FlagsItem","ast::ClassSet","ast::RepetitionKind","ast::Literal","ast::RepetitionRange","ast::Repetition","error::Error","hir::Group","hir::Literal","ast::ClassSetBinaryOp","hir::ClassBytes","ast::Position","ast::ClassSetBinaryOpKind","hir::ClassBytesRange","hir::ErrorKind","hir::Error","hir::Repetition"],"Right":["hir::Anchor","ast::ClassSetUnion","hir::RepetitionKind","ast::Concat","ast::Group","ast::ClassSetRange","hir::RepetitionRange","ast::FlagsItemKind","ast::Span","ast::Flag","ast::HexLiteralKind","ast::ClassPerl","ast::RepetitionKind","ast::SetFlags","ast::FlagsItem","ast::Literal","hir::Literal","hir::Repetition","ast::Ast","hir::Class","ast::Comment","utf8::Utf8Sequence","ast::Alternation","ast::Position","ast::SpecialLiteralKind","hir::ClassUnicode","ast::Class","ast::ClassSetBinaryOp","ast::ClassAsciiKind","ast::Assertion","ast::ClassAscii","ast::ClassSet","ast::Flags","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","hir::HirKind","ast::ClassUnicode","ast::Repetition","ast::ClassSetBinaryOpKind","hir::Group","hir::literal::Literals","ast::ClassUnicodeKind","ast::RepetitionOp","ast::parse::Primitive","ast::LiteralKind","ast::Error","hir::ClassBytesRange","ast::ClassBracketed","either::Either","hir::ClassUnicodeRange","hir::HirInfo","ast::CaptureName","error::Error","hir::literal::Literal","ast::RepetitionRange","ast::GroupKind","hir::GroupKind","hir::ClassBytes","hir::Hir","hir::WordBoundary","hir::interval::IntervalSet","hir::Error","ast::ClassSetItem","hir::ErrorKind","ast::WithComments","utf8::Utf8Range","ast::ErrorKind","ast::ClassUnicodeOpKind","ast::AssertionKind","ast::ClassPerlKind"]},"error::Formatter":{"E":["hir::Error","ast::ErrorKind","unicode::UnicodeWordError","error::Formatter","hir::Hir","hir::ErrorKind","unicode::CaseFoldError","<&T as std::fmt::Debug>","error::Error","ast::Ast","ast::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::ClassBracketed","hir::RepetitionKind","utf8::Utf8Sequences","ast::ClassSetUnion","hir::interval::IntervalSetIter","hir::ClassBytesRange","error::Formatter","ast::parse::Primitive","ast::ClassSet","ast::FlagsItem","hir::ClassUnicodeIter","utf8::Utf8Range","hir::Error","ast::RepetitionKind","hir::ClassBytesIter","hir::interval::IntervalSet","hir::print::Writer","hir::RepetitionRange","ast::Span","hir::translate::Translator","ast::parse::ParserBuilder","ast::Literal","ast::Ast","ast::parse::NestLimiter","hir::ClassUnicode","parser::Parser","ast::SpecialLiteralKind","ast::visitor::ClassInduct","hir::print::Printer","utf8::ScalarRange","ast::ClassSetItem","hir::ClassUnicodeRange","hir::ErrorKind","ast::Group","hir::Repetition","hir::print::PrinterBuilder","ast::Position","ast::ClassSetBinaryOp","ast::FlagsItemKind","unicode::UnicodeWordError","ast::ClassUnicodeOpKind","hir::Literal","hir::translate::HirFrame","utf8::Utf8Sequence","hir::translate::TranslatorBuilder","ast::Flags","ast::visitor::ClassFrame","ast::CaptureName","unicode::Error","unicode::CaseFoldError","ast::parse::ClassState","ast::SetFlags","parser::ParserBuilder","hir::translate::Flags","ast::parse::ParserI","ast::AssertionKind","ast::ClassAsciiKind","unicode::ClassQuery","ast::ClassAscii","ast::Error","hir::literal::Literal","ast::Concat","hir::GroupKind","hir::Hir","unicode::CanonicalClassQuery","hir::literal::Literals","ast::ClassSetRange","ast::WithComments","ast::ClassPerlKind","ast::Comment","hir::Anchor","hir::WordBoundary","ast::Assertion","hir::HirKind","ast::Repetition","ast::ClassSetBinaryOpKind","<&mut T as std::fmt::Debug>","either::Either","ast::ErrorKind","ast::Class","ast::ClassUnicodeKind","hir::translate::TranslatorI","ast::parse::GroupState","hir::Class","hir::HirInfo","ast::Alternation","ast::RepetitionRange","hir::Group","error::Error","hir::ClassBytes","ast::print::Writer","ast::print::PrinterBuilder","ast::ClassPerl","ast::RepetitionOp","ast::Flag","ast::ClassUnicode","ast::parse::Parser","ast::GroupKind","ast::LiteralKind","ast::HexLiteralKind","ast::print::Printer"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Formatter<'e, E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Formatter<'e, E> as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Formatter<'e, E> as std::fmt::Debug>::fmt(p0, p1);
+<error::Formatter<'e, E>>::fmt(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from
'e
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from(p0);
+crate::<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from(p0);
+<error::Formatter<'e, ast::ErrorKind>>::from(p0);
-----------------
regex-syntax/src/error.rs <error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from
'e
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from(p0);
+crate::<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from(p0);
+<error::Formatter<'e, hir::ErrorKind>>::from(p0);
-----------------
regex-syntax/src/error.rs <error::Formatter<'e, E> as std::fmt::Display>::fmt
'e
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<error::Formatter<'e, E> as std::fmt::Display>::fmt":{"E":["std::fmt::Display","std::marker::Sized"]},"error::Formatter":{"E":["std::fmt::Display","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<error::Formatter<'e, E> as std::fmt::Display>::fmt":{"E":["ast::Error","hir::ErrorKind","<&T as std::fmt::Display>","<&mut T as std::fmt::Display>","ast::Ast","error::Formatter","hir::Hir","error::Error","unicode::UnicodeWordError","ast::ErrorKind","hir::Error","unicode::CaseFoldError"]},"error::Formatter":{"E":["ast::Ast","ast::ErrorKind","ast::Error","unicode::UnicodeWordError","hir::Hir","error::Error","<&mut T as std::fmt::Debug>","unicode::CaseFoldError","hir::Error","error::Formatter","hir::ErrorKind"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Formatter<'e, E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Formatter<'e, E> as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Formatter<'e, E> as std::fmt::Display>::fmt(p0, p1);
+<error::Formatter<'e, E>>::fmt(p0, p1);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::from_formatter
'p
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"error::Formatter":{"E":["std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::Spans::<'p>::from_formatter":{"E":["std::fmt::Display","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"error::Formatter":{"E":["ast::ErrorKind","unicode::UnicodeWordError","error::Error","hir::Hir","hir::Error","unicode::CaseFoldError","<&mut T as std::fmt::Display>","error::Formatter","ast::Ast","ast::Error","hir::ErrorKind"]},"error::Spans::<'p>::from_formatter":{"E":["ast::Ast","unicode::CaseFoldError","hir::Error","error::Formatter","ast::ErrorKind","hir::ErrorKind","<&mut T as std::fmt::Display>","hir::Hir","unicode::UnicodeWordError","<&T as std::fmt::Display>","error::Error","ast::Error"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Formatter<'e, E>
+error::Spans::<'p>::from_formatter(p0);
+crate::error::Spans::<'p>::from_formatter(p0);
+<error::Spans<'p>>::from_formatter(p0);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::add
'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // error::Spans<'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
+p0.add(p1);
+error::Spans::<'p>::add(p0, p1);
+crate::error::Spans::<'p>::add(p0, p1);
+<error::Spans<'p>>::add(p0, p1);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::notate
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
+p0.notate();
+error::Spans::<'p>::notate(p0);
+crate::error::Spans::<'p>::notate(p0);
+<error::Spans<'p>>::notate(p0);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::notate_line
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
let mut p1 = 0usize; // None+usize
+p0.notate_line(p1);
+error::Spans::<'p>::notate_line(p0, p1);
+crate::error::Spans::<'p>::notate_line(p0, p1);
+<error::Spans<'p>>::notate_line(p0, p1);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::left_pad_line_number
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
let mut p1 = 0usize; // None+usize
+p0.left_pad_line_number(p1);
+error::Spans::<'p>::left_pad_line_number(p0, p1);
+crate::error::Spans::<'p>::left_pad_line_number(p0, p1);
+<error::Spans<'p>>::left_pad_line_number(p0, p1);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::line_number_padding
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
+p0.line_number_padding();
+error::Spans::<'p>::line_number_padding(p0);
+crate::error::Spans::<'p>::line_number_padding(p0);
+<error::Spans<'p>>::line_number_padding(p0);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSet<I> as std::clone::Clone>::clone
deps:{"<&mut T as std::borrow::Borrow<T>>":{},"<hir::interval::IntervalSet<I> as std::clone::Clone>::clone":{"I":["std::marker::Sized","std::clone::Clone"]},"ast::parse::ParserI":{"P":["std::clone::Clone","std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"either::Either":{"Left":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"],"Right":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","hir::interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&mut T as std::borrow::Borrow<T>>":{},"<hir::interval::IntervalSet<I> as std::clone::Clone>::clone":{"I":["ast::ClassAscii","ast::Span","ast::Group","std::clone::impls::<impl std::clone::Clone for &T>","ast::ClassPerl","ast::Class","ast::parse::Parser","ast::ClassBracketed","ast::RepetitionKind","ast::Literal","hir::WordBoundary","ast::ClassSetBinaryOp","ast::parse::ParserBuilder","hir::interval::IntervalSet","hir::Anchor","ast::ClassSetRange","hir::Error","ast::WithComments","hir::HirInfo","hir::HirKind","ast::Comment","utf8::Utf8Sequence","ast::LiteralKind","ast::Assertion","hir::ClassUnicode","ast::print::PrinterBuilder","ast::Flags","hir::ClassBytesRange","hir::translate::TranslatorBuilder","either::Either","hir::RepetitionKind","hir::Hir","ast::ClassSet","ast::SpecialLiteralKind","hir::ErrorKind","hir::GroupKind","hir::translate::Translator","hir::ClassBytes","ast::CaptureName","ast::ErrorKind","ast::AssertionKind","ast::ClassPerlKind","ast::Position","ast::ClassAsciiKind","ast::FlagsItem","ast::parse::ClassState","hir::translate::Flags","ast::Error","ast::RepetitionOp","hir::print::PrinterBuilder","parser::ParserBuilder","ast::ClassUnicode","ast::GroupKind","hir::literal::Literals","hir::ClassUnicodeRange","ast::ClassSetUnion","ast::Concat","ast::FlagsItemKind","hir::literal::Literal","utf8::Utf8Range","ast::ClassUnicodeOpKind","ast::ClassSetItem","hir::Class","ast::parse::GroupState","hir::RepetitionRange","hir::translate::TranslatorI","ast::ClassSetBinaryOpKind","ast::SetFlags","hir::Group","ast::HexLiteralKind","std::clone::impls::<impl std::clone::Clone for &mut T>","ast::Ast","hir::translate::HirFrame","hir::Literal","ast::ClassUnicodeKind","ast::Flag","ast::Repetition","error::Error","ast::parse::Primitive","parser::Parser","ast::parse::ParserI","ast::Alternation","ast::RepetitionRange","hir::Repetition"]},"ast::parse::ParserI":{"P":["std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String","std::ffi::OsString","std::clone::impls::<impl std::clone::Clone for &T>","std::rc::Rc<T>","std::path::PathBuf","std::ffi::CString"]},"either::Either":{"Left":["ast::ClassUnicode","ast::Literal","ast::AssertionKind","ast::ClassSetItem","ast::HexLiteralKind","hir::WordBoundary","ast::ClassSetBinaryOpKind","ast::ClassSetUnion","ast::ClassSet","hir::ClassBytes","ast::GroupKind","hir::ClassUnicodeRange","hir::RepetitionKind","hir::interval::IntervalSet","hir::Class","error::Error","hir::Error","utf8::Utf8Range","hir::HirKind","ast::ClassUnicodeOpKind","ast::SetFlags","hir::Hir","hir::literal::Literals","ast::ErrorKind","ast::ClassPerlKind","hir::Repetition","ast::FlagsItemKind","ast::Flag","hir::Anchor","ast::Concat","ast::RepetitionKind","ast::SpecialLiteralKind","ast::ClassAscii","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","hir::RepetitionRange","ast::Flags","ast::ClassUnicodeKind","ast::Assertion","hir::ClassBytesRange","ast::Error","hir::ClassUnicode","ast::ClassSetBinaryOp","ast::Alternation","ast::ClassAsciiKind","ast::RepetitionRange","ast::Position","hir::ErrorKind","ast::WithComments","hir::literal::Literal","ast::Comment","ast::Span","ast::LiteralKind","either::Either","ast::Ast","ast::Group","hir::HirInfo","ast::CaptureName","hir::Literal","ast::ClassBracketed","utf8::Utf8Sequence","ast::Class","hir::Group","ast::ClassPerl","ast::Repetition","ast::ClassSetRange","ast::FlagsItem","hir::GroupKind","ast::parse::Primitive","ast::RepetitionOp"],"Right":["ast::ClassUnicode","ast::ClassSetBinaryOp","hir::Repetition","utf8::Utf8Range","ast::Repetition","hir::ClassBytes","ast::ClassPerl","hir::ClassUnicodeRange","ast::ErrorKind","ast::Literal","ast::LiteralKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","hir::interval::IntervalSet","ast::RepetitionRange","ast::Assertion","ast::RepetitionKind","either::Either","ast::ClassBracketed","ast::Error","ast::ClassUnicodeKind","utf8::Utf8Sequence","ast::ClassUnicodeOpKind","ast::GroupKind","hir::Error","ast::Flag","ast::CaptureName","ast::Position","ast::WithComments","ast::SpecialLiteralKind","ast::AssertionKind","hir::Hir","ast::Concat","hir::HirKind","hir::WordBoundary","ast::ClassSetBinaryOpKind","ast::ClassSetUnion","ast::Group","ast::ClassSetRange","hir::HirInfo","ast::Comment","hir::Literal","hir::Group","ast::HexLiteralKind","hir::Anchor","ast::ClassPerlKind","hir::literal::Literals","ast::SetFlags","hir::RepetitionRange","ast::ClassSetItem","hir::Class","hir::ErrorKind","hir::literal::Literal","hir::RepetitionKind","error::Error","ast::FlagsItemKind","ast::Alternation","ast::Class","ast::ClassAscii","hir::ClassUnicode","ast::RepetitionOp","ast::ClassAsciiKind","ast::FlagsItem","ast::Ast","ast::parse::Primitive","hir::GroupKind","ast::Span","ast::Flags","hir::ClassBytesRange","ast::ClassSet"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.clone();
+<hir::interval::IntervalSet<I> as std::clone::Clone>::clone(p0);
+crate::<hir::interval::IntervalSet<I> as std::clone::Clone>::clone(p0);
+<hir::interval::IntervalSet<I>>::clone(p0);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt":{"I":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::clone::Clone","std::borrow::Borrow","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"either::Either":{"Left":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"],"Right":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt":{"I":["ast::Alternation","ast::GroupKind","hir::translate::TranslatorBuilder","hir::translate::HirFrame","hir::Hir","utf8::ScalarRange","ast::SetFlags","ast::visitor::ClassFrame","ast::Group","parser::ParserBuilder","ast::print::PrinterBuilder","ast::ClassSetBinaryOp","hir::WordBoundary","utf8::Utf8Range","ast::RepetitionOp","ast::Ast","ast::ClassUnicodeOpKind","hir::Group","hir::interval::IntervalSetIter","hir::translate::TranslatorI","ast::FlagsItem","hir::print::Printer","ast::Concat","ast::parse::Parser","ast::parse::Primitive","utf8::Utf8Sequences","ast::ClassSetItem","hir::RepetitionRange","ast::ClassUnicode","hir::ErrorKind","ast::SpecialLiteralKind","<*mut T as std::fmt::Debug>","hir::HirInfo","ast::visitor::ClassInduct","ast::Flags","<*const T as std::fmt::Debug>","either::Either","ast::Flag","ast::ClassBracketed","ast::Literal","hir::literal::Literal","error::Error","ast::ClassPerl","ast::ClassUnicodeKind","hir::interval::IntervalSet","ast::CaptureName","ast::Assertion","hir::print::Writer","ast::ClassSetUnion","ast::print::Writer","hir::RepetitionKind","unicode::ClassQuery","unicode::CanonicalClassQuery","ast::HexLiteralKind","unicode::CaseFoldError","ast::WithComments","hir::Repetition","ast::ErrorKind","error::Formatter","hir::GroupKind","hir::translate::Flags","ast::Comment","unicode::UnicodeWordError","ast::AssertionKind","utf8::Utf8Sequence","hir::HirKind","hir::ClassBytesIter","ast::parse::ParserI","hir::Class","ast::FlagsItemKind","ast::Error","hir::print::PrinterBuilder","ast::parse::GroupState","ast::parse::ClassState","ast::RepetitionKind","ast::ClassSet","hir::Error","ast::ClassAsciiKind","unicode::Error","ast::Span","hir::ClassBytesRange","ast::LiteralKind","parser::Parser","hir::ClassUnicodeRange","ast::ClassSetRange","ast::print::Printer","ast::ClassAscii","hir::ClassBytes","ast::ClassPerlKind","hir::Anchor","hir::ClassUnicode","ast::Position","hir::translate::Translator","ast::Class","ast::Repetition","ast::ClassSetBinaryOpKind","ast::parse::NestLimiter","hir::ClassUnicodeIter","hir::Literal","ast::RepetitionRange","ast::parse::ParserBuilder","hir::literal::Literals"]},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::rc::Rc<T>","std::vec::Vec<T, A>","std::ffi::CString","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::string::String","std::boxed::Box<T, A>"]},"ast::parse::ParserI":{"P":["std::ffi::OsString","std::boxed::Box<T, A>","std::ffi::CString","std::path::PathBuf","std::string::String","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::sync::Arc<T>","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["hir::interval::IntervalSet","ast::ClassUnicodeKind","ast::ClassUnicode","ast::ClassSetBinaryOp","hir::RepetitionRange","hir::Group","ast::ClassPerl","ast::WithComments","ast::Group","ast::Span","ast::Concat","hir::Error","hir::RepetitionKind","hir::HirInfo","ast::RepetitionRange","ast::Ast","ast::LiteralKind","ast::ClassPerlKind","ast::parse::Primitive","ast::Repetition","hir::literal::Literals","hir::ClassBytes","ast::Assertion","hir::ClassUnicode","hir::Literal","hir::Hir","hir::ErrorKind","ast::AssertionKind","error::Error","either::Either","hir::literal::Literal","ast::HexLiteralKind","ast::ClassSet","ast::ClassBracketed","hir::Repetition","hir::Class","ast::FlagsItemKind","hir::WordBoundary","ast::Alternation","ast::ClassSetRange","hir::ClassUnicodeRange","ast::RepetitionOp","ast::Flags","hir::ClassBytesRange","ast::Flag","utf8::Utf8Sequence","ast::ClassSetBinaryOpKind","hir::Anchor","ast::SpecialLiteralKind","ast::ClassAsciiKind","ast::Position","ast::Error","ast::CaptureName","<*mut T as std::fmt::Debug>","ast::SetFlags","ast::Literal","ast::ClassUnicodeOpKind","ast::GroupKind","ast::RepetitionKind","ast::ClassSetItem","utf8::Utf8Range","ast::FlagsItem","ast::ErrorKind","ast::Class","ast::ClassAscii","hir::HirKind","hir::GroupKind","ast::Comment","ast::ClassSetUnion"],"Right":["ast::RepetitionKind","ast::ClassSetBinaryOp","ast::ClassSetRange","hir::interval::IntervalSet","hir::ClassUnicodeRange","hir::Hir","ast::ErrorKind","ast::ClassPerl","ast::ClassPerlKind","ast::WithComments","ast::FlagsItemKind","hir::WordBoundary","ast::Comment","ast::Span","ast::RepetitionOp","hir::GroupKind","ast::HexLiteralKind","ast::Error","ast::Literal","hir::HirInfo","ast::AssertionKind","ast::ClassAsciiKind","hir::ClassBytes","ast::ClassAscii","hir::literal::Literals","ast::SpecialLiteralKind","ast::Repetition","hir::ClassUnicode","ast::ClassSet","hir::ClassBytesRange","hir::RepetitionKind","ast::Flags","ast::ClassUnicode","ast::SetFlags","ast::Group","ast::CaptureName","hir::Error","ast::LiteralKind","ast::ClassUnicodeKind","ast::GroupKind","ast::Alternation","hir::Literal","hir::Group","ast::FlagsItem","either::Either","ast::ClassSetBinaryOpKind","utf8::Utf8Sequence","ast::Assertion","hir::Anchor","hir::Class","hir::HirKind","hir::Repetition","error::Error","ast::ClassSetItem","ast::Position","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::ClassUnicodeOpKind","utf8::Utf8Range","ast::parse::Primitive","ast::Class","ast::Flag","ast::Ast","ast::RepetitionRange","ast::Concat","ast::ClassBracketed","hir::ErrorKind","ast::ClassSetUnion","hir::RepetitionRange","hir::literal::Literal"]},"error::Formatter":{"E":["unicode::UnicodeWordError","ast::Ast","ast::Error","error::Formatter","hir::Hir","<&mut T as std::fmt::Display>","ast::ErrorKind","error::Error","unicode::CaseFoldError","hir::Error","hir::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::ClassSetBinaryOpKind","ast::ClassSetRange","either::Either","hir::translate::TranslatorI","ast::ClassBracketed","ast::RepetitionKind","utf8::Utf8Sequences","ast::parse::ParserBuilder","ast::ClassUnicodeKind","ast::Group","ast::ErrorKind","ast::Assertion","ast::GroupKind","ast::Flag","unicode::UnicodeWordError","ast::parse::ClassState","utf8::ScalarRange","hir::HirKind","unicode::ClassQuery","hir::Error","hir::literal::Literals","hir::Literal","hir::Hir","ast::parse::NestLimiter","ast::Concat","ast::visitor::ClassFrame","hir::interval::IntervalSet","ast::print::Printer","hir::ClassUnicodeIter","hir::translate::HirFrame","hir::Group","<&T as std::fmt::Debug>","ast::parse::Parser","ast::WithComments","hir::ClassBytesIter","ast::Literal","hir::Repetition","unicode::Error","ast::parse::Primitive","hir::translate::Translator","hir::print::PrinterBuilder","hir::RepetitionKind","ast::ClassSet","hir::ErrorKind","unicode::CanonicalClassQuery","parser::Parser","ast::visitor::ClassInduct","ast::print::Writer","hir::interval::IntervalSetIter","ast::print::PrinterBuilder","ast::AssertionKind","ast::RepetitionOp","parser::ParserBuilder","hir::ClassUnicodeRange","error::Error","ast::ClassSetUnion","ast::parse::GroupState","ast::ClassUnicode","error::Formatter","ast::FlagsItemKind","ast::Comment","ast::Repetition","hir::Class","hir::HirInfo","hir::translate::Flags","ast::RepetitionRange","ast::LiteralKind","hir::literal::Literal","hir::print::Printer","ast::HexLiteralKind","ast::Alternation","ast::ClassSetItem","ast::SetFlags","hir::GroupKind","unicode::CaseFoldError","utf8::Utf8Sequence","ast::parse::ParserI","ast::Span","ast::FlagsItem","hir::print::Writer","ast::Position","hir::translate::TranslatorBuilder","hir::ClassBytesRange","ast::ClassUnicodeOpKind","hir::ClassBytes","ast::ClassPerl","ast::SpecialLiteralKind","ast::ClassAsciiKind","ast::ClassAscii","hir::RepetitionRange","ast::Class","utf8::Utf8Range","hir::ClassUnicode","hir::Anchor","ast::Error","hir::WordBoundary","ast::CaptureName","ast::Ast","ast::ClassSetBinaryOp","ast::Flags","ast::ClassPerlKind"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt(p0, p1);
+<hir::interval::IntervalSet<I>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq":{"I":["std::marker::Sized","std::cmp::Eq"]},"either::Either":{"Left":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"],"Right":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","hir::interval::Interval","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq":{"I":["ast::Assertion","ast::CaptureName","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","hir::ErrorKind","hir::ClassBytes","ast::AssertionKind","hir::WordBoundary","hir::Error","ast::GroupKind","ast::ClassAsciiKind","ast::ClassSetBinaryOpKind","error::Error","ast::ClassSetBinaryOp","ast::Span","ast::Position","hir::literal::Literals","ast::RepetitionKind","either::Either","ast::ClassBracketed","hir::HirKind","ast::Flags","hir::Class","ast::ClassSetItem","ast::Literal","ast::RepetitionOp","ast::ClassUnicodeKind","ast::ClassSetRange","hir::Repetition","hir::Anchor","hir::Hir","ast::ClassUnicodeOpKind","ast::LiteralKind","hir::interval::IntervalSet","ast::Error","hir::RepetitionRange","hir::HirInfo","std::cmp::impls::<impl std::cmp::Eq for &A>","hir::ClassUnicodeRange","ast::ClassPerlKind","ast::Alternation","ast::SetFlags","ast::FlagsItem","ast::Comment","ast::ClassUnicode","ast::ClassSetUnion","hir::Group","hir::ClassUnicode","ast::Repetition","ast::Group","hir::Literal","unicode::CanonicalClassQuery","ast::Flag","ast::ClassAscii","ast::SpecialLiteralKind","ast::ClassPerl","ast::parse::Primitive","hir::GroupKind","hir::ClassBytesRange","utf8::Utf8Range","ast::ClassSet","ast::RepetitionRange","ast::ErrorKind","hir::literal::Literal","ast::Concat","ast::Class","ast::HexLiteralKind","ast::FlagsItemKind","hir::RepetitionKind","ast::WithComments","ast::Ast","utf8::Utf8Sequence"]},"either::Either":{"Left":["ast::ClassSetBinaryOp","hir::ErrorKind","ast::FlagsItemKind","ast::parse::Primitive","ast::ErrorKind","ast::Flag","hir::Literal","ast::ClassUnicodeKind","hir::ClassBytes","ast::Class","hir::Hir","ast::Flags","ast::ClassBracketed","ast::Error","hir::literal::Literal","ast::Assertion","ast::FlagsItem","ast::RepetitionKind","ast::Span","hir::ClassBytesRange","ast::SpecialLiteralKind","error::Error","ast::ClassUnicode","hir::interval::IntervalSet","ast::HexLiteralKind","ast::Group","ast::WithComments","ast::ClassPerl","ast::GroupKind","hir::literal::Literals","ast::RepetitionOp","ast::ClassSetRange","hir::ClassUnicode","ast::ClassAscii","hir::Class","ast::Ast","ast::ClassSet","ast::Literal","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","hir::WordBoundary","ast::LiteralKind","utf8::Utf8Range","ast::ClassSetBinaryOpKind","ast::ClassUnicodeOpKind","ast::ClassAsciiKind","ast::SetFlags","ast::RepetitionRange","ast::Repetition","hir::Repetition","either::Either","hir::Anchor","ast::ClassPerlKind","ast::ClassSetItem","hir::GroupKind","ast::CaptureName","ast::Concat","utf8::Utf8Sequence","ast::Alternation","ast::AssertionKind","hir::HirKind","hir::Error","hir::HirInfo","ast::Position","ast::ClassSetUnion","hir::RepetitionKind","hir::ClassUnicodeRange","hir::Group","hir::RepetitionRange","ast::Comment"],"Right":["ast::Flag","either::Either","hir::Group","ast::WithComments","ast::RepetitionRange","hir::Literal","hir::ClassUnicodeRange","ast::RepetitionOp","hir::Repetition","ast::ClassSetUnion","ast::ClassUnicode","ast::Span","ast::ClassSetBinaryOp","hir::Class","utf8::Utf8Sequence","ast::RepetitionKind","ast::ClassSet","ast::Ast","hir::interval::IntervalSet","ast::HexLiteralKind","ast::GroupKind","utf8::Utf8Range","hir::ErrorKind","ast::parse::Primitive","ast::ErrorKind","ast::Error","ast::Repetition","ast::ClassSetBinaryOpKind","ast::Assertion","ast::CaptureName","hir::literal::Literals","ast::Flags","ast::ClassAsciiKind","ast::Class","ast::ClassPerlKind","hir::HirKind","hir::WordBoundary","hir::Hir","ast::ClassSetItem","error::Error","ast::Literal","ast::ClassPerl","ast::SetFlags","ast::ClassUnicodeOpKind","hir::RepetitionKind","ast::Concat","ast::Alternation","hir::Error","ast::ClassAscii","ast::ClassSetRange","ast::FlagsItemKind","ast::Position","ast::LiteralKind","hir::ClassBytes","ast::ClassBracketed","hir::Anchor","hir::ClassBytesRange","ast::ClassUnicodeKind","ast::FlagsItem","ast::Group","hir::RepetitionRange","ast::SpecialLiteralKind","hir::HirInfo","hir::GroupKind","hir::literal::Literal","ast::AssertionKind","ast::Comment","std::clone::impls::<impl std::clone::Clone for *const T>","hir::ClassUnicode"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.assert_receiver_is_total_eq();
+<hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::interval::IntervalSet<I>>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq
deps:{"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":{"I":["std::marker::Sized","std::cmp::PartialEq"]},"either::Either":{"Left":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"],"Right":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"hir::interval::IntervalSet":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","hir::interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":{"I":["ast::Assertion","ast::Flag","ast::ClassSetBinaryOpKind","ast::ClassPerlKind","ast::ClassUnicodeOpKind","ast::Concat","hir::Hir","ast::ClassSetBinaryOp","ast::Repetition","hir::WordBoundary","ast::GroupKind","ast::ClassUnicodeKind","ast::HexLiteralKind","ast::LiteralKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::Class","hir::ClassBytes","hir::ClassBytesRange","ast::parse::Primitive","ast::Span","ast::RepetitionRange","ast::ClassSetItem","ast::ClassSetUnion","hir::RepetitionRange","ast::ClassAscii","hir::ClassUnicode","ast::WithComments","ast::Error","either::Either","unicode::CanonicalClassQuery","error::Error","ast::SpecialLiteralKind","hir::GroupKind","ast::SetFlags","ast::Position","hir::Repetition","hir::ErrorKind","hir::interval::IntervalSet","ast::FlagsItem","hir::Class","ast::Group","hir::HirKind","ast::ClassUnicode","ast::FlagsItemKind","hir::RepetitionKind","ast::Ast","hir::literal::Literal","ast::ErrorKind","hir::Error","ast::ClassSet","utf8::Utf8Range","ast::Flags","hir::Literal","hir::ClassUnicodeRange","ast::ClassAsciiKind","hir::Anchor","hir::Group","ast::RepetitionOp","ast::AssertionKind","hir::literal::Literals","ast::ClassPerl","ast::ClassBracketed","ast::Comment","ast::RepetitionKind","ast::CaptureName","ast::Alternation","ast::ClassSetRange","utf8::Utf8Sequence","hir::HirInfo","ast::Literal"]},"either::Either":{"Left":["hir::WordBoundary","hir::ClassUnicode","ast::FlagsItemKind","hir::ClassUnicodeRange","hir::ClassBytes","ast::Position","hir::HirInfo","hir::Error","std::clone::impls::<impl std::clone::Clone for *const T>","hir::Anchor","ast::GroupKind","either::Either","ast::Literal","error::Error","ast::RepetitionRange","ast::ClassSetUnion","ast::Flags","ast::LiteralKind","ast::CaptureName","ast::ClassBracketed","ast::ErrorKind","ast::Flag","ast::ClassPerlKind","ast::Group","hir::Repetition","utf8::Utf8Range","hir::RepetitionKind","ast::Repetition","hir::GroupKind","ast::ClassAsciiKind","ast::Concat","ast::RepetitionOp","ast::Comment","ast::ClassSetItem","ast::ClassAscii","ast::Ast","ast::ClassUnicodeOpKind","ast::parse::Primitive","ast::ClassPerl","ast::Span","ast::SetFlags","ast::HexLiteralKind","ast::SpecialLiteralKind","utf8::Utf8Sequence","hir::Hir","hir::interval::IntervalSet","hir::Group","ast::Assertion","hir::ErrorKind","ast::AssertionKind","ast::FlagsItem","hir::ClassBytesRange","ast::ClassUnicode","ast::ClassSet","ast::ClassUnicodeKind","hir::literal::Literal","hir::HirKind","ast::Alternation","hir::literal::Literals","ast::ClassSetBinaryOp","ast::ClassSetRange","hir::Literal","ast::RepetitionKind","ast::Error","ast::WithComments","ast::ClassSetBinaryOpKind","hir::RepetitionRange","hir::Class","ast::Class"],"Right":["ast::ClassSetItem","hir::literal::Literals","hir::HirInfo","ast::FlagsItemKind","hir::Hir","hir::WordBoundary","ast::RepetitionKind","ast::ClassPerl","ast::SpecialLiteralKind","ast::Position","error::Error","ast::ErrorKind","hir::literal::Literal","ast::ClassBracketed","ast::CaptureName","hir::ErrorKind","hir::RepetitionKind","ast::SetFlags","ast::RepetitionRange","ast::ClassSetRange","ast::LiteralKind","ast::Assertion","ast::ClassUnicodeKind","ast::RepetitionOp","ast::HexLiteralKind","ast::Group","hir::HirKind","ast::Repetition","hir::Class","ast::parse::Primitive","hir::RepetitionRange","ast::WithComments","ast::Flag","ast::Comment","ast::Flags","hir::Repetition","hir::Group","ast::Concat","ast::Alternation","ast::ClassSetBinaryOpKind","either::Either","ast::ClassAsciiKind","ast::ClassSetUnion","hir::ClassUnicode","ast::ClassPerlKind","ast::ClassSetBinaryOp","ast::ClassSet","hir::Error","ast::GroupKind","utf8::Utf8Range","ast::ClassAscii","hir::interval::IntervalSet","ast::ClassUnicodeOpKind","ast::FlagsItem","hir::Literal","hir::ClassBytesRange","utf8::Utf8Sequence","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::AssertionKind","ast::ClassUnicode","ast::Error","hir::GroupKind","hir::Anchor","ast::Span","hir::ClassUnicodeRange","hir::ClassBytes","ast::Class","ast::Literal","ast::Ast"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.eq(p1);
+<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq(p0, p1);
+<hir::interval::IntervalSet<I>>::eq(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow","std::clone::Clone"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"either::Either":{"Left":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized"],"Right":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::Formatter":{"E":["std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","hir::interval::Interval","std::marker::Sized"]},"hir::interval::IntervalSet::<I>::new":{"I":["std::marker::Sized","hir::interval::Interval"],"T":["std::iter::IntoIterator","std::marker::Sized"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["utf8::Utf8Sequences","hir::ClassBytesIter","<&mut I as std::iter::Iterator>","hir::ClassUnicodeIter","hir::interval::IntervalSetIter"]},"ast::parse::NestLimiter":{"P":["<&T as std::fmt::Debug>","std::ffi::OsString","std::string::String","std::ffi::CString","std::rc::Rc<T>","std::path::PathBuf","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::sync::Arc<T>"]},"ast::parse::ParserI":{"P":["std::ffi::CString","std::path::PathBuf","std::string::String","std::vec::Vec<T, A>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::rc::Rc<T>","<&T as std::fmt::Debug>","std::ffi::OsString"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::ClassSetRange","ast::Alternation","ast::HexLiteralKind","ast::AssertionKind","error::Error","ast::Concat","ast::parse::Primitive","ast::RepetitionRange","hir::Literal","ast::WithComments","ast::ClassPerl","ast::Comment","ast::GroupKind","hir::GroupKind","ast::ClassSetItem","ast::ClassUnicodeKind","ast::Assertion","ast::ClassAscii","hir::RepetitionKind","hir::Class","hir::Anchor","ast::ClassBracketed","hir::ClassBytes","hir::literal::Literal","hir::ClassUnicode","ast::FlagsItem","utf8::Utf8Range","ast::Ast","hir::Repetition","ast::CaptureName","ast::ClassSet","ast::Flag","hir::HirKind","ast::ClassSetUnion","hir::RepetitionRange","ast::Position","ast::ClassUnicodeOpKind","ast::Class","either::Either","hir::Hir","ast::ClassAsciiKind","ast::Group","ast::ClassUnicode","hir::Group","ast::RepetitionKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::ClassSetBinaryOp","ast::Span","ast::Flags","hir::interval::IntervalSet","hir::ClassUnicodeRange","utf8::Utf8Sequence","ast::SetFlags","ast::LiteralKind","hir::Error","hir::ErrorKind","ast::Repetition","ast::FlagsItemKind","hir::literal::Literals","hir::WordBoundary","ast::ErrorKind","ast::ClassPerlKind","ast::RepetitionOp","ast::Error","ast::Literal","hir::ClassBytesRange","ast::ClassSetBinaryOpKind","hir::HirInfo","ast::SpecialLiteralKind"],"Right":["ast::Ast","ast::AssertionKind","ast::WithComments","ast::ClassSetItem","ast::ClassSetBinaryOpKind","ast::parse::Primitive","ast::ClassBracketed","ast::ClassSetBinaryOp","ast::RepetitionRange","hir::literal::Literal","ast::Literal","ast::Error","utf8::Utf8Range","ast::ClassUnicodeOpKind","ast::Position","hir::ClassBytes","hir::Group","ast::SetFlags","ast::ErrorKind","ast::Span","hir::Repetition","hir::Error","ast::Assertion","hir::Literal","hir::HirInfo","hir::RepetitionKind","ast::ClassUnicodeKind","error::Error","ast::Group","ast::ClassPerl","hir::Anchor","ast::ClassAscii","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","ast::ClassSet","ast::Concat","ast::HexLiteralKind","ast::SpecialLiteralKind","ast::FlagsItem","ast::FlagsItemKind","ast::ClassAsciiKind","ast::Flag","ast::CaptureName","hir::Hir","ast::ClassSetUnion","ast::Alternation","ast::RepetitionOp","either::Either","ast::Flags","hir::Class","ast::Repetition","ast::ClassPerlKind","hir::ClassUnicode","hir::WordBoundary","ast::Comment","hir::interval::IntervalSet","hir::HirKind","hir::literal::Literals","ast::GroupKind","hir::GroupKind","ast::ClassSetRange","ast::RepetitionKind","hir::RepetitionRange","hir::ClassUnicodeRange","ast::Class","utf8::Utf8Sequence","ast::ClassUnicode","hir::ClassBytesRange","hir::ErrorKind","ast::LiteralKind"]},"error::Formatter":{"E":["hir::ErrorKind","unicode::CaseFoldError","ast::Ast","unicode::UnicodeWordError","error::Error","hir::Error","hir::Hir","ast::ErrorKind","error::Formatter","<&T as std::fmt::Debug>","ast::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSet::<I>::new":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"],"T":["<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>","<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>"]},"hir::interval::IntervalSetIter":{"I":["ast::GroupKind","hir::ClassUnicode","ast::Flags","ast::ClassSetBinaryOpKind","ast::Span","error::Formatter","ast::parse::GroupState","ast::Comment","ast::WithComments","ast::Alternation","ast::Class","ast::Error","hir::ClassBytes","ast::ClassPerlKind","hir::Anchor","hir::translate::HirFrame","ast::SetFlags","unicode::CaseFoldError","hir::RepetitionRange","ast::ClassPerl","hir::ErrorKind","ast::parse::NestLimiter","unicode::CanonicalClassQuery","hir::ClassUnicodeRange","hir::print::PrinterBuilder","utf8::ScalarRange","hir::ClassUnicodeIter","ast::ClassUnicodeKind","unicode::UnicodeWordError","ast::RepetitionRange","ast::ClassUnicode","unicode::Error","ast::ErrorKind","ast::AssertionKind","ast::ClassSetRange","hir::literal::Literals","utf8::Utf8Range","ast::Group","hir::Repetition","hir::print::Writer","ast::Position","hir::ClassBytesIter","hir::Hir","ast::parse::ParserBuilder","unicode::ClassQuery","hir::HirInfo","ast::ClassAscii","hir::GroupKind","hir::WordBoundary","error::Error","hir::print::Printer","ast::SpecialLiteralKind","parser::ParserBuilder","ast::Concat","ast::Repetition","ast::RepetitionKind","ast::print::Printer","ast::ClassAsciiKind","ast::ClassSetItem","ast::CaptureName","utf8::Utf8Sequences","ast::ClassSetBinaryOp","hir::Error","hir::translate::Flags","utf8::Utf8Sequence","ast::print::Writer","ast::print::PrinterBuilder","hir::translate::Translator","hir::Class","ast::ClassSetUnion","ast::Assertion","either::Either","ast::parse::ClassState","ast::LiteralKind","ast::HexLiteralKind","hir::translate::TranslatorI","hir::RepetitionKind","ast::ClassUnicodeOpKind","ast::visitor::ClassInduct","ast::Flag","hir::translate::TranslatorBuilder","ast::FlagsItem","<*const T as std::fmt::Debug>","hir::Literal","ast::ClassSet","hir::HirKind","ast::parse::Primitive","ast::visitor::ClassFrame","ast::Ast","hir::interval::IntervalSetIter","ast::parse::Parser","ast::RepetitionOp","hir::literal::Literal","ast::ClassBracketed","hir::ClassBytesRange","hir::Group","parser::Parser","hir::interval::IntervalSet","ast::FlagsItemKind","ast::parse::ParserI","ast::Literal"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+hir::interval::IntervalSet::<I>::new(p0);
+crate::hir::interval::IntervalSet::<I>::new(p0);
+<hir::interval::IntervalSet<I>>::new(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::push
deps:{"hir::interval::IntervalSet::<I>::push":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::push":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.push(p1);
+hir::interval::IntervalSet::<I>::push(p0, p1);
+crate::hir::interval::IntervalSet::<I>::push(p0, p1);
+<hir::interval::IntervalSet<I>>::push(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::iter
deps:{"hir::interval::IntervalSet::<I>::iter":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::iter":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.iter();
+hir::interval::IntervalSet::<I>::iter(p0);
+crate::hir::interval::IntervalSet::<I>::iter(p0);
+<hir::interval::IntervalSet<I>>::iter(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::intervals
deps:{"hir::interval::IntervalSet::<I>::intervals":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::intervals":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.intervals();
+hir::interval::IntervalSet::<I>::intervals(p0);
+crate::hir::interval::IntervalSet::<I>::intervals(p0);
+<hir::interval::IntervalSet<I>>::intervals(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::case_fold_simple
deps:{"hir::interval::IntervalSet::<I>::case_fold_simple":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::case_fold_simple":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.case_fold_simple();
+hir::interval::IntervalSet::<I>::case_fold_simple(p0);
+crate::hir::interval::IntervalSet::<I>::case_fold_simple(p0);
+<hir::interval::IntervalSet<I>>::case_fold_simple(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::union
deps:{"hir::interval::IntervalSet::<I>::union":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::union":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.union(p1);
+hir::interval::IntervalSet::<I>::union(p0, p1);
+crate::hir::interval::IntervalSet::<I>::union(p0, p1);
+<hir::interval::IntervalSet<I>>::union(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::intersect
deps:{"hir::interval::IntervalSet::<I>::intersect":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::intersect":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.intersect(p1);
+hir::interval::IntervalSet::<I>::intersect(p0, p1);
+crate::hir::interval::IntervalSet::<I>::intersect(p0, p1);
+<hir::interval::IntervalSet<I>>::intersect(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::difference
deps:{"hir::interval::IntervalSet::<I>::difference":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::difference":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.difference(p1);
+hir::interval::IntervalSet::<I>::difference(p0, p1);
+crate::hir::interval::IntervalSet::<I>::difference(p0, p1);
+<hir::interval::IntervalSet<I>>::difference(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::symmetric_difference
deps:{"hir::interval::IntervalSet::<I>::symmetric_difference":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::symmetric_difference":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.symmetric_difference(p1);
+hir::interval::IntervalSet::<I>::symmetric_difference(p0, p1);
+crate::hir::interval::IntervalSet::<I>::symmetric_difference(p0, p1);
+<hir::interval::IntervalSet<I>>::symmetric_difference(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::negate
deps:{"hir::interval::IntervalSet::<I>::negate":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::negate":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.negate();
+hir::interval::IntervalSet::<I>::negate(p0);
+crate::hir::interval::IntervalSet::<I>::negate(p0);
+<hir::interval::IntervalSet<I>>::negate(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::canonicalize
deps:{"hir::interval::IntervalSet::<I>::canonicalize":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::canonicalize":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.canonicalize();
+hir::interval::IntervalSet::<I>::canonicalize(p0);
+crate::hir::interval::IntervalSet::<I>::canonicalize(p0);
+<hir::interval::IntervalSet<I>>::canonicalize(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::is_canonical
deps:{"hir::interval::IntervalSet::<I>::is_canonical":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::is_canonical":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.is_canonical();
+hir::interval::IntervalSet::<I>::is_canonical(p0);
+crate::hir::interval::IntervalSet::<I>::is_canonical(p0);
+<hir::interval::IntervalSet<I>>::is_canonical(p0);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::borrow::Borrow","std::clone::Clone","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"either::Either":{"Left":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"],"Right":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"error::Formatter":{"E":["std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["hir::interval::Interval","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt":{"I":["ast::ErrorKind","hir::ClassBytes","hir::literal::Literal","utf8::ScalarRange","ast::Class","ast::visitor::ClassFrame","ast::GroupKind","hir::ClassBytesRange","ast::ClassSetUnion","ast::print::Printer","hir::GroupKind","parser::ParserBuilder","unicode::CanonicalClassQuery","unicode::CaseFoldError","<&mut T as std::fmt::Debug>","hir::translate::TranslatorI","hir::HirInfo","hir::print::PrinterBuilder","ast::RepetitionKind","ast::AssertionKind","ast::ClassSet","hir::interval::IntervalSetIter","hir::translate::Translator","ast::Literal","hir::Repetition","hir::RepetitionKind","ast::Error","ast::parse::NestLimiter","ast::RepetitionRange","utf8::Utf8Range","utf8::Utf8Sequence","hir::translate::Flags","ast::Span","hir::Anchor","ast::WithComments","ast::parse::Primitive","utf8::Utf8Sequences","hir::ClassUnicode","error::Formatter","ast::print::PrinterBuilder","ast::CaptureName","hir::Error","hir::translate::HirFrame","ast::ClassPerlKind","ast::ClassAsciiKind","hir::print::Printer","ast::RepetitionOp","ast::parse::Parser","ast::Concat","ast::visitor::ClassInduct","hir::ErrorKind","ast::ClassUnicode","unicode::ClassQuery","hir::interval::IntervalSet","unicode::Error","ast::ClassBracketed","ast::Comment","ast::Position","hir::translate::TranslatorBuilder","hir::Hir","ast::Assertion","ast::ClassSetRange","ast::ClassSetBinaryOp","hir::Group","ast::LiteralKind","hir::WordBoundary","ast::FlagsItemKind","ast::SpecialLiteralKind","hir::Literal","error::Error","ast::Ast","<*mut T as std::fmt::Debug>","hir::ClassBytesIter","ast::ClassAscii","ast::print::Writer","ast::ClassUnicodeOpKind","ast::parse::ParserI","ast::ClassSetBinaryOpKind","ast::SetFlags","ast::Group","hir::ClassUnicodeIter","ast::Flags","hir::HirKind","unicode::UnicodeWordError","ast::Flag","ast::ClassUnicodeKind","ast::parse::ParserBuilder","hir::Class","ast::Repetition","hir::ClassUnicodeRange","ast::parse::ClassState","either::Either","ast::ClassSetItem","ast::Alternation","ast::ClassPerl","parser::Parser","hir::print::Writer","ast::FlagsItem","ast::HexLiteralKind","hir::RepetitionRange","hir::literal::Literals","ast::parse::GroupState"]},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::sync::Arc<T>","<&T as std::fmt::Debug>","std::ffi::CString","std::boxed::Box<T, A>","std::string::String","std::path::PathBuf","std::rc::Rc<T>","std::vec::Vec<T, A>"]},"ast::parse::ParserI":{"P":["std::rc::Rc<T>","std::path::PathBuf","std::sync::Arc<T>","std::ffi::OsString","std::string::String","std::boxed::Box<T, A>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::ffi::CString"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["hir::Literal","ast::ErrorKind","ast::Literal","ast::Concat","ast::ClassSet","hir::Hir","hir::Class","ast::Flag","ast::SetFlags","ast::AssertionKind","ast::GroupKind","ast::FlagsItem","ast::CaptureName","error::Error","ast::HexLiteralKind","hir::Group","ast::ClassSetBinaryOp","ast::Comment","ast::RepetitionKind","ast::ClassSetBinaryOpKind","ast::ClassUnicodeKind","hir::GroupKind","hir::Anchor","ast::ClassPerlKind","ast::Ast","ast::parse::Primitive","hir::literal::Literals","ast::Flags","ast::ClassUnicode","hir::HirKind","ast::RepetitionRange","ast::SpecialLiteralKind","hir::WordBoundary","hir::literal::Literal","<*mut T as std::fmt::Debug>","ast::ClassUnicodeOpKind","ast::Group","utf8::Utf8Sequence","utf8::Utf8Range","hir::ErrorKind","ast::ClassAsciiKind","ast::Position","ast::ClassAscii","hir::HirInfo","ast::LiteralKind","ast::ClassSetUnion","ast::ClassPerl","ast::WithComments","ast::Error","hir::Repetition","hir::ClassUnicodeRange","hir::interval::IntervalSet","hir::ClassBytes","ast::ClassSetItem","ast::Span","hir::RepetitionKind","ast::Alternation","ast::Repetition","hir::ClassBytesRange","ast::ClassSetRange","hir::Error","hir::ClassUnicode","hir::RepetitionRange","either::Either","ast::RepetitionOp","ast::Class","ast::Assertion","ast::FlagsItemKind","ast::ClassBracketed"],"Right":["ast::parse::Primitive","utf8::Utf8Sequence","utf8::Utf8Range","error::Error","ast::ClassSet","ast::ClassSetRange","ast::Alternation","ast::ClassUnicode","ast::ClassSetUnion","ast::ClassUnicodeOpKind","hir::ClassUnicode","ast::ClassBracketed","ast::Ast","hir::interval::IntervalSet","hir::ErrorKind","ast::ClassPerl","ast::Class","ast::Concat","hir::ClassBytes","ast::WithComments","ast::ClassAscii","hir::RepetitionKind","hir::ClassBytesRange","ast::ErrorKind","hir::GroupKind","hir::Class","ast::Error","hir::Repetition","ast::HexLiteralKind","ast::ClassSetBinaryOp","ast::ClassUnicodeKind","ast::Literal","ast::Span","ast::FlagsItem","hir::Error","ast::Repetition","ast::Position","ast::ClassAsciiKind","ast::ClassSetItem","ast::GroupKind","ast::CaptureName","hir::HirInfo","ast::RepetitionKind","hir::RepetitionRange","ast::SpecialLiteralKind","ast::SetFlags","ast::RepetitionOp","ast::Comment","hir::WordBoundary","hir::Group","ast::Flag","ast::ClassSetBinaryOpKind","hir::ClassUnicodeRange","ast::Group","ast::RepetitionRange","ast::Flags","ast::FlagsItemKind","ast::Assertion","hir::Anchor","hir::literal::Literal","ast::LiteralKind","hir::literal::Literals","either::Either","hir::Hir","std::clone::impls::<impl std::clone::Clone for *const T>","ast::AssertionKind","hir::Literal","ast::ClassPerlKind","hir::HirKind"]},"error::Formatter":{"E":["hir::Error","hir::Hir","hir::ErrorKind","unicode::UnicodeWordError","ast::Error","<&T as std::fmt::Debug>","unicode::CaseFoldError","ast::Ast","error::Formatter","error::Error","ast::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["hir::Anchor","ast::Alternation","ast::ClassPerlKind","hir::ClassUnicodeRange","ast::RepetitionKind","either::Either","utf8::Utf8Sequences","ast::GroupKind","hir::ErrorKind","ast::ClassBracketed","hir::HirInfo","ast::FlagsItem","ast::visitor::ClassFrame","ast::ClassSet","ast::ClassUnicodeOpKind","ast::Ast","ast::Repetition","ast::SpecialLiteralKind","hir::print::Printer","ast::Error","hir::RepetitionKind","ast::Span","unicode::Error","ast::RepetitionOp","unicode::UnicodeWordError","ast::print::Printer","ast::FlagsItemKind","ast::ClassSetRange","hir::RepetitionRange","hir::ClassUnicodeIter","ast::parse::NestLimiter","ast::ClassSetUnion","hir::Repetition","hir::ClassBytesIter","parser::Parser","ast::ErrorKind","hir::ClassUnicode","ast::parse::ClassState","hir::interval::IntervalSetIter","<*const T as std::fmt::Debug>","ast::print::Writer","ast::Assertion","ast::ClassAscii","ast::parse::Primitive","unicode::CanonicalClassQuery","ast::visitor::ClassInduct","ast::SetFlags","ast::ClassSetItem","ast::ClassSetBinaryOp","hir::Error","parser::ParserBuilder","ast::Class","ast::ClassSetBinaryOpKind","ast::CaptureName","hir::WordBoundary","hir::print::Writer","ast::RepetitionRange","ast::ClassUnicode","ast::ClassPerl","ast::Literal","ast::Concat","ast::parse::Parser","hir::ClassBytes","hir::Group","ast::Position","utf8::Utf8Range","unicode::ClassQuery","ast::print::PrinterBuilder","hir::literal::Literal","ast::parse::ParserBuilder","ast::Flag","utf8::Utf8Sequence","ast::WithComments","error::Formatter","hir::GroupKind","hir::translate::Flags","hir::Class","hir::HirKind","ast::ClassAsciiKind","utf8::ScalarRange","hir::translate::HirFrame","hir::Hir","hir::Literal","hir::translate::Translator","ast::Comment","hir::literal::Literals","ast::parse::GroupState","hir::print::PrinterBuilder","ast::parse::ParserI","ast::Group","ast::Flags","hir::translate::TranslatorI","hir::interval::IntervalSet","ast::AssertionKind","ast::ClassUnicodeKind","ast::LiteralKind","error::Error","unicode::CaseFoldError","ast::HexLiteralKind","hir::ClassBytesRange","hir::translate::TranslatorBuilder"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSetIter<'a, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt(p0, p1);
+<hir::interval::IntervalSetIter<'a, I>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next
'a
deps:{"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":{"I":["std::marker::Sized"]}}
candidates:{"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":{"I":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSetIter<'a, I>
+p0.next();
+<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next(p0);
+crate::<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next(p0);
+<hir::interval::IntervalSetIter<'a, I>>::next(p0);
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::min_value
deps:{}
candidates:{}
+<u8 as hir::interval::Bound>::min_value();
+crate::<u8 as hir::interval::Bound>::min_value();
+<u8>::min_value();
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::max_value
deps:{}
candidates:{}
+<u8 as hir::interval::Bound>::max_value();
+crate::<u8 as hir::interval::Bound>::max_value();
+<u8>::max_value();
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::as_u32
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_u32();
+<u8 as hir::interval::Bound>::as_u32(p0);
+crate::<u8 as hir::interval::Bound>::as_u32(p0);
+<u8>::as_u32(p0);
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::increment
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.increment();
+<u8 as hir::interval::Bound>::increment(p0);
+crate::<u8 as hir::interval::Bound>::increment(p0);
+<u8>::increment(p0);
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::decrement
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.decrement();
+<u8 as hir::interval::Bound>::decrement(p0);
+crate::<u8 as hir::interval::Bound>::decrement(p0);
+<u8>::decrement(p0);
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::min_value
deps:{}
candidates:{}
+<char as hir::interval::Bound>::min_value();
+crate::<char as hir::interval::Bound>::min_value();
+<char>::min_value();
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::max_value
deps:{}
candidates:{}
+<char as hir::interval::Bound>::max_value();
+crate::<char as hir::interval::Bound>::max_value();
+<char>::max_value();
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::as_u32
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_u32();
+<char as hir::interval::Bound>::as_u32(p0);
+crate::<char as hir::interval::Bound>::as_u32(p0);
+<char>::as_u32(p0);
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::increment
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.increment();
+<char as hir::interval::Bound>::increment(p0);
+crate::<char as hir::interval::Bound>::increment(p0);
+<char>::increment(p0);
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::decrement
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.decrement();
+<char as hir::interval::Bound>::decrement(p0);
+crate::<char as hir::interval::Bound>::decrement(p0);
+<char>::decrement(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literals as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.clone();
+<hir::literal::Literals as std::clone::Clone>::clone(p0);
+crate::<hir::literal::Literals as std::clone::Clone>::clone(p0);
+<hir::literal::Literals>::clone(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literals as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.assert_receiver_is_total_eq();
+<hir::literal::Literals as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::literal::Literals as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::literal::Literals>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literals as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.eq(p1);
+<hir::literal::Literals as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::literal::Literals as std::cmp::PartialEq>::eq(p0, p1);
+<hir::literal::Literals>::eq(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.clone();
+<hir::literal::Literal as std::clone::Clone>::clone(p0);
+crate::<hir::literal::Literal as std::clone::Clone>::clone(p0);
+<hir::literal::Literal>::clone(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.assert_receiver_is_total_eq();
+<hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::literal::Literal>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.cmp(p1);
+<hir::literal::Literal as std::cmp::Ord>::cmp(p0, p1);
+crate::<hir::literal::Literal as std::cmp::Ord>::cmp(p0, p1);
+<hir::literal::Literal>::cmp(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::empty
deps:{}
candidates:{}
+hir::literal::Literals::empty();
+crate::hir::literal::Literals::empty();
+<hir::literal::Literals>::empty();
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+hir::literal::Literals::prefixes(p0);
+crate::hir::literal::Literals::prefixes(p0);
+<hir::literal::Literals>::prefixes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+hir::literal::Literals::suffixes(p0);
+crate::hir::literal::Literals::suffixes(p0);
+<hir::literal::Literals>::suffixes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::limit_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.limit_size();
+hir::literal::Literals::limit_size(p0);
+crate::hir::literal::Literals::limit_size(p0);
+<hir::literal::Literals>::limit_size(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::set_limit_size
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = 0usize; // None+usize
+p0.set_limit_size(p1);
+hir::literal::Literals::set_limit_size(p0, p1);
+crate::hir::literal::Literals::set_limit_size(p0, p1);
+<hir::literal::Literals>::set_limit_size(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::limit_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.limit_class();
+hir::literal::Literals::limit_class(p0);
+crate::hir::literal::Literals::limit_class(p0);
+<hir::literal::Literals>::limit_class(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::set_limit_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = 0usize; // None+usize
+p0.set_limit_class(p1);
+hir::literal::Literals::set_limit_class(p0, p1);
+crate::hir::literal::Literals::set_limit_class(p0, p1);
+<hir::literal::Literals>::set_limit_class(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::literals
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.literals();
+hir::literal::Literals::literals(p0);
+crate::hir::literal::Literals::literals(p0);
+<hir::literal::Literals>::literals(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::min_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.min_len();
+hir::literal::Literals::min_len(p0);
+crate::hir::literal::Literals::min_len(p0);
+<hir::literal::Literals>::min_len(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::all_complete
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.all_complete();
+hir::literal::Literals::all_complete(p0);
+crate::hir::literal::Literals::all_complete(p0);
+<hir::literal::Literals>::all_complete(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::any_complete
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.any_complete();
+hir::literal::Literals::any_complete(p0);
+crate::hir::literal::Literals::any_complete(p0);
+<hir::literal::Literals>::any_complete(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::contains_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.contains_empty();
+hir::literal::Literals::contains_empty(p0);
+crate::hir::literal::Literals::contains_empty(p0);
+<hir::literal::Literals>::contains_empty(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.is_empty();
+hir::literal::Literals::is_empty(p0);
+crate::hir::literal::Literals::is_empty(p0);
+<hir::literal::Literals>::is_empty(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::to_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.to_empty();
+hir::literal::Literals::to_empty(p0);
+crate::hir::literal::Literals::to_empty(p0);
+<hir::literal::Literals>::to_empty(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::longest_common_prefix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.longest_common_prefix();
+hir::literal::Literals::longest_common_prefix(p0);
+crate::hir::literal::Literals::longest_common_prefix(p0);
+<hir::literal::Literals>::longest_common_prefix(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::longest_common_suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.longest_common_suffix();
+hir::literal::Literals::longest_common_suffix(p0);
+crate::hir::literal::Literals::longest_common_suffix(p0);
+<hir::literal::Literals>::longest_common_suffix(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::trim_suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = 0usize; // None+usize
+p0.trim_suffix(p1);
+hir::literal::Literals::trim_suffix(p0, p1);
+crate::hir::literal::Literals::trim_suffix(p0, p1);
+<hir::literal::Literals>::trim_suffix(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::unambiguous_prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.unambiguous_prefixes();
+hir::literal::Literals::unambiguous_prefixes(p0);
+crate::hir::literal::Literals::unambiguous_prefixes(p0);
+<hir::literal::Literals>::unambiguous_prefixes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::unambiguous_suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.unambiguous_suffixes();
+hir::literal::Literals::unambiguous_suffixes(p0);
+crate::hir::literal::Literals::unambiguous_suffixes(p0);
+<hir::literal::Literals>::unambiguous_suffixes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::union_prefixes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.union_prefixes(p1);
+hir::literal::Literals::union_prefixes(p0, p1);
+crate::hir::literal::Literals::union_prefixes(p0, p1);
+<hir::literal::Literals>::union_prefixes(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::union_suffixes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.union_suffixes(p1);
+hir::literal::Literals::union_suffixes(p0, p1);
+crate::hir::literal::Literals::union_suffixes(p0, p1);
+<hir::literal::Literals>::union_suffixes(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.union(p1);
+hir::literal::Literals::union(p0, p1);
+crate::hir::literal::Literals::union(p0, p1);
+<hir::literal::Literals>::union(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::cross_product
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.cross_product(p1);
+hir::literal::Literals::cross_product(p0, p1);
+crate::hir::literal::Literals::cross_product(p0, p1);
+<hir::literal::Literals>::cross_product(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::cross_add
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.cross_add(p1);
+hir::literal::Literals::cross_add(p0, p1);
+crate::hir::literal::Literals::cross_add(p0, p1);
+<hir::literal::Literals>::cross_add(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::add
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.add(p1);
+hir::literal::Literals::add(p0, p1);
+crate::hir::literal::Literals::add(p0, p1);
+<hir::literal::Literals>::add(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::add_char_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.add_char_class(p1);
+hir::literal::Literals::add_char_class(p0, p1);
+crate::hir::literal::Literals::add_char_class(p0, p1);
+<hir::literal::Literals>::add_char_class(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::add_char_class_reverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.add_char_class_reverse(p1);
+hir::literal::Literals::add_char_class_reverse(p0, p1);
+crate::hir::literal::Literals::add_char_class_reverse(p0, p1);
+<hir::literal::Literals>::add_char_class_reverse(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::_add_char_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p2 = true; // None+bool
+p0._add_char_class(p1, p2);
+hir::literal::Literals::_add_char_class(p0, p1, p2);
+crate::hir::literal::Literals::_add_char_class(p0, p1, p2);
+<hir::literal::Literals>::_add_char_class(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::add_byte_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.add_byte_class(p1);
+hir::literal::Literals::add_byte_class(p0, p1);
+crate::hir::literal::Literals::add_byte_class(p0, p1);
+<hir::literal::Literals>::add_byte_class(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::cut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.cut();
+hir::literal::Literals::cut(p0);
+crate::hir::literal::Literals::cut(p0);
+<hir::literal::Literals>::cut(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::reverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.reverse();
+hir::literal::Literals::reverse(p0);
+crate::hir::literal::Literals::reverse(p0);
+<hir::literal::Literals>::reverse(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.clear();
+hir::literal::Literals::clear(p0);
+crate::hir::literal::Literals::clear(p0);
+<hir::literal::Literals>::clear(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::remove_complete
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.remove_complete();
+hir::literal::Literals::remove_complete(p0);
+crate::hir::literal::Literals::remove_complete(p0);
+<hir::literal::Literals>::remove_complete(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::num_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.num_bytes();
+hir::literal::Literals::num_bytes(p0);
+crate::hir::literal::Literals::num_bytes(p0);
+<hir::literal::Literals>::num_bytes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::class_exceeds_limits
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = 0usize; // None+usize
+p0.class_exceeds_limits(p1);
+hir::literal::Literals::class_exceeds_limits(p0, p1);
+crate::hir::literal::Literals::class_exceeds_limits(p0, p1);
+<hir::literal::Literals>::class_exceeds_limits(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literals as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::Literals as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::Literals as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::Literals>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literal::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+hir::literal::Literal::new(p0);
+crate::hir::literal::Literal::new(p0);
+<hir::literal::Literal>::new(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literal::empty
deps:{}
candidates:{}
+hir::literal::Literal::empty();
+crate::hir::literal::Literal::empty();
+<hir::literal::Literal>::empty();
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literal::is_cut
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.is_cut();
+hir::literal::Literal::is_cut(p0);
+crate::hir::literal::Literal::is_cut(p0);
+<hir::literal::Literal>::is_cut(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literal::cut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.cut();
+hir::literal::Literal::cut(p0);
+crate::hir::literal::Literal::cut(p0);
+<hir::literal::Literal>::cut(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.eq(p1);
+<hir::literal::Literal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::literal::Literal as std::cmp::PartialEq>::eq(p0, p1);
+<hir::literal::Literal>::eq(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.partial_cmp(p1);
+<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<hir::literal::Literal>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::Literal as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::Literal as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::Literal>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.as_ref();
+<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref(p0);
+crate::<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref(p0);
+<hir::literal::Literal>::as_ref(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.deref();
+<hir::literal::Literal as std::ops::Deref>::deref(p0);
+crate::<hir::literal::Literal as std::ops::Deref>::deref(p0);
+<hir::literal::Literal>::deref(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::ops::DerefMut>::deref_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.deref_mut();
+<hir::literal::Literal as std::ops::DerefMut>::deref_mut(p0);
+crate::<hir::literal::Literal as std::ops::DerefMut>::deref_mut(p0);
+<hir::literal::Literal>::deref_mut(p0);
-----------------
regex-syntax/src/hir/print.rs <hir::print::PrinterBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::PrinterBuilder
+p0.clone();
+<hir::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+crate::<hir::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+<hir::print::PrinterBuilder>::clone(p0);
-----------------
regex-syntax/src/hir/print.rs <hir::print::PrinterBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::PrinterBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+<hir::print::PrinterBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/print.rs <hir::print::PrinterBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<hir::print::PrinterBuilder as std::default::Default>::default();
+crate::<hir::print::PrinterBuilder as std::default::Default>::default();
+<hir::print::PrinterBuilder>::default();
-----------------
regex-syntax/src/hir/print.rs hir::print::PrinterBuilder::new
deps:{}
candidates:{}
+hir::print::PrinterBuilder::new();
+crate::hir::print::PrinterBuilder::new();
+<hir::print::PrinterBuilder>::new();
-----------------
regex-syntax/src/hir/print.rs hir::print::PrinterBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::PrinterBuilder
+p0.build();
+hir::print::PrinterBuilder::build(p0);
+crate::hir::print::PrinterBuilder::build(p0);
+<hir::print::PrinterBuilder>::build(p0);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Printer as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::Printer
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+<hir::print::Printer>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/print.rs hir::print::Printer::new
deps:{}
candidates:{}
+hir::print::Printer::new();
+crate::hir::print::Printer::new();
+<hir::print::Printer>::new();
-----------------
regex-syntax/src/hir/print.rs hir::print::Printer::print
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Printer::print":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Printer::print":{"W":["<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::fmt::Formatter<'_>","std::string::String","core::fmt::builders::PadAdapter<'_, '_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Printer
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p2 = MaybeUninit::uninit().assume_init(); // W
+p0.print(p1, p2);
+hir::print::Printer::print(p0, p1, p2);
+crate::hir::print::Printer::print(p0, p1, p2);
+<hir::print::Printer>::print(p0, p1, p2);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as std::fmt::Debug>::fmt
'p
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::print::Writer<'p, W> as std::fmt::Debug>::fmt":{"W":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"],"Right":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::cmp::PartialEq","hir::interval::Interval","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::print::Writer<'p, W> as std::fmt::Debug>::fmt":{"W":["ast::Ast","hir::HirKind","ast::ClassUnicodeKind","ast::print::Printer","ast::visitor::ClassInduct","hir::RepetitionRange","ast::parse::Primitive","ast::ClassUnicodeOpKind","hir::ClassUnicodeIter","hir::Class","ast::LiteralKind","utf8::ScalarRange","hir::ClassBytes","ast::Class","ast::Flag","hir::translate::TranslatorI","ast::WithComments","hir::print::PrinterBuilder","ast::HexLiteralKind","ast::CaptureName","ast::ErrorKind","hir::Hir","hir::literal::Literals","ast::ClassUnicode","hir::Literal","ast::Concat","ast::ClassPerl","unicode::CaseFoldError","ast::Comment","ast::GroupKind","ast::ClassSetRange","ast::Literal","utf8::Utf8Sequence","hir::print::Printer","ast::visitor::ClassFrame","ast::FlagsItem","hir::interval::IntervalSetIter","hir::literal::Literal","ast::Assertion","hir::translate::HirFrame","hir::ClassUnicodeRange","hir::WordBoundary","<*mut T as std::fmt::Debug>","ast::Flags","ast::parse::ParserI","hir::Group","ast::parse::ParserBuilder","<&mut T as std::fmt::Debug>","hir::translate::Translator","hir::GroupKind","ast::print::PrinterBuilder","hir::translate::Flags","ast::Error","ast::ClassBracketed","hir::HirInfo","ast::ClassSetItem","ast::ClassPerlKind","ast::Repetition","ast::parse::NestLimiter","hir::print::Writer","ast::ClassAsciiKind","utf8::Utf8Sequences","utf8::Utf8Range","unicode::CanonicalClassQuery","ast::ClassAscii","ast::ClassSetBinaryOpKind","ast::parse::ClassState","ast::SpecialLiteralKind","error::Error","hir::interval::IntervalSet","ast::ClassSetUnion","ast::AssertionKind","ast::SetFlags","ast::Group","ast::Span","hir::ErrorKind","unicode::ClassQuery","hir::RepetitionKind","ast::print::Writer","parser::ParserBuilder","hir::translate::TranslatorBuilder","ast::Position","ast::FlagsItemKind","hir::ClassBytesRange","hir::ClassBytesIter","unicode::Error","ast::RepetitionOp","ast::ClassSet","ast::RepetitionRange","parser::Parser","unicode::UnicodeWordError","ast::parse::GroupState","ast::Alternation","either::Either","hir::ClassUnicode","ast::parse::Parser","error::Formatter","ast::RepetitionKind","ast::ClassSetBinaryOp","hir::Error","hir::Anchor","hir::Repetition"]},"ast::parse::NestLimiter":{"P":["std::rc::Rc<T>","std::ffi::OsString","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::path::PathBuf"]},"ast::parse::ParserI":{"P":["std::string::String","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::OsString","std::boxed::Box<T, A>","std::sync::Arc<T>","<&mut T as std::fmt::Debug>","std::rc::Rc<T>","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["hir::literal::Literals","ast::ErrorKind","hir::RepetitionKind","hir::Repetition","hir::GroupKind","ast::Literal","ast::ClassSetBinaryOp","ast::Concat","ast::RepetitionOp","ast::GroupKind","hir::ErrorKind","ast::SetFlags","ast::Flag","hir::HirInfo","ast::FlagsItem","ast::ClassSetBinaryOpKind","ast::ClassSetItem","hir::ClassUnicode","hir::ClassBytesRange","ast::Ast","hir::Class","utf8::Utf8Range","ast::ClassPerlKind","ast::Flags","ast::CaptureName","hir::Literal","ast::ClassSetRange","hir::RepetitionRange","hir::HirKind","hir::ClassBytes","ast::ClassUnicodeOpKind","hir::interval::IntervalSet","ast::ClassAscii","ast::RepetitionRange","ast::LiteralKind","ast::Group","ast::ClassBracketed","ast::Span","ast::ClassSet","ast::ClassPerl","hir::Error","ast::ClassUnicode","hir::WordBoundary","ast::ClassUnicodeKind","ast::ClassAsciiKind","utf8::Utf8Sequence","ast::AssertionKind","ast::FlagsItemKind","ast::ClassSetUnion","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","hir::ClassUnicodeRange","either::Either","ast::Alternation","ast::Assertion","ast::Position","ast::Class","hir::literal::Literal","error::Error","hir::Hir","ast::WithComments","ast::parse::Primitive","ast::SpecialLiteralKind","ast::HexLiteralKind","hir::Group","ast::RepetitionKind","ast::Comment","hir::Anchor","ast::Error","ast::Repetition"],"Right":["hir::RepetitionKind","ast::Repetition","ast::ClassSet","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","utf8::Utf8Range","ast::RepetitionOp","hir::HirInfo","ast::Comment","ast::ClassBracketed","ast::ClassUnicodeKind","hir::ClassBytes","ast::WithComments","ast::Group","ast::AssertionKind","ast::ClassPerl","hir::Class","ast::RepetitionRange","error::Error","ast::Flag","ast::GroupKind","hir::RepetitionRange","hir::literal::Literals","ast::HexLiteralKind","ast::ClassSetBinaryOpKind","ast::Ast","ast::RepetitionKind","hir::ClassUnicode","ast::SpecialLiteralKind","ast::ClassAsciiKind","ast::ClassSetRange","ast::Position","hir::Literal","ast::ClassSetItem","ast::ClassSetBinaryOp","hir::ErrorKind","ast::FlagsItem","ast::Literal","hir::Hir","hir::Repetition","hir::literal::Literal","ast::parse::Primitive","hir::WordBoundary","either::Either","ast::SetFlags","hir::interval::IntervalSet","hir::ClassBytesRange","hir::HirKind","ast::FlagsItemKind","hir::ClassUnicodeRange","ast::Alternation","hir::Error","ast::ClassPerlKind","ast::Error","hir::GroupKind","ast::ClassSetUnion","ast::Class","hir::Group","ast::LiteralKind","ast::ErrorKind","hir::Anchor","ast::CaptureName","ast::Span","ast::Assertion","utf8::Utf8Sequence","ast::ClassUnicode","ast::ClassUnicodeOpKind","ast::Concat","ast::ClassAscii","ast::Flags"]},"error::Formatter":{"E":["unicode::CaseFoldError","hir::ErrorKind","unicode::UnicodeWordError","hir::Hir","error::Error","ast::Error","ast::ErrorKind","hir::Error","<&T as std::fmt::Debug>","ast::Ast","error::Formatter"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::ClassAscii","ast::Repetition","hir::interval::IntervalSet","hir::ClassUnicodeIter","hir::Group","utf8::Utf8Sequences","hir::Repetition","ast::RepetitionRange","ast::AssertionKind","ast::CaptureName","unicode::Error","parser::Parser","hir::ClassBytes","hir::GroupKind","hir::ClassUnicodeRange","ast::ClassSetRange","ast::Flags","ast::Error","ast::HexLiteralKind","unicode::UnicodeWordError","hir::translate::TranslatorBuilder","ast::parse::Parser","hir::ClassBytesRange","ast::SetFlags","hir::HirInfo","ast::Comment","ast::ClassAsciiKind","ast::FlagsItem","ast::parse::Primitive","ast::GroupKind","ast::parse::GroupState","ast::ClassUnicodeKind","utf8::ScalarRange","hir::Anchor","ast::ClassSetBinaryOp","ast::RepetitionKind","ast::parse::ParserBuilder","hir::Error","ast::parse::ClassState","ast::Assertion","unicode::CanonicalClassQuery","ast::ErrorKind","hir::WordBoundary","hir::translate::Flags","hir::print::Printer","ast::ClassSetItem","ast::Alternation","ast::ClassUnicode","ast::print::Writer","unicode::ClassQuery","ast::parse::NestLimiter","hir::translate::TranslatorI","error::Formatter","ast::Class","utf8::Utf8Sequence","hir::HirKind","ast::Concat","ast::ClassBracketed","ast::WithComments","hir::Class","ast::ClassSet","ast::visitor::ClassFrame","ast::SpecialLiteralKind","ast::Ast","parser::ParserBuilder","unicode::CaseFoldError","ast::Flag","hir::interval::IntervalSetIter","<&T as std::fmt::Debug>","hir::ClassUnicode","ast::Span","ast::print::PrinterBuilder","ast::Literal","ast::visitor::ClassInduct","hir::RepetitionRange","hir::Literal","hir::translate::Translator","hir::Hir","ast::ClassSetUnion","either::Either","ast::Position","ast::parse::ParserI","ast::print::Printer","ast::ClassPerl","error::Error","ast::FlagsItemKind","ast::ClassUnicodeOpKind","utf8::Utf8Range","hir::ClassBytesIter","ast::RepetitionOp","hir::literal::Literal","hir::ErrorKind","ast::ClassSetBinaryOpKind","hir::print::PrinterBuilder","hir::literal::Literals","ast::LiteralKind","hir::RepetitionKind","hir::translate::HirFrame","hir::print::Writer","ast::Group","ast::ClassPerlKind"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::print::Writer<'p, W> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::print::Writer<'p, W> as std::fmt::Debug>::fmt(p0, p1);
+<hir::print::Writer<'p, W>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish
'p
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>","std::ffi::OsString","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::string::String"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
+p0.finish();
+<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish(p0);
+crate::<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish(p0);
+<hir::print::Writer<'p, W>>::finish(p0);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre":{"W":["std::error::Indented<'_, T>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_pre(p1);
+<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre(p0, p1);
+crate::<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre(p0, p1);
+<hir::print::Writer<'p, W>>::visit_pre(p0, p1);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post":{"W":["std::ffi::OsString","std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_post(p1);
+<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post(p0, p1);
+crate::<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post(p0, p1);
+<hir::print::Writer<'p, W>>::visit_post(p0, p1);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in
'p
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","std::fmt::Formatter<'_>","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::error::Indented<'_, T>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
+p0.visit_alternation_in();
+<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in(p0);
+crate::<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in(p0);
+<hir::print::Writer<'p, W>>::visit_alternation_in(p0);
-----------------
regex-syntax/src/hir/print.rs hir::print::Writer::<'p, W>::write_literal_char
'p
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_char":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_char":{"W":["std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>","std::error::Indented<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::string::String","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = 'a'; // None+char
+p0.write_literal_char(p1);
+hir::print::Writer::<'p, W>::write_literal_char(p0, p1);
+crate::hir::print::Writer::<'p, W>::write_literal_char(p0, p1);
+<hir::print::Writer<'p, W>>::write_literal_char(p0, p1);
-----------------
regex-syntax/src/hir/print.rs hir::print::Writer::<'p, W>::write_literal_byte
'p
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_byte":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_byte":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = 0u8; // None+u8
+p0.write_literal_byte(p1);
+hir::print::Writer::<'p, W>::write_literal_byte(p0, p1);
+crate::hir::print::Writer::<'p, W>::write_literal_byte(p0, p1);
+<hir::print::Writer<'p, W>>::write_literal_byte(p0, p1);
-----------------
regex-syntax/src/hir/print.rs hir::print::Writer::<'p, W>::write_literal_class_byte
'p
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_class_byte":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_class_byte":{"W":["std::string::String","std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = 0u8; // None+u8
+p0.write_literal_class_byte(p1);
+hir::print::Writer::<'p, W>::write_literal_class_byte(p0, p1);
+crate::hir::print::Writer::<'p, W>::write_literal_class_byte(p0, p1);
+<hir::print::Writer<'p, W>>::write_literal_class_byte(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
+p0.clone();
+<hir::translate::TranslatorBuilder as std::clone::Clone>::clone(p0);
+crate::<hir::translate::TranslatorBuilder as std::clone::Clone>::clone(p0);
+<hir::translate::TranslatorBuilder>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::TranslatorBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<hir::translate::TranslatorBuilder as std::default::Default>::default();
+crate::<hir::translate::TranslatorBuilder as std::default::Default>::default();
+<hir::translate::TranslatorBuilder>::default();
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::new
deps:{}
candidates:{}
+hir::translate::TranslatorBuilder::new();
+crate::hir::translate::TranslatorBuilder::new();
+<hir::translate::TranslatorBuilder>::new();
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
+p0.build();
+hir::translate::TranslatorBuilder::build(p0);
+crate::hir::translate::TranslatorBuilder::build(p0);
+<hir::translate::TranslatorBuilder>::build(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::allow_invalid_utf8
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.allow_invalid_utf8(p1);
+hir::translate::TranslatorBuilder::allow_invalid_utf8(p0, p1);
+crate::hir::translate::TranslatorBuilder::allow_invalid_utf8(p0, p1);
+<hir::translate::TranslatorBuilder>::allow_invalid_utf8(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+hir::translate::TranslatorBuilder::case_insensitive(p0, p1);
+crate::hir::translate::TranslatorBuilder::case_insensitive(p0, p1);
+<hir::translate::TranslatorBuilder>::case_insensitive(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+hir::translate::TranslatorBuilder::multi_line(p0, p1);
+crate::hir::translate::TranslatorBuilder::multi_line(p0, p1);
+<hir::translate::TranslatorBuilder>::multi_line(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+hir::translate::TranslatorBuilder::dot_matches_new_line(p0, p1);
+crate::hir::translate::TranslatorBuilder::dot_matches_new_line(p0, p1);
+<hir::translate::TranslatorBuilder>::dot_matches_new_line(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+hir::translate::TranslatorBuilder::swap_greed(p0, p1);
+crate::hir::translate::TranslatorBuilder::swap_greed(p0, p1);
+<hir::translate::TranslatorBuilder>::swap_greed(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+hir::translate::TranslatorBuilder::unicode(p0, p1);
+crate::hir::translate::TranslatorBuilder::unicode(p0, p1);
+<hir::translate::TranslatorBuilder>::unicode(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Translator as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Translator
+p0.clone();
+<hir::translate::Translator as std::clone::Clone>::clone(p0);
+crate::<hir::translate::Translator as std::clone::Clone>::clone(p0);
+<hir::translate::Translator>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Translator as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Translator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::Translator as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::Translator as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::Translator>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Translator::new
deps:{}
candidates:{}
+hir::translate::Translator::new();
+crate::hir::translate::Translator::new();
+<hir::translate::Translator>::new();
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Translator::translate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::Translator
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.translate(&p1, p2);
+hir::translate::Translator::translate(p0, &p1, p2);
+crate::hir::translate::Translator::translate(p0, &p1, p2);
+<hir::translate::Translator>::translate(p0, &p1, p2);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::HirFrame as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.clone();
+<hir::translate::HirFrame as std::clone::Clone>::clone(p0);
+crate::<hir::translate::HirFrame as std::clone::Clone>::clone(p0);
+<hir::translate::HirFrame>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::HirFrame as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::HirFrame as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::HirFrame as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::HirFrame>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::HirFrame::unwrap_expr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_expr();
+hir::translate::HirFrame::unwrap_expr(p0);
+crate::hir::translate::HirFrame::unwrap_expr(p0);
+<hir::translate::HirFrame>::unwrap_expr(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::HirFrame::unwrap_class_unicode
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_class_unicode();
+hir::translate::HirFrame::unwrap_class_unicode(p0);
+crate::hir::translate::HirFrame::unwrap_class_unicode(p0);
+<hir::translate::HirFrame>::unwrap_class_unicode(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::HirFrame::unwrap_class_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_class_bytes();
+hir::translate::HirFrame::unwrap_class_bytes(p0);
+crate::hir::translate::HirFrame::unwrap_class_bytes(p0);
+<hir::translate::HirFrame>::unwrap_class_bytes(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::HirFrame::unwrap_group
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_group();
+hir::translate::HirFrame::unwrap_group(p0);
+crate::hir::translate::HirFrame::unwrap_group(p0);
+<hir::translate::HirFrame>::unwrap_group(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish
't,'p
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.finish();
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish(p0);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish(p0);
+<hir::translate::TranslatorI<'t, 'p>>::finish(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_pre(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_post(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_item_pre(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_item_post(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_pre(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_binary_op_pre(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_in(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_binary_op_in(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_post(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_binary_op_post(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.clone();
+<hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone(p0);
+crate::<hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone(p0);
+<hir::translate::TranslatorI<'t, 'p>>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::new
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Translator
let mut p1 = "sample"; // None+&str
+hir::translate::TranslatorI::<'t, 'p>::new(p0, &p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::new(p0, &p1);
+<hir::translate::TranslatorI<'t, 'p>>::new(p0, &p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::trans
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.trans();
+hir::translate::TranslatorI::<'t, 'p>::trans(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::trans(p0);
+<hir::translate::TranslatorI<'t, 'p>>::trans(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::push
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.push(p1);
+hir::translate::TranslatorI::<'t, 'p>::push(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::push(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::push(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::pop
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.pop();
+hir::translate::TranslatorI::<'t, 'p>::pop(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::pop(p0);
+<hir::translate::TranslatorI<'t, 'p>>::pop(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::error
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.error(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::error(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::error(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::error(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::flags
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.flags();
+hir::translate::TranslatorI::<'t, 'p>::flags(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::flags(p0);
+<hir::translate::TranslatorI<'t, 'p>>::flags(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::set_flags
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.set_flags(p1);
+hir::translate::TranslatorI::<'t, 'p>::set_flags(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::set_flags(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::set_flags(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_literal
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.hir_literal(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_literal(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_literal(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_literal(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::literal_to_char
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.literal_to_char(p1);
+hir::translate::TranslatorI::<'t, 'p>::literal_to_char(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::literal_to_char(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::literal_to_char(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_from_char
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = 'a'; // None+char
+p0.hir_from_char(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_from_char(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_from_char(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_from_char(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_from_char_case_insensitive
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = 'a'; // None+char
+p0.hir_from_char_case_insensitive(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_from_char_case_insensitive(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_from_char_case_insensitive(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_from_char_case_insensitive(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_dot
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
+p0.hir_dot(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_dot(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_dot(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_dot(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_assertion
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.hir_assertion(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_assertion(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_assertion(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_assertion(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_group
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
let mut p2 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.hir_group(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_group(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_group(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_group(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_repetition
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
let mut p2 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.hir_repetition(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_repetition(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_repetition(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_repetition(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.hir_unicode_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_unicode_class(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.hir_perl_unicode_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_perl_unicode_class(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.hir_perl_byte_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_perl_byte_class(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = MaybeUninit::uninit().assume_init(); // std::result::Result<hir::ClassUnicode, unicode::Error>
+p0.convert_unicode_class_error(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::convert_unicode_class_error(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = true; // None+bool
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.unicode_fold_and_negate(p1, p2, p3);
+hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate(p0, p1, p2, p3);
+crate::hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate(p0, p1, p2, p3);
+<hir::translate::TranslatorI<'t, 'p>>::unicode_fold_and_negate(p0, p1, p2, p3);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = true; // None+bool
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.bytes_fold_and_negate(p1, p2, p3);
+hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate(p0, p1, p2, p3);
+crate::hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate(p0, p1, p2, p3);
+<hir::translate::TranslatorI<'t, 'p>>::bytes_fold_and_negate(p0, p1, p2, p3);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::class_literal_byte
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.class_literal_byte(p1);
+hir::translate::TranslatorI::<'t, 'p>::class_literal_byte(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::class_literal_byte(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::class_literal_byte(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Flags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.clone();
+<hir::translate::Flags as std::clone::Clone>::clone(p0);
+crate::<hir::translate::Flags as std::clone::Clone>::clone(p0);
+<hir::translate::Flags>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Flags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::Flags as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::Flags as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::Flags>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Flags as std::default::Default>::default
deps:{}
candidates:{}
+<hir::translate::Flags as std::default::Default>::default();
+crate::<hir::translate::Flags as std::default::Default>::default();
+<hir::translate::Flags>::default();
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::from_ast
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+hir::translate::Flags::from_ast(p0);
+crate::hir::translate::Flags::from_ast(p0);
+<hir::translate::Flags>::from_ast(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::merge
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::Flags
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.merge(p1);
+hir::translate::Flags::merge(p0, p1);
+crate::hir::translate::Flags::merge(p0, p1);
+<hir::translate::Flags>::merge(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::case_insensitive
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.case_insensitive();
+hir::translate::Flags::case_insensitive(p0);
+crate::hir::translate::Flags::case_insensitive(p0);
+<hir::translate::Flags>::case_insensitive(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::multi_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.multi_line();
+hir::translate::Flags::multi_line(p0);
+crate::hir::translate::Flags::multi_line(p0);
+<hir::translate::Flags>::multi_line(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.dot_matches_new_line();
+hir::translate::Flags::dot_matches_new_line(p0);
+crate::hir::translate::Flags::dot_matches_new_line(p0);
+<hir::translate::Flags>::dot_matches_new_line(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::swap_greed
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.swap_greed();
+hir::translate::Flags::swap_greed(p0);
+crate::hir::translate::Flags::swap_greed(p0);
+<hir::translate::Flags>::swap_greed(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::unicode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.unicode();
+hir::translate::Flags::unicode(p0);
+crate::hir::translate::Flags::unicode(p0);
+<hir::translate::Flags>::unicode(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::new
'a
deps:{}
candidates:{}
+hir::visitor::HeapVisitor::<'a>::new();
+crate::hir::visitor::HeapVisitor::<'a>::new();
+<hir::visitor::HeapVisitor<'a>>::new();
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::visit
'a
deps:{"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"hir::visitor::HeapVisitor::<'a>::visit":{"V":["hir::visitor::Visitor","std::marker::Sized"]}}
candidates:{"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"hir::visitor::HeapVisitor::<'a>::visit":{"V":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.visit(p1, p2);
+hir::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+crate::hir::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+<hir::visitor::HeapVisitor<'a>>::visit(p0, p1, p2);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::induct
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.induct(p1);
+hir::visitor::HeapVisitor::<'a>::induct(p0, p1);
+crate::hir::visitor::HeapVisitor::<'a>::induct(p0, p1);
+<hir::visitor::HeapVisitor<'a>>::induct(p0, p1);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::pop
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::visitor::HeapVisitor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::visitor::Frame<'a>
+p0.pop(p1);
+hir::visitor::HeapVisitor::<'a>::pop(p0, p1);
+crate::hir::visitor::HeapVisitor::<'a>::pop(p0, p1);
+<hir::visitor::HeapVisitor<'a>>::pop(p0, p1);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Frame::<'a>::child
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::visitor::Frame<'a>
+p0.child();
+hir::visitor::Frame::<'a>::child(p0);
+crate::hir::visitor::Frame::<'a>::child(p0);
+<hir::visitor::Frame<'a>>::child(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.clone();
+<hir::Error as std::clone::Clone>::clone(p0);
+crate::<hir::Error as std::clone::Clone>::clone(p0);
+<hir::Error>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Error as std::fmt::Debug>::fmt(p0, p1);
+<hir::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.assert_receiver_is_total_eq();
+<hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Error>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.eq(p1);
+<hir::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Error as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Error>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Error::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.kind();
+hir::Error::kind(p0);
+crate::hir::Error::kind(p0);
+<hir::Error>::kind(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Error::pattern
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.pattern();
+hir::Error::pattern(p0);
+crate::hir::Error::pattern(p0);
+<hir::Error>::pattern(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Error::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.span();
+hir::Error::span(p0);
+crate::hir::Error::span(p0);
+<hir::Error>::span(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.clone();
+<hir::ErrorKind as std::clone::Clone>::clone(p0);
+crate::<hir::ErrorKind as std::clone::Clone>::clone(p0);
+<hir::ErrorKind>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::ErrorKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.assert_receiver_is_total_eq();
+<hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.eq(p1);
+<hir::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ErrorKind>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ErrorKind::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.description();
+hir::ErrorKind::description(p0);
+crate::hir::ErrorKind::description(p0);
+<hir::ErrorKind>::description(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.description();
+<hir::Error as std::error::Error>::description(p0);
+crate::<hir::Error as std::error::Error>::description(p0);
+<hir::Error>::description(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<hir::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<hir::Error as std::fmt::Display>::fmt(p0, p1);
+<hir::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<hir::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+crate::<hir::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+<hir::ErrorKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.clone();
+<hir::Hir as std::clone::Clone>::clone(p0);
+crate::<hir::Hir as std::clone::Clone>::clone(p0);
+<hir::Hir>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Hir as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Hir as std::fmt::Debug>::fmt(p0, p1);
+<hir::Hir>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.assert_receiver_is_total_eq();
+<hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Hir>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.eq(p1);
+<hir::Hir as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Hir as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Hir>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.clone();
+<hir::HirKind as std::clone::Clone>::clone(p0);
+crate::<hir::HirKind as std::clone::Clone>::clone(p0);
+<hir::HirKind>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::HirKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::HirKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::HirKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.assert_receiver_is_total_eq();
+<hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::HirKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.eq(p1);
+<hir::HirKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::HirKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::HirKind>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.kind();
+hir::Hir::kind(p0);
+crate::hir::Hir::kind(p0);
+<hir::Hir>::kind(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::into_kind
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.into_kind();
+hir::Hir::into_kind(p0);
+crate::hir::Hir::into_kind(p0);
+<hir::Hir>::into_kind(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::empty
deps:{}
candidates:{}
+hir::Hir::empty();
+crate::hir::Hir::empty();
+<hir::Hir>::empty();
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::literal
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Literal
+hir::Hir::literal(p0);
+crate::hir::Hir::literal(p0);
+<hir::Hir>::literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::class
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Class
+hir::Hir::class(p0);
+crate::hir::Hir::class(p0);
+<hir::Hir>::class(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::anchor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Anchor
+hir::Hir::anchor(p0);
+crate::hir::Hir::anchor(p0);
+<hir::Hir>::anchor(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::word_boundary
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+hir::Hir::word_boundary(p0);
+crate::hir::Hir::word_boundary(p0);
+<hir::Hir>::word_boundary(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::repetition
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Repetition
+hir::Hir::repetition(p0);
+crate::hir::Hir::repetition(p0);
+<hir::Hir>::repetition(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::group
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Group
+hir::Hir::group(p0);
+crate::hir::Hir::group(p0);
+<hir::Hir>::group(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::concat
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::Hir>
+hir::Hir::concat(p0);
+crate::hir::Hir::concat(p0);
+<hir::Hir>::concat(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::alternation
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::Hir>
+hir::Hir::alternation(p0);
+crate::hir::Hir::alternation(p0);
+<hir::Hir>::alternation(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::dot
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+hir::Hir::dot(p0);
+crate::hir::Hir::dot(p0);
+<hir::Hir>::dot(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::any
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+hir::Hir::any(p0);
+crate::hir::Hir::any(p0);
+<hir::Hir>::any(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_always_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_always_utf8();
+hir::Hir::is_always_utf8(p0);
+crate::hir::Hir::is_always_utf8(p0);
+<hir::Hir>::is_always_utf8(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_all_assertions
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_all_assertions();
+hir::Hir::is_all_assertions(p0);
+crate::hir::Hir::is_all_assertions(p0);
+<hir::Hir>::is_all_assertions(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_anchored_start();
+hir::Hir::is_anchored_start(p0);
+crate::hir::Hir::is_anchored_start(p0);
+<hir::Hir>::is_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_anchored_end();
+hir::Hir::is_anchored_end(p0);
+crate::hir::Hir::is_anchored_end(p0);
+<hir::Hir>::is_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_line_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_line_anchored_start();
+hir::Hir::is_line_anchored_start(p0);
+crate::hir::Hir::is_line_anchored_start(p0);
+<hir::Hir>::is_line_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_line_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_line_anchored_end();
+hir::Hir::is_line_anchored_end(p0);
+crate::hir::Hir::is_line_anchored_end(p0);
+<hir::Hir>::is_line_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_any_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_any_anchored_start();
+hir::Hir::is_any_anchored_start(p0);
+crate::hir::Hir::is_any_anchored_start(p0);
+<hir::Hir>::is_any_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_any_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_any_anchored_end();
+hir::Hir::is_any_anchored_end(p0);
+crate::hir::Hir::is_any_anchored_end(p0);
+<hir::Hir>::is_any_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_match_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_match_empty();
+hir::Hir::is_match_empty(p0);
+crate::hir::Hir::is_match_empty(p0);
+<hir::Hir>::is_match_empty(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_literal();
+hir::Hir::is_literal(p0);
+crate::hir::Hir::is_literal(p0);
+<hir::Hir>::is_literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_alternation_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_alternation_literal();
+hir::Hir::is_alternation_literal(p0);
+crate::hir::Hir::is_alternation_literal(p0);
+<hir::Hir>::is_alternation_literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirKind::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.is_empty();
+hir::HirKind::is_empty(p0);
+crate::hir::HirKind::is_empty(p0);
+<hir::HirKind>::is_empty(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirKind::has_subexprs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.has_subexprs();
+hir::HirKind::has_subexprs(p0);
+crate::hir::HirKind::has_subexprs(p0);
+<hir::HirKind>::has_subexprs(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<hir::Hir as std::fmt::Display>::fmt(p0, p1);
+crate::<hir::Hir as std::fmt::Display>::fmt(p0, p1);
+<hir::Hir>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Literal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.clone();
+<hir::Literal as std::clone::Clone>::clone(p0);
+crate::<hir::Literal as std::clone::Clone>::clone(p0);
+<hir::Literal>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Literal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Literal as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Literal as std::fmt::Debug>::fmt(p0, p1);
+<hir::Literal>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.assert_receiver_is_total_eq();
+<hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Literal>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Literal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.eq(p1);
+<hir::Literal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Literal as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Literal>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Literal::is_unicode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.is_unicode();
+hir::Literal::is_unicode(p0);
+crate::hir::Literal::is_unicode(p0);
+<hir::Literal>::is_unicode(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Class as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.clone();
+<hir::Class as std::clone::Clone>::clone(p0);
+crate::<hir::Class as std::clone::Clone>::clone(p0);
+<hir::Class>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Class as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Class as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Class as std::fmt::Debug>::fmt(p0, p1);
+<hir::Class>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.assert_receiver_is_total_eq();
+<hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Class>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Class as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.eq(p1);
+<hir::Class as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Class as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Class>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Class::case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Class
+p0.case_fold_simple();
+hir::Class::case_fold_simple(p0);
+crate::hir::Class::case_fold_simple(p0);
+<hir::Class>::case_fold_simple(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Class::negate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Class
+p0.negate();
+hir::Class::negate(p0);
+crate::hir::Class::negate(p0);
+<hir::Class>::negate(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Class::is_always_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.is_always_utf8();
+hir::Class::is_always_utf8(p0);
+crate::hir::Class::is_always_utf8(p0);
+<hir::Class>::is_always_utf8(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicode as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.clone();
+<hir::ClassUnicode as std::clone::Clone>::clone(p0);
+crate::<hir::ClassUnicode as std::clone::Clone>::clone(p0);
+<hir::ClassUnicode>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicode as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassUnicode>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.assert_receiver_is_total_eq();
+<hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassUnicode>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicode as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.eq(p1);
+<hir::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassUnicode>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"either::Either":{"Left":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"],"Right":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::ClassUnicode::new":{"I":["std::iter::IntoIterator","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","hir::interval::Interval","std::clone::Clone"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["<&mut I as std::iter::Iterator>","hir::interval::IntervalSetIter","hir::ClassUnicodeIter","hir::ClassBytesIter","utf8::Utf8Sequences"]},"ast::parse::NestLimiter":{"P":["std::sync::Arc<T>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::CString","std::path::PathBuf","std::ffi::OsString","std::string::String","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>"]},"ast::parse::ParserI":{"P":["std::ffi::CString","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::path::PathBuf","std::rc::Rc<T>","std::string::String","std::ffi::OsString","std::sync::Arc<T>","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::ClassSetUnion","hir::Repetition","ast::SetFlags","ast::Concat","hir::interval::IntervalSet","hir::ClassUnicode","ast::ClassPerl","ast::ClassSetBinaryOpKind","ast::ClassSetRange","ast::Class","ast::RepetitionRange","hir::Literal","ast::LiteralKind","hir::HirKind","ast::Error","hir::RepetitionKind","hir::Group","hir::GroupKind","ast::GroupKind","ast::RepetitionOp","ast::ClassUnicodeOpKind","ast::Assertion","hir::HirInfo","ast::ClassAsciiKind","ast::Span","hir::RepetitionRange","ast::ClassSetItem","hir::literal::Literal","hir::ClassBytesRange","ast::Alternation","ast::HexLiteralKind","hir::ErrorKind","ast::Repetition","ast::Flag","hir::Class","error::Error","ast::ClassAscii","ast::ClassSet","ast::ClassSetBinaryOp","ast::CaptureName","<*const T as std::fmt::Debug>","ast::AssertionKind","hir::Anchor","hir::Hir","ast::Literal","ast::parse::Primitive","hir::literal::Literals","hir::ClassUnicodeRange","ast::Comment","ast::FlagsItemKind","hir::WordBoundary","ast::Flags","ast::SpecialLiteralKind","utf8::Utf8Sequence","ast::ClassBracketed","ast::Group","ast::RepetitionKind","ast::WithComments","ast::FlagsItem","ast::Ast","ast::Position","ast::ClassUnicode","ast::ClassPerlKind","either::Either","hir::ClassBytes","ast::ClassUnicodeKind","utf8::Utf8Range","hir::Error","ast::ErrorKind"],"Right":["hir::ClassUnicodeRange","hir::Repetition","hir::WordBoundary","hir::Group","hir::literal::Literal","ast::ClassSetUnion","hir::Hir","ast::Literal","ast::Comment","ast::ClassAscii","ast::ClassSetItem","ast::SetFlags","ast::RepetitionOp","utf8::Utf8Range","ast::Ast","ast::ClassUnicode","hir::HirKind","ast::Class","hir::ClassUnicode","hir::literal::Literals","ast::Group","ast::Assertion","ast::ClassAsciiKind","utf8::Utf8Sequence","ast::Alternation","<*const T as std::fmt::Debug>","ast::WithComments","ast::RepetitionRange","hir::Error","ast::AssertionKind","ast::Position","hir::Anchor","hir::RepetitionRange","ast::RepetitionKind","ast::HexLiteralKind","ast::FlagsItemKind","ast::CaptureName","hir::Literal","hir::HirInfo","hir::Class","hir::interval::IntervalSet","ast::ClassUnicodeOpKind","ast::ClassSetRange","ast::Flags","ast::Concat","ast::ClassPerl","ast::LiteralKind","ast::ClassSet","ast::FlagsItem","error::Error","ast::Span","ast::GroupKind","hir::ErrorKind","ast::ClassPerlKind","ast::ErrorKind","ast::ClassSetBinaryOpKind","hir::GroupKind","ast::SpecialLiteralKind","hir::ClassBytesRange","ast::ClassBracketed","ast::Repetition","hir::ClassBytes","ast::parse::Primitive","ast::ClassSetBinaryOp","ast::ClassUnicodeKind","either::Either","hir::RepetitionKind","ast::Error","ast::Flag"]},"error::Formatter":{"E":["error::Error","ast::Error","ast::ErrorKind","ast::Ast","<&T as std::fmt::Display>","unicode::UnicodeWordError","hir::ErrorKind","hir::Hir","hir::Error","unicode::CaseFoldError","error::Formatter"]},"hir::ClassUnicode::new":{"I":["<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>","<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::ErrorKind","ast::ClassPerlKind","ast::Span","utf8::Utf8Sequence","ast::parse::ParserBuilder","ast::Repetition","hir::interval::IntervalSetIter","hir::GroupKind","ast::ClassSetUnion","ast::CaptureName","ast::ClassSetRange","ast::GroupKind","hir::interval::IntervalSet","ast::FlagsItemKind","utf8::Utf8Sequences","hir::translate::HirFrame","hir::ClassBytes","ast::parse::ClassState","unicode::ClassQuery","ast::Class","ast::Flags","error::Error","ast::SpecialLiteralKind","hir::ClassUnicodeIter","utf8::ScalarRange","ast::WithComments","ast::ClassUnicode","hir::RepetitionRange","ast::AssertionKind","hir::ClassBytesIter","ast::FlagsItem","hir::Hir","ast::RepetitionKind","hir::translate::Translator","ast::ClassSet","hir::Repetition","ast::Comment","hir::print::Printer","ast::Assertion","hir::Group","ast::Alternation","ast::parse::NestLimiter","either::Either","ast::parse::GroupState","ast::Error","ast::Concat","ast::print::Writer","ast::ClassUnicodeOpKind","ast::LiteralKind","hir::WordBoundary","parser::ParserBuilder","ast::ClassUnicodeKind","ast::HexLiteralKind","ast::ClassSetBinaryOp","ast::Flag","hir::HirInfo","ast::RepetitionRange","ast::parse::ParserI","ast::ClassPerl","hir::translate::TranslatorBuilder","ast::Position","hir::translate::Flags","ast::ClassAscii","hir::translate::TranslatorI","hir::ClassUnicode","ast::visitor::ClassFrame","unicode::UnicodeWordError","ast::ClassAsciiKind","ast::RepetitionOp","hir::Literal","ast::print::Printer","hir::ErrorKind","ast::parse::Primitive","ast::Literal","hir::literal::Literals","ast::visitor::ClassInduct","hir::RepetitionKind","hir::print::Writer","unicode::Error","ast::ClassBracketed","hir::ClassUnicodeRange","ast::print::PrinterBuilder","hir::print::PrinterBuilder","hir::Anchor","unicode::CanonicalClassQuery","ast::SetFlags","hir::Class","ast::Group","unicode::CaseFoldError","utf8::Utf8Range","ast::parse::Parser","hir::literal::Literal","<&T as std::fmt::Debug>","hir::ClassBytesRange","ast::Ast","hir::HirKind","error::Formatter","ast::ClassSetBinaryOpKind","hir::Error","parser::Parser","ast::ClassSetItem"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+hir::ClassUnicode::new(p0);
+crate::hir::ClassUnicode::new(p0);
+<hir::ClassUnicode>::new(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::empty
deps:{}
candidates:{}
+hir::ClassUnicode::empty();
+crate::hir::ClassUnicode::empty();
+<hir::ClassUnicode>::empty();
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.push(p1);
+hir::ClassUnicode::push(p0, p1);
+crate::hir::ClassUnicode::push(p0, p1);
+<hir::ClassUnicode>::push(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.iter();
+hir::ClassUnicode::iter(p0);
+crate::hir::ClassUnicode::iter(p0);
+<hir::ClassUnicode>::iter(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::ranges
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.ranges();
+hir::ClassUnicode::ranges(p0);
+crate::hir::ClassUnicode::ranges(p0);
+<hir::ClassUnicode>::ranges(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.case_fold_simple();
+hir::ClassUnicode::case_fold_simple(p0);
+crate::hir::ClassUnicode::case_fold_simple(p0);
+<hir::ClassUnicode>::case_fold_simple(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::try_case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.try_case_fold_simple();
+hir::ClassUnicode::try_case_fold_simple(p0);
+crate::hir::ClassUnicode::try_case_fold_simple(p0);
+<hir::ClassUnicode>::try_case_fold_simple(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::negate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.negate();
+hir::ClassUnicode::negate(p0);
+crate::hir::ClassUnicode::negate(p0);
+<hir::ClassUnicode>::negate(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.union(p1);
+hir::ClassUnicode::union(p0, p1);
+crate::hir::ClassUnicode::union(p0, p1);
+<hir::ClassUnicode>::union(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::intersect
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.intersect(p1);
+hir::ClassUnicode::intersect(p0, p1);
+crate::hir::ClassUnicode::intersect(p0, p1);
+<hir::ClassUnicode>::intersect(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.difference(p1);
+hir::ClassUnicode::difference(p0, p1);
+crate::hir::ClassUnicode::difference(p0, p1);
+<hir::ClassUnicode>::difference(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::symmetric_difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.symmetric_difference(p1);
+hir::ClassUnicode::symmetric_difference(p0, p1);
+crate::hir::ClassUnicode::symmetric_difference(p0, p1);
+<hir::ClassUnicode>::symmetric_difference(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::is_all_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.is_all_ascii();
+hir::ClassUnicode::is_all_ascii(p0);
+crate::hir::ClassUnicode::is_all_ascii(p0);
+<hir::ClassUnicode>::is_all_ascii(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassUnicodeIter<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeIter<'a>
+p0.next();
+<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next(p0);
+crate::<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next(p0);
+<hir::ClassUnicodeIter<'a>>::next(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.clone();
+<hir::ClassUnicodeRange as std::clone::Clone>::clone(p0);
+crate::<hir::ClassUnicodeRange as std::clone::Clone>::clone(p0);
+<hir::ClassUnicodeRange>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::default::Default>::default
deps:{}
candidates:{}
+<hir::ClassUnicodeRange as std::default::Default>::default();
+crate::<hir::ClassUnicodeRange as std::default::Default>::default();
+<hir::ClassUnicodeRange>::default();
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.assert_receiver_is_total_eq();
+<hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassUnicodeRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.eq(p1);
+<hir::ClassUnicodeRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassUnicodeRange as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassUnicodeRange>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.partial_cmp(p1);
+<hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<hir::ClassUnicodeRange>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.cmp(p1);
+<hir::ClassUnicodeRange as std::cmp::Ord>::cmp(p0, p1);
+crate::<hir::ClassUnicodeRange as std::cmp::Ord>::cmp(p0, p1);
+<hir::ClassUnicodeRange>::cmp(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassUnicodeRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassUnicodeRange as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassUnicodeRange>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::lower
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.lower();
+<hir::ClassUnicodeRange as hir::interval::Interval>::lower(p0);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::lower(p0);
+<hir::ClassUnicodeRange>::lower(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::upper
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.upper();
+<hir::ClassUnicodeRange as hir::interval::Interval>::upper(p0);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::upper(p0);
+<hir::ClassUnicodeRange>::upper(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::set_lower
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = 'a'; // None+char
+p0.set_lower(p1);
+<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower(p0, p1);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower(p0, p1);
+<hir::ClassUnicodeRange>::set_lower(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::set_upper
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = 'a'; // None+char
+p0.set_upper(p1);
+<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper(p0, p1);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper(p0, p1);
+<hir::ClassUnicodeRange>::set_upper(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::ClassUnicodeRange>
+p0.case_fold_simple(p1);
+<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+<hir::ClassUnicodeRange>::case_fold_simple(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicodeRange::new
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+hir::ClassUnicodeRange::new(p0, p1);
+crate::hir::ClassUnicodeRange::new(p0, p1);
+<hir::ClassUnicodeRange>::new(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicodeRange::start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.start();
+hir::ClassUnicodeRange::start(p0);
+crate::hir::ClassUnicodeRange::start(p0);
+<hir::ClassUnicodeRange>::start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicodeRange::end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.end();
+hir::ClassUnicodeRange::end(p0);
+crate::hir::ClassUnicodeRange::end(p0);
+<hir::ClassUnicodeRange>::end(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytes as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.clone();
+<hir::ClassBytes as std::clone::Clone>::clone(p0);
+crate::<hir::ClassBytes as std::clone::Clone>::clone(p0);
+<hir::ClassBytes>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytes as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassBytes as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassBytes as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassBytes>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.assert_receiver_is_total_eq();
+<hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassBytes>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytes as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.eq(p1);
+<hir::ClassBytes as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassBytes as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassBytes>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"],"Right":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::ClassBytes::new":{"I":["std::iter::IntoIterator","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","hir::interval::Interval","std::fmt::Debug","std::clone::Clone"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["<&mut I as std::iter::Iterator>","utf8::Utf8Sequences","hir::ClassUnicodeIter","hir::ClassBytesIter","hir::interval::IntervalSetIter"]},"ast::parse::NestLimiter":{"P":["std::rc::Rc<T>","std::vec::Vec<T, A>","<&mut T as std::fmt::Debug>","std::ffi::OsString","std::path::PathBuf","std::string::String","std::sync::Arc<T>","std::ffi::CString","std::boxed::Box<T, A>"]},"ast::parse::ParserI":{"P":["std::string::String","std::ffi::CString","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::path::PathBuf","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::ffi::OsString"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::Assertion","ast::Literal","ast::Error","ast::ClassAscii","either::Either","hir::literal::Literals","ast::Repetition","ast::FlagsItemKind","hir::Class","ast::Group","ast::RepetitionKind","error::Error","ast::Comment","ast::parse::Primitive","ast::ClassUnicode","hir::literal::Literal","ast::ClassUnicodeOpKind","ast::ClassSetBinaryOpKind","hir::GroupKind","hir::RepetitionRange","hir::ClassBytesRange","ast::Concat","hir::ClassUnicodeRange","hir::HirKind","ast::RepetitionOp","hir::Anchor","ast::ClassSetUnion","ast::Position","ast::Flags","ast::Class","hir::ClassBytes","ast::ErrorKind","ast::GroupKind","hir::Literal","hir::ClassUnicode","ast::AssertionKind","ast::ClassUnicodeKind","ast::ClassSet","hir::HirInfo","ast::LiteralKind","ast::Span","hir::Error","ast::ClassSetItem","ast::Flag","ast::RepetitionRange","ast::Alternation","hir::ErrorKind","ast::Ast","std::clone::impls::<impl std::clone::Clone for *const T>","hir::Group","hir::interval::IntervalSet","hir::WordBoundary","hir::Repetition","hir::Hir","ast::ClassPerlKind","hir::RepetitionKind","ast::ClassAsciiKind","ast::WithComments","ast::HexLiteralKind","ast::FlagsItem","ast::ClassSetBinaryOp","ast::SpecialLiteralKind","ast::CaptureName","ast::ClassBracketed","ast::SetFlags","ast::ClassPerl","ast::ClassSetRange","utf8::Utf8Sequence","utf8::Utf8Range"],"Right":["hir::ClassBytesRange","ast::FlagsItem","ast::ClassBracketed","ast::ClassUnicodeOpKind","ast::ClassAsciiKind","ast::Position","ast::SetFlags","hir::WordBoundary","hir::Anchor","ast::HexLiteralKind","hir::HirKind","either::Either","ast::ClassUnicode","hir::ErrorKind","ast::ClassSetUnion","hir::literal::Literal","ast::ClassSetBinaryOpKind","hir::Repetition","ast::Span","ast::ClassSetItem","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::ClassAscii","ast::ClassUnicodeKind","ast::ClassSet","hir::interval::IntervalSet","ast::RepetitionOp","hir::Error","ast::RepetitionRange","ast::ClassSetBinaryOp","ast::ClassPerl","ast::Comment","hir::GroupKind","hir::RepetitionRange","hir::ClassUnicodeRange","ast::parse::Primitive","ast::RepetitionKind","ast::LiteralKind","utf8::Utf8Sequence","ast::CaptureName","ast::WithComments","hir::ClassBytes","ast::ErrorKind","ast::Error","ast::Literal","ast::Class","ast::Repetition","ast::Flag","hir::Group","ast::Ast","ast::Group","hir::literal::Literals","ast::Alternation","ast::GroupKind","hir::HirInfo","ast::ClassPerlKind","hir::Class","utf8::Utf8Range","hir::Hir","hir::RepetitionKind","ast::AssertionKind","error::Error","ast::Flags","hir::Literal","ast::Assertion","ast::FlagsItemKind","hir::ClassUnicode","ast::SpecialLiteralKind","ast::ClassSetRange","ast::Concat"]},"error::Formatter":{"E":["ast::ErrorKind","error::Error","unicode::UnicodeWordError","<&mut T as std::fmt::Debug>","hir::Hir","ast::Ast","error::Formatter","unicode::CaseFoldError","hir::ErrorKind","hir::Error","ast::Error"]},"hir::ClassBytes::new":{"I":["<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>","<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::ClassUnicodeOpKind","ast::ClassSet","hir::ClassBytesIter","ast::RepetitionRange","ast::Position","ast::RepetitionOp","hir::print::PrinterBuilder","hir::RepetitionKind","ast::Group","ast::Flag","ast::parse::ParserBuilder","hir::interval::IntervalSet","ast::visitor::ClassInduct","hir::HirKind","hir::interval::IntervalSetIter","ast::print::Printer","ast::RepetitionKind","ast::print::PrinterBuilder","unicode::CaseFoldError","hir::translate::Translator","ast::Span","error::Formatter","unicode::Error","unicode::ClassQuery","hir::print::Printer","ast::GroupKind","parser::ParserBuilder","hir::Group","unicode::CanonicalClassQuery","ast::CaptureName","hir::Error","ast::ClassSetBinaryOpKind","ast::ClassSetUnion","ast::print::Writer","ast::Literal","hir::translate::TranslatorBuilder","ast::parse::NestLimiter","unicode::UnicodeWordError","ast::Error","ast::LiteralKind","ast::ClassSetItem","ast::Repetition","ast::ClassSetRange","ast::FlagsItem","ast::Ast","hir::GroupKind","ast::FlagsItemKind","ast::SpecialLiteralKind","hir::RepetitionRange","hir::ClassBytesRange","hir::ClassUnicodeIter","hir::ClassBytes","ast::parse::Parser","ast::ClassAscii","hir::Anchor","ast::Class","ast::ClassBracketed","ast::WithComments","hir::ErrorKind","hir::literal::Literals","utf8::Utf8Sequences","ast::ClassUnicode","hir::WordBoundary","ast::Assertion","error::Error","ast::ClassPerl","either::Either","ast::ClassSetBinaryOp","hir::ClassUnicodeRange","<&T as std::fmt::Debug>","hir::print::Writer","hir::translate::TranslatorI","parser::Parser","ast::visitor::ClassFrame","ast::Concat","hir::ClassUnicode","ast::parse::Primitive","hir::translate::HirFrame","utf8::Utf8Sequence","hir::Hir","hir::Repetition","hir::Literal","hir::Class","utf8::ScalarRange","ast::parse::ParserI","ast::ClassAsciiKind","ast::AssertionKind","ast::HexLiteralKind","ast::Alternation","ast::parse::ClassState","ast::Flags","ast::SetFlags","ast::Comment","utf8::Utf8Range","ast::ErrorKind","hir::HirInfo","ast::parse::GroupState","hir::literal::Literal","ast::ClassUnicodeKind","ast::ClassPerlKind","hir::translate::Flags"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+hir::ClassBytes::new(p0);
+crate::hir::ClassBytes::new(p0);
+<hir::ClassBytes>::new(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::empty
deps:{}
candidates:{}
+hir::ClassBytes::empty();
+crate::hir::ClassBytes::empty();
+<hir::ClassBytes>::empty();
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.push(p1);
+hir::ClassBytes::push(p0, p1);
+crate::hir::ClassBytes::push(p0, p1);
+<hir::ClassBytes>::push(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.iter();
+hir::ClassBytes::iter(p0);
+crate::hir::ClassBytes::iter(p0);
+<hir::ClassBytes>::iter(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::ranges
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.ranges();
+hir::ClassBytes::ranges(p0);
+crate::hir::ClassBytes::ranges(p0);
+<hir::ClassBytes>::ranges(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.case_fold_simple();
+hir::ClassBytes::case_fold_simple(p0);
+crate::hir::ClassBytes::case_fold_simple(p0);
+<hir::ClassBytes>::case_fold_simple(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::negate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.negate();
+hir::ClassBytes::negate(p0);
+crate::hir::ClassBytes::negate(p0);
+<hir::ClassBytes>::negate(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.union(p1);
+hir::ClassBytes::union(p0, p1);
+crate::hir::ClassBytes::union(p0, p1);
+<hir::ClassBytes>::union(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::intersect
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.intersect(p1);
+hir::ClassBytes::intersect(p0, p1);
+crate::hir::ClassBytes::intersect(p0, p1);
+<hir::ClassBytes>::intersect(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.difference(p1);
+hir::ClassBytes::difference(p0, p1);
+crate::hir::ClassBytes::difference(p0, p1);
+<hir::ClassBytes>::difference(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::symmetric_difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.symmetric_difference(p1);
+hir::ClassBytes::symmetric_difference(p0, p1);
+crate::hir::ClassBytes::symmetric_difference(p0, p1);
+<hir::ClassBytes>::symmetric_difference(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::is_all_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.is_all_ascii();
+hir::ClassBytes::is_all_ascii(p0);
+crate::hir::ClassBytes::is_all_ascii(p0);
+<hir::ClassBytes>::is_all_ascii(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassBytesIter<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytesIter<'a>
+p0.next();
+<hir::ClassBytesIter<'a> as std::iter::Iterator>::next(p0);
+crate::<hir::ClassBytesIter<'a> as std::iter::Iterator>::next(p0);
+<hir::ClassBytesIter<'a>>::next(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.clone();
+<hir::ClassBytesRange as std::clone::Clone>::clone(p0);
+crate::<hir::ClassBytesRange as std::clone::Clone>::clone(p0);
+<hir::ClassBytesRange>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::default::Default>::default
deps:{}
candidates:{}
+<hir::ClassBytesRange as std::default::Default>::default();
+crate::<hir::ClassBytesRange as std::default::Default>::default();
+<hir::ClassBytesRange>::default();
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.assert_receiver_is_total_eq();
+<hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassBytesRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.eq(p1);
+<hir::ClassBytesRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassBytesRange as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassBytesRange>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.partial_cmp(p1);
+<hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<hir::ClassBytesRange>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.cmp(p1);
+<hir::ClassBytesRange as std::cmp::Ord>::cmp(p0, p1);
+crate::<hir::ClassBytesRange as std::cmp::Ord>::cmp(p0, p1);
+<hir::ClassBytesRange>::cmp(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::lower
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.lower();
+<hir::ClassBytesRange as hir::interval::Interval>::lower(p0);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::lower(p0);
+<hir::ClassBytesRange>::lower(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::upper
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.upper();
+<hir::ClassBytesRange as hir::interval::Interval>::upper(p0);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::upper(p0);
+<hir::ClassBytesRange>::upper(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::set_lower
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = 0u8; // None+u8
+p0.set_lower(p1);
+<hir::ClassBytesRange as hir::interval::Interval>::set_lower(p0, p1);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::set_lower(p0, p1);
+<hir::ClassBytesRange>::set_lower(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::set_upper
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = 0u8; // None+u8
+p0.set_upper(p1);
+<hir::ClassBytesRange as hir::interval::Interval>::set_upper(p0, p1);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::set_upper(p0, p1);
+<hir::ClassBytesRange>::set_upper(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::ClassBytesRange>
+p0.case_fold_simple(p1);
+<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+<hir::ClassBytesRange>::case_fold_simple(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytesRange::new
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+hir::ClassBytesRange::new(p0, p1);
+crate::hir::ClassBytesRange::new(p0, p1);
+<hir::ClassBytesRange>::new(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytesRange::start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.start();
+hir::ClassBytesRange::start(p0);
+crate::hir::ClassBytesRange::start(p0);
+<hir::ClassBytesRange>::start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytesRange::end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.end();
+hir::ClassBytesRange::end(p0);
+crate::hir::ClassBytesRange::end(p0);
+<hir::ClassBytesRange>::end(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassBytesRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassBytesRange as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassBytesRange>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Anchor as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
+p0.clone();
+<hir::Anchor as std::clone::Clone>::clone(p0);
+crate::<hir::Anchor as std::clone::Clone>::clone(p0);
+<hir::Anchor>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Anchor as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Anchor as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Anchor as std::fmt::Debug>::fmt(p0, p1);
+<hir::Anchor>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Anchor as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
+p0.assert_receiver_is_total_eq();
+<hir::Anchor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Anchor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Anchor>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Anchor as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
+p0.eq(p1);
+<hir::Anchor as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Anchor as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Anchor>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::WordBoundary as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+p0.clone();
+<hir::WordBoundary as std::clone::Clone>::clone(p0);
+crate::<hir::WordBoundary as std::clone::Clone>::clone(p0);
+<hir::WordBoundary>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::WordBoundary as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::WordBoundary as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::WordBoundary as std::fmt::Debug>::fmt(p0, p1);
+<hir::WordBoundary>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::WordBoundary as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+p0.assert_receiver_is_total_eq();
+<hir::WordBoundary as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::WordBoundary as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::WordBoundary>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::WordBoundary as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+p0.eq(p1);
+<hir::WordBoundary as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::WordBoundary as std::cmp::PartialEq>::eq(p0, p1);
+<hir::WordBoundary>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::WordBoundary::is_negated
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+p0.is_negated();
+hir::WordBoundary::is_negated(p0);
+crate::hir::WordBoundary::is_negated(p0);
+<hir::WordBoundary>::is_negated(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Group as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Group
+p0.clone();
+<hir::Group as std::clone::Clone>::clone(p0);
+crate::<hir::Group as std::clone::Clone>::clone(p0);
+<hir::Group>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Group as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Group
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Group as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Group as std::fmt::Debug>::fmt(p0, p1);
+<hir::Group>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Group as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Group
+p0.assert_receiver_is_total_eq();
+<hir::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Group>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Group as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Group
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Group
+p0.eq(p1);
+<hir::Group as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Group as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Group>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::GroupKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
+p0.clone();
+<hir::GroupKind as std::clone::Clone>::clone(p0);
+crate::<hir::GroupKind as std::clone::Clone>::clone(p0);
+<hir::GroupKind>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::GroupKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::GroupKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
+p0.assert_receiver_is_total_eq();
+<hir::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::GroupKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::GroupKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
+p0.eq(p1);
+<hir::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::GroupKind>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Repetition as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.clone();
+<hir::Repetition as std::clone::Clone>::clone(p0);
+crate::<hir::Repetition as std::clone::Clone>::clone(p0);
+<hir::Repetition>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Repetition as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Repetition as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Repetition as std::fmt::Debug>::fmt(p0, p1);
+<hir::Repetition>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.assert_receiver_is_total_eq();
+<hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Repetition>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Repetition as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.eq(p1);
+<hir::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Repetition>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Repetition::is_match_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.is_match_empty();
+hir::Repetition::is_match_empty(p0);
+crate::hir::Repetition::is_match_empty(p0);
+<hir::Repetition>::is_match_empty(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
+p0.clone();
+<hir::RepetitionKind as std::clone::Clone>::clone(p0);
+crate::<hir::RepetitionKind as std::clone::Clone>::clone(p0);
+<hir::RepetitionKind>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::RepetitionKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
+p0.assert_receiver_is_total_eq();
+<hir::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::RepetitionKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
+p0.eq(p1);
+<hir::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::RepetitionKind>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
+p0.clone();
+<hir::RepetitionRange as std::clone::Clone>::clone(p0);
+crate::<hir::RepetitionRange as std::clone::Clone>::clone(p0);
+<hir::RepetitionRange>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+<hir::RepetitionRange>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
+p0.assert_receiver_is_total_eq();
+<hir::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::RepetitionRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
+p0.eq(p1);
+<hir::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+<hir::RepetitionRange>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.drop();
+<hir::Hir as std::ops::Drop>::drop(p0);
+crate::<hir::Hir as std::ops::Drop>::drop(p0);
+<hir::Hir>::drop(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirInfo as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.clone();
+<hir::HirInfo as std::clone::Clone>::clone(p0);
+crate::<hir::HirInfo as std::clone::Clone>::clone(p0);
+<hir::HirInfo>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirInfo as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::HirInfo as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::HirInfo as std::fmt::Debug>::fmt(p0, p1);
+<hir::HirInfo>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirInfo as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.assert_receiver_is_total_eq();
+<hir::HirInfo as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::HirInfo as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::HirInfo>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirInfo as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.eq(p1);
+<hir::HirInfo as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::HirInfo as std::cmp::PartialEq>::eq(p0, p1);
+<hir::HirInfo>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::new
deps:{}
candidates:{}
+hir::HirInfo::new();
+crate::hir::HirInfo::new();
+<hir::HirInfo>::new();
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_always_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_always_utf8();
+hir::HirInfo::is_always_utf8(p0);
+crate::hir::HirInfo::is_always_utf8(p0);
+<hir::HirInfo>::is_always_utf8(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_always_utf8
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_always_utf8(p1);
+hir::HirInfo::set_always_utf8(p0, p1);
+crate::hir::HirInfo::set_always_utf8(p0, p1);
+<hir::HirInfo>::set_always_utf8(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_all_assertions
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_all_assertions();
+hir::HirInfo::is_all_assertions(p0);
+crate::hir::HirInfo::is_all_assertions(p0);
+<hir::HirInfo>::is_all_assertions(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_all_assertions
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_all_assertions(p1);
+hir::HirInfo::set_all_assertions(p0, p1);
+crate::hir::HirInfo::set_all_assertions(p0, p1);
+<hir::HirInfo>::set_all_assertions(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_anchored_start();
+hir::HirInfo::is_anchored_start(p0);
+crate::hir::HirInfo::is_anchored_start(p0);
+<hir::HirInfo>::is_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_anchored_start
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_anchored_start(p1);
+hir::HirInfo::set_anchored_start(p0, p1);
+crate::hir::HirInfo::set_anchored_start(p0, p1);
+<hir::HirInfo>::set_anchored_start(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_anchored_end();
+hir::HirInfo::is_anchored_end(p0);
+crate::hir::HirInfo::is_anchored_end(p0);
+<hir::HirInfo>::is_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_anchored_end
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_anchored_end(p1);
+hir::HirInfo::set_anchored_end(p0, p1);
+crate::hir::HirInfo::set_anchored_end(p0, p1);
+<hir::HirInfo>::set_anchored_end(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_line_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_line_anchored_start();
+hir::HirInfo::is_line_anchored_start(p0);
+crate::hir::HirInfo::is_line_anchored_start(p0);
+<hir::HirInfo>::is_line_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_line_anchored_start
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_line_anchored_start(p1);
+hir::HirInfo::set_line_anchored_start(p0, p1);
+crate::hir::HirInfo::set_line_anchored_start(p0, p1);
+<hir::HirInfo>::set_line_anchored_start(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_line_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_line_anchored_end();
+hir::HirInfo::is_line_anchored_end(p0);
+crate::hir::HirInfo::is_line_anchored_end(p0);
+<hir::HirInfo>::is_line_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_line_anchored_end
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_line_anchored_end(p1);
+hir::HirInfo::set_line_anchored_end(p0, p1);
+crate::hir::HirInfo::set_line_anchored_end(p0, p1);
+<hir::HirInfo>::set_line_anchored_end(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_any_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_any_anchored_start();
+hir::HirInfo::is_any_anchored_start(p0);
+crate::hir::HirInfo::is_any_anchored_start(p0);
+<hir::HirInfo>::is_any_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_any_anchored_start
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_any_anchored_start(p1);
+hir::HirInfo::set_any_anchored_start(p0, p1);
+crate::hir::HirInfo::set_any_anchored_start(p0, p1);
+<hir::HirInfo>::set_any_anchored_start(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_any_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_any_anchored_end();
+hir::HirInfo::is_any_anchored_end(p0);
+crate::hir::HirInfo::is_any_anchored_end(p0);
+<hir::HirInfo>::is_any_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_any_anchored_end
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_any_anchored_end(p1);
+hir::HirInfo::set_any_anchored_end(p0, p1);
+crate::hir::HirInfo::set_any_anchored_end(p0, p1);
+<hir::HirInfo>::set_any_anchored_end(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_match_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_match_empty();
+hir::HirInfo::is_match_empty(p0);
+crate::hir::HirInfo::is_match_empty(p0);
+<hir::HirInfo>::is_match_empty(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_match_empty
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_match_empty(p1);
+hir::HirInfo::set_match_empty(p0, p1);
+crate::hir::HirInfo::set_match_empty(p0, p1);
+<hir::HirInfo>::set_match_empty(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_literal();
+hir::HirInfo::is_literal(p0);
+crate::hir::HirInfo::is_literal(p0);
+<hir::HirInfo>::is_literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_literal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_literal(p1);
+hir::HirInfo::set_literal(p0, p1);
+crate::hir::HirInfo::set_literal(p0, p1);
+<hir::HirInfo>::set_literal(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_alternation_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_alternation_literal();
+hir::HirInfo::is_alternation_literal(p0);
+crate::hir::HirInfo::is_alternation_literal(p0);
+<hir::HirInfo>::is_alternation_literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_alternation_literal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_alternation_literal(p1);
+hir::HirInfo::set_alternation_literal(p0, p1);
+crate::hir::HirInfo::set_alternation_literal(p0, p1);
+<hir::HirInfo>::set_alternation_literal(p0, p1);
-----------------
regex-syntax/src/parser.rs <parser::ParserBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
+p0.clone();
+<parser::ParserBuilder as std::clone::Clone>::clone(p0);
+crate::<parser::ParserBuilder as std::clone::Clone>::clone(p0);
+<parser::ParserBuilder>::clone(p0);
-----------------
regex-syntax/src/parser.rs <parser::ParserBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+<parser::ParserBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/parser.rs <parser::ParserBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<parser::ParserBuilder as std::default::Default>::default();
+crate::<parser::ParserBuilder as std::default::Default>::default();
+<parser::ParserBuilder>::default();
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::new
deps:{}
candidates:{}
+parser::ParserBuilder::new();
+crate::parser::ParserBuilder::new();
+<parser::ParserBuilder>::new();
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
+p0.build();
+parser::ParserBuilder::build(p0);
+crate::parser::ParserBuilder::build(p0);
+<parser::ParserBuilder>::build(p0);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+parser::ParserBuilder::nest_limit(p0, p1);
+crate::parser::ParserBuilder::nest_limit(p0, p1);
+<parser::ParserBuilder>::nest_limit(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+parser::ParserBuilder::octal(p0, p1);
+crate::parser::ParserBuilder::octal(p0, p1);
+<parser::ParserBuilder>::octal(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::allow_invalid_utf8
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.allow_invalid_utf8(p1);
+parser::ParserBuilder::allow_invalid_utf8(p0, p1);
+crate::parser::ParserBuilder::allow_invalid_utf8(p0, p1);
+<parser::ParserBuilder>::allow_invalid_utf8(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+parser::ParserBuilder::ignore_whitespace(p0, p1);
+crate::parser::ParserBuilder::ignore_whitespace(p0, p1);
+<parser::ParserBuilder>::ignore_whitespace(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+parser::ParserBuilder::case_insensitive(p0, p1);
+crate::parser::ParserBuilder::case_insensitive(p0, p1);
+<parser::ParserBuilder>::case_insensitive(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+parser::ParserBuilder::multi_line(p0, p1);
+crate::parser::ParserBuilder::multi_line(p0, p1);
+<parser::ParserBuilder>::multi_line(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+parser::ParserBuilder::dot_matches_new_line(p0, p1);
+crate::parser::ParserBuilder::dot_matches_new_line(p0, p1);
+<parser::ParserBuilder>::dot_matches_new_line(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+parser::ParserBuilder::swap_greed(p0, p1);
+crate::parser::ParserBuilder::swap_greed(p0, p1);
+<parser::ParserBuilder>::swap_greed(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+parser::ParserBuilder::unicode(p0, p1);
+crate::parser::ParserBuilder::unicode(p0, p1);
+<parser::ParserBuilder>::unicode(p0, p1);
-----------------
regex-syntax/src/parser.rs <parser::Parser as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::Parser
+p0.clone();
+<parser::Parser as std::clone::Clone>::clone(p0);
+crate::<parser::Parser as std::clone::Clone>::clone(p0);
+<parser::Parser>::clone(p0);
-----------------
regex-syntax/src/parser.rs <parser::Parser as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::Parser
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::Parser as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::Parser as std::fmt::Debug>::fmt(p0, p1);
+<parser::Parser>::fmt(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::Parser::new
deps:{}
candidates:{}
+parser::Parser::new();
+crate::parser::Parser::new();
+<parser::Parser>::new();
-----------------
regex-syntax/src/parser.rs parser::Parser::parse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::Parser
let mut p1 = "sample"; // None+&str
+p0.parse(&p1);
+parser::Parser::parse(p0, &p1);
+crate::parser::Parser::parse(p0, &p1);
+<parser::Parser>::parse(p0, &p1);
-----------------
regex-syntax/src/unicode.rs <unicode::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::Error as std::fmt::Debug>::fmt(p0, p1);
+<unicode::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::CaseFoldError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CaseFoldError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::CaseFoldError as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::CaseFoldError as std::fmt::Debug>::fmt(p0, p1);
+<unicode::CaseFoldError>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::CaseFoldError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CaseFoldError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<unicode::CaseFoldError as std::fmt::Display>::fmt(p0, p1);
+crate::<unicode::CaseFoldError as std::fmt::Display>::fmt(p0, p1);
+<unicode::CaseFoldError>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::UnicodeWordError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::UnicodeWordError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::UnicodeWordError as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::UnicodeWordError as std::fmt::Debug>::fmt(p0, p1);
+<unicode::UnicodeWordError>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::UnicodeWordError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::UnicodeWordError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<unicode::UnicodeWordError as std::fmt::Display>::fmt(p0, p1);
+crate::<unicode::UnicodeWordError as std::fmt::Display>::fmt(p0, p1);
+<unicode::UnicodeWordError>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::ClassQuery<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::ClassQuery<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::ClassQuery<'a> as std::fmt::Debug>::fmt(p0, p1);
+<unicode::ClassQuery<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs unicode::ClassQuery::<'a>::canonicalize
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'a>
+p0.canonicalize();
+unicode::ClassQuery::<'a>::canonicalize(p0);
+crate::unicode::ClassQuery::<'a>::canonicalize(p0);
+<unicode::ClassQuery<'a>>::canonicalize(p0);
-----------------
regex-syntax/src/unicode.rs unicode::ClassQuery::<'a>::canonical_binary
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'a>
let mut p1 = "sample"; // None+&str
+p0.canonical_binary(&p1);
+unicode::ClassQuery::<'a>::canonical_binary(p0, &p1);
+crate::unicode::ClassQuery::<'a>::canonical_binary(p0, &p1);
+<unicode::ClassQuery<'a>>::canonical_binary(p0, &p1);
-----------------
regex-syntax/src/unicode.rs <unicode::CanonicalClassQuery as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::CanonicalClassQuery as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::CanonicalClassQuery as std::fmt::Debug>::fmt(p0, p1);
+<unicode::CanonicalClassQuery>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
+p0.assert_receiver_is_total_eq();
+<unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<unicode::CanonicalClassQuery>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/unicode.rs <unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
let mut p1 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
+p0.eq(p1);
+<unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq(p0, p1);
+crate::<unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq(p0, p1);
+<unicode::CanonicalClassQuery>::eq(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.clone();
+<utf8::Utf8Sequence as std::clone::Clone>::clone(p0);
+crate::<utf8::Utf8Sequence as std::clone::Clone>::clone(p0);
+<utf8::Utf8Sequence>::clone(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.assert_receiver_is_total_eq();
+<utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<utf8::Utf8Sequence>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.eq(p1);
+<utf8::Utf8Sequence as std::cmp::PartialEq>::eq(p0, p1);
+crate::<utf8::Utf8Sequence as std::cmp::PartialEq>::eq(p0, p1);
+<utf8::Utf8Sequence>::eq(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.partial_cmp(p1);
+<utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<utf8::Utf8Sequence>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.cmp(p1);
+<utf8::Utf8Sequence as std::cmp::Ord>::cmp(p0, p1);
+crate::<utf8::Utf8Sequence as std::cmp::Ord>::cmp(p0, p1);
+<utf8::Utf8Sequence>::cmp(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::from_encoded_range
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+utf8::Utf8Sequence::from_encoded_range(p0, p1);
+crate::utf8::Utf8Sequence::from_encoded_range(p0, p1);
+<utf8::Utf8Sequence>::from_encoded_range(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::as_slice
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.as_slice();
+utf8::Utf8Sequence::as_slice(p0);
+crate::utf8::Utf8Sequence::as_slice(p0);
+<utf8::Utf8Sequence>::as_slice(p0);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.len();
+utf8::Utf8Sequence::len(p0);
+crate::utf8::Utf8Sequence::len(p0);
+<utf8::Utf8Sequence>::len(p0);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::reverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.reverse();
+utf8::Utf8Sequence::reverse(p0);
+crate::utf8::Utf8Sequence::reverse(p0);
+<utf8::Utf8Sequence>::reverse(p0);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.matches(p1);
+utf8::Utf8Sequence::matches(p0, p1);
+crate::utf8::Utf8Sequence::matches(p0, p1);
+<utf8::Utf8Sequence>::matches(p0, p1);
-----------------
regex-syntax/src/utf8.rs <&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.into_iter();
+<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter(p0);
+<&'a utf8::Utf8Sequence>::into_iter(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::Utf8Sequence as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::Utf8Sequence as std::fmt::Debug>::fmt(p0, p1);
+<utf8::Utf8Sequence>::fmt(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.clone();
+<utf8::Utf8Range as std::clone::Clone>::clone(p0);
+crate::<utf8::Utf8Range as std::clone::Clone>::clone(p0);
+<utf8::Utf8Range>::clone(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.assert_receiver_is_total_eq();
+<utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<utf8::Utf8Range>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.eq(p1);
+<utf8::Utf8Range as std::cmp::PartialEq>::eq(p0, p1);
+crate::<utf8::Utf8Range as std::cmp::PartialEq>::eq(p0, p1);
+<utf8::Utf8Range>::eq(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.partial_cmp(p1);
+<utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<utf8::Utf8Range>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.cmp(p1);
+<utf8::Utf8Range as std::cmp::Ord>::cmp(p0, p1);
+crate::<utf8::Utf8Range as std::cmp::Ord>::cmp(p0, p1);
+<utf8::Utf8Range>::cmp(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Range::new
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+utf8::Utf8Range::new(p0, p1);
+crate::utf8::Utf8Range::new(p0, p1);
+<utf8::Utf8Range>::new(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Range::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = 0u8; // None+u8
+p0.matches(p1);
+utf8::Utf8Range::matches(p0, p1);
+crate::utf8::Utf8Range::matches(p0, p1);
+<utf8::Utf8Range>::matches(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::Utf8Range as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::Utf8Range as std::fmt::Debug>::fmt(p0, p1);
+<utf8::Utf8Range>::fmt(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequences as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::Utf8Sequences as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::Utf8Sequences as std::fmt::Debug>::fmt(p0, p1);
+<utf8::Utf8Sequences>::fmt(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequences::new
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+utf8::Utf8Sequences::new(p0, p1);
+crate::utf8::Utf8Sequences::new(p0, p1);
+<utf8::Utf8Sequences>::new(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequences::reset
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
let mut p1 = 'a'; // None+char
let mut p2 = 'a'; // None+char
+p0.reset(p1, p2);
+utf8::Utf8Sequences::reset(p0, p1, p2);
+crate::utf8::Utf8Sequences::reset(p0, p1, p2);
+<utf8::Utf8Sequences>::reset(p0, p1, p2);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequences::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+p0.push(p1, p2);
+utf8::Utf8Sequences::push(p0, p1, p2);
+crate::utf8::Utf8Sequences::push(p0, p1, p2);
+<utf8::Utf8Sequences>::push(p0, p1, p2);
-----------------
regex-syntax/src/utf8.rs <utf8::ScalarRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::ScalarRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::ScalarRange as std::fmt::Debug>::fmt(p0, p1);
+<utf8::ScalarRange>::fmt(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequences as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
+p0.next();
+<utf8::Utf8Sequences as std::iter::Iterator>::next(p0);
+crate::<utf8::Utf8Sequences as std::iter::Iterator>::next(p0);
+<utf8::Utf8Sequences>::next(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::split
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.split();
+utf8::ScalarRange::split(p0);
+crate::utf8::ScalarRange::split(p0);
+<utf8::ScalarRange>::split(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::is_valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.is_valid();
+utf8::ScalarRange::is_valid(p0);
+crate::utf8::ScalarRange::is_valid(p0);
+<utf8::ScalarRange>::is_valid(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::as_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.as_ascii();
+utf8::ScalarRange::as_ascii(p0);
+crate::utf8::ScalarRange::as_ascii(p0);
+<utf8::ScalarRange>::as_ascii(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::is_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.is_ascii();
+utf8::ScalarRange::is_ascii(p0);
+crate::utf8::ScalarRange::is_ascii(p0);
+<utf8::ScalarRange>::is_ascii(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
let mut p2 = &mut [0u8].as_mut_slice(); // None+[u8]
+p0.encode(p1, p2);
+utf8::ScalarRange::encode(p0, p1, p2);
+crate::utf8::ScalarRange::encode(p0, p1, p2);
+<utf8::ScalarRange>::encode(p0, p1, p2);