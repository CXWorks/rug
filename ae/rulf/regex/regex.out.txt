-----------------
regex-syntax/src/ast/parse.rs ast::parse::is_hex
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+ast::parse::is_hex(p0);
+crate::ast::parse::is_hex(p0);
+crate::ast::parse::is_hex(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::is_capture_char
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = true; // None+bool
+ast::parse::is_capture_char(p0, p1);
+crate::ast::parse::is_capture_char(p0, p1);
+crate::ast::parse::is_capture_char(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::specialize_err
deps:{"ast::parse::specialize_err":{"T":["std::marker::Sized"]}}
candidates:{"ast::parse::specialize_err":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<T, ast::Error>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+ast::parse::specialize_err(p0, p1, p2);
+crate::ast::parse::specialize_err(p0, p1, p2);
+crate::ast::parse::specialize_err(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::visit
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::visit":{"V":["ast::visitor::Visitor","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::sync::Arc<T>","std::path::PathBuf","std::rc::Rc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::ffi::CString"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::visit":{"V":["ast::print::Writer","hir::translate::TranslatorI","ast::parse::NestLimiter"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+ast::visitor::visit(p0, p1);
+crate::ast::visitor::visit(p0, p1);
+crate::ast::visitor::visit(p0, p1);
-----------------
regex-syntax/src/error.rs error::repeat_char
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 0usize; // None+usize
+error::repeat_char(p0, p1);
+crate::error::repeat_char(p0, p1);
+crate::error::repeat_char(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+hir::literal::prefixes(p0, p1);
+crate::hir::literal::prefixes(p0, p1);
+crate::hir::literal::prefixes(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+hir::literal::suffixes(p0, p1);
+crate::hir::literal::suffixes(p0, p1);
+crate::hir::literal::suffixes(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::repeat_zero_or_one_literals
deps:{"hir::literal::repeat_zero_or_one_literals":{"F":["std::ops::FnMut","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::repeat_zero_or_one_literals":{"F":["core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::repeat_zero_or_one_literals(p0, p1, p2);
+crate::hir::literal::repeat_zero_or_one_literals(p0, p1, p2);
+crate::hir::literal::repeat_zero_or_one_literals(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::repeat_zero_or_more_literals
deps:{"hir::literal::repeat_zero_or_more_literals":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::repeat_zero_or_more_literals":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsWhitespace"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::repeat_zero_or_more_literals(p0, p1, p2);
+crate::hir::literal::repeat_zero_or_more_literals(p0, p1, p2);
+crate::hir::literal::repeat_zero_or_more_literals(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::repeat_one_or_more_literals
deps:{"hir::literal::repeat_one_or_more_literals":{"F":["std::ops::FnMut","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::repeat_one_or_more_literals":{"F":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::repeat_one_or_more_literals(p0, p1, p2);
+crate::hir::literal::repeat_one_or_more_literals(p0, p1, p2);
+crate::hir::literal::repeat_one_or_more_literals(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::repeat_range_literals
deps:{"hir::literal::repeat_range_literals":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::repeat_range_literals":{"F":["core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = 0u32; // None+u32
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<u32>
let mut p3 = true; // None+bool
let mut p4 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p5 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::repeat_range_literals(p0, p1, p2, p3, p4, p5);
+crate::hir::literal::repeat_range_literals(p0, p1, p2, p3, p4, p5);
+crate::hir::literal::repeat_range_literals(p0, p1, p2, p3, p4, p5);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::alternate_literals
deps:{"hir::literal::alternate_literals":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"hir::literal::alternate_literals":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [hir::Hir]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+hir::literal::alternate_literals(p0, p1, p2);
+crate::hir::literal::alternate_literals(p0, p1, p2);
+crate::hir::literal::alternate_literals(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::position
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+hir::literal::position(p0, p1);
+crate::hir::literal::position(p0, p1);
+crate::hir::literal::position(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::escape_unicode
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+hir::literal::escape_unicode(p0);
+crate::hir::literal::escape_unicode(p0);
+crate::hir::literal::escape_unicode(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::escape_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+hir::literal::escape_bytes(p0);
+crate::hir::literal::escape_bytes(p0);
+crate::hir::literal::escape_bytes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::escape_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+hir::literal::escape_byte(p0);
+crate::hir::literal::escape_byte(p0);
+crate::hir::literal::escape_byte(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::cls_char_count
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+hir::literal::cls_char_count(p0);
+crate::hir::literal::cls_char_count(p0);
+crate::hir::literal::cls_char_count(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::cls_byte_count
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+hir::literal::cls_byte_count(p0);
+crate::hir::literal::cls_byte_count(p0);
+crate::hir::literal::cls_byte_count(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::hir_ascii_class_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+hir::translate::hir_ascii_class_bytes(p0);
+crate::hir::translate::hir_ascii_class_bytes(p0);
+crate::hir::translate::hir_ascii_class_bytes(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::ascii_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+hir::translate::ascii_class(p0);
+crate::hir::translate::ascii_class(p0);
+crate::hir::translate::ascii_class(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::visit
deps:{"hir::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"hir::visitor::visit":{"V":["hir::visitor::Visitor","std::marker::Sized"]}}
candidates:{"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"hir::visitor::visit":{"V":["hir::print::Writer"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+hir::visitor::visit(p0, p1);
+crate::hir::visitor::visit(p0, p1);
+crate::hir::visitor::visit(p0, p1);
-----------------
regex-syntax/src/unicode.rs unicode::simple_fold
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::simple_fold(p0);
+crate::unicode::simple_fold(p0);
+crate::unicode::simple_fold(p0);
-----------------
regex-syntax/src/unicode.rs unicode::simple_fold::imp
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::simple_fold::imp(p0);
+crate::unicode::simple_fold::imp(p0);
+crate::unicode::simple_fold::imp(p0);
-----------------
regex-syntax/src/unicode.rs unicode::contains_simple_case_mapping
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+unicode::contains_simple_case_mapping(p0, p1);
+crate::unicode::contains_simple_case_mapping(p0, p1);
+crate::unicode::contains_simple_case_mapping(p0, p1);
-----------------
regex-syntax/src/unicode.rs unicode::contains_simple_case_mapping::imp
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+unicode::contains_simple_case_mapping::imp(p0, p1);
+crate::unicode::contains_simple_case_mapping::imp(p0, p1);
+crate::unicode::contains_simple_case_mapping::imp(p0, p1);
-----------------
regex-syntax/src/unicode.rs unicode::class
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'_>
+unicode::class(p0);
+crate::unicode::class(p0);
+crate::unicode::class(p0);
-----------------
regex-syntax/src/unicode.rs unicode::perl_word
deps:{}
candidates:{}
+unicode::perl_word();
+crate::unicode::perl_word();
+crate::unicode::perl_word();
-----------------
regex-syntax/src/unicode.rs unicode::perl_word::imp
deps:{}
candidates:{}
+unicode::perl_word::imp();
+crate::unicode::perl_word::imp();
+crate::unicode::perl_word::imp();
-----------------
regex-syntax/src/unicode.rs unicode::perl_space
deps:{}
candidates:{}
+unicode::perl_space();
+crate::unicode::perl_space();
+crate::unicode::perl_space();
-----------------
regex-syntax/src/unicode.rs unicode::perl_space::imp
deps:{}
candidates:{}
+unicode::perl_space::imp();
+crate::unicode::perl_space::imp();
+crate::unicode::perl_space::imp();
-----------------
regex-syntax/src/unicode.rs unicode::perl_digit
deps:{}
candidates:{}
+unicode::perl_digit();
+crate::unicode::perl_digit();
+crate::unicode::perl_digit();
-----------------
regex-syntax/src/unicode.rs unicode::perl_digit::imp
deps:{}
candidates:{}
+unicode::perl_digit::imp();
+crate::unicode::perl_digit::imp();
+crate::unicode::perl_digit::imp();
-----------------
regex-syntax/src/unicode.rs unicode::hir_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(char, char)]
+unicode::hir_class(p0);
+crate::unicode::hir_class(p0);
+crate::unicode::hir_class(p0);
-----------------
regex-syntax/src/unicode.rs unicode::is_word_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::is_word_character(p0);
+crate::unicode::is_word_character(p0);
+crate::unicode::is_word_character(p0);
-----------------
regex-syntax/src/unicode.rs unicode::is_word_character::imp
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+unicode::is_word_character::imp(p0);
+crate::unicode::is_word_character::imp(p0);
+crate::unicode::is_word_character::imp(p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_gencat
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_gencat(&p0);
+crate::unicode::canonical_gencat(&p0);
+crate::unicode::canonical_gencat(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_script
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_script(&p0);
+crate::unicode::canonical_script(&p0);
+crate::unicode::canonical_script(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_prop
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_prop(&p0);
+crate::unicode::canonical_prop(&p0);
+crate::unicode::canonical_prop(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_prop::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::canonical_prop::imp(&p0);
+crate::unicode::canonical_prop::imp(&p0);
+crate::unicode::canonical_prop::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::canonical_value
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(&'static str, &'static str)]
let mut p1 = "sample"; // None+&str
+unicode::canonical_value(p0, &p1);
+crate::unicode::canonical_value(p0, &p1);
+crate::unicode::canonical_value(p0, &p1);
-----------------
regex-syntax/src/unicode.rs unicode::property_values
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::property_values(&p0);
+crate::unicode::property_values(&p0);
+crate::unicode::property_values(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::property_values::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::property_values::imp(&p0);
+crate::unicode::property_values::imp(&p0);
+crate::unicode::property_values::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::property_set
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [(&'static str, &'static [(char, char)])]
let mut p1 = "sample"; // None+&str
+unicode::property_set(p0, &p1);
+crate::unicode::property_set(p0, &p1);
+crate::unicode::property_set(p0, &p1);
-----------------
regex-syntax/src/unicode.rs unicode::ages
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::ages(&p0);
+crate::unicode::ages(&p0);
+crate::unicode::ages(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::ages::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::ages::imp(&p0);
+crate::unicode::ages::imp(&p0);
+crate::unicode::ages::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::gencat
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gencat(&p0);
+crate::unicode::gencat(&p0);
+crate::unicode::gencat(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::gencat::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gencat::imp(&p0);
+crate::unicode::gencat::imp(&p0);
+crate::unicode::gencat::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::script
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script(&p0);
+crate::unicode::script(&p0);
+crate::unicode::script(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::script::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script::imp(&p0);
+crate::unicode::script::imp(&p0);
+crate::unicode::script::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::script_extension
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script_extension(&p0);
+crate::unicode::script_extension(&p0);
+crate::unicode::script_extension(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::script_extension::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::script_extension::imp(&p0);
+crate::unicode::script_extension::imp(&p0);
+crate::unicode::script_extension::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::bool_property
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::bool_property(&p0);
+crate::unicode::bool_property(&p0);
+crate::unicode::bool_property(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::bool_property::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::bool_property::imp(&p0);
+crate::unicode::bool_property::imp(&p0);
+crate::unicode::bool_property::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::gcb
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gcb(&p0);
+crate::unicode::gcb(&p0);
+crate::unicode::gcb(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::gcb::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::gcb::imp(&p0);
+crate::unicode::gcb::imp(&p0);
+crate::unicode::gcb::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::wb
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::wb(&p0);
+crate::unicode::wb(&p0);
+crate::unicode::wb(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::wb::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::wb::imp(&p0);
+crate::unicode::wb::imp(&p0);
+crate::unicode::wb::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::sb
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::sb(&p0);
+crate::unicode::sb(&p0);
+crate::unicode::sb(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::sb::imp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::sb::imp(&p0);
+crate::unicode::sb::imp(&p0);
+crate::unicode::sb::imp(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::symbolic_name_normalize
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+unicode::symbolic_name_normalize(&p0);
+crate::unicode::symbolic_name_normalize(&p0);
+crate::unicode::symbolic_name_normalize(&p0);
-----------------
regex-syntax/src/unicode.rs unicode::symbolic_name_normalize_bytes
deps:{}
candidates:{}
let mut p0 = &mut [0u8].as_mut_slice(); // None+[u8]
+unicode::symbolic_name_normalize_bytes(p0);
+crate::unicode::symbolic_name_normalize_bytes(p0);
+crate::unicode::symbolic_name_normalize_bytes(p0);
-----------------
regex-syntax/src/utf8.rs utf8::max_scalar_value
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+utf8::max_scalar_value(p0);
+crate::utf8::max_scalar_value(p0);
+crate::utf8::max_scalar_value(p0);
-----------------
regex-syntax/src/lib.rs escape
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+escape(&p0);
+crate::escape(&p0);
+crate::escape(&p0);
-----------------
regex-syntax/src/lib.rs escape_into
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+escape_into(&p0, p1);
+crate::escape_into(&p0, p1);
+crate::escape_into(&p0, p1);
-----------------
regex-syntax/src/lib.rs is_meta_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+is_meta_character(p0);
+crate::is_meta_character(p0);
+crate::is_meta_character(p0);
-----------------
regex-syntax/src/lib.rs is_word_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+is_word_character(p0);
+crate::is_word_character(p0);
+crate::is_word_character(p0);
-----------------
regex-syntax/src/lib.rs try_is_word_character
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+try_is_word_character(p0);
+crate::try_is_word_character(p0);
+crate::try_is_word_character(p0);
-----------------
regex-syntax/src/lib.rs is_word_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+is_word_byte(p0);
+crate::is_word_byte(p0);
+crate::is_word_byte(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::finish
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"ast::visitor::Visitor::finish":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::OsString","std::ffi::CString","std::sync::Arc<T>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::string::String"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::finish":{"Self":["ast::parse::NestLimiter","ast::print::Writer","hir::translate::TranslatorI"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.finish();
+ast::visitor::Visitor::finish(p0);
+crate::ast::visitor::Visitor::finish(p0);
+crate::ast::visitor::Visitor::finish(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::start
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"ast::visitor::Visitor::start":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::sync::Arc<T>","std::ffi::CString","std::string::String","std::rc::Rc<T>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","std::boxed::Box<T, A>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::start":{"Self":["ast::parse::NestLimiter","ast::print::Writer","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.start();
+ast::visitor::Visitor::start(p0);
+crate::ast::visitor::Visitor::start(p0);
+crate::ast::visitor::Visitor::start(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_pre
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::Visitor::visit_pre":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::string::String","<&T as std::fmt::Debug>","std::sync::Arc<T>","std::ffi::CString","std::ffi::OsString","std::rc::Rc<T>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::visit_pre":{"Self":["ast::parse::NestLimiter","ast::print::Writer","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+ast::visitor::Visitor::visit_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_pre(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_post
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::Visitor::visit_post":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::rc::Rc<T>","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","std::string::String","std::vec::Vec<T, A>","std::ffi::CString","std::boxed::Box<T, A>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_post":{"Self":["hir::translate::TranslatorI","ast::print::Writer","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+ast::visitor::Visitor::visit_post(p0, p1);
+crate::ast::visitor::Visitor::visit_post(p0, p1);
+crate::ast::visitor::Visitor::visit_post(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_alternation_in
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"ast::visitor::Visitor::visit_alternation_in":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::vec::Vec<T, A>","<&T as std::fmt::Debug>","std::rc::Rc<T>","std::sync::Arc<T>","std::ffi::OsString","std::path::PathBuf","std::string::String","std::boxed::Box<T, A>","std::ffi::CString"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::visit_alternation_in":{"Self":["ast::print::Writer","hir::translate::TranslatorI","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.visit_alternation_in();
+ast::visitor::Visitor::visit_alternation_in(p0);
+crate::ast::visitor::Visitor::visit_alternation_in(p0);
+crate::ast::visitor::Visitor::visit_alternation_in(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_item_pre
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"ast::visitor::Visitor::visit_class_set_item_pre":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::rc::Rc<T>","std::sync::Arc<T>","std::string::String","std::vec::Vec<T, A>","std::ffi::CString","std::boxed::Box<T, A>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_item_pre":{"Self":["hir::translate::TranslatorI","ast::print::Writer","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+ast::visitor::Visitor::visit_class_set_item_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_pre(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_item_post
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"ast::visitor::Visitor::visit_class_set_item_post":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::sync::Arc<T>","std::vec::Vec<T, A>","std::rc::Rc<T>","std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_item_post":{"Self":["ast::parse::NestLimiter","hir::translate::TranslatorI","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+ast::visitor::Visitor::visit_class_set_item_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_item_post(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_binary_op_pre
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"ast::visitor::Visitor::visit_class_set_binary_op_pre":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::path::PathBuf","std::boxed::Box<T, A>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::ffi::CString","std::string::String","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::Visitor::visit_class_set_binary_op_pre":{"Self":["hir::translate::TranslatorI","ast::print::Writer","ast::parse::NestLimiter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_pre(p1);
+ast::visitor::Visitor::visit_class_set_binary_op_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_pre(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_pre(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_binary_op_post
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"ast::visitor::Visitor::visit_class_set_binary_op_post":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::rc::Rc<T>","std::vec::Vec<T, A>","std::ffi::CString","std::path::PathBuf","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::visit_class_set_binary_op_post":{"Self":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_post(p1);
+ast::visitor::Visitor::visit_class_set_binary_op_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_post(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_post(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Visitor::visit_class_set_binary_op_in
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::Visitor::visit_class_set_binary_op_in":{"Self":["ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::vec::Vec<T, A>","std::string::String","std::path::PathBuf","std::ffi::OsString"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::Visitor::visit_class_set_binary_op_in":{"Self":["hir::translate::TranslatorI","ast::parse::NestLimiter","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_in(p1);
+ast::visitor::Visitor::visit_class_set_binary_op_in(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_in(p0, p1);
+crate::ast::visitor::Visitor::visit_class_set_binary_op_in(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::lower
deps:{"hir::interval::Interval::lower":{"Self":["std::marker::Copy","std::clone::Clone","hir::interval::Interval","std::default::Default","std::cmp::Eq","std::cmp::PartialOrd","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Ord"]}}
candidates:{"hir::interval::Interval::lower":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.lower();
+hir::interval::Interval::lower(p0);
+crate::hir::interval::Interval::lower(p0);
+crate::hir::interval::Interval::lower(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::upper
deps:{"hir::interval::Interval::upper":{"Self":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::Ord","std::default::Default","std::marker::Copy","std::cmp::PartialEq","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::upper":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.upper();
+hir::interval::Interval::upper(p0);
+crate::hir::interval::Interval::upper(p0);
+crate::hir::interval::Interval::upper(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::set_lower
deps:{"hir::interval::Interval::set_lower":{"Self":["std::fmt::Debug","std::cmp::Eq","std::default::Default","std::cmp::Ord","std::cmp::PartialOrd","std::marker::Copy","std::clone::Clone","std::cmp::PartialEq","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::set_lower":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
+p0.set_lower(p1);
+hir::interval::Interval::set_lower(p0, p1);
+crate::hir::interval::Interval::set_lower(p0, p1);
+crate::hir::interval::Interval::set_lower(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::set_upper
deps:{"hir::interval::Interval::set_upper":{"Self":["std::marker::Copy","hir::interval::Interval","std::default::Default","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::cmp::Ord","std::cmp::PartialOrd"]}}
candidates:{"hir::interval::Interval::set_upper":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
+p0.set_upper(p1);
+hir::interval::Interval::set_upper(p0, p1);
+crate::hir::interval::Interval::set_upper(p0, p1);
+crate::hir::interval::Interval::set_upper(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::case_fold_simple
deps:{"hir::interval::Interval::case_fold_simple":{"Self":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialOrd","std::marker::Copy","std::default::Default","std::clone::Clone","std::cmp::PartialEq","std::cmp::Ord","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::case_fold_simple":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<Self>
+p0.case_fold_simple(p1);
+hir::interval::Interval::case_fold_simple(p0, p1);
+crate::hir::interval::Interval::case_fold_simple(p0, p1);
+crate::hir::interval::Interval::case_fold_simple(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::create
deps:{"hir::interval::Interval::create":{"Self":["std::default::Default","std::cmp::Ord","std::cmp::PartialEq","std::clone::Clone","std::marker::Copy","std::cmp::PartialOrd","std::cmp::Eq","std::fmt::Debug","hir::interval::Interval"]}}
candidates:{"hir::interval::Interval::create":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
let mut p1 = MaybeUninit::uninit().assume_init(); // <Self as hir::interval::Interval>::Bound
+hir::interval::Interval::create(p0, p1);
+crate::hir::interval::Interval::create(p0, p1);
+crate::hir::interval::Interval::create(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::union
deps:{"hir::interval::Interval::union":{"Self":["std::cmp::Ord","std::cmp::Eq","std::cmp::PartialEq","std::marker::Copy","std::cmp::PartialOrd","hir::interval::Interval","std::clone::Clone","std::fmt::Debug","std::default::Default"]}}
candidates:{"hir::interval::Interval::union":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.union(p1);
+hir::interval::Interval::union(p0, p1);
+crate::hir::interval::Interval::union(p0, p1);
+crate::hir::interval::Interval::union(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::intersect
deps:{"hir::interval::Interval::intersect":{"Self":["std::cmp::Ord","std::marker::Copy","hir::interval::Interval","std::cmp::PartialEq","std::cmp::Eq","std::default::Default","std::clone::Clone","std::fmt::Debug","std::cmp::PartialOrd"]}}
candidates:{"hir::interval::Interval::intersect":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.intersect(p1);
+hir::interval::Interval::intersect(p0, p1);
+crate::hir::interval::Interval::intersect(p0, p1);
+crate::hir::interval::Interval::intersect(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::difference
deps:{"hir::interval::Interval::difference":{"Self":["std::cmp::Ord","hir::interval::Interval","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::PartialEq","std::marker::Copy","std::clone::Clone","std::fmt::Debug","std::default::Default"]}}
candidates:{"hir::interval::Interval::difference":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.difference(p1);
+hir::interval::Interval::difference(p0, p1);
+crate::hir::interval::Interval::difference(p0, p1);
+crate::hir::interval::Interval::difference(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::symmetric_difference
deps:{"hir::interval::Interval::symmetric_difference":{"Self":["std::cmp::PartialOrd","std::cmp::PartialEq","hir::interval::Interval","std::fmt::Debug","std::default::Default","std::cmp::Eq","std::marker::Copy","std::cmp::Ord","std::clone::Clone"]}}
candidates:{"hir::interval::Interval::symmetric_difference":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.symmetric_difference(p1);
+hir::interval::Interval::symmetric_difference(p0, p1);
+crate::hir::interval::Interval::symmetric_difference(p0, p1);
+crate::hir::interval::Interval::symmetric_difference(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::is_contiguous
deps:{"hir::interval::Interval::is_contiguous":{"Self":["std::cmp::PartialOrd","hir::interval::Interval","std::clone::Clone","std::marker::Copy","std::default::Default","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Ord"]}}
candidates:{"hir::interval::Interval::is_contiguous":{"Self":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_contiguous(p1);
+hir::interval::Interval::is_contiguous(p0, p1);
+crate::hir::interval::Interval::is_contiguous(p0, p1);
+crate::hir::interval::Interval::is_contiguous(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::is_intersection_empty
deps:{"hir::interval::Interval::is_intersection_empty":{"Self":["std::fmt::Debug","std::clone::Clone","std::marker::Copy","hir::interval::Interval","std::cmp::Ord","std::default::Default","std::cmp::Eq","std::cmp::PartialOrd","std::cmp::PartialEq"]}}
candidates:{"hir::interval::Interval::is_intersection_empty":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_intersection_empty(p1);
+hir::interval::Interval::is_intersection_empty(p0, p1);
+crate::hir::interval::Interval::is_intersection_empty(p0, p1);
+crate::hir::interval::Interval::is_intersection_empty(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Interval::is_subset
deps:{"hir::interval::Interval::is_subset":{"Self":["std::cmp::Eq","hir::interval::Interval","std::default::Default","std::clone::Clone","std::marker::Copy","std::fmt::Debug","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd"]}}
candidates:{"hir::interval::Interval::is_subset":{"Self":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_subset(p1);
+hir::interval::Interval::is_subset(p0, p1);
+crate::hir::interval::Interval::is_subset(p0, p1);
+crate::hir::interval::Interval::is_subset(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::min_value
deps:{"hir::interval::Bound::min_value":{"Self":["hir::interval::Bound","std::clone::Clone","std::cmp::Ord","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialOrd","std::marker::Copy","std::cmp::PartialEq"]}}
candidates:{"hir::interval::Bound::min_value":{"Self":["char","u8"]}}
+hir::interval::Bound::min_value();
+crate::hir::interval::Bound::min_value();
+crate::hir::interval::Bound::min_value();
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::max_value
deps:{"hir::interval::Bound::max_value":{"Self":["std::marker::Copy","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Ord","std::cmp::Eq","std::cmp::PartialOrd","hir::interval::Bound"]}}
candidates:{"hir::interval::Bound::max_value":{"Self":["u8","char"]}}
+hir::interval::Bound::max_value();
+crate::hir::interval::Bound::max_value();
+crate::hir::interval::Bound::max_value();
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::as_u32
deps:{"hir::interval::Bound::as_u32":{"Self":["std::fmt::Debug","std::cmp::PartialOrd","std::cmp::Eq","std::cmp::PartialEq","std::cmp::Ord","std::marker::Copy","hir::interval::Bound","std::clone::Clone"]}}
candidates:{"hir::interval::Bound::as_u32":{"Self":["char","u8"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.as_u32();
+hir::interval::Bound::as_u32(p0);
+crate::hir::interval::Bound::as_u32(p0);
+crate::hir::interval::Bound::as_u32(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::increment
deps:{"hir::interval::Bound::increment":{"Self":["std::cmp::Ord","std::clone::Clone","std::marker::Copy","std::cmp::PartialOrd","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","hir::interval::Bound"]}}
candidates:{"hir::interval::Bound::increment":{"Self":["u8","char"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.increment();
+hir::interval::Bound::increment(p0);
+crate::hir::interval::Bound::increment(p0);
+crate::hir::interval::Bound::increment(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::Bound::decrement
deps:{"hir::interval::Bound::decrement":{"Self":["std::cmp::PartialOrd","std::cmp::Ord","std::marker::Copy","std::fmt::Debug","std::cmp::PartialEq","hir::interval::Bound","std::cmp::Eq","std::clone::Clone"]}}
candidates:{"hir::interval::Bound::decrement":{"Self":["u8","char"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.decrement();
+hir::interval::Bound::decrement(p0);
+crate::hir::interval::Bound::decrement(p0);
+crate::hir::interval::Bound::decrement(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::finish
deps:{"hir::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"hir::visitor::Visitor::finish":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::finish":{"Self":["hir::print::Writer"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.finish();
+hir::visitor::Visitor::finish(p0);
+crate::hir::visitor::Visitor::finish(p0);
+crate::hir::visitor::Visitor::finish(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::start
deps:{"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"hir::visitor::Visitor::start":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::start":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.start();
+hir::visitor::Visitor::start(p0);
+crate::hir::visitor::Visitor::start(p0);
+crate::hir::visitor::Visitor::start(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::visit_pre
deps:{"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"hir::visitor::Visitor::visit_pre":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::visit_pre":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_pre(p1);
+hir::visitor::Visitor::visit_pre(p0, p1);
+crate::hir::visitor::Visitor::visit_pre(p0, p1);
+crate::hir::visitor::Visitor::visit_pre(p0, p1);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::visit_post
deps:{"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"hir::visitor::Visitor::visit_post":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"hir::visitor::Visitor::visit_post":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_post(p1);
+hir::visitor::Visitor::visit_post(p0, p1);
+crate::hir::visitor::Visitor::visit_post(p0, p1);
+crate::hir::visitor::Visitor::visit_post(p0, p1);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Visitor::visit_alternation_in
deps:{"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"hir::visitor::Visitor::visit_alternation_in":{"Self":["hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"hir::visitor::Visitor::visit_alternation_in":{"Self":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.visit_alternation_in();
+hir::visitor::Visitor::visit_alternation_in(p0);
+crate::hir::visitor::Visitor::visit_alternation_in(p0);
+crate::hir::visitor::Visitor::visit_alternation_in(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Primitive as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.clone();
+<ast::parse::Primitive as std::clone::Clone>::clone(p0);
+crate::<ast::parse::Primitive as std::clone::Clone>::clone(p0);
+<ast::parse::Primitive>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Primitive as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::Primitive as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::Primitive as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::Primitive>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.assert_receiver_is_total_eq();
+<ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::parse::Primitive as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::parse::Primitive>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Primitive as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.eq(p1);
+<ast::parse::Primitive as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::parse::Primitive as std::cmp::PartialEq>::eq(p0, p1);
+<ast::parse::Primitive>::eq(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Primitive::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.span();
+ast::parse::Primitive::span(p0);
+crate::ast::parse::Primitive::span(p0);
+<ast::parse::Primitive>::span(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Primitive::into_ast
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
+p0.into_ast();
+ast::parse::Primitive::into_ast(p0);
+crate::ast::parse::Primitive::into_ast(p0);
+<ast::parse::Primitive>::into_ast(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Primitive::into_class_set_item
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_set_item":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_set_item":{"P":["std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::CString","<T as std::borrow::Borrow<T>>","<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::ffi::OsString","std::borrow::Cow<'a, B>","std::path::PathBuf","std::vec::Vec<T, A>","std::string::String"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'_, P>
+p0.into_class_set_item(p1);
+ast::parse::Primitive::into_class_set_item(p0, p1);
+crate::ast::parse::Primitive::into_class_set_item(p0, p1);
+<ast::parse::Primitive>::into_class_set_item(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Primitive::into_class_literal
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_literal":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::Primitive::into_class_literal":{"P":["std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::OsString","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::string::String","std::ffi::CString","std::boxed::Box<T, A>","std::path::PathBuf"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::Primitive
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'_, P>
+p0.into_class_literal(p1);
+ast::parse::Primitive::into_class_literal(p0, p1);
+crate::ast::parse::Primitive::into_class_literal(p0, p1);
+<ast::parse::Primitive>::into_class_literal(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
+p0.clone();
+<ast::parse::ParserBuilder as std::clone::Clone>::clone(p0);
+crate::<ast::parse::ParserBuilder as std::clone::Clone>::clone(p0);
+<ast::parse::ParserBuilder>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::ParserBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<ast::parse::ParserBuilder as std::default::Default>::default();
+crate::<ast::parse::ParserBuilder as std::default::Default>::default();
+<ast::parse::ParserBuilder>::default();
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::new
deps:{}
candidates:{}
+ast::parse::ParserBuilder::new();
+crate::ast::parse::ParserBuilder::new();
+<ast::parse::ParserBuilder>::new();
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
+p0.build();
+ast::parse::ParserBuilder::build(p0);
+crate::ast::parse::ParserBuilder::build(p0);
+<ast::parse::ParserBuilder>::build(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+ast::parse::ParserBuilder::nest_limit(p0, p1);
+crate::ast::parse::ParserBuilder::nest_limit(p0, p1);
+<ast::parse::ParserBuilder>::nest_limit(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+ast::parse::ParserBuilder::octal(p0, p1);
+crate::ast::parse::ParserBuilder::octal(p0, p1);
+<ast::parse::ParserBuilder>::octal(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::ParserBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+ast::parse::ParserBuilder::ignore_whitespace(p0, p1);
+crate::ast::parse::ParserBuilder::ignore_whitespace(p0, p1);
+<ast::parse::ParserBuilder>::ignore_whitespace(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Parser as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Parser
+p0.clone();
+<ast::parse::Parser as std::clone::Clone>::clone(p0);
+crate::<ast::parse::Parser as std::clone::Clone>::clone(p0);
+<ast::parse::Parser>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::Parser as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Parser
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::Parser as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::Parser as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::Parser>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserI<'s, P> as std::clone::Clone>::clone
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone":{"P":["std::clone::Clone","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::borrow::Borrow","std::clone::Clone","std::fmt::Debug"]},"either::Either":{"Left":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"],"Right":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","hir::interval::Interval","std::cmp::Eq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone":{"P":["ast::HexLiteralKind","hir::Repetition","ast::WithComments","ast::LiteralKind","hir::translate::HirFrame","hir::translate::TranslatorI","hir::print::PrinterBuilder","ast::parse::ClassState","ast::Literal","ast::parse::Primitive","parser::Parser","ast::RepetitionOp","ast::ClassSetRange","ast::Error","ast::ClassSetUnion","ast::Repetition","either::Either","ast::Flag","ast::AssertionKind","ast::RepetitionRange","hir::translate::Translator","hir::ClassUnicode","ast::ClassAscii","ast::ClassSetBinaryOp","ast::Group","ast::ClassSetBinaryOpKind","ast::ClassUnicodeOpKind","ast::Comment","utf8::Utf8Range","hir::ClassBytesRange","hir::literal::Literals","hir::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","ast::ClassPerl","ast::Ast","ast::ClassBracketed","ast::ClassUnicode","ast::parse::ParserI","hir::HirKind","ast::Span","hir::ClassBytes","hir::Class","ast::FlagsItem","ast::GroupKind","hir::HirInfo","hir::Group","hir::GroupKind","ast::parse::GroupState","ast::ClassAsciiKind","error::Error","ast::ClassSetItem","ast::SetFlags","ast::RepetitionKind","hir::translate::Flags","ast::ErrorKind","hir::ClassUnicodeRange","hir::Hir","ast::print::PrinterBuilder","ast::Concat","hir::interval::IntervalSet","ast::ClassSet","hir::translate::TranslatorBuilder","ast::SpecialLiteralKind","hir::Anchor","ast::Alternation","hir::RepetitionRange","ast::FlagsItemKind","hir::RepetitionKind","ast::ClassUnicodeKind","utf8::Utf8Sequence","ast::parse::Parser","hir::Literal","hir::literal::Literal","hir::Error","ast::CaptureName","hir::WordBoundary","ast::Assertion","ast::Position","parser::ParserBuilder","ast::Class","ast::ClassPerlKind","ast::Flags","ast::parse::ParserBuilder"]},"ast::parse::ParserI":{"P":["std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::OsString","std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::path::PathBuf","std::rc::Rc<T>","std::string::String"]},"either::Either":{"Left":["ast::LiteralKind","ast::Literal","ast::Span","ast::ClassSetItem","hir::GroupKind","hir::Literal","ast::GroupKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::RepetitionKind","hir::Repetition","hir::interval::IntervalSet","ast::RepetitionOp","hir::Error","ast::Comment","hir::WordBoundary","ast::ClassSetBinaryOpKind","hir::Hir","hir::literal::Literal","ast::parse::Primitive","hir::HirKind","utf8::Utf8Sequence","ast::Class","ast::ClassSetBinaryOp","ast::ClassPerl","hir::Group","hir::RepetitionKind","ast::ClassUnicode","ast::FlagsItemKind","ast::ErrorKind","error::Error","ast::ClassPerlKind","ast::Concat","ast::Flags","ast::ClassAscii","ast::CaptureName","ast::Assertion","hir::ClassUnicodeRange","ast::FlagsItem","ast::ClassAsciiKind","ast::ClassUnicodeOpKind","hir::ClassUnicode","ast::WithComments","hir::Anchor","ast::ClassUnicodeKind","hir::literal::Literals","utf8::Utf8Range","ast::AssertionKind","ast::Error","hir::HirInfo","ast::Alternation","ast::Repetition","ast::SetFlags","ast::Position","ast::SpecialLiteralKind","ast::ClassBracketed","ast::ClassSetRange","hir::Class","ast::ClassSet","ast::HexLiteralKind","ast::Ast","either::Either","ast::ClassSetUnion","ast::RepetitionRange","hir::RepetitionRange","ast::Flag","ast::Group","hir::ErrorKind","hir::ClassBytesRange","hir::ClassBytes"],"Right":["ast::Concat","ast::Repetition","hir::ClassBytesRange","hir::Repetition","hir::ClassUnicodeRange","ast::Span","ast::Group","ast::ClassPerl","utf8::Utf8Range","error::Error","hir::Class","ast::ClassSetBinaryOp","ast::FlagsItemKind","hir::GroupKind","hir::literal::Literals","ast::ClassSetItem","ast::ErrorKind","hir::Literal","ast::WithComments","either::Either","ast::AssertionKind","hir::Anchor","ast::RepetitionOp","ast::ClassAscii","ast::Alternation","ast::Class","ast::SpecialLiteralKind","ast::Comment","hir::literal::Literal","ast::ClassPerlKind","ast::ClassSet","utf8::Utf8Sequence","ast::ClassUnicode","hir::ErrorKind","ast::ClassAsciiKind","ast::SetFlags","ast::Position","ast::ClassBracketed","hir::HirInfo","hir::WordBoundary","ast::parse::Primitive","ast::Error","ast::ClassUnicodeKind","ast::Literal","hir::interval::IntervalSet","ast::GroupKind","ast::RepetitionRange","ast::LiteralKind","hir::RepetitionKind","hir::ClassBytes","ast::CaptureName","ast::ClassSetUnion","hir::Group","hir::Error","ast::ClassSetRange","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","ast::FlagsItem","hir::HirKind","ast::Flags","ast::HexLiteralKind","ast::Assertion","ast::ClassUnicodeOpKind","hir::ClassUnicode","ast::Ast","ast::ClassSetBinaryOpKind","ast::RepetitionKind","hir::RepetitionRange","ast::Flag","hir::Hir"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.clone();
+<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone(p0);
+crate::<ast::parse::ParserI<'s, P> as std::clone::Clone>::clone(p0);
+<ast::parse::ParserI<'s, P>>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt":{"P":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow","std::clone::Clone"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"either::Either":{"Left":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"],"Right":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["hir::interval::Interval","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt":{"P":["hir::translate::Flags","ast::visitor::ClassFrame","hir::Group","ast::ClassSet","ast::parse::Parser","hir::HirKind","ast::Group","parser::Parser","hir::ClassBytesIter","utf8::ScalarRange","ast::Flags","ast::Position","ast::parse::ClassState","ast::ClassSetBinaryOpKind","ast::parse::Primitive","ast::Assertion","ast::Alternation","ast::ClassAsciiKind","hir::RepetitionKind","ast::RepetitionOp","ast::CaptureName","ast::ClassSetBinaryOp","hir::WordBoundary","ast::ClassUnicodeKind","hir::interval::IntervalSetIter","hir::ClassUnicodeIter","ast::HexLiteralKind","hir::HirInfo","ast::Class","ast::LiteralKind","hir::ClassUnicodeRange","ast::Literal","ast::ClassAscii","ast::WithComments","hir::ClassBytes","ast::Span","hir::print::Writer","hir::translate::TranslatorI","hir::translate::HirFrame","ast::print::PrinterBuilder","<*mut T as std::fmt::Debug>","hir::Repetition","ast::parse::NestLimiter","ast::ClassSetUnion","unicode::CanonicalClassQuery","hir::translate::Translator","ast::AssertionKind","ast::RepetitionRange","ast::visitor::ClassInduct","hir::print::Printer","hir::print::PrinterBuilder","unicode::ClassQuery","ast::RepetitionKind","unicode::UnicodeWordError","<*const T as std::fmt::Debug>","hir::Anchor","error::Formatter","ast::ErrorKind","hir::interval::IntervalSet","hir::literal::Literal","ast::GroupKind","hir::Class","hir::Literal","ast::print::Printer","parser::ParserBuilder","hir::GroupKind","ast::Flag","ast::parse::ParserI","hir::ErrorKind","ast::ClassUnicode","hir::ClassUnicode","either::Either","hir::translate::TranslatorBuilder","hir::RepetitionRange","ast::ClassSetRange","ast::FlagsItemKind","utf8::Utf8Sequences","ast::Concat","utf8::Utf8Sequence","ast::Ast","unicode::CaseFoldError","ast::ClassSetItem","ast::Error","ast::ClassPerl","ast::ClassUnicodeOpKind","ast::SetFlags","unicode::Error","ast::print::Writer","ast::Repetition","ast::FlagsItem","ast::parse::GroupState","utf8::Utf8Range","hir::Error","ast::SpecialLiteralKind","hir::Hir","hir::literal::Literals","hir::ClassBytesRange","ast::Comment","ast::ClassBracketed","ast::ClassPerlKind","ast::parse::ParserBuilder","error::Error"]},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::ffi::OsString","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::string::String","std::ffi::CString"]},"ast::parse::ParserI":{"P":["std::boxed::Box<T, A>","<&mut T as std::fmt::Debug>","std::ffi::OsString","std::rc::Rc<T>","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::CString","std::string::String","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::RepetitionRange","ast::Ast","ast::Error","hir::WordBoundary","ast::Alternation","ast::SetFlags","hir::ClassUnicodeRange","ast::ClassSet","hir::Group","utf8::Utf8Sequence","std::clone::impls::<impl std::clone::Clone for *const T>","ast::ClassBracketed","hir::ClassUnicode","hir::ErrorKind","ast::ClassSetBinaryOpKind","ast::Assertion","error::Error","hir::ClassBytes","ast::Flags","hir::HirKind","hir::RepetitionKind","hir::Literal","ast::FlagsItem","ast::GroupKind","hir::literal::Literals","ast::ClassSetItem","ast::Class","hir::RepetitionRange","ast::Literal","ast::WithComments","ast::RepetitionKind","hir::Error","hir::GroupKind","ast::ClassSetBinaryOp","hir::ClassBytesRange","hir::literal::Literal","hir::Class","ast::Comment","ast::HexLiteralKind","ast::ClassUnicode","ast::parse::Primitive","ast::FlagsItemKind","hir::Anchor","hir::HirInfo","ast::ClassPerl","either::Either","ast::ClassUnicodeKind","ast::ClassAscii","ast::SpecialLiteralKind","ast::CaptureName","hir::Hir","utf8::Utf8Range","ast::Repetition","ast::ClassUnicodeOpKind","ast::RepetitionOp","ast::Span","ast::Flag","ast::LiteralKind","ast::AssertionKind","hir::interval::IntervalSet","ast::Group","ast::ClassAsciiKind","ast::ClassSetUnion","hir::Repetition","ast::ClassSetRange","ast::ClassPerlKind","ast::ErrorKind","ast::Position","ast::Concat"],"Right":["ast::ClassPerl","ast::ClassSetRange","hir::Repetition","either::Either","hir::GroupKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","ast::Comment","ast::FlagsItem","hir::Error","hir::HirInfo","ast::ClassBracketed","hir::Hir","ast::Group","hir::interval::IntervalSet","ast::Position","ast::ClassSetUnion","hir::literal::Literals","ast::Assertion","ast::ClassUnicodeKind","ast::Literal","ast::CaptureName","ast::parse::Primitive","hir::ClassUnicode","hir::Literal","ast::FlagsItemKind","ast::Error","ast::Repetition","ast::SetFlags","ast::Class","ast::Alternation","ast::WithComments","hir::Group","ast::ClassSet","ast::ClassAscii","ast::RepetitionKind","ast::ClassSetItem","ast::RepetitionOp","ast::SpecialLiteralKind","ast::ClassSetBinaryOp","ast::GroupKind","utf8::Utf8Sequence","ast::HexLiteralKind","ast::RepetitionRange","hir::ClassUnicodeRange","hir::literal::Literal","utf8::Utf8Range","ast::ClassPerlKind","ast::LiteralKind","ast::Span","ast::Ast","hir::Anchor","ast::ErrorKind","ast::Concat","ast::ClassAsciiKind","hir::ClassBytes","ast::ClassUnicodeOpKind","ast::Flags","hir::HirKind","hir::RepetitionKind","hir::RepetitionRange","ast::ClassSetBinaryOpKind","hir::WordBoundary","error::Error","ast::AssertionKind","ast::Flag","hir::ClassBytesRange","hir::Class","hir::ErrorKind","ast::ClassUnicode"]},"error::Formatter":{"E":["ast::Ast","ast::ErrorKind","hir::ErrorKind","unicode::CaseFoldError","error::Error","hir::Hir","error::Formatter","unicode::UnicodeWordError","hir::Error","ast::Error","<&mut T as std::fmt::Display>"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["hir::Repetition","ast::ErrorKind","hir::ClassUnicodeRange","ast::WithComments","hir::ClassBytesRange","ast::GroupKind","hir::HirInfo","ast::FlagsItemKind","hir::Group","hir::literal::Literals","ast::parse::GroupState","ast::FlagsItem","hir::ClassBytesIter","ast::Position","ast::print::Printer","hir::Class","ast::Concat","ast::parse::Parser","parser::ParserBuilder","ast::print::PrinterBuilder","hir::RepetitionRange","ast::AssertionKind","hir::WordBoundary","hir::print::PrinterBuilder","utf8::ScalarRange","hir::Literal","ast::ClassBracketed","ast::SetFlags","<*const T as std::fmt::Debug>","ast::Alternation","ast::RepetitionOp","ast::HexLiteralKind","ast::visitor::ClassFrame","utf8::Utf8Sequences","hir::print::Printer","utf8::Utf8Sequence","ast::parse::ParserI","ast::ClassSetBinaryOpKind","ast::ClassSetBinaryOp","ast::parse::NestLimiter","unicode::Error","ast::ClassPerl","ast::ClassUnicodeKind","ast::RepetitionRange","hir::translate::Translator","ast::ClassUnicodeOpKind","hir::translate::Flags","hir::interval::IntervalSet","error::Formatter","hir::ClassUnicodeIter","ast::Ast","ast::Literal","hir::HirKind","ast::ClassAscii","hir::translate::HirFrame","ast::Comment","hir::RepetitionKind","unicode::ClassQuery","ast::Repetition","hir::ClassUnicode","unicode::CanonicalClassQuery","hir::ClassBytes","ast::ClassSet","error::Error","ast::ClassUnicode","hir::GroupKind","unicode::CaseFoldError","parser::Parser","ast::ClassSetRange","utf8::Utf8Range","ast::LiteralKind","unicode::UnicodeWordError","hir::translate::TranslatorI","ast::ClassPerlKind","hir::Error","ast::visitor::ClassInduct","ast::RepetitionKind","ast::Span","ast::Flags","ast::CaptureName","ast::Error","hir::Hir","ast::ClassAsciiKind","hir::literal::Literal","ast::SpecialLiteralKind","ast::Flag","hir::interval::IntervalSetIter","hir::translate::TranslatorBuilder","hir::Anchor","ast::parse::ClassState","ast::Class","either::Either","ast::Assertion","ast::ClassSetItem","ast::parse::ParserBuilder","ast::parse::Primitive","ast::print::Writer","hir::ErrorKind","hir::print::Writer","ast::Group","ast::ClassSetUnion"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::ParserI<'s, P> as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::ParserI<'s, P>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::GroupState as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::GroupState
+p0.clone();
+<ast::parse::GroupState as std::clone::Clone>::clone(p0);
+crate::<ast::parse::GroupState as std::clone::Clone>::clone(p0);
+<ast::parse::GroupState>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::GroupState as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::GroupState
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::GroupState as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::GroupState as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::GroupState>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ClassState as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ClassState
+p0.clone();
+<ast::parse::ClassState as std::clone::Clone>::clone(p0);
+crate::<ast::parse::ClassState as std::clone::Clone>::clone(p0);
+<ast::parse::ClassState>::clone(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::ClassState as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ClassState
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::ClassState as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::ClassState as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::ClassState>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Parser::new
deps:{}
candidates:{}
+ast::parse::Parser::new();
+crate::ast::parse::Parser::new();
+<ast::parse::Parser>::new();
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Parser::parse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::Parser
let mut p1 = "sample"; // None+&str
+p0.parse(&p1);
+ast::parse::Parser::parse(p0, &p1);
+crate::ast::parse::Parser::parse(p0, &p1);
+<ast::parse::Parser>::parse(p0, &p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Parser::parse_with_comments
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::Parser
let mut p1 = "sample"; // None+&str
+p0.parse_with_comments(&p1);
+ast::parse::Parser::parse_with_comments(p0, &p1);
+crate::ast::parse::Parser::parse_with_comments(p0, &p1);
+<ast::parse::Parser>::parse_with_comments(p0, &p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::Parser::reset
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::Parser
+p0.reset();
+ast::parse::Parser::reset(p0);
+crate::ast::parse::Parser::reset(p0);
+<ast::parse::Parser>::reset(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::new
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::new":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::new":{"P":["std::string::String","std::sync::Arc<T>","std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::CString","std::ffi::OsString","std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::rc::Rc<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // P
let mut p1 = "sample"; // None+&str
+ast::parse::ParserI::<'s, P>::new(p0, &p1);
+crate::ast::parse::ParserI::<'s, P>::new(p0, &p1);
+<ast::parse::ParserI<'s, P>>::new(p0, &p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parser
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parser":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parser":{"P":["<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::path::PathBuf","std::string::String","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::ffi::CString","std::sync::Arc<T>","std::rc::Rc<T>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parser();
+ast::parse::ParserI::<'s, P>::parser(p0);
+crate::ast::parse::ParserI::<'s, P>::parser(p0);
+<ast::parse::ParserI<'s, P>>::parser(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pattern
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pattern":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pattern":{"P":["std::ffi::CString","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::ffi::OsString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::string::String","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.pattern();
+ast::parse::ParserI::<'s, P>::pattern(p0);
+crate::ast::parse::ParserI::<'s, P>::pattern(p0);
+<ast::parse::ParserI<'s, P>>::pattern(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::error
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::error":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::error":{"P":["std::sync::Arc<T>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::string::String","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::path::PathBuf","std::ffi::CString","<&T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.error(p1, p2);
+ast::parse::ParserI::<'s, P>::error(p0, p1, p2);
+crate::ast::parse::ParserI::<'s, P>::error(p0, p1, p2);
+<ast::parse::ParserI<'s, P>>::error(p0, p1, p2);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::offset
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::offset":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::offset":{"P":["std::vec::Vec<T, A>","std::path::PathBuf","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::ffi::OsString","std::sync::Arc<T>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.offset();
+ast::parse::ParserI::<'s, P>::offset(p0);
+crate::ast::parse::ParserI::<'s, P>::offset(p0);
+<ast::parse::ParserI<'s, P>>::offset(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::line
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::line":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::line":{"P":["std::rc::Rc<T>","std::ffi::OsString","std::sync::Arc<T>","std::borrow::Cow<'a, B>","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::CString","std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.line();
+ast::parse::ParserI::<'s, P>::line(p0);
+crate::ast::parse::ParserI::<'s, P>::line(p0);
+<ast::parse::ParserI<'s, P>>::line(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::column
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::column":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::column":{"P":["std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::string::String","std::ffi::OsString","std::ffi::CString","std::path::PathBuf","std::sync::Arc<T>","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.column();
+ast::parse::ParserI::<'s, P>::column(p0);
+crate::ast::parse::ParserI::<'s, P>::column(p0);
+<ast::parse::ParserI<'s, P>>::column(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::next_capture_index
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::next_capture_index":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::next_capture_index":{"P":["std::ffi::OsString","std::path::PathBuf","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","<&mut T as std::borrow::Borrow<T>>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
+p0.next_capture_index(p1);
+ast::parse::ParserI::<'s, P>::next_capture_index(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::next_capture_index(p0, p1);
+<ast::parse::ParserI<'s, P>>::next_capture_index(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::add_capture_name
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::add_capture_name":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::add_capture_name":{"P":["std::ffi::OsString","std::sync::Arc<T>","std::vec::Vec<T, A>","std::path::PathBuf","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::CString","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.add_capture_name(p1);
+ast::parse::ParserI::<'s, P>::add_capture_name(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::add_capture_name(p0, p1);
+<ast::parse::ParserI<'s, P>>::add_capture_name(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::ignore_whitespace
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::ignore_whitespace":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::ignore_whitespace":{"P":["std::sync::Arc<T>","<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::string::String","std::ffi::OsString","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::path::PathBuf","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.ignore_whitespace();
+ast::parse::ParserI::<'s, P>::ignore_whitespace(p0);
+crate::ast::parse::ParserI::<'s, P>::ignore_whitespace(p0);
+<ast::parse::ParserI<'s, P>>::ignore_whitespace(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::char
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char":{"P":["<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::ffi::OsString","std::rc::Rc<T>","std::path::PathBuf","std::sync::Arc<T>","std::borrow::Cow<'a, B>","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.char();
+ast::parse::ParserI::<'s, P>::char(p0);
+crate::ast::parse::ParserI::<'s, P>::char(p0);
+<ast::parse::ParserI<'s, P>>::char(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::char_at
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char_at":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::char_at":{"P":["std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::boxed::Box<T, A>","std::rc::Rc<T>","std::string::String","std::sync::Arc<T>","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = 0usize; // None+usize
+p0.char_at(p1);
+ast::parse::ParserI::<'s, P>::char_at(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::char_at(p0, p1);
+<ast::parse::ParserI<'s, P>>::char_at(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump":{"P":["std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::rc::Rc<T>","std::string::String","std::path::PathBuf","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.bump();
+ast::parse::ParserI::<'s, P>::bump(p0);
+crate::ast::parse::ParserI::<'s, P>::bump(p0);
+<ast::parse::ParserI<'s, P>>::bump(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump_if
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_if":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_if":{"P":["std::boxed::Box<T, A>","std::path::PathBuf","std::rc::Rc<T>","std::borrow::Cow<'a, B>","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::ffi::OsString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::string::String","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = "sample"; // None+&str
+p0.bump_if(&p1);
+ast::parse::ParserI::<'s, P>::bump_if(p0, &p1);
+crate::ast::parse::ParserI::<'s, P>::bump_if(p0, &p1);
+<ast::parse::ParserI<'s, P>>::bump_if(p0, &p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::is_lookaround_prefix
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_lookaround_prefix":{"P":["std::vec::Vec<T, A>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","<&T as std::borrow::Borrow<T>>","std::string::String","std::ffi::OsString","std::rc::Rc<T>","std::path::PathBuf","std::sync::Arc<T>","std::ffi::CString","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.is_lookaround_prefix();
+ast::parse::ParserI::<'s, P>::is_lookaround_prefix(p0);
+crate::ast::parse::ParserI::<'s, P>::is_lookaround_prefix(p0);
+<ast::parse::ParserI<'s, P>>::is_lookaround_prefix(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump_and_bump_space
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_and_bump_space":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_and_bump_space":{"P":["std::sync::Arc<T>","<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::boxed::Box<T, A>","std::path::PathBuf","std::vec::Vec<T, A>","std::string::String","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.bump_and_bump_space();
+ast::parse::ParserI::<'s, P>::bump_and_bump_space(p0);
+crate::ast::parse::ParserI::<'s, P>::bump_and_bump_space(p0);
+<ast::parse::ParserI<'s, P>>::bump_and_bump_space(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::bump_space
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_space":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::bump_space":{"P":["std::ffi::OsString","std::sync::Arc<T>","std::string::String","std::ffi::CString","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::path::PathBuf","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.bump_space();
+ast::parse::ParserI::<'s, P>::bump_space(p0);
+crate::ast::parse::ParserI::<'s, P>::bump_space(p0);
+<ast::parse::ParserI<'s, P>>::bump_space(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::peek
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek":{"P":["std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","std::ffi::CString","std::sync::Arc<T>","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::rc::Rc<T>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.peek();
+ast::parse::ParserI::<'s, P>::peek(p0);
+crate::ast::parse::ParserI::<'s, P>::peek(p0);
+<ast::parse::ParserI<'s, P>>::peek(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::peek_space
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek_space":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::peek_space":{"P":["std::path::PathBuf","std::sync::Arc<T>","std::string::String","std::vec::Vec<T, A>","std::rc::Rc<T>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::ffi::OsString","std::ffi::CString","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.peek_space();
+ast::parse::ParserI::<'s, P>::peek_space(p0);
+crate::ast::parse::ParserI::<'s, P>::peek_space(p0);
+<ast::parse::ParserI<'s, P>>::peek_space(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::is_eof
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_eof":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::is_eof":{"P":["std::vec::Vec<T, A>","std::string::String","std::ffi::CString","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::path::PathBuf","<T as std::borrow::Borrow<T>>","std::ffi::OsString","std::rc::Rc<T>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.is_eof();
+ast::parse::ParserI::<'s, P>::is_eof(p0);
+crate::ast::parse::ParserI::<'s, P>::is_eof(p0);
+<ast::parse::ParserI<'s, P>>::is_eof(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pos
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pos":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pos":{"P":["std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","std::path::PathBuf","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.pos();
+ast::parse::ParserI::<'s, P>::pos(p0);
+crate::ast::parse::ParserI::<'s, P>::pos(p0);
+<ast::parse::ParserI<'s, P>>::pos(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::span
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span":{"P":["std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::vec::Vec<T, A>","std::rc::Rc<T>","std::boxed::Box<T, A>","std::path::PathBuf","std::string::String","std::sync::Arc<T>","std::borrow::Cow<'a, B>","<&T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.span();
+ast::parse::ParserI::<'s, P>::span(p0);
+crate::ast::parse::ParserI::<'s, P>::span(p0);
+<ast::parse::ParserI<'s, P>>::span(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::span_char
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span_char":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::span_char":{"P":["std::vec::Vec<T, A>","std::path::PathBuf","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::OsString","std::ffi::CString","std::string::String","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.span_char();
+ast::parse::ParserI::<'s, P>::span_char(p0);
+crate::ast::parse::ParserI::<'s, P>::span_char(p0);
+<ast::parse::ParserI<'s, P>>::span_char(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_alternate
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_alternate":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_alternate":{"P":["std::string::String","std::path::PathBuf","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::ffi::OsString","std::ffi::CString","std::boxed::Box<T, A>","std::sync::Arc<T>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.push_alternate(p1);
+ast::parse::ParserI::<'s, P>::push_alternate(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_alternate(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_alternate(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_or_add_alternation
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_or_add_alternation":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_or_add_alternation":{"P":["<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","std::string::String","std::ffi::OsString","std::path::PathBuf","std::borrow::Cow<'a, B>","std::ffi::CString","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.push_or_add_alternation(p1);
+ast::parse::ParserI::<'s, P>::push_or_add_alternation(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_or_add_alternation(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_or_add_alternation(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_group
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_group":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_group":{"P":["std::ffi::OsString","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::string::String","std::ffi::CString","std::sync::Arc<T>","std::vec::Vec<T, A>","std::path::PathBuf","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.push_group(p1);
+ast::parse::ParserI::<'s, P>::push_group(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_group(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_group(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_group
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group":{"P":["std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::path::PathBuf","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::string::String","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.pop_group(p1);
+ast::parse::ParserI::<'s, P>::pop_group(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_group(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_group(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_group_end
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group_end":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_group_end":{"P":["std::sync::Arc<T>","std::vec::Vec<T, A>","std::rc::Rc<T>","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>","std::string::String","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","std::boxed::Box<T, A>","std::path::PathBuf","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.pop_group_end(p1);
+ast::parse::ParserI::<'s, P>::pop_group_end(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_group_end(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_group_end(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_class_open
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_open":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_open":{"P":["std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf","std::ffi::OsString","std::borrow::Cow<'a, B>","std::ffi::CString","std::string::String","std::vec::Vec<T, A>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.push_class_open(p1);
+ast::parse::ParserI::<'s, P>::push_class_open(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::push_class_open(p0, p1);
+<ast::parse::ParserI<'s, P>>::push_class_open(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class":{"P":["std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::CString","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::ffi::OsString","std::borrow::Cow<'a, B>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.pop_class(p1);
+ast::parse::ParserI::<'s, P>::pop_class(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_class(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_class(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::unclosed_class_error
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::unclosed_class_error":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::unclosed_class_error":{"P":["std::borrow::Cow<'a, B>","std::path::PathBuf","std::vec::Vec<T, A>","std::rc::Rc<T>","std::sync::Arc<T>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::string::String","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.unclosed_class_error();
+ast::parse::ParserI::<'s, P>::unclosed_class_error(p0);
+crate::ast::parse::ParserI::<'s, P>::unclosed_class_error(p0);
+<ast::parse::ParserI<'s, P>>::unclosed_class_error(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::push_class_op
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_op":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::push_class_op":{"P":["<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::path::PathBuf","std::string::String","std::ffi::CString","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.push_class_op(p1, p2);
+ast::parse::ParserI::<'s, P>::push_class_op(p0, p1, p2);
+crate::ast::parse::ParserI::<'s, P>::push_class_op(p0, p1, p2);
+<ast::parse::ParserI<'s, P>>::push_class_op(p0, p1, p2);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::pop_class_op
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class_op":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::pop_class_op":{"P":["std::borrow::Cow<'a, B>","std::string::String","std::rc::Rc<T>","std::boxed::Box<T, A>","std::ffi::OsString","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::ffi::CString","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.pop_class_op(p1);
+ast::parse::ParserI::<'s, P>::pop_class_op(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::pop_class_op(p0, p1);
+<ast::parse::ParserI<'s, P>>::pop_class_op(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse":{"P":["std::ffi::OsString","std::ffi::CString","std::rc::Rc<T>","std::vec::Vec<T, A>","std::path::PathBuf","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse();
+ast::parse::ParserI::<'s, P>::parse(p0);
+crate::ast::parse::ParserI::<'s, P>::parse(p0);
+<ast::parse::ParserI<'s, P>>::parse(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_with_comments
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_with_comments":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_with_comments":{"P":["<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::path::PathBuf","std::ffi::CString","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::ffi::OsString","std::string::String","std::vec::Vec<T, A>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_with_comments();
+ast::parse::ParserI::<'s, P>::parse_with_comments(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_with_comments(p0);
+<ast::parse::ParserI<'s, P>>::parse_with_comments(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_uncounted_repetition
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_uncounted_repetition":{"P":["std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::ffi::CString","std::boxed::Box<T, A>","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::OsString","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
let mut p2 = MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.parse_uncounted_repetition(p1, p2);
+ast::parse::ParserI::<'s, P>::parse_uncounted_repetition(p0, p1, p2);
+crate::ast::parse::ParserI::<'s, P>::parse_uncounted_repetition(p0, p1, p2);
+<ast::parse::ParserI<'s, P>>::parse_uncounted_repetition(p0, p1, p2);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_counted_repetition
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_counted_repetition":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_counted_repetition":{"P":["<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::ffi::OsString","std::path::PathBuf","std::rc::Rc<T>","std::ffi::CString","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.parse_counted_repetition(p1);
+ast::parse::ParserI::<'s, P>::parse_counted_repetition(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_counted_repetition(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_counted_repetition(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_group
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_group":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_group":{"P":["std::ffi::OsString","std::string::String","std::ffi::CString","std::rc::Rc<T>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_group();
+ast::parse::ParserI::<'s, P>::parse_group(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_group(p0);
+<ast::parse::ParserI<'s, P>>::parse_group(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_capture_name
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_capture_name":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_capture_name":{"P":["<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::rc::Rc<T>","std::string::String","std::ffi::OsString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::path::PathBuf","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = 0u32; // None+u32
+p0.parse_capture_name(p1);
+ast::parse::ParserI::<'s, P>::parse_capture_name(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_capture_name(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_capture_name(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_flags
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flags":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flags":{"P":["std::sync::Arc<T>","std::string::String","std::path::PathBuf","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::ffi::CString","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_flags();
+ast::parse::ParserI::<'s, P>::parse_flags(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_flags(p0);
+<ast::parse::ParserI<'s, P>>::parse_flags(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_flag
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flag":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_flag":{"P":["<&T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::ffi::OsString","std::string::String","std::rc::Rc<T>","std::boxed::Box<T, A>","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::CString","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_flag();
+ast::parse::ParserI::<'s, P>::parse_flag(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_flag(p0);
+<ast::parse::ParserI<'s, P>>::parse_flag(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_primitive
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_primitive":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_primitive":{"P":["std::ffi::CString","std::path::PathBuf","std::vec::Vec<T, A>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::ffi::OsString","std::sync::Arc<T>","std::borrow::Cow<'a, B>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_primitive();
+ast::parse::ParserI::<'s, P>::parse_primitive(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_primitive(p0);
+<ast::parse::ParserI<'s, P>>::parse_primitive(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_escape
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_escape":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_escape":{"P":["std::ffi::CString","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::rc::Rc<T>","std::sync::Arc<T>","std::string::String","std::path::PathBuf","<&T as std::borrow::Borrow<T>>","<&mut T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_escape();
+ast::parse::ParserI::<'s, P>::parse_escape(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_escape(p0);
+<ast::parse::ParserI<'s, P>>::parse_escape(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_octal
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_octal":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_octal":{"P":["std::string::String","std::vec::Vec<T, A>","std::rc::Rc<T>","std::ffi::CString","std::path::PathBuf","std::ffi::OsString","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_octal();
+ast::parse::ParserI::<'s, P>::parse_octal(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_octal(p0);
+<ast::parse::ParserI<'s, P>>::parse_octal(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_hex
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex":{"P":["std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::ffi::OsString","std::path::PathBuf","std::vec::Vec<T, A>","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","std::string::String","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_hex();
+ast::parse::ParserI::<'s, P>::parse_hex(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_hex(p0);
+<ast::parse::ParserI<'s, P>>::parse_hex(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_hex_digits
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_digits":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_digits":{"P":["std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::path::PathBuf","std::string::String","std::sync::Arc<T>","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.parse_hex_digits(p1);
+ast::parse::ParserI::<'s, P>::parse_hex_digits(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_hex_digits(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_hex_digits(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_hex_brace
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_brace":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_hex_brace":{"P":["std::rc::Rc<T>","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::path::PathBuf","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::string::String","std::ffi::CString","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.parse_hex_brace(p1);
+ast::parse::ParserI::<'s, P>::parse_hex_brace(p0, p1);
+crate::ast::parse::ParserI::<'s, P>::parse_hex_brace(p0, p1);
+<ast::parse::ParserI<'s, P>>::parse_hex_brace(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_decimal
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_decimal":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_decimal":{"P":["std::borrow::Cow<'a, B>","std::ffi::OsString","std::boxed::Box<T, A>","std::ffi::CString","<&T as std::borrow::Borrow<T>>","<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::sync::Arc<T>","std::string::String","std::vec::Vec<T, A>","std::rc::Rc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_decimal();
+ast::parse::ParserI::<'s, P>::parse_decimal(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_decimal(p0);
+<ast::parse::ParserI<'s, P>>::parse_decimal(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class":{"P":["std::path::PathBuf","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::boxed::Box<T, A>","std::ffi::CString","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::OsString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class();
+ast::parse::ParserI::<'s, P>::parse_set_class(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class_range
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_range":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_range":{"P":["<&T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::string::String","std::ffi::CString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>","std::ffi::OsString","std::boxed::Box<T, A>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class_range();
+ast::parse::ParserI::<'s, P>::parse_set_class_range(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class_range(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class_range(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class_item
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_item":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_item":{"P":["std::string::String","std::ffi::OsString","std::ffi::CString","std::rc::Rc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::path::PathBuf"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class_item();
+ast::parse::ParserI::<'s, P>::parse_set_class_item(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class_item(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class_item(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_set_class_open
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_open":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_set_class_open":{"P":["std::path::PathBuf","std::ffi::OsString","std::rc::Rc<T>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::ffi::CString","<T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::string::String","std::borrow::Cow<'a, B>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_set_class_open();
+ast::parse::ParserI::<'s, P>::parse_set_class_open(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_set_class_open(p0);
+<ast::parse::ParserI<'s, P>>::parse_set_class_open(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class":{"P":["std::path::PathBuf","std::ffi::CString","std::ffi::OsString","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","<&mut T as std::borrow::Borrow<T>>","std::string::String","std::boxed::Box<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","std::vec::Vec<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.maybe_parse_ascii_class();
+ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class(p0);
+crate::ast::parse::ParserI::<'s, P>::maybe_parse_ascii_class(p0);
+<ast::parse::ParserI<'s, P>>::maybe_parse_ascii_class(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_unicode_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_unicode_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_unicode_class":{"P":["std::rc::Rc<T>","std::ffi::OsString","std::string::String","std::path::PathBuf","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>","std::ffi::CString","std::vec::Vec<T, A>","std::sync::Arc<T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_unicode_class();
+ast::parse::ParserI::<'s, P>::parse_unicode_class(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_unicode_class(p0);
+<ast::parse::ParserI<'s, P>>::parse_unicode_class(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::ParserI::<'s, P>::parse_perl_class
's
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_perl_class":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::ParserI::<'s, P>::parse_perl_class":{"P":["<T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::string::String","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::path::PathBuf","std::ffi::CString"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+p0.parse_perl_class();
+ast::parse::ParserI::<'s, P>::parse_perl_class(p0);
+crate::ast::parse::ParserI::<'s, P>::parse_perl_class(p0);
+<ast::parse::ParserI<'s, P>>::parse_perl_class(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt":{"P":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug","std::clone::Clone"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"],"Right":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"error::Formatter":{"E":["std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","hir::interval::Interval","std::clone::Clone"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt":{"P":["hir::print::Writer","ast::parse::GroupState","ast::parse::ParserBuilder","hir::print::Printer","ast::Alternation","error::Error","ast::ClassUnicodeKind","hir::translate::HirFrame","ast::ClassSet","ast::Assertion","hir::print::PrinterBuilder","hir::HirKind","hir::Error","ast::AssertionKind","ast::Span","parser::Parser","ast::ClassPerl","ast::SpecialLiteralKind","ast::parse::ClassState","ast::ClassBracketed","hir::translate::TranslatorI","ast::parse::Parser","ast::Group","hir::RepetitionKind","hir::Anchor","ast::RepetitionOp","ast::RepetitionRange","ast::print::PrinterBuilder","unicode::ClassQuery","ast::ClassUnicodeOpKind","error::Formatter","hir::translate::TranslatorBuilder","ast::ClassPerlKind","ast::HexLiteralKind","ast::Concat","ast::ClassSetBinaryOp","hir::HirInfo","hir::ClassBytes","ast::Class","hir::ClassUnicode","hir::ClassBytesIter","hir::literal::Literal","either::Either","ast::WithComments","hir::translate::Flags","parser::ParserBuilder","utf8::Utf8Sequences","ast::Flags","hir::RepetitionRange","<&mut T as std::fmt::Debug>","ast::Flag","ast::visitor::ClassInduct","ast::ClassSetUnion","ast::ClassAscii","ast::FlagsItem","ast::print::Writer","hir::translate::Translator","ast::ClassAsciiKind","hir::Class","ast::ClassSetBinaryOpKind","ast::Error","hir::literal::Literals","ast::parse::Primitive","hir::ErrorKind","unicode::CanonicalClassQuery","unicode::CaseFoldError","ast::ClassUnicode","unicode::UnicodeWordError","ast::parse::ParserI","ast::ClassSetItem","ast::SetFlags","ast::visitor::ClassFrame","ast::ErrorKind","ast::Ast","hir::ClassUnicodeIter","hir::WordBoundary","hir::Repetition","ast::FlagsItemKind","ast::ClassSetRange","ast::Comment","hir::Hir","ast::LiteralKind","utf8::Utf8Range","hir::ClassBytesRange","ast::Repetition","ast::print::Printer","hir::interval::IntervalSetIter","hir::Literal","hir::Group","ast::RepetitionKind","ast::CaptureName","<*const T as std::fmt::Debug>","ast::Literal","hir::GroupKind","hir::interval::IntervalSet","ast::GroupKind","utf8::Utf8Sequence","utf8::ScalarRange","ast::Position","hir::ClassUnicodeRange","unicode::Error","ast::parse::NestLimiter"]},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::rc::Rc<T>","std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::ffi::OsString","std::string::String","std::sync::Arc<T>","std::boxed::Box<T, A>"]},"ast::parse::ParserI":{"P":["std::string::String","std::ffi::OsString","std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::CString","std::clone::impls::<impl std::clone::Clone for &T>","std::boxed::Box<T, A>","std::path::PathBuf","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["hir::RepetitionKind","ast::CaptureName","ast::ClassSetBinaryOp","ast::Repetition","ast::ClassUnicode","hir::WordBoundary","either::Either","error::Error","ast::ClassPerlKind","ast::ClassUnicodeOpKind","hir::Class","ast::SetFlags","hir::Anchor","hir::ClassBytesRange","ast::FlagsItem","ast::Assertion","ast::Literal","hir::ClassBytes","ast::RepetitionOp","ast::ClassSet","ast::SpecialLiteralKind","hir::GroupKind","ast::Error","ast::ClassAscii","hir::Hir","ast::Class","ast::Ast","hir::Group","hir::RepetitionRange","hir::interval::IntervalSet","ast::Flags","hir::literal::Literal","ast::WithComments","ast::Span","ast::ClassSetRange","ast::ClassSetItem","ast::ClassSetUnion","ast::HexLiteralKind","ast::ClassSetBinaryOpKind","ast::ErrorKind","utf8::Utf8Sequence","hir::HirKind","hir::ErrorKind","ast::LiteralKind","hir::Error","ast::RepetitionRange","hir::literal::Literals","ast::Group","ast::RepetitionKind","ast::Comment","hir::Repetition","ast::FlagsItemKind","ast::GroupKind","ast::Concat","ast::ClassPerl","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::Alternation","ast::Position","hir::ClassUnicodeRange","ast::ClassBracketed","utf8::Utf8Range","ast::parse::Primitive","hir::ClassUnicode","ast::ClassUnicodeKind","hir::Literal","ast::ClassAsciiKind","ast::AssertionKind","ast::Flag","hir::HirInfo"],"Right":["hir::HirKind","ast::ClassSetBinaryOpKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::ClassPerl","hir::HirInfo","ast::Literal","hir::interval::IntervalSet","hir::RepetitionRange","ast::ClassAscii","ast::RepetitionRange","ast::ClassSet","ast::Alternation","hir::ClassUnicodeRange","ast::ErrorKind","ast::GroupKind","ast::ClassPerlKind","hir::Group","ast::ClassUnicodeOpKind","hir::literal::Literals","ast::AssertionKind","hir::Class","ast::ClassSetRange","ast::LiteralKind","ast::Concat","ast::SpecialLiteralKind","ast::ClassSetUnion","ast::Comment","ast::Error","hir::WordBoundary","ast::RepetitionOp","hir::Literal","ast::CaptureName","either::Either","ast::Ast","hir::RepetitionKind","ast::ClassUnicodeKind","ast::ClassBracketed","hir::GroupKind","ast::Repetition","ast::FlagsItem","ast::parse::Primitive","ast::FlagsItemKind","hir::ClassBytes","ast::RepetitionKind","ast::ClassSetBinaryOp","ast::Span","utf8::Utf8Range","ast::HexLiteralKind","ast::ClassUnicode","ast::WithComments","error::Error","ast::ClassAsciiKind","ast::SetFlags","hir::ClassBytesRange","hir::Repetition","utf8::Utf8Sequence","hir::ClassUnicode","hir::ErrorKind","ast::ClassSetItem","hir::literal::Literal","hir::Anchor","ast::Flag","ast::Flags","ast::Group","hir::Hir","ast::Assertion","ast::Class","ast::Position","hir::Error"]},"error::Formatter":{"E":["error::Error","hir::Error","unicode::UnicodeWordError","unicode::CaseFoldError","error::Formatter","<&mut T as std::fmt::Debug>","ast::ErrorKind","ast::Ast","hir::ErrorKind","ast::Error","hir::Hir"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::print::Writer","hir::ClassBytes","hir::interval::IntervalSet","ast::HexLiteralKind","ast::ClassBracketed","either::Either","ast::WithComments","ast::ClassPerl","ast::GroupKind","ast::ClassAsciiKind","ast::Group","utf8::Utf8Sequence","hir::print::Writer","unicode::UnicodeWordError","hir::literal::Literals","ast::Class","ast::Span","ast::parse::GroupState","hir::ClassBytesRange","ast::Position","ast::Repetition","hir::literal::Literal","hir::Literal","ast::RepetitionOp","ast::AssertionKind","ast::CaptureName","ast::Assertion","ast::ClassPerlKind","ast::ClassSetBinaryOp","utf8::Utf8Sequences","ast::print::PrinterBuilder","hir::ClassBytesIter","ast::ClassSet","ast::parse::ParserI","ast::Alternation","hir::Error","ast::visitor::ClassFrame","hir::HirKind","hir::Anchor","hir::HirInfo","hir::translate::HirFrame","hir::RepetitionRange","ast::RepetitionRange","ast::ClassUnicodeOpKind","ast::ClassSetItem","hir::print::PrinterBuilder","ast::ClassUnicode","ast::LiteralKind","ast::SetFlags","unicode::Error","hir::Hir","ast::Error","ast::ErrorKind","ast::Flag","hir::RepetitionKind","ast::Concat","ast::ClassAscii","error::Formatter","ast::FlagsItem","hir::ClassUnicode","ast::parse::Parser","error::Error","hir::Class","ast::visitor::ClassInduct","ast::parse::ParserBuilder","ast::Flags","hir::Repetition","hir::WordBoundary","parser::Parser","hir::ErrorKind","ast::parse::NestLimiter","unicode::CaseFoldError","ast::ClassSetRange","ast::RepetitionKind","ast::Comment","hir::translate::TranslatorBuilder","hir::GroupKind","ast::ClassSetBinaryOpKind","ast::parse::ClassState","unicode::ClassQuery","unicode::CanonicalClassQuery","ast::FlagsItemKind","parser::ParserBuilder","hir::ClassUnicodeRange","hir::translate::Translator","hir::print::Printer","hir::ClassUnicodeIter","ast::SpecialLiteralKind","utf8::Utf8Range","ast::Literal","hir::translate::TranslatorI","hir::Group","ast::ClassSetUnion","ast::Ast","utf8::ScalarRange","hir::interval::IntervalSetIter","<*mut T as std::fmt::Debug>","ast::ClassUnicodeKind","hir::translate::Flags","ast::print::Printer","ast::parse::Primitive"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as std::fmt::Debug>::fmt(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::new
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::new":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::new":{"P":["std::borrow::Cow<'a, B>","<T as std::borrow::Borrow<T>>","std::ffi::CString","std::sync::Arc<T>","std::boxed::Box<T, A>","std::string::String","std::rc::Rc<T>","std::path::PathBuf","std::vec::Vec<T, A>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::parse::ParserI<'s, P>
+ast::parse::NestLimiter::<'p, 's, P>::new(p0);
+crate::ast::parse::NestLimiter::<'p, 's, P>::new(p0);
+<ast::parse::NestLimiter<'p, 's, P>>::new(p0);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::check
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::check":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::check":{"P":["<T as std::borrow::Borrow<T>>","std::ffi::OsString","std::boxed::Box<T, A>","std::ffi::CString","std::rc::Rc<T>","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::path::PathBuf","std::string::String"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.check(p1);
+ast::parse::NestLimiter::<'p, 's, P>::check(p0, p1);
+crate::ast::parse::NestLimiter::<'p, 's, P>::check(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::check(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::increment_depth
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::increment_depth":{"P":["std::string::String","std::rc::Rc<T>","std::path::PathBuf","std::ffi::CString","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.increment_depth(p1);
+ast::parse::NestLimiter::<'p, 's, P>::increment_depth(p0, p1);
+crate::ast::parse::NestLimiter::<'p, 's, P>::increment_depth(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::increment_depth(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs ast::parse::NestLimiter::<'p, 's, P>::decrement_depth
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter::<'p, 's, P>::decrement_depth":{"P":["std::sync::Arc<T>","std::boxed::Box<T, A>","std::path::PathBuf","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","std::string::String","std::ffi::CString","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
+p0.decrement_depth();
+ast::parse::NestLimiter::<'p, 's, P>::decrement_depth(p0);
+crate::ast::parse::NestLimiter::<'p, 's, P>::decrement_depth(p0);
+<ast::parse::NestLimiter<'p, 's, P>>::decrement_depth(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish":{"P":["std::rc::Rc<T>","<T as std::borrow::Borrow<T>>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::path::PathBuf","std::ffi::CString","std::ffi::OsString","std::sync::Arc<T>","std::vec::Vec<T, A>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
+p0.finish();
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish(p0);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::finish(p0);
+<ast::parse::NestLimiter<'p, 's, P>>::finish(p0);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre":{"P":["std::rc::Rc<T>","std::ffi::CString","<&T as std::borrow::Borrow<T>>","std::string::String","std::path::PathBuf","std::ffi::OsString","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","std::sync::Arc<T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_pre(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_pre(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post":{"P":["std::path::PathBuf","std::vec::Vec<T, A>","std::sync::Arc<T>","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::CString","std::rc::Rc<T>","std::string::String","std::ffi::OsString","std::boxed::Box<T, A>","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_post(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_post(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre":{"P":["std::sync::Arc<T>","std::path::PathBuf","std::string::String","std::boxed::Box<T, A>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::CString","<&mut T as std::borrow::Borrow<T>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_item_pre(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":{"P":["std::marker::Sized","std::borrow::Borrow"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post":{"P":["std::borrow::Cow<'a, B>","std::string::String","std::sync::Arc<T>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::CString","std::ffi::OsString","<T as std::borrow::Borrow<T>>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_item_post(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre":{"P":["std::sync::Arc<T>","std::string::String","std::ffi::CString","<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::vec::Vec<T, A>","std::borrow::Cow<'a, B>","<&T as std::borrow::Borrow<T>>","std::ffi::OsString","std::path::PathBuf","std::boxed::Box<T, A>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_pre(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_binary_op_pre(p0, p1);
-----------------
regex-syntax/src/ast/parse.rs <ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post
'p,'s
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":{"P":["std::borrow::Borrow","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post":{"P":["<T as std::borrow::Borrow<T>>","std::rc::Rc<T>","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::vec::Vec<T, A>","std::path::PathBuf","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::parse::NestLimiter<'p, 's, P>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_post(p1);
+<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+crate::<ast::parse::NestLimiter<'p, 's, P> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+<ast::parse::NestLimiter<'p, 's, P>>::visit_class_set_binary_op_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::PrinterBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::PrinterBuilder
+p0.clone();
+<ast::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+crate::<ast::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+<ast::print::PrinterBuilder>::clone(p0);
-----------------
regex-syntax/src/ast/print.rs <ast::print::PrinterBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::PrinterBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+<ast::print::PrinterBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::PrinterBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<ast::print::PrinterBuilder as std::default::Default>::default();
+crate::<ast::print::PrinterBuilder as std::default::Default>::default();
+<ast::print::PrinterBuilder>::default();
-----------------
regex-syntax/src/ast/print.rs ast::print::PrinterBuilder::new
deps:{}
candidates:{}
+ast::print::PrinterBuilder::new();
+crate::ast::print::PrinterBuilder::new();
+<ast::print::PrinterBuilder>::new();
-----------------
regex-syntax/src/ast/print.rs ast::print::PrinterBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::PrinterBuilder
+p0.build();
+ast::print::PrinterBuilder::build(p0);
+crate::ast::print::PrinterBuilder::build(p0);
+<ast::print::PrinterBuilder>::build(p0);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Printer as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::Printer
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+<ast::print::Printer>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Printer::new
deps:{}
candidates:{}
+ast::print::Printer::new();
+crate::ast::print::Printer::new();
+<ast::print::Printer>::new();
-----------------
regex-syntax/src/ast/print.rs ast::print::Printer::print
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Printer::print":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Printer::print":{"W":["std::error::Indented<'_, T>","std::string::String","std::ffi::OsString","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Printer
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p2 = MaybeUninit::uninit().assume_init(); // W
+p0.print(p1, p2);
+ast::print::Printer::print(p0, p1, p2);
+crate::ast::print::Printer::print(p0, p1, p2);
+<ast::print::Printer>::print(p0, p1, p2);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as std::fmt::Debug>::fmt
'p
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::print::Writer<'p, W> as std::fmt::Debug>::fmt":{"W":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"either::Either":{"Left":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"],"Right":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"error::Formatter":{"E":["std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::clone::Clone","hir::interval::Interval","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<ast::print::Writer<'p, W> as std::fmt::Debug>::fmt":{"W":["ast::ClassAscii","ast::Assertion","ast::Literal","hir::ClassBytes","ast::CaptureName","hir::Anchor","hir::Class","hir::ClassBytesRange","ast::RepetitionKind","ast::ClassSetRange","ast::ClassSetUnion","hir::ClassUnicodeIter","ast::HexLiteralKind","ast::parse::Primitive","utf8::ScalarRange","ast::visitor::ClassFrame","ast::ClassPerlKind","ast::WithComments","hir::translate::HirFrame","hir::RepetitionKind","utf8::Utf8Sequences","parser::Parser","utf8::Utf8Range","hir::HirKind","error::Error","ast::Concat","unicode::ClassQuery","hir::Repetition","ast::FlagsItemKind","ast::AssertionKind","ast::RepetitionOp","ast::visitor::ClassInduct","hir::translate::Flags","ast::print::Writer","ast::ClassUnicodeOpKind","ast::Class","unicode::UnicodeWordError","hir::WordBoundary","ast::SpecialLiteralKind","parser::ParserBuilder","hir::GroupKind","hir::literal::Literal","ast::print::Printer","hir::translate::Translator","ast::ErrorKind","ast::Error","ast::ClassBracketed","ast::parse::GroupState","either::Either","<&T as std::fmt::Debug>","hir::translate::TranslatorBuilder","ast::ClassSetBinaryOp","error::Formatter","ast::parse::ClassState","ast::Repetition","ast::print::PrinterBuilder","ast::Flags","ast::SetFlags","ast::LiteralKind","hir::interval::IntervalSetIter","hir::translate::TranslatorI","ast::Ast","ast::ClassPerl","ast::parse::ParserI","hir::ErrorKind","hir::print::PrinterBuilder","ast::Span","hir::Literal","unicode::CaseFoldError","ast::Comment","ast::Group","ast::ClassUnicodeKind","ast::ClassSetItem","ast::Flag","hir::literal::Literals","utf8::Utf8Sequence","ast::Position","ast::FlagsItem","hir::print::Writer","ast::ClassSet","unicode::Error","hir::interval::IntervalSet","hir::ClassUnicode","ast::parse::NestLimiter","ast::ClassSetBinaryOpKind","hir::HirInfo","hir::ClassUnicodeRange","ast::parse::ParserBuilder","ast::Alternation","hir::Group","ast::ClassAsciiKind","ast::ClassUnicode","hir::Hir","<*mut T as std::fmt::Debug>","hir::print::Printer","ast::RepetitionRange","ast::GroupKind","hir::RepetitionRange","hir::ClassBytesIter","hir::Error","unicode::CanonicalClassQuery","ast::parse::Parser"]},"ast::parse::NestLimiter":{"P":["std::ffi::OsString","std::rc::Rc<T>","std::path::PathBuf","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::ffi::CString","std::sync::Arc<T>","<&mut T as std::fmt::Debug>","std::string::String"]},"ast::parse::ParserI":{"P":["std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf","std::vec::Vec<T, A>","std::string::String","std::boxed::Box<T, A>","std::ffi::OsString","<&mut T as std::fmt::Debug>","std::ffi::CString"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::ClassSet","hir::literal::Literals","hir::Hir","hir::interval::IntervalSet","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","hir::RepetitionRange","ast::ClassPerlKind","ast::ClassSetRange","ast::Literal","ast::ClassSetBinaryOpKind","ast::ClassSetBinaryOp","ast::ClassUnicodeKind","hir::ClassUnicode","ast::Group","ast::Position","hir::HirInfo","hir::literal::Literal","ast::SpecialLiteralKind","hir::Anchor","ast::Flags","hir::Literal","hir::ClassBytes","hir::Class","ast::CaptureName","hir::Repetition","ast::ClassPerl","hir::ErrorKind","either::Either","ast::parse::Primitive","ast::RepetitionRange","ast::Class","hir::ClassUnicodeRange","hir::GroupKind","ast::Ast","hir::RepetitionKind","hir::ClassBytesRange","ast::HexLiteralKind","ast::ClassUnicodeOpKind","ast::SetFlags","ast::Span","ast::ClassSetItem","ast::Repetition","ast::Comment","ast::RepetitionKind","utf8::Utf8Range","ast::Alternation","ast::GroupKind","ast::ClassAscii","ast::ErrorKind","ast::Error","ast::RepetitionOp","ast::ClassUnicode","ast::AssertionKind","ast::Flag","error::Error","hir::HirKind","ast::LiteralKind","hir::WordBoundary","ast::Assertion","ast::ClassSetUnion","ast::WithComments","hir::Group","ast::Concat","ast::FlagsItem","hir::Error","ast::ClassAsciiKind","utf8::Utf8Sequence","ast::FlagsItemKind","ast::ClassBracketed"],"Right":["either::Either","ast::ClassAscii","hir::RepetitionKind","ast::Flag","hir::ClassUnicodeRange","ast::RepetitionKind","ast::ClassSetRange","hir::Class","ast::Group","ast::CaptureName","ast::Position","ast::Alternation","ast::ClassSetItem","ast::Span","hir::interval::IntervalSet","ast::ClassBracketed","utf8::Utf8Sequence","ast::ClassAsciiKind","ast::Concat","error::Error","ast::Class","ast::ClassSetBinaryOp","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::RepetitionRange","ast::ClassUnicodeKind","hir::Hir","hir::Error","ast::ClassUnicode","hir::HirInfo","hir::ClassBytesRange","ast::Comment","ast::LiteralKind","hir::literal::Literal","ast::Assertion","ast::Flags","ast::FlagsItemKind","ast::ErrorKind","hir::WordBoundary","ast::SpecialLiteralKind","ast::Ast","utf8::Utf8Range","hir::RepetitionRange","ast::AssertionKind","ast::SetFlags","hir::Anchor","ast::RepetitionOp","ast::ClassSet","ast::ClassPerl","hir::HirKind","ast::Repetition","ast::ClassSetUnion","hir::Repetition","ast::GroupKind","ast::parse::Primitive","ast::HexLiteralKind","ast::FlagsItem","ast::WithComments","ast::ClassSetBinaryOpKind","hir::ClassUnicode","hir::ClassBytes","hir::ErrorKind","hir::Group","hir::GroupKind","ast::ClassUnicodeOpKind","hir::Literal","ast::Literal","ast::Error","ast::ClassPerlKind","hir::literal::Literals"]},"error::Formatter":{"E":["<&T as std::fmt::Debug>","ast::Ast","hir::ErrorKind","error::Formatter","ast::Error","hir::Error","error::Error","ast::ErrorKind","unicode::UnicodeWordError","unicode::CaseFoldError","hir::Hir"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::ClassSetUnion","parser::Parser","ast::SpecialLiteralKind","ast::ClassUnicode","hir::HirInfo","<&T as std::fmt::Debug>","unicode::CaseFoldError","ast::print::Printer","utf8::Utf8Sequences","ast::Concat","hir::translate::HirFrame","hir::ClassBytes","hir::interval::IntervalSetIter","ast::ClassSetRange","unicode::UnicodeWordError","ast::Literal","hir::ClassBytesIter","ast::parse::ParserI","ast::Span","hir::Literal","hir::GroupKind","error::Error","ast::FlagsItemKind","hir::RepetitionRange","hir::ErrorKind","ast::ClassSetBinaryOpKind","ast::Position","hir::HirKind","unicode::CanonicalClassQuery","hir::translate::TranslatorI","hir::Group","hir::Class","utf8::Utf8Range","ast::parse::Parser","hir::Error","ast::Group","ast::CaptureName","hir::translate::Flags","hir::WordBoundary","ast::FlagsItem","ast::ClassSetBinaryOp","ast::Error","hir::ClassUnicodeIter","hir::RepetitionKind","hir::translate::Translator","utf8::Utf8Sequence","ast::ClassAsciiKind","ast::SetFlags","ast::LiteralKind","ast::ClassSetItem","hir::Anchor","ast::ClassUnicodeKind","ast::Ast","hir::Hir","ast::RepetitionOp","ast::visitor::ClassFrame","ast::AssertionKind","ast::parse::GroupState","ast::Flags","ast::Repetition","ast::Alternation","hir::ClassUnicode","hir::ClassBytesRange","ast::Flag","unicode::Error","hir::print::Printer","ast::print::Writer","ast::RepetitionKind","ast::ErrorKind","ast::parse::ParserBuilder","ast::parse::Primitive","ast::Comment","either::Either","ast::RepetitionRange","ast::visitor::ClassInduct","ast::Class","ast::ClassPerl","ast::HexLiteralKind","unicode::ClassQuery","ast::Assertion","hir::print::PrinterBuilder","hir::print::Writer","ast::WithComments","hir::translate::TranslatorBuilder","ast::ClassPerlKind","hir::Repetition","ast::ClassBracketed","ast::ClassSet","hir::ClassUnicodeRange","ast::ClassAscii","ast::GroupKind","hir::literal::Literals","hir::literal::Literal","ast::ClassUnicodeOpKind","ast::parse::ClassState","error::Formatter","hir::interval::IntervalSet","parser::ParserBuilder","utf8::ScalarRange","ast::parse::NestLimiter","ast::print::PrinterBuilder"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::print::Writer<'p, W> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::print::Writer<'p, W> as std::fmt::Debug>::fmt(p0, p1);
+<ast::print::Writer<'p, W>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::string::String","std::fmt::Formatter<'_>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
+p0.finish();
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish(p0);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::finish(p0);
+<ast::print::Writer<'p, W>>::finish(p0);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre":{"W":["std::error::Indented<'_, T>","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_pre(p0, p1);
+<ast::print::Writer<'p, W>>::visit_pre(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post":{"W":["std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>","std::string::String","std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post(p0, p1);
+<ast::print::Writer<'p, W>>::visit_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::fmt::Formatter<'_>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
+p0.visit_alternation_in();
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in(p0);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_alternation_in(p0);
+<ast::print::Writer<'p, W>>::visit_alternation_in(p0);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre":{"W":["<&mut W as std::fmt::Write>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+<ast::print::Writer<'p, W>>::visit_class_set_item_pre(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post":{"W":["core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>","std::string::String","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+<ast::print::Writer<'p, W>>::visit_class_set_item_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs <ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in
'p
deps:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::string::String","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_in(p1);
+<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+crate::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+<ast::print::Writer<'p, W>>::visit_class_set_binary_op_in(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_group_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_group_pre":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_group_pre":{"W":["core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::error::Indented<'_, T>","std::string::String","std::fmt::Formatter<'_>","std::ffi::OsString","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.fmt_group_pre(p1);
+ast::print::Writer::<'p, W>::fmt_group_pre(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_group_pre(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_group_pre(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_group_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_group_post":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_group_post":{"W":["std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.fmt_group_post(p1);
+ast::print::Writer::<'p, W>::fmt_group_post(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_group_post(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_group_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_repetition
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_repetition":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_repetition":{"W":["core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::error::Indented<'_, T>","std::string::String","std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.fmt_repetition(p1);
+ast::print::Writer::<'p, W>::fmt_repetition(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_repetition(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_repetition(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_repetition_range
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_repetition_range":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_repetition_range":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>","std::string::String","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","std::fmt::Formatter<'_>","core::fmt::builders::PadAdapter<'_, '_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.fmt_repetition_range(p1);
+ast::print::Writer::<'p, W>::fmt_repetition_range(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_repetition_range(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_repetition_range(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_literal
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_literal":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_literal":{"W":["<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","std::fmt::Formatter<'_>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.fmt_literal(p1);
+ast::print::Writer::<'p, W>::fmt_literal(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_literal(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_literal(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_assertion
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_assertion":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_assertion":{"W":["core::fmt::builders::PadAdapter<'_, '_>","std::string::String","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::fmt::Formatter<'_>","<&mut W as std::fmt::Write>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.fmt_assertion(p1);
+ast::print::Writer::<'p, W>::fmt_assertion(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_assertion(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_assertion(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_set_flags
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_set_flags":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_set_flags":{"W":["<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","std::fmt::Formatter<'_>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::error::Indented<'_, T>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.fmt_set_flags(p1);
+ast::print::Writer::<'p, W>::fmt_set_flags(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_set_flags(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_set_flags(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_flags
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_flags":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_flags":{"W":["std::ffi::OsString","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.fmt_flags(p1);
+ast::print::Writer::<'p, W>::fmt_flags(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_flags(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_flags(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_bracketed_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_bracketed_pre":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_bracketed_pre":{"W":["std::fmt::Formatter<'_>","std::error::Indented<'_, T>","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.fmt_class_bracketed_pre(p1);
+ast::print::Writer::<'p, W>::fmt_class_bracketed_pre(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_bracketed_pre(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_bracketed_pre(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_bracketed_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_bracketed_post":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_bracketed_post":{"W":["std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::string::String","std::ffi::OsString","std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.fmt_class_bracketed_post(p1);
+ast::print::Writer::<'p, W>::fmt_class_bracketed_post(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_bracketed_post(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_bracketed_post(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind":{"W":["std::error::Indented<'_, T>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","<&mut W as std::fmt::Write>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.fmt_class_set_binary_op_kind(p1);
+ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_set_binary_op_kind(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_set_binary_op_kind(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_perl
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_perl":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_perl":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>","<&mut W as std::fmt::Write>","std::ffi::OsString","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.fmt_class_perl(p1);
+ast::print::Writer::<'p, W>::fmt_class_perl(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_perl(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_perl(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_ascii
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_ascii":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_ascii":{"W":["std::ffi::OsString","std::net::display_buffer::DisplayBuffer<SIZE>","std::io::Write::write_fmt::Adapter<'_, T>","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>","std::string::String","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.fmt_class_ascii(p1);
+ast::print::Writer::<'p, W>::fmt_class_ascii(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_ascii(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_ascii(p0, p1);
-----------------
regex-syntax/src/ast/print.rs ast::print::Writer::<'p, W>::fmt_class_unicode
'p
deps:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_unicode":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"ast::print::Writer::<'p, W>::fmt_class_unicode":{"W":["std::string::String","std::error::Indented<'_, T>","<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.fmt_class_unicode(p1);
+ast::print::Writer::<'p, W>::fmt_class_unicode(p0, p1);
+crate::ast::print::Writer::<'p, W>::fmt_class_unicode(p0, p1);
+<ast::print::Writer<'p, W>>::fmt_class_unicode(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::new
'a
deps:{}
candidates:{}
+ast::visitor::HeapVisitor::<'a>::new();
+crate::ast::visitor::HeapVisitor::<'a>::new();
+<ast::visitor::HeapVisitor<'a>>::new();
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"ast::visitor::HeapVisitor::<'a>::visit":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::ffi::OsString","std::sync::Arc<T>","std::vec::Vec<T, A>","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::string::String","std::boxed::Box<T, A>","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::HeapVisitor::<'a>::visit":{"V":["hir::translate::TranslatorI","ast::parse::NestLimiter","ast::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.visit(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::induct
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"ast::visitor::HeapVisitor::<'a>::induct":{"V":["ast::visitor::Visitor","std::marker::Sized"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::vec::Vec<T, A>","std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf","std::ffi::OsString","std::string::String","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::boxed::Box<T, A>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"ast::visitor::HeapVisitor::<'a>::induct":{"V":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.induct(p1, p2);
+ast::visitor::HeapVisitor::<'a>::induct(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::induct(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::induct(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::pop
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::visitor::Frame<'a>
+p0.pop(p1);
+ast::visitor::HeapVisitor::<'a>::pop(p0, p1);
+crate::ast::visitor::HeapVisitor::<'a>::pop(p0, p1);
+<ast::visitor::HeapVisitor<'a>>::pop(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit_class
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::fmt::Write","std::marker::Sized","std::fmt::Debug"]},"ast::visitor::HeapVisitor::<'a>::visit_class":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"ast::parse::NestLimiter":{"P":["std::path::PathBuf","std::ffi::CString","std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::OsString","std::vec::Vec<T, A>","std::string::String","<&mut T as std::fmt::Debug>","std::sync::Arc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::HeapVisitor::<'a>::visit_class":{"V":["ast::parse::NestLimiter","ast::print::Writer","hir::translate::TranslatorI"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.visit_class(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit_class(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit_class(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit_class(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit_class_pre
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::HeapVisitor::<'a>::visit_class_pre":{"V":["std::marker::Sized","ast::visitor::Visitor"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::ffi::CString","std::sync::Arc<T>","std::rc::Rc<T>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::HeapVisitor::<'a>::visit_class_pre":{"V":["ast::print::Writer","hir::translate::TranslatorI","ast::parse::NestLimiter"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.visit_class_pre(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit_class_pre(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit_class_pre(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit_class_pre(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::visit_class_post
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"ast::visitor::HeapVisitor::<'a>::visit_class_post":{"V":["ast::visitor::Visitor","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"ast::parse::NestLimiter":{"P":["std::ffi::CString","std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::OsString","std::string::String","std::rc::Rc<T>","<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"ast::visitor::HeapVisitor::<'a>::visit_class_post":{"V":["ast::print::Writer","ast::parse::NestLimiter","hir::translate::TranslatorI"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // V
+p0.visit_class_post(p1, p2);
+ast::visitor::HeapVisitor::<'a>::visit_class_post(p0, p1, p2);
+crate::ast::visitor::HeapVisitor::<'a>::visit_class_post(p0, p1, p2);
+<ast::visitor::HeapVisitor<'a>>::visit_class_post(p0, p1, p2);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::induct_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
+p0.induct_class(p1);
+ast::visitor::HeapVisitor::<'a>::induct_class(p0, p1);
+crate::ast::visitor::HeapVisitor::<'a>::induct_class(p0, p1);
+<ast::visitor::HeapVisitor<'a>>::induct_class(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::HeapVisitor::<'a>::pop_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::HeapVisitor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::visitor::ClassFrame<'a>
+p0.pop_class(p1);
+ast::visitor::HeapVisitor::<'a>::pop_class(p0, p1);
+crate::ast::visitor::HeapVisitor::<'a>::pop_class(p0, p1);
+<ast::visitor::HeapVisitor<'a>>::pop_class(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::Frame::<'a>::child
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::Frame<'a>
+p0.child();
+ast::visitor::Frame::<'a>::child(p0);
+crate::ast::visitor::Frame::<'a>::child(p0);
+<ast::visitor::Frame<'a>>::child(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::ClassFrame::<'a>::child
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassFrame<'a>
+p0.child();
+ast::visitor::ClassFrame::<'a>::child(p0);
+crate::ast::visitor::ClassFrame::<'a>::child(p0);
+<ast::visitor::ClassFrame<'a>>::child(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::ClassInduct::<'a>::from_bracketed
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+ast::visitor::ClassInduct::<'a>::from_bracketed(p0);
+crate::ast::visitor::ClassInduct::<'a>::from_bracketed(p0);
+<ast::visitor::ClassInduct<'a>>::from_bracketed(p0);
-----------------
regex-syntax/src/ast/visitor.rs ast::visitor::ClassInduct::<'a>::from_set
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+ast::visitor::ClassInduct::<'a>::from_set(p0);
+crate::ast::visitor::ClassInduct::<'a>::from_set(p0);
+<ast::visitor::ClassInduct<'a>>::from_set(p0);
-----------------
regex-syntax/src/ast/visitor.rs <ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassFrame<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::visitor::ClassFrame<'a> as std::fmt::Debug>::fmt(p0, p1);
+<ast::visitor::ClassFrame<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/visitor.rs <ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::visitor::ClassInduct<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt(p0, p1);
+<ast::visitor::ClassInduct<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.clone();
+<ast::Error as std::clone::Clone>::clone(p0);
+crate::<ast::Error as std::clone::Clone>::clone(p0);
+<ast::Error>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Error as std::fmt::Debug>::fmt(p0, p1);
+<ast::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.assert_receiver_is_total_eq();
+<ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Error>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.eq(p1);
+<ast::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Error as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Error>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Error::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.kind();
+ast::Error::kind(p0);
+crate::ast::Error::kind(p0);
+<ast::Error>::kind(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Error::pattern
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.pattern();
+ast::Error::pattern(p0);
+crate::ast::Error::pattern(p0);
+<ast::Error>::pattern(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Error::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.span();
+ast::Error::span(p0);
+crate::ast::Error::span(p0);
+<ast::Error>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Error::auxiliary_span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.auxiliary_span();
+ast::Error::auxiliary_span(p0);
+crate::ast::Error::auxiliary_span(p0);
+<ast::Error>::auxiliary_span(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.clone();
+<ast::ErrorKind as std::clone::Clone>::clone(p0);
+crate::<ast::ErrorKind as std::clone::Clone>::clone(p0);
+<ast::ErrorKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ErrorKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.assert_receiver_is_total_eq();
+<ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
+p0.eq(p1);
+<ast::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ErrorKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+p0.description();
+<ast::Error as std::error::Error>::description(p0);
+crate::<ast::Error as std::error::Error>::description(p0);
+<ast::Error>::description(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ast::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<ast::Error as std::fmt::Display>::fmt(p0, p1);
+<ast::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ErrorKind as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ast::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+crate::<ast::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+<ast::ErrorKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.clone();
+<ast::Span as std::clone::Clone>::clone(p0);
+crate::<ast::Span as std::clone::Clone>::clone(p0);
+<ast::Span>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.assert_receiver_is_total_eq();
+<ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Span as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Span>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.eq(p1);
+<ast::Span as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Span as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Span>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Span as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Span as std::fmt::Debug>::fmt(p0, p1);
+<ast::Span>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.cmp(p1);
+<ast::Span as std::cmp::Ord>::cmp(p0, p1);
+crate::<ast::Span as std::cmp::Ord>::cmp(p0, p1);
+<ast::Span>::cmp(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Span as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.partial_cmp(p1);
+<ast::Span as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<ast::Span as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<ast::Span>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.clone();
+<ast::Position as std::clone::Clone>::clone(p0);
+crate::<ast::Position as std::clone::Clone>::clone(p0);
+<ast::Position>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.assert_receiver_is_total_eq();
+<ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Position as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Position>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.eq(p1);
+<ast::Position as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Position as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Position>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Position as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Position as std::fmt::Debug>::fmt(p0, p1);
+<ast::Position>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.cmp(p1);
+<ast::Position as std::cmp::Ord>::cmp(p0, p1);
+crate::<ast::Position as std::cmp::Ord>::cmp(p0, p1);
+<ast::Position>::cmp(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Position as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Position
+p0.partial_cmp(p1);
+<ast::Position as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<ast::Position as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<ast::Position>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Position
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Position
+ast::Span::new(p0, p1);
+crate::ast::Span::new(p0, p1);
+<ast::Span>::new(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::splat
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Position
+ast::Span::splat(p0);
+crate::ast::Span::splat(p0);
+<ast::Span>::splat(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::with_start
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Position
+p0.with_start(p1);
+ast::Span::with_start(p0, p1);
+crate::ast::Span::with_start(p0, p1);
+<ast::Span>::with_start(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::with_end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Position
+p0.with_end(p1);
+ast::Span::with_end(p0, p1);
+crate::ast::Span::with_end(p0, p1);
+<ast::Span>::with_end(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::is_one_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.is_one_line();
+ast::Span::is_one_line(p0);
+crate::ast::Span::is_one_line(p0);
+<ast::Span>::is_one_line(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Span::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Span
+p0.is_empty();
+ast::Span::is_empty(p0);
+crate::ast::Span::is_empty(p0);
+<ast::Span>::is_empty(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Position::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+ast::Position::new(p0, p1, p2);
+crate::ast::Position::new(p0, p1, p2);
+<ast::Position>::new(p0, p1, p2);
-----------------
regex-syntax/src/ast/mod.rs <ast::WithComments as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
+p0.clone();
+<ast::WithComments as std::clone::Clone>::clone(p0);
+crate::<ast::WithComments as std::clone::Clone>::clone(p0);
+<ast::WithComments>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::WithComments as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::WithComments as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::WithComments as std::fmt::Debug>::fmt(p0, p1);
+<ast::WithComments>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
+p0.assert_receiver_is_total_eq();
+<ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::WithComments as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::WithComments>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::WithComments as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::WithComments
+p0.eq(p1);
+<ast::WithComments as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::WithComments as std::cmp::PartialEq>::eq(p0, p1);
+<ast::WithComments>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Comment as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
+p0.clone();
+<ast::Comment as std::clone::Clone>::clone(p0);
+crate::<ast::Comment as std::clone::Clone>::clone(p0);
+<ast::Comment>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Comment as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Comment as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Comment as std::fmt::Debug>::fmt(p0, p1);
+<ast::Comment>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
+p0.assert_receiver_is_total_eq();
+<ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Comment as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Comment>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Comment as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Comment
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Comment
+p0.eq(p1);
+<ast::Comment as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Comment as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Comment>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.clone();
+<ast::Ast as std::clone::Clone>::clone(p0);
+crate::<ast::Ast as std::clone::Clone>::clone(p0);
+<ast::Ast>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Ast as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Ast as std::fmt::Debug>::fmt(p0, p1);
+<ast::Ast>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.assert_receiver_is_total_eq();
+<ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Ast as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Ast>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.eq(p1);
+<ast::Ast as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Ast as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Ast>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Ast::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.span();
+ast::Ast::span(p0);
+crate::ast::Ast::span(p0);
+<ast::Ast>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Ast::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.is_empty();
+ast::Ast::is_empty(p0);
+crate::ast::Ast::is_empty(p0);
+<ast::Ast>::is_empty(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Ast::has_subexprs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.has_subexprs();
+ast::Ast::has_subexprs(p0);
+crate::ast::Ast::has_subexprs(p0);
+<ast::Ast>::has_subexprs(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Ast
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<ast::Ast as std::fmt::Display>::fmt(p0, p1);
+crate::<ast::Ast as std::fmt::Display>::fmt(p0, p1);
+<ast::Ast>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Alternation as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.clone();
+<ast::Alternation as std::clone::Clone>::clone(p0);
+crate::<ast::Alternation as std::clone::Clone>::clone(p0);
+<ast::Alternation>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Alternation as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Alternation as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Alternation as std::fmt::Debug>::fmt(p0, p1);
+<ast::Alternation>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.assert_receiver_is_total_eq();
+<ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Alternation as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Alternation>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Alternation as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.eq(p1);
+<ast::Alternation as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Alternation as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Alternation>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Alternation::into_ast
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Alternation
+p0.into_ast();
+ast::Alternation::into_ast(p0);
+crate::ast::Alternation::into_ast(p0);
+<ast::Alternation>::into_ast(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Concat as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.clone();
+<ast::Concat as std::clone::Clone>::clone(p0);
+crate::<ast::Concat as std::clone::Clone>::clone(p0);
+<ast::Concat>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Concat as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Concat as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Concat as std::fmt::Debug>::fmt(p0, p1);
+<ast::Concat>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.assert_receiver_is_total_eq();
+<ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Concat as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Concat>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Concat as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Concat
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.eq(p1);
+<ast::Concat as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Concat as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Concat>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Concat::into_ast
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Concat
+p0.into_ast();
+ast::Concat::into_ast(p0);
+crate::ast::Concat::into_ast(p0);
+<ast::Concat>::into_ast(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Literal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.clone();
+<ast::Literal as std::clone::Clone>::clone(p0);
+crate::<ast::Literal as std::clone::Clone>::clone(p0);
+<ast::Literal>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Literal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Literal as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Literal as std::fmt::Debug>::fmt(p0, p1);
+<ast::Literal>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.assert_receiver_is_total_eq();
+<ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Literal>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Literal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.eq(p1);
+<ast::Literal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Literal as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Literal>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Literal::byte
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.byte();
+ast::Literal::byte(p0);
+crate::ast::Literal::byte(p0);
+<ast::Literal>::byte(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::LiteralKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
+p0.clone();
+<ast::LiteralKind as std::clone::Clone>::clone(p0);
+crate::<ast::LiteralKind as std::clone::Clone>::clone(p0);
+<ast::LiteralKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::LiteralKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::LiteralKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::LiteralKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::LiteralKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
+p0.assert_receiver_is_total_eq();
+<ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::LiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::LiteralKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::LiteralKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::LiteralKind
+p0.eq(p1);
+<ast::LiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::LiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::LiteralKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::SpecialLiteralKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
+p0.clone();
+<ast::SpecialLiteralKind as std::clone::Clone>::clone(p0);
+crate::<ast::SpecialLiteralKind as std::clone::Clone>::clone(p0);
+<ast::SpecialLiteralKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::SpecialLiteralKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::SpecialLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::SpecialLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::SpecialLiteralKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
+p0.assert_receiver_is_total_eq();
+<ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::SpecialLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::SpecialLiteralKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::SpecialLiteralKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::SpecialLiteralKind
+p0.eq(p1);
+<ast::SpecialLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::SpecialLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::SpecialLiteralKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::HexLiteralKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.clone();
+<ast::HexLiteralKind as std::clone::Clone>::clone(p0);
+crate::<ast::HexLiteralKind as std::clone::Clone>::clone(p0);
+<ast::HexLiteralKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::HexLiteralKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::HexLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::HexLiteralKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::HexLiteralKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.assert_receiver_is_total_eq();
+<ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::HexLiteralKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::HexLiteralKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::HexLiteralKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.eq(p1);
+<ast::HexLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::HexLiteralKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::HexLiteralKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::HexLiteralKind::digits
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::HexLiteralKind
+p0.digits();
+ast::HexLiteralKind::digits(p0);
+crate::ast::HexLiteralKind::digits(p0);
+<ast::HexLiteralKind>::digits(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Class as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.clone();
+<ast::Class as std::clone::Clone>::clone(p0);
+crate::<ast::Class as std::clone::Clone>::clone(p0);
+<ast::Class>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Class as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Class as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Class as std::fmt::Debug>::fmt(p0, p1);
+<ast::Class>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.assert_receiver_is_total_eq();
+<ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Class>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Class as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.eq(p1);
+<ast::Class as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Class as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Class>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Class::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Class
+p0.span();
+ast::Class::span(p0);
+crate::ast::Class::span(p0);
+<ast::Class>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerl as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.clone();
+<ast::ClassPerl as std::clone::Clone>::clone(p0);
+crate::<ast::ClassPerl as std::clone::Clone>::clone(p0);
+<ast::ClassPerl>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerl as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassPerl as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassPerl as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassPerl>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.assert_receiver_is_total_eq();
+<ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassPerl as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassPerl>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerl as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.eq(p1);
+<ast::ClassPerl as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassPerl as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassPerl>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerlKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
+p0.clone();
+<ast::ClassPerlKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassPerlKind as std::clone::Clone>::clone(p0);
+<ast::ClassPerlKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerlKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassPerlKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassPerlKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassPerlKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassPerlKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassPerlKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassPerlKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerlKind
+p0.eq(p1);
+<ast::ClassPerlKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassPerlKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassPerlKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAscii as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.clone();
+<ast::ClassAscii as std::clone::Clone>::clone(p0);
+crate::<ast::ClassAscii as std::clone::Clone>::clone(p0);
+<ast::ClassAscii>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAscii as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassAscii as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassAscii as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassAscii>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.assert_receiver_is_total_eq();
+<ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassAscii as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassAscii>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAscii as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAscii
+p0.eq(p1);
+<ast::ClassAscii as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassAscii as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassAscii>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAsciiKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+p0.clone();
+<ast::ClassAsciiKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassAsciiKind as std::clone::Clone>::clone(p0);
+<ast::ClassAsciiKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAsciiKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassAsciiKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassAsciiKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassAsciiKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassAsciiKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassAsciiKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassAsciiKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassAsciiKind
+p0.eq(p1);
+<ast::ClassAsciiKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassAsciiKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassAsciiKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassAsciiKind::from_name
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+ast::ClassAsciiKind::from_name(&p0);
+crate::ast::ClassAsciiKind::from_name(&p0);
+<ast::ClassAsciiKind>::from_name(&p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicode as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.clone();
+<ast::ClassUnicode as std::clone::Clone>::clone(p0);
+crate::<ast::ClassUnicode as std::clone::Clone>::clone(p0);
+<ast::ClassUnicode>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicode as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassUnicode>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.assert_receiver_is_total_eq();
+<ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassUnicode>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicode as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.eq(p1);
+<ast::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassUnicode>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassUnicode::is_negated
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.is_negated();
+ast::ClassUnicode::is_negated(p0);
+crate::ast::ClassUnicode::is_negated(p0);
+<ast::ClassUnicode>::is_negated(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
+p0.clone();
+<ast::ClassUnicodeKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassUnicodeKind as std::clone::Clone>::clone(p0);
+<ast::ClassUnicodeKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassUnicodeKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassUnicodeKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassUnicodeKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassUnicodeKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassUnicodeKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeKind
+p0.eq(p1);
+<ast::ClassUnicodeKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassUnicodeKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassUnicodeKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeOpKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.clone();
+<ast::ClassUnicodeOpKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassUnicodeOpKind as std::clone::Clone>::clone(p0);
+<ast::ClassUnicodeOpKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassUnicodeOpKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassUnicodeOpKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassUnicodeOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassUnicodeOpKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.eq(p1);
+<ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassUnicodeOpKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassUnicodeOpKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassUnicodeOpKind::is_equal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicodeOpKind
+p0.is_equal();
+ast::ClassUnicodeOpKind::is_equal(p0);
+crate::ast::ClassUnicodeOpKind::is_equal(p0);
+<ast::ClassUnicodeOpKind>::is_equal(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassBracketed as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.clone();
+<ast::ClassBracketed as std::clone::Clone>::clone(p0);
+crate::<ast::ClassBracketed as std::clone::Clone>::clone(p0);
+<ast::ClassBracketed>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassBracketed as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassBracketed as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassBracketed as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassBracketed>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.assert_receiver_is_total_eq();
+<ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassBracketed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassBracketed>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassBracketed as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassBracketed
+p0.eq(p1);
+<ast::ClassBracketed as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassBracketed as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassBracketed>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.clone();
+<ast::ClassSet as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSet as std::clone::Clone>::clone(p0);
+<ast::ClassSet>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSet as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSet>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.assert_receiver_is_total_eq();
+<ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSet as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSet>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.eq(p1);
+<ast::ClassSet as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSet as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSet>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSet::union
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+ast::ClassSet::union(p0);
+crate::ast::ClassSet::union(p0);
+<ast::ClassSet>::union(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSet::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.span();
+ast::ClassSet::span(p0);
+crate::ast::ClassSet::span(p0);
+<ast::ClassSet>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSet::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.is_empty();
+ast::ClassSet::is_empty(p0);
+crate::ast::ClassSet::is_empty(p0);
+<ast::ClassSet>::is_empty(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetItem as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.clone();
+<ast::ClassSetItem as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetItem as std::clone::Clone>::clone(p0);
+<ast::ClassSetItem>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetItem as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetItem as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetItem as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetItem>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetItem>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetItem as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.eq(p1);
+<ast::ClassSetItem as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetItem as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetItem>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSetItem::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.span();
+ast::ClassSetItem::span(p0);
+crate::ast::ClassSetItem::span(p0);
+<ast::ClassSetItem>::span(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.clone();
+<ast::ClassSetRange as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetRange as std::clone::Clone>::clone(p0);
+<ast::ClassSetRange>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetRange as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetRange>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.eq(p1);
+<ast::ClassSetRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetRange as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetRange>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSetRange::is_valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetRange
+p0.is_valid();
+ast::ClassSetRange::is_valid(p0);
+crate::ast::ClassSetRange::is_valid(p0);
+<ast::ClassSetRange>::is_valid(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetUnion as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.clone();
+<ast::ClassSetUnion as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetUnion as std::clone::Clone>::clone(p0);
+<ast::ClassSetUnion>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetUnion as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetUnion as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetUnion as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetUnion>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetUnion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetUnion>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetUnion as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.eq(p1);
+<ast::ClassSetUnion as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetUnion as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetUnion>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSetUnion::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.push(p1);
+ast::ClassSetUnion::push(p0, p1);
+crate::ast::ClassSetUnion::push(p0, p1);
+<ast::ClassSetUnion>::push(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::ClassSetUnion::into_item
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::ClassSetUnion
+p0.into_item();
+ast::ClassSetUnion::into_item(p0);
+crate::ast::ClassSetUnion::into_item(p0);
+<ast::ClassSetUnion>::into_item(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.clone();
+<ast::ClassSetBinaryOp as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetBinaryOp as std::clone::Clone>::clone(p0);
+<ast::ClassSetBinaryOp>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetBinaryOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetBinaryOp as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetBinaryOp>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetBinaryOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetBinaryOp>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.eq(p1);
+<ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetBinaryOp as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetBinaryOp>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.clone();
+<ast::ClassSetBinaryOpKind as std::clone::Clone>::clone(p0);
+crate::<ast::ClassSetBinaryOpKind as std::clone::Clone>::clone(p0);
+<ast::ClassSetBinaryOpKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::ClassSetBinaryOpKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::ClassSetBinaryOpKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.assert_receiver_is_total_eq();
+<ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::ClassSetBinaryOpKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::ClassSetBinaryOpKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOpKind
+p0.eq(p1);
+<ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::ClassSetBinaryOpKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::ClassSetBinaryOpKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Assertion as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.clone();
+<ast::Assertion as std::clone::Clone>::clone(p0);
+crate::<ast::Assertion as std::clone::Clone>::clone(p0);
+<ast::Assertion>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Assertion as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Assertion as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Assertion as std::fmt::Debug>::fmt(p0, p1);
+<ast::Assertion>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.assert_receiver_is_total_eq();
+<ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Assertion as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Assertion>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Assertion as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.eq(p1);
+<ast::Assertion as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Assertion as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Assertion>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::AssertionKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
+p0.clone();
+<ast::AssertionKind as std::clone::Clone>::clone(p0);
+crate::<ast::AssertionKind as std::clone::Clone>::clone(p0);
+<ast::AssertionKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::AssertionKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::AssertionKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::AssertionKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::AssertionKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
+p0.assert_receiver_is_total_eq();
+<ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::AssertionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::AssertionKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::AssertionKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::AssertionKind
+p0.eq(p1);
+<ast::AssertionKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::AssertionKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::AssertionKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Repetition as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.clone();
+<ast::Repetition as std::clone::Clone>::clone(p0);
+crate::<ast::Repetition as std::clone::Clone>::clone(p0);
+<ast::Repetition>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Repetition as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Repetition as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Repetition as std::fmt::Debug>::fmt(p0, p1);
+<ast::Repetition>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.assert_receiver_is_total_eq();
+<ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Repetition>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Repetition as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
+p0.eq(p1);
+<ast::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Repetition>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionOp as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
+p0.clone();
+<ast::RepetitionOp as std::clone::Clone>::clone(p0);
+crate::<ast::RepetitionOp as std::clone::Clone>::clone(p0);
+<ast::RepetitionOp>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionOp as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::RepetitionOp as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::RepetitionOp as std::fmt::Debug>::fmt(p0, p1);
+<ast::RepetitionOp>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
+p0.assert_receiver_is_total_eq();
+<ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::RepetitionOp as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::RepetitionOp>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionOp as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionOp
+p0.eq(p1);
+<ast::RepetitionOp as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::RepetitionOp as std::cmp::PartialEq>::eq(p0, p1);
+<ast::RepetitionOp>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.clone();
+<ast::RepetitionKind as std::clone::Clone>::clone(p0);
+crate::<ast::RepetitionKind as std::clone::Clone>::clone(p0);
+<ast::RepetitionKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::RepetitionKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.assert_receiver_is_total_eq();
+<ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::RepetitionKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionKind
+p0.eq(p1);
+<ast::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::RepetitionKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.clone();
+<ast::RepetitionRange as std::clone::Clone>::clone(p0);
+crate::<ast::RepetitionRange as std::clone::Clone>::clone(p0);
+<ast::RepetitionRange>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+<ast::RepetitionRange>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.assert_receiver_is_total_eq();
+<ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::RepetitionRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::RepetitionRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.eq(p1);
+<ast::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+<ast::RepetitionRange>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::RepetitionRange::is_valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::RepetitionRange
+p0.is_valid();
+ast::RepetitionRange::is_valid(p0);
+crate::ast::RepetitionRange::is_valid(p0);
+<ast::RepetitionRange>::is_valid(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Group as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.clone();
+<ast::Group as std::clone::Clone>::clone(p0);
+crate::<ast::Group as std::clone::Clone>::clone(p0);
+<ast::Group>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Group as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Group as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Group as std::fmt::Debug>::fmt(p0, p1);
+<ast::Group>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.assert_receiver_is_total_eq();
+<ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Group>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Group as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.eq(p1);
+<ast::Group as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Group as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Group>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Group::flags
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.flags();
+ast::Group::flags(p0);
+crate::ast::Group::flags(p0);
+<ast::Group>::flags(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Group::is_capturing
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.is_capturing();
+ast::Group::is_capturing(p0);
+crate::ast::Group::is_capturing(p0);
+<ast::Group>::is_capturing(p0);
-----------------
regex-syntax/src/ast/mod.rs ast::Group::capture_index
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Group
+p0.capture_index();
+ast::Group::capture_index(p0);
+crate::ast::Group::capture_index(p0);
+<ast::Group>::capture_index(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::GroupKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
+p0.clone();
+<ast::GroupKind as std::clone::Clone>::clone(p0);
+crate::<ast::GroupKind as std::clone::Clone>::clone(p0);
+<ast::GroupKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::GroupKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::GroupKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
+p0.assert_receiver_is_total_eq();
+<ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::GroupKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::GroupKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::GroupKind
+p0.eq(p1);
+<ast::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::GroupKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::CaptureName as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.clone();
+<ast::CaptureName as std::clone::Clone>::clone(p0);
+crate::<ast::CaptureName as std::clone::Clone>::clone(p0);
+<ast::CaptureName>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::CaptureName as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::CaptureName as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::CaptureName as std::fmt::Debug>::fmt(p0, p1);
+<ast::CaptureName>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.assert_receiver_is_total_eq();
+<ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::CaptureName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::CaptureName>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::CaptureName as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::CaptureName
+p0.eq(p1);
+<ast::CaptureName as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::CaptureName as std::cmp::PartialEq>::eq(p0, p1);
+<ast::CaptureName>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::SetFlags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.clone();
+<ast::SetFlags as std::clone::Clone>::clone(p0);
+crate::<ast::SetFlags as std::clone::Clone>::clone(p0);
+<ast::SetFlags>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::SetFlags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::SetFlags as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::SetFlags as std::fmt::Debug>::fmt(p0, p1);
+<ast::SetFlags>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.assert_receiver_is_total_eq();
+<ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::SetFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::SetFlags>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::SetFlags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::SetFlags
+p0.eq(p1);
+<ast::SetFlags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::SetFlags as std::cmp::PartialEq>::eq(p0, p1);
+<ast::SetFlags>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.clone();
+<ast::Flags as std::clone::Clone>::clone(p0);
+crate::<ast::Flags as std::clone::Clone>::clone(p0);
+<ast::Flags>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Flags as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Flags as std::fmt::Debug>::fmt(p0, p1);
+<ast::Flags>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.assert_receiver_is_total_eq();
+<ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Flags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Flags>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.eq(p1);
+<ast::Flags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Flags as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Flags>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Flags::add_item
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.add_item(p1);
+ast::Flags::add_item(p0, p1);
+crate::ast::Flags::add_item(p0, p1);
+<ast::Flags>::add_item(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::Flags::flag_state
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.flag_state(p1);
+ast::Flags::flag_state(p0, p1);
+crate::ast::Flags::flag_state(p0, p1);
+<ast::Flags>::flag_state(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItem as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.clone();
+<ast::FlagsItem as std::clone::Clone>::clone(p0);
+crate::<ast::FlagsItem as std::clone::Clone>::clone(p0);
+<ast::FlagsItem>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItem as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::FlagsItem as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::FlagsItem as std::fmt::Debug>::fmt(p0, p1);
+<ast::FlagsItem>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.assert_receiver_is_total_eq();
+<ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::FlagsItem as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::FlagsItem>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItem as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItem
+p0.eq(p1);
+<ast::FlagsItem as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::FlagsItem as std::cmp::PartialEq>::eq(p0, p1);
+<ast::FlagsItem>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItemKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.clone();
+<ast::FlagsItemKind as std::clone::Clone>::clone(p0);
+crate::<ast::FlagsItemKind as std::clone::Clone>::clone(p0);
+<ast::FlagsItemKind>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItemKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::FlagsItemKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::FlagsItemKind as std::fmt::Debug>::fmt(p0, p1);
+<ast::FlagsItemKind>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.assert_receiver_is_total_eq();
+<ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::FlagsItemKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::FlagsItemKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::FlagsItemKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.eq(p1);
+<ast::FlagsItemKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::FlagsItemKind as std::cmp::PartialEq>::eq(p0, p1);
+<ast::FlagsItemKind>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs ast::FlagsItemKind::is_negation
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::FlagsItemKind
+p0.is_negation();
+ast::FlagsItemKind::is_negation(p0);
+crate::ast::FlagsItemKind::is_negation(p0);
+<ast::FlagsItemKind>::is_negation(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flag as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.clone();
+<ast::Flag as std::clone::Clone>::clone(p0);
+crate::<ast::Flag as std::clone::Clone>::clone(p0);
+<ast::Flag>::clone(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flag as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ast::Flag as std::fmt::Debug>::fmt(p0, p1);
+crate::<ast::Flag as std::fmt::Debug>::fmt(p0, p1);
+<ast::Flag>::fmt(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.assert_receiver_is_total_eq();
+<ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ast::Flag as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ast::Flag>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::Flag as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flag
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flag
+p0.eq(p1);
+<ast::Flag as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ast::Flag as std::cmp::PartialEq>::eq(p0, p1);
+<ast::Flag>::eq(p0, p1);
-----------------
regex-syntax/src/ast/mod.rs <ast::Ast as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.drop();
+<ast::Ast as std::ops::Drop>::drop(p0);
+crate::<ast::Ast as std::ops::Drop>::drop(p0);
+<ast::Ast>::drop(p0);
-----------------
regex-syntax/src/ast/mod.rs <ast::ClassSet as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ast::ClassSet
+p0.drop();
+<ast::ClassSet as std::ops::Drop>::drop(p0);
+crate::<ast::ClassSet as std::ops::Drop>::drop(p0);
+<ast::ClassSet>::drop(p0);
-----------------
regex-syntax/src/either.rs <either::Either<Left, Right> as std::clone::Clone>::clone
deps:{"<&T as std::borrow::Borrow<T>>":{},"<either::Either<Left, Right> as std::clone::Clone>::clone":{"Left":["std::marker::Sized","std::clone::Clone"],"Right":["std::clone::Clone","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::clone::Clone","std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"either::Either":{"Left":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"],"Right":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","hir::interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<either::Either<Left, Right> as std::clone::Clone>::clone":{"Left":["ast::parse::ClassState","hir::literal::Literals","ast::ClassAsciiKind","std::clone::impls::<impl std::clone::Clone for &mut T>","ast::ClassUnicode","ast::RepetitionKind","ast::LiteralKind","ast::ClassPerlKind","hir::translate::Flags","ast::Literal","hir::ErrorKind","ast::SpecialLiteralKind","hir::Error","hir::GroupKind","ast::HexLiteralKind","hir::ClassUnicode","error::Error","ast::Group","ast::FlagsItemKind","hir::translate::TranslatorBuilder","hir::literal::Literal","hir::Class","ast::GroupKind","ast::Span","either::Either","parser::ParserBuilder","hir::RepetitionKind","ast::Repetition","ast::ErrorKind","ast::ClassSet","ast::parse::ParserI","ast::ClassSetRange","ast::Comment","ast::SetFlags","hir::Repetition","utf8::Utf8Sequence","hir::Hir","ast::parse::ParserBuilder","ast::ClassPerl","ast::ClassSetBinaryOp","ast::RepetitionOp","ast::ClassSetItem","hir::translate::Translator","ast::Position","ast::ClassUnicodeKind","ast::ClassUnicodeOpKind","ast::Ast","ast::AssertionKind","hir::Group","ast::Assertion","hir::ClassBytes","hir::WordBoundary","hir::HirKind","ast::WithComments","utf8::Utf8Range","hir::ClassBytesRange","ast::parse::GroupState","ast::Flag","hir::HirInfo","ast::print::PrinterBuilder","ast::FlagsItem","ast::CaptureName","ast::RepetitionRange","ast::Class","ast::parse::Primitive","parser::Parser","hir::print::PrinterBuilder","ast::ClassBracketed","hir::RepetitionRange","ast::ClassAscii","ast::Flags","ast::ClassSetUnion","hir::Literal","ast::parse::Parser","hir::ClassUnicodeRange","ast::Concat","ast::Alternation","ast::ClassSetBinaryOpKind","std::clone::impls::<impl std::clone::Clone for *const T>","hir::translate::TranslatorI","hir::interval::IntervalSet","ast::Error","hir::Anchor","hir::translate::HirFrame"],"Right":["ast::HexLiteralKind","ast::parse::GroupState","ast::RepetitionRange","ast::ClassSetBinaryOp","ast::Position","ast::ClassSetUnion","ast::parse::ParserBuilder","ast::Comment","hir::print::PrinterBuilder","ast::WithComments","ast::parse::Parser","ast::AssertionKind","ast::SetFlags","hir::ClassBytes","hir::translate::TranslatorBuilder","hir::Hir","ast::ClassPerl","ast::print::PrinterBuilder","ast::ClassUnicode","hir::translate::Flags","ast::RepetitionOp","ast::Class","ast::Ast","ast::parse::Primitive","ast::RepetitionKind","hir::ClassBytesRange","ast::Flags","ast::Repetition","ast::ClassSet","parser::ParserBuilder","ast::Group","hir::interval::IntervalSet","ast::Span","hir::ErrorKind","ast::ErrorKind","hir::WordBoundary","hir::Repetition","hir::Error","ast::Assertion","hir::HirInfo","ast::Literal","ast::ClassSetBinaryOpKind","std::clone::impls::<impl std::clone::Clone for *const T>","utf8::Utf8Range","hir::translate::HirFrame","hir::Class","ast::GroupKind","ast::ClassUnicodeOpKind","hir::ClassUnicodeRange","hir::Anchor","utf8::Utf8Sequence","hir::RepetitionKind","ast::ClassAscii","ast::Concat","hir::Group","ast::LiteralKind","ast::ClassAsciiKind","parser::Parser","ast::ClassSetItem","ast::ClassUnicodeKind","hir::ClassUnicode","ast::Alternation","hir::translate::TranslatorI","ast::Flag","ast::FlagsItemKind","ast::parse::ParserI","hir::HirKind","ast::SpecialLiteralKind","ast::Error","hir::RepetitionRange","hir::literal::Literals","error::Error","hir::Literal","either::Either","ast::ClassPerlKind","hir::literal::Literal","hir::translate::Translator","hir::GroupKind","ast::CaptureName","ast::ClassSetRange","ast::FlagsItem","ast::parse::ClassState","ast::ClassBracketed","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"ast::parse::ParserI":{"P":["std::string::String","std::ffi::CString","std::sync::Arc<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::path::PathBuf","std::rc::Rc<T>","std::clone::impls::<impl std::clone::Clone for &mut T>","std::ffi::OsString"]},"either::Either":{"Left":["hir::literal::Literals","ast::ClassSetRange","hir::HirKind","hir::Class","ast::ClassUnicodeOpKind","hir::Anchor","ast::Assertion","hir::Hir","error::Error","ast::FlagsItem","ast::Ast","hir::ClassUnicode","hir::ClassUnicodeRange","ast::Position","ast::GroupKind","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::FlagsItemKind","ast::RepetitionOp","hir::GroupKind","ast::ClassSetItem","ast::ClassSetBinaryOpKind","utf8::Utf8Range","ast::RepetitionRange","ast::AssertionKind","hir::literal::Literal","hir::HirInfo","ast::CaptureName","ast::Literal","ast::Comment","either::Either","hir::RepetitionKind","ast::ClassUnicodeKind","ast::Error","ast::ClassSetBinaryOp","ast::ClassAscii","hir::Error","ast::Repetition","utf8::Utf8Sequence","ast::ClassSet","hir::WordBoundary","ast::Flags","hir::Repetition","ast::ClassAsciiKind","ast::parse::Primitive","hir::Literal","ast::Flag","ast::Group","ast::SetFlags","ast::SpecialLiteralKind","ast::ErrorKind","hir::ClassBytesRange","ast::HexLiteralKind","hir::ErrorKind","ast::Span","ast::Concat","ast::ClassPerl","hir::RepetitionRange","ast::ClassSetUnion","hir::ClassBytes","ast::ClassPerlKind","ast::Class","ast::ClassUnicode","ast::ClassBracketed","ast::LiteralKind","hir::interval::IntervalSet","ast::Alternation","ast::RepetitionKind","ast::WithComments","hir::Group"],"Right":["ast::SpecialLiteralKind","ast::Ast","ast::ClassSet","ast::Comment","ast::ClassAscii","ast::ClassSetBinaryOpKind","hir::RepetitionRange","ast::FlagsItemKind","ast::Span","hir::WordBoundary","ast::ClassSetRange","ast::Literal","ast::ClassUnicodeKind","ast::SetFlags","ast::HexLiteralKind","ast::FlagsItem","ast::ClassUnicode","ast::RepetitionRange","hir::Literal","hir::literal::Literals","ast::ClassPerlKind","hir::ClassBytesRange","ast::AssertionKind","ast::CaptureName","hir::Repetition","hir::ClassUnicode","ast::Concat","ast::WithComments","ast::RepetitionKind","hir::literal::Literal","hir::Class","ast::GroupKind","utf8::Utf8Range","hir::RepetitionKind","ast::Group","hir::Error","ast::ClassUnicodeOpKind","utf8::Utf8Sequence","hir::ClassUnicodeRange","ast::Repetition","ast::RepetitionOp","ast::Error","ast::ClassSetBinaryOp","ast::Flag","ast::Alternation","ast::Flags","hir::Group","hir::ClassBytes","ast::ClassBracketed","ast::Assertion","ast::Position","ast::LiteralKind","hir::interval::IntervalSet","ast::ErrorKind","ast::ClassAsciiKind","ast::ClassSetUnion","hir::ErrorKind","ast::parse::Primitive","hir::Hir","ast::Class","error::Error","either::Either","hir::HirInfo","hir::GroupKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","hir::Anchor","ast::ClassSetItem","hir::HirKind","ast::ClassPerl"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
+p0.clone();
+<either::Either<Left, Right> as std::clone::Clone>::clone(p0);
+crate::<either::Either<Left, Right> as std::clone::Clone>::clone(p0);
+<either::Either<Left, Right>>::clone(p0);
-----------------
regex-syntax/src/either.rs <either::Either<Left, Right> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::fmt::Debug>::fmt":{"Left":["std::marker::Sized","std::fmt::Debug"],"Right":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"either::Either":{"Left":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"],"Right":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","hir::interval::Interval","std::clone::Clone"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::fmt::Debug>::fmt":{"Left":["ast::WithComments","hir::print::Writer","ast::CaptureName","hir::interval::IntervalSetIter","ast::RepetitionRange","ast::Error","hir::print::Printer","ast::FlagsItem","ast::Span","unicode::Error","ast::Flag","ast::ClassSetItem","hir::ClassUnicodeIter","ast::ClassUnicodeKind","hir::ErrorKind","hir::ClassUnicodeRange","ast::LiteralKind","unicode::UnicodeWordError","utf8::ScalarRange","ast::ClassSetUnion","ast::Assertion","ast::Group","hir::ClassBytesRange","ast::AssertionKind","ast::ClassSetBinaryOp","ast::ClassSetRange","hir::interval::IntervalSet","hir::translate::HirFrame","ast::parse::NestLimiter","hir::translate::Translator","ast::ClassAsciiKind","ast::Concat","ast::print::Writer","ast::GroupKind","unicode::CanonicalClassQuery","ast::visitor::ClassInduct","hir::GroupKind","ast::Class","hir::Hir","hir::Literal","ast::Alternation","error::Error","ast::parse::ClassState","ast::Ast","ast::RepetitionOp","ast::ClassSetBinaryOpKind","ast::ClassSet","utf8::Utf8Range","hir::Error","ast::ClassUnicode","ast::ClassPerlKind","hir::translate::Flags","ast::ClassPerl","hir::Anchor","parser::Parser","ast::ClassAscii","error::Formatter","hir::RepetitionRange","<&T as std::fmt::Debug>","ast::print::PrinterBuilder","hir::HirInfo","either::Either","ast::visitor::ClassFrame","hir::WordBoundary","ast::parse::ParserBuilder","ast::Position","ast::ClassUnicodeOpKind","ast::FlagsItemKind","hir::Repetition","ast::HexLiteralKind","<*mut T as std::fmt::Debug>","hir::HirKind","hir::translate::TranslatorBuilder","ast::parse::Parser","hir::literal::Literals","hir::translate::TranslatorI","ast::Repetition","ast::parse::ParserI","ast::Literal","ast::SpecialLiteralKind","utf8::Utf8Sequences","ast::ClassBracketed","utf8::Utf8Sequence","hir::print::PrinterBuilder","unicode::CaseFoldError","ast::ErrorKind","hir::Group","hir::ClassUnicode","hir::Class","parser::ParserBuilder","hir::ClassBytes","hir::literal::Literal","ast::print::Printer","unicode::ClassQuery","ast::SetFlags","hir::RepetitionKind","ast::Comment","hir::ClassBytesIter","ast::parse::Primitive","ast::parse::GroupState","ast::RepetitionKind","ast::Flags"],"Right":["ast::ClassSetBinaryOpKind","parser::ParserBuilder","hir::ClassBytes","ast::ClassSet","hir::Repetition","ast::visitor::ClassFrame","ast::Error","ast::parse::GroupState","ast::ClassSetBinaryOp","hir::print::Printer","error::Error","ast::Assertion","hir::RepetitionRange","ast::parse::Primitive","error::Formatter","hir::translate::HirFrame","hir::HirKind","ast::SetFlags","ast::Literal","hir::Error","unicode::CanonicalClassQuery","ast::RepetitionRange","hir::HirInfo","hir::ClassUnicodeRange","ast::Flag","ast::ClassPerl","hir::translate::Flags","ast::FlagsItemKind","hir::Class","hir::Anchor","hir::Literal","ast::Alternation","hir::ErrorKind","ast::Span","hir::translate::TranslatorBuilder","ast::Ast","ast::ClassAscii","ast::visitor::ClassInduct","ast::parse::ParserI","utf8::Utf8Sequences","either::Either","hir::ClassUnicodeIter","ast::LiteralKind","ast::parse::NestLimiter","ast::FlagsItem","hir::interval::IntervalSetIter","ast::Group","ast::RepetitionOp","ast::Repetition","ast::GroupKind","hir::translate::TranslatorI","ast::parse::ClassState","utf8::ScalarRange","ast::parse::Parser","ast::ClassPerlKind","ast::Concat","ast::Position","ast::AssertionKind","hir::literal::Literal","ast::print::PrinterBuilder","ast::ClassBracketed","ast::CaptureName","ast::ClassSetRange","hir::literal::Literals","ast::ClassUnicodeKind","hir::print::PrinterBuilder","parser::Parser","ast::Comment","ast::ClassUnicode","hir::Group","unicode::UnicodeWordError","hir::ClassBytesIter","ast::SpecialLiteralKind","hir::print::Writer","ast::ClassSetItem","ast::Flags","hir::translate::Translator","hir::ClassUnicode","ast::Class","hir::Hir","hir::RepetitionKind","hir::ClassBytesRange","ast::WithComments","unicode::CaseFoldError","<*mut T as std::fmt::Debug>","hir::GroupKind","ast::ErrorKind","unicode::Error","ast::ClassSetUnion","hir::interval::IntervalSet","utf8::Utf8Range","ast::parse::ParserBuilder","ast::ClassAsciiKind","ast::print::Printer","ast::ClassUnicodeOpKind","ast::RepetitionKind","utf8::Utf8Sequence","unicode::ClassQuery","hir::WordBoundary","ast::print::Writer","ast::HexLiteralKind"]},"ast::parse::NestLimiter":{"P":["std::ffi::CString","std::boxed::Box<T, A>","<&mut T as std::fmt::Debug>","std::string::String","std::vec::Vec<T, A>","std::ffi::OsString","std::path::PathBuf","std::sync::Arc<T>","std::rc::Rc<T>"]},"ast::parse::ParserI":{"P":["std::boxed::Box<T, A>","std::ffi::CString","<&mut T as std::fmt::Debug>","std::sync::Arc<T>","std::rc::Rc<T>","std::ffi::OsString","std::path::PathBuf","std::vec::Vec<T, A>","std::string::String"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::SetFlags","ast::ErrorKind","ast::LiteralKind","ast::AssertionKind","ast::ClassSetRange","ast::Group","ast::ClassAscii","hir::RepetitionRange","hir::literal::Literals","ast::ClassSetUnion","ast::GroupKind","ast::RepetitionKind","ast::FlagsItemKind","ast::SpecialLiteralKind","ast::ClassSetBinaryOpKind","hir::Class","hir::ClassBytes","hir::ClassUnicode","ast::ClassAsciiKind","ast::ClassUnicode","hir::Group","ast::CaptureName","ast::HexLiteralKind","ast::ClassPerl","ast::ClassUnicodeOpKind","hir::HirKind","ast::Flags","hir::Repetition","hir::WordBoundary","ast::Class","ast::Literal","ast::ClassBracketed","ast::ClassSetItem","utf8::Utf8Sequence","ast::Ast","ast::ClassSet","hir::Hir","ast::parse::Primitive","hir::literal::Literal","hir::GroupKind","hir::ClassUnicodeRange","hir::interval::IntervalSet","utf8::Utf8Range","either::Either","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::Alternation","error::Error","hir::Literal","hir::RepetitionKind","hir::HirInfo","ast::Repetition","hir::Error","ast::WithComments","ast::ClassUnicodeKind","ast::Assertion","hir::Anchor","ast::Flag","ast::ClassPerlKind","ast::Position","hir::ClassBytesRange","ast::Span","ast::RepetitionOp","ast::RepetitionRange","ast::Comment","ast::Error","ast::FlagsItem","ast::Concat","ast::ClassSetBinaryOp","hir::ErrorKind"],"Right":["ast::AssertionKind","ast::ClassAscii","ast::ErrorKind","ast::GroupKind","hir::Error","ast::Literal","ast::ClassPerl","ast::RepetitionOp","hir::literal::Literal","hir::Hir","hir::Group","hir::ClassBytes","ast::SpecialLiteralKind","hir::ClassBytesRange","ast::ClassSetRange","hir::HirKind","either::Either","hir::HirInfo","ast::FlagsItem","ast::HexLiteralKind","ast::parse::Primitive","ast::Class","hir::GroupKind","utf8::Utf8Range","ast::Flags","utf8::Utf8Sequence","ast::ClassSet","ast::ClassSetBinaryOpKind","hir::ClassUnicodeRange","ast::Assertion","ast::Repetition","hir::Literal","ast::Span","ast::ClassUnicode","ast::ClassSetItem","hir::ErrorKind","ast::ClassUnicodeOpKind","hir::WordBoundary","hir::literal::Literals","ast::Ast","ast::ClassSetBinaryOp","hir::interval::IntervalSet","ast::Alternation","ast::Group","ast::LiteralKind","ast::CaptureName","ast::SetFlags","ast::Concat","hir::Anchor","ast::Error","hir::RepetitionRange","ast::Position","ast::Flag","hir::RepetitionKind","hir::Repetition","ast::RepetitionKind","ast::ClassAsciiKind","error::Error","ast::ClassSetUnion","ast::WithComments","ast::FlagsItemKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::Comment","hir::ClassUnicode","ast::ClassUnicodeKind","hir::Class","ast::RepetitionRange","ast::ClassBracketed","ast::ClassPerlKind"]},"error::Formatter":{"E":["ast::Ast","hir::Hir","error::Error","unicode::CaseFoldError","unicode::UnicodeWordError","ast::ErrorKind","ast::Error","error::Formatter","<&T as std::fmt::Debug>","hir::Error","hir::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["hir::literal::Literal","ast::parse::ParserI","ast::parse::Parser","ast::Comment","hir::Repetition","hir::HirInfo","utf8::Utf8Range","hir::Literal","hir::ClassUnicodeRange","ast::ClassSetUnion","ast::visitor::ClassFrame","unicode::CaseFoldError","hir::ErrorKind","ast::parse::ClassState","utf8::Utf8Sequence","hir::translate::Flags","hir::interval::IntervalSetIter","ast::Span","ast::parse::NestLimiter","ast::print::Writer","hir::Hir","ast::parse::GroupState","hir::RepetitionRange","ast::FlagsItemKind","unicode::CanonicalClassQuery","ast::Literal","hir::HirKind","hir::RepetitionKind","ast::Ast","hir::Class","hir::translate::TranslatorBuilder","ast::Repetition","unicode::Error","ast::ClassAscii","hir::print::Printer","ast::Concat","ast::visitor::ClassInduct","ast::SpecialLiteralKind","ast::ClassPerlKind","ast::RepetitionRange","ast::Flags","either::Either","ast::ClassAsciiKind","hir::interval::IntervalSet","ast::ClassSetItem","error::Formatter","ast::ClassBracketed","ast::Position","hir::ClassBytesRange","unicode::ClassQuery","hir::ClassBytes","ast::WithComments","hir::print::Writer","hir::translate::TranslatorI","hir::Anchor","ast::RepetitionKind","unicode::UnicodeWordError","ast::print::PrinterBuilder","ast::parse::ParserBuilder","hir::print::PrinterBuilder","ast::Alternation","error::Error","utf8::Utf8Sequences","hir::translate::HirFrame","hir::ClassUnicode","ast::ClassSetBinaryOpKind","parser::Parser","hir::ClassUnicodeIter","ast::Group","ast::ClassUnicodeKind","ast::ClassPerl","<&mut T as std::fmt::Debug>","ast::ClassSetBinaryOp","ast::CaptureName","ast::ClassUnicode","ast::ClassSet","hir::Group","parser::ParserBuilder","utf8::ScalarRange","ast::GroupKind","ast::Error","ast::LiteralKind","ast::print::Printer","hir::WordBoundary","ast::ClassUnicodeOpKind","ast::SetFlags","ast::AssertionKind","ast::ClassSetRange","ast::parse::Primitive","hir::literal::Literals","ast::Flag","hir::GroupKind","ast::Class","ast::ErrorKind","ast::RepetitionOp","hir::translate::Translator","ast::HexLiteralKind","hir::ClassBytesIter","ast::FlagsItem","ast::Assertion","hir::Error"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<either::Either<Left, Right> as std::fmt::Debug>::fmt(p0, p1);
+crate::<either::Either<Left, Right> as std::fmt::Debug>::fmt(p0, p1);
+<either::Either<Left, Right>>::fmt(p0, p1);
-----------------
regex-syntax/src/either.rs <either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq":{"Left":["std::cmp::Eq","std::marker::Sized"],"Right":["std::cmp::Eq","std::marker::Sized"]},"either::Either":{"Left":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"],"Right":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","hir::interval::Interval","std::cmp::PartialEq"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq":{"Left":["ast::Literal","hir::WordBoundary","ast::ClassSet","hir::Error","hir::ClassBytes","ast::CaptureName","ast::LiteralKind","hir::ClassUnicode","ast::RepetitionRange","hir::Hir","ast::GroupKind","ast::AssertionKind","ast::Concat","ast::Span","ast::Group","ast::parse::Primitive","ast::ClassBracketed","ast::Error","hir::GroupKind","ast::ClassSetRange","ast::Ast","ast::ClassUnicodeOpKind","ast::ErrorKind","ast::HexLiteralKind","ast::ClassAsciiKind","ast::ClassUnicodeKind","ast::ClassSetItem","error::Error","ast::Repetition","ast::ClassSetBinaryOpKind","utf8::Utf8Range","ast::Alternation","ast::Flag","hir::RepetitionKind","hir::Class","hir::interval::IntervalSet","ast::WithComments","ast::Assertion","unicode::CanonicalClassQuery","either::Either","ast::Flags","hir::HirKind","ast::ClassPerl","hir::Group","ast::Comment","ast::ClassAscii","hir::HirInfo","hir::ErrorKind","hir::literal::Literal","ast::RepetitionKind","ast::ClassSetUnion","hir::RepetitionRange","hir::ClassBytesRange","std::cmp::impls::<impl std::cmp::Eq for &mut A>","ast::FlagsItem","ast::ClassUnicode","ast::RepetitionOp","ast::ClassSetBinaryOp","ast::SetFlags","std::cmp::impls::<impl std::cmp::Eq for &A>","ast::Class","utf8::Utf8Sequence","ast::FlagsItemKind","hir::Repetition","ast::SpecialLiteralKind","hir::ClassUnicodeRange","hir::literal::Literals","ast::ClassPerlKind","ast::Position","hir::Anchor","hir::Literal"],"Right":["ast::AssertionKind","ast::ClassSetBinaryOpKind","ast::ClassAsciiKind","hir::ErrorKind","hir::WordBoundary","ast::SpecialLiteralKind","hir::HirKind","unicode::CanonicalClassQuery","ast::Span","hir::Group","ast::ClassSetRange","ast::ClassBracketed","ast::parse::Primitive","ast::SetFlags","hir::Literal","hir::ClassBytesRange","utf8::Utf8Sequence","ast::ClassUnicodeOpKind","hir::Anchor","hir::literal::Literals","ast::Class","ast::Error","hir::RepetitionRange","ast::ErrorKind","hir::ClassBytes","ast::Comment","error::Error","hir::Class","ast::Repetition","ast::Position","ast::CaptureName","ast::GroupKind","ast::ClassUnicodeKind","ast::ClassSetBinaryOp","ast::ClassAscii","ast::FlagsItem","hir::RepetitionKind","hir::ClassUnicode","ast::Group","ast::Assertion","ast::Literal","hir::Error","hir::HirInfo","ast::WithComments","ast::ClassPerl","ast::Concat","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::Ast","ast::ClassUnicode","std::cmp::impls::<impl std::cmp::Eq for &A>","ast::Flags","hir::ClassUnicodeRange","ast::ClassSetItem","ast::ClassPerlKind","ast::RepetitionRange","ast::HexLiteralKind","hir::Repetition","ast::FlagsItemKind","hir::literal::Literal","ast::ClassSetUnion","ast::ClassSet","hir::interval::IntervalSet","utf8::Utf8Range","hir::Hir","ast::RepetitionKind","either::Either","ast::Flag","ast::LiteralKind","ast::RepetitionOp","hir::GroupKind","ast::Alternation"]},"either::Either":{"Left":["ast::Alternation","hir::interval::IntervalSet","hir::literal::Literal","hir::RepetitionKind","ast::Repetition","ast::Assertion","ast::Position","hir::HirInfo","hir::Class","ast::ClassUnicodeOpKind","ast::CaptureName","ast::ClassBracketed","hir::Hir","ast::RepetitionKind","ast::SpecialLiteralKind","hir::ClassUnicode","ast::ClassAscii","utf8::Utf8Sequence","ast::Comment","ast::FlagsItemKind","error::Error","hir::ClassBytesRange","ast::Concat","ast::FlagsItem","ast::Ast","hir::ClassUnicodeRange","ast::ClassSetBinaryOp","ast::LiteralKind","hir::Repetition","ast::Class","hir::Literal","ast::ClassAsciiKind","ast::SetFlags","ast::ClassSetBinaryOpKind","either::Either","ast::parse::Primitive","ast::Error","ast::ClassSet","hir::Group","hir::Error","hir::ErrorKind","ast::ClassPerlKind","utf8::Utf8Range","ast::ClassSetRange","hir::GroupKind","hir::WordBoundary","ast::RepetitionRange","ast::ClassSetItem","ast::GroupKind","ast::WithComments","hir::literal::Literals","ast::RepetitionOp","ast::ClassUnicodeKind","ast::ClassSetUnion","hir::ClassBytes","ast::ClassUnicode","ast::Literal","ast::Flag","ast::AssertionKind","hir::RepetitionRange","ast::Group","ast::Flags","hir::HirKind","ast::Span","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::ClassPerl","hir::Anchor","ast::HexLiteralKind","ast::ErrorKind"],"Right":["ast::Ast","ast::Assertion","utf8::Utf8Range","hir::ErrorKind","hir::RepetitionKind","hir::Group","ast::ClassAsciiKind","ast::Error","error::Error","ast::Comment","hir::literal::Literals","ast::ClassPerlKind","ast::HexLiteralKind","hir::HirInfo","ast::SpecialLiteralKind","hir::Anchor","hir::Repetition","ast::Group","ast::parse::Primitive","ast::RepetitionKind","hir::ClassBytesRange","ast::SetFlags","ast::CaptureName","ast::ClassSetUnion","ast::AssertionKind","ast::Literal","hir::Error","ast::ClassUnicodeKind","hir::Literal","ast::ClassSetRange","hir::RepetitionRange","ast::GroupKind","ast::ClassSetBinaryOp","ast::RepetitionOp","ast::Alternation","ast::ClassUnicode","hir::Hir","ast::Class","ast::Flag","hir::interval::IntervalSet","hir::literal::Literal","hir::HirKind","ast::ClassSetBinaryOpKind","hir::ClassUnicodeRange","ast::FlagsItem","ast::ErrorKind","ast::ClassBracketed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::Flags","ast::FlagsItemKind","ast::Concat","ast::ClassSet","hir::ClassBytes","hir::WordBoundary","ast::RepetitionRange","ast::ClassUnicodeOpKind","ast::Position","ast::WithComments","utf8::Utf8Sequence","ast::Span","ast::ClassPerl","ast::Repetition","ast::ClassSetItem","hir::Class","either::Either","ast::ClassAscii","ast::LiteralKind","hir::ClassUnicode","hir::GroupKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
+p0.assert_receiver_is_total_eq();
+<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<either::Either<Left, Right> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<either::Either<Left, Right>>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/either.rs <either::Either<Left, Right> as std::cmp::PartialEq>::eq
deps:{"<either::Either<Left, Right> as std::cmp::PartialEq>::eq":{"Left":["std::cmp::PartialEq","std::marker::Sized"],"Right":["std::marker::Sized","std::cmp::PartialEq"]},"either::Either":{"Left":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"],"Right":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","hir::interval::Interval","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<either::Either<Left, Right> as std::cmp::PartialEq>::eq":{"Left":["ast::Concat","ast::Literal","ast::Comment","ast::RepetitionRange","ast::LiteralKind","ast::FlagsItem","hir::literal::Literals","ast::ClassSetItem","ast::ErrorKind","ast::HexLiteralKind","hir::Anchor","ast::ClassUnicodeOpKind","ast::ClassBracketed","hir::RepetitionRange","ast::Repetition","hir::ErrorKind","hir::GroupKind","ast::Group","unicode::CanonicalClassQuery","ast::ClassSetUnion","ast::RepetitionOp","ast::SpecialLiteralKind","ast::ClassSetRange","ast::ClassAscii","hir::ClassBytes","hir::ClassBytesRange","ast::Ast","ast::Position","ast::ClassPerlKind","utf8::Utf8Sequence","ast::GroupKind","ast::ClassSet","ast::ClassSetBinaryOp","ast::ClassPerl","ast::Error","hir::interval::IntervalSet","utf8::Utf8Range","hir::Literal","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","hir::Group","hir::ClassUnicodeRange","hir::RepetitionKind","ast::ClassAsciiKind","hir::WordBoundary","ast::Span","hir::Repetition","ast::Alternation","ast::Flags","ast::CaptureName","hir::literal::Literal","hir::HirInfo","hir::Class","either::Either","ast::ClassUnicodeKind","hir::HirKind","ast::ClassSetBinaryOpKind","ast::AssertionKind","hir::Error","hir::ClassUnicode","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::Error","ast::Flag","ast::RepetitionKind","ast::Class","hir::Hir","ast::Assertion","ast::WithComments","ast::FlagsItemKind","ast::ClassUnicode","ast::SetFlags","ast::parse::Primitive"],"Right":["hir::HirInfo","hir::Hir","ast::FlagsItemKind","ast::LiteralKind","ast::Literal","ast::Alternation","ast::GroupKind","ast::SpecialLiteralKind","hir::Repetition","hir::Group","hir::interval::IntervalSet","ast::ClassSetUnion","ast::Flag","ast::ClassPerlKind","ast::ClassSet","ast::RepetitionRange","ast::FlagsItem","utf8::Utf8Range","ast::ClassSetBinaryOp","ast::Error","hir::RepetitionKind","ast::ClassSetRange","ast::ClassPerl","ast::ClassAsciiKind","unicode::CanonicalClassQuery","hir::GroupKind","hir::literal::Literals","hir::ClassBytesRange","hir::ClassBytes","utf8::Utf8Sequence","hir::Class","hir::ClassUnicode","ast::HexLiteralKind","hir::ClassUnicodeRange","hir::ErrorKind","ast::ClassBracketed","hir::Literal","ast::SetFlags","ast::Assertion","hir::HirKind","error::Error","ast::Position","ast::Class","ast::ClassSetItem","ast::RepetitionOp","ast::WithComments","ast::Span","ast::Concat","ast::Comment","ast::ErrorKind","ast::ClassAscii","ast::Ast","ast::Flags","ast::ClassUnicodeKind","hir::Error","hir::literal::Literal","hir::RepetitionRange","ast::Group","ast::ClassUnicode","ast::ClassUnicodeOpKind","hir::Anchor","ast::parse::Primitive","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","hir::WordBoundary","ast::RepetitionKind","ast::Repetition","ast::AssertionKind","ast::CaptureName","ast::ClassSetBinaryOpKind","either::Either"]},"either::Either":{"Left":["ast::ClassSetItem","ast::SetFlags","hir::HirKind","hir::WordBoundary","ast::RepetitionOp","hir::Literal","ast::RepetitionRange","hir::Group","hir::RepetitionKind","ast::ErrorKind","ast::Position","hir::literal::Literals","ast::Ast","ast::Class","ast::ClassSetUnion","ast::RepetitionKind","hir::ClassBytes","hir::ClassBytesRange","ast::CaptureName","ast::ClassUnicode","hir::HirInfo","ast::ClassPerl","ast::Flags","ast::ClassUnicodeKind","ast::Span","ast::GroupKind","ast::ClassPerlKind","ast::Concat","hir::Anchor","ast::ClassSetBinaryOp","utf8::Utf8Sequence","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::Alternation","ast::Repetition","ast::ClassSetRange","hir::literal::Literal","ast::Flag","ast::ClassBracketed","ast::parse::Primitive","ast::HexLiteralKind","ast::ClassUnicodeOpKind","ast::Literal","ast::Group","ast::AssertionKind","hir::RepetitionRange","ast::LiteralKind","hir::Repetition","hir::Error","ast::SpecialLiteralKind","ast::FlagsItem","ast::ClassAscii","hir::Class","hir::interval::IntervalSet","ast::ClassSetBinaryOpKind","hir::ClassUnicode","error::Error","hir::ErrorKind","hir::Hir","ast::FlagsItemKind","ast::Assertion","either::Either","ast::Comment","utf8::Utf8Range","hir::GroupKind","ast::ClassAsciiKind","ast::WithComments","ast::Error","hir::ClassUnicodeRange","ast::ClassSet"],"Right":["hir::ClassBytesRange","ast::HexLiteralKind","ast::Position","hir::ErrorKind","hir::Hir","hir::literal::Literals","hir::RepetitionRange","ast::ClassUnicodeKind","ast::Assertion","hir::literal::Literal","ast::FlagsItemKind","ast::Flag","ast::ClassAsciiKind","ast::Span","ast::Concat","ast::ClassBracketed","hir::HirInfo","ast::AssertionKind","ast::Alternation","ast::Error","hir::ClassBytes","ast::ClassSet","hir::Literal","ast::Class","ast::ClassUnicode","ast::FlagsItem","ast::WithComments","ast::Comment","ast::SpecialLiteralKind","hir::Error","ast::CaptureName","ast::parse::Primitive","either::Either","hir::interval::IntervalSet","hir::GroupKind","ast::RepetitionOp","ast::LiteralKind","ast::GroupKind","hir::Repetition","hir::Class","ast::Repetition","ast::ClassAscii","ast::Group","ast::Ast","ast::ClassSetItem","hir::Group","hir::HirKind","ast::ClassPerl","ast::Flags","ast::ClassUnicodeOpKind","error::Error","hir::ClassUnicodeRange","std::clone::impls::<impl std::clone::Clone for *const T>","hir::WordBoundary","ast::ClassSetBinaryOpKind","utf8::Utf8Range","ast::Literal","ast::ClassSetRange","utf8::Utf8Sequence","ast::RepetitionRange","ast::ClassSetBinaryOp","ast::SetFlags","hir::ClassUnicode","hir::RepetitionKind","hir::Anchor","ast::RepetitionKind","ast::ErrorKind","ast::ClassSetUnion","ast::ClassPerlKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
let mut p1 = & MaybeUninit::uninit().assume_init(); // either::Either<Left, Right>
+p0.eq(p1);
+<either::Either<Left, Right> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<either::Either<Left, Right> as std::cmp::PartialEq>::eq(p0, p1);
+<either::Either<Left, Right>>::eq(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.clone();
+<error::Error as std::clone::Clone>::clone(p0);
+crate::<error::Error as std::clone::Clone>::clone(p0);
+<error::Error>::clone(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Debug>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.assert_receiver_is_total_eq();
+<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::Error>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.eq(p1);
+<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+<error::Error>::eq(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Error as std::convert::From<ast::Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // ast::Error
+<error::Error as std::convert::From<ast::Error>>::from(p0);
+crate::<error::Error as std::convert::From<ast::Error>>::from(p0);
+<error::Error>::from(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::convert::From<hir::Error>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Error
+<error::Error as std::convert::From<hir::Error>>::from(p0);
+crate::<error::Error as std::convert::From<hir::Error>>::from(p0);
+<error::Error>::from(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.description();
+<error::Error as std::error::Error>::description(p0);
+crate::<error::Error as std::error::Error>::description(p0);
+<error::Error>::description(p0);
-----------------
regex-syntax/src/error.rs <error::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Display>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Formatter<'e, E> as std::fmt::Debug>::fmt
'e
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Formatter<'e, E> as std::fmt::Debug>::fmt":{"E":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"either::Either":{"Left":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"],"Right":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::cmp::Eq","hir::interval::Interval","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Formatter<'e, E> as std::fmt::Debug>::fmt":{"E":["unicode::Error","ast::parse::Primitive","hir::translate::Translator","error::Formatter","ast::AssertionKind","ast::WithComments","ast::ClassSetBinaryOp","ast::ClassUnicodeOpKind","ast::RepetitionOp","ast::print::Writer","ast::Group","hir::Group","hir::ErrorKind","ast::Class","ast::CaptureName","ast::FlagsItem","ast::ClassAscii","hir::WordBoundary","ast::SpecialLiteralKind","hir::Hir","ast::Flag","utf8::ScalarRange","hir::ClassBytes","hir::translate::HirFrame","ast::RepetitionRange","hir::literal::Literals","ast::LiteralKind","hir::ClassBytesIter","unicode::CaseFoldError","ast::Ast","unicode::ClassQuery","ast::ClassSetRange","ast::visitor::ClassFrame","hir::RepetitionRange","hir::print::Writer","ast::Flags","ast::FlagsItemKind","unicode::UnicodeWordError","hir::translate::TranslatorI","hir::print::PrinterBuilder","ast::parse::Parser","ast::parse::ClassState","ast::ClassAsciiKind","ast::ErrorKind","error::Error","parser::Parser","hir::HirKind","hir::Repetition","ast::RepetitionKind","ast::ClassSetBinaryOpKind","ast::SetFlags","ast::ClassPerlKind","ast::Literal","hir::print::Printer","ast::HexLiteralKind","hir::ClassUnicodeIter","parser::ParserBuilder","either::Either","hir::translate::Flags","hir::translate::TranslatorBuilder","ast::Assertion","hir::literal::Literal","ast::Concat","ast::ClassPerl","hir::Error","ast::Comment","ast::ClassUnicode","ast::Position","ast::parse::NestLimiter","hir::RepetitionKind","ast::Span","utf8::Utf8Range","ast::print::Printer","ast::Error","ast::ClassUnicodeKind","hir::interval::IntervalSetIter","hir::HirInfo","ast::ClassBracketed","ast::Alternation","hir::Class","hir::ClassUnicodeRange","ast::ClassSetItem","ast::parse::ParserI","utf8::Utf8Sequences","<&mut T as std::fmt::Debug>","hir::Anchor","unicode::CanonicalClassQuery","ast::Repetition","ast::parse::ParserBuilder","utf8::Utf8Sequence","hir::Literal","ast::ClassSetUnion","ast::print::PrinterBuilder","ast::visitor::ClassInduct","hir::interval::IntervalSet","hir::GroupKind","ast::ClassSet","hir::ClassBytesRange","hir::ClassUnicode","ast::GroupKind","ast::parse::GroupState"]},"ast::parse::NestLimiter":{"P":["std::ffi::CString","std::vec::Vec<T, A>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::ffi::OsString","std::boxed::Box<T, A>","std::rc::Rc<T>","std::sync::Arc<T>","std::path::PathBuf"]},"ast::parse::ParserI":{"P":["std::vec::Vec<T, A>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::sync::Arc<T>","std::path::PathBuf","std::boxed::Box<T, A>","std::string::String","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["hir::HirInfo","ast::ClassSetRange","ast::Class","hir::ClassBytes","either::Either","ast::AssertionKind","hir::Repetition","utf8::Utf8Range","ast::SpecialLiteralKind","ast::ClassSetBinaryOpKind","hir::Class","ast::Literal","ast::ClassPerl","ast::FlagsItem","ast::ClassUnicodeOpKind","hir::HirKind","ast::RepetitionOp","hir::interval::IntervalSet","ast::Span","ast::Comment","ast::RepetitionRange","ast::Flags","ast::Flag","hir::Group","ast::Group","hir::RepetitionKind","ast::ClassAscii","hir::ClassBytesRange","hir::Literal","ast::RepetitionKind","ast::ErrorKind","ast::Alternation","hir::WordBoundary","ast::Repetition","ast::ClassSetItem","ast::Error","ast::Position","hir::ClassUnicode","hir::ClassUnicodeRange","ast::ClassSetUnion","ast::WithComments","ast::ClassSetBinaryOp","ast::ClassUnicodeKind","utf8::Utf8Sequence","<*mut T as std::fmt::Debug>","ast::Concat","ast::ClassAsciiKind","hir::RepetitionRange","ast::ClassBracketed","ast::ClassSet","hir::Error","hir::Anchor","ast::parse::Primitive","hir::GroupKind","error::Error","hir::literal::Literal","ast::FlagsItemKind","ast::Assertion","ast::Ast","ast::SetFlags","ast::GroupKind","hir::Hir","hir::literal::Literals","ast::CaptureName","ast::ClassPerlKind","hir::ErrorKind","ast::LiteralKind","ast::ClassUnicode","ast::HexLiteralKind"],"Right":["ast::Literal","ast::Class","hir::Repetition","hir::ClassBytes","ast::RepetitionKind","ast::RepetitionRange","ast::Flags","hir::ClassUnicodeRange","ast::Alternation","error::Error","utf8::Utf8Sequence","ast::HexLiteralKind","hir::RepetitionKind","ast::ClassSetUnion","ast::ClassBracketed","hir::Class","ast::ClassSetRange","ast::Concat","ast::CaptureName","ast::Group","hir::literal::Literals","hir::WordBoundary","ast::ClassAsciiKind","hir::HirInfo","utf8::Utf8Range","ast::Repetition","ast::Comment","ast::Flag","ast::ClassSet","hir::GroupKind","ast::ClassSetBinaryOp","ast::FlagsItem","ast::Position","hir::RepetitionRange","ast::ClassPerl","ast::ErrorKind","ast::ClassPerlKind","hir::Group","ast::WithComments","ast::ClassSetItem","either::Either","hir::Literal","ast::Error","hir::HirKind","ast::AssertionKind","ast::SpecialLiteralKind","ast::ClassUnicodeKind","hir::ClassUnicode","ast::parse::Primitive","ast::SetFlags","hir::Anchor","ast::Assertion","ast::RepetitionOp","hir::literal::Literal","hir::ClassBytesRange","hir::Error","hir::ErrorKind","ast::ClassSetBinaryOpKind","ast::GroupKind","ast::ClassUnicodeOpKind","ast::ClassAscii","std::clone::impls::<impl std::clone::Clone for *const T>","ast::Ast","ast::FlagsItemKind","hir::Hir","ast::LiteralKind","ast::ClassUnicode","ast::Span","hir::interval::IntervalSet"]},"error::Formatter":{"E":["unicode::UnicodeWordError","error::Formatter","ast::ErrorKind","error::Error","hir::Hir","ast::Ast","ast::Error","hir::ErrorKind","unicode::CaseFoldError","hir::Error","<&mut T as std::fmt::Display>"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::Concat","hir::ClassBytes","utf8::ScalarRange","ast::ClassSetItem","ast::print::PrinterBuilder","ast::WithComments","ast::visitor::ClassFrame","hir::ClassBytesIter","utf8::Utf8Sequences","ast::Flag","ast::Ast","ast::Repetition","hir::print::PrinterBuilder","hir::Repetition","ast::ClassAscii","hir::interval::IntervalSet","ast::HexLiteralKind","unicode::CanonicalClassQuery","ast::Position","ast::parse::Parser","unicode::ClassQuery","ast::ClassUnicodeOpKind","unicode::UnicodeWordError","parser::Parser","ast::Class","ast::parse::NestLimiter","ast::ClassSetRange","ast::ClassSet","error::Formatter","hir::ClassUnicodeIter","ast::RepetitionRange","hir::GroupKind","hir::literal::Literals","ast::ErrorKind","ast::parse::GroupState","unicode::CaseFoldError","ast::ClassSetBinaryOpKind","ast::ClassUnicodeKind","ast::ClassUnicode","ast::print::Printer","ast::Alternation","utf8::Utf8Sequence","ast::LiteralKind","ast::parse::ParserI","ast::parse::ClassState","<&T as std::fmt::Debug>","hir::RepetitionKind","ast::RepetitionKind","hir::translate::Flags","hir::ClassUnicodeRange","hir::translate::TranslatorBuilder","hir::ClassBytesRange","ast::Span","parser::ParserBuilder","ast::parse::Primitive","hir::translate::TranslatorI","hir::print::Printer","ast::parse::ParserBuilder","hir::translate::HirFrame","ast::ClassPerl","ast::ClassSetBinaryOp","hir::literal::Literal","hir::Hir","utf8::Utf8Range","ast::ClassPerlKind","ast::FlagsItemKind","hir::Class","ast::RepetitionOp","hir::interval::IntervalSetIter","ast::visitor::ClassInduct","either::Either","ast::Group","hir::ClassUnicode","ast::GroupKind","hir::translate::Translator","ast::SpecialLiteralKind","ast::ClassAsciiKind","ast::ClassSetUnion","hir::ErrorKind","hir::Group","ast::AssertionKind","hir::Literal","ast::Comment","ast::CaptureName","unicode::Error","error::Error","ast::Assertion","ast::print::Writer","hir::Anchor","hir::RepetitionRange","hir::Error","ast::Literal","hir::HirKind","ast::Flags","ast::SetFlags","ast::Error","hir::HirInfo","ast::ClassBracketed","ast::FlagsItem","hir::print::Writer","hir::WordBoundary"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Formatter<'e, E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Formatter<'e, E> as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Formatter<'e, E> as std::fmt::Debug>::fmt(p0, p1);
+<error::Formatter<'e, E>>::fmt(p0, p1);
-----------------
regex-syntax/src/error.rs <error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from
'e
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Error
+<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from(p0);
+crate::<error::Formatter<'e, ast::ErrorKind> as std::convert::From<&'e ast::Error>>::from(p0);
+<error::Formatter<'e, ast::ErrorKind>>::from(p0);
-----------------
regex-syntax/src/error.rs <error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from
'e
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from(p0);
+crate::<error::Formatter<'e, hir::ErrorKind> as std::convert::From<&'e hir::Error>>::from(p0);
+<error::Formatter<'e, hir::ErrorKind>>::from(p0);
-----------------
regex-syntax/src/error.rs <error::Formatter<'e, E> as std::fmt::Display>::fmt
'e
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<error::Formatter<'e, E> as std::fmt::Display>::fmt":{"E":["std::fmt::Display","std::marker::Sized"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<error::Formatter<'e, E> as std::fmt::Display>::fmt":{"E":["hir::Error","ast::ErrorKind","error::Error","unicode::CaseFoldError","error::Formatter","unicode::UnicodeWordError","ast::Error","hir::ErrorKind","<&mut T as std::fmt::Display>","ast::Ast","hir::Hir","<&T as std::fmt::Display>"]},"error::Formatter":{"E":["ast::ErrorKind","hir::ErrorKind","hir::Hir","error::Error","unicode::UnicodeWordError","ast::Error","error::Formatter","<&T as std::fmt::Display>","ast::Ast","unicode::CaseFoldError","hir::Error"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Formatter<'e, E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Formatter<'e, E> as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Formatter<'e, E> as std::fmt::Display>::fmt(p0, p1);
+<error::Formatter<'e, E>>::fmt(p0, p1);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::from_formatter
'p
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"error::Formatter":{"E":["std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::Spans::<'p>::from_formatter":{"E":["std::fmt::Display","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"error::Formatter":{"E":["hir::Error","<&mut T as std::fmt::Display>","ast::Ast","error::Formatter","error::Error","ast::Error","hir::ErrorKind","unicode::CaseFoldError","hir::Hir","ast::ErrorKind","unicode::UnicodeWordError"]},"error::Spans::<'p>::from_formatter":{"E":["<&mut T as std::fmt::Display>","ast::Error","hir::ErrorKind","error::Formatter","error::Error","hir::Error","unicode::UnicodeWordError","ast::Ast","ast::ErrorKind","unicode::CaseFoldError","hir::Hir"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Formatter<'e, E>
+error::Spans::<'p>::from_formatter(p0);
+crate::error::Spans::<'p>::from_formatter(p0);
+<error::Spans<'p>>::from_formatter(p0);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::add
'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // error::Spans<'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
+p0.add(p1);
+error::Spans::<'p>::add(p0, p1);
+crate::error::Spans::<'p>::add(p0, p1);
+<error::Spans<'p>>::add(p0, p1);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::notate
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
+p0.notate();
+error::Spans::<'p>::notate(p0);
+crate::error::Spans::<'p>::notate(p0);
+<error::Spans<'p>>::notate(p0);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::notate_line
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
let mut p1 = 0usize; // None+usize
+p0.notate_line(p1);
+error::Spans::<'p>::notate_line(p0, p1);
+crate::error::Spans::<'p>::notate_line(p0, p1);
+<error::Spans<'p>>::notate_line(p0, p1);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::left_pad_line_number
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
let mut p1 = 0usize; // None+usize
+p0.left_pad_line_number(p1);
+error::Spans::<'p>::left_pad_line_number(p0, p1);
+crate::error::Spans::<'p>::left_pad_line_number(p0, p1);
+<error::Spans<'p>>::left_pad_line_number(p0, p1);
-----------------
regex-syntax/src/error.rs error::Spans::<'p>::line_number_padding
'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Spans<'p>
+p0.line_number_padding();
+error::Spans::<'p>::line_number_padding(p0);
+crate::error::Spans::<'p>::line_number_padding(p0);
+<error::Spans<'p>>::line_number_padding(p0);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSet<I> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::clone::Clone>::clone":{"I":["std::marker::Sized","std::clone::Clone"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug","std::clone::Clone"]},"either::Either":{"Left":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"],"Right":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"hir::interval::IntervalSet":{"I":["std::clone::Clone","hir::interval::Interval","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::clone::Clone>::clone":{"I":["hir::ErrorKind","ast::print::PrinterBuilder","ast::FlagsItemKind","ast::ClassSet","hir::ClassBytesRange","hir::Repetition","ast::ClassAscii","hir::print::PrinterBuilder","hir::HirKind","hir::GroupKind","ast::Concat","ast::parse::ParserI","hir::Class","ast::Flags","hir::ClassUnicodeRange","ast::Assertion","utf8::Utf8Sequence","parser::ParserBuilder","ast::SpecialLiteralKind","ast::RepetitionOp","ast::GroupKind","ast::parse::Primitive","std::clone::impls::<impl std::clone::Clone for *const T>","ast::Flag","ast::ClassPerl","ast::ClassSetRange","ast::CaptureName","hir::HirInfo","ast::Alternation","ast::Group","utf8::Utf8Range","ast::ClassPerlKind","ast::ErrorKind","hir::Hir","hir::Anchor","hir::ClassUnicode","hir::translate::TranslatorI","ast::parse::GroupState","ast::AssertionKind","hir::translate::Translator","either::Either","hir::RepetitionKind","ast::ClassUnicodeKind","ast::RepetitionRange","ast::WithComments","hir::translate::HirFrame","ast::RepetitionKind","hir::translate::Flags","hir::WordBoundary","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::ClassUnicode","error::Error","hir::literal::Literals","ast::ClassAsciiKind","ast::SetFlags","ast::parse::ClassState","ast::Span","ast::ClassSetBinaryOpKind","ast::Ast","ast::Position","hir::translate::TranslatorBuilder","hir::Literal","ast::Literal","ast::Repetition","ast::LiteralKind","ast::parse::ParserBuilder","ast::ClassBracketed","ast::ClassUnicodeOpKind","ast::ClassSetItem","hir::interval::IntervalSet","ast::Class","ast::Error","hir::literal::Literal","ast::ClassSetBinaryOp","hir::RepetitionRange","ast::ClassSetUnion","hir::ClassBytes","hir::Error","hir::Group","ast::parse::Parser","ast::Comment","ast::FlagsItem","ast::HexLiteralKind","parser::Parser"]},"ast::parse::ParserI":{"P":["std::boxed::Box<T, A>","std::path::PathBuf","std::string::String","std::vec::Vec<T, A>","std::ffi::OsString","std::sync::Arc<T>","std::rc::Rc<T>","std::ffi::CString","<&T as std::fmt::Debug>"]},"either::Either":{"Left":["ast::Error","hir::ClassUnicode","hir::RepetitionRange","ast::RepetitionKind","ast::ClassUnicode","ast::SpecialLiteralKind","ast::WithComments","ast::Concat","ast::ClassBracketed","hir::RepetitionKind","ast::ClassSetRange","ast::GroupKind","ast::Repetition","either::Either","error::Error","ast::Assertion","ast::Position","ast::HexLiteralKind","ast::ErrorKind","hir::HirInfo","ast::Comment","ast::Literal","hir::HirKind","ast::ClassSetBinaryOpKind","ast::Ast","hir::literal::Literal","hir::ErrorKind","ast::ClassSetUnion","hir::interval::IntervalSet","ast::FlagsItem","ast::ClassSetBinaryOp","ast::Span","ast::CaptureName","hir::literal::Literals","<*mut T as std::fmt::Debug>","ast::ClassPerlKind","ast::LiteralKind","hir::Repetition","ast::ClassSetItem","ast::Flags","hir::Anchor","ast::ClassAscii","ast::RepetitionOp","hir::ClassUnicodeRange","ast::Flag","hir::ClassBytesRange","ast::FlagsItemKind","ast::parse::Primitive","ast::ClassUnicodeKind","ast::RepetitionRange","ast::ClassAsciiKind","hir::Literal","ast::Alternation","ast::AssertionKind","ast::ClassPerl","hir::Group","hir::GroupKind","hir::Error","utf8::Utf8Sequence","hir::Hir","hir::WordBoundary","utf8::Utf8Range","ast::Class","hir::Class","hir::ClassBytes","ast::ClassUnicodeOpKind","ast::Group","ast::SetFlags","ast::ClassSet"],"Right":["hir::ClassBytesRange","hir::ClassBytes","ast::ClassSetUnion","ast::CaptureName","ast::ClassSetBinaryOp","hir::Group","hir::HirKind","ast::ClassBracketed","ast::ClassSetRange","hir::Repetition","ast::RepetitionOp","hir::ClassUnicodeRange","ast::RepetitionKind","ast::FlagsItem","hir::GroupKind","ast::ClassPerlKind","either::Either","ast::SpecialLiteralKind","ast::GroupKind","ast::ClassUnicodeKind","ast::HexLiteralKind","ast::Comment","hir::Error","ast::ClassSetItem","error::Error","ast::Group","ast::RepetitionRange","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","ast::parse::Primitive","hir::Anchor","hir::RepetitionKind","ast::LiteralKind","ast::Alternation","ast::Assertion","ast::ClassPerl","ast::SetFlags","hir::literal::Literals","ast::Ast","hir::Literal","hir::RepetitionRange","ast::ClassAscii","hir::literal::Literal","ast::Repetition","hir::WordBoundary","ast::Concat","ast::Position","ast::ClassSetBinaryOpKind","ast::FlagsItemKind","ast::Span","ast::Literal","hir::ErrorKind","hir::HirInfo","utf8::Utf8Range","hir::Class","ast::AssertionKind","ast::ErrorKind","ast::Flag","utf8::Utf8Sequence","ast::ClassUnicode","ast::ClassUnicodeOpKind","ast::Flags","ast::Error","ast::WithComments","ast::ClassSet","hir::interval::IntervalSet","ast::Class","ast::ClassAsciiKind","hir::Hir","hir::ClassUnicode"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.clone();
+<hir::interval::IntervalSet<I> as std::clone::Clone>::clone(p0);
+crate::<hir::interval::IntervalSet<I> as std::clone::Clone>::clone(p0);
+<hir::interval::IntervalSet<I>>::clone(p0);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt":{"I":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"either::Either":{"Left":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"],"Right":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","hir::interval::Interval"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt":{"I":["unicode::ClassQuery","hir::ErrorKind","ast::Alternation","hir::RepetitionRange","ast::ClassUnicodeKind","hir::translate::Translator","hir::Anchor","hir::print::PrinterBuilder","ast::Span","ast::GroupKind","utf8::Utf8Sequence","hir::interval::IntervalSetIter","hir::ClassBytes","hir::ClassBytesIter","hir::print::Writer","hir::literal::Literal","parser::Parser","hir::Literal","ast::print::Writer","hir::HirKind","ast::parse::ParserI","ast::ClassUnicode","ast::Assertion","ast::SpecialLiteralKind","ast::ClassBracketed","utf8::Utf8Range","hir::ClassUnicodeRange","hir::ClassUnicode","ast::FlagsItemKind","ast::ClassSetRange","hir::translate::TranslatorBuilder","ast::Concat","ast::Class","hir::ClassBytesRange","hir::WordBoundary","ast::Error","<&T as std::fmt::Debug>","ast::visitor::ClassFrame","ast::AssertionKind","ast::ErrorKind","hir::GroupKind","ast::RepetitionRange","either::Either","hir::HirInfo","ast::ClassSet","ast::CaptureName","utf8::Utf8Sequences","error::Formatter","ast::ClassSetUnion","ast::RepetitionOp","hir::translate::TranslatorI","unicode::CaseFoldError","ast::Group","hir::RepetitionKind","ast::Comment","ast::visitor::ClassInduct","hir::Class","ast::ClassAsciiKind","error::Error","ast::ClassPerlKind","hir::Error","ast::Flags","ast::parse::Primitive","hir::translate::Flags","hir::Repetition","ast::print::Printer","ast::Position","ast::ClassAscii","hir::Group","ast::Ast","ast::parse::GroupState","ast::parse::ParserBuilder","ast::WithComments","ast::ClassSetItem","ast::Repetition","unicode::UnicodeWordError","ast::ClassSetBinaryOp","hir::literal::Literals","ast::parse::Parser","ast::ClassPerl","<*mut T as std::fmt::Debug>","utf8::ScalarRange","ast::Literal","ast::print::PrinterBuilder","ast::RepetitionKind","hir::print::Printer","ast::HexLiteralKind","ast::Flag","ast::ClassSetBinaryOpKind","hir::Hir","unicode::CanonicalClassQuery","ast::parse::NestLimiter","ast::FlagsItem","ast::LiteralKind","hir::ClassUnicodeIter","ast::ClassUnicodeOpKind","hir::interval::IntervalSet","ast::parse::ClassState","ast::SetFlags","hir::translate::HirFrame","unicode::Error","parser::ParserBuilder"]},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","<&T as std::fmt::Debug>","std::string::String","std::vec::Vec<T, A>","std::sync::Arc<T>","std::ffi::OsString","std::path::PathBuf","std::ffi::CString","std::rc::Rc<T>"]},"ast::parse::ParserI":{"P":["std::ffi::CString","std::path::PathBuf","std::boxed::Box<T, A>","<&mut T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::rc::Rc<T>","std::ffi::OsString","std::vec::Vec<T, A>","std::string::String"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["ast::ClassSetBinaryOpKind","ast::RepetitionKind","ast::Concat","ast::Error","ast::ClassPerl","ast::Assertion","hir::Anchor","hir::Class","ast::ClassBracketed","ast::GroupKind","ast::ClassSetUnion","hir::RepetitionKind","ast::Alternation","ast::SetFlags","hir::Repetition","ast::Flags","ast::HexLiteralKind","hir::Literal","ast::ClassPerlKind","ast::ClassUnicodeOpKind","hir::HirKind","hir::ClassUnicodeRange","ast::Flag","ast::CaptureName","ast::LiteralKind","hir::Error","ast::Literal","hir::Hir","hir::interval::IntervalSet","utf8::Utf8Range","hir::RepetitionRange","ast::Ast","ast::SpecialLiteralKind","hir::ClassBytes","ast::ClassUnicode","error::Error","ast::ClassSetBinaryOp","ast::Class","ast::ErrorKind","ast::FlagsItemKind","ast::Span","ast::parse::Primitive","hir::ClassUnicode","ast::Comment","ast::RepetitionOp","ast::ClassAscii","ast::ClassSet","hir::GroupKind","<*mut T as std::fmt::Debug>","hir::ClassBytesRange","hir::WordBoundary","utf8::Utf8Sequence","hir::Group","ast::WithComments","ast::Repetition","ast::RepetitionRange","hir::ErrorKind","ast::ClassSetItem","ast::ClassAsciiKind","hir::HirInfo","ast::ClassSetRange","ast::AssertionKind","hir::literal::Literals","ast::Position","ast::FlagsItem","hir::literal::Literal","ast::Group","ast::ClassUnicodeKind","either::Either"],"Right":["ast::ClassSet","ast::Group","ast::ClassSetBinaryOp","utf8::Utf8Sequence","ast::FlagsItem","hir::Hir","ast::Span","ast::ClassUnicodeKind","hir::literal::Literal","hir::WordBoundary","ast::Literal","ast::ClassPerlKind","either::Either","hir::Group","hir::ClassBytesRange","hir::Anchor","hir::interval::IntervalSet","hir::ClassBytes","ast::LiteralKind","ast::AssertionKind","ast::Ast","hir::Error","ast::RepetitionRange","ast::Concat","ast::Repetition","ast::Assertion","hir::HirInfo","ast::ClassPerl","hir::literal::Literals","ast::ClassAsciiKind","ast::SpecialLiteralKind","hir::Repetition","ast::ClassAscii","hir::Literal","ast::Flag","ast::RepetitionOp","ast::Error","ast::ClassSetRange","ast::ClassUnicode","ast::HexLiteralKind","utf8::Utf8Range","error::Error","hir::HirKind","ast::GroupKind","ast::Position","ast::ErrorKind","ast::ClassUnicodeOpKind","ast::SetFlags","ast::ClassSetBinaryOpKind","ast::RepetitionKind","hir::RepetitionRange","ast::Flags","hir::GroupKind","ast::ClassSetUnion","hir::ErrorKind","ast::Class","ast::FlagsItemKind","hir::ClassUnicodeRange","ast::WithComments","hir::RepetitionKind","ast::CaptureName","ast::Alternation","hir::Class","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::ClassSetItem","ast::ClassBracketed","ast::Comment","ast::parse::Primitive","hir::ClassUnicode"]},"error::Formatter":{"E":["ast::ErrorKind","error::Formatter","ast::Error","<&T as std::fmt::Display>","hir::ErrorKind","ast::Ast","hir::Error","unicode::CaseFoldError","unicode::UnicodeWordError","hir::Hir","error::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["ast::Span","ast::WithComments","hir::translate::Flags","hir::translate::TranslatorBuilder","ast::ClassBracketed","ast::ErrorKind","ast::Concat","hir::HirKind","hir::literal::Literals","hir::GroupKind","parser::Parser","ast::ClassAsciiKind","hir::Literal","ast::ClassPerl","ast::Repetition","ast::ClassSetUnion","ast::visitor::ClassInduct","hir::Hir","hir::ClassBytesIter","ast::RepetitionRange","ast::visitor::ClassFrame","ast::Flag","ast::Comment","ast::parse::NestLimiter","hir::ClassBytesRange","utf8::Utf8Range","ast::parse::GroupState","utf8::ScalarRange","ast::SpecialLiteralKind","hir::translate::HirFrame","unicode::UnicodeWordError","hir::ClassBytes","hir::Repetition","ast::parse::ParserI","ast::Group","hir::interval::IntervalSetIter","ast::CaptureName","hir::ClassUnicode","ast::parse::Parser","ast::ClassSetItem","unicode::ClassQuery","unicode::CanonicalClassQuery","ast::ClassUnicodeOpKind","either::Either","ast::FlagsItemKind","unicode::CaseFoldError","ast::ClassSetBinaryOpKind","ast::ClassSetBinaryOp","hir::Class","ast::parse::ClassState","ast::print::PrinterBuilder","unicode::Error","hir::Anchor","ast::Assertion","hir::RepetitionRange","ast::print::Printer","hir::RepetitionKind","hir::Group","ast::Flags","ast::Error","ast::RepetitionKind","ast::AssertionKind","hir::literal::Literal","utf8::Utf8Sequences","<*const T as std::fmt::Debug>","ast::ClassUnicodeKind","hir::translate::TranslatorI","ast::parse::ParserBuilder","hir::ClassUnicodeIter","hir::WordBoundary","ast::SetFlags","ast::GroupKind","ast::Ast","ast::parse::Primitive","error::Formatter","utf8::Utf8Sequence","ast::ClassSet","ast::Class","ast::FlagsItem","hir::print::PrinterBuilder","ast::ClassPerlKind","ast::RepetitionOp","ast::print::Writer","hir::translate::Translator","hir::HirInfo","parser::ParserBuilder","ast::ClassSetRange","error::Error","hir::ErrorKind","ast::Literal","hir::print::Writer","hir::interval::IntervalSet","ast::Position","ast::ClassAscii","ast::HexLiteralKind","ast::ClassUnicode","hir::print::Printer","hir::Error","ast::Alternation","ast::LiteralKind","hir::ClassUnicodeRange"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::interval::IntervalSet<I> as std::fmt::Debug>::fmt(p0, p1);
+<hir::interval::IntervalSet<I>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq":{"I":["std::cmp::Eq","std::marker::Sized"]},"either::Either":{"Left":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"],"Right":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"hir::interval::IntervalSet":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","hir::interval::Interval"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq":{"I":["ast::ClassSetItem","ast::ClassSetBinaryOp","ast::Repetition","ast::GroupKind","hir::ClassBytesRange","ast::Flags","hir::Error","hir::WordBoundary","ast::Flag","hir::ClassUnicode","either::Either","ast::ClassPerl","utf8::Utf8Range","hir::ClassBytes","ast::ErrorKind","hir::Group","hir::Class","ast::ClassUnicodeKind","hir::Anchor","error::Error","hir::literal::Literals","hir::Hir","ast::ClassUnicode","ast::Concat","ast::Comment","hir::RepetitionRange","ast::parse::Primitive","ast::FlagsItem","ast::ClassAsciiKind","unicode::CanonicalClassQuery","ast::ClassSet","ast::ClassPerlKind","ast::ClassAscii","ast::Alternation","ast::HexLiteralKind","ast::Position","ast::Assertion","ast::Error","ast::RepetitionKind","ast::Literal","hir::literal::Literal","ast::ClassSetBinaryOpKind","ast::LiteralKind","ast::ClassSetRange","ast::Span","hir::Repetition","hir::Literal","hir::ErrorKind","ast::WithComments","ast::Class","ast::ClassSetUnion","hir::GroupKind","ast::FlagsItemKind","std::cmp::impls::<impl std::cmp::Eq for &A>","hir::HirKind","hir::RepetitionKind","ast::Ast","utf8::Utf8Sequence","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","ast::SpecialLiteralKind","hir::HirInfo","hir::ClassUnicodeRange","hir::interval::IntervalSet","ast::ClassBracketed","ast::RepetitionRange","ast::AssertionKind","ast::SetFlags","ast::Group","ast::RepetitionOp","ast::ClassUnicodeOpKind","ast::CaptureName"]},"either::Either":{"Left":["hir::interval::IntervalSet","ast::ClassPerl","hir::GroupKind","hir::Class","ast::ClassSetBinaryOp","ast::ClassPerlKind","ast::ClassBracketed","ast::Assertion","ast::Flags","ast::FlagsItem","<*const T as std::fmt::Debug>","hir::ClassUnicodeRange","ast::Group","ast::parse::Primitive","ast::Ast","hir::HirInfo","ast::ClassSetRange","ast::ClassSetBinaryOpKind","ast::Alternation","ast::ClassSetUnion","ast::Repetition","ast::ClassSet","hir::literal::Literal","ast::RepetitionRange","ast::RepetitionOp","ast::ClassUnicodeOpKind","hir::Repetition","hir::RepetitionKind","hir::Anchor","hir::ClassBytes","ast::AssertionKind","hir::ClassBytesRange","ast::SpecialLiteralKind","ast::Class","utf8::Utf8Range","ast::Comment","hir::Group","ast::CaptureName","hir::ErrorKind","ast::Literal","ast::Position","ast::HexLiteralKind","ast::ErrorKind","ast::ClassSetItem","hir::RepetitionRange","ast::FlagsItemKind","hir::Hir","ast::RepetitionKind","hir::WordBoundary","ast::WithComments","ast::Flag","ast::Span","hir::literal::Literals","ast::GroupKind","ast::Error","ast::ClassAsciiKind","ast::ClassAscii","hir::Error","ast::ClassUnicode","ast::Concat","ast::SetFlags","hir::HirKind","either::Either","ast::ClassUnicodeKind","ast::LiteralKind","hir::ClassUnicode","error::Error","utf8::Utf8Sequence","hir::Literal"],"Right":["ast::RepetitionOp","hir::literal::Literals","ast::FlagsItem","hir::WordBoundary","hir::literal::Literal","either::Either","hir::HirInfo","hir::ErrorKind","hir::ClassBytes","hir::GroupKind","hir::ClassBytesRange","ast::AssertionKind","ast::ClassUnicodeOpKind","ast::WithComments","ast::Span","ast::Ast","ast::ErrorKind","ast::Group","ast::Class","error::Error","ast::ClassSetItem","ast::Assertion","hir::HirKind","hir::Anchor","hir::interval::IntervalSet","ast::Error","ast::ClassAscii","hir::RepetitionKind","ast::Alternation","ast::Flag","ast::ClassSetBinaryOp","ast::Concat","ast::ClassSetRange","hir::ClassUnicodeRange","ast::Flags","hir::Hir","ast::SetFlags","ast::FlagsItemKind","hir::Class","ast::SpecialLiteralKind","ast::ClassSetBinaryOpKind","utf8::Utf8Sequence","ast::parse::Primitive","ast::Repetition","ast::ClassBracketed","hir::Error","ast::ClassUnicodeKind","ast::ClassSet","ast::RepetitionKind","utf8::Utf8Range","hir::Group","hir::RepetitionRange","ast::RepetitionRange","ast::Position","hir::ClassUnicode","ast::GroupKind","ast::ClassPerlKind","ast::Comment","hir::Literal","ast::LiteralKind","ast::CaptureName","ast::ClassSetUnion","ast::ClassPerl","ast::ClassAsciiKind","ast::Literal","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::HexLiteralKind","ast::ClassUnicode","hir::Repetition"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.assert_receiver_is_total_eq();
+<hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::interval::IntervalSet<I> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::interval::IntervalSet<I>>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":{"I":["std::cmp::PartialEq","std::marker::Sized"]},"either::Either":{"Left":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"],"Right":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"hir::interval::IntervalSet":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","hir::interval::Interval","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq":{"I":["ast::ClassUnicodeOpKind","ast::Position","ast::Repetition","unicode::CanonicalClassQuery","ast::Flag","ast::ClassAsciiKind","ast::ClassAscii","ast::Ast","hir::Hir","ast::RepetitionRange","hir::ClassBytes","ast::Alternation","hir::Literal","ast::ClassSetBinaryOpKind","hir::literal::Literals","hir::Repetition","ast::ClassSet","ast::ClassPerlKind","hir::RepetitionKind","hir::RepetitionRange","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::ClassUnicodeKind","ast::ClassUnicode","ast::RepetitionOp","hir::literal::Literal","ast::SetFlags","ast::Concat","ast::RepetitionKind","ast::Flags","ast::CaptureName","ast::ClassSetRange","ast::Comment","ast::ClassSetUnion","hir::interval::IntervalSet","ast::LiteralKind","ast::ClassPerl","hir::Class","hir::ErrorKind","hir::ClassUnicodeRange","ast::ClassBracketed","ast::Literal","hir::ClassUnicode","ast::SpecialLiteralKind","ast::ClassSetItem","hir::Group","hir::GroupKind","ast::FlagsItemKind","error::Error","ast::Class","ast::Error","ast::parse::Primitive","utf8::Utf8Range","ast::ErrorKind","hir::ClassBytesRange","ast::FlagsItem","ast::GroupKind","ast::HexLiteralKind","ast::Group","ast::ClassSetBinaryOp","utf8::Utf8Sequence","hir::Anchor","ast::WithComments","hir::HirKind","hir::Error","hir::HirInfo","ast::Assertion","either::Either","ast::AssertionKind","ast::Span","hir::WordBoundary"]},"either::Either":{"Left":["ast::parse::Primitive","ast::Assertion","ast::ClassSetItem","ast::ClassBracketed","ast::FlagsItem","hir::WordBoundary","hir::RepetitionKind","hir::literal::Literals","ast::ClassSetRange","<*const T as std::fmt::Debug>","ast::Alternation","hir::ClassBytesRange","ast::LiteralKind","ast::Position","utf8::Utf8Range","hir::HirInfo","ast::CaptureName","hir::Hir","ast::ClassSetBinaryOpKind","ast::FlagsItemKind","hir::Anchor","hir::Class","ast::Repetition","hir::HirKind","ast::Group","hir::Group","ast::ErrorKind","ast::RepetitionOp","ast::ClassSet","hir::GroupKind","ast::ClassSetUnion","ast::RepetitionKind","ast::ClassPerlKind","ast::ClassUnicodeOpKind","ast::ClassPerl","ast::Comment","ast::Concat","ast::GroupKind","ast::ClassUnicodeKind","ast::HexLiteralKind","hir::RepetitionRange","ast::Ast","ast::AssertionKind","ast::Literal","hir::ClassUnicode","ast::ClassAscii","ast::WithComments","ast::ClassUnicode","hir::ClassUnicodeRange","ast::ClassSetBinaryOp","ast::RepetitionRange","utf8::Utf8Sequence","either::Either","error::Error","hir::ErrorKind","hir::Error","hir::interval::IntervalSet","hir::ClassBytes","ast::Error","hir::Literal","ast::ClassAsciiKind","hir::Repetition","ast::Flag","ast::Class","ast::SetFlags","hir::literal::Literal","ast::SpecialLiteralKind","ast::Span","ast::Flags"],"Right":["ast::Group","ast::Flags","ast::parse::Primitive","hir::Group","ast::Literal","hir::WordBoundary","hir::ClassUnicodeRange","ast::ClassSetBinaryOpKind","ast::RepetitionRange","ast::AssertionKind","hir::literal::Literals","hir::ClassBytes","ast::SetFlags","ast::ClassSetItem","ast::ClassUnicodeKind","ast::Repetition","ast::ClassUnicodeOpKind","ast::Ast","ast::HexLiteralKind","ast::ClassSetUnion","either::Either","ast::FlagsItem","ast::LiteralKind","ast::WithComments","ast::ClassUnicode","ast::RepetitionOp","ast::Position","ast::SpecialLiteralKind","ast::ClassAscii","hir::ClassUnicode","hir::interval::IntervalSet","ast::ClassSetBinaryOp","hir::literal::Literal","ast::Span","utf8::Utf8Range","hir::Anchor","ast::ClassBracketed","ast::ClassSet","hir::ErrorKind","ast::Error","ast::Alternation","hir::HirInfo","ast::RepetitionKind","ast::FlagsItemKind","ast::Class","ast::GroupKind","ast::ClassPerlKind","hir::Error","ast::ClassPerl","hir::RepetitionRange","error::Error","hir::ClassBytesRange","ast::CaptureName","ast::ErrorKind","utf8::Utf8Sequence","hir::HirKind","hir::Class","ast::ClassSetRange","<*mut T as std::fmt::Debug>","hir::RepetitionKind","ast::Assertion","hir::Repetition","ast::ClassAsciiKind","hir::GroupKind","hir::Literal","ast::Concat","ast::Flag","hir::Hir","ast::Comment"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.eq(p1);
+<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::interval::IntervalSet<I> as std::cmp::PartialEq>::eq(p0, p1);
+<hir::interval::IntervalSet<I>>::eq(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::borrow::Borrow","std::marker::Sized","std::fmt::Debug"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::borrow::Borrow","std::marker::Sized","std::clone::Clone"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"],"Right":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["hir::interval::Interval","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"hir::interval::IntervalSet::<I>::new":{"I":["std::marker::Sized","hir::interval::Interval"],"T":["std::iter::IntoIterator","std::marker::Sized"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["hir::interval::IntervalSetIter","utf8::Utf8Sequences","hir::ClassBytesIter","<&mut I as std::iter::Iterator>","hir::ClassUnicodeIter"]},"ast::parse::NestLimiter":{"P":["std::rc::Rc<T>","std::string::String","std::ffi::CString","std::vec::Vec<T, A>","std::ffi::OsString","<&T as std::borrow::Borrow<T>>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::path::PathBuf"]},"ast::parse::ParserI":{"P":["std::string::String","std::path::PathBuf","std::ffi::OsString","std::vec::Vec<T, A>","std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","<&T as std::fmt::Debug>"]},"ast::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"either::Either":{"Left":["error::Error","hir::Group","ast::RepetitionRange","hir::ClassBytes","ast::CaptureName","ast::ClassUnicodeKind","hir::Error","ast::Comment","ast::Flag","ast::FlagsItem","ast::WithComments","ast::SetFlags","ast::ClassAsciiKind","hir::Repetition","hir::literal::Literal","ast::Position","ast::Error","hir::literal::Literals","ast::LiteralKind","hir::Anchor","ast::ClassBracketed","ast::Literal","ast::ErrorKind","ast::ClassUnicodeOpKind","ast::ClassSetBinaryOpKind","hir::ClassBytesRange","hir::HirInfo","ast::Flags","hir::HirKind","ast::ClassSet","utf8::Utf8Sequence","utf8::Utf8Range","ast::ClassSetItem","ast::SpecialLiteralKind","ast::ClassPerlKind","ast::Span","ast::ClassSetRange","either::Either","ast::Alternation","ast::RepetitionKind","ast::RepetitionOp","hir::Hir","ast::Assertion","ast::Repetition","ast::ClassSetUnion","ast::parse::Primitive","std::clone::impls::<impl std::clone::Clone for *const T>","ast::Group","hir::Class","ast::HexLiteralKind","ast::ClassSetBinaryOp","hir::WordBoundary","ast::FlagsItemKind","hir::ClassUnicode","hir::RepetitionRange","hir::ErrorKind","ast::AssertionKind","ast::ClassUnicode","ast::ClassAscii","ast::Concat","ast::Ast","ast::Class","hir::GroupKind","ast::ClassPerl","ast::GroupKind","hir::interval::IntervalSet","hir::Literal","hir::ClassUnicodeRange","hir::RepetitionKind"],"Right":["ast::Span","hir::literal::Literals","hir::Literal","error::Error","ast::Assertion","hir::HirInfo","ast::Alternation","ast::Flag","ast::ClassSetRange","ast::ClassPerlKind","ast::ClassUnicode","hir::ErrorKind","ast::ClassSet","hir::ClassBytes","ast::ClassAsciiKind","ast::Flags","hir::Hir","ast::FlagsItem","ast::Concat","ast::ClassSetBinaryOpKind","hir::RepetitionRange","ast::ClassSetUnion","hir::Repetition","ast::Class","hir::Anchor","hir::ClassUnicodeRange","ast::parse::Primitive","utf8::Utf8Range","ast::ClassSetBinaryOp","ast::HexLiteralKind","ast::FlagsItemKind","ast::Repetition","ast::RepetitionRange","hir::Group","either::Either","ast::ErrorKind","ast::GroupKind","ast::ClassUnicodeKind","ast::SetFlags","ast::Literal","hir::ClassUnicode","ast::ClassSetItem","ast::Position","hir::HirKind","std::clone::impls::<impl std::clone::Clone for *mut T>","hir::Class","ast::AssertionKind","hir::literal::Literal","ast::ClassPerl","hir::RepetitionKind","hir::interval::IntervalSet","ast::ClassAscii","ast::RepetitionOp","ast::CaptureName","ast::Group","ast::SpecialLiteralKind","ast::LiteralKind","ast::RepetitionKind","hir::Error","ast::Error","utf8::Utf8Sequence","hir::GroupKind","hir::ClassBytesRange","hir::WordBoundary","ast::Ast","ast::ClassBracketed","ast::ClassUnicodeOpKind","ast::WithComments","ast::Comment"]},"error::Formatter":{"E":["<&T as std::fmt::Debug>","unicode::UnicodeWordError","error::Formatter","unicode::CaseFoldError","ast::Error","hir::Hir","hir::ErrorKind","ast::Ast","ast::ErrorKind","error::Error","hir::Error"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSet::<I>::new":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"],"T":["<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>","<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>"]},"hir::interval::IntervalSetIter":{"I":["hir::Group","ast::GroupKind","ast::SpecialLiteralKind","hir::ClassBytesIter","error::Formatter","hir::ErrorKind","ast::parse::Parser","hir::print::Printer","ast::visitor::ClassFrame","hir::interval::IntervalSet","hir::Class","ast::Alternation","ast::Flag","utf8::Utf8Sequence","hir::ClassBytes","unicode::Error","hir::Repetition","ast::Span","<*const T as std::fmt::Debug>","hir::translate::Translator","utf8::Utf8Range","ast::ClassSetBinaryOpKind","hir::HirInfo","ast::ClassAscii","hir::ClassUnicodeRange","ast::parse::Primitive","ast::parse::ParserI","hir::literal::Literals","hir::translate::TranslatorBuilder","ast::ClassSetItem","ast::RepetitionOp","ast::ClassUnicode","hir::interval::IntervalSetIter","ast::print::Writer","ast::parse::NestLimiter","ast::ErrorKind","ast::RepetitionRange","ast::Literal","hir::print::PrinterBuilder","ast::Flags","hir::WordBoundary","ast::ClassSet","error::Error","ast::FlagsItem","ast::print::Printer","utf8::Utf8Sequences","ast::Concat","parser::Parser","ast::RepetitionKind","ast::LiteralKind","ast::Position","hir::GroupKind","ast::ClassSetBinaryOp","hir::Hir","hir::ClassUnicodeIter","ast::print::PrinterBuilder","ast::ClassSetRange","hir::Error","ast::ClassUnicodeKind","hir::translate::Flags","ast::Error","ast::Repetition","ast::ClassPerl","ast::HexLiteralKind","ast::ClassBracketed","ast::Ast","hir::print::Writer","hir::Literal","either::Either","unicode::ClassQuery","unicode::CanonicalClassQuery","hir::translate::HirFrame","hir::HirKind","hir::RepetitionKind","hir::translate::TranslatorI","ast::CaptureName","ast::ClassUnicodeOpKind","utf8::ScalarRange","ast::visitor::ClassInduct","ast::Group","ast::FlagsItemKind","hir::ClassBytesRange","hir::RepetitionRange","hir::Anchor","ast::ClassPerlKind","ast::parse::GroupState","parser::ParserBuilder","ast::SetFlags","hir::ClassUnicode","ast::ClassSetUnion","ast::Assertion","unicode::UnicodeWordError","ast::Comment","ast::parse::ClassState","hir::literal::Literal","ast::Class","ast::parse::ParserBuilder","ast::ClassAsciiKind","unicode::CaseFoldError","ast::AssertionKind","ast::WithComments"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+hir::interval::IntervalSet::<I>::new(p0);
+crate::hir::interval::IntervalSet::<I>::new(p0);
+<hir::interval::IntervalSet<I>>::new(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::push
deps:{"hir::interval::IntervalSet::<I>::push":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::push":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.push(p1);
+hir::interval::IntervalSet::<I>::push(p0, p1);
+crate::hir::interval::IntervalSet::<I>::push(p0, p1);
+<hir::interval::IntervalSet<I>>::push(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::iter
deps:{"hir::interval::IntervalSet::<I>::iter":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::iter":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.iter();
+hir::interval::IntervalSet::<I>::iter(p0);
+crate::hir::interval::IntervalSet::<I>::iter(p0);
+<hir::interval::IntervalSet<I>>::iter(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::intervals
deps:{"hir::interval::IntervalSet::<I>::intervals":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::intervals":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.intervals();
+hir::interval::IntervalSet::<I>::intervals(p0);
+crate::hir::interval::IntervalSet::<I>::intervals(p0);
+<hir::interval::IntervalSet<I>>::intervals(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::case_fold_simple
deps:{"hir::interval::IntervalSet::<I>::case_fold_simple":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::case_fold_simple":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.case_fold_simple();
+hir::interval::IntervalSet::<I>::case_fold_simple(p0);
+crate::hir::interval::IntervalSet::<I>::case_fold_simple(p0);
+<hir::interval::IntervalSet<I>>::case_fold_simple(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::union
deps:{"hir::interval::IntervalSet::<I>::union":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::union":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.union(p1);
+hir::interval::IntervalSet::<I>::union(p0, p1);
+crate::hir::interval::IntervalSet::<I>::union(p0, p1);
+<hir::interval::IntervalSet<I>>::union(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::intersect
deps:{"hir::interval::IntervalSet::<I>::intersect":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::intersect":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.intersect(p1);
+hir::interval::IntervalSet::<I>::intersect(p0, p1);
+crate::hir::interval::IntervalSet::<I>::intersect(p0, p1);
+<hir::interval::IntervalSet<I>>::intersect(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::difference
deps:{"hir::interval::IntervalSet::<I>::difference":{"I":["hir::interval::Interval","std::marker::Sized"]}}
candidates:{"hir::interval::IntervalSet::<I>::difference":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.difference(p1);
+hir::interval::IntervalSet::<I>::difference(p0, p1);
+crate::hir::interval::IntervalSet::<I>::difference(p0, p1);
+<hir::interval::IntervalSet<I>>::difference(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::symmetric_difference
deps:{"hir::interval::IntervalSet::<I>::symmetric_difference":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::symmetric_difference":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.symmetric_difference(p1);
+hir::interval::IntervalSet::<I>::symmetric_difference(p0, p1);
+crate::hir::interval::IntervalSet::<I>::symmetric_difference(p0, p1);
+<hir::interval::IntervalSet<I>>::symmetric_difference(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::negate
deps:{"hir::interval::IntervalSet::<I>::negate":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::negate":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.negate();
+hir::interval::IntervalSet::<I>::negate(p0);
+crate::hir::interval::IntervalSet::<I>::negate(p0);
+<hir::interval::IntervalSet<I>>::negate(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::canonicalize
deps:{"hir::interval::IntervalSet::<I>::canonicalize":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::canonicalize":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.canonicalize();
+hir::interval::IntervalSet::<I>::canonicalize(p0);
+crate::hir::interval::IntervalSet::<I>::canonicalize(p0);
+<hir::interval::IntervalSet<I>>::canonicalize(p0);
-----------------
regex-syntax/src/hir/interval.rs hir::interval::IntervalSet::<I>::is_canonical
deps:{"hir::interval::IntervalSet::<I>::is_canonical":{"I":["std::marker::Sized","hir::interval::Interval"]}}
candidates:{"hir::interval::IntervalSet::<I>::is_canonical":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSet<I>
+p0.is_canonical();
+hir::interval::IntervalSet::<I>::is_canonical(p0);
+crate::hir::interval::IntervalSet::<I>::is_canonical(p0);
+<hir::interval::IntervalSet<I>>::is_canonical(p0);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt":{"I":["std::fmt::Debug","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::borrow::Borrow","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::marker::Sized","std::fmt::Write"]},"either::Either":{"Left":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"],"Right":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::cmp::Eq","hir::interval::Interval","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt":{"I":["error::Error","ast::Ast","ast::RepetitionRange","hir::ErrorKind","ast::ClassAscii","hir::GroupKind","hir::print::Writer","ast::ClassUnicodeOpKind","hir::ClassUnicodeRange","hir::RepetitionRange","ast::parse::Primitive","ast::parse::Parser","ast::RepetitionKind","parser::Parser","unicode::CaseFoldError","ast::Repetition","hir::literal::Literal","hir::translate::TranslatorBuilder","ast::Error","ast::parse::ParserI","hir::ClassBytesIter","hir::print::PrinterBuilder","ast::ClassSetItem","ast::Class","ast::ClassPerlKind","<&T as std::fmt::Debug>","ast::Flag","hir::interval::IntervalSetIter","hir::print::Printer","hir::WordBoundary","ast::parse::NestLimiter","ast::ClassSet","ast::ClassSetRange","hir::Literal","hir::Repetition","hir::ClassBytes","ast::ClassPerl","ast::GroupKind","ast::ClassAsciiKind","ast::visitor::ClassInduct","hir::ClassUnicode","ast::FlagsItemKind","hir::RepetitionKind","ast::Assertion","ast::ClassBracketed","ast::HexLiteralKind","ast::visitor::ClassFrame","ast::Group","ast::Concat","ast::WithComments","ast::parse::GroupState","ast::Comment","hir::translate::Flags","hir::ClassUnicodeIter","ast::Span","hir::Group","ast::LiteralKind","utf8::ScalarRange","unicode::CanonicalClassQuery","ast::FlagsItem","ast::ClassSetBinaryOp","ast::ClassSetUnion","ast::SpecialLiteralKind","ast::print::Printer","ast::parse::ClassState","hir::ClassBytesRange","ast::ClassUnicode","ast::ClassSetBinaryOpKind","<&mut T as std::fmt::Debug>","ast::ErrorKind","utf8::Utf8Sequence","hir::interval::IntervalSet","ast::print::PrinterBuilder","hir::Class","hir::translate::Translator","error::Formatter","unicode::UnicodeWordError","either::Either","parser::ParserBuilder","unicode::Error","ast::SetFlags","ast::parse::ParserBuilder","hir::literal::Literals","hir::Hir","ast::RepetitionOp","ast::Position","ast::ClassUnicodeKind","ast::print::Writer","ast::AssertionKind","ast::CaptureName","hir::HirKind","hir::translate::HirFrame","ast::Alternation","unicode::ClassQuery","hir::HirInfo","utf8::Utf8Range","hir::translate::TranslatorI","utf8::Utf8Sequences","hir::Anchor","ast::Flags","ast::Literal","hir::Error"]},"ast::parse::NestLimiter":{"P":["std::vec::Vec<T, A>","std::rc::Rc<T>","<&mut T as std::fmt::Debug>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::ffi::CString","std::ffi::OsString","std::path::PathBuf","std::string::String"]},"ast::parse::ParserI":{"P":["std::ffi::OsString","<&T as std::fmt::Debug>","std::sync::Arc<T>","std::vec::Vec<T, A>","std::string::String","std::rc::Rc<T>","std::boxed::Box<T, A>","std::path::PathBuf","std::ffi::CString"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::GroupKind","hir::ClassBytesRange","ast::Concat","hir::literal::Literal","ast::ClassPerlKind","hir::HirKind","utf8::Utf8Sequence","hir::WordBoundary","ast::Position","<*const T as std::fmt::Debug>","ast::RepetitionRange","ast::ClassAscii","ast::RepetitionKind","ast::Ast","hir::Hir","utf8::Utf8Range","ast::ClassSetBinaryOpKind","ast::parse::Primitive","hir::Anchor","error::Error","ast::Literal","ast::WithComments","hir::ErrorKind","ast::ClassAsciiKind","ast::Repetition","ast::CaptureName","ast::Class","ast::ClassSetUnion","ast::AssertionKind","ast::Alternation","ast::Flag","ast::FlagsItem","hir::Group","ast::ClassSetItem","ast::Flags","hir::Class","either::Either","ast::Span","hir::ClassUnicode","hir::GroupKind","hir::ClassBytes","ast::ClassSetRange","ast::Group","hir::Repetition","ast::ClassSetBinaryOp","ast::ClassUnicodeKind","hir::Literal","hir::HirInfo","ast::ClassSet","ast::SetFlags","ast::ClassUnicode","ast::ClassPerl","ast::ClassUnicodeOpKind","hir::ClassUnicodeRange","hir::Error","ast::LiteralKind","ast::RepetitionOp","ast::SpecialLiteralKind","ast::Assertion","hir::RepetitionRange","hir::RepetitionKind","ast::FlagsItemKind","hir::interval::IntervalSet","ast::HexLiteralKind","ast::Error","ast::Comment","ast::ClassBracketed","hir::literal::Literals","ast::ErrorKind"],"Right":["ast::SetFlags","hir::GroupKind","ast::GroupKind","ast::CaptureName","ast::Class","either::Either","ast::HexLiteralKind","ast::WithComments","ast::Ast","ast::FlagsItemKind","hir::Anchor","ast::ClassBracketed","hir::literal::Literal","ast::ClassSet","ast::Comment","hir::Hir","ast::ClassUnicodeKind","hir::Group","ast::FlagsItem","hir::interval::IntervalSet","hir::ClassBytesRange","ast::RepetitionKind","ast::ClassAsciiKind","ast::Position","hir::RepetitionKind","ast::Literal","error::Error","hir::HirInfo","ast::Concat","ast::parse::Primitive","ast::AssertionKind","ast::Repetition","ast::ClassSetBinaryOpKind","ast::ClassUnicodeOpKind","ast::RepetitionOp","hir::ClassUnicode","hir::Literal","ast::LiteralKind","hir::Class","ast::Error","hir::Repetition","utf8::Utf8Sequence","hir::HirKind","ast::Span","ast::ClassSetUnion","hir::ErrorKind","ast::ClassSetBinaryOp","ast::Flags","hir::ClassUnicodeRange","ast::Alternation","ast::Flag","ast::ClassUnicode","ast::ClassSetItem","ast::ClassPerlKind","ast::ClassPerl","hir::WordBoundary","hir::literal::Literals","<*mut T as std::fmt::Debug>","ast::ClassSetRange","ast::Group","hir::ClassBytes","ast::Assertion","utf8::Utf8Range","ast::RepetitionRange","ast::SpecialLiteralKind","hir::Error","hir::RepetitionRange","ast::ClassAscii","ast::ErrorKind"]},"error::Formatter":{"E":["ast::Error","ast::Ast","hir::Error","error::Error","hir::Hir","error::Formatter","<&mut T as std::fmt::Display>","unicode::UnicodeWordError","unicode::CaseFoldError","ast::ErrorKind","hir::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassBytesRange","hir::ClassUnicodeRange"]},"hir::interval::IntervalSetIter":{"I":["utf8::Utf8Sequences","ast::print::PrinterBuilder","ast::ClassUnicodeKind","hir::translate::TranslatorBuilder","ast::ClassUnicodeOpKind","ast::RepetitionKind","hir::Class","hir::ClassBytes","ast::FlagsItemKind","ast::FlagsItem","ast::print::Writer","ast::parse::ClassState","hir::ErrorKind","hir::ClassBytesRange","hir::HirKind","<*const T as std::fmt::Debug>","hir::print::Writer","ast::ClassPerl","ast::Flag","hir::ClassUnicode","unicode::ClassQuery","hir::ClassUnicodeRange","ast::Alternation","ast::LiteralKind","ast::parse::Parser","ast::parse::Primitive","ast::Comment","ast::ClassAscii","ast::ClassBracketed","ast::ClassSetItem","ast::Class","hir::print::PrinterBuilder","error::Error","hir::RepetitionKind","ast::ErrorKind","ast::parse::ParserI","unicode::CaseFoldError","ast::HexLiteralKind","ast::Flags","hir::translate::HirFrame","ast::RepetitionRange","ast::parse::GroupState","hir::translate::Translator","ast::visitor::ClassInduct","parser::Parser","hir::Literal","unicode::Error","ast::Repetition","hir::interval::IntervalSetIter","hir::print::Printer","hir::RepetitionRange","ast::ClassSetBinaryOpKind","ast::SetFlags","ast::parse::ParserBuilder","utf8::ScalarRange","ast::ClassUnicode","ast::ClassPerlKind","unicode::CanonicalClassQuery","ast::RepetitionOp","ast::WithComments","hir::Hir","ast::Position","hir::Repetition","ast::ClassSetUnion","ast::Literal","ast::ClassSetRange","ast::print::Printer","hir::ClassUnicodeIter","ast::Group","ast::Span","hir::literal::Literal","hir::translate::Flags","ast::Ast","hir::HirInfo","hir::literal::Literals","ast::visitor::ClassFrame","error::Formatter","either::Either","ast::SpecialLiteralKind","ast::ClassAsciiKind","hir::Error","hir::Anchor","ast::GroupKind","ast::CaptureName","hir::translate::TranslatorI","ast::Concat","hir::Group","ast::AssertionKind","ast::ClassSet","ast::ClassSetBinaryOp","utf8::Utf8Range","ast::parse::NestLimiter","ast::Error","parser::ParserBuilder","unicode::UnicodeWordError","utf8::Utf8Sequence","hir::ClassBytesIter","hir::WordBoundary","ast::Assertion","hir::interval::IntervalSet","hir::GroupKind"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSetIter<'a, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::interval::IntervalSetIter<'a, I> as std::fmt::Debug>::fmt(p0, p1);
+<hir::interval::IntervalSetIter<'a, I>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/interval.rs <hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next
'a
deps:{"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":{"I":["std::marker::Sized"]}}
candidates:{"<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next":{"I":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::interval::IntervalSetIter<'a, I>
+p0.next();
+<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next(p0);
+crate::<hir::interval::IntervalSetIter<'a, I> as std::iter::Iterator>::next(p0);
+<hir::interval::IntervalSetIter<'a, I>>::next(p0);
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::min_value
deps:{}
candidates:{}
+<u8 as hir::interval::Bound>::min_value();
+crate::<u8 as hir::interval::Bound>::min_value();
+<u8>::min_value();
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::max_value
deps:{}
candidates:{}
+<u8 as hir::interval::Bound>::max_value();
+crate::<u8 as hir::interval::Bound>::max_value();
+<u8>::max_value();
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::as_u32
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_u32();
+<u8 as hir::interval::Bound>::as_u32(p0);
+crate::<u8 as hir::interval::Bound>::as_u32(p0);
+<u8>::as_u32(p0);
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::increment
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.increment();
+<u8 as hir::interval::Bound>::increment(p0);
+crate::<u8 as hir::interval::Bound>::increment(p0);
+<u8>::increment(p0);
-----------------
regex-syntax/src/hir/interval.rs <u8 as hir::interval::Bound>::decrement
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.decrement();
+<u8 as hir::interval::Bound>::decrement(p0);
+crate::<u8 as hir::interval::Bound>::decrement(p0);
+<u8>::decrement(p0);
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::min_value
deps:{}
candidates:{}
+<char as hir::interval::Bound>::min_value();
+crate::<char as hir::interval::Bound>::min_value();
+<char>::min_value();
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::max_value
deps:{}
candidates:{}
+<char as hir::interval::Bound>::max_value();
+crate::<char as hir::interval::Bound>::max_value();
+<char>::max_value();
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::as_u32
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_u32();
+<char as hir::interval::Bound>::as_u32(p0);
+crate::<char as hir::interval::Bound>::as_u32(p0);
+<char>::as_u32(p0);
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::increment
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.increment();
+<char as hir::interval::Bound>::increment(p0);
+crate::<char as hir::interval::Bound>::increment(p0);
+<char>::increment(p0);
-----------------
regex-syntax/src/hir/interval.rs <char as hir::interval::Bound>::decrement
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.decrement();
+<char as hir::interval::Bound>::decrement(p0);
+crate::<char as hir::interval::Bound>::decrement(p0);
+<char>::decrement(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literals as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.clone();
+<hir::literal::Literals as std::clone::Clone>::clone(p0);
+crate::<hir::literal::Literals as std::clone::Clone>::clone(p0);
+<hir::literal::Literals>::clone(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literals as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.assert_receiver_is_total_eq();
+<hir::literal::Literals as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::literal::Literals as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::literal::Literals>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literals as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.eq(p1);
+<hir::literal::Literals as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::literal::Literals as std::cmp::PartialEq>::eq(p0, p1);
+<hir::literal::Literals>::eq(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.clone();
+<hir::literal::Literal as std::clone::Clone>::clone(p0);
+crate::<hir::literal::Literal as std::clone::Clone>::clone(p0);
+<hir::literal::Literal>::clone(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.assert_receiver_is_total_eq();
+<hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::literal::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::literal::Literal>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.cmp(p1);
+<hir::literal::Literal as std::cmp::Ord>::cmp(p0, p1);
+crate::<hir::literal::Literal as std::cmp::Ord>::cmp(p0, p1);
+<hir::literal::Literal>::cmp(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::empty
deps:{}
candidates:{}
+hir::literal::Literals::empty();
+crate::hir::literal::Literals::empty();
+<hir::literal::Literals>::empty();
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+hir::literal::Literals::prefixes(p0);
+crate::hir::literal::Literals::prefixes(p0);
+<hir::literal::Literals>::prefixes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+hir::literal::Literals::suffixes(p0);
+crate::hir::literal::Literals::suffixes(p0);
+<hir::literal::Literals>::suffixes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::limit_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.limit_size();
+hir::literal::Literals::limit_size(p0);
+crate::hir::literal::Literals::limit_size(p0);
+<hir::literal::Literals>::limit_size(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::set_limit_size
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = 0usize; // None+usize
+p0.set_limit_size(p1);
+hir::literal::Literals::set_limit_size(p0, p1);
+crate::hir::literal::Literals::set_limit_size(p0, p1);
+<hir::literal::Literals>::set_limit_size(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::limit_class
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.limit_class();
+hir::literal::Literals::limit_class(p0);
+crate::hir::literal::Literals::limit_class(p0);
+<hir::literal::Literals>::limit_class(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::set_limit_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = 0usize; // None+usize
+p0.set_limit_class(p1);
+hir::literal::Literals::set_limit_class(p0, p1);
+crate::hir::literal::Literals::set_limit_class(p0, p1);
+<hir::literal::Literals>::set_limit_class(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::literals
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.literals();
+hir::literal::Literals::literals(p0);
+crate::hir::literal::Literals::literals(p0);
+<hir::literal::Literals>::literals(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::min_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.min_len();
+hir::literal::Literals::min_len(p0);
+crate::hir::literal::Literals::min_len(p0);
+<hir::literal::Literals>::min_len(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::all_complete
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.all_complete();
+hir::literal::Literals::all_complete(p0);
+crate::hir::literal::Literals::all_complete(p0);
+<hir::literal::Literals>::all_complete(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::any_complete
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.any_complete();
+hir::literal::Literals::any_complete(p0);
+crate::hir::literal::Literals::any_complete(p0);
+<hir::literal::Literals>::any_complete(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::contains_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.contains_empty();
+hir::literal::Literals::contains_empty(p0);
+crate::hir::literal::Literals::contains_empty(p0);
+<hir::literal::Literals>::contains_empty(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.is_empty();
+hir::literal::Literals::is_empty(p0);
+crate::hir::literal::Literals::is_empty(p0);
+<hir::literal::Literals>::is_empty(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::to_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.to_empty();
+hir::literal::Literals::to_empty(p0);
+crate::hir::literal::Literals::to_empty(p0);
+<hir::literal::Literals>::to_empty(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::longest_common_prefix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.longest_common_prefix();
+hir::literal::Literals::longest_common_prefix(p0);
+crate::hir::literal::Literals::longest_common_prefix(p0);
+<hir::literal::Literals>::longest_common_prefix(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::longest_common_suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.longest_common_suffix();
+hir::literal::Literals::longest_common_suffix(p0);
+crate::hir::literal::Literals::longest_common_suffix(p0);
+<hir::literal::Literals>::longest_common_suffix(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::trim_suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = 0usize; // None+usize
+p0.trim_suffix(p1);
+hir::literal::Literals::trim_suffix(p0, p1);
+crate::hir::literal::Literals::trim_suffix(p0, p1);
+<hir::literal::Literals>::trim_suffix(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::unambiguous_prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.unambiguous_prefixes();
+hir::literal::Literals::unambiguous_prefixes(p0);
+crate::hir::literal::Literals::unambiguous_prefixes(p0);
+<hir::literal::Literals>::unambiguous_prefixes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::unambiguous_suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.unambiguous_suffixes();
+hir::literal::Literals::unambiguous_suffixes(p0);
+crate::hir::literal::Literals::unambiguous_suffixes(p0);
+<hir::literal::Literals>::unambiguous_suffixes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::union_prefixes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.union_prefixes(p1);
+hir::literal::Literals::union_prefixes(p0, p1);
+crate::hir::literal::Literals::union_prefixes(p0, p1);
+<hir::literal::Literals>::union_prefixes(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::union_suffixes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.union_suffixes(p1);
+hir::literal::Literals::union_suffixes(p0, p1);
+crate::hir::literal::Literals::union_suffixes(p0, p1);
+<hir::literal::Literals>::union_suffixes(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.union(p1);
+hir::literal::Literals::union(p0, p1);
+crate::hir::literal::Literals::union(p0, p1);
+<hir::literal::Literals>::union(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::cross_product
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.cross_product(p1);
+hir::literal::Literals::cross_product(p0, p1);
+crate::hir::literal::Literals::cross_product(p0, p1);
+<hir::literal::Literals>::cross_product(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::cross_add
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.cross_add(p1);
+hir::literal::Literals::cross_add(p0, p1);
+crate::hir::literal::Literals::cross_add(p0, p1);
+<hir::literal::Literals>::cross_add(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::add
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.add(p1);
+hir::literal::Literals::add(p0, p1);
+crate::hir::literal::Literals::add(p0, p1);
+<hir::literal::Literals>::add(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::add_char_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.add_char_class(p1);
+hir::literal::Literals::add_char_class(p0, p1);
+crate::hir::literal::Literals::add_char_class(p0, p1);
+<hir::literal::Literals>::add_char_class(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::add_char_class_reverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.add_char_class_reverse(p1);
+hir::literal::Literals::add_char_class_reverse(p0, p1);
+crate::hir::literal::Literals::add_char_class_reverse(p0, p1);
+<hir::literal::Literals>::add_char_class_reverse(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::_add_char_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p2 = true; // None+bool
+p0._add_char_class(p1, p2);
+hir::literal::Literals::_add_char_class(p0, p1, p2);
+crate::hir::literal::Literals::_add_char_class(p0, p1, p2);
+<hir::literal::Literals>::_add_char_class(p0, p1, p2);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::add_byte_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.add_byte_class(p1);
+hir::literal::Literals::add_byte_class(p0, p1);
+crate::hir::literal::Literals::add_byte_class(p0, p1);
+<hir::literal::Literals>::add_byte_class(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::cut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.cut();
+hir::literal::Literals::cut(p0);
+crate::hir::literal::Literals::cut(p0);
+<hir::literal::Literals>::cut(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::reverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.reverse();
+hir::literal::Literals::reverse(p0);
+crate::hir::literal::Literals::reverse(p0);
+<hir::literal::Literals>::reverse(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.clear();
+hir::literal::Literals::clear(p0);
+crate::hir::literal::Literals::clear(p0);
+<hir::literal::Literals>::clear(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::remove_complete
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.remove_complete();
+hir::literal::Literals::remove_complete(p0);
+crate::hir::literal::Literals::remove_complete(p0);
+<hir::literal::Literals>::remove_complete(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::num_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
+p0.num_bytes();
+hir::literal::Literals::num_bytes(p0);
+crate::hir::literal::Literals::num_bytes(p0);
+<hir::literal::Literals>::num_bytes(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literals::class_exceeds_limits
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = 0usize; // None+usize
+p0.class_exceeds_limits(p1);
+hir::literal::Literals::class_exceeds_limits(p0, p1);
+crate::hir::literal::Literals::class_exceeds_limits(p0, p1);
+<hir::literal::Literals>::class_exceeds_limits(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literals as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literals
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::Literals as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::Literals as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::Literals>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literal::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+hir::literal::Literal::new(p0);
+crate::hir::literal::Literal::new(p0);
+<hir::literal::Literal>::new(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literal::empty
deps:{}
candidates:{}
+hir::literal::Literal::empty();
+crate::hir::literal::Literal::empty();
+<hir::literal::Literal>::empty();
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literal::is_cut
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.is_cut();
+hir::literal::Literal::is_cut(p0);
+crate::hir::literal::Literal::is_cut(p0);
+<hir::literal::Literal>::is_cut(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs hir::literal::Literal::cut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.cut();
+hir::literal::Literal::cut(p0);
+crate::hir::literal::Literal::cut(p0);
+<hir::literal::Literal>::cut(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.eq(p1);
+<hir::literal::Literal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::literal::Literal as std::cmp::PartialEq>::eq(p0, p1);
+<hir::literal::Literal>::eq(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.partial_cmp(p1);
+<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<hir::literal::Literal as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<hir::literal::Literal>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::literal::Literal as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::literal::Literal as std::fmt::Debug>::fmt(p0, p1);
+<hir::literal::Literal>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.as_ref();
+<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref(p0);
+crate::<hir::literal::Literal as std::convert::AsRef<[u8]>>::as_ref(p0);
+<hir::literal::Literal>::as_ref(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.deref();
+<hir::literal::Literal as std::ops::Deref>::deref(p0);
+crate::<hir::literal::Literal as std::ops::Deref>::deref(p0);
+<hir::literal::Literal>::deref(p0);
-----------------
regex-syntax/src/hir/literal/mod.rs <hir::literal::Literal as std::ops::DerefMut>::deref_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::literal::Literal
+p0.deref_mut();
+<hir::literal::Literal as std::ops::DerefMut>::deref_mut(p0);
+crate::<hir::literal::Literal as std::ops::DerefMut>::deref_mut(p0);
+<hir::literal::Literal>::deref_mut(p0);
-----------------
regex-syntax/src/hir/print.rs <hir::print::PrinterBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::PrinterBuilder
+p0.clone();
+<hir::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+crate::<hir::print::PrinterBuilder as std::clone::Clone>::clone(p0);
+<hir::print::PrinterBuilder>::clone(p0);
-----------------
regex-syntax/src/hir/print.rs <hir::print::PrinterBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::PrinterBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::print::PrinterBuilder as std::fmt::Debug>::fmt(p0, p1);
+<hir::print::PrinterBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/print.rs <hir::print::PrinterBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<hir::print::PrinterBuilder as std::default::Default>::default();
+crate::<hir::print::PrinterBuilder as std::default::Default>::default();
+<hir::print::PrinterBuilder>::default();
-----------------
regex-syntax/src/hir/print.rs hir::print::PrinterBuilder::new
deps:{}
candidates:{}
+hir::print::PrinterBuilder::new();
+crate::hir::print::PrinterBuilder::new();
+<hir::print::PrinterBuilder>::new();
-----------------
regex-syntax/src/hir/print.rs hir::print::PrinterBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::PrinterBuilder
+p0.build();
+hir::print::PrinterBuilder::build(p0);
+crate::hir::print::PrinterBuilder::build(p0);
+<hir::print::PrinterBuilder>::build(p0);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Printer as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::Printer
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::print::Printer as std::fmt::Debug>::fmt(p0, p1);
+<hir::print::Printer>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/print.rs hir::print::Printer::new
deps:{}
candidates:{}
+hir::print::Printer::new();
+crate::hir::print::Printer::new();
+<hir::print::Printer>::new();
-----------------
regex-syntax/src/hir/print.rs hir::print::Printer::print
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Printer::print":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Printer::print":{"W":["std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString","std::fmt::Formatter<'_>","core::fmt::builders::PadAdapter<'_, '_>","std::error::Indented<'_, T>","<&mut W as std::fmt::Write>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Printer
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p2 = MaybeUninit::uninit().assume_init(); // W
+p0.print(p1, p2);
+hir::print::Printer::print(p0, p1, p2);
+crate::hir::print::Printer::print(p0, p1, p2);
+<hir::print::Printer>::print(p0, p1, p2);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as std::fmt::Debug>::fmt
'p
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::print::Writer<'p, W> as std::fmt::Debug>::fmt":{"W":["std::marker::Sized","std::fmt::Debug"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::clone::Clone","std::borrow::Borrow","std::marker::Sized"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Write","std::fmt::Debug"]},"either::Either":{"Left":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"],"Right":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::interval::IntervalSet":{"I":["hir::interval::Interval","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<hir::print::Writer<'p, W> as std::fmt::Debug>::fmt":{"W":["ast::print::Writer","unicode::ClassQuery","parser::Parser","ast::ClassSetBinaryOp","ast::parse::NestLimiter","ast::Repetition","ast::ClassSetItem","hir::interval::IntervalSetIter","ast::ClassUnicode","utf8::Utf8Sequence","ast::FlagsItemKind","ast::Flag","utf8::Utf8Sequences","hir::ErrorKind","ast::Literal","ast::Concat","hir::print::PrinterBuilder","ast::RepetitionOp","unicode::Error","<&mut T as std::fmt::Debug>","hir::HirInfo","hir::literal::Literal","ast::ClassPerl","hir::Anchor","utf8::Utf8Range","hir::ClassBytesRange","hir::Hir","ast::ClassAscii","ast::Alternation","ast::ClassBracketed","ast::WithComments","unicode::CanonicalClassQuery","ast::SpecialLiteralKind","ast::Class","ast::ClassSet","ast::ClassSetRange","hir::print::Printer","hir::Repetition","hir::Literal","ast::ClassUnicodeKind","ast::Group","utf8::ScalarRange","ast::visitor::ClassFrame","hir::ClassUnicodeRange","ast::Position","ast::parse::ClassState","ast::ClassSetBinaryOpKind","unicode::CaseFoldError","hir::ClassUnicode","hir::Class","hir::Group","hir::RepetitionKind","ast::FlagsItem","ast::CaptureName","ast::ClassUnicodeOpKind","ast::Span","hir::interval::IntervalSet","unicode::UnicodeWordError","ast::parse::Parser","ast::ClassSetUnion","ast::Ast","ast::Comment","either::Either","hir::translate::Flags","hir::ClassBytesIter","ast::ClassAsciiKind","ast::print::Printer","hir::RepetitionRange","hir::ClassBytes","ast::LiteralKind","ast::RepetitionKind","hir::GroupKind","ast::parse::Primitive","ast::Error","ast::print::PrinterBuilder","hir::HirKind","ast::visitor::ClassInduct","hir::print::Writer","hir::translate::Translator","error::Formatter","ast::Assertion","ast::ErrorKind","ast::parse::ParserBuilder","ast::SetFlags","hir::ClassUnicodeIter","ast::Flags","hir::translate::TranslatorI","ast::AssertionKind","hir::translate::TranslatorBuilder","parser::ParserBuilder","hir::WordBoundary","ast::parse::GroupState","ast::HexLiteralKind","ast::ClassPerlKind","hir::Error","hir::literal::Literals","ast::parse::ParserI","ast::RepetitionRange","ast::GroupKind","hir::translate::HirFrame","error::Error"]},"ast::parse::NestLimiter":{"P":["std::ffi::CString","std::sync::Arc<T>","std::ffi::OsString","std::rc::Rc<T>","<&mut T as std::fmt::Debug>","std::vec::Vec<T, A>","std::path::PathBuf","std::string::String","std::boxed::Box<T, A>"]},"ast::parse::ParserI":{"P":["std::string::String","std::ffi::CString","std::vec::Vec<T, A>","std::ffi::OsString","std::sync::Arc<T>","std::boxed::Box<T, A>","std::rc::Rc<T>","<&mut T as std::fmt::Debug>","std::path::PathBuf"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::SpecialLiteralKind","ast::Assertion","ast::parse::Primitive","ast::ClassSet","hir::Group","hir::ClassBytesRange","ast::FlagsItem","ast::Flags","hir::ErrorKind","ast::GroupKind","hir::Hir","ast::ClassPerl","ast::AssertionKind","ast::Repetition","ast::ClassUnicode","hir::HirKind","hir::Literal","ast::Flag","ast::Span","ast::ClassSetItem","ast::RepetitionRange","hir::HirInfo","utf8::Utf8Sequence","ast::Ast","ast::SetFlags","hir::WordBoundary","hir::literal::Literal","ast::Group","hir::interval::IntervalSet","ast::ClassUnicodeKind","hir::GroupKind","ast::ClassBracketed","ast::Class","hir::ClassUnicode","hir::RepetitionKind","ast::ClassPerlKind","error::Error","ast::Error","ast::ErrorKind","ast::ClassAscii","ast::FlagsItemKind","ast::RepetitionKind","ast::ClassUnicodeOpKind","<*const T as std::fmt::Debug>","hir::Anchor","ast::ClassAsciiKind","hir::ClassBytes","hir::literal::Literals","either::Either","ast::ClassSetBinaryOp","ast::ClassSetUnion","hir::ClassUnicodeRange","hir::Repetition","utf8::Utf8Range","ast::ClassSetBinaryOpKind","ast::Position","ast::Alternation","hir::RepetitionRange","ast::ClassSetRange","ast::WithComments","ast::Concat","ast::CaptureName","hir::Class","ast::HexLiteralKind","ast::Comment","hir::Error","ast::Literal","ast::RepetitionOp","ast::LiteralKind"],"Right":["ast::FlagsItemKind","utf8::Utf8Sequence","hir::Class","ast::GroupKind","hir::ClassBytesRange","ast::ClassUnicode","hir::ClassUnicodeRange","ast::ClassAsciiKind","ast::ClassSetBinaryOpKind","ast::Class","ast::Ast","ast::ClassSetUnion","ast::Position","std::clone::impls::<impl std::clone::Clone for *mut T>","ast::SetFlags","error::Error","utf8::Utf8Range","ast::ClassSetRange","hir::literal::Literals","ast::AssertionKind","ast::SpecialLiteralKind","ast::ClassSetBinaryOp","hir::literal::Literal","hir::RepetitionRange","hir::ClassBytes","ast::RepetitionOp","ast::Assertion","hir::Literal","hir::interval::IntervalSet","ast::ClassBracketed","ast::HexLiteralKind","hir::RepetitionKind","hir::HirInfo","hir::ErrorKind","ast::Span","ast::Repetition","ast::ClassPerl","ast::ClassSet","ast::Literal","ast::Flag","ast::Alternation","ast::ClassUnicodeKind","ast::ClassPerlKind","ast::LiteralKind","ast::Comment","hir::Hir","ast::RepetitionRange","hir::HirKind","ast::Flags","ast::ClassUnicodeOpKind","ast::ClassAscii","ast::WithComments","ast::CaptureName","ast::FlagsItem","hir::WordBoundary","hir::ClassUnicode","ast::Group","hir::Error","ast::ClassSetItem","ast::parse::Primitive","hir::Group","hir::Anchor","ast::ErrorKind","hir::GroupKind","hir::Repetition","ast::Concat","ast::RepetitionKind","ast::Error","either::Either"]},"error::Formatter":{"E":["error::Formatter","<&mut T as std::fmt::Display>","ast::Ast","hir::Error","hir::Hir","ast::ErrorKind","error::Error","unicode::CaseFoldError","ast::Error","unicode::UnicodeWordError","hir::ErrorKind"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["ast::SetFlags","ast::ClassSetBinaryOpKind","hir::ErrorKind","ast::RepetitionOp","ast::Class","hir::ClassUnicodeIter","ast::Comment","ast::ClassBracketed","ast::ClassUnicodeOpKind","parser::ParserBuilder","ast::Position","hir::Error","ast::parse::GroupState","ast::Group","ast::RepetitionRange","hir::RepetitionKind","ast::Error","ast::ClassSetItem","ast::ClassAscii","hir::translate::Translator","utf8::Utf8Range","hir::translate::HirFrame","utf8::Utf8Sequences","ast::ClassSetRange","ast::CaptureName","ast::Flag","<&mut T as std::fmt::Debug>","ast::parse::NestLimiter","hir::literal::Literals","hir::interval::IntervalSetIter","hir::HirKind","unicode::Error","hir::translate::TranslatorBuilder","ast::ClassSetUnion","hir::Group","hir::WordBoundary","ast::print::Printer","ast::visitor::ClassFrame","ast::ClassUnicodeKind","ast::Ast","ast::ClassSet","ast::SpecialLiteralKind","ast::Literal","ast::AssertionKind","hir::ClassBytesRange","ast::Span","hir::print::PrinterBuilder","ast::print::Writer","hir::HirInfo","ast::WithComments","ast::Assertion","ast::parse::ParserBuilder","utf8::ScalarRange","hir::ClassUnicode","unicode::UnicodeWordError","ast::ClassSetBinaryOp","hir::literal::Literal","error::Formatter","ast::Alternation","ast::ClassPerl","ast::ClassAsciiKind","ast::FlagsItemKind","hir::ClassBytesIter","hir::translate::TranslatorI","ast::parse::Primitive","error::Error","ast::FlagsItem","hir::interval::IntervalSet","hir::Anchor","hir::Class","ast::parse::Parser","ast::print::PrinterBuilder","hir::translate::Flags","ast::RepetitionKind","ast::parse::ParserI","either::Either","ast::Flags","ast::LiteralKind","unicode::CaseFoldError","hir::RepetitionRange","hir::Literal","parser::Parser","hir::ClassBytes","hir::Repetition","unicode::ClassQuery","hir::print::Printer","unicode::CanonicalClassQuery","hir::print::Writer","utf8::Utf8Sequence","ast::ClassUnicode","hir::Hir","ast::ClassPerlKind","ast::visitor::ClassInduct","ast::Concat","ast::ErrorKind","ast::parse::ClassState","hir::GroupKind","ast::HexLiteralKind","hir::ClassUnicodeRange","ast::GroupKind","ast::Repetition"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::print::Writer<'p, W> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::print::Writer<'p, W> as std::fmt::Debug>::fmt(p0, p1);
+<hir::print::Writer<'p, W>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish
'p
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish":{"W":["<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::string::String","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
+p0.finish();
+<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish(p0);
+crate::<hir::print::Writer<'p, W> as hir::visitor::Visitor>::finish(p0);
+<hir::print::Writer<'p, W>>::finish(p0);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre
'p
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre":{"W":["<&mut W as std::fmt::Write>","std::fmt::Formatter<'_>","std::net::display_buffer::DisplayBuffer<SIZE>","std::error::Indented<'_, T>","std::string::String","core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_pre(p1);
+<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre(p0, p1);
+crate::<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_pre(p0, p1);
+<hir::print::Writer<'p, W>>::visit_pre(p0, p1);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post
'p
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post":{"W":["std::ffi::OsString","std::error::Indented<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>","std::io::Write::write_fmt::Adapter<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.visit_post(p1);
+<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post(p0, p1);
+crate::<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_post(p0, p1);
+<hir::print::Writer<'p, W>>::visit_post(p0, p1);
-----------------
regex-syntax/src/hir/print.rs <hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in
'p
deps:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in":{"W":["std::io::Write::write_fmt::Adapter<'_, T>","std::error::Indented<'_, T>","<&mut W as std::fmt::Write>","std::string::String","std::net::display_buffer::DisplayBuffer<SIZE>","std::ffi::OsString","core::fmt::builders::PadAdapter<'_, '_>","std::fmt::Formatter<'_>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
+p0.visit_alternation_in();
+<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in(p0);
+crate::<hir::print::Writer<'p, W> as hir::visitor::Visitor>::visit_alternation_in(p0);
+<hir::print::Writer<'p, W>>::visit_alternation_in(p0);
-----------------
regex-syntax/src/hir/print.rs hir::print::Writer::<'p, W>::write_literal_char
'p
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_char":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_char":{"W":["<&mut W as std::fmt::Write>","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","core::fmt::builders::PadAdapter<'_, '_>","std::ffi::OsString","std::string::String","std::fmt::Formatter<'_>","std::error::Indented<'_, T>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = 'a'; // None+char
+p0.write_literal_char(p1);
+hir::print::Writer::<'p, W>::write_literal_char(p0, p1);
+crate::hir::print::Writer::<'p, W>::write_literal_char(p0, p1);
+<hir::print::Writer<'p, W>>::write_literal_char(p0, p1);
-----------------
regex-syntax/src/hir/print.rs hir::print::Writer::<'p, W>::write_literal_byte
'p
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_byte":{"W":["std::marker::Sized","std::fmt::Write"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_byte":{"W":["std::fmt::Formatter<'_>","core::fmt::builders::PadAdapter<'_, '_>","std::io::Write::write_fmt::Adapter<'_, T>","std::net::display_buffer::DisplayBuffer<SIZE>","std::string::String","<&mut W as std::fmt::Write>","std::error::Indented<'_, T>","std::ffi::OsString"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = 0u8; // None+u8
+p0.write_literal_byte(p1);
+hir::print::Writer::<'p, W>::write_literal_byte(p0, p1);
+crate::hir::print::Writer::<'p, W>::write_literal_byte(p0, p1);
+<hir::print::Writer<'p, W>>::write_literal_byte(p0, p1);
-----------------
regex-syntax/src/hir/print.rs hir::print::Writer::<'p, W>::write_literal_class_byte
'p
deps:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_class_byte":{"W":["std::fmt::Write","std::marker::Sized"]}}
candidates:{"<&mut W as std::fmt::Write>":{},"hir::print::Writer::<'p, W>::write_literal_class_byte":{"W":["std::fmt::Formatter<'_>","std::ffi::OsString","std::error::Indented<'_, T>","std::string::String","std::io::Write::write_fmt::Adapter<'_, T>","<&mut W as std::fmt::Write>","core::fmt::builders::PadAdapter<'_, '_>","std::net::display_buffer::DisplayBuffer<SIZE>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::print::Writer<'p, W>
let mut p1 = 0u8; // None+u8
+p0.write_literal_class_byte(p1);
+hir::print::Writer::<'p, W>::write_literal_class_byte(p0, p1);
+crate::hir::print::Writer::<'p, W>::write_literal_class_byte(p0, p1);
+<hir::print::Writer<'p, W>>::write_literal_class_byte(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
+p0.clone();
+<hir::translate::TranslatorBuilder as std::clone::Clone>::clone(p0);
+crate::<hir::translate::TranslatorBuilder as std::clone::Clone>::clone(p0);
+<hir::translate::TranslatorBuilder>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::TranslatorBuilder as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::TranslatorBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<hir::translate::TranslatorBuilder as std::default::Default>::default();
+crate::<hir::translate::TranslatorBuilder as std::default::Default>::default();
+<hir::translate::TranslatorBuilder>::default();
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::new
deps:{}
candidates:{}
+hir::translate::TranslatorBuilder::new();
+crate::hir::translate::TranslatorBuilder::new();
+<hir::translate::TranslatorBuilder>::new();
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
+p0.build();
+hir::translate::TranslatorBuilder::build(p0);
+crate::hir::translate::TranslatorBuilder::build(p0);
+<hir::translate::TranslatorBuilder>::build(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::allow_invalid_utf8
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.allow_invalid_utf8(p1);
+hir::translate::TranslatorBuilder::allow_invalid_utf8(p0, p1);
+crate::hir::translate::TranslatorBuilder::allow_invalid_utf8(p0, p1);
+<hir::translate::TranslatorBuilder>::allow_invalid_utf8(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+hir::translate::TranslatorBuilder::case_insensitive(p0, p1);
+crate::hir::translate::TranslatorBuilder::case_insensitive(p0, p1);
+<hir::translate::TranslatorBuilder>::case_insensitive(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+hir::translate::TranslatorBuilder::multi_line(p0, p1);
+crate::hir::translate::TranslatorBuilder::multi_line(p0, p1);
+<hir::translate::TranslatorBuilder>::multi_line(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+hir::translate::TranslatorBuilder::dot_matches_new_line(p0, p1);
+crate::hir::translate::TranslatorBuilder::dot_matches_new_line(p0, p1);
+<hir::translate::TranslatorBuilder>::dot_matches_new_line(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+hir::translate::TranslatorBuilder::swap_greed(p0, p1);
+crate::hir::translate::TranslatorBuilder::swap_greed(p0, p1);
+<hir::translate::TranslatorBuilder>::swap_greed(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+hir::translate::TranslatorBuilder::unicode(p0, p1);
+crate::hir::translate::TranslatorBuilder::unicode(p0, p1);
+<hir::translate::TranslatorBuilder>::unicode(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Translator as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Translator
+p0.clone();
+<hir::translate::Translator as std::clone::Clone>::clone(p0);
+crate::<hir::translate::Translator as std::clone::Clone>::clone(p0);
+<hir::translate::Translator>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Translator as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Translator
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::Translator as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::Translator as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::Translator>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Translator::new
deps:{}
candidates:{}
+hir::translate::Translator::new();
+crate::hir::translate::Translator::new();
+<hir::translate::Translator>::new();
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Translator::translate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::Translator
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.translate(&p1, p2);
+hir::translate::Translator::translate(p0, &p1, p2);
+crate::hir::translate::Translator::translate(p0, &p1, p2);
+<hir::translate::Translator>::translate(p0, &p1, p2);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::HirFrame as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.clone();
+<hir::translate::HirFrame as std::clone::Clone>::clone(p0);
+crate::<hir::translate::HirFrame as std::clone::Clone>::clone(p0);
+<hir::translate::HirFrame>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::HirFrame as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::HirFrame as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::HirFrame as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::HirFrame>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::HirFrame::unwrap_expr
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_expr();
+hir::translate::HirFrame::unwrap_expr(p0);
+crate::hir::translate::HirFrame::unwrap_expr(p0);
+<hir::translate::HirFrame>::unwrap_expr(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::HirFrame::unwrap_class_unicode
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_class_unicode();
+hir::translate::HirFrame::unwrap_class_unicode(p0);
+crate::hir::translate::HirFrame::unwrap_class_unicode(p0);
+<hir::translate::HirFrame>::unwrap_class_unicode(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::HirFrame::unwrap_class_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_class_bytes();
+hir::translate::HirFrame::unwrap_class_bytes(p0);
+crate::hir::translate::HirFrame::unwrap_class_bytes(p0);
+<hir::translate::HirFrame>::unwrap_class_bytes(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::HirFrame::unwrap_group
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.unwrap_group();
+hir::translate::HirFrame::unwrap_group(p0);
+crate::hir::translate::HirFrame::unwrap_group(p0);
+<hir::translate::HirFrame>::unwrap_group(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish
't,'p
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.finish();
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish(p0);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::finish(p0);
+<hir::translate::TranslatorI<'t, 'p>>::finish(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_pre(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_pre(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_pre(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Ast
+p0.visit_post(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_post(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_pre(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_pre(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_item_pre(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetItem
+p0.visit_class_set_item_post(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_item_post(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_pre(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_pre(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_binary_op_pre(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_in(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_in(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_binary_op_in(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post
't,'p
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassSetBinaryOp
+p0.visit_class_set_binary_op_post(p1);
+<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::visit_class_set_binary_op_post(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.clone();
+<hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone(p0);
+crate::<hir::translate::TranslatorI<'t, 'p> as std::clone::Clone>::clone(p0);
+<hir::translate::TranslatorI<'t, 'p>>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::TranslatorI<'t, 'p> as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::new
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Translator
let mut p1 = "sample"; // None+&str
+hir::translate::TranslatorI::<'t, 'p>::new(p0, &p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::new(p0, &p1);
+<hir::translate::TranslatorI<'t, 'p>>::new(p0, &p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::trans
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.trans();
+hir::translate::TranslatorI::<'t, 'p>::trans(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::trans(p0);
+<hir::translate::TranslatorI<'t, 'p>>::trans(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::push
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::translate::HirFrame
+p0.push(p1);
+hir::translate::TranslatorI::<'t, 'p>::push(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::push(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::push(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::pop
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.pop();
+hir::translate::TranslatorI::<'t, 'p>::pop(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::pop(p0);
+<hir::translate::TranslatorI<'t, 'p>>::pop(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::error
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.error(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::error(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::error(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::error(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::flags
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
+p0.flags();
+hir::translate::TranslatorI::<'t, 'p>::flags(p0);
+crate::hir::translate::TranslatorI::<'t, 'p>::flags(p0);
+<hir::translate::TranslatorI<'t, 'p>>::flags(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::set_flags
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+p0.set_flags(p1);
+hir::translate::TranslatorI::<'t, 'p>::set_flags(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::set_flags(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::set_flags(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_literal
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.hir_literal(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_literal(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_literal(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_literal(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::literal_to_char
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.literal_to_char(p1);
+hir::translate::TranslatorI::<'t, 'p>::literal_to_char(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::literal_to_char(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::literal_to_char(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_from_char
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = 'a'; // None+char
+p0.hir_from_char(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_from_char(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_from_char(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_from_char(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_from_char_case_insensitive
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = 'a'; // None+char
+p0.hir_from_char_case_insensitive(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_from_char_case_insensitive(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_from_char_case_insensitive(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_from_char_case_insensitive(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_dot
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = MaybeUninit::uninit().assume_init(); // ast::Span
+p0.hir_dot(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_dot(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_dot(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_dot(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_assertion
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Assertion
+p0.hir_assertion(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_assertion(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_assertion(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_assertion(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_group
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Group
let mut p2 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.hir_group(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_group(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_group(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_group(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_repetition
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Repetition
let mut p2 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.hir_repetition(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::hir_repetition(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_repetition(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::hir_repetition(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassUnicode
+p0.hir_unicode_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_unicode_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_unicode_class(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.hir_perl_unicode_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_perl_unicode_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_perl_unicode_class(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::ClassPerl
+p0.hir_perl_byte_class(p1);
+hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::hir_perl_byte_class(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::hir_perl_byte_class(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = MaybeUninit::uninit().assume_init(); // std::result::Result<hir::ClassUnicode, unicode::Error>
+p0.convert_unicode_class_error(p1, p2);
+hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error(p0, p1, p2);
+crate::hir::translate::TranslatorI::<'t, 'p>::convert_unicode_class_error(p0, p1, p2);
+<hir::translate::TranslatorI<'t, 'p>>::convert_unicode_class_error(p0, p1, p2);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = true; // None+bool
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.unicode_fold_and_negate(p1, p2, p3);
+hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate(p0, p1, p2, p3);
+crate::hir::translate::TranslatorI::<'t, 'p>::unicode_fold_and_negate(p0, p1, p2, p3);
+<hir::translate::TranslatorI<'t, 'p>>::unicode_fold_and_negate(p0, p1, p2, p3);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Span
let mut p2 = true; // None+bool
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.bytes_fold_and_negate(p1, p2, p3);
+hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate(p0, p1, p2, p3);
+crate::hir::translate::TranslatorI::<'t, 'p>::bytes_fold_and_negate(p0, p1, p2, p3);
+<hir::translate::TranslatorI<'t, 'p>>::bytes_fold_and_negate(p0, p1, p2, p3);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::TranslatorI::<'t, 'p>::class_literal_byte
't,'p
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::TranslatorI<'t, 'p>
let mut p1 = & MaybeUninit::uninit().assume_init(); // ast::Literal
+p0.class_literal_byte(p1);
+hir::translate::TranslatorI::<'t, 'p>::class_literal_byte(p0, p1);
+crate::hir::translate::TranslatorI::<'t, 'p>::class_literal_byte(p0, p1);
+<hir::translate::TranslatorI<'t, 'p>>::class_literal_byte(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Flags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.clone();
+<hir::translate::Flags as std::clone::Clone>::clone(p0);
+crate::<hir::translate::Flags as std::clone::Clone>::clone(p0);
+<hir::translate::Flags>::clone(p0);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Flags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::translate::Flags as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::translate::Flags as std::fmt::Debug>::fmt(p0, p1);
+<hir::translate::Flags>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs <hir::translate::Flags as std::default::Default>::default
deps:{}
candidates:{}
+<hir::translate::Flags as std::default::Default>::default();
+crate::<hir::translate::Flags as std::default::Default>::default();
+<hir::translate::Flags>::default();
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::from_ast
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ast::Flags
+hir::translate::Flags::from_ast(p0);
+crate::hir::translate::Flags::from_ast(p0);
+<hir::translate::Flags>::from_ast(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::merge
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::translate::Flags
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.merge(p1);
+hir::translate::Flags::merge(p0, p1);
+crate::hir::translate::Flags::merge(p0, p1);
+<hir::translate::Flags>::merge(p0, p1);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::case_insensitive
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.case_insensitive();
+hir::translate::Flags::case_insensitive(p0);
+crate::hir::translate::Flags::case_insensitive(p0);
+<hir::translate::Flags>::case_insensitive(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::multi_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.multi_line();
+hir::translate::Flags::multi_line(p0);
+crate::hir::translate::Flags::multi_line(p0);
+<hir::translate::Flags>::multi_line(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.dot_matches_new_line();
+hir::translate::Flags::dot_matches_new_line(p0);
+crate::hir::translate::Flags::dot_matches_new_line(p0);
+<hir::translate::Flags>::dot_matches_new_line(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::swap_greed
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.swap_greed();
+hir::translate::Flags::swap_greed(p0);
+crate::hir::translate::Flags::swap_greed(p0);
+<hir::translate::Flags>::swap_greed(p0);
-----------------
regex-syntax/src/hir/translate.rs hir::translate::Flags::unicode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::translate::Flags
+p0.unicode();
+hir::translate::Flags::unicode(p0);
+crate::hir::translate::Flags::unicode(p0);
+<hir::translate::Flags>::unicode(p0);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::new
'a
deps:{}
candidates:{}
+hir::visitor::HeapVisitor::<'a>::new();
+crate::hir::visitor::HeapVisitor::<'a>::new();
+<hir::visitor::HeapVisitor<'a>>::new();
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::visit
'a
deps:{"hir::print::Writer":{"W":["std::fmt::Write","std::fmt::Debug","std::marker::Sized"]},"hir::visitor::HeapVisitor::<'a>::visit":{"V":["std::marker::Sized","hir::visitor::Visitor"]}}
candidates:{"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"hir::visitor::HeapVisitor::<'a>::visit":{"V":["hir::print::Writer"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.visit(p1, p2);
+hir::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+crate::hir::visitor::HeapVisitor::<'a>::visit(p0, p1, p2);
+<hir::visitor::HeapVisitor<'a>>::visit(p0, p1, p2);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::induct
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::visitor::HeapVisitor<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.induct(p1);
+hir::visitor::HeapVisitor::<'a>::induct(p0, p1);
+crate::hir::visitor::HeapVisitor::<'a>::induct(p0, p1);
+<hir::visitor::HeapVisitor<'a>>::induct(p0, p1);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::HeapVisitor::<'a>::pop
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::visitor::HeapVisitor<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::visitor::Frame<'a>
+p0.pop(p1);
+hir::visitor::HeapVisitor::<'a>::pop(p0, p1);
+crate::hir::visitor::HeapVisitor::<'a>::pop(p0, p1);
+<hir::visitor::HeapVisitor<'a>>::pop(p0, p1);
-----------------
regex-syntax/src/hir/visitor.rs hir::visitor::Frame::<'a>::child
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::visitor::Frame<'a>
+p0.child();
+hir::visitor::Frame::<'a>::child(p0);
+crate::hir::visitor::Frame::<'a>::child(p0);
+<hir::visitor::Frame<'a>>::child(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.clone();
+<hir::Error as std::clone::Clone>::clone(p0);
+crate::<hir::Error as std::clone::Clone>::clone(p0);
+<hir::Error>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Error as std::fmt::Debug>::fmt(p0, p1);
+<hir::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.assert_receiver_is_total_eq();
+<hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Error as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Error>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.eq(p1);
+<hir::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Error as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Error>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Error::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.kind();
+hir::Error::kind(p0);
+crate::hir::Error::kind(p0);
+<hir::Error>::kind(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Error::pattern
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.pattern();
+hir::Error::pattern(p0);
+crate::hir::Error::pattern(p0);
+<hir::Error>::pattern(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Error::span
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.span();
+hir::Error::span(p0);
+crate::hir::Error::span(p0);
+<hir::Error>::span(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.clone();
+<hir::ErrorKind as std::clone::Clone>::clone(p0);
+crate::<hir::ErrorKind as std::clone::Clone>::clone(p0);
+<hir::ErrorKind>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::ErrorKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.assert_receiver_is_total_eq();
+<hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.eq(p1);
+<hir::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ErrorKind>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ErrorKind::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
+p0.description();
+hir::ErrorKind::description(p0);
+crate::hir::ErrorKind::description(p0);
+<hir::ErrorKind>::description(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
+p0.description();
+<hir::Error as std::error::Error>::description(p0);
+crate::<hir::Error as std::error::Error>::description(p0);
+<hir::Error>::description(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<hir::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<hir::Error as std::fmt::Display>::fmt(p0, p1);
+<hir::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ErrorKind as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<hir::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+crate::<hir::ErrorKind as std::fmt::Display>::fmt(p0, p1);
+<hir::ErrorKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.clone();
+<hir::Hir as std::clone::Clone>::clone(p0);
+crate::<hir::Hir as std::clone::Clone>::clone(p0);
+<hir::Hir>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Hir as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Hir as std::fmt::Debug>::fmt(p0, p1);
+<hir::Hir>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.assert_receiver_is_total_eq();
+<hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Hir as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Hir>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.eq(p1);
+<hir::Hir as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Hir as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Hir>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.clone();
+<hir::HirKind as std::clone::Clone>::clone(p0);
+crate::<hir::HirKind as std::clone::Clone>::clone(p0);
+<hir::HirKind>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::HirKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::HirKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::HirKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.assert_receiver_is_total_eq();
+<hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::HirKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::HirKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.eq(p1);
+<hir::HirKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::HirKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::HirKind>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::kind
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.kind();
+hir::Hir::kind(p0);
+crate::hir::Hir::kind(p0);
+<hir::Hir>::kind(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::into_kind
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.into_kind();
+hir::Hir::into_kind(p0);
+crate::hir::Hir::into_kind(p0);
+<hir::Hir>::into_kind(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::empty
deps:{}
candidates:{}
+hir::Hir::empty();
+crate::hir::Hir::empty();
+<hir::Hir>::empty();
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::literal
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Literal
+hir::Hir::literal(p0);
+crate::hir::Hir::literal(p0);
+<hir::Hir>::literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::class
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Class
+hir::Hir::class(p0);
+crate::hir::Hir::class(p0);
+<hir::Hir>::class(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::anchor
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Anchor
+hir::Hir::anchor(p0);
+crate::hir::Hir::anchor(p0);
+<hir::Hir>::anchor(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::word_boundary
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+hir::Hir::word_boundary(p0);
+crate::hir::Hir::word_boundary(p0);
+<hir::Hir>::word_boundary(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::repetition
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Repetition
+hir::Hir::repetition(p0);
+crate::hir::Hir::repetition(p0);
+<hir::Hir>::repetition(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::group
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // hir::Group
+hir::Hir::group(p0);
+crate::hir::Hir::group(p0);
+<hir::Hir>::group(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::concat
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::Hir>
+hir::Hir::concat(p0);
+crate::hir::Hir::concat(p0);
+<hir::Hir>::concat(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::alternation
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::Hir>
+hir::Hir::alternation(p0);
+crate::hir::Hir::alternation(p0);
+<hir::Hir>::alternation(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::dot
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+hir::Hir::dot(p0);
+crate::hir::Hir::dot(p0);
+<hir::Hir>::dot(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::any
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+hir::Hir::any(p0);
+crate::hir::Hir::any(p0);
+<hir::Hir>::any(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_always_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_always_utf8();
+hir::Hir::is_always_utf8(p0);
+crate::hir::Hir::is_always_utf8(p0);
+<hir::Hir>::is_always_utf8(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_all_assertions
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_all_assertions();
+hir::Hir::is_all_assertions(p0);
+crate::hir::Hir::is_all_assertions(p0);
+<hir::Hir>::is_all_assertions(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_anchored_start();
+hir::Hir::is_anchored_start(p0);
+crate::hir::Hir::is_anchored_start(p0);
+<hir::Hir>::is_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_anchored_end();
+hir::Hir::is_anchored_end(p0);
+crate::hir::Hir::is_anchored_end(p0);
+<hir::Hir>::is_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_line_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_line_anchored_start();
+hir::Hir::is_line_anchored_start(p0);
+crate::hir::Hir::is_line_anchored_start(p0);
+<hir::Hir>::is_line_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_line_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_line_anchored_end();
+hir::Hir::is_line_anchored_end(p0);
+crate::hir::Hir::is_line_anchored_end(p0);
+<hir::Hir>::is_line_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_any_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_any_anchored_start();
+hir::Hir::is_any_anchored_start(p0);
+crate::hir::Hir::is_any_anchored_start(p0);
+<hir::Hir>::is_any_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_any_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_any_anchored_end();
+hir::Hir::is_any_anchored_end(p0);
+crate::hir::Hir::is_any_anchored_end(p0);
+<hir::Hir>::is_any_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_match_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_match_empty();
+hir::Hir::is_match_empty(p0);
+crate::hir::Hir::is_match_empty(p0);
+<hir::Hir>::is_match_empty(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_literal();
+hir::Hir::is_literal(p0);
+crate::hir::Hir::is_literal(p0);
+<hir::Hir>::is_literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Hir::is_alternation_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.is_alternation_literal();
+hir::Hir::is_alternation_literal(p0);
+crate::hir::Hir::is_alternation_literal(p0);
+<hir::Hir>::is_alternation_literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirKind::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.is_empty();
+hir::HirKind::is_empty(p0);
+crate::hir::HirKind::is_empty(p0);
+<hir::HirKind>::is_empty(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirKind::has_subexprs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirKind
+p0.has_subexprs();
+hir::HirKind::has_subexprs(p0);
+crate::hir::HirKind::has_subexprs(p0);
+<hir::HirKind>::has_subexprs(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Hir
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<hir::Hir as std::fmt::Display>::fmt(p0, p1);
+crate::<hir::Hir as std::fmt::Display>::fmt(p0, p1);
+<hir::Hir>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Literal as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.clone();
+<hir::Literal as std::clone::Clone>::clone(p0);
+crate::<hir::Literal as std::clone::Clone>::clone(p0);
+<hir::Literal>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Literal as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Literal as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Literal as std::fmt::Debug>::fmt(p0, p1);
+<hir::Literal>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.assert_receiver_is_total_eq();
+<hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Literal as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Literal>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Literal as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.eq(p1);
+<hir::Literal as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Literal as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Literal>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Literal::is_unicode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Literal
+p0.is_unicode();
+hir::Literal::is_unicode(p0);
+crate::hir::Literal::is_unicode(p0);
+<hir::Literal>::is_unicode(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Class as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.clone();
+<hir::Class as std::clone::Clone>::clone(p0);
+crate::<hir::Class as std::clone::Clone>::clone(p0);
+<hir::Class>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Class as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Class as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Class as std::fmt::Debug>::fmt(p0, p1);
+<hir::Class>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.assert_receiver_is_total_eq();
+<hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Class as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Class>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Class as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.eq(p1);
+<hir::Class as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Class as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Class>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Class::case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Class
+p0.case_fold_simple();
+hir::Class::case_fold_simple(p0);
+crate::hir::Class::case_fold_simple(p0);
+<hir::Class>::case_fold_simple(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Class::negate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Class
+p0.negate();
+hir::Class::negate(p0);
+crate::hir::Class::negate(p0);
+<hir::Class>::negate(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::Class::is_always_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Class
+p0.is_always_utf8();
+hir::Class::is_always_utf8(p0);
+crate::hir::Class::is_always_utf8(p0);
+<hir::Class>::is_always_utf8(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicode as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.clone();
+<hir::ClassUnicode as std::clone::Clone>::clone(p0);
+crate::<hir::ClassUnicode as std::clone::Clone>::clone(p0);
+<hir::ClassUnicode>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicode as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassUnicode as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassUnicode>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.assert_receiver_is_total_eq();
+<hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassUnicode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassUnicode>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicode as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.eq(p1);
+<hir::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassUnicode as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassUnicode>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"ast::parse::NestLimiter":{"P":["std::fmt::Debug","std::marker::Sized","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::borrow::Borrow"]},"ast::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"either::Either":{"Left":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq"],"Right":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"error::Formatter":{"E":["std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"hir::ClassUnicode::new":{"I":["std::iter::IntoIterator","std::marker::Sized"]},"hir::interval::IntervalSet":{"I":["std::cmp::PartialEq","hir::interval::Interval","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"hir::interval::IntervalSetIter":{"I":["std::marker::Sized","std::fmt::Debug"]},"hir::print::Writer":{"W":["std::marker::Sized","std::fmt::Debug","std::fmt::Write"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["hir::ClassUnicodeIter","<&mut I as std::iter::Iterator>","hir::interval::IntervalSetIter","hir::ClassBytesIter","utf8::Utf8Sequences"]},"ast::parse::NestLimiter":{"P":["std::boxed::Box<T, A>","std::rc::Rc<T>","std::ffi::CString","std::string::String","<&mut T as std::fmt::Debug>","std::sync::Arc<T>","std::ffi::OsString","std::path::PathBuf","std::vec::Vec<T, A>"]},"ast::parse::ParserI":{"P":["std::path::PathBuf","std::sync::Arc<T>","std::ffi::OsString","<&T as std::fmt::Debug>","std::vec::Vec<T, A>","std::ffi::CString","std::boxed::Box<T, A>","std::string::String","std::rc::Rc<T>"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["hir::Anchor","hir::literal::Literal","ast::WithComments","ast::Comment","ast::ClassSet","ast::ClassSetItem","utf8::Utf8Range","ast::RepetitionKind","hir::ClassUnicode","hir::ClassBytes","ast::Alternation","ast::ClassSetRange","ast::RepetitionOp","ast::parse::Primitive","hir::Group","ast::ClassAsciiKind","ast::SpecialLiteralKind","ast::ClassAscii","ast::Class","ast::ErrorKind","ast::HexLiteralKind","ast::LiteralKind","ast::GroupKind","hir::Hir","ast::ClassSetBinaryOpKind","hir::interval::IntervalSet","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","hir::Error","hir::ErrorKind","hir::Literal","ast::Flags","ast::AssertionKind","utf8::Utf8Sequence","ast::Span","ast::CaptureName","ast::Repetition","hir::ClassBytesRange","hir::RepetitionKind","ast::ClassBracketed","ast::ClassPerlKind","hir::WordBoundary","ast::ClassUnicodeOpKind","ast::Position","hir::Repetition","ast::Ast","hir::RepetitionRange","ast::ClassSetBinaryOp","ast::Assertion","error::Error","hir::HirKind","hir::ClassUnicodeRange","either::Either","ast::RepetitionRange","ast::ClassSetUnion","ast::Concat","ast::Flag","hir::literal::Literals","ast::ClassUnicode","ast::Literal","hir::HirInfo","hir::Class","ast::FlagsItem","ast::ClassUnicodeKind","ast::Group","ast::SetFlags","hir::GroupKind","ast::Error","ast::FlagsItemKind","ast::ClassPerl"],"Right":["ast::LiteralKind","ast::ClassSetUnion","ast::SetFlags","std::clone::impls::<impl std::clone::Clone for *const T>","ast::Assertion","hir::RepetitionKind","ast::ClassUnicodeKind","hir::ClassBytes","hir::Anchor","ast::Error","ast::CaptureName","hir::HirInfo","hir::literal::Literal","ast::AssertionKind","ast::SpecialLiteralKind","ast::ClassUnicode","ast::ClassPerlKind","hir::literal::Literals","hir::Repetition","ast::HexLiteralKind","ast::RepetitionRange","hir::interval::IntervalSet","either::Either","hir::Error","hir::Group","ast::ErrorKind","utf8::Utf8Sequence","hir::GroupKind","ast::parse::Primitive","hir::ClassUnicodeRange","hir::ClassBytesRange","hir::ErrorKind","ast::Flag","hir::WordBoundary","ast::ClassAsciiKind","ast::RepetitionOp","hir::RepetitionRange","hir::HirKind","ast::WithComments","ast::ClassAscii","hir::Class","ast::ClassSetBinaryOp","error::Error","ast::Flags","ast::ClassBracketed","ast::Concat","hir::Literal","ast::Class","hir::Hir","ast::Span","ast::FlagsItemKind","ast::Position","ast::ClassPerl","ast::ClassSetItem","ast::RepetitionKind","ast::Literal","hir::ClassUnicode","ast::ClassSetBinaryOpKind","utf8::Utf8Range","ast::Group","ast::Repetition","ast::FlagsItem","ast::ClassSet","ast::GroupKind","ast::ClassSetRange","ast::Alternation","ast::Comment","ast::ClassUnicodeOpKind","ast::Ast"]},"error::Formatter":{"E":["unicode::CaseFoldError","hir::Error","unicode::UnicodeWordError","hir::ErrorKind","ast::ErrorKind","hir::Hir","ast::Error","error::Error","<&mut T as std::fmt::Display>","error::Formatter","ast::Ast"]},"hir::ClassUnicode::new":{"I":["<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>","<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["hir::HirInfo","unicode::CanonicalClassQuery","hir::ErrorKind","ast::ClassUnicodeOpKind","hir::ClassBytesIter","hir::HirKind","hir::Anchor","hir::Literal","ast::SetFlags","ast::LiteralKind","hir::print::Printer","ast::Error","hir::Group","ast::Literal","ast::ClassBracketed","hir::Error","ast::HexLiteralKind","parser::Parser","hir::ClassUnicodeIter","ast::visitor::ClassInduct","ast::parse::NestLimiter","error::Formatter","unicode::ClassQuery","either::Either","ast::ClassUnicode","ast::ClassSetItem","ast::ClassAscii","ast::ClassSet","hir::translate::Translator","hir::translate::HirFrame","<*const T as std::fmt::Debug>","hir::literal::Literals","utf8::Utf8Sequence","ast::print::Writer","hir::literal::Literal","ast::parse::ParserI","ast::Ast","ast::ClassSetUnion","ast::Group","ast::visitor::ClassFrame","ast::Span","utf8::Utf8Sequences","hir::RepetitionRange","ast::FlagsItem","ast::parse::ClassState","unicode::Error","ast::SpecialLiteralKind","utf8::ScalarRange","ast::ClassSetBinaryOp","unicode::CaseFoldError","ast::ClassUnicodeKind","hir::Hir","unicode::UnicodeWordError","ast::CaptureName","ast::Concat","ast::ClassSetRange","hir::print::PrinterBuilder","hir::translate::TranslatorBuilder","hir::translate::Flags","hir::translate::TranslatorI","hir::interval::IntervalSet","hir::ClassUnicodeRange","ast::Flags","parser::ParserBuilder","ast::Alternation","ast::Repetition","ast::parse::Parser","ast::Flag","ast::parse::GroupState","ast::ClassSetBinaryOpKind","ast::Class","ast::WithComments","ast::print::PrinterBuilder","ast::Position","ast::print::Printer","ast::GroupKind","hir::GroupKind","ast::RepetitionOp","hir::RepetitionKind","ast::ClassAsciiKind","ast::AssertionKind","ast::FlagsItemKind","hir::print::Writer","ast::ErrorKind","ast::ClassPerl","error::Error","hir::ClassUnicode","hir::Repetition","hir::ClassBytesRange","hir::Class","ast::ClassPerlKind","hir::ClassBytes","ast::Assertion","ast::RepetitionRange","hir::WordBoundary","utf8::Utf8Range","ast::RepetitionKind","ast::Comment","ast::parse::ParserBuilder","hir::interval::IntervalSetIter","ast::parse::Primitive"]},"hir::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+hir::ClassUnicode::new(p0);
+crate::hir::ClassUnicode::new(p0);
+<hir::ClassUnicode>::new(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::empty
deps:{}
candidates:{}
+hir::ClassUnicode::empty();
+crate::hir::ClassUnicode::empty();
+<hir::ClassUnicode>::empty();
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.push(p1);
+hir::ClassUnicode::push(p0, p1);
+crate::hir::ClassUnicode::push(p0, p1);
+<hir::ClassUnicode>::push(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.iter();
+hir::ClassUnicode::iter(p0);
+crate::hir::ClassUnicode::iter(p0);
+<hir::ClassUnicode>::iter(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::ranges
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.ranges();
+hir::ClassUnicode::ranges(p0);
+crate::hir::ClassUnicode::ranges(p0);
+<hir::ClassUnicode>::ranges(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.case_fold_simple();
+hir::ClassUnicode::case_fold_simple(p0);
+crate::hir::ClassUnicode::case_fold_simple(p0);
+<hir::ClassUnicode>::case_fold_simple(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::try_case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.try_case_fold_simple();
+hir::ClassUnicode::try_case_fold_simple(p0);
+crate::hir::ClassUnicode::try_case_fold_simple(p0);
+<hir::ClassUnicode>::try_case_fold_simple(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::negate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.negate();
+hir::ClassUnicode::negate(p0);
+crate::hir::ClassUnicode::negate(p0);
+<hir::ClassUnicode>::negate(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.union(p1);
+hir::ClassUnicode::union(p0, p1);
+crate::hir::ClassUnicode::union(p0, p1);
+<hir::ClassUnicode>::union(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::intersect
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.intersect(p1);
+hir::ClassUnicode::intersect(p0, p1);
+crate::hir::ClassUnicode::intersect(p0, p1);
+<hir::ClassUnicode>::intersect(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.difference(p1);
+hir::ClassUnicode::difference(p0, p1);
+crate::hir::ClassUnicode::difference(p0, p1);
+<hir::ClassUnicode>::difference(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::symmetric_difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.symmetric_difference(p1);
+hir::ClassUnicode::symmetric_difference(p0, p1);
+crate::hir::ClassUnicode::symmetric_difference(p0, p1);
+<hir::ClassUnicode>::symmetric_difference(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicode::is_all_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicode
+p0.is_all_ascii();
+hir::ClassUnicode::is_all_ascii(p0);
+crate::hir::ClassUnicode::is_all_ascii(p0);
+<hir::ClassUnicode>::is_all_ascii(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassUnicodeIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassUnicodeIter<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeIter<'a>
+p0.next();
+<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next(p0);
+crate::<hir::ClassUnicodeIter<'a> as std::iter::Iterator>::next(p0);
+<hir::ClassUnicodeIter<'a>>::next(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.clone();
+<hir::ClassUnicodeRange as std::clone::Clone>::clone(p0);
+crate::<hir::ClassUnicodeRange as std::clone::Clone>::clone(p0);
+<hir::ClassUnicodeRange>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::default::Default>::default
deps:{}
candidates:{}
+<hir::ClassUnicodeRange as std::default::Default>::default();
+crate::<hir::ClassUnicodeRange as std::default::Default>::default();
+<hir::ClassUnicodeRange>::default();
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.assert_receiver_is_total_eq();
+<hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassUnicodeRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassUnicodeRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.eq(p1);
+<hir::ClassUnicodeRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassUnicodeRange as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassUnicodeRange>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.partial_cmp(p1);
+<hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<hir::ClassUnicodeRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<hir::ClassUnicodeRange>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.cmp(p1);
+<hir::ClassUnicodeRange as std::cmp::Ord>::cmp(p0, p1);
+crate::<hir::ClassUnicodeRange as std::cmp::Ord>::cmp(p0, p1);
+<hir::ClassUnicodeRange>::cmp(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassUnicodeRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassUnicodeRange as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassUnicodeRange>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::lower
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.lower();
+<hir::ClassUnicodeRange as hir::interval::Interval>::lower(p0);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::lower(p0);
+<hir::ClassUnicodeRange>::lower(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::upper
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.upper();
+<hir::ClassUnicodeRange as hir::interval::Interval>::upper(p0);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::upper(p0);
+<hir::ClassUnicodeRange>::upper(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::set_lower
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = 'a'; // None+char
+p0.set_lower(p1);
+<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower(p0, p1);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::set_lower(p0, p1);
+<hir::ClassUnicodeRange>::set_lower(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::set_upper
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = 'a'; // None+char
+p0.set_upper(p1);
+<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper(p0, p1);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::set_upper(p0, p1);
+<hir::ClassUnicodeRange>::set_upper(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::ClassUnicodeRange>
+p0.case_fold_simple(p1);
+<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+crate::<hir::ClassUnicodeRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+<hir::ClassUnicodeRange>::case_fold_simple(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicodeRange::new
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+hir::ClassUnicodeRange::new(p0, p1);
+crate::hir::ClassUnicodeRange::new(p0, p1);
+<hir::ClassUnicodeRange>::new(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicodeRange::start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.start();
+hir::ClassUnicodeRange::start(p0);
+crate::hir::ClassUnicodeRange::start(p0);
+<hir::ClassUnicodeRange>::start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassUnicodeRange::end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassUnicodeRange
+p0.end();
+hir::ClassUnicodeRange::end(p0);
+crate::hir::ClassUnicodeRange::end(p0);
+<hir::ClassUnicodeRange>::end(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytes as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.clone();
+<hir::ClassBytes as std::clone::Clone>::clone(p0);
+crate::<hir::ClassBytes as std::clone::Clone>::clone(p0);
+<hir::ClassBytes>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytes as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassBytes as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassBytes as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassBytes>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.assert_receiver_is_total_eq();
+<hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassBytes as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassBytes>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytes as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.eq(p1);
+<hir::ClassBytes as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassBytes as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassBytes>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"ast::parse::NestLimiter":{"P":["std::marker::Sized","std::fmt::Debug","std::borrow::Borrow"]},"ast::parse::ParserI":{"P":["std::marker::Sized","std::borrow::Borrow","std::fmt::Debug","std::clone::Clone"]},"ast::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"either::Either":{"Left":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"],"Right":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"error::Formatter":{"E":["std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"hir::ClassBytes::new":{"I":["std::marker::Sized","std::iter::IntoIterator"]},"hir::interval::IntervalSet":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","hir::interval::Interval","std::fmt::Debug"]},"hir::interval::IntervalSetIter":{"I":["std::fmt::Debug","std::marker::Sized"]},"hir::print::Writer":{"W":["std::fmt::Debug","std::fmt::Write","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&T as std::fmt::Display>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<I as std::iter::IntoIterator>":{"I":["hir::ClassUnicodeIter","<&mut I as std::iter::Iterator>","utf8::Utf8Sequences","hir::ClassBytesIter","hir::interval::IntervalSetIter"]},"ast::parse::NestLimiter":{"P":["std::sync::Arc<T>","std::boxed::Box<T, A>","<&T as std::fmt::Debug>","std::rc::Rc<T>","std::string::String","std::vec::Vec<T, A>","std::ffi::OsString","std::ffi::CString","std::path::PathBuf"]},"ast::parse::ParserI":{"P":["std::sync::Arc<T>","std::vec::Vec<T, A>","std::ffi::OsString","std::ffi::CString","std::rc::Rc<T>","std::path::PathBuf","<&mut T as std::fmt::Debug>","std::boxed::Box<T, A>","std::string::String"]},"ast::print::Writer":{"W":["std::ffi::OsString","std::string::String"]},"either::Either":{"Left":["ast::Ast","hir::Literal","ast::Flags","ast::parse::Primitive","ast::GroupKind","hir::Repetition","hir::Anchor","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::AssertionKind","hir::Class","hir::literal::Literal","ast::Repetition","hir::HirInfo","ast::Class","hir::ClassUnicode","ast::ClassAsciiKind","ast::ErrorKind","ast::Group","ast::ClassUnicode","hir::HirKind","hir::Hir","ast::ClassBracketed","ast::ClassSetUnion","ast::HexLiteralKind","ast::ClassUnicodeOpKind","ast::LiteralKind","ast::RepetitionOp","utf8::Utf8Range","hir::RepetitionRange","hir::ClassBytesRange","ast::Alternation","ast::WithComments","utf8::Utf8Sequence","ast::Position","ast::Comment","ast::SetFlags","hir::GroupKind","hir::WordBoundary","ast::ClassAscii","hir::Error","hir::Group","ast::ClassUnicodeKind","ast::ClassPerl","ast::ClassSetItem","hir::ClassBytes","ast::Assertion","ast::RepetitionKind","ast::Concat","hir::interval::IntervalSet","ast::Error","ast::ClassSetBinaryOp","either::Either","ast::Flag","hir::ClassUnicodeRange","hir::ErrorKind","ast::FlagsItem","ast::ClassSetRange","ast::ClassSetBinaryOpKind","ast::Literal","ast::CaptureName","error::Error","ast::Span","hir::literal::Literals","ast::SpecialLiteralKind","ast::ClassPerlKind","ast::RepetitionRange","ast::ClassSet","hir::RepetitionKind","ast::FlagsItemKind"],"Right":["ast::ClassSet","ast::CaptureName","ast::RepetitionOp","ast::ClassBracketed","ast::Position","hir::RepetitionKind","hir::RepetitionRange","ast::Concat","ast::ClassSetBinaryOp","ast::ClassSetItem","ast::ClassUnicodeOpKind","ast::ErrorKind","hir::WordBoundary","hir::ClassUnicode","hir::literal::Literals","hir::Hir","hir::ClassUnicodeRange","ast::ClassAsciiKind","hir::ClassBytesRange","hir::Repetition","ast::Span","either::Either","hir::Literal","hir::interval::IntervalSet","ast::RepetitionRange","ast::ClassPerlKind","ast::SetFlags","ast::HexLiteralKind","ast::ClassUnicodeKind","ast::ClassPerl","ast::GroupKind","hir::Error","ast::Alternation","ast::Flag","ast::Ast","hir::ErrorKind","ast::parse::Primitive","utf8::Utf8Sequence","ast::LiteralKind","ast::Flags","ast::Comment","ast::SpecialLiteralKind","ast::Error","ast::Assertion","ast::ClassSetUnion","ast::ClassSetRange","utf8::Utf8Range","hir::GroupKind","hir::literal::Literal","hir::HirInfo","hir::Group","ast::ClassSetBinaryOpKind","ast::WithComments","hir::ClassBytes","ast::FlagsItemKind","ast::Repetition","ast::RepetitionKind","ast::Class","ast::ClassUnicode","ast::ClassAscii","hir::HirKind","ast::Group","hir::Anchor","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","ast::AssertionKind","ast::Literal","ast::FlagsItem","hir::Class","error::Error"]},"error::Formatter":{"E":["error::Formatter","hir::ErrorKind","unicode::CaseFoldError","ast::ErrorKind","error::Error","unicode::UnicodeWordError","hir::Hir","ast::Error","hir::Error","ast::Ast","<&mut T as std::fmt::Debug>"]},"hir::ClassBytes::new":{"I":["<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>","<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>"]},"hir::interval::IntervalSet":{"I":["hir::ClassUnicodeRange","hir::ClassBytesRange"]},"hir::interval::IntervalSetIter":{"I":["utf8::Utf8Range","ast::print::Printer","ast::parse::Primitive","ast::RepetitionRange","hir::ClassBytesRange","ast::Concat","hir::Group","ast::ClassUnicode","ast::Position","ast::visitor::ClassInduct","ast::ClassSetUnion","ast::RepetitionOp","ast::SetFlags","hir::print::Writer","ast::ClassPerl","ast::parse::ParserBuilder","unicode::CanonicalClassQuery","ast::parse::NestLimiter","hir::literal::Literals","hir::WordBoundary","ast::ClassAscii","hir::translate::TranslatorI","ast::ClassUnicodeKind","ast::FlagsItem","hir::Hir","ast::SpecialLiteralKind","ast::ClassSetRange","ast::print::Writer","ast::LiteralKind","ast::Literal","hir::literal::Literal","ast::AssertionKind","error::Formatter","<*const T as std::fmt::Debug>","hir::RepetitionRange","hir::ClassUnicodeRange","ast::ClassSetItem","parser::Parser","hir::ErrorKind","unicode::Error","hir::Repetition","ast::RepetitionKind","hir::Anchor","parser::ParserBuilder","hir::HirInfo","ast::ClassAsciiKind","ast::CaptureName","ast::WithComments","hir::ClassUnicode","ast::Comment","ast::ClassPerlKind","hir::interval::IntervalSet","hir::translate::Flags","ast::visitor::ClassFrame","unicode::CaseFoldError","hir::ClassBytesIter","either::Either","ast::GroupKind","ast::parse::ParserI","unicode::ClassQuery","ast::ClassUnicodeOpKind","ast::Flag","hir::translate::Translator","ast::parse::Parser","hir::translate::HirFrame","ast::FlagsItemKind","hir::ClassUnicodeIter","hir::interval::IntervalSetIter","ast::parse::ClassState","hir::translate::TranslatorBuilder","hir::print::PrinterBuilder","ast::Group","ast::Flags","ast::ClassSetBinaryOp","ast::ClassSetBinaryOpKind","ast::Ast","hir::Error","ast::ClassSet","ast::ClassBracketed","ast::parse::GroupState","hir::ClassBytes","ast::Class","unicode::UnicodeWordError","hir::Class","utf8::Utf8Sequence","hir::HirKind","hir::GroupKind","utf8::Utf8Sequences","hir::RepetitionKind","ast::HexLiteralKind","utf8::ScalarRange","error::Error","ast::Repetition","ast::Assertion","ast::ErrorKind","ast::Span","hir::Literal","ast::Alternation","ast::print::PrinterBuilder","hir::print::Printer","ast::Error"]},"hir::print::Writer":{"W":["std::string::String","std::ffi::OsString"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+hir::ClassBytes::new(p0);
+crate::hir::ClassBytes::new(p0);
+<hir::ClassBytes>::new(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::empty
deps:{}
candidates:{}
+hir::ClassBytes::empty();
+crate::hir::ClassBytes::empty();
+<hir::ClassBytes>::empty();
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.push(p1);
+hir::ClassBytes::push(p0, p1);
+crate::hir::ClassBytes::push(p0, p1);
+<hir::ClassBytes>::push(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.iter();
+hir::ClassBytes::iter(p0);
+crate::hir::ClassBytes::iter(p0);
+<hir::ClassBytes>::iter(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::ranges
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.ranges();
+hir::ClassBytes::ranges(p0);
+crate::hir::ClassBytes::ranges(p0);
+<hir::ClassBytes>::ranges(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::case_fold_simple
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.case_fold_simple();
+hir::ClassBytes::case_fold_simple(p0);
+crate::hir::ClassBytes::case_fold_simple(p0);
+<hir::ClassBytes>::case_fold_simple(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::negate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.negate();
+hir::ClassBytes::negate(p0);
+crate::hir::ClassBytes::negate(p0);
+<hir::ClassBytes>::negate(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::union
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.union(p1);
+hir::ClassBytes::union(p0, p1);
+crate::hir::ClassBytes::union(p0, p1);
+<hir::ClassBytes>::union(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::intersect
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.intersect(p1);
+hir::ClassBytes::intersect(p0, p1);
+crate::hir::ClassBytes::intersect(p0, p1);
+<hir::ClassBytes>::intersect(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.difference(p1);
+hir::ClassBytes::difference(p0, p1);
+crate::hir::ClassBytes::difference(p0, p1);
+<hir::ClassBytes>::difference(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::symmetric_difference
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytes
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.symmetric_difference(p1);
+hir::ClassBytes::symmetric_difference(p0, p1);
+crate::hir::ClassBytes::symmetric_difference(p0, p1);
+<hir::ClassBytes>::symmetric_difference(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytes::is_all_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytes
+p0.is_all_ascii();
+hir::ClassBytes::is_all_ascii(p0);
+crate::hir::ClassBytes::is_all_ascii(p0);
+<hir::ClassBytes>::is_all_ascii(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassBytesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassBytesIter<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytesIter<'a>
+p0.next();
+<hir::ClassBytesIter<'a> as std::iter::Iterator>::next(p0);
+crate::<hir::ClassBytesIter<'a> as std::iter::Iterator>::next(p0);
+<hir::ClassBytesIter<'a>>::next(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.clone();
+<hir::ClassBytesRange as std::clone::Clone>::clone(p0);
+crate::<hir::ClassBytesRange as std::clone::Clone>::clone(p0);
+<hir::ClassBytesRange>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::default::Default>::default
deps:{}
candidates:{}
+<hir::ClassBytesRange as std::default::Default>::default();
+crate::<hir::ClassBytesRange as std::default::Default>::default();
+<hir::ClassBytesRange>::default();
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.assert_receiver_is_total_eq();
+<hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::ClassBytesRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::ClassBytesRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.eq(p1);
+<hir::ClassBytesRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::ClassBytesRange as std::cmp::PartialEq>::eq(p0, p1);
+<hir::ClassBytesRange>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.partial_cmp(p1);
+<hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<hir::ClassBytesRange as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<hir::ClassBytesRange>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.cmp(p1);
+<hir::ClassBytesRange as std::cmp::Ord>::cmp(p0, p1);
+crate::<hir::ClassBytesRange as std::cmp::Ord>::cmp(p0, p1);
+<hir::ClassBytesRange>::cmp(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::lower
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.lower();
+<hir::ClassBytesRange as hir::interval::Interval>::lower(p0);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::lower(p0);
+<hir::ClassBytesRange>::lower(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::upper
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.upper();
+<hir::ClassBytesRange as hir::interval::Interval>::upper(p0);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::upper(p0);
+<hir::ClassBytesRange>::upper(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::set_lower
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = 0u8; // None+u8
+p0.set_lower(p1);
+<hir::ClassBytesRange as hir::interval::Interval>::set_lower(p0, p1);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::set_lower(p0, p1);
+<hir::ClassBytesRange>::set_lower(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::set_upper
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = 0u8; // None+u8
+p0.set_upper(p1);
+<hir::ClassBytesRange as hir::interval::Interval>::set_upper(p0, p1);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::set_upper(p0, p1);
+<hir::ClassBytesRange>::set_upper(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<hir::ClassBytesRange>
+p0.case_fold_simple(p1);
+<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+crate::<hir::ClassBytesRange as hir::interval::Interval>::case_fold_simple(p0, p1);
+<hir::ClassBytesRange>::case_fold_simple(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytesRange::new
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+hir::ClassBytesRange::new(p0, p1);
+crate::hir::ClassBytesRange::new(p0, p1);
+<hir::ClassBytesRange>::new(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytesRange::start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.start();
+hir::ClassBytesRange::start(p0);
+crate::hir::ClassBytesRange::start(p0);
+<hir::ClassBytesRange>::start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::ClassBytesRange::end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
+p0.end();
+hir::ClassBytesRange::end(p0);
+crate::hir::ClassBytesRange::end(p0);
+<hir::ClassBytesRange>::end(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::ClassBytesRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::ClassBytesRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::ClassBytesRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::ClassBytesRange as std::fmt::Debug>::fmt(p0, p1);
+<hir::ClassBytesRange>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Anchor as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
+p0.clone();
+<hir::Anchor as std::clone::Clone>::clone(p0);
+crate::<hir::Anchor as std::clone::Clone>::clone(p0);
+<hir::Anchor>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Anchor as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Anchor as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Anchor as std::fmt::Debug>::fmt(p0, p1);
+<hir::Anchor>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Anchor as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
+p0.assert_receiver_is_total_eq();
+<hir::Anchor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Anchor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Anchor>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Anchor as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Anchor
+p0.eq(p1);
+<hir::Anchor as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Anchor as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Anchor>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::WordBoundary as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+p0.clone();
+<hir::WordBoundary as std::clone::Clone>::clone(p0);
+crate::<hir::WordBoundary as std::clone::Clone>::clone(p0);
+<hir::WordBoundary>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::WordBoundary as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::WordBoundary as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::WordBoundary as std::fmt::Debug>::fmt(p0, p1);
+<hir::WordBoundary>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::WordBoundary as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+p0.assert_receiver_is_total_eq();
+<hir::WordBoundary as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::WordBoundary as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::WordBoundary>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::WordBoundary as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+p0.eq(p1);
+<hir::WordBoundary as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::WordBoundary as std::cmp::PartialEq>::eq(p0, p1);
+<hir::WordBoundary>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::WordBoundary::is_negated
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::WordBoundary
+p0.is_negated();
+hir::WordBoundary::is_negated(p0);
+crate::hir::WordBoundary::is_negated(p0);
+<hir::WordBoundary>::is_negated(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Group as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Group
+p0.clone();
+<hir::Group as std::clone::Clone>::clone(p0);
+crate::<hir::Group as std::clone::Clone>::clone(p0);
+<hir::Group>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Group as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Group
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Group as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Group as std::fmt::Debug>::fmt(p0, p1);
+<hir::Group>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Group as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Group
+p0.assert_receiver_is_total_eq();
+<hir::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Group as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Group>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Group as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Group
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Group
+p0.eq(p1);
+<hir::Group as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Group as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Group>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::GroupKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
+p0.clone();
+<hir::GroupKind as std::clone::Clone>::clone(p0);
+crate::<hir::GroupKind as std::clone::Clone>::clone(p0);
+<hir::GroupKind>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::GroupKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::GroupKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::GroupKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
+p0.assert_receiver_is_total_eq();
+<hir::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::GroupKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::GroupKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::GroupKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::GroupKind
+p0.eq(p1);
+<hir::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::GroupKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::GroupKind>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Repetition as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.clone();
+<hir::Repetition as std::clone::Clone>::clone(p0);
+crate::<hir::Repetition as std::clone::Clone>::clone(p0);
+<hir::Repetition>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Repetition as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::Repetition as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::Repetition as std::fmt::Debug>::fmt(p0, p1);
+<hir::Repetition>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.assert_receiver_is_total_eq();
+<hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::Repetition as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::Repetition>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::Repetition as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.eq(p1);
+<hir::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::Repetition as std::cmp::PartialEq>::eq(p0, p1);
+<hir::Repetition>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::Repetition::is_match_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::Repetition
+p0.is_match_empty();
+hir::Repetition::is_match_empty(p0);
+crate::hir::Repetition::is_match_empty(p0);
+<hir::Repetition>::is_match_empty(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
+p0.clone();
+<hir::RepetitionKind as std::clone::Clone>::clone(p0);
+crate::<hir::RepetitionKind as std::clone::Clone>::clone(p0);
+<hir::RepetitionKind>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::RepetitionKind as std::fmt::Debug>::fmt(p0, p1);
+<hir::RepetitionKind>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
+p0.assert_receiver_is_total_eq();
+<hir::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::RepetitionKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::RepetitionKind>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionKind
+p0.eq(p1);
+<hir::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::RepetitionKind as std::cmp::PartialEq>::eq(p0, p1);
+<hir::RepetitionKind>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
+p0.clone();
+<hir::RepetitionRange as std::clone::Clone>::clone(p0);
+crate::<hir::RepetitionRange as std::clone::Clone>::clone(p0);
+<hir::RepetitionRange>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::RepetitionRange as std::fmt::Debug>::fmt(p0, p1);
+<hir::RepetitionRange>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
+p0.assert_receiver_is_total_eq();
+<hir::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::RepetitionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::RepetitionRange>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::RepetitionRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::RepetitionRange
+p0.eq(p1);
+<hir::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::RepetitionRange as std::cmp::PartialEq>::eq(p0, p1);
+<hir::RepetitionRange>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::Hir as std::ops::Drop>::drop
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::Hir
+p0.drop();
+<hir::Hir as std::ops::Drop>::drop(p0);
+crate::<hir::Hir as std::ops::Drop>::drop(p0);
+<hir::Hir>::drop(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirInfo as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.clone();
+<hir::HirInfo as std::clone::Clone>::clone(p0);
+crate::<hir::HirInfo as std::clone::Clone>::clone(p0);
+<hir::HirInfo>::clone(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirInfo as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<hir::HirInfo as std::fmt::Debug>::fmt(p0, p1);
+crate::<hir::HirInfo as std::fmt::Debug>::fmt(p0, p1);
+<hir::HirInfo>::fmt(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirInfo as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.assert_receiver_is_total_eq();
+<hir::HirInfo as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<hir::HirInfo as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<hir::HirInfo>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/hir/mod.rs <hir::HirInfo as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.eq(p1);
+<hir::HirInfo as std::cmp::PartialEq>::eq(p0, p1);
+crate::<hir::HirInfo as std::cmp::PartialEq>::eq(p0, p1);
+<hir::HirInfo>::eq(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::new
deps:{}
candidates:{}
+hir::HirInfo::new();
+crate::hir::HirInfo::new();
+<hir::HirInfo>::new();
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_always_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_always_utf8();
+hir::HirInfo::is_always_utf8(p0);
+crate::hir::HirInfo::is_always_utf8(p0);
+<hir::HirInfo>::is_always_utf8(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_always_utf8
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_always_utf8(p1);
+hir::HirInfo::set_always_utf8(p0, p1);
+crate::hir::HirInfo::set_always_utf8(p0, p1);
+<hir::HirInfo>::set_always_utf8(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_all_assertions
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_all_assertions();
+hir::HirInfo::is_all_assertions(p0);
+crate::hir::HirInfo::is_all_assertions(p0);
+<hir::HirInfo>::is_all_assertions(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_all_assertions
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_all_assertions(p1);
+hir::HirInfo::set_all_assertions(p0, p1);
+crate::hir::HirInfo::set_all_assertions(p0, p1);
+<hir::HirInfo>::set_all_assertions(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_anchored_start();
+hir::HirInfo::is_anchored_start(p0);
+crate::hir::HirInfo::is_anchored_start(p0);
+<hir::HirInfo>::is_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_anchored_start
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_anchored_start(p1);
+hir::HirInfo::set_anchored_start(p0, p1);
+crate::hir::HirInfo::set_anchored_start(p0, p1);
+<hir::HirInfo>::set_anchored_start(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_anchored_end();
+hir::HirInfo::is_anchored_end(p0);
+crate::hir::HirInfo::is_anchored_end(p0);
+<hir::HirInfo>::is_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_anchored_end
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_anchored_end(p1);
+hir::HirInfo::set_anchored_end(p0, p1);
+crate::hir::HirInfo::set_anchored_end(p0, p1);
+<hir::HirInfo>::set_anchored_end(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_line_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_line_anchored_start();
+hir::HirInfo::is_line_anchored_start(p0);
+crate::hir::HirInfo::is_line_anchored_start(p0);
+<hir::HirInfo>::is_line_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_line_anchored_start
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_line_anchored_start(p1);
+hir::HirInfo::set_line_anchored_start(p0, p1);
+crate::hir::HirInfo::set_line_anchored_start(p0, p1);
+<hir::HirInfo>::set_line_anchored_start(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_line_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_line_anchored_end();
+hir::HirInfo::is_line_anchored_end(p0);
+crate::hir::HirInfo::is_line_anchored_end(p0);
+<hir::HirInfo>::is_line_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_line_anchored_end
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_line_anchored_end(p1);
+hir::HirInfo::set_line_anchored_end(p0, p1);
+crate::hir::HirInfo::set_line_anchored_end(p0, p1);
+<hir::HirInfo>::set_line_anchored_end(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_any_anchored_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_any_anchored_start();
+hir::HirInfo::is_any_anchored_start(p0);
+crate::hir::HirInfo::is_any_anchored_start(p0);
+<hir::HirInfo>::is_any_anchored_start(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_any_anchored_start
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_any_anchored_start(p1);
+hir::HirInfo::set_any_anchored_start(p0, p1);
+crate::hir::HirInfo::set_any_anchored_start(p0, p1);
+<hir::HirInfo>::set_any_anchored_start(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_any_anchored_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_any_anchored_end();
+hir::HirInfo::is_any_anchored_end(p0);
+crate::hir::HirInfo::is_any_anchored_end(p0);
+<hir::HirInfo>::is_any_anchored_end(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_any_anchored_end
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_any_anchored_end(p1);
+hir::HirInfo::set_any_anchored_end(p0, p1);
+crate::hir::HirInfo::set_any_anchored_end(p0, p1);
+<hir::HirInfo>::set_any_anchored_end(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_match_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_match_empty();
+hir::HirInfo::is_match_empty(p0);
+crate::hir::HirInfo::is_match_empty(p0);
+<hir::HirInfo>::is_match_empty(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_match_empty
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_match_empty(p1);
+hir::HirInfo::set_match_empty(p0, p1);
+crate::hir::HirInfo::set_match_empty(p0, p1);
+<hir::HirInfo>::set_match_empty(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_literal();
+hir::HirInfo::is_literal(p0);
+crate::hir::HirInfo::is_literal(p0);
+<hir::HirInfo>::is_literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_literal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_literal(p1);
+hir::HirInfo::set_literal(p0, p1);
+crate::hir::HirInfo::set_literal(p0, p1);
+<hir::HirInfo>::set_literal(p0, p1);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::is_alternation_literal
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // hir::HirInfo
+p0.is_alternation_literal();
+hir::HirInfo::is_alternation_literal(p0);
+crate::hir::HirInfo::is_alternation_literal(p0);
+<hir::HirInfo>::is_alternation_literal(p0);
-----------------
regex-syntax/src/hir/mod.rs hir::HirInfo::set_alternation_literal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // hir::HirInfo
let mut p1 = true; // None+bool
+p0.set_alternation_literal(p1);
+hir::HirInfo::set_alternation_literal(p0, p1);
+crate::hir::HirInfo::set_alternation_literal(p0, p1);
+<hir::HirInfo>::set_alternation_literal(p0, p1);
-----------------
regex-syntax/src/parser.rs <parser::ParserBuilder as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
+p0.clone();
+<parser::ParserBuilder as std::clone::Clone>::clone(p0);
+crate::<parser::ParserBuilder as std::clone::Clone>::clone(p0);
+<parser::ParserBuilder>::clone(p0);
-----------------
regex-syntax/src/parser.rs <parser::ParserBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::ParserBuilder as std::fmt::Debug>::fmt(p0, p1);
+<parser::ParserBuilder>::fmt(p0, p1);
-----------------
regex-syntax/src/parser.rs <parser::ParserBuilder as std::default::Default>::default
deps:{}
candidates:{}
+<parser::ParserBuilder as std::default::Default>::default();
+crate::<parser::ParserBuilder as std::default::Default>::default();
+<parser::ParserBuilder>::default();
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::new
deps:{}
candidates:{}
+parser::ParserBuilder::new();
+crate::parser::ParserBuilder::new();
+<parser::ParserBuilder>::new();
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
+p0.build();
+parser::ParserBuilder::build(p0);
+crate::parser::ParserBuilder::build(p0);
+<parser::ParserBuilder>::build(p0);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+parser::ParserBuilder::nest_limit(p0, p1);
+crate::parser::ParserBuilder::nest_limit(p0, p1);
+<parser::ParserBuilder>::nest_limit(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+parser::ParserBuilder::octal(p0, p1);
+crate::parser::ParserBuilder::octal(p0, p1);
+<parser::ParserBuilder>::octal(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::allow_invalid_utf8
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.allow_invalid_utf8(p1);
+parser::ParserBuilder::allow_invalid_utf8(p0, p1);
+crate::parser::ParserBuilder::allow_invalid_utf8(p0, p1);
+<parser::ParserBuilder>::allow_invalid_utf8(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+parser::ParserBuilder::ignore_whitespace(p0, p1);
+crate::parser::ParserBuilder::ignore_whitespace(p0, p1);
+<parser::ParserBuilder>::ignore_whitespace(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+parser::ParserBuilder::case_insensitive(p0, p1);
+crate::parser::ParserBuilder::case_insensitive(p0, p1);
+<parser::ParserBuilder>::case_insensitive(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+parser::ParserBuilder::multi_line(p0, p1);
+crate::parser::ParserBuilder::multi_line(p0, p1);
+<parser::ParserBuilder>::multi_line(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+parser::ParserBuilder::dot_matches_new_line(p0, p1);
+crate::parser::ParserBuilder::dot_matches_new_line(p0, p1);
+<parser::ParserBuilder>::dot_matches_new_line(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+parser::ParserBuilder::swap_greed(p0, p1);
+crate::parser::ParserBuilder::swap_greed(p0, p1);
+<parser::ParserBuilder>::swap_greed(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::ParserBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::ParserBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+parser::ParserBuilder::unicode(p0, p1);
+crate::parser::ParserBuilder::unicode(p0, p1);
+<parser::ParserBuilder>::unicode(p0, p1);
-----------------
regex-syntax/src/parser.rs <parser::Parser as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::Parser
+p0.clone();
+<parser::Parser as std::clone::Clone>::clone(p0);
+crate::<parser::Parser as std::clone::Clone>::clone(p0);
+<parser::Parser>::clone(p0);
-----------------
regex-syntax/src/parser.rs <parser::Parser as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // parser::Parser
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<parser::Parser as std::fmt::Debug>::fmt(p0, p1);
+crate::<parser::Parser as std::fmt::Debug>::fmt(p0, p1);
+<parser::Parser>::fmt(p0, p1);
-----------------
regex-syntax/src/parser.rs parser::Parser::new
deps:{}
candidates:{}
+parser::Parser::new();
+crate::parser::Parser::new();
+<parser::Parser>::new();
-----------------
regex-syntax/src/parser.rs parser::Parser::parse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // parser::Parser
let mut p1 = "sample"; // None+&str
+p0.parse(&p1);
+parser::Parser::parse(p0, &p1);
+crate::parser::Parser::parse(p0, &p1);
+<parser::Parser>::parse(p0, &p1);
-----------------
regex-syntax/src/unicode.rs <unicode::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::Error as std::fmt::Debug>::fmt(p0, p1);
+<unicode::Error>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::CaseFoldError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CaseFoldError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::CaseFoldError as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::CaseFoldError as std::fmt::Debug>::fmt(p0, p1);
+<unicode::CaseFoldError>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::CaseFoldError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CaseFoldError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<unicode::CaseFoldError as std::fmt::Display>::fmt(p0, p1);
+crate::<unicode::CaseFoldError as std::fmt::Display>::fmt(p0, p1);
+<unicode::CaseFoldError>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::UnicodeWordError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::UnicodeWordError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::UnicodeWordError as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::UnicodeWordError as std::fmt::Debug>::fmt(p0, p1);
+<unicode::UnicodeWordError>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::UnicodeWordError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::UnicodeWordError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<unicode::UnicodeWordError as std::fmt::Display>::fmt(p0, p1);
+crate::<unicode::UnicodeWordError as std::fmt::Display>::fmt(p0, p1);
+<unicode::UnicodeWordError>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::ClassQuery<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::ClassQuery<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::ClassQuery<'a> as std::fmt::Debug>::fmt(p0, p1);
+<unicode::ClassQuery<'a>>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs unicode::ClassQuery::<'a>::canonicalize
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'a>
+p0.canonicalize();
+unicode::ClassQuery::<'a>::canonicalize(p0);
+crate::unicode::ClassQuery::<'a>::canonicalize(p0);
+<unicode::ClassQuery<'a>>::canonicalize(p0);
-----------------
regex-syntax/src/unicode.rs unicode::ClassQuery::<'a>::canonical_binary
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::ClassQuery<'a>
let mut p1 = "sample"; // None+&str
+p0.canonical_binary(&p1);
+unicode::ClassQuery::<'a>::canonical_binary(p0, &p1);
+crate::unicode::ClassQuery::<'a>::canonical_binary(p0, &p1);
+<unicode::ClassQuery<'a>>::canonical_binary(p0, &p1);
-----------------
regex-syntax/src/unicode.rs <unicode::CanonicalClassQuery as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<unicode::CanonicalClassQuery as std::fmt::Debug>::fmt(p0, p1);
+crate::<unicode::CanonicalClassQuery as std::fmt::Debug>::fmt(p0, p1);
+<unicode::CanonicalClassQuery>::fmt(p0, p1);
-----------------
regex-syntax/src/unicode.rs <unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
+p0.assert_receiver_is_total_eq();
+<unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<unicode::CanonicalClassQuery as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<unicode::CanonicalClassQuery>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/unicode.rs <unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
let mut p1 = & MaybeUninit::uninit().assume_init(); // unicode::CanonicalClassQuery
+p0.eq(p1);
+<unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq(p0, p1);
+crate::<unicode::CanonicalClassQuery as std::cmp::PartialEq>::eq(p0, p1);
+<unicode::CanonicalClassQuery>::eq(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.clone();
+<utf8::Utf8Sequence as std::clone::Clone>::clone(p0);
+crate::<utf8::Utf8Sequence as std::clone::Clone>::clone(p0);
+<utf8::Utf8Sequence>::clone(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.assert_receiver_is_total_eq();
+<utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<utf8::Utf8Sequence as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<utf8::Utf8Sequence>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.eq(p1);
+<utf8::Utf8Sequence as std::cmp::PartialEq>::eq(p0, p1);
+crate::<utf8::Utf8Sequence as std::cmp::PartialEq>::eq(p0, p1);
+<utf8::Utf8Sequence>::eq(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.partial_cmp(p1);
+<utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<utf8::Utf8Sequence as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<utf8::Utf8Sequence>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.cmp(p1);
+<utf8::Utf8Sequence as std::cmp::Ord>::cmp(p0, p1);
+crate::<utf8::Utf8Sequence as std::cmp::Ord>::cmp(p0, p1);
+<utf8::Utf8Sequence>::cmp(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::from_encoded_range
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+utf8::Utf8Sequence::from_encoded_range(p0, p1);
+crate::utf8::Utf8Sequence::from_encoded_range(p0, p1);
+<utf8::Utf8Sequence>::from_encoded_range(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::as_slice
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.as_slice();
+utf8::Utf8Sequence::as_slice(p0);
+crate::utf8::Utf8Sequence::as_slice(p0);
+<utf8::Utf8Sequence>::as_slice(p0);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.len();
+utf8::Utf8Sequence::len(p0);
+crate::utf8::Utf8Sequence::len(p0);
+<utf8::Utf8Sequence>::len(p0);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::reverse
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.reverse();
+utf8::Utf8Sequence::reverse(p0);
+crate::utf8::Utf8Sequence::reverse(p0);
+<utf8::Utf8Sequence>::reverse(p0);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequence::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.matches(p1);
+utf8::Utf8Sequence::matches(p0, p1);
+crate::utf8::Utf8Sequence::matches(p0, p1);
+<utf8::Utf8Sequence>::matches(p0, p1);
-----------------
regex-syntax/src/utf8.rs <&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
+p0.into_iter();
+<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a utf8::Utf8Sequence as std::iter::IntoIterator>::into_iter(p0);
+<&'a utf8::Utf8Sequence>::into_iter(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequence as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequence
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::Utf8Sequence as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::Utf8Sequence as std::fmt::Debug>::fmt(p0, p1);
+<utf8::Utf8Sequence>::fmt(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.clone();
+<utf8::Utf8Range as std::clone::Clone>::clone(p0);
+crate::<utf8::Utf8Range as std::clone::Clone>::clone(p0);
+<utf8::Utf8Range>::clone(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.assert_receiver_is_total_eq();
+<utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<utf8::Utf8Range as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<utf8::Utf8Range>::assert_receiver_is_total_eq(p0);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.eq(p1);
+<utf8::Utf8Range as std::cmp::PartialEq>::eq(p0, p1);
+crate::<utf8::Utf8Range as std::cmp::PartialEq>::eq(p0, p1);
+<utf8::Utf8Range>::eq(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.partial_cmp(p1);
+<utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<utf8::Utf8Range as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<utf8::Utf8Range>::partial_cmp(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
+p0.cmp(p1);
+<utf8::Utf8Range as std::cmp::Ord>::cmp(p0, p1);
+crate::<utf8::Utf8Range as std::cmp::Ord>::cmp(p0, p1);
+<utf8::Utf8Range>::cmp(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Range::new
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+utf8::Utf8Range::new(p0, p1);
+crate::utf8::Utf8Range::new(p0, p1);
+<utf8::Utf8Range>::new(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Range::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = 0u8; // None+u8
+p0.matches(p1);
+utf8::Utf8Range::matches(p0, p1);
+crate::utf8::Utf8Range::matches(p0, p1);
+<utf8::Utf8Range>::matches(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Range as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Range
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::Utf8Range as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::Utf8Range as std::fmt::Debug>::fmt(p0, p1);
+<utf8::Utf8Range>::fmt(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequences as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::Utf8Sequences as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::Utf8Sequences as std::fmt::Debug>::fmt(p0, p1);
+<utf8::Utf8Sequences>::fmt(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequences::new
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
let mut p1 = 'a'; // None+char
+utf8::Utf8Sequences::new(p0, p1);
+crate::utf8::Utf8Sequences::new(p0, p1);
+<utf8::Utf8Sequences>::new(p0, p1);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequences::reset
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
let mut p1 = 'a'; // None+char
let mut p2 = 'a'; // None+char
+p0.reset(p1, p2);
+utf8::Utf8Sequences::reset(p0, p1, p2);
+crate::utf8::Utf8Sequences::reset(p0, p1, p2);
+<utf8::Utf8Sequences>::reset(p0, p1, p2);
-----------------
regex-syntax/src/utf8.rs utf8::Utf8Sequences::push
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
let mut p1 = 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+p0.push(p1, p2);
+utf8::Utf8Sequences::push(p0, p1, p2);
+crate::utf8::Utf8Sequences::push(p0, p1, p2);
+<utf8::Utf8Sequences>::push(p0, p1, p2);
-----------------
regex-syntax/src/utf8.rs <utf8::ScalarRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utf8::ScalarRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<utf8::ScalarRange as std::fmt::Debug>::fmt(p0, p1);
+<utf8::ScalarRange>::fmt(p0, p1);
-----------------
regex-syntax/src/utf8.rs <utf8::Utf8Sequences as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // utf8::Utf8Sequences
+p0.next();
+<utf8::Utf8Sequences as std::iter::Iterator>::next(p0);
+crate::<utf8::Utf8Sequences as std::iter::Iterator>::next(p0);
+<utf8::Utf8Sequences>::next(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::split
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.split();
+utf8::ScalarRange::split(p0);
+crate::utf8::ScalarRange::split(p0);
+<utf8::ScalarRange>::split(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::is_valid
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.is_valid();
+utf8::ScalarRange::is_valid(p0);
+crate::utf8::ScalarRange::is_valid(p0);
+<utf8::ScalarRange>::is_valid(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::as_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.as_ascii();
+utf8::ScalarRange::as_ascii(p0);
+crate::utf8::ScalarRange::as_ascii(p0);
+<utf8::ScalarRange>::as_ascii(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::is_ascii
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
+p0.is_ascii();
+utf8::ScalarRange::is_ascii(p0);
+crate::utf8::ScalarRange::is_ascii(p0);
+<utf8::ScalarRange>::is_ascii(p0);
-----------------
regex-syntax/src/utf8.rs utf8::ScalarRange::encode
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utf8::ScalarRange
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
let mut p2 = &mut [0u8].as_mut_slice(); // None+[u8]
+p0.encode(p1, p2);
+utf8::ScalarRange::encode(p0, p1, p2);
+crate::utf8::ScalarRange::encode(p0, p1, p2);
+<utf8::ScalarRange>::encode(p0, p1, p2);
-----------------
src/backtrack.rs backtrack::should_exec
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
+backtrack::should_exec(p0, p1);
+crate::backtrack::should_exec(p0, p1);
+crate::backtrack::should_exec(p0, p1);
-----------------
src/backtrack.rs backtrack::usize_to_u32
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+backtrack::usize_to_u32(p0);
+crate::backtrack::usize_to_u32(p0);
+crate::backtrack::usize_to_u32(p0);
-----------------
src/compile.rs compile::u32_to_usize
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+compile::u32_to_usize(p0);
+crate::compile::u32_to_usize(p0);
+crate::compile::u32_to_usize(p0);
-----------------
src/dfa.rs dfa::can_exec
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+dfa::can_exec(p0);
+crate::dfa::can_exec(p0);
+crate::dfa::can_exec(p0);
-----------------
src/dfa.rs dfa::push_inst_ptr
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p1 = &mut 0u32; // None+u32
let mut p2 = 0u32; // None+u32
+dfa::push_inst_ptr(p0, p1, p2);
+crate::dfa::push_inst_ptr(p0, p1, p2);
+crate::dfa::push_inst_ptr(p0, p1, p2);
-----------------
src/dfa.rs dfa::vb
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+dfa::vb(p0);
+crate::dfa::vb(p0);
+crate::dfa::vb(p0);
-----------------
src/dfa.rs dfa::usize_to_u32
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+dfa::usize_to_u32(p0);
+crate::dfa::usize_to_u32(p0);
+crate::dfa::usize_to_u32(p0);
-----------------
src/dfa.rs dfa::show_state_ptr
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+dfa::show_state_ptr(p0);
+crate::dfa::show_state_ptr(p0);
+crate::dfa::show_state_ptr(p0);
-----------------
src/dfa.rs dfa::write_vari32
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p1 = 0i32; // None+i32
+dfa::write_vari32(p0, p1);
+crate::dfa::write_vari32(p0, p1);
+crate::dfa::write_vari32(p0, p1);
-----------------
src/dfa.rs dfa::read_vari32
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+dfa::read_vari32(p0);
+crate::dfa::read_vari32(p0);
+crate::dfa::read_vari32(p0);
-----------------
src/dfa.rs dfa::write_varu32
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p1 = 0u32; // None+u32
+dfa::write_varu32(p0, p1);
+crate::dfa::write_varu32(p0, p1);
+crate::dfa::write_varu32(p0, p1);
-----------------
src/dfa.rs dfa::read_varu32
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+dfa::read_varu32(p0);
+crate::dfa::read_varu32(p0);
+crate::dfa::read_varu32(p0);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::is_anchor_end_match::imp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+exec::ExecNoSync::<'c>::is_anchor_end_match::imp(p0, p1);
+crate::exec::ExecNoSync::<'c>::is_anchor_end_match::imp(p0, p1);
+<exec::ExecNoSync<'c>>::is_anchor_end_match::imp(p0, p1);
-----------------
src/exec.rs exec::ExecReadOnly::choose_literal_match_type::imp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+exec::ExecReadOnly::choose_literal_match_type::imp(p0);
+crate::exec::ExecReadOnly::choose_literal_match_type::imp(p0);
+<exec::ExecReadOnly>::choose_literal_match_type::imp(p0);
-----------------
src/exec.rs exec::ExecReadOnly::choose_dfa_match_type::imp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+exec::ExecReadOnly::choose_dfa_match_type::imp(p0);
+crate::exec::ExecReadOnly::choose_dfa_match_type::imp(p0);
+<exec::ExecReadOnly>::choose_dfa_match_type::imp(p0);
-----------------
src/exec.rs exec::alternation_literals
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Hir
+exec::alternation_literals(p0);
+crate::exec::alternation_literals(p0);
+crate::exec::alternation_literals(p0);
-----------------
src/expand.rs expand::expand_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p1 = "sample"; // None+&str
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+expand::expand_str(p0, &p1, p2);
+crate::expand::expand_str(p0, &p1, p2);
+crate::expand::expand_str(p0, &p1, p2);
-----------------
src/expand.rs expand::expand_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+expand::expand_bytes(p0, p1, p2);
+crate::expand::expand_bytes(p0, p1, p2);
+crate::expand::expand_bytes(p0, p1, p2);
-----------------
src/expand.rs expand::find_cap_ref
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+expand::find_cap_ref(p0);
+crate::expand::find_cap_ref(p0);
+crate::expand::find_cap_ref(p0);
-----------------
src/expand.rs expand::find_cap_ref_braced
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
+expand::find_cap_ref_braced(p0, p1);
+crate::expand::find_cap_ref_braced(p0, p1);
+crate::expand::find_cap_ref_braced(p0, p1);
-----------------
src/expand.rs expand::is_valid_cap_letter
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+expand::is_valid_cap_letter(p0);
+crate::expand::is_valid_cap_letter(p0);
+crate::expand::is_valid_cap_letter(p0);
-----------------
src/find_byte.rs find_byte::find_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+find_byte::find_byte(p0, p1);
+crate::find_byte::find_byte(p0, p1);
+crate::find_byte::find_byte(p0, p1);
-----------------
src/find_byte.rs find_byte::find_byte::imp
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+find_byte::find_byte::imp(p0, p1);
+crate::find_byte::find_byte::imp(p0, p1);
+crate::find_byte::find_byte::imp(p0, p1);
-----------------
src/literal/imp.rs literal::imp::char_len_lossy
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+literal::imp::char_len_lossy(p0);
+crate::literal::imp::char_len_lossy(p0);
+crate::literal::imp::char_len_lossy(p0);
-----------------
src/literal/imp.rs literal::imp::freq_rank
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+literal::imp::freq_rank(p0);
+crate::literal::imp::freq_rank(p0);
+crate::literal::imp::freq_rank(p0);
-----------------
src/prog.rs <prog::Program as std::fmt::Debug>::fmt::with_goto
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = std::string::String::new(); // None+std::string::String
+<prog::Program as std::fmt::Debug>::fmt::with_goto(p0, p1, p2);
+crate::<prog::Program as std::fmt::Debug>::fmt::with_goto(p0, p1, p2);
+<prog::Program>::fmt::with_goto(p0, p1, p2);
-----------------
src/prog.rs <prog::Program as std::fmt::Debug>::fmt::visible_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<prog::Program as std::fmt::Debug>::fmt::visible_byte(p0);
+crate::<prog::Program as std::fmt::Debug>::fmt::visible_byte(p0);
+<prog::Program>::fmt::visible_byte(p0);
-----------------
src/re_bytes.rs <re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_bytes(p0);
+crate::<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_bytes(p0);
+<re_bytes::CapturesDebug<'c, 't>>::fmt::escape_bytes(p0);
-----------------
src/re_bytes.rs <re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_byte(p0);
+crate::<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_byte(p0);
+<re_bytes::CapturesDebug<'c, 't>>::fmt::escape_byte(p0);
-----------------
src/re_set.rs re_set::unicode::as_bytes_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_set::unicode::as_bytes_str(&p0);
+crate::re_set::unicode::as_bytes_str(&p0);
+crate::re_set::unicode::as_bytes_str(&p0);
-----------------
src/re_set.rs re_set::unicode::as_bytes_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+re_set::unicode::as_bytes_bytes(p0);
+crate::re_set::unicode::as_bytes_bytes(p0);
+crate::re_set::unicode::as_bytes_bytes(p0);
-----------------
src/re_set.rs re_set::bytes::as_bytes_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_set::bytes::as_bytes_str(&p0);
+crate::re_set::bytes::as_bytes_str(&p0);
+crate::re_set::bytes::as_bytes_str(&p0);
-----------------
src/re_set.rs re_set::bytes::as_bytes_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+re_set::bytes::as_bytes_bytes(p0);
+crate::re_set::bytes::as_bytes_bytes(p0);
+crate::re_set::bytes::as_bytes_bytes(p0);
-----------------
src/re_unicode.rs re_unicode::escape
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_unicode::escape(&p0);
+crate::re_unicode::escape(&p0);
+crate::re_unicode::escape(&p0);
-----------------
src/utf8.rs utf8::next_utf8
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
+utf8::next_utf8(p0, p1);
+crate::utf8::next_utf8(p0, p1);
+crate::utf8::next_utf8(p0, p1);
-----------------
src/utf8.rs utf8::decode_utf8
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+utf8::decode_utf8(p0);
+crate::utf8::decode_utf8(p0);
+crate::utf8::decode_utf8(p0);
-----------------
src/utf8.rs utf8::decode_last_utf8
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+utf8::decode_last_utf8(p0);
+crate::utf8::decode_last_utf8(p0);
+crate::utf8::decode_last_utf8(p0);
-----------------
src/utf8.rs utf8::is_start_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+utf8::is_start_byte(p0);
+crate::utf8::is_start_byte(p0);
+crate::utf8::is_start_byte(p0);
-----------------
src/input.rs input::Input::at
deps:{"input::Input::at":{"Self":["input::Input","std::fmt::Debug"]}}
candidates:{"input::Input::at":{"Self":["input::ByteInput","input::CharInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.at(p1);
+input::Input::at(p0, p1);
+crate::input::Input::at(p0, p1);
+crate::input::Input::at(p0, p1);
-----------------
src/input.rs input::Input::next_char
deps:{"input::Input::next_char":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::next_char":{"Self":["input::CharInput","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_char(p1);
+input::Input::next_char(p0, p1);
+crate::input::Input::next_char(p0, p1);
+crate::input::Input::next_char(p0, p1);
-----------------
src/input.rs input::Input::previous_char
deps:{"input::Input::previous_char":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::previous_char":{"Self":["input::ByteInput","input::CharInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.previous_char(p1);
+input::Input::previous_char(p0, p1);
+crate::input::Input::previous_char(p0, p1);
+crate::input::Input::previous_char(p0, p1);
-----------------
src/input.rs input::Input::is_empty_match
deps:{"input::Input::is_empty_match":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::is_empty_match":{"Self":["input::CharInput","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.is_empty_match(p1, p2);
+input::Input::is_empty_match(p0, p1, p2);
+crate::input::Input::is_empty_match(p0, p1, p2);
+crate::input::Input::is_empty_match(p0, p1, p2);
-----------------
src/input.rs input::Input::prefix_at
deps:{"input::Input::prefix_at":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::prefix_at":{"Self":["input::ByteInput","input::CharInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.prefix_at(p1, p2);
+input::Input::prefix_at(p0, p1, p2);
+crate::input::Input::prefix_at(p0, p1, p2);
+crate::input::Input::prefix_at(p0, p1, p2);
-----------------
src/input.rs input::Input::len
deps:{"input::Input::len":{"Self":["std::fmt::Debug","input::Input"]}}
candidates:{"input::Input::len":{"Self":["input::ByteInput","input::CharInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.len();
+input::Input::len(p0);
+crate::input::Input::len(p0);
+crate::input::Input::len(p0);
-----------------
src/input.rs input::Input::is_empty
deps:{"input::Input::is_empty":{"Self":["input::Input","std::fmt::Debug"]}}
candidates:{"input::Input::is_empty":{"Self":["input::CharInput","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.is_empty();
+input::Input::is_empty(p0);
+crate::input::Input::is_empty(p0);
+crate::input::Input::is_empty(p0);
-----------------
src/input.rs input::Input::as_bytes
deps:{"input::Input::as_bytes":{"Self":["input::Input","std::fmt::Debug"]}}
candidates:{"input::Input::as_bytes":{"Self":["input::ByteInput","input::CharInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.as_bytes();
+input::Input::as_bytes(p0);
+crate::input::Input::as_bytes(p0);
+crate::input::Input::as_bytes(p0);
-----------------
src/re_bytes.rs re_bytes::Replacer::replace_append
deps:{"<F as re_bytes::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"re_bytes::Replacer::replace_append":{"Self":["re_bytes::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_bytes::Replacer>":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"re_bytes::Replacer::replace_append":{"Self":["re_bytes::NoExpand","re_bytes::ReplacerRef","<F as re_bytes::Replacer>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+re_bytes::Replacer::replace_append(p0, p1, p2);
+crate::re_bytes::Replacer::replace_append(p0, p1, p2);
+crate::re_bytes::Replacer::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Replacer::no_expansion
deps:{"<F as re_bytes::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"re_bytes::Replacer::no_expansion":{"Self":["re_bytes::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_bytes::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeDefault"]},"re_bytes::Replacer::no_expansion":{"Self":["re_bytes::ReplacerRef","re_bytes::NoExpand","<F as re_bytes::Replacer>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.no_expansion();
+re_bytes::Replacer::no_expansion(p0);
+crate::re_bytes::Replacer::no_expansion(p0);
+crate::re_bytes::Replacer::no_expansion(p0);
-----------------
src/re_bytes.rs re_bytes::Replacer::by_ref
deps:{"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"re_bytes::Replacer::by_ref":{"Self":["re_bytes::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_bytes::Replacer>":{"F":["core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue"]},"re_bytes::Replacer::by_ref":{"Self":["re_bytes::ReplacerRef","<F as re_bytes::Replacer>","re_bytes::NoExpand"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.by_ref();
+re_bytes::Replacer::by_ref(p0);
+crate::re_bytes::Replacer::by_ref(p0);
+crate::re_bytes::Replacer::by_ref(p0);
-----------------
src/re_trait.rs re_trait::RegularExpression::slots_len
deps:{"re_trait::RegularExpression::slots_len":{"Self":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]}}
candidates:{"re_trait::RegularExpression::slots_len":{"Self":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.slots_len();
+re_trait::RegularExpression::slots_len(p0);
+crate::re_trait::RegularExpression::slots_len(p0);
+crate::re_trait::RegularExpression::slots_len(p0);
-----------------
src/re_trait.rs re_trait::RegularExpression::locations
deps:{"re_trait::RegularExpression::locations":{"Self":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]}}
candidates:{"re_trait::RegularExpression::locations":{"Self":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.locations();
+re_trait::RegularExpression::locations(p0);
+crate::re_trait::RegularExpression::locations(p0);
+crate::re_trait::RegularExpression::locations(p0);
-----------------
src/re_trait.rs re_trait::RegularExpression::next_after_empty
deps:{"re_trait::RegularExpression::next_after_empty":{"Self":["std::fmt::Debug","re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"re_trait::RegularExpression::next_after_empty":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p2 = 0usize; // None+usize
+p0.next_after_empty(p1, p2);
+re_trait::RegularExpression::next_after_empty(p0, p1, p2);
+crate::re_trait::RegularExpression::next_after_empty(p0, p1, p2);
+crate::re_trait::RegularExpression::next_after_empty(p0, p1, p2);
-----------------
src/re_trait.rs re_trait::RegularExpression::shortest_match_at
deps:{"re_trait::RegularExpression::shortest_match_at":{"Self":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]}}
candidates:{"re_trait::RegularExpression::shortest_match_at":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(p1, p2);
+re_trait::RegularExpression::shortest_match_at(p0, p1, p2);
+crate::re_trait::RegularExpression::shortest_match_at(p0, p1, p2);
+crate::re_trait::RegularExpression::shortest_match_at(p0, p1, p2);
-----------------
src/re_trait.rs re_trait::RegularExpression::is_match_at
deps:{"re_trait::RegularExpression::is_match_at":{"Self":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"re_trait::RegularExpression::is_match_at":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p2 = 0usize; // None+usize
+p0.is_match_at(p1, p2);
+re_trait::RegularExpression::is_match_at(p0, p1, p2);
+crate::re_trait::RegularExpression::is_match_at(p0, p1, p2);
+crate::re_trait::RegularExpression::is_match_at(p0, p1, p2);
-----------------
src/re_trait.rs re_trait::RegularExpression::find_at
deps:{"re_trait::RegularExpression::find_at":{"Self":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"re_trait::RegularExpression::find_at":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p2 = 0usize; // None+usize
+p0.find_at(p1, p2);
+re_trait::RegularExpression::find_at(p0, p1, p2);
+crate::re_trait::RegularExpression::find_at(p0, p1, p2);
+crate::re_trait::RegularExpression::find_at(p0, p1, p2);
-----------------
src/re_trait.rs re_trait::RegularExpression::captures_read_at
deps:{"re_trait::RegularExpression::captures_read_at":{"Self":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]}}
candidates:{"re_trait::RegularExpression::captures_read_at":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p2 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, p2, p3);
+re_trait::RegularExpression::captures_read_at(p0, p1, p2, p3);
+crate::re_trait::RegularExpression::captures_read_at(p0, p1, p2, p3);
+crate::re_trait::RegularExpression::captures_read_at(p0, p1, p2, p3);
-----------------
src/re_trait.rs re_trait::RegularExpression::find_iter
deps:{"re_trait::RegularExpression::find_iter":{"Self":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]}}
candidates:{"re_trait::RegularExpression::find_iter":{"Self":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
+p0.find_iter(p1);
+re_trait::RegularExpression::find_iter(p0, p1);
+crate::re_trait::RegularExpression::find_iter(p0, p1);
+crate::re_trait::RegularExpression::find_iter(p0, p1);
-----------------
src/re_trait.rs re_trait::RegularExpression::captures_iter
deps:{"re_trait::RegularExpression::captures_iter":{"Self":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"re_trait::RegularExpression::captures_iter":{"Self":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // <Self as re_trait::RegularExpression>::Text
+p0.captures_iter(p1);
+re_trait::RegularExpression::captures_iter(p0, p1);
+crate::re_trait::RegularExpression::captures_iter(p0, p1);
+crate::re_trait::RegularExpression::captures_iter(p0, p1);
-----------------
src/re_unicode.rs re_unicode::Replacer::replace_append
deps:{"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"re_unicode::Replacer::replace_append":{"Self":["re_unicode::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_unicode::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty"]},"re_unicode::Replacer::replace_append":{"Self":["re_unicode::NoExpand","<F as re_unicode::Replacer>","re_unicode::ReplacerRef"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+re_unicode::Replacer::replace_append(p0, p1, p2);
+crate::re_unicode::Replacer::replace_append(p0, p1, p2);
+crate::re_unicode::Replacer::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs re_unicode::Replacer::no_expansion
deps:{"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"re_unicode::Replacer::no_expansion":{"Self":["re_unicode::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_unicode::Replacer>":{"F":["core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"]},"re_unicode::Replacer::no_expansion":{"Self":["re_unicode::NoExpand","re_unicode::ReplacerRef","<F as re_unicode::Replacer>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.no_expansion();
+re_unicode::Replacer::no_expansion(p0);
+crate::re_unicode::Replacer::no_expansion(p0);
+crate::re_unicode::Replacer::no_expansion(p0);
-----------------
src/re_unicode.rs re_unicode::Replacer::by_ref
deps:{"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"re_unicode::Replacer::by_ref":{"Self":["re_unicode::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_unicode::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault"]},"re_unicode::Replacer::by_ref":{"Self":["re_unicode::NoExpand","re_unicode::ReplacerRef","<F as re_unicode::Replacer>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.by_ref();
+re_unicode::Replacer::by_ref(p0);
+crate::re_unicode::Replacer::by_ref(p0);
+crate::re_unicode::Replacer::by_ref(p0);
-----------------
src/backtrack.rs <backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt
'a,'m,'r,'s
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"backtrack::Bounded":{"I":["input::Input","std::fmt::Debug","std::marker::Sized"]},"cache::imp::Cached":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"cache::imp::CachedGuard":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"dfa::Result":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"pikevm::Fsm":{"I":["input::Input","std::marker::Sized","std::fmt::Debug"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt":{"I":["pikevm::FollowEpsilon","re_builder::bytes::RegexBuilder","re_unicode::Regex","re_bytes::CapturesDebug","re_unicode::SplitN","re_builder::set_bytes::RegexSetBuilder","dfa::StateMap","re_unicode::ReplacerRef","backtrack::Cache","backtrack::Bounded","literal::imp::LiteralIter","re_trait::Matches","literal::imp::SingleByteSet","prog::EmptyLook","re_unicode::CaptureNames","re_builder::unicode::RegexBuilder","prog::Inst","compile::SuffixCacheEntry","compile::ByteClassSet","re_set::bytes::RegexSet","dfa::TransitionsRow","sparse::SparseSet","re_unicode::CaptureMatches","compile::InstHole","<*const T as std::fmt::Debug>","expand::CaptureRef","re_bytes::NoExpand","re_trait::SubCapturesPosIter","re_bytes::CaptureLocations","re_unicode::Match","dfa::Fsm","re_bytes::SubCaptureMatches","prog::Program","dfa::CacheInner","compile::SuffixCacheKey","re_unicode::Split","re_unicode::Captures","re_set::bytes::SetMatchesIter","literal::imp::FreqyPacked","cache::imp::CachedGuard","re_set::bytes::SetMatchesIntoIter","literal::imp::BoyerMooreSearch","dfa::Result","re_set::unicode::SetMatchesIntoIter","dfa::Byte","dfa::Transitions","re_trait::Locations","cache::imp::Cached","input::InputAt","exec::ProgramCacheInner","compile::SuffixCache","exec::ExecNoSyncStr","re_set::unicode::SetMatches","compile::Patch","compile::Hole","prog::InstSplit","re_bytes::Matches","re_builder::RegexOptions","prog::InstRanges","backtrack::Job","exec::MatchNfaType","pikevm::Threads","re_bytes::CaptureMatches","prog::InstChar","expand::Ref","re_bytes::SplitN","re_bytes::Split","prog::InstSave","input::CharInput","dfa::Cache","dfa::StateFlags","re_bytes::Regex","exec::ExecReadOnly","re_unicode::CapturesDebug","compile::MaybeInst","re_bytes::ReplacerRef","exec::MatchLiteralType","re_builder::set_unicode::RegexSetBuilder","re_unicode::NoExpand","re_unicode::SubCaptureMatches","literal::imp::Matcher","dfa::State","literal::imp::LiteralSearcher","re_set::unicode::SetMatchesIter","re_unicode::CaptureLocations","error::Error","exec::Exec","re_unicode::Matches","re_set::bytes::SetMatches","pikevm::Cache","prog::InstEmptyLook","pikevm::Fsm","re_set::unicode::RegexSet","input::Char","prog::InstBytes","re_bytes::CaptureNames","re_bytes::Match","re_trait::CaptureMatches","re_bytes::Captures","exec::ExecNoSync","exec::MatchType","input::ByteInput","<*mut T as std::fmt::Debug>","dfa::EmptyFlags"]},"backtrack::Bounded":{"I":["input::ByteInput","input::CharInput"]},"cache::imp::Cached":{"T":["std::collections::vec_deque::Drain<'_, T, A>","std::collections::LinkedList<T>","std::cell::Cell<T>","std::sync::Mutex<T>","std::sys::unix::args::Args","std::vec::IntoIter<T, A>","std::sync::mpsc::SyncSender<T>","std::future::ResumeTy","std::sync::mpmc::Receiver<T>","std::sync::RwLock<T>","std::sync::mpsc::Receiver<T>","std::collections::linked_list::Iter<'_, T>","std::slice::Iter<'_, T>","std::sync::MutexGuard<'_, T>","std::io::error::repr_bitpacked::Repr","std::sync::mpmc::Sender<T>","std::rc::Weak<T>","<*mut T as std::marker::Send>","std::vec::Drain<'_, T, A>","<*const T as std::marker::Send>","std::rc::Rc<T>","std::ptr::Unique<T>","std::env::Args","std::sync::mpsc::Sender<T>","std::thread::JoinHandle<T>","std::env::ArgsOs","std::task::Waker","std::ptr::NonNull<T>","std::io::IoSlice<'a>","std::sync::RwLockReadGuard<'_, T>","std::collections::linked_list::IterMut<'_, T>","std::sync::atomic::AtomicPtr<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::Arc<T>","std::cell::RefCell<T>","std::sync::RwLockWriteGuard<'_, T>","std::collections::linked_list::CursorMut<'_, T>","std::io::IoSliceMut<'a>","std::string::Drain<'_>","std::slice::IterMut<'_, T>","std::sync::OnceLock<T>","std::ptr::DynMetadata<Dyn>","std::sync::Weak<T>","std::boxed::ThinBox<T>"]},"cache::imp::CachedGuard":{"T":["std::io::IoSliceMut<'a>","std::sync::Mutex<T>","std::sync::mpsc::Sender<T>","std::sync::MutexGuard<'_, T>","std::sync::RwLockWriteGuard<'_, T>","std::collections::vec_deque::Drain<'_, T, A>","std::collections::LinkedList<T>","std::ptr::Unique<T>","<*mut T as std::fmt::Debug>","std::env::Args","std::sync::mpsc::Receiver<T>","std::rc::Weak<T>","std::env::ArgsOs","std::sync::atomic::AtomicPtr<T>","std::ptr::DynMetadata<Dyn>","std::sys::unix::args::Args","std::boxed::ThinBox<T>","std::sync::RwLock<T>","std::slice::IterMut<'_, T>","std::sync::mpmc::Receiver<T>","std::sync::OnceLock<T>","std::sync::RwLockReadGuard<'_, T>","std::slice::Iter<'_, T>","std::io::error::repr_bitpacked::Repr","std::collections::linked_list::Cursor<'_, T>","std::collections::linked_list::IterMut<'_, T>","std::string::Drain<'_>","std::sync::Arc<T>","std::sync::Weak<T>","std::sync::mpsc::SyncSender<T>","std::cell::RefCell<T>","std::thread::JoinHandle<T>","std::collections::linked_list::Iter<'_, T>","std::io::IoSlice<'a>","std::rc::Rc<T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::mpmc::Sender<T>","std::task::Waker","std::future::ResumeTy","std::vec::IntoIter<T, A>","std::vec::Drain<'_, T, A>","std::ptr::NonNull<T>","std::cell::Cell<T>"]},"dfa::Result":{"T":["re_unicode::CaptureNames","prog::InstBytes","dfa::StateFlags","re_unicode::NoExpand","compile::SuffixCacheKey","re_trait::Locations","re_bytes::Regex","prog::InstSplit","expand::CaptureRef","re_bytes::SubCaptureMatches","literal::imp::SingleByteSet","dfa::EmptyFlags","re_set::unicode::RegexSet","re_bytes::Match","exec::MatchLiteralType","pikevm::Cache","re_bytes::CaptureNames","re_set::bytes::RegexSet","re_unicode::CaptureLocations","input::InputAt","prog::InstSave","dfa::Transitions","re_set::unicode::SetMatches","prog::InstChar","backtrack::Job","prog::InstRanges","exec::Exec","re_bytes::CaptureLocations","backtrack::Cache","compile::MaybeInst","re_set::bytes::SetMatchesIter","dfa::Byte","prog::EmptyLook","exec::MatchType","re_trait::SubCapturesPosIter","re_unicode::SubCaptureMatches","prog::Program","prog::Inst","dfa::Result","re_builder::RegexOptions","literal::imp::Matcher","literal::imp::BoyerMooreSearch","input::CharInput","pikevm::FollowEpsilon","re_unicode::Regex","prog::InstEmptyLook","expand::Ref","compile::InstHole","input::ByteInput","re_unicode::Match","dfa::State","compile::SuffixCacheEntry","re_set::unicode::SetMatchesIter","exec::MatchNfaType","input::Char","std::clone::impls::<impl std::clone::Clone for &T>","sparse::SparseSet","error::Error","re_bytes::NoExpand","re_set::bytes::SetMatches","literal::imp::LiteralSearcher","pikevm::Threads","literal::imp::FreqyPacked"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt(p0, p1);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::fmt(p0, p1);
-----------------
src/backtrack.rs <backtrack::Cache as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Cache
+p0.clone();
+<backtrack::Cache as std::clone::Clone>::clone(p0);
+crate::<backtrack::Cache as std::clone::Clone>::clone(p0);
+<backtrack::Cache>::clone(p0);
-----------------
src/backtrack.rs <backtrack::Cache as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Cache
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<backtrack::Cache as std::fmt::Debug>::fmt(p0, p1);
+crate::<backtrack::Cache as std::fmt::Debug>::fmt(p0, p1);
+<backtrack::Cache>::fmt(p0, p1);
-----------------
src/backtrack.rs backtrack::Cache::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+backtrack::Cache::new(p0);
+crate::backtrack::Cache::new(p0);
+<backtrack::Cache>::new(p0);
-----------------
src/backtrack.rs <backtrack::Job as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Job
+p0.clone();
+<backtrack::Job as std::clone::Clone>::clone(p0);
+crate::<backtrack::Job as std::clone::Clone>::clone(p0);
+<backtrack::Job>::clone(p0);
-----------------
src/backtrack.rs <backtrack::Job as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // backtrack::Job
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<backtrack::Job as std::fmt::Debug>::fmt(p0, p1);
+crate::<backtrack::Job as std::fmt::Debug>::fmt(p0, p1);
+<backtrack::Job>::fmt(p0, p1);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec":{"I":["input::CharInput","input::ByteInput","<&'a T as input::Input>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<exec::ProgramCacheInner>
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p4 = MaybeUninit::uninit().assume_init(); // I
let mut p5 = 0usize; // None+usize
let mut p6 = 0usize; // None+usize
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec(p0, p1, p2, p3, p4, p5, p6);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec(p0, p1, p2, p3, p4, p5, p6);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::exec(p0, p1, p2, p3, p4, p5, p6);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear":{"I":["<&'a T as input::Input>","input::ByteInput","input::CharInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
+p0.clear();
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear(p0);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear(p0);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::clear(p0);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_":{"I":["input::CharInput","input::ByteInput","<&'a T as input::Input>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = 0usize; // None+usize
+p0.exec_(p1, p2);
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_(p0, p1, p2);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_(p0, p1, p2);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::exec_(p0, p1, p2);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack":{"I":["input::ByteInput","<&'a T as input::Input>","input::CharInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.backtrack(p1);
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack(p0, p1);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack(p0, p1);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::backtrack(p0, p1);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::step
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::step":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::step":{"I":["<&'a T as input::Input>","input::CharInput","input::ByteInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.step(p1, p2);
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::step(p0, p1, p2);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::step(p0, p1, p2);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::step(p0, p1, p2);
-----------------
src/backtrack.rs backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited
'a,'m,'r,'s
deps:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited":{"I":["<&'a T as input::Input>","input::ByteInput","input::CharInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // backtrack::Bounded<'a, 'm, 'r, 's, I>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.has_visited(p1, p2);
+backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited(p0, p1, p2);
+crate::backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited(p0, p1, p2);
+<backtrack::Bounded<'a, 'm, 'r, 's, I>>::has_visited(p0, p1, p2);
-----------------
src/cache.rs <cache::imp::Cached<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<cache::imp::Cached<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<cache::imp::Cached<T> as std::fmt::Debug>::fmt":{"T":["std::io::IoSliceMut<'a>","std::vec::IntoIter<T, A>","std::ptr::Unique<T>","std::collections::linked_list::Cursor<'_, T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::OnceLock<T>","std::sync::MutexGuard<'_, T>","std::sync::Arc<T>","std::rc::Rc<T>","std::string::Drain<'_>","std::boxed::ThinBox<T>","std::ptr::NonNull<T>","std::sync::mpmc::Receiver<T>","std::io::error::repr_bitpacked::Repr","<&T as std::marker::Send>","<*const T as std::marker::Send>","std::sys::unix::args::Args","std::sync::atomic::AtomicPtr<T>","std::sync::mpsc::SyncSender<T>","std::cell::Cell<T>","std::sync::RwLock<T>","std::env::Args","std::cell::RefCell<T>","std::env::ArgsOs","std::sync::mpmc::Sender<T>","std::slice::Iter<'_, T>","std::rc::Weak<T>","std::sync::mpsc::Sender<T>","std::sync::Mutex<T>","std::thread::JoinHandle<T>","std::sync::RwLockWriteGuard<'_, T>","std::ptr::DynMetadata<Dyn>","std::collections::linked_list::CursorMut<'_, T>","std::collections::linked_list::Iter<'_, T>","std::task::Waker","std::sync::RwLockReadGuard<'_, T>","std::io::IoSlice<'a>","std::collections::linked_list::IterMut<'_, T>","std::sync::Weak<T>","std::collections::LinkedList<T>","std::future::ResumeTy","std::vec::Drain<'_, T, A>","std::sync::mpsc::Receiver<T>","std::slice::IterMut<'_, T>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::imp::Cached<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<cache::imp::Cached<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<cache::imp::Cached<T> as std::fmt::Debug>::fmt(p0, p1);
+<cache::imp::Cached<T>>::fmt(p0, p1);
-----------------
src/cache.rs <cache::imp::CachedGuard<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<cache::imp::CachedGuard<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"backtrack::Bounded":{"I":["std::marker::Sized","input::Input","std::fmt::Debug"]},"cache::imp::Cached":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"cache::imp::CachedGuard":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"dfa::Result":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"pikevm::Fsm":{"I":["std::marker::Sized","input::Input","std::fmt::Debug"]},"re_trait::CaptureMatches":{"R":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]},"re_trait::Matches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<cache::imp::CachedGuard<'a, T> as std::fmt::Debug>::fmt":{"T":["dfa::StateFlags","re_trait::Matches","input::ByteInput","dfa::Byte","exec::ExecNoSync","re_set::bytes::SetMatchesIntoIter","literal::imp::LiteralIter","dfa::Result","cache::imp::Cached","compile::SuffixCacheKey","prog::InstSave","re_bytes::CapturesDebug","input::InputAt","compile::SuffixCacheEntry","literal::imp::LiteralSearcher","exec::ExecReadOnly","expand::CaptureRef","expand::Ref","dfa::Transitions","compile::Hole","prog::Program","<&T as std::fmt::Debug>","exec::MatchLiteralType","re_unicode::CapturesDebug","backtrack::Bounded","literal::imp::Matcher","prog::InstChar","dfa::CacheInner","re_bytes::CaptureNames","re_set::unicode::RegexSet","re_builder::set_bytes::RegexSetBuilder","input::CharInput","exec::ProgramCacheInner","input::Char","dfa::Fsm","re_bytes::Match","re_unicode::NoExpand","re_set::bytes::SetMatches","compile::SuffixCache","re_trait::CaptureMatches","re_set::unicode::SetMatchesIntoIter","re_builder::RegexOptions","re_set::unicode::SetMatchesIter","re_bytes::NoExpand","re_unicode::CaptureLocations","re_unicode::SplitN","re_bytes::CaptureLocations","prog::InstBytes","re_unicode::Regex","re_set::bytes::RegexSet","compile::InstHole","literal::imp::SingleByteSet","dfa::State","re_unicode::Captures","re_builder::unicode::RegexBuilder","prog::Inst","re_trait::Locations","dfa::TransitionsRow","prog::InstEmptyLook","exec::Exec","prog::EmptyLook","re_bytes::Regex","re_builder::bytes::RegexBuilder","re_set::bytes::SetMatchesIter","prog::InstRanges","re_builder::set_unicode::RegexSetBuilder","exec::MatchType","re_unicode::SubCaptureMatches","re_bytes::CaptureMatches","dfa::StateMap","re_bytes::SubCaptureMatches","re_unicode::Match","pikevm::FollowEpsilon","re_bytes::Matches","<*const T as std::fmt::Debug>","pikevm::Cache","error::Error","re_set::unicode::SetMatches","compile::Patch","dfa::EmptyFlags","pikevm::Fsm","re_unicode::Matches","re_bytes::Captures","literal::imp::BoyerMooreSearch","exec::MatchNfaType","backtrack::Job","dfa::Cache","re_unicode::ReplacerRef","prog::InstSplit","exec::ExecNoSyncStr","backtrack::Cache","re_trait::SubCapturesPosIter","cache::imp::CachedGuard","compile::ByteClassSet","re_bytes::SplitN","re_bytes::ReplacerRef","re_bytes::Split","sparse::SparseSet","re_unicode::Split","literal::imp::FreqyPacked","pikevm::Threads","compile::MaybeInst","re_unicode::CaptureNames","re_unicode::CaptureMatches"]},"backtrack::Bounded":{"I":["input::CharInput","input::ByteInput"]},"cache::imp::Cached":{"T":["std::cell::Cell<T>","std::sys::unix::args::Args","std::sync::mpmc::Receiver<T>","std::task::Waker","std::io::IoSliceMut<'a>","std::boxed::ThinBox<T>","std::vec::IntoIter<T, A>","std::ptr::Unique<T>","std::slice::Iter<'_, T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::Arc<T>","std::vec::Drain<'_, T, A>","std::sync::mpsc::SyncSender<T>","std::sync::mpsc::Receiver<T>","std::sync::atomic::AtomicPtr<T>","std::collections::LinkedList<T>","std::string::Drain<'_>","std::collections::linked_list::IterMut<'_, T>","std::collections::linked_list::CursorMut<'_, T>","std::ptr::DynMetadata<Dyn>","std::sync::Weak<T>","std::cell::RefCell<T>","std::io::IoSlice<'a>","<&T as std::fmt::Debug>","std::env::Args","std::ptr::NonNull<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::Mutex<T>","std::sync::mpmc::Sender<T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::OnceLock<T>","std::rc::Weak<T>","std::rc::Rc<T>","std::slice::IterMut<'_, T>","std::sync::MutexGuard<'_, T>","std::env::ArgsOs","std::io::error::repr_bitpacked::Repr","std::sync::RwLockReadGuard<'_, T>","std::collections::linked_list::Iter<'_, T>","std::sync::RwLock<T>","std::sync::mpsc::Sender<T>","std::future::ResumeTy","std::thread::JoinHandle<T>"]},"cache::imp::CachedGuard":{"T":["std::sync::RwLockReadGuard<'_, T>","std::rc::Weak<T>","std::vec::Drain<'_, T, A>","std::sync::Mutex<T>","std::env::Args","std::io::error::repr_bitpacked::Repr","std::collections::vec_deque::Drain<'_, T, A>","std::slice::IterMut<'_, T>","std::rc::Rc<T>","<&T as std::marker::Send>","std::sync::mpsc::Sender<T>","std::vec::IntoIter<T, A>","std::slice::Iter<'_, T>","std::sync::OnceLock<T>","std::thread::JoinHandle<T>","std::cell::Cell<T>","std::collections::linked_list::IterMut<'_, T>","std::sync::RwLock<T>","std::sync::Weak<T>","std::collections::linked_list::CursorMut<'_, T>","std::collections::linked_list::Iter<'_, T>","std::collections::LinkedList<T>","std::io::IoSlice<'a>","std::boxed::ThinBox<T>","std::ptr::Unique<T>","std::sync::mpsc::SyncSender<T>","std::sync::mpmc::Receiver<T>","std::future::ResumeTy","std::sync::Arc<T>","std::task::Waker","std::sync::RwLockWriteGuard<'_, T>","std::string::Drain<'_>","std::sync::atomic::AtomicPtr<T>","std::sys::unix::args::Args","std::ptr::DynMetadata<Dyn>","std::env::ArgsOs","std::io::IoSliceMut<'a>","std::sync::mpmc::Sender<T>","std::cell::RefCell<T>","std::ptr::NonNull<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::MutexGuard<'_, T>","std::sync::mpsc::Receiver<T>"]},"dfa::Result":{"T":["prog::InstSave","std::clone::impls::<impl std::clone::Clone for &T>","exec::Exec","dfa::State","re_unicode::CaptureNames","re_set::bytes::SetMatches","compile::InstHole","input::CharInput","compile::SuffixCacheEntry","prog::InstChar","re_bytes::Match","pikevm::Threads","re_bytes::CaptureLocations","dfa::Transitions","pikevm::FollowEpsilon","prog::InstBytes","dfa::Result","prog::InstEmptyLook","re_trait::SubCapturesPosIter","exec::MatchLiteralType","dfa::Byte","exec::MatchNfaType","re_unicode::Match","backtrack::Job","input::InputAt","literal::imp::FreqyPacked","dfa::StateFlags","backtrack::Cache","re_bytes::CaptureNames","literal::imp::BoyerMooreSearch","re_set::bytes::RegexSet","prog::Inst","re_unicode::CaptureLocations","re_set::unicode::RegexSet","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::SingleByteSet","re_bytes::SubCaptureMatches","pikevm::Cache","literal::imp::Matcher","dfa::EmptyFlags","error::Error","re_builder::RegexOptions","input::Char","re_unicode::NoExpand","sparse::SparseSet","prog::InstSplit","re_set::unicode::SetMatches","prog::InstRanges","input::ByteInput","re_bytes::NoExpand","re_unicode::Regex","re_set::bytes::SetMatchesIter","re_trait::Locations","compile::SuffixCacheKey","re_set::unicode::SetMatchesIter","re_bytes::Regex","expand::Ref","prog::EmptyLook","prog::Program","compile::MaybeInst","expand::CaptureRef","re_unicode::SubCaptureMatches"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::imp::CachedGuard<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<cache::imp::CachedGuard<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<cache::imp::CachedGuard<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<cache::imp::CachedGuard<'a, T>>::fmt(p0, p1);
-----------------
src/cache.rs cache::imp::Cached::<T>::new
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"cache::imp::Cached::<T>::new":{"T":["std::marker::Send","std::marker::Sized"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"cache::imp::Cached::<T>::new":{"T":["std::io::IoSlice<'a>","std::collections::linked_list::IterMut<'_, T>","std::cell::Cell<T>","std::slice::RChunksExactMut<'_, T>","std::sys_common::net::LookupHost","std::sys::unix::process::process_common::Argv","std::sync::mpsc::Sender<T>","std::sync::mpmc::Sender<T>","std::cell::RefCell<T>","std::sync::mpsc::Receiver<T>","std::task::Waker","std::slice::Iter<'_, T>","std::ptr::DynMetadata<Dyn>","std::vec::IntoIter<T, A>","std::env::Args","std::sync::Weak<T>","std::io::error::repr_bitpacked::Repr","std::slice::IterMut<'_, T>","std::rc::Rc<T>","std::sys::unix::os::Env","std::future::ResumeTy","std::string::Drain<'_>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::rc::Weak<T>","std::env::ArgsOs","std::ptr::Unique<T>","std::sys::unix::args::Args","std::backtrace_rs::backtrace::libunwind::Frame","std::sync::RwLock<T>","std::sync::atomic::AtomicPtr<T>","std::collections::LinkedList<T>","std::collections::linked_list::Cursor<'_, T>","std::slice::RChunksMut<'_, T>","std::sync::Mutex<T>","std::ptr::NonNull<T>","<&T as std::marker::Send>","std::collections::linked_list::Iter<'_, T>","std::sync::mpsc::SyncSender<T>","std::sys_common::remutex::ReentrantMutex<T>","std::sync::mpmc::Receiver<T>","std::slice::ChunksMut<'_, T>","std::sys::unix::fs::Dir","std::vec::Drain<'_, T, A>","std::sync::MutexGuard<'_, T>","std::thread::JoinHandle<T>","std::sync::RwLockReadGuard<'_, T>","std::collections::linked_list::CursorMut<'_, T>","<*mut T as std::marker::Send>","std::io::IoSliceMut<'a>","std::boxed::ThinBox<T>","std::sync::Arc<T>","std::sync::OnceLock<T>","std::sys::unix::thread::Thread","std::collections::vec_deque::Drain<'_, T, A>","std::slice::ChunksExactMut<'_, T>","std::sync::RwLockWriteGuard<'_, T>"]}}
+cache::imp::Cached::<T>::new();
+crate::cache::imp::Cached::<T>::new();
+<cache::imp::Cached<T>>::new();
-----------------
src/cache.rs cache::imp::Cached::<T>::get_or
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"cache::imp::Cached::<T>::get_or":{"T":["std::marker::Sized","std::marker::Send"],"impl FnOnce() -> T":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"cache::imp::Cached::<T>::get_or":{"T":["std::env::ArgsOs","std::env::Args","std::slice::RChunksMut<'_, T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::Arc<T>","std::sync::mpmc::Sender<T>","std::rc::Weak<T>","std::sync::mpsc::Sender<T>","std::sys::unix::args::Args","std::collections::linked_list::IterMut<'_, T>","std::sys::unix::process::process_common::Argv","std::collections::linked_list::Iter<'_, T>","std::sync::Mutex<T>","std::task::Waker","std::slice::ChunksExactMut<'_, T>","std::sync::mpsc::Receiver<T>","std::sync::Weak<T>","std::sys::unix::os::Env","std::ptr::NonNull<T>","std::cell::RefCell<T>","<&T as std::marker::Send>","std::io::error::repr_bitpacked::Repr","std::ptr::Unique<T>","std::slice::ChunksMut<'_, T>","std::sys_common::net::LookupHost","<*const T as std::marker::Send>","std::io::IoSlice<'a>","std::cell::Cell<T>","std::collections::linked_list::CursorMut<'_, T>","std::vec::IntoIter<T, A>","std::sys_common::remutex::ReentrantMutex<T>","std::collections::linked_list::Cursor<'_, T>","std::slice::RChunksExactMut<'_, T>","std::sync::mpsc::SyncSender<T>","std::backtrace_rs::backtrace::libunwind::Frame","std::collections::LinkedList<T>","std::slice::IterMut<'_, T>","std::sync::RwLock<T>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::ptr::DynMetadata<Dyn>","std::thread::JoinHandle<T>","std::io::IoSliceMut<'a>","std::slice::Iter<'_, T>","std::sys::unix::fs::Dir","std::sync::MutexGuard<'_, T>","std::sys::unix::thread::Thread","std::boxed::ThinBox<T>","std::sync::mpmc::Receiver<T>","std::sync::RwLockReadGuard<'_, T>","std::rc::Rc<T>","std::sync::OnceLock<T>","std::vec::Drain<'_, T, A>","std::future::ResumeTy","std::string::Drain<'_>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::atomic::AtomicPtr<T>"],"impl FnOnce() -> T":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::panic::AssertUnwindSafe<F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::imp::Cached<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> T
+p0.get_or(p1);
+cache::imp::Cached::<T>::get_or(p0, p1);
+crate::cache::imp::Cached::<T>::get_or(p0, p1);
+<cache::imp::Cached<T>>::get_or(p0, p1);
-----------------
src/cache.rs cache::imp::CachedGuard::<'a, T>::value
'a
deps:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"cache::imp::CachedGuard::<'a, T>::value":{"T":["std::marker::Send","std::marker::Sized"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::marker::Send>":{},"cache::imp::CachedGuard::<'a, T>::value":{"T":["std::sys::unix::args::Args","std::collections::LinkedList<T>","std::sync::mpmc::Sender<T>","std::sync::OnceLock<T>","std::slice::RChunksMut<'_, T>","std::sys::unix::thread::Thread","std::sys::unix::process::process_common::Argv","std::sync::Arc<T>","std::io::IoSlice<'a>","std::slice::IterMut<'_, T>","std::vec::IntoIter<T, A>","std::task::Waker","std::slice::ChunksMut<'_, T>","std::env::ArgsOs","<*mut T as std::marker::Send>","std::rc::Rc<T>","std::sync::MutexGuard<'_, T>","std::slice::Iter<'_, T>","std::ptr::DynMetadata<Dyn>","std::collections::linked_list::Cursor<'_, T>","std::sync::atomic::AtomicPtr<T>","std::slice::RChunksExactMut<'_, T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::RwLock<T>","std::vec::Drain<'_, T, A>","std::collections::linked_list::Iter<'_, T>","std::sync::mpsc::Receiver<T>","std::collections::linked_list::CursorMut<'_, T>","std::slice::ChunksExactMut<'_, T>","std::future::ResumeTy","std::sys_common::net::LookupHost","<&T as std::marker::Send>","std::sync::Mutex<T>","std::boxed::ThinBox<T>","std::sys::unix::fs::Dir","std::env::Args","std::sync::mpmc::Receiver<T>","std::ptr::Unique<T>","std::backtrace_rs::backtrace::libunwind::Frame","std::sync::mpsc::Sender<T>","std::collections::vec_deque::Drain<'_, T, A>","std::rc::Weak<T>","std::sync::Weak<T>","std::sys_common::remutex::ReentrantMutex<T>","std::ptr::NonNull<T>","std::cell::Cell<T>","std::sync::mpsc::SyncSender<T>","std::sys::unix::os::Env","std::sync::RwLockReadGuard<'_, T>","std::io::error::repr_bitpacked::Repr","std::thread::JoinHandle<T>","std::collections::linked_list::IterMut<'_, T>","std::string::Drain<'_>","std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::cell::RefCell<T>","std::io::IoSliceMut<'a>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // cache::imp::CachedGuard<'a, T>
+p0.value();
+cache::imp::CachedGuard::<'a, T>::value(p0);
+crate::cache::imp::CachedGuard::<'a, T>::value(p0);
+<cache::imp::CachedGuard<'a, T>>::value(p0);
-----------------
src/compile.rs <compile::Patch as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::Patch
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::Patch as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::Patch as std::fmt::Debug>::fmt(p0, p1);
+<compile::Patch>::fmt(p0, p1);
-----------------
src/compile.rs compile::Compiler::new
deps:{}
candidates:{}
+compile::Compiler::new();
+crate::compile::Compiler::new();
+<compile::Compiler>::new();
-----------------
src/compile.rs compile::Compiler::size_limit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+compile::Compiler::size_limit(p0, p1);
+crate::compile::Compiler::size_limit(p0, p1);
+<compile::Compiler>::size_limit(p0, p1);
-----------------
src/compile.rs compile::Compiler::bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = true; // None+bool
+p0.bytes(p1);
+compile::Compiler::bytes(p0, p1);
+crate::compile::Compiler::bytes(p0, p1);
+<compile::Compiler>::bytes(p0, p1);
-----------------
src/compile.rs compile::Compiler::only_utf8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = true; // None+bool
+p0.only_utf8(p1);
+compile::Compiler::only_utf8(p0, p1);
+crate::compile::Compiler::only_utf8(p0, p1);
+<compile::Compiler>::only_utf8(p0, p1);
-----------------
src/compile.rs compile::Compiler::dfa
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = true; // None+bool
+p0.dfa(p1);
+compile::Compiler::dfa(p0, p1);
+crate::compile::Compiler::dfa(p0, p1);
+<compile::Compiler>::dfa(p0, p1);
-----------------
src/compile.rs compile::Compiler::reverse
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = true; // None+bool
+p0.reverse(p1);
+compile::Compiler::reverse(p0, p1);
+crate::compile::Compiler::reverse(p0, p1);
+<compile::Compiler>::reverse(p0, p1);
-----------------
src/compile.rs compile::Compiler::compile
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [syntax::hir::Hir]
+p0.compile(p1);
+compile::Compiler::compile(p0, p1);
+crate::compile::Compiler::compile(p0, p1);
+<compile::Compiler>::compile(p0, p1);
-----------------
src/compile.rs compile::Compiler::compile_one
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Hir
+p0.compile_one(p1);
+compile::Compiler::compile_one(p0, p1);
+crate::compile::Compiler::compile_one(p0, p1);
+<compile::Compiler>::compile_one(p0, p1);
-----------------
src/compile.rs compile::Compiler::compile_many
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [syntax::hir::Hir]
+p0.compile_many(p1);
+compile::Compiler::compile_many(p0, p1);
+crate::compile::Compiler::compile_many(p0, p1);
+<compile::Compiler>::compile_many(p0, p1);
-----------------
src/compile.rs compile::Compiler::compile_finish
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.compile_finish();
+compile::Compiler::compile_finish(p0);
+crate::compile::Compiler::compile_finish(p0);
+<compile::Compiler>::compile_finish(p0);
-----------------
src/compile.rs compile::Compiler::c
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Hir
+p0.c(p1);
+compile::Compiler::c(p0, p1);
+crate::compile::Compiler::c(p0, p1);
+<compile::Compiler>::c(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_capture
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = 0usize; // None+usize
let mut p2 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Hir
+p0.c_capture(p1, p2);
+compile::Compiler::c_capture(p0, p1, p2);
+crate::compile::Compiler::c_capture(p0, p1, p2);
+<compile::Compiler>::c_capture(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::c_dotstar
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.c_dotstar();
+compile::Compiler::c_dotstar(p0);
+crate::compile::Compiler::c_dotstar(p0);
+<compile::Compiler>::c_dotstar(p0);
-----------------
src/compile.rs compile::Compiler::c_char
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = 'a'; // None+char
+p0.c_char(p1);
+compile::Compiler::c_char(p0, p1);
+crate::compile::Compiler::c_char(p0, p1);
+<compile::Compiler>::c_char(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_class
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [syntax::hir::ClassUnicodeRange]
+p0.c_class(p1);
+compile::Compiler::c_class(p0, p1);
+crate::compile::Compiler::c_class(p0, p1);
+<compile::Compiler>::c_class(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_byte
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = 0u8; // None+u8
+p0.c_byte(p1);
+compile::Compiler::c_byte(p0, p1);
+crate::compile::Compiler::c_byte(p0, p1);
+<compile::Compiler>::c_byte(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_class_bytes
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [syntax::hir::ClassBytesRange]
+p0.c_class_bytes(p1);
+compile::Compiler::c_class_bytes(p0, p1);
+crate::compile::Compiler::c_class_bytes(p0, p1);
+<compile::Compiler>::c_class_bytes(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_empty_look
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // prog::EmptyLook
+p0.c_empty_look(p1);
+compile::Compiler::c_empty_look(p0, p1);
+crate::compile::Compiler::c_empty_look(p0, p1);
+<compile::Compiler>::c_empty_look(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_concat
'a
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"compile::Compiler::c_concat":{"I":["std::iter::IntoIterator","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"re_trait::Matches":{"R":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["re_unicode::CaptureMatches","re_bytes::CaptureMatches","re_trait::SubCapturesPosIter","re_trait::CaptureMatches","re_set::bytes::SetMatchesIter","re_bytes::Split","re_set::unicode::SetMatchesIter","re_unicode::Split","dfa::InstPtrs","re_bytes::Matches","re_bytes::SplitN","re_unicode::Matches","re_trait::Matches","<&mut I as std::iter::Iterator>","re_unicode::CaptureNames","re_unicode::SplitN","re_set::bytes::SetMatchesIntoIter","re_bytes::CaptureNames","re_unicode::SubCaptureMatches","literal::imp::LiteralIter","re_bytes::SubCaptureMatches","re_set::unicode::SetMatchesIntoIter"]},"compile::Compiler::c_concat":{"I":["re_set::bytes::SetMatches","<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>","re_set::unicode::SetMatches","<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.c_concat(p1);
+compile::Compiler::c_concat(p0, p1);
+crate::compile::Compiler::c_concat(p0, p1);
+<compile::Compiler>::c_concat(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_alternate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // [syntax::hir::Hir]
+p0.c_alternate(p1);
+compile::Compiler::c_alternate(p0, p1);
+crate::compile::Compiler::c_alternate(p0, p1);
+<compile::Compiler>::c_alternate(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_repeat
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Repetition
+p0.c_repeat(p1);
+compile::Compiler::c_repeat(p0, p1);
+crate::compile::Compiler::c_repeat(p0, p1);
+<compile::Compiler>::c_repeat(p0, p1);
-----------------
src/compile.rs compile::Compiler::c_repeat_zero_or_one
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Hir
let mut p2 = true; // None+bool
+p0.c_repeat_zero_or_one(p1, p2);
+compile::Compiler::c_repeat_zero_or_one(p0, p1, p2);
+crate::compile::Compiler::c_repeat_zero_or_one(p0, p1, p2);
+<compile::Compiler>::c_repeat_zero_or_one(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::c_repeat_zero_or_more
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Hir
let mut p2 = true; // None+bool
+p0.c_repeat_zero_or_more(p1, p2);
+compile::Compiler::c_repeat_zero_or_more(p0, p1, p2);
+crate::compile::Compiler::c_repeat_zero_or_more(p0, p1, p2);
+<compile::Compiler>::c_repeat_zero_or_more(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::c_repeat_one_or_more
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Hir
let mut p2 = true; // None+bool
+p0.c_repeat_one_or_more(p1, p2);
+compile::Compiler::c_repeat_one_or_more(p0, p1, p2);
+crate::compile::Compiler::c_repeat_one_or_more(p0, p1, p2);
+<compile::Compiler>::c_repeat_one_or_more(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::c_repeat_range_min_or_more
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Hir
let mut p2 = true; // None+bool
let mut p3 = 0u32; // None+u32
+p0.c_repeat_range_min_or_more(p1, p2, p3);
+compile::Compiler::c_repeat_range_min_or_more(p0, p1, p2, p3);
+crate::compile::Compiler::c_repeat_range_min_or_more(p0, p1, p2, p3);
+<compile::Compiler>::c_repeat_range_min_or_more(p0, p1, p2, p3);
-----------------
src/compile.rs compile::Compiler::c_repeat_range
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = & MaybeUninit::uninit().assume_init(); // syntax::hir::Hir
let mut p2 = true; // None+bool
let mut p3 = 0u32; // None+u32
let mut p4 = 0u32; // None+u32
+p0.c_repeat_range(p1, p2, p3, p4);
+compile::Compiler::c_repeat_range(p0, p1, p2, p3, p4);
+crate::compile::Compiler::c_repeat_range(p0, p1, p2, p3, p4);
+<compile::Compiler>::c_repeat_range(p0, p1, p2, p3, p4);
-----------------
src/compile.rs compile::Compiler::next_inst
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.next_inst();
+compile::Compiler::next_inst(p0);
+crate::compile::Compiler::next_inst(p0);
+<compile::Compiler>::next_inst(p0);
-----------------
src/compile.rs compile::Compiler::fill
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::Hole
let mut p2 = 0usize; // None+usize
+p0.fill(p1, p2);
+compile::Compiler::fill(p0, p1, p2);
+crate::compile::Compiler::fill(p0, p1, p2);
+<compile::Compiler>::fill(p0, p1, p2);
-----------------
src/compile.rs compile::Compiler::fill_to_next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::Hole
+p0.fill_to_next(p1);
+compile::Compiler::fill_to_next(p0, p1);
+crate::compile::Compiler::fill_to_next(p0, p1);
+<compile::Compiler>::fill_to_next(p0, p1);
-----------------
src/compile.rs compile::Compiler::fill_split
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::Hole
let mut p2 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
let mut p3 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.fill_split(p1, p2, p3);
+compile::Compiler::fill_split(p0, p1, p2, p3);
+crate::compile::Compiler::fill_split(p0, p1, p2, p3);
+<compile::Compiler>::fill_split(p0, p1, p2, p3);
-----------------
src/compile.rs compile::Compiler::push_compiled
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // prog::Inst
+p0.push_compiled(p1);
+compile::Compiler::push_compiled(p0, p1);
+crate::compile::Compiler::push_compiled(p0, p1);
+<compile::Compiler>::push_compiled(p0, p1);
-----------------
src/compile.rs compile::Compiler::push_hole
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::InstHole
+p0.push_hole(p1);
+compile::Compiler::push_hole(p0, p1);
+crate::compile::Compiler::push_hole(p0, p1);
+<compile::Compiler>::push_hole(p0, p1);
-----------------
src/compile.rs compile::Compiler::push_split_hole
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.push_split_hole();
+compile::Compiler::push_split_hole(p0);
+crate::compile::Compiler::push_split_hole(p0);
+<compile::Compiler>::push_split_hole(p0);
-----------------
src/compile.rs compile::Compiler::pop_split_hole
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.pop_split_hole();
+compile::Compiler::pop_split_hole(p0);
+crate::compile::Compiler::pop_split_hole(p0);
+<compile::Compiler>::pop_split_hole(p0);
-----------------
src/compile.rs compile::Compiler::check_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::Compiler
+p0.check_size();
+compile::Compiler::check_size(p0);
+crate::compile::Compiler::check_size(p0);
+<compile::Compiler>::check_size(p0);
-----------------
src/compile.rs <compile::Hole as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::Hole
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::Hole as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::Hole as std::fmt::Debug>::fmt(p0, p1);
+<compile::Hole>::fmt(p0, p1);
-----------------
src/compile.rs compile::Hole::dup_one
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::Hole
+p0.dup_one();
+compile::Hole::dup_one(p0);
+crate::compile::Hole::dup_one(p0);
+<compile::Hole>::dup_one(p0);
-----------------
src/compile.rs <compile::MaybeInst as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::MaybeInst
+p0.clone();
+<compile::MaybeInst as std::clone::Clone>::clone(p0);
+crate::<compile::MaybeInst as std::clone::Clone>::clone(p0);
+<compile::MaybeInst>::clone(p0);
-----------------
src/compile.rs <compile::MaybeInst as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::MaybeInst as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::MaybeInst as std::fmt::Debug>::fmt(p0, p1);
+<compile::MaybeInst>::fmt(p0, p1);
-----------------
src/compile.rs compile::MaybeInst::fill
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = 0usize; // None+usize
+p0.fill(p1);
+compile::MaybeInst::fill(p0, p1);
+crate::compile::MaybeInst::fill(p0, p1);
+<compile::MaybeInst>::fill(p0, p1);
-----------------
src/compile.rs compile::MaybeInst::fill_split
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.fill_split(p1, p2);
+compile::MaybeInst::fill_split(p0, p1, p2);
+crate::compile::MaybeInst::fill_split(p0, p1, p2);
+<compile::MaybeInst>::fill_split(p0, p1, p2);
-----------------
src/compile.rs compile::MaybeInst::half_fill_split_goto1
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = 0usize; // None+usize
+p0.half_fill_split_goto1(p1);
+compile::MaybeInst::half_fill_split_goto1(p0, p1);
+crate::compile::MaybeInst::half_fill_split_goto1(p0, p1);
+<compile::MaybeInst>::half_fill_split_goto1(p0, p1);
-----------------
src/compile.rs compile::MaybeInst::half_fill_split_goto2
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::MaybeInst
let mut p1 = 0usize; // None+usize
+p0.half_fill_split_goto2(p1);
+compile::MaybeInst::half_fill_split_goto2(p0, p1);
+crate::compile::MaybeInst::half_fill_split_goto2(p0, p1);
+<compile::MaybeInst>::half_fill_split_goto2(p0, p1);
-----------------
src/compile.rs compile::MaybeInst::unwrap
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::MaybeInst
+p0.unwrap();
+compile::MaybeInst::unwrap(p0);
+crate::compile::MaybeInst::unwrap(p0);
+<compile::MaybeInst>::unwrap(p0);
-----------------
src/compile.rs <compile::InstHole as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::InstHole
+p0.clone();
+<compile::InstHole as std::clone::Clone>::clone(p0);
+crate::<compile::InstHole as std::clone::Clone>::clone(p0);
+<compile::InstHole>::clone(p0);
-----------------
src/compile.rs <compile::InstHole as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::InstHole
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::InstHole as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::InstHole as std::fmt::Debug>::fmt(p0, p1);
+<compile::InstHole>::fmt(p0, p1);
-----------------
src/compile.rs compile::InstHole::fill
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::InstHole
let mut p1 = 0usize; // None+usize
+p0.fill(p1);
+compile::InstHole::fill(p0, p1);
+crate::compile::InstHole::fill(p0, p1);
+<compile::InstHole>::fill(p0, p1);
-----------------
src/compile.rs compile::CompileClass::<'a, 'b>::compile
'a,'b
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // compile::CompileClass<'a, 'b>
+p0.compile();
+compile::CompileClass::<'a, 'b>::compile(p0);
+crate::compile::CompileClass::<'a, 'b>::compile(p0);
+<compile::CompileClass<'a, 'b>>::compile(p0);
-----------------
src/compile.rs compile::CompileClass::<'a, 'b>::c_utf8_seq
'a,'b
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::CompileClass<'a, 'b>
let mut p1 = & MaybeUninit::uninit().assume_init(); // syntax::utf8::Utf8Sequence
+p0.c_utf8_seq(p1);
+compile::CompileClass::<'a, 'b>::c_utf8_seq(p0, p1);
+crate::compile::CompileClass::<'a, 'b>::c_utf8_seq(p0, p1);
+<compile::CompileClass<'a, 'b>>::c_utf8_seq(p0, p1);
-----------------
src/compile.rs compile::CompileClass::<'a, 'b>::c_utf8_seq_
'a,'b,'r
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"compile::CompileClass::<'a, 'b>::c_utf8_seq_":{"I":["std::iter::IntoIterator","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["<&mut I as std::iter::Iterator>","re_set::bytes::SetMatchesIter","re_trait::CaptureMatches","re_unicode::Split","re_bytes::CaptureMatches","dfa::InstPtrs","re_bytes::SubCaptureMatches","re_unicode::SubCaptureMatches","re_set::unicode::SetMatchesIter","re_unicode::SplitN","re_trait::SubCapturesPosIter","re_unicode::Matches","re_unicode::CaptureMatches","re_set::bytes::SetMatchesIntoIter","re_bytes::Matches","re_unicode::CaptureNames","re_bytes::SplitN","re_set::unicode::SetMatchesIntoIter","re_bytes::CaptureNames","literal::imp::LiteralIter","re_bytes::Split","re_trait::Matches"]},"compile::CompileClass::<'a, 'b>::c_utf8_seq_":{"I":["re_set::bytes::SetMatches","<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>","re_set::unicode::SetMatches","<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::CompileClass<'a, 'b>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.c_utf8_seq_(p1);
+compile::CompileClass::<'a, 'b>::c_utf8_seq_(p0, p1);
+crate::compile::CompileClass::<'a, 'b>::c_utf8_seq_(p0, p1);
+<compile::CompileClass<'a, 'b>>::c_utf8_seq_(p0, p1);
-----------------
src/compile.rs <compile::SuffixCache as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCache
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::SuffixCache as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::SuffixCache as std::fmt::Debug>::fmt(p0, p1);
+<compile::SuffixCache>::fmt(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
+p0.clone();
+<compile::SuffixCacheEntry as std::clone::Clone>::clone(p0);
+crate::<compile::SuffixCacheEntry as std::clone::Clone>::clone(p0);
+<compile::SuffixCacheEntry>::clone(p0);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::SuffixCacheEntry as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::SuffixCacheEntry as std::fmt::Debug>::fmt(p0, p1);
+<compile::SuffixCacheEntry>::fmt(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::default::Default>::default
deps:{}
candidates:{}
+<compile::SuffixCacheEntry as std::default::Default>::default();
+crate::<compile::SuffixCacheEntry as std::default::Default>::default();
+<compile::SuffixCacheEntry>::default();
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
+p0.assert_receiver_is_total_eq();
+<compile::SuffixCacheEntry as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<compile::SuffixCacheEntry as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<compile::SuffixCacheEntry>::assert_receiver_is_total_eq(p0);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<compile::SuffixCacheEntry as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<compile::SuffixCacheEntry as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<compile::SuffixCacheEntry as std::hash::Hash>::hash(p0, p1);
+crate::<compile::SuffixCacheEntry as std::hash::Hash>::hash(p0, p1);
+<compile::SuffixCacheEntry>::hash(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheEntry as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
let mut p1 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheEntry
+p0.eq(p1);
+<compile::SuffixCacheEntry as std::cmp::PartialEq>::eq(p0, p1);
+crate::<compile::SuffixCacheEntry as std::cmp::PartialEq>::eq(p0, p1);
+<compile::SuffixCacheEntry>::eq(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
+p0.clone();
+<compile::SuffixCacheKey as std::clone::Clone>::clone(p0);
+crate::<compile::SuffixCacheKey as std::clone::Clone>::clone(p0);
+<compile::SuffixCacheKey>::clone(p0);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::SuffixCacheKey as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::SuffixCacheKey as std::fmt::Debug>::fmt(p0, p1);
+<compile::SuffixCacheKey>::fmt(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::default::Default>::default
deps:{}
candidates:{}
+<compile::SuffixCacheKey as std::default::Default>::default();
+crate::<compile::SuffixCacheKey as std::default::Default>::default();
+<compile::SuffixCacheKey>::default();
-----------------
src/compile.rs <compile::SuffixCacheKey as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
+p0.assert_receiver_is_total_eq();
+<compile::SuffixCacheKey as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<compile::SuffixCacheKey as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<compile::SuffixCacheKey>::assert_receiver_is_total_eq(p0);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<compile::SuffixCacheKey as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<compile::SuffixCacheKey as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<compile::SuffixCacheKey as std::hash::Hash>::hash(p0, p1);
+crate::<compile::SuffixCacheKey as std::hash::Hash>::hash(p0, p1);
+<compile::SuffixCacheKey>::hash(p0, p1);
-----------------
src/compile.rs <compile::SuffixCacheKey as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
let mut p1 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
+p0.eq(p1);
+<compile::SuffixCacheKey as std::cmp::PartialEq>::eq(p0, p1);
+crate::<compile::SuffixCacheKey as std::cmp::PartialEq>::eq(p0, p1);
+<compile::SuffixCacheKey>::eq(p0, p1);
-----------------
src/compile.rs compile::SuffixCache::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+compile::SuffixCache::new(p0);
+crate::compile::SuffixCache::new(p0);
+<compile::SuffixCache>::new(p0);
-----------------
src/compile.rs compile::SuffixCache::get
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::SuffixCache
let mut p1 = MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
let mut p2 = 0usize; // None+usize
+p0.get(p1, p2);
+compile::SuffixCache::get(p0, p1, p2);
+crate::compile::SuffixCache::get(p0, p1, p2);
+<compile::SuffixCache>::get(p0, p1, p2);
-----------------
src/compile.rs compile::SuffixCache::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::SuffixCache
+p0.clear();
+compile::SuffixCache::clear(p0);
+crate::compile::SuffixCache::clear(p0);
+<compile::SuffixCache>::clear(p0);
-----------------
src/compile.rs compile::SuffixCache::hash
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCache
let mut p1 = & MaybeUninit::uninit().assume_init(); // compile::SuffixCacheKey
+p0.hash(p1);
+compile::SuffixCache::hash(p0, p1);
+crate::compile::SuffixCache::hash(p0, p1);
+<compile::SuffixCache>::hash(p0, p1);
-----------------
src/compile.rs compile::ByteClassSet::new
deps:{}
candidates:{}
+compile::ByteClassSet::new();
+crate::compile::ByteClassSet::new();
+<compile::ByteClassSet>::new();
-----------------
src/compile.rs compile::ByteClassSet::set_range
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::ByteClassSet
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
+p0.set_range(p1, p2);
+compile::ByteClassSet::set_range(p0, p1, p2);
+crate::compile::ByteClassSet::set_range(p0, p1, p2);
+<compile::ByteClassSet>::set_range(p0, p1, p2);
-----------------
src/compile.rs compile::ByteClassSet::set_word_boundary
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // compile::ByteClassSet
+p0.set_word_boundary();
+compile::ByteClassSet::set_word_boundary(p0);
+crate::compile::ByteClassSet::set_word_boundary(p0);
+<compile::ByteClassSet>::set_word_boundary(p0);
-----------------
src/compile.rs compile::ByteClassSet::byte_classes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::ByteClassSet
+p0.byte_classes();
+compile::ByteClassSet::byte_classes(p0);
+crate::compile::ByteClassSet::byte_classes(p0);
+<compile::ByteClassSet>::byte_classes(p0);
-----------------
src/compile.rs <compile::ByteClassSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // compile::ByteClassSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<compile::ByteClassSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<compile::ByteClassSet as std::fmt::Debug>::fmt(p0, p1);
+<compile::ByteClassSet>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::Cache as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Cache
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Cache as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Cache as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Cache>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::CacheInner as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::CacheInner
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::CacheInner as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::CacheInner as std::fmt::Debug>::fmt(p0, p1);
+<dfa::CacheInner>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::Transitions as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.clone();
+<dfa::Transitions as std::clone::Clone>::clone(p0);
+crate::<dfa::Transitions as std::clone::Clone>::clone(p0);
+<dfa::Transitions>::clone(p0);
-----------------
src/dfa.rs <dfa::Fsm<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Fsm<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Fsm<'a> as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Fsm<'a>>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::Result<T> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<dfa::Result<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"dfa::Result":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<dfa::Result<T> as std::clone::Clone>::clone":{"T":["literal::imp::FreqyPacked","re_set::unicode::SetMatches","re_set::bytes::RegexSet","dfa::StateFlags","sparse::SparseSet","re_set::bytes::SetMatches","literal::imp::LiteralSearcher","re_set::unicode::RegexSet","std::clone::impls::<impl std::clone::Clone for *const T>","prog::InstSave","re_bytes::NoExpand","re_trait::SubCapturesPosIter","backtrack::Job","literal::imp::BoyerMooreSearch","dfa::State","prog::InstChar","prog::Inst","compile::SuffixCacheKey","re_unicode::NoExpand","re_unicode::CaptureLocations","input::ByteInput","expand::CaptureRef","exec::MatchNfaType","re_set::unicode::SetMatchesIter","dfa::Transitions","prog::InstBytes","std::clone::impls::<impl std::clone::Clone for *mut T>","re_bytes::CaptureLocations","input::InputAt","literal::imp::SingleByteSet","input::Char","error::Error","re_bytes::SubCaptureMatches","prog::InstRanges","re_unicode::CaptureNames","exec::MatchLiteralType","pikevm::Threads","prog::Program","re_bytes::Regex","backtrack::Cache","re_bytes::Match","compile::MaybeInst","pikevm::Cache","re_set::bytes::SetMatchesIter","prog::InstSplit","compile::InstHole","literal::imp::Matcher","dfa::Result","re_bytes::CaptureNames","expand::Ref","pikevm::FollowEpsilon","compile::SuffixCacheEntry","exec::MatchType","re_unicode::Regex","dfa::Byte","prog::InstEmptyLook","re_builder::RegexOptions","input::CharInput","re_unicode::Match","re_unicode::SubCaptureMatches","dfa::EmptyFlags","prog::EmptyLook","exec::Exec","re_trait::Locations"]},"dfa::Result":{"T":["exec::MatchNfaType","dfa::State","re_bytes::NoExpand","re_set::bytes::RegexSet","prog::InstChar","input::CharInput","<&mut T as std::fmt::Debug>","prog::InstSplit","input::ByteInput","re_set::unicode::SetMatchesIter","re_unicode::NoExpand","literal::imp::LiteralSearcher","compile::InstHole","compile::MaybeInst","backtrack::Cache","re_bytes::Regex","re_set::unicode::SetMatches","re_unicode::SubCaptureMatches","exec::Exec","pikevm::FollowEpsilon","literal::imp::FreqyPacked","dfa::StateFlags","literal::imp::Matcher","literal::imp::BoyerMooreSearch","compile::SuffixCacheEntry","re_trait::Locations","dfa::Transitions","re_set::bytes::SetMatchesIter","re_trait::SubCapturesPosIter","input::Char","re_unicode::Regex","re_unicode::Match","re_bytes::Match","input::InputAt","re_bytes::CaptureLocations","prog::EmptyLook","prog::InstBytes","re_builder::RegexOptions","prog::Program","literal::imp::SingleByteSet","prog::InstRanges","re_unicode::CaptureLocations","expand::CaptureRef","prog::Inst","backtrack::Job","re_set::bytes::SetMatches","dfa::EmptyFlags","compile::SuffixCacheKey","expand::Ref","prog::InstSave","pikevm::Cache","prog::InstEmptyLook","pikevm::Threads","exec::MatchType","dfa::Byte","exec::MatchLiteralType","re_set::unicode::RegexSet","re_bytes::CaptureNames","re_unicode::CaptureNames","dfa::Result","re_bytes::SubCaptureMatches","sparse::SparseSet","error::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Result<T>
+p0.clone();
+<dfa::Result<T> as std::clone::Clone>::clone(p0);
+crate::<dfa::Result<T> as std::clone::Clone>::clone(p0);
+<dfa::Result<T>>::clone(p0);
-----------------
src/dfa.rs <dfa::Result<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<dfa::Result<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"backtrack::Bounded":{"I":["std::fmt::Debug","std::marker::Sized","input::Input"]},"cache::imp::Cached":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"cache::imp::CachedGuard":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"dfa::Result":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"pikevm::Fsm":{"I":["input::Input","std::fmt::Debug","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::fmt::Debug","std::marker::Sized","re_trait::RegularExpression"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<dfa::Result<T> as std::fmt::Debug>::fmt":{"T":["re_unicode::Split","exec::MatchLiteralType","re_bytes::NoExpand","re_bytes::SplitN","re_unicode::CaptureNames","re_trait::Matches","prog::InstEmptyLook","backtrack::Cache","re_set::bytes::SetMatches","re_bytes::CaptureNames","literal::imp::FreqyPacked","prog::InstRanges","re_unicode::CaptureMatches","re_set::unicode::RegexSet","prog::Inst","re_bytes::CapturesDebug","compile::SuffixCacheKey","exec::ExecNoSync","compile::Patch","exec::ProgramCacheInner","sparse::SparseSet","re_bytes::Captures","re_unicode::Matches","prog::InstChar","dfa::Fsm","re_bytes::Match","prog::Program","re_builder::set_unicode::RegexSetBuilder","re_unicode::ReplacerRef","literal::imp::Matcher","re_unicode::SubCaptureMatches","error::Error","backtrack::Bounded","re_bytes::CaptureMatches","exec::ExecReadOnly","prog::InstSave","re_set::unicode::SetMatchesIntoIter","cache::imp::Cached","re_trait::SubCapturesPosIter","dfa::Transitions","compile::SuffixCache","re_set::bytes::SetMatchesIntoIter","re_set::bytes::RegexSet","re_bytes::Split","prog::InstSplit","dfa::State","input::ByteInput","dfa::Result","dfa::Cache","literal::imp::BoyerMooreSearch","re_set::bytes::SetMatchesIter","dfa::TransitionsRow","pikevm::Cache","re_unicode::Match","literal::imp::SingleByteSet","re_set::unicode::SetMatches","exec::ExecNoSyncStr","re_set::unicode::SetMatchesIter","re_unicode::CaptureLocations","pikevm::FollowEpsilon","dfa::CacheInner","re_unicode::Captures","compile::MaybeInst","literal::imp::LiteralIter","literal::imp::LiteralSearcher","dfa::StateFlags","expand::Ref","re_builder::unicode::RegexBuilder","re_trait::CaptureMatches","re_builder::bytes::RegexBuilder","input::CharInput","expand::CaptureRef","exec::Exec","cache::imp::CachedGuard","exec::MatchNfaType","re_builder::set_bytes::RegexSetBuilder","compile::Hole","re_unicode::CapturesDebug","exec::MatchType","prog::InstBytes","compile::ByteClassSet","<&mut T as std::fmt::Debug>","compile::InstHole","re_builder::RegexOptions","prog::EmptyLook","dfa::EmptyFlags","re_unicode::Regex","<&T as std::fmt::Debug>","pikevm::Threads","re_trait::Locations","dfa::Byte","dfa::StateMap","input::InputAt","re_bytes::Regex","re_bytes::CaptureLocations","input::Char","re_bytes::Matches","re_bytes::SubCaptureMatches","pikevm::Fsm","re_unicode::NoExpand","backtrack::Job","re_unicode::SplitN","compile::SuffixCacheEntry","re_bytes::ReplacerRef"]},"backtrack::Bounded":{"I":["input::ByteInput","input::CharInput"]},"cache::imp::Cached":{"T":["std::sync::mpmc::Receiver<T>","std::sync::RwLockReadGuard<'_, T>","std::cell::Cell<T>","std::future::ResumeTy","std::sync::mpmc::Sender<T>","std::sys::unix::args::Args","std::io::IoSlice<'a>","std::vec::Drain<'_, T, A>","std::sync::mpsc::SyncSender<T>","std::sync::OnceLock<T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::RwLockWriteGuard<'_, T>","std::thread::JoinHandle<T>","std::io::IoSliceMut<'a>","std::env::ArgsOs","std::rc::Weak<T>","std::env::Args","std::sync::atomic::AtomicPtr<T>","std::sync::Mutex<T>","std::vec::IntoIter<T, A>","std::collections::linked_list::CursorMut<'_, T>","std::sync::MutexGuard<'_, T>","std::rc::Rc<T>","std::cell::RefCell<T>","std::sync::Weak<T>","std::ptr::NonNull<T>","std::sync::Arc<T>","std::collections::linked_list::Cursor<'_, T>","std::slice::IterMut<'_, T>","std::sync::mpsc::Sender<T>","std::string::Drain<'_>","std::task::Waker","<&T as std::fmt::Debug>","std::sync::RwLock<T>","std::ptr::Unique<T>","std::io::error::repr_bitpacked::Repr","std::slice::Iter<'_, T>","std::ptr::DynMetadata<Dyn>","std::boxed::ThinBox<T>","std::collections::LinkedList<T>","std::sync::mpsc::Receiver<T>","std::collections::linked_list::IterMut<'_, T>","std::collections::linked_list::Iter<'_, T>"]},"cache::imp::CachedGuard":{"T":["std::collections::linked_list::IterMut<'_, T>","std::sync::mpmc::Receiver<T>","std::future::ResumeTy","std::sync::Mutex<T>","std::sync::RwLock<T>","std::slice::Iter<'_, T>","std::sync::Weak<T>","std::sync::atomic::AtomicPtr<T>","std::collections::LinkedList<T>","std::cell::RefCell<T>","std::ptr::DynMetadata<Dyn>","std::collections::vec_deque::Drain<'_, T, A>","std::thread::JoinHandle<T>","std::env::ArgsOs","std::sync::RwLockWriteGuard<'_, T>","std::vec::IntoIter<T, A>","std::env::Args","std::sync::MutexGuard<'_, T>","std::sync::Arc<T>","std::sys::unix::args::Args","std::sync::mpmc::Sender<T>","std::collections::linked_list::Cursor<'_, T>","std::io::IoSlice<'a>","std::collections::linked_list::CursorMut<'_, T>","std::slice::IterMut<'_, T>","std::boxed::ThinBox<T>","std::sync::RwLockReadGuard<'_, T>","std::task::Waker","std::sync::mpsc::Sender<T>","std::collections::linked_list::Iter<'_, T>","std::string::Drain<'_>","std::rc::Rc<T>","std::cell::Cell<T>","std::rc::Weak<T>","std::io::error::repr_bitpacked::Repr","<*mut T as std::fmt::Debug>","std::sync::mpsc::Receiver<T>","std::ptr::Unique<T>","std::sync::OnceLock<T>","std::ptr::NonNull<T>","std::vec::Drain<'_, T, A>","std::io::IoSliceMut<'a>","std::sync::mpsc::SyncSender<T>"]},"dfa::Result":{"T":["re_unicode::Match","literal::imp::BoyerMooreSearch","dfa::Transitions","re_set::bytes::SetMatches","pikevm::Threads","prog::InstSplit","literal::imp::Matcher","re_set::unicode::RegexSet","re_builder::RegexOptions","backtrack::Cache","prog::InstSave","dfa::State","prog::Inst","re_bytes::NoExpand","re_unicode::CaptureNames","re_set::unicode::SetMatches","dfa::Result","pikevm::Cache","re_set::unicode::SetMatchesIter","re_unicode::CaptureLocations","re_unicode::SubCaptureMatches","exec::Exec","dfa::Byte","exec::MatchNfaType","re_unicode::NoExpand","literal::imp::FreqyPacked","literal::imp::SingleByteSet","input::InputAt","literal::imp::LiteralSearcher","expand::CaptureRef","prog::EmptyLook","re_unicode::Regex","prog::InstEmptyLook","compile::MaybeInst","dfa::EmptyFlags","re_set::bytes::SetMatchesIter","expand::Ref","prog::Program","std::clone::impls::<impl std::clone::Clone for &T>","pikevm::FollowEpsilon","prog::InstRanges","dfa::StateFlags","re_bytes::CaptureLocations","backtrack::Job","re_bytes::Match","compile::SuffixCacheEntry","re_trait::Locations","re_bytes::CaptureNames","compile::InstHole","input::ByteInput","error::Error","prog::InstChar","prog::InstBytes","sparse::SparseSet","re_bytes::Regex","compile::SuffixCacheKey","exec::MatchType","exec::MatchLiteralType","re_trait::SubCapturesPosIter","input::CharInput","input::Char","re_set::bytes::RegexSet","re_bytes::SubCaptureMatches"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Result<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Result<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Result<T> as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Result<T>>::fmt(p0, p1);
-----------------
src/dfa.rs dfa::Result::<T>::is_match
deps:{"dfa::Result::<T>::is_match":{"T":["std::marker::Sized"]}}
candidates:{"dfa::Result::<T>::is_match":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Result<T>
+p0.is_match();
+dfa::Result::<T>::is_match(p0);
+crate::dfa::Result::<T>::is_match(p0);
+<dfa::Result<T>>::is_match(p0);
-----------------
src/dfa.rs dfa::Result::<T>::map
deps:{"dfa::Result::<T>::map":{"F":["std::ops::FnMut","std::marker::Sized"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"dfa::Result::<T>::map":{"F":["core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // dfa::Result<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+dfa::Result::<T>::map(p0, p1);
+crate::dfa::Result::<T>::map(p0, p1);
+<dfa::Result<T>>::map(p0, p1);
-----------------
src/dfa.rs dfa::Result::<T>::set_non_match
deps:{"dfa::Result::<T>::set_non_match":{"T":["std::marker::Sized"]}}
candidates:{"dfa::Result::<T>::set_non_match":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // dfa::Result<T>
let mut p1 = 0usize; // None+usize
+p0.set_non_match(p1);
+dfa::Result::<T>::set_non_match(p0, p1);
+crate::dfa::Result::<T>::set_non_match(p0, p1);
+<dfa::Result<T>>::set_non_match(p0, p1);
-----------------
src/dfa.rs <dfa::State as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.clone();
+<dfa::State as std::clone::Clone>::clone(p0);
+crate::<dfa::State as std::clone::Clone>::clone(p0);
+<dfa::State>::clone(p0);
-----------------
src/dfa.rs <dfa::State as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.assert_receiver_is_total_eq();
+<dfa::State as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<dfa::State as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<dfa::State>::assert_receiver_is_total_eq(p0);
-----------------
src/dfa.rs <dfa::State as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<dfa::State as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<dfa::State as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<dfa::State as std::hash::Hash>::hash(p0, p1);
+crate::<dfa::State as std::hash::Hash>::hash(p0, p1);
+<dfa::State>::hash(p0, p1);
-----------------
src/dfa.rs <dfa::State as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
let mut p1 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.eq(p1);
+<dfa::State as std::cmp::PartialEq>::eq(p0, p1);
+crate::<dfa::State as std::cmp::PartialEq>::eq(p0, p1);
+<dfa::State>::eq(p0, p1);
-----------------
src/dfa.rs <dfa::InstPtrs<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::InstPtrs<'a>
+p0.next();
+<dfa::InstPtrs<'a> as std::iter::Iterator>::next(p0);
+crate::<dfa::InstPtrs<'a> as std::iter::Iterator>::next(p0);
+<dfa::InstPtrs<'a>>::next(p0);
-----------------
src/dfa.rs dfa::State::flags
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.flags();
+dfa::State::flags(p0);
+crate::dfa::State::flags(p0);
+<dfa::State>::flags(p0);
-----------------
src/dfa.rs dfa::State::inst_ptrs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.inst_ptrs();
+dfa::State::inst_ptrs(p0);
+crate::dfa::State::inst_ptrs(p0);
+<dfa::State>::inst_ptrs(p0);
-----------------
src/dfa.rs <dfa::Byte as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.clone();
+<dfa::Byte as std::clone::Clone>::clone(p0);
+crate::<dfa::Byte as std::clone::Clone>::clone(p0);
+<dfa::Byte>::clone(p0);
-----------------
src/dfa.rs <dfa::Byte as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Byte as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Byte as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Byte>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
+p0.clone();
+<dfa::EmptyFlags as std::clone::Clone>::clone(p0);
+crate::<dfa::EmptyFlags as std::clone::Clone>::clone(p0);
+<dfa::EmptyFlags>::clone(p0);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
+p0.assert_receiver_is_total_eq();
+<dfa::EmptyFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<dfa::EmptyFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<dfa::EmptyFlags>::assert_receiver_is_total_eq(p0);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::EmptyFlags as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::EmptyFlags as std::fmt::Debug>::fmt(p0, p1);
+<dfa::EmptyFlags>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::default::Default>::default
deps:{}
candidates:{}
+<dfa::EmptyFlags as std::default::Default>::default();
+crate::<dfa::EmptyFlags as std::default::Default>::default();
+<dfa::EmptyFlags>::default();
-----------------
src/dfa.rs <dfa::EmptyFlags as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<dfa::EmptyFlags as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<dfa::EmptyFlags as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<dfa::EmptyFlags as std::hash::Hash>::hash(p0, p1);
+crate::<dfa::EmptyFlags as std::hash::Hash>::hash(p0, p1);
+<dfa::EmptyFlags>::hash(p0, p1);
-----------------
src/dfa.rs <dfa::EmptyFlags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
let mut p1 = & MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
+p0.eq(p1);
+<dfa::EmptyFlags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<dfa::EmptyFlags as std::cmp::PartialEq>::eq(p0, p1);
+<dfa::EmptyFlags>::eq(p0, p1);
-----------------
src/dfa.rs <dfa::StateFlags as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.clone();
+<dfa::StateFlags as std::clone::Clone>::clone(p0);
+crate::<dfa::StateFlags as std::clone::Clone>::clone(p0);
+<dfa::StateFlags>::clone(p0);
-----------------
src/dfa.rs <dfa::StateFlags as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.assert_receiver_is_total_eq();
+<dfa::StateFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<dfa::StateFlags as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<dfa::StateFlags>::assert_receiver_is_total_eq(p0);
-----------------
src/dfa.rs <dfa::StateFlags as std::default::Default>::default
deps:{}
candidates:{}
+<dfa::StateFlags as std::default::Default>::default();
+crate::<dfa::StateFlags as std::default::Default>::default();
+<dfa::StateFlags>::default();
-----------------
src/dfa.rs <dfa::StateFlags as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<dfa::StateFlags as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<dfa::StateFlags as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::hash::SipHasher","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<dfa::StateFlags as std::hash::Hash>::hash(p0, p1);
+crate::<dfa::StateFlags as std::hash::Hash>::hash(p0, p1);
+<dfa::StateFlags>::hash(p0, p1);
-----------------
src/dfa.rs <dfa::StateFlags as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
let mut p1 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.eq(p1);
+<dfa::StateFlags as std::cmp::PartialEq>::eq(p0, p1);
+crate::<dfa::StateFlags as std::cmp::PartialEq>::eq(p0, p1);
+<dfa::StateFlags>::eq(p0, p1);
-----------------
src/dfa.rs dfa::Cache::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+dfa::Cache::new(p0);
+crate::dfa::Cache::new(p0);
+<dfa::Cache>::new(p0);
-----------------
src/dfa.rs dfa::CacheInner::reset_size
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::CacheInner
+p0.reset_size();
+dfa::CacheInner::reset_size(p0);
+crate::dfa::CacheInner::reset_size(p0);
+<dfa::CacheInner>::reset_size(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::forward
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<exec::ProgramCacheInner>
let mut p2 = true; // None+bool
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
+dfa::Fsm::<'a>::forward(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::forward(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::forward(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::reverse
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<exec::ProgramCacheInner>
let mut p2 = true; // None+bool
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
+dfa::Fsm::<'a>::reverse(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::reverse(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::reverse(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::forward_many
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<exec::ProgramCacheInner>
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
+dfa::Fsm::<'a>::forward_many(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::forward_many(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::forward_many(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::exec_at
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.exec_at(p1, p2, p3);
+dfa::Fsm::<'a>::exec_at(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::exec_at(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::exec_at(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::exec_at_reverse
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.exec_at_reverse(p1, p2, p3);
+dfa::Fsm::<'a>::exec_at_reverse(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::exec_at_reverse(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::exec_at_reverse(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::next_si
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u32; // None+u32
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.next_si(p1, p2, p3);
+dfa::Fsm::<'a>::next_si(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::next_si(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::next_si(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::exec_byte
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = 0u32; // None+u32
let mut p4 = MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.exec_byte(p1, p2, p3, p4);
+dfa::Fsm::<'a>::exec_byte(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::exec_byte(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::exec_byte(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::follow_epsilons
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u32; // None+u32
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
+p0.follow_epsilons(p1, p2, p3);
+dfa::Fsm::<'a>::follow_epsilons(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::follow_epsilons(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::follow_epsilons(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::cached_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = MaybeUninit::uninit().assume_init(); // dfa::StateFlags
let mut p3 = MaybeUninit::uninit().assume_init(); // std::option::Option<&mut u32>
+p0.cached_state(p1, p2, p3);
+dfa::Fsm::<'a>::cached_state(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::cached_state(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::cached_state(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::cached_state_key
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.cached_state_key(p1, p2);
+dfa::Fsm::<'a>::cached_state_key(p0, p1, p2);
+crate::dfa::Fsm::<'a>::cached_state_key(p0, p1, p2);
+<dfa::Fsm<'a>>::cached_state_key(p0, p1, p2);
-----------------
src/dfa.rs dfa::Fsm::<'a>::clear_cache_and_save
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<&mut u32>
+p0.clear_cache_and_save(p1);
+dfa::Fsm::<'a>::clear_cache_and_save(p0, p1);
+crate::dfa::Fsm::<'a>::clear_cache_and_save(p0, p1);
+<dfa::Fsm<'a>>::clear_cache_and_save(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::clear_cache
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.clear_cache();
+dfa::Fsm::<'a>::clear_cache(p0);
+crate::dfa::Fsm::<'a>::clear_cache(p0);
+<dfa::Fsm<'a>>::clear_cache(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::restore_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // dfa::State
+p0.restore_state(p1);
+dfa::Fsm::<'a>::restore_state(p0, p1);
+crate::dfa::Fsm::<'a>::restore_state(p0, p1);
+<dfa::Fsm<'a>>::restore_state(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::next_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p3 = 0u32; // None+u32
let mut p4 = MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.next_state(p1, p2, p3, p4);
+dfa::Fsm::<'a>::next_state(p0, p1, p2, p3, p4);
+crate::dfa::Fsm::<'a>::next_state(p0, p1, p2, p3, p4);
+<dfa::Fsm<'a>>::next_state(p0, p1, p2, p3, p4);
-----------------
src/dfa.rs dfa::Fsm::<'a>::start_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p2 = MaybeUninit::uninit().assume_init(); // dfa::EmptyFlags
let mut p3 = MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.start_state(p1, p2, p3);
+dfa::Fsm::<'a>::start_state(p0, p1, p2, p3);
+crate::dfa::Fsm::<'a>::start_state(p0, p1, p2, p3);
+<dfa::Fsm<'a>>::start_state(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Fsm::<'a>::start_flags
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.start_flags(p1, p2);
+dfa::Fsm::<'a>::start_flags(p0, p1, p2);
+crate::dfa::Fsm::<'a>::start_flags(p0, p1, p2);
+<dfa::Fsm<'a>>::start_flags(p0, p1, p2);
-----------------
src/dfa.rs dfa::Fsm::<'a>::start_flags_reverse
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.start_flags_reverse(p1, p2);
+dfa::Fsm::<'a>::start_flags_reverse(p0, p1, p2);
+crate::dfa::Fsm::<'a>::start_flags_reverse(p0, p1, p2);
+<dfa::Fsm<'a>>::start_flags_reverse(p0, p1, p2);
-----------------
src/dfa.rs dfa::Fsm::<'a>::state
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u32; // None+u32
+p0.state(p1);
+dfa::Fsm::<'a>::state(p0, p1);
+crate::dfa::Fsm::<'a>::state(p0, p1);
+<dfa::Fsm<'a>>::state(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::add_state
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // dfa::State
+p0.add_state(p1);
+dfa::Fsm::<'a>::add_state(p0, p1);
+crate::dfa::Fsm::<'a>::add_state(p0, p1);
+<dfa::Fsm<'a>>::add_state(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::prefix_at
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.prefix_at(p1, p2);
+dfa::Fsm::<'a>::prefix_at(p0, p1, p2);
+crate::dfa::Fsm::<'a>::prefix_at(p0, p1, p2);
+<dfa::Fsm<'a>>::prefix_at(p0, p1, p2);
-----------------
src/dfa.rs dfa::Fsm::<'a>::num_byte_classes
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.num_byte_classes();
+dfa::Fsm::<'a>::num_byte_classes(p0);
+crate::dfa::Fsm::<'a>::num_byte_classes(p0);
+<dfa::Fsm<'a>>::num_byte_classes(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::byte_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.byte_class(p1);
+dfa::Fsm::<'a>::byte_class(p0, p1);
+crate::dfa::Fsm::<'a>::byte_class(p0, p1);
+<dfa::Fsm<'a>>::byte_class(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::u8_class
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u8; // None+u8
+p0.u8_class(p1);
+dfa::Fsm::<'a>::u8_class(p0, p1);
+crate::dfa::Fsm::<'a>::u8_class(p0, p1);
+<dfa::Fsm<'a>>::u8_class(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::continue_past_first_match
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.continue_past_first_match();
+dfa::Fsm::<'a>::continue_past_first_match(p0);
+crate::dfa::Fsm::<'a>::continue_past_first_match(p0);
+<dfa::Fsm<'a>>::continue_past_first_match(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::has_prefix
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.has_prefix();
+dfa::Fsm::<'a>::has_prefix(p0);
+crate::dfa::Fsm::<'a>::has_prefix(p0);
+<dfa::Fsm<'a>>::has_prefix(p0);
-----------------
src/dfa.rs dfa::Fsm::<'a>::start_ptr
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
let mut p1 = 0u32; // None+u32
+p0.start_ptr(p1);
+dfa::Fsm::<'a>::start_ptr(p0, p1);
+crate::dfa::Fsm::<'a>::start_ptr(p0, p1);
+<dfa::Fsm<'a>>::start_ptr(p0, p1);
-----------------
src/dfa.rs dfa::Fsm::<'a>::approximate_size
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Fsm<'a>
+p0.approximate_size();
+dfa::Fsm::<'a>::approximate_size(p0);
+crate::dfa::Fsm::<'a>::approximate_size(p0);
+<dfa::Fsm<'a>>::approximate_size(p0);
-----------------
src/dfa.rs <dfa::StateMap as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::StateMap as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::StateMap as std::fmt::Debug>::fmt(p0, p1);
+<dfa::StateMap>::fmt(p0, p1);
-----------------
src/dfa.rs dfa::StateMap::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+dfa::StateMap::new(p0);
+crate::dfa::StateMap::new(p0);
+<dfa::StateMap>::new(p0);
-----------------
src/dfa.rs dfa::StateMap::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
+p0.len();
+dfa::StateMap::len(p0);
+crate::dfa::StateMap::len(p0);
+<dfa::StateMap>::len(p0);
-----------------
src/dfa.rs dfa::StateMap::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
+p0.is_empty();
+dfa::StateMap::is_empty(p0);
+crate::dfa::StateMap::is_empty(p0);
+<dfa::StateMap>::is_empty(p0);
-----------------
src/dfa.rs dfa::StateMap::get_ptr
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // dfa::State
+p0.get_ptr(p1);
+dfa::StateMap::get_ptr(p0, p1);
+crate::dfa::StateMap::get_ptr(p0, p1);
+<dfa::StateMap>::get_ptr(p0, p1);
-----------------
src/dfa.rs dfa::StateMap::get_state
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateMap
let mut p1 = 0u32; // None+u32
+p0.get_state(p1);
+dfa::StateMap::get_state(p0, p1);
+crate::dfa::StateMap::get_state(p0, p1);
+<dfa::StateMap>::get_state(p0, p1);
-----------------
src/dfa.rs dfa::StateMap::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateMap
let mut p1 = MaybeUninit::uninit().assume_init(); // dfa::State
let mut p2 = 0u32; // None+u32
+p0.insert(p1, p2);
+dfa::StateMap::insert(p0, p1, p2);
+crate::dfa::StateMap::insert(p0, p1, p2);
+<dfa::StateMap>::insert(p0, p1, p2);
-----------------
src/dfa.rs dfa::StateMap::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateMap
+p0.clear();
+dfa::StateMap::clear(p0);
+crate::dfa::StateMap::clear(p0);
+<dfa::StateMap>::clear(p0);
-----------------
src/dfa.rs dfa::Transitions::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+dfa::Transitions::new(p0);
+crate::dfa::Transitions::new(p0);
+<dfa::Transitions>::new(p0);
-----------------
src/dfa.rs dfa::Transitions::num_states
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.num_states();
+dfa::Transitions::num_states(p0);
+crate::dfa::Transitions::num_states(p0);
+<dfa::Transitions>::num_states(p0);
-----------------
src/dfa.rs dfa::Transitions::add
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.add();
+dfa::Transitions::add(p0);
+crate::dfa::Transitions::add(p0);
+<dfa::Transitions>::add(p0);
-----------------
src/dfa.rs dfa::Transitions::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.clear();
+dfa::Transitions::clear(p0);
+crate::dfa::Transitions::clear(p0);
+<dfa::Transitions>::clear(p0);
-----------------
src/dfa.rs dfa::Transitions::set_next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::Transitions
let mut p1 = 0u32; // None+u32
let mut p2 = 0usize; // None+usize
let mut p3 = 0u32; // None+u32
+p0.set_next(p1, p2, p3);
+dfa::Transitions::set_next(p0, p1, p2, p3);
+crate::dfa::Transitions::set_next(p0, p1, p2, p3);
+<dfa::Transitions>::set_next(p0, p1, p2, p3);
-----------------
src/dfa.rs dfa::Transitions::next
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
let mut p1 = 0u32; // None+u32
let mut p2 = 0usize; // None+usize
+p0.next(p1, p2);
+dfa::Transitions::next(p0, p1, p2);
+crate::dfa::Transitions::next(p0, p1, p2);
+<dfa::Transitions>::next(p0, p1, p2);
-----------------
src/dfa.rs dfa::Transitions::state_heap_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
+p0.state_heap_size();
+dfa::Transitions::state_heap_size(p0);
+crate::dfa::Transitions::state_heap_size(p0);
+<dfa::Transitions>::state_heap_size(p0);
-----------------
src/dfa.rs dfa::Transitions::next_unchecked
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
let mut p1 = 0u32; // None+u32
let mut p2 = 0usize; // None+usize
+p0.next_unchecked(p1, p2);
+dfa::Transitions::next_unchecked(p0, p1, p2);
+crate::dfa::Transitions::next_unchecked(p0, p1, p2);
+<dfa::Transitions>::next_unchecked(p0, p1, p2);
-----------------
src/dfa.rs dfa::StateFlags::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.is_match();
+dfa::StateFlags::is_match(p0);
+crate::dfa::StateFlags::is_match(p0);
+<dfa::StateFlags>::is_match(p0);
-----------------
src/dfa.rs dfa::StateFlags::set_match
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.set_match();
+dfa::StateFlags::set_match(p0);
+crate::dfa::StateFlags::set_match(p0);
+<dfa::StateFlags>::set_match(p0);
-----------------
src/dfa.rs dfa::StateFlags::is_word
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.is_word();
+dfa::StateFlags::is_word(p0);
+crate::dfa::StateFlags::is_word(p0);
+<dfa::StateFlags>::is_word(p0);
-----------------
src/dfa.rs dfa::StateFlags::set_word
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.set_word();
+dfa::StateFlags::set_word(p0);
+crate::dfa::StateFlags::set_word(p0);
+<dfa::StateFlags>::set_word(p0);
-----------------
src/dfa.rs dfa::StateFlags::has_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.has_empty();
+dfa::StateFlags::has_empty(p0);
+crate::dfa::StateFlags::has_empty(p0);
+<dfa::StateFlags>::has_empty(p0);
-----------------
src/dfa.rs dfa::StateFlags::set_empty
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // dfa::StateFlags
+p0.set_empty();
+dfa::StateFlags::set_empty(p0);
+crate::dfa::StateFlags::set_empty(p0);
+<dfa::StateFlags>::set_empty(p0);
-----------------
src/dfa.rs dfa::Byte::byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+dfa::Byte::byte(p0);
+crate::dfa::Byte::byte(p0);
+<dfa::Byte>::byte(p0);
-----------------
src/dfa.rs dfa::Byte::eof
deps:{}
candidates:{}
+dfa::Byte::eof();
+crate::dfa::Byte::eof();
+<dfa::Byte>::eof();
-----------------
src/dfa.rs dfa::Byte::is_eof
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.is_eof();
+dfa::Byte::is_eof(p0);
+crate::dfa::Byte::is_eof(p0);
+<dfa::Byte>::is_eof(p0);
-----------------
src/dfa.rs dfa::Byte::is_ascii_word
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.is_ascii_word();
+dfa::Byte::is_ascii_word(p0);
+crate::dfa::Byte::is_ascii_word(p0);
+<dfa::Byte>::is_ascii_word(p0);
-----------------
src/dfa.rs dfa::Byte::as_byte
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Byte
+p0.as_byte();
+dfa::Byte::as_byte(p0);
+crate::dfa::Byte::as_byte(p0);
+<dfa::Byte>::as_byte(p0);
-----------------
src/dfa.rs <dfa::State as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::State
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::State as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::State as std::fmt::Debug>::fmt(p0, p1);
+<dfa::State>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::Transitions as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::Transitions
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::Transitions as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::Transitions as std::fmt::Debug>::fmt(p0, p1);
+<dfa::Transitions>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::TransitionsRow<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::TransitionsRow<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::TransitionsRow<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::TransitionsRow<'a> as std::fmt::Debug>::fmt(p0, p1);
+<dfa::TransitionsRow<'a>>::fmt(p0, p1);
-----------------
src/dfa.rs <dfa::StateFlags as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // dfa::StateFlags
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<dfa::StateFlags as std::fmt::Debug>::fmt(p0, p1);
+crate::<dfa::StateFlags as std::fmt::Debug>::fmt(p0, p1);
+<dfa::StateFlags>::fmt(p0, p1);
-----------------
src/error.rs <error::Error as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.clone();
+<error::Error as std::clone::Clone>::clone(p0);
+crate::<error::Error as std::clone::Clone>::clone(p0);
+<error::Error>::clone(p0);
-----------------
src/error.rs <error::Error as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.eq(p1);
+<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::Error as std::cmp::PartialEq>::eq(p0, p1);
+<error::Error>::eq(p0, p1);
-----------------
src/error.rs <error::Error as std::error::Error>::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.description();
+<error::Error as std::error::Error>::description(p0);
+crate::<error::Error as std::error::Error>::description(p0);
+<error::Error>::description(p0);
-----------------
src/error.rs <error::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Display>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error.rs <error::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Debug>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/exec.rs <exec::Exec as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::Exec as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::Exec as std::fmt::Debug>::fmt(p0, p1);
+<exec::Exec>::fmt(p0, p1);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as std::fmt::Debug>::fmt
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::ExecNoSync<'c> as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::ExecNoSync<'c> as std::fmt::Debug>::fmt(p0, p1);
+<exec::ExecNoSync<'c>>::fmt(p0, p1);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as std::fmt::Debug>::fmt
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::ExecNoSyncStr<'c> as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::ExecNoSyncStr<'c> as std::fmt::Debug>::fmt(p0, p1);
+<exec::ExecNoSyncStr<'c>>::fmt(p0, p1);
-----------------
src/exec.rs <exec::ExecReadOnly as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::ExecReadOnly as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::ExecReadOnly as std::fmt::Debug>::fmt(p0, p1);
+<exec::ExecReadOnly>::fmt(p0, p1);
-----------------
src/exec.rs exec::ExecBuilder::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+exec::ExecBuilder::new(&p0);
+crate::exec::ExecBuilder::new(&p0);
+<exec::ExecBuilder>::new(&p0);
-----------------
src/exec.rs exec::ExecBuilder::new_many
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"exec::ExecBuilder::new_many":{"I":["std::marker::Sized","std::iter::IntoIterator"],"S":["std::convert::AsRef","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["re_set::unicode::SetMatchesIter","re_unicode::Split","re_unicode::SubCaptureMatches","<&mut I as std::iter::Iterator>","re_unicode::CaptureNames","re_set::bytes::SetMatchesIter","re_bytes::Split","re_set::bytes::SetMatchesIntoIter","re_trait::SubCapturesPosIter","re_bytes::CaptureNames","literal::imp::LiteralIter","re_trait::CaptureMatches","re_bytes::CaptureMatches","re_trait::Matches","re_unicode::Matches","re_unicode::SplitN","dfa::InstPtrs","re_bytes::SubCaptureMatches","re_bytes::Matches","re_unicode::CaptureMatches","re_bytes::SplitN","re_set::unicode::SetMatchesIntoIter"]},"exec::ExecBuilder::new_many":{"I":["re_set::bytes::SetMatches","re_set::unicode::SetMatches","<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>"],"S":["std::vec::Drain<'a, T, A>","std::sync::Arc<T>","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, std::ffi::OsStr>","<&mut T as std::convert::AsRef<U>>","std::borrow::Cow<'_, T>","std::ffi::CString","std::vec::IntoIter<T, A>","std::boxed::Box<T, A>","std::slice::IterMut<'_, T>","std::slice::Iter<'_, T>","std::rc::Rc<T>","<&T as std::convert::AsRef<U>>","std::ffi::CStr"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+exec::ExecBuilder::new_many(p0);
+crate::exec::ExecBuilder::new_many(p0);
+<exec::ExecBuilder>::new_many(p0);
-----------------
src/exec.rs exec::ExecBuilder::new_options
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_builder::RegexOptions
+exec::ExecBuilder::new_options(p0);
+crate::exec::ExecBuilder::new_options(p0);
+<exec::ExecBuilder>::new_options(p0);
-----------------
src/exec.rs exec::ExecBuilder::automatic
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.automatic();
+exec::ExecBuilder::automatic(p0);
+crate::exec::ExecBuilder::automatic(p0);
+<exec::ExecBuilder>::automatic(p0);
-----------------
src/exec.rs exec::ExecBuilder::nfa
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.nfa();
+exec::ExecBuilder::nfa(p0);
+crate::exec::ExecBuilder::nfa(p0);
+<exec::ExecBuilder>::nfa(p0);
-----------------
src/exec.rs exec::ExecBuilder::bounded_backtracking
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.bounded_backtracking();
+exec::ExecBuilder::bounded_backtracking(p0);
+crate::exec::ExecBuilder::bounded_backtracking(p0);
+<exec::ExecBuilder>::bounded_backtracking(p0);
-----------------
src/exec.rs exec::ExecBuilder::bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
let mut p1 = true; // None+bool
+p0.bytes(p1);
+exec::ExecBuilder::bytes(p0, p1);
+crate::exec::ExecBuilder::bytes(p0, p1);
+<exec::ExecBuilder>::bytes(p0, p1);
-----------------
src/exec.rs exec::ExecBuilder::only_utf8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
let mut p1 = true; // None+bool
+p0.only_utf8(p1);
+exec::ExecBuilder::only_utf8(p0, p1);
+crate::exec::ExecBuilder::only_utf8(p0, p1);
+<exec::ExecBuilder>::only_utf8(p0, p1);
-----------------
src/exec.rs exec::ExecBuilder::unicode
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+exec::ExecBuilder::unicode(p0, p1);
+crate::exec::ExecBuilder::unicode(p0, p1);
+<exec::ExecBuilder>::unicode(p0, p1);
-----------------
src/exec.rs exec::ExecBuilder::parse
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.parse();
+exec::ExecBuilder::parse(p0);
+crate::exec::ExecBuilder::parse(p0);
+<exec::ExecBuilder>::parse(p0);
-----------------
src/exec.rs exec::ExecBuilder::build
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
+p0.build();
+exec::ExecBuilder::build(p0);
+crate::exec::ExecBuilder::build(p0);
+<exec::ExecBuilder>::build(p0);
-----------------
src/exec.rs exec::ExecBuilder::build_aho_corasick
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecBuilder
let mut p1 = & MaybeUninit::uninit().assume_init(); // exec::Parsed
+p0.build_aho_corasick(p1);
+exec::ExecBuilder::build_aho_corasick(p0, p1);
+crate::exec::ExecBuilder::build_aho_corasick(p0, p1);
+<exec::ExecBuilder>::build_aho_corasick(p0, p1);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::slots_len
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
+p0.slots_len();
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::slots_len(p0);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::slots_len(p0);
+<exec::ExecNoSyncStr<'c>>::slots_len(p0);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::next_after_empty
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.next_after_empty(&p1, p2);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::next_after_empty(p0, &p1, p2);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::next_after_empty(p0, &p1, p2);
+<exec::ExecNoSyncStr<'c>>::next_after_empty(p0, &p1, p2);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::shortest_match_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(&p1, p2);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::shortest_match_at(p0, &p1, p2);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::shortest_match_at(p0, &p1, p2);
+<exec::ExecNoSyncStr<'c>>::shortest_match_at(p0, &p1, p2);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::is_match_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.is_match_at(&p1, p2);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::is_match_at(p0, &p1, p2);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::is_match_at(p0, &p1, p2);
+<exec::ExecNoSyncStr<'c>>::is_match_at(p0, &p1, p2);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::find_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.find_at(&p1, p2);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::find_at(p0, &p1, p2);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::find_at(p0, &p1, p2);
+<exec::ExecNoSyncStr<'c>>::find_at(p0, &p1, p2);
-----------------
src/exec.rs <exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::captures_read_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p2 = "sample"; // None+&str
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, &p2, p3);
+<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::captures_read_at(p0, p1, &p2, p3);
+crate::<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::captures_read_at(p0, p1, &p2, p3);
+<exec::ExecNoSyncStr<'c>>::captures_read_at(p0, p1, &p2, p3);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::slots_len
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
+p0.slots_len();
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::slots_len(p0);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::slots_len(p0);
+<exec::ExecNoSync<'c>>::slots_len(p0);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::next_after_empty
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.next_after_empty(p1, p2);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::next_after_empty(p0, p1, p2);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::next_after_empty(p0, p1, p2);
+<exec::ExecNoSync<'c>>::next_after_empty(p0, p1, p2);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::shortest_match_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(p1, p2);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::shortest_match_at(p0, p1, p2);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::shortest_match_at(p0, p1, p2);
+<exec::ExecNoSync<'c>>::shortest_match_at(p0, p1, p2);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.is_match_at(p1, p2);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at(p0, p1, p2);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at(p0, p1, p2);
+<exec::ExecNoSync<'c>>::is_match_at(p0, p1, p2);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::find_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_at(p1, p2);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::find_at(p0, p1, p2);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::find_at(p0, p1, p2);
+<exec::ExecNoSync<'c>>::find_at(p0, p1, p2);
-----------------
src/exec.rs <exec::ExecNoSync<'c> as re_trait::RegularExpression>::captures_read_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, p2, p3);
+<exec::ExecNoSync<'c> as re_trait::RegularExpression>::captures_read_at(p0, p1, p2, p3);
+crate::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::captures_read_at(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::captures_read_at(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_literals
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchLiteralType
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.find_literals(p1, p2, p3);
+exec::ExecNoSync::<'c>::find_literals(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::find_literals(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::find_literals(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_dfa_forward
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_dfa_forward(p1, p2);
+exec::ExecNoSync::<'c>::find_dfa_forward(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::find_dfa_forward(p0, p1, p2);
+<exec::ExecNoSync<'c>>::find_dfa_forward(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_dfa_anchored_reverse
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_dfa_anchored_reverse(p1, p2);
+exec::ExecNoSync::<'c>::find_dfa_anchored_reverse(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::find_dfa_anchored_reverse(p0, p1, p2);
+<exec::ExecNoSync<'c>>::find_dfa_anchored_reverse(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::shortest_dfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_dfa(p1, p2);
+exec::ExecNoSync::<'c>::shortest_dfa(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::shortest_dfa(p0, p1, p2);
+<exec::ExecNoSync<'c>>::shortest_dfa(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::shortest_dfa_reverse_suffix
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_dfa_reverse_suffix(p1, p2);
+exec::ExecNoSync::<'c>::shortest_dfa_reverse_suffix(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::shortest_dfa_reverse_suffix(p0, p1, p2);
+<exec::ExecNoSync<'c>>::shortest_dfa_reverse_suffix(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::exec_dfa_reverse_suffix
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.exec_dfa_reverse_suffix(p1, p2);
+exec::ExecNoSync::<'c>::exec_dfa_reverse_suffix(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::exec_dfa_reverse_suffix(p0, p1, p2);
+<exec::ExecNoSync<'c>>::exec_dfa_reverse_suffix(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_dfa_reverse_suffix
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_dfa_reverse_suffix(p1, p2);
+exec::ExecNoSync::<'c>::find_dfa_reverse_suffix(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::find_dfa_reverse_suffix(p0, p1, p2);
+<exec::ExecNoSync<'c>>::find_dfa_reverse_suffix(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::match_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.match_nfa(p1, p2);
+exec::ExecNoSync::<'c>::match_nfa(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::match_nfa(p0, p1, p2);
+<exec::ExecNoSync<'c>>::match_nfa(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::match_nfa_type
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.match_nfa_type(p1, p2, p3);
+exec::ExecNoSync::<'c>::match_nfa_type(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::match_nfa_type(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::match_nfa_type(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::shortest_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_nfa(p1, p2);
+exec::ExecNoSync::<'c>::shortest_nfa(p0, p1, p2);
+crate::exec::ExecNoSync::<'c>::shortest_nfa(p0, p1, p2);
+<exec::ExecNoSync<'c>>::shortest_nfa(p0, p1, p2);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::shortest_nfa_type
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.shortest_nfa_type(p1, p2, p3);
+exec::ExecNoSync::<'c>::shortest_nfa_type(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::shortest_nfa_type(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::shortest_nfa_type(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::find_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.find_nfa(p1, p2, p3);
+exec::ExecNoSync::<'c>::find_nfa(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::find_nfa(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::find_nfa(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::captures_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.captures_nfa(p1, p2, p3);
+exec::ExecNoSync::<'c>::captures_nfa(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::captures_nfa(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::captures_nfa(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::captures_nfa_type
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
let mut p5 = 0usize; // None+usize
+p0.captures_nfa_type(p1, p2, p3, p4, p5);
+exec::ExecNoSync::<'c>::captures_nfa_type(p0, p1, p2, p3, p4, p5);
+crate::exec::ExecNoSync::<'c>::captures_nfa_type(p0, p1, p2, p3, p4, p5);
+<exec::ExecNoSync<'c>>::captures_nfa_type(p0, p1, p2, p3, p4, p5);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::exec_nfa
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p4 = true; // None+bool
let mut p5 = true; // None+bool
let mut p6 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p7 = 0usize; // None+usize
let mut p8 = 0usize; // None+usize
+p0.exec_nfa(p1, p2, p3, p4, p5, p6, p7, p8);
+exec::ExecNoSync::<'c>::exec_nfa(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+crate::exec::ExecNoSync::<'c>::exec_nfa(p0, p1, p2, p3, p4, p5, p6, p7, p8);
+<exec::ExecNoSync<'c>>::exec_nfa(p0, p1, p2, p3, p4, p5, p6, p7, p8);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::exec_pikevm
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = true; // None+bool
let mut p4 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p5 = 0usize; // None+usize
let mut p6 = 0usize; // None+usize
+p0.exec_pikevm(p1, p2, p3, p4, p5, p6);
+exec::ExecNoSync::<'c>::exec_pikevm(p0, p1, p2, p3, p4, p5, p6);
+crate::exec::ExecNoSync::<'c>::exec_pikevm(p0, p1, p2, p3, p4, p5, p6);
+<exec::ExecNoSync<'c>>::exec_pikevm(p0, p1, p2, p3, p4, p5, p6);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::exec_backtrack
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p4 = 0usize; // None+usize
let mut p5 = 0usize; // None+usize
+p0.exec_backtrack(p1, p2, p3, p4, p5);
+exec::ExecNoSync::<'c>::exec_backtrack(p0, p1, p2, p3, p4, p5);
+crate::exec::ExecNoSync::<'c>::exec_backtrack(p0, p1, p2, p3, p4, p5);
+<exec::ExecNoSync<'c>>::exec_backtrack(p0, p1, p2, p3, p4, p5);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::many_matches_at
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.many_matches_at(p1, p2, p3);
+exec::ExecNoSync::<'c>::many_matches_at(p0, p1, p2, p3);
+crate::exec::ExecNoSync::<'c>::many_matches_at(p0, p1, p2, p3);
+<exec::ExecNoSync<'c>>::many_matches_at(p0, p1, p2, p3);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::is_anchor_end_match
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.is_anchor_end_match(p1);
+exec::ExecNoSync::<'c>::is_anchor_end_match(p0, p1);
+crate::exec::ExecNoSync::<'c>::is_anchor_end_match(p0, p1);
+<exec::ExecNoSync<'c>>::is_anchor_end_match(p0, p1);
-----------------
src/exec.rs exec::ExecNoSync::<'c>::capture_name_idx
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSync<'c>
+p0.capture_name_idx();
+exec::ExecNoSync::<'c>::capture_name_idx(p0);
+crate::exec::ExecNoSync::<'c>::capture_name_idx(p0);
+<exec::ExecNoSync<'c>>::capture_name_idx(p0);
-----------------
src/exec.rs exec::ExecNoSyncStr::<'c>::capture_name_idx
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecNoSyncStr<'c>
+p0.capture_name_idx();
+exec::ExecNoSyncStr::<'c>::capture_name_idx(p0);
+crate::exec::ExecNoSyncStr::<'c>::capture_name_idx(p0);
+<exec::ExecNoSyncStr<'c>>::capture_name_idx(p0);
-----------------
src/exec.rs exec::Exec::searcher
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.searcher();
+exec::Exec::searcher(p0);
+crate::exec::Exec::searcher(p0);
+<exec::Exec>::searcher(p0);
-----------------
src/exec.rs exec::Exec::searcher_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.searcher_str();
+exec::Exec::searcher_str(p0);
+crate::exec::Exec::searcher_str(p0);
+<exec::Exec>::searcher_str(p0);
-----------------
src/exec.rs exec::Exec::into_regex
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.into_regex();
+exec::Exec::into_regex(p0);
+crate::exec::Exec::into_regex(p0);
+<exec::Exec>::into_regex(p0);
-----------------
src/exec.rs exec::Exec::into_regex_set
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.into_regex_set();
+exec::Exec::into_regex_set(p0);
+crate::exec::Exec::into_regex_set(p0);
+<exec::Exec>::into_regex_set(p0);
-----------------
src/exec.rs exec::Exec::into_byte_regex
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.into_byte_regex();
+exec::Exec::into_byte_regex(p0);
+crate::exec::Exec::into_byte_regex(p0);
+<exec::Exec>::into_byte_regex(p0);
-----------------
src/exec.rs exec::Exec::into_byte_regex_set
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.into_byte_regex_set();
+exec::Exec::into_byte_regex_set(p0);
+crate::exec::Exec::into_byte_regex_set(p0);
+<exec::Exec>::into_byte_regex_set(p0);
-----------------
src/exec.rs exec::Exec::regex_strings
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.regex_strings();
+exec::Exec::regex_strings(p0);
+crate::exec::Exec::regex_strings(p0);
+<exec::Exec>::regex_strings(p0);
-----------------
src/exec.rs exec::Exec::capture_names
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.capture_names();
+exec::Exec::capture_names(p0);
+crate::exec::Exec::capture_names(p0);
+<exec::Exec>::capture_names(p0);
-----------------
src/exec.rs exec::Exec::capture_name_idx
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.capture_name_idx();
+exec::Exec::capture_name_idx(p0);
+crate::exec::Exec::capture_name_idx(p0);
+<exec::Exec>::capture_name_idx(p0);
-----------------
src/exec.rs <exec::Exec as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::Exec
+p0.clone();
+<exec::Exec as std::clone::Clone>::clone(p0);
+crate::<exec::Exec as std::clone::Clone>::clone(p0);
+<exec::Exec>::clone(p0);
-----------------
src/exec.rs exec::ExecReadOnly::choose_match_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<exec::MatchType>
+p0.choose_match_type(p1);
+exec::ExecReadOnly::choose_match_type(p0, p1);
+crate::exec::ExecReadOnly::choose_match_type(p0, p1);
+<exec::ExecReadOnly>::choose_match_type(p0, p1);
-----------------
src/exec.rs exec::ExecReadOnly::choose_literal_match_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+p0.choose_literal_match_type();
+exec::ExecReadOnly::choose_literal_match_type(p0);
+crate::exec::ExecReadOnly::choose_literal_match_type(p0);
+<exec::ExecReadOnly>::choose_literal_match_type(p0);
-----------------
src/exec.rs exec::ExecReadOnly::choose_dfa_match_type
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+p0.choose_dfa_match_type();
+exec::ExecReadOnly::choose_dfa_match_type(p0);
+crate::exec::ExecReadOnly::choose_dfa_match_type(p0);
+<exec::ExecReadOnly>::choose_dfa_match_type(p0);
-----------------
src/exec.rs exec::ExecReadOnly::should_suffix_scan
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+p0.should_suffix_scan();
+exec::ExecReadOnly::should_suffix_scan(p0);
+crate::exec::ExecReadOnly::should_suffix_scan(p0);
+<exec::ExecReadOnly>::should_suffix_scan(p0);
-----------------
src/exec.rs <exec::MatchType as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchType
+p0.clone();
+<exec::MatchType as std::clone::Clone>::clone(p0);
+crate::<exec::MatchType as std::clone::Clone>::clone(p0);
+<exec::MatchType>::clone(p0);
-----------------
src/exec.rs <exec::MatchType as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::MatchType as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::MatchType as std::fmt::Debug>::fmt(p0, p1);
+<exec::MatchType>::fmt(p0, p1);
-----------------
src/exec.rs <exec::MatchLiteralType as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchLiteralType
+p0.clone();
+<exec::MatchLiteralType as std::clone::Clone>::clone(p0);
+crate::<exec::MatchLiteralType as std::clone::Clone>::clone(p0);
+<exec::MatchLiteralType>::clone(p0);
-----------------
src/exec.rs <exec::MatchLiteralType as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchLiteralType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::MatchLiteralType as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::MatchLiteralType as std::fmt::Debug>::fmt(p0, p1);
+<exec::MatchLiteralType>::fmt(p0, p1);
-----------------
src/exec.rs <exec::MatchNfaType as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
+p0.clone();
+<exec::MatchNfaType as std::clone::Clone>::clone(p0);
+crate::<exec::MatchNfaType as std::clone::Clone>::clone(p0);
+<exec::MatchNfaType>::clone(p0);
-----------------
src/exec.rs <exec::MatchNfaType as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::MatchNfaType as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::MatchNfaType as std::fmt::Debug>::fmt(p0, p1);
+<exec::MatchNfaType>::fmt(p0, p1);
-----------------
src/exec.rs <exec::MatchNfaType as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
+p0.assert_receiver_is_total_eq();
+<exec::MatchNfaType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<exec::MatchNfaType as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<exec::MatchNfaType>::assert_receiver_is_total_eq(p0);
-----------------
src/exec.rs <exec::MatchNfaType as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
let mut p1 = & MaybeUninit::uninit().assume_init(); // exec::MatchNfaType
+p0.eq(p1);
+<exec::MatchNfaType as std::cmp::PartialEq>::eq(p0, p1);
+crate::<exec::MatchNfaType as std::cmp::PartialEq>::eq(p0, p1);
+<exec::MatchNfaType>::eq(p0, p1);
-----------------
src/exec.rs <exec::ProgramCacheInner as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ProgramCacheInner
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<exec::ProgramCacheInner as std::fmt::Debug>::fmt(p0, p1);
+crate::<exec::ProgramCacheInner as std::fmt::Debug>::fmt(p0, p1);
+<exec::ProgramCacheInner>::fmt(p0, p1);
-----------------
src/exec.rs exec::ProgramCacheInner::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // exec::ExecReadOnly
+exec::ProgramCacheInner::new(p0);
+crate::exec::ProgramCacheInner::new(p0);
+<exec::ProgramCacheInner>::new(p0);
-----------------
src/expand.rs <expand::CaptureRef<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
+p0.clone();
+<expand::CaptureRef<'a> as std::clone::Clone>::clone(p0);
+crate::<expand::CaptureRef<'a> as std::clone::Clone>::clone(p0);
+<expand::CaptureRef<'a>>::clone(p0);
-----------------
src/expand.rs <expand::CaptureRef<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<expand::CaptureRef<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<expand::CaptureRef<'a> as std::fmt::Debug>::fmt(p0, p1);
+<expand::CaptureRef<'a>>::fmt(p0, p1);
-----------------
src/expand.rs <expand::CaptureRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
+p0.assert_receiver_is_total_eq();
+<expand::CaptureRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<expand::CaptureRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<expand::CaptureRef<'a>>::assert_receiver_is_total_eq(p0);
-----------------
src/expand.rs <expand::CaptureRef<'a> as std::cmp::PartialEq>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // expand::CaptureRef<'a>
+p0.eq(p1);
+<expand::CaptureRef<'a> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<expand::CaptureRef<'a> as std::cmp::PartialEq>::eq(p0, p1);
+<expand::CaptureRef<'a>>::eq(p0, p1);
-----------------
src/expand.rs <expand::Ref<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
+p0.clone();
+<expand::Ref<'a> as std::clone::Clone>::clone(p0);
+crate::<expand::Ref<'a> as std::clone::Clone>::clone(p0);
+<expand::Ref<'a>>::clone(p0);
-----------------
src/expand.rs <expand::Ref<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<expand::Ref<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<expand::Ref<'a> as std::fmt::Debug>::fmt(p0, p1);
+<expand::Ref<'a>>::fmt(p0, p1);
-----------------
src/expand.rs <expand::Ref<'a> as std::cmp::Eq>::assert_receiver_is_total_eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
+p0.assert_receiver_is_total_eq();
+<expand::Ref<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<expand::Ref<'a> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<expand::Ref<'a>>::assert_receiver_is_total_eq(p0);
-----------------
src/expand.rs <expand::Ref<'a> as std::cmp::PartialEq>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
let mut p1 = & MaybeUninit::uninit().assume_init(); // expand::Ref<'a>
+p0.eq(p1);
+<expand::Ref<'a> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<expand::Ref<'a> as std::cmp::PartialEq>::eq(p0, p1);
+<expand::Ref<'a>>::eq(p0, p1);
-----------------
src/expand.rs <expand::Ref<'a> as std::convert::From<&'a str>>::from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<expand::Ref<'a> as std::convert::From<&'a str>>::from(&p0);
+crate::<expand::Ref<'a> as std::convert::From<&'a str>>::from(&p0);
+<expand::Ref<'a>>::from(&p0);
-----------------
src/expand.rs <expand::Ref<'static> as std::convert::From<usize>>::from
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<expand::Ref<'static> as std::convert::From<usize>>::from(p0);
+crate::<expand::Ref<'static> as std::convert::From<usize>>::from(p0);
+<expand::Ref<'static>>::from(p0);
-----------------
src/input.rs <input::InputAt as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.clone();
+<input::InputAt as std::clone::Clone>::clone(p0);
+crate::<input::InputAt as std::clone::Clone>::clone(p0);
+<input::InputAt>::clone(p0);
-----------------
src/input.rs <input::InputAt as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<input::InputAt as std::fmt::Debug>::fmt(p0, p1);
+crate::<input::InputAt as std::fmt::Debug>::fmt(p0, p1);
+<input::InputAt>::fmt(p0, p1);
-----------------
src/input.rs input::InputAt::is_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.is_start();
+input::InputAt::is_start(p0);
+crate::input::InputAt::is_start(p0);
+<input::InputAt>::is_start(p0);
-----------------
src/input.rs input::InputAt::is_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.is_end();
+input::InputAt::is_end(p0);
+crate::input::InputAt::is_end(p0);
+<input::InputAt>::is_end(p0);
-----------------
src/input.rs input::InputAt::char
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.char();
+input::InputAt::char(p0);
+crate::input::InputAt::char(p0);
+<input::InputAt>::char(p0);
-----------------
src/input.rs input::InputAt::byte
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.byte();
+input::InputAt::byte(p0);
+crate::input::InputAt::byte(p0);
+<input::InputAt>::byte(p0);
-----------------
src/input.rs input::InputAt::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.len();
+input::InputAt::len(p0);
+crate::input::InputAt::len(p0);
+<input::InputAt>::len(p0);
-----------------
src/input.rs input::InputAt::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.is_empty();
+input::InputAt::is_empty(p0);
+crate::input::InputAt::is_empty(p0);
+<input::InputAt>::is_empty(p0);
-----------------
src/input.rs input::InputAt::pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.pos();
+input::InputAt::pos(p0);
+crate::input::InputAt::pos(p0);
+<input::InputAt>::pos(p0);
-----------------
src/input.rs input::InputAt::next_pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_pos();
+input::InputAt::next_pos(p0);
+crate::input::InputAt::next_pos(p0);
+<input::InputAt>::next_pos(p0);
-----------------
src/input.rs <&'a T as input::Input>::at
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::at":{"T":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::at":{"T":["<&'a T as input::Input>","input::ByteInput","input::CharInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+p0.at(p1);
+<&'a T as input::Input>::at(p0, p1);
+crate::<&'a T as input::Input>::at(p0, p1);
+<&'a T>::at(p0, p1);
-----------------
src/input.rs <&'a T as input::Input>::next_char
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::next_char":{"T":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::next_char":{"T":["<&'a T as input::Input>","input::CharInput","input::ByteInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_char(p1);
+<&'a T as input::Input>::next_char(p0, p1);
+crate::<&'a T as input::Input>::next_char(p0, p1);
+<&'a T>::next_char(p0, p1);
-----------------
src/input.rs <&'a T as input::Input>::previous_char
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::previous_char":{"T":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::previous_char":{"T":["<&'a T as input::Input>","input::ByteInput","input::CharInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.previous_char(p1);
+<&'a T as input::Input>::previous_char(p0, p1);
+crate::<&'a T as input::Input>::previous_char(p0, p1);
+<&'a T>::previous_char(p0, p1);
-----------------
src/input.rs <&'a T as input::Input>::is_empty_match
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::is_empty_match":{"T":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::is_empty_match":{"T":["input::ByteInput","input::CharInput","<&'a T as input::Input>"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.is_empty_match(p1, p2);
+<&'a T as input::Input>::is_empty_match(p0, p1, p2);
+crate::<&'a T as input::Input>::is_empty_match(p0, p1, p2);
+<&'a T>::is_empty_match(p0, p1, p2);
-----------------
src/input.rs <&'a T as input::Input>::prefix_at
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::prefix_at":{"T":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::prefix_at":{"T":["input::ByteInput","<&'a T as input::Input>","input::CharInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.prefix_at(p1, p2);
+<&'a T as input::Input>::prefix_at(p0, p1, p2);
+crate::<&'a T as input::Input>::prefix_at(p0, p1, p2);
+<&'a T>::prefix_at(p0, p1, p2);
-----------------
src/input.rs <&'a T as input::Input>::len
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::len":{"T":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::len":{"T":["input::CharInput","<&'a T as input::Input>","input::ByteInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
+p0.len();
+<&'a T as input::Input>::len(p0);
+crate::<&'a T as input::Input>::len(p0);
+<&'a T>::len(p0);
-----------------
src/input.rs <&'a T as input::Input>::as_bytes
'a
deps:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::as_bytes":{"T":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"<&'a T as input::Input>::as_bytes":{"T":["<&'a T as input::Input>","input::ByteInput","input::CharInput"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
+p0.as_bytes();
+<&'a T as input::Input>::as_bytes(p0);
+crate::<&'a T as input::Input>::as_bytes(p0);
+<&'a T>::as_bytes(p0);
-----------------
src/input.rs <input::CharInput<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
+p0.clone();
+<input::CharInput<'t> as std::clone::Clone>::clone(p0);
+crate::<input::CharInput<'t> as std::clone::Clone>::clone(p0);
+<input::CharInput<'t>>::clone(p0);
-----------------
src/input.rs <input::CharInput<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<input::CharInput<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<input::CharInput<'t> as std::fmt::Debug>::fmt(p0, p1);
+<input::CharInput<'t>>::fmt(p0, p1);
-----------------
src/input.rs input::CharInput::<'t>::new
't
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+input::CharInput::<'t>::new(p0);
+crate::input::CharInput::<'t>::new(p0);
+<input::CharInput<'t>>::new(p0);
-----------------
src/input.rs <input::CharInput<'t> as std::ops::Deref>::deref
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
+p0.deref();
+<input::CharInput<'t> as std::ops::Deref>::deref(p0);
+crate::<input::CharInput<'t> as std::ops::Deref>::deref(p0);
+<input::CharInput<'t>>::deref(p0);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::at
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = 0usize; // None+usize
+p0.at(p1);
+<input::CharInput<'t> as input::Input>::at(p0, p1);
+crate::<input::CharInput<'t> as input::Input>::at(p0, p1);
+<input::CharInput<'t>>::at(p0, p1);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::next_char
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_char(p1);
+<input::CharInput<'t> as input::Input>::next_char(p0, p1);
+crate::<input::CharInput<'t> as input::Input>::next_char(p0, p1);
+<input::CharInput<'t>>::next_char(p0, p1);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::previous_char
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.previous_char(p1);
+<input::CharInput<'t> as input::Input>::previous_char(p0, p1);
+crate::<input::CharInput<'t> as input::Input>::previous_char(p0, p1);
+<input::CharInput<'t>>::previous_char(p0, p1);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::is_empty_match
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.is_empty_match(p1, p2);
+<input::CharInput<'t> as input::Input>::is_empty_match(p0, p1, p2);
+crate::<input::CharInput<'t> as input::Input>::is_empty_match(p0, p1, p2);
+<input::CharInput<'t>>::is_empty_match(p0, p1, p2);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::prefix_at
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.prefix_at(p1, p2);
+<input::CharInput<'t> as input::Input>::prefix_at(p0, p1, p2);
+crate::<input::CharInput<'t> as input::Input>::prefix_at(p0, p1, p2);
+<input::CharInput<'t>>::prefix_at(p0, p1, p2);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
+p0.len();
+<input::CharInput<'t> as input::Input>::len(p0);
+crate::<input::CharInput<'t> as input::Input>::len(p0);
+<input::CharInput<'t>>::len(p0);
-----------------
src/input.rs <input::CharInput<'t> as input::Input>::as_bytes
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::CharInput<'t>
+p0.as_bytes();
+<input::CharInput<'t> as input::Input>::as_bytes(p0);
+crate::<input::CharInput<'t> as input::Input>::as_bytes(p0);
+<input::CharInput<'t>>::as_bytes(p0);
-----------------
src/input.rs <input::ByteInput<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
+p0.clone();
+<input::ByteInput<'t> as std::clone::Clone>::clone(p0);
+crate::<input::ByteInput<'t> as std::clone::Clone>::clone(p0);
+<input::ByteInput<'t>>::clone(p0);
-----------------
src/input.rs <input::ByteInput<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<input::ByteInput<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<input::ByteInput<'t> as std::fmt::Debug>::fmt(p0, p1);
+<input::ByteInput<'t>>::fmt(p0, p1);
-----------------
src/input.rs input::ByteInput::<'t>::new
't
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = true; // None+bool
+input::ByteInput::<'t>::new(p0, p1);
+crate::input::ByteInput::<'t>::new(p0, p1);
+<input::ByteInput<'t>>::new(p0, p1);
-----------------
src/input.rs <input::ByteInput<'t> as std::ops::Deref>::deref
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
+p0.deref();
+<input::ByteInput<'t> as std::ops::Deref>::deref(p0);
+crate::<input::ByteInput<'t> as std::ops::Deref>::deref(p0);
+<input::ByteInput<'t>>::deref(p0);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::at
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = 0usize; // None+usize
+p0.at(p1);
+<input::ByteInput<'t> as input::Input>::at(p0, p1);
+crate::<input::ByteInput<'t> as input::Input>::at(p0, p1);
+<input::ByteInput<'t>>::at(p0, p1);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::next_char
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.next_char(p1);
+<input::ByteInput<'t> as input::Input>::next_char(p0, p1);
+crate::<input::ByteInput<'t> as input::Input>::next_char(p0, p1);
+<input::ByteInput<'t>>::next_char(p0, p1);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::previous_char
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.previous_char(p1);
+<input::ByteInput<'t> as input::Input>::previous_char(p0, p1);
+crate::<input::ByteInput<'t> as input::Input>::previous_char(p0, p1);
+<input::ByteInput<'t>>::previous_char(p0, p1);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::is_empty_match
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p2 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.is_empty_match(p1, p2);
+<input::ByteInput<'t> as input::Input>::is_empty_match(p0, p1, p2);
+crate::<input::ByteInput<'t> as input::Input>::is_empty_match(p0, p1, p2);
+<input::ByteInput<'t>>::is_empty_match(p0, p1, p2);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::prefix_at
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p2 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.prefix_at(p1, p2);
+<input::ByteInput<'t> as input::Input>::prefix_at(p0, p1, p2);
+crate::<input::ByteInput<'t> as input::Input>::prefix_at(p0, p1, p2);
+<input::ByteInput<'t>>::prefix_at(p0, p1, p2);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
+p0.len();
+<input::ByteInput<'t> as input::Input>::len(p0);
+crate::<input::ByteInput<'t> as input::Input>::len(p0);
+<input::ByteInput<'t>>::len(p0);
-----------------
src/input.rs <input::ByteInput<'t> as input::Input>::as_bytes
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::ByteInput<'t>
+p0.as_bytes();
+<input::ByteInput<'t> as input::Input>::as_bytes(p0);
+crate::<input::ByteInput<'t> as input::Input>::as_bytes(p0);
+<input::ByteInput<'t>>::as_bytes(p0);
-----------------
src/input.rs <input::Char as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.clone();
+<input::Char as std::clone::Clone>::clone(p0);
+crate::<input::Char as std::clone::Clone>::clone(p0);
+<input::Char>::clone(p0);
-----------------
src/input.rs <input::Char as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<input::Char as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<input::Char as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::hash::SipHasher","std::collections::hash_map::DefaultHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<input::Char as std::hash::Hash>::hash(p0, p1);
+crate::<input::Char as std::hash::Hash>::hash(p0, p1);
+<input::Char>::hash(p0, p1);
-----------------
src/input.rs <input::Char as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.eq(p1);
+<input::Char as std::cmp::PartialEq>::eq(p0, p1);
+crate::<input::Char as std::cmp::PartialEq>::eq(p0, p1);
+<input::Char>::eq(p0, p1);
-----------------
src/input.rs <input::Char as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.assert_receiver_is_total_eq();
+<input::Char as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<input::Char as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<input::Char>::assert_receiver_is_total_eq(p0);
-----------------
src/input.rs <input::Char as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.partial_cmp(p1);
+<input::Char as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<input::Char as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<input::Char>::partial_cmp(p0, p1);
-----------------
src/input.rs <input::Char as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.cmp(p1);
+<input::Char as std::cmp::Ord>::cmp(p0, p1);
+crate::<input::Char as std::cmp::Ord>::cmp(p0, p1);
+<input::Char>::cmp(p0, p1);
-----------------
src/input.rs <input::Char as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<input::Char as std::fmt::Debug>::fmt(p0, p1);
+crate::<input::Char as std::fmt::Debug>::fmt(p0, p1);
+<input::Char>::fmt(p0, p1);
-----------------
src/input.rs input::Char::is_none
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.is_none();
+input::Char::is_none(p0);
+crate::input::Char::is_none(p0);
+<input::Char>::is_none(p0);
-----------------
src/input.rs input::Char::len_utf8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.len_utf8();
+input::Char::len_utf8(p0);
+crate::input::Char::len_utf8(p0);
+<input::Char>::len_utf8(p0);
-----------------
src/input.rs input::Char::is_word_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.is_word_char();
+input::Char::is_word_char(p0);
+crate::input::Char::is_word_char(p0);
+<input::Char>::is_word_char(p0);
-----------------
src/input.rs input::Char::is_word_byte
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.is_word_byte();
+input::Char::is_word_byte(p0);
+crate::input::Char::is_word_byte(p0);
+<input::Char>::is_word_byte(p0);
-----------------
src/input.rs <input::Char as std::convert::From<char>>::from
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+<input::Char as std::convert::From<char>>::from(p0);
+crate::<input::Char as std::convert::From<char>>::from(p0);
+<input::Char>::from(p0);
-----------------
src/input.rs <input::Char as std::convert::From<std::option::Option<char>>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<char>
+<input::Char as std::convert::From<std::option::Option<char>>>::from(p0);
+crate::<input::Char as std::convert::From<std::option::Option<char>>>::from(p0);
+<input::Char>::from(p0);
-----------------
src/input.rs <input::Char as std::cmp::PartialEq<char>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & 'a'; // None+char
+p0.eq(p1);
+<input::Char as std::cmp::PartialEq<char>>::eq(p0, p1);
+crate::<input::Char as std::cmp::PartialEq<char>>::eq(p0, p1);
+<input::Char>::eq(p0, p1);
-----------------
src/input.rs input::<impl std::cmp::PartialEq<input::Char> for char>::eq
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.eq(p1);
+input::<impl std::cmp::PartialEq<input::Char> for char>::eq(p0, p1);
+crate::input::<impl std::cmp::PartialEq<input::Char> for char>::eq(p0, p1);
+<char>::eq(p0, p1);
-----------------
src/input.rs <input::Char as std::cmp::PartialOrd<char>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // input::Char
let mut p1 = & 'a'; // None+char
+p0.partial_cmp(p1);
+<input::Char as std::cmp::PartialOrd<char>>::partial_cmp(p0, p1);
+crate::<input::Char as std::cmp::PartialOrd<char>>::partial_cmp(p0, p1);
+<input::Char>::partial_cmp(p0, p1);
-----------------
src/input.rs input::<impl std::cmp::PartialOrd<input::Char> for char>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
let mut p1 = & MaybeUninit::uninit().assume_init(); // input::Char
+p0.partial_cmp(p1);
+input::<impl std::cmp::PartialOrd<input::Char> for char>::partial_cmp(p0, p1);
+crate::input::<impl std::cmp::PartialOrd<input::Char> for char>::partial_cmp(p0, p1);
+<char>::partial_cmp(p0, p1);
-----------------
src/literal/imp.rs <literal::imp::LiteralSearcher as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.clone();
+<literal::imp::LiteralSearcher as std::clone::Clone>::clone(p0);
+crate::<literal::imp::LiteralSearcher as std::clone::Clone>::clone(p0);
+<literal::imp::LiteralSearcher>::clone(p0);
-----------------
src/literal/imp.rs <literal::imp::LiteralSearcher as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::LiteralSearcher as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::LiteralSearcher as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::LiteralSearcher>::fmt(p0, p1);
-----------------
src/literal/imp.rs <literal::imp::Matcher as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Matcher
+p0.clone();
+<literal::imp::Matcher as std::clone::Clone>::clone(p0);
+crate::<literal::imp::Matcher as std::clone::Clone>::clone(p0);
+<literal::imp::Matcher>::clone(p0);
-----------------
src/literal/imp.rs <literal::imp::Matcher as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::Matcher
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::Matcher as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::Matcher as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::Matcher>::fmt(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::empty
deps:{}
candidates:{}
+literal::imp::LiteralSearcher::empty();
+crate::literal::imp::LiteralSearcher::empty();
+<literal::imp::LiteralSearcher>::empty();
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::prefixes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // syntax::hir::literal::Literals
+literal::imp::LiteralSearcher::prefixes(p0);
+crate::literal::imp::LiteralSearcher::prefixes(p0);
+<literal::imp::LiteralSearcher>::prefixes(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::suffixes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // syntax::hir::literal::Literals
+literal::imp::LiteralSearcher::suffixes(p0);
+crate::literal::imp::LiteralSearcher::suffixes(p0);
+<literal::imp::LiteralSearcher>::suffixes(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // syntax::hir::literal::Literals
let mut p1 = MaybeUninit::uninit().assume_init(); // literal::imp::Matcher
+literal::imp::LiteralSearcher::new(p0, p1);
+crate::literal::imp::LiteralSearcher::new(p0, p1);
+<literal::imp::LiteralSearcher>::new(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::complete
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.complete();
+literal::imp::LiteralSearcher::complete(p0);
+crate::literal::imp::LiteralSearcher::complete(p0);
+<literal::imp::LiteralSearcher>::complete(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find(p1);
+literal::imp::LiteralSearcher::find(p0, p1);
+crate::literal::imp::LiteralSearcher::find(p0, p1);
+<literal::imp::LiteralSearcher>::find(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::find_start
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find_start(p1);
+literal::imp::LiteralSearcher::find_start(p0, p1);
+crate::literal::imp::LiteralSearcher::find_start(p0, p1);
+<literal::imp::LiteralSearcher>::find_start(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::find_end
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find_end(p1);
+literal::imp::LiteralSearcher::find_end(p0, p1);
+crate::literal::imp::LiteralSearcher::find_end(p0, p1);
+<literal::imp::LiteralSearcher>::find_end(p0, p1);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.iter();
+literal::imp::LiteralSearcher::iter(p0);
+crate::literal::imp::LiteralSearcher::iter(p0);
+<literal::imp::LiteralSearcher>::iter(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::lcp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.lcp();
+literal::imp::LiteralSearcher::lcp(p0);
+crate::literal::imp::LiteralSearcher::lcp(p0);
+<literal::imp::LiteralSearcher>::lcp(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::lcs
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.lcs();
+literal::imp::LiteralSearcher::lcs(p0);
+crate::literal::imp::LiteralSearcher::lcs(p0);
+<literal::imp::LiteralSearcher>::lcs(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.is_empty();
+literal::imp::LiteralSearcher::is_empty(p0);
+crate::literal::imp::LiteralSearcher::is_empty(p0);
+<literal::imp::LiteralSearcher>::is_empty(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.len();
+literal::imp::LiteralSearcher::len(p0);
+crate::literal::imp::LiteralSearcher::len(p0);
+<literal::imp::LiteralSearcher>::len(p0);
-----------------
src/literal/imp.rs literal::imp::LiteralSearcher::approximate_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralSearcher
+p0.approximate_size();
+literal::imp::LiteralSearcher::approximate_size(p0);
+crate::literal::imp::LiteralSearcher::approximate_size(p0);
+<literal::imp::LiteralSearcher>::approximate_size(p0);
-----------------
src/literal/imp.rs literal::imp::Matcher::prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // syntax::hir::literal::Literals
+literal::imp::Matcher::prefixes(p0);
+crate::literal::imp::Matcher::prefixes(p0);
+<literal::imp::Matcher>::prefixes(p0);
-----------------
src/literal/imp.rs literal::imp::Matcher::suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // syntax::hir::literal::Literals
+literal::imp::Matcher::suffixes(p0);
+crate::literal::imp::Matcher::suffixes(p0);
+<literal::imp::Matcher>::suffixes(p0);
-----------------
src/literal/imp.rs literal::imp::Matcher::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // syntax::hir::literal::Literals
let mut p1 = MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
+literal::imp::Matcher::new(p0, p1);
+crate::literal::imp::Matcher::new(p0, p1);
+<literal::imp::Matcher>::new(p0, p1);
-----------------
src/literal/imp.rs <literal::imp::LiteralIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::LiteralIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::LiteralIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::LiteralIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::LiteralIter<'a>>::fmt(p0, p1);
-----------------
src/literal/imp.rs <literal::imp::LiteralIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // literal::imp::LiteralIter<'a>
+p0.next();
+<literal::imp::LiteralIter<'a> as std::iter::Iterator>::next(p0);
+crate::<literal::imp::LiteralIter<'a> as std::iter::Iterator>::next(p0);
+<literal::imp::LiteralIter<'a>>::next(p0);
-----------------
src/literal/imp.rs <literal::imp::SingleByteSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
+p0.clone();
+<literal::imp::SingleByteSet as std::clone::Clone>::clone(p0);
+crate::<literal::imp::SingleByteSet as std::clone::Clone>::clone(p0);
+<literal::imp::SingleByteSet>::clone(p0);
-----------------
src/literal/imp.rs <literal::imp::SingleByteSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::SingleByteSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::SingleByteSet as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::SingleByteSet>::fmt(p0, p1);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::new
deps:{}
candidates:{}
+literal::imp::SingleByteSet::new();
+crate::literal::imp::SingleByteSet::new();
+<literal::imp::SingleByteSet>::new();
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::prefixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // syntax::hir::literal::Literals
+literal::imp::SingleByteSet::prefixes(p0);
+crate::literal::imp::SingleByteSet::prefixes(p0);
+<literal::imp::SingleByteSet>::prefixes(p0);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::suffixes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // syntax::hir::literal::Literals
+literal::imp::SingleByteSet::suffixes(p0);
+crate::literal::imp::SingleByteSet::suffixes(p0);
+<literal::imp::SingleByteSet>::suffixes(p0);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find(p1);
+literal::imp::SingleByteSet::find(p0, p1);
+crate::literal::imp::SingleByteSet::find(p0, p1);
+<literal::imp::SingleByteSet>::find(p0, p1);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::_find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0._find(p1);
+literal::imp::SingleByteSet::_find(p0, p1);
+crate::literal::imp::SingleByteSet::_find(p0, p1);
+<literal::imp::SingleByteSet>::_find(p0, p1);
-----------------
src/literal/imp.rs literal::imp::SingleByteSet::approximate_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::SingleByteSet
+p0.approximate_size();
+literal::imp::SingleByteSet::approximate_size(p0);
+crate::literal::imp::SingleByteSet::approximate_size(p0);
+<literal::imp::SingleByteSet>::approximate_size(p0);
-----------------
src/literal/imp.rs <literal::imp::FreqyPacked as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::FreqyPacked
+p0.clone();
+<literal::imp::FreqyPacked as std::clone::Clone>::clone(p0);
+crate::<literal::imp::FreqyPacked as std::clone::Clone>::clone(p0);
+<literal::imp::FreqyPacked>::clone(p0);
-----------------
src/literal/imp.rs <literal::imp::FreqyPacked as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::FreqyPacked
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::FreqyPacked as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::FreqyPacked as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::FreqyPacked>::fmt(p0, p1);
-----------------
src/literal/imp.rs literal::imp::FreqyPacked::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+literal::imp::FreqyPacked::new(p0);
+crate::literal::imp::FreqyPacked::new(p0);
+<literal::imp::FreqyPacked>::new(p0);
-----------------
src/literal/imp.rs literal::imp::FreqyPacked::empty
deps:{}
candidates:{}
+literal::imp::FreqyPacked::empty();
+crate::literal::imp::FreqyPacked::empty();
+<literal::imp::FreqyPacked>::empty();
-----------------
src/literal/imp.rs literal::imp::FreqyPacked::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::FreqyPacked
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find(p1);
+literal::imp::FreqyPacked::find(p0, p1);
+crate::literal::imp::FreqyPacked::find(p0, p1);
+<literal::imp::FreqyPacked>::find(p0, p1);
-----------------
src/literal/imp.rs literal::imp::FreqyPacked::is_suffix
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::FreqyPacked
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.is_suffix(p1);
+literal::imp::FreqyPacked::is_suffix(p0, p1);
+crate::literal::imp::FreqyPacked::is_suffix(p0, p1);
+<literal::imp::FreqyPacked>::is_suffix(p0, p1);
-----------------
src/literal/imp.rs literal::imp::FreqyPacked::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::FreqyPacked
+p0.len();
+literal::imp::FreqyPacked::len(p0);
+crate::literal::imp::FreqyPacked::len(p0);
+<literal::imp::FreqyPacked>::len(p0);
-----------------
src/literal/imp.rs literal::imp::FreqyPacked::char_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::FreqyPacked
+p0.char_len();
+literal::imp::FreqyPacked::char_len(p0);
+crate::literal::imp::FreqyPacked::char_len(p0);
+<literal::imp::FreqyPacked>::char_len(p0);
-----------------
src/literal/imp.rs literal::imp::FreqyPacked::approximate_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::FreqyPacked
+p0.approximate_size();
+literal::imp::FreqyPacked::approximate_size(p0);
+crate::literal::imp::FreqyPacked::approximate_size(p0);
+<literal::imp::FreqyPacked>::approximate_size(p0);
-----------------
src/literal/imp.rs <literal::imp::BoyerMooreSearch as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::BoyerMooreSearch
+p0.clone();
+<literal::imp::BoyerMooreSearch as std::clone::Clone>::clone(p0);
+crate::<literal::imp::BoyerMooreSearch as std::clone::Clone>::clone(p0);
+<literal::imp::BoyerMooreSearch>::clone(p0);
-----------------
src/literal/imp.rs <literal::imp::BoyerMooreSearch as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::BoyerMooreSearch
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<literal::imp::BoyerMooreSearch as std::fmt::Debug>::fmt(p0, p1);
+crate::<literal::imp::BoyerMooreSearch as std::fmt::Debug>::fmt(p0, p1);
+<literal::imp::BoyerMooreSearch>::fmt(p0, p1);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+literal::imp::BoyerMooreSearch::new(p0);
+crate::literal::imp::BoyerMooreSearch::new(p0);
+<literal::imp::BoyerMooreSearch>::new(p0);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::BoyerMooreSearch
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find(p1);
+literal::imp::BoyerMooreSearch::find(p0, p1);
+crate::literal::imp::BoyerMooreSearch::find(p0, p1);
+<literal::imp::BoyerMooreSearch>::find(p0, p1);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::BoyerMooreSearch
+p0.len();
+literal::imp::BoyerMooreSearch::len(p0);
+crate::literal::imp::BoyerMooreSearch::len(p0);
+<literal::imp::BoyerMooreSearch>::len(p0);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::should_use
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+literal::imp::BoyerMooreSearch::should_use(p0);
+crate::literal::imp::BoyerMooreSearch::should_use(p0);
+<literal::imp::BoyerMooreSearch>::should_use(p0);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::check_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::BoyerMooreSearch
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.check_match(p1, p2);
+literal::imp::BoyerMooreSearch::check_match(p0, p1, p2);
+crate::literal::imp::BoyerMooreSearch::check_match(p0, p1, p2);
+<literal::imp::BoyerMooreSearch>::check_match(p0, p1, p2);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::skip_loop
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::BoyerMooreSearch
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
let mut p3 = 0usize; // None+usize
+p0.skip_loop(p1, p2, p3);
+literal::imp::BoyerMooreSearch::skip_loop(p0, p1, p2, p3);
+crate::literal::imp::BoyerMooreSearch::skip_loop(p0, p1, p2, p3);
+<literal::imp::BoyerMooreSearch>::skip_loop(p0, p1, p2, p3);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::compile_skip_table
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+literal::imp::BoyerMooreSearch::compile_skip_table(p0);
+crate::literal::imp::BoyerMooreSearch::compile_skip_table(p0);
+<literal::imp::BoyerMooreSearch>::compile_skip_table(p0);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::select_guard
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+literal::imp::BoyerMooreSearch::select_guard(p0);
+crate::literal::imp::BoyerMooreSearch::select_guard(p0);
+<literal::imp::BoyerMooreSearch>::select_guard(p0);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::compile_md2_shift
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+literal::imp::BoyerMooreSearch::compile_md2_shift(p0);
+crate::literal::imp::BoyerMooreSearch::compile_md2_shift(p0);
+<literal::imp::BoyerMooreSearch>::compile_md2_shift(p0);
-----------------
src/literal/imp.rs literal::imp::BoyerMooreSearch::approximate_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // literal::imp::BoyerMooreSearch
+p0.approximate_size();
+literal::imp::BoyerMooreSearch::approximate_size(p0);
+crate::literal::imp::BoyerMooreSearch::approximate_size(p0);
+<literal::imp::BoyerMooreSearch>::approximate_size(p0);
-----------------
src/pikevm.rs <pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt
'r
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"backtrack::Bounded":{"I":["std::marker::Sized","input::Input","std::fmt::Debug"]},"cache::imp::Cached":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"cache::imp::CachedGuard":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"dfa::Result":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"pikevm::Fsm":{"I":["std::marker::Sized","std::fmt::Debug","input::Input"]},"re_trait::CaptureMatches":{"R":["std::fmt::Debug","re_trait::RegularExpression","std::marker::Sized"]},"re_trait::Matches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt":{"I":["pikevm::Cache","dfa::StateFlags","re_trait::SubCapturesPosIter","re_unicode::CapturesDebug","re_set::bytes::SetMatchesIter","sparse::SparseSet","literal::imp::LiteralSearcher","re_bytes::CaptureLocations","re_bytes::Regex","re_unicode::Captures","pikevm::FollowEpsilon","re_set::bytes::RegexSet","re_set::unicode::SetMatchesIter","dfa::Fsm","compile::Hole","cache::imp::Cached","exec::ExecReadOnly","literal::imp::BoyerMooreSearch","dfa::Result","dfa::StateMap","dfa::TransitionsRow","input::InputAt","pikevm::Fsm","re_bytes::CapturesDebug","re_builder::bytes::RegexBuilder","backtrack::Cache","re_set::unicode::SetMatches","input::Char","re_unicode::Matches","re_set::unicode::RegexSet","re_builder::unicode::RegexBuilder","compile::ByteClassSet","exec::MatchLiteralType","prog::InstRanges","<&mut T as std::fmt::Debug>","prog::InstChar","re_bytes::SplitN","expand::CaptureRef","re_unicode::SubCaptureMatches","literal::imp::Matcher","re_builder::RegexOptions","dfa::EmptyFlags","backtrack::Job","re_bytes::CaptureMatches","exec::Exec","compile::SuffixCacheEntry","re_bytes::SubCaptureMatches","compile::SuffixCache","prog::Inst","prog::InstSplit","re_bytes::Matches","re_unicode::CaptureLocations","re_set::unicode::SetMatchesIntoIter","backtrack::Bounded","re_bytes::Match","re_unicode::CaptureNames","literal::imp::SingleByteSet","prog::InstBytes","re_trait::Locations","re_unicode::Split","re_trait::Matches","re_unicode::CaptureMatches","dfa::Transitions","exec::ExecNoSyncStr","dfa::CacheInner","error::Error","dfa::Cache","input::CharInput","dfa::State","compile::Patch","exec::ProgramCacheInner","literal::imp::LiteralIter","re_unicode::NoExpand","dfa::Byte","prog::EmptyLook","re_builder::set_unicode::RegexSetBuilder","expand::Ref","re_bytes::Captures","re_unicode::ReplacerRef","<*const T as std::fmt::Debug>","re_set::bytes::SetMatchesIntoIter","compile::InstHole","prog::Program","re_builder::set_bytes::RegexSetBuilder","re_unicode::Regex","re_bytes::ReplacerRef","re_set::bytes::SetMatches","compile::MaybeInst","literal::imp::FreqyPacked","exec::MatchNfaType","re_unicode::SplitN","re_bytes::CaptureNames","re_trait::CaptureMatches","exec::ExecNoSync","cache::imp::CachedGuard","pikevm::Threads","re_bytes::Split","re_unicode::Match","prog::InstEmptyLook","exec::MatchType","re_bytes::NoExpand","compile::SuffixCacheKey","input::ByteInput","prog::InstSave"]},"backtrack::Bounded":{"I":["input::ByteInput","input::CharInput"]},"cache::imp::Cached":{"T":["std::cell::RefCell<T>","std::string::Drain<'_>","std::sync::MutexGuard<'_, T>","std::slice::IterMut<'_, T>","std::io::IoSliceMut<'a>","std::rc::Rc<T>","std::vec::IntoIter<T, A>","std::collections::LinkedList<T>","std::vec::Drain<'_, T, A>","std::collections::linked_list::Iter<'_, T>","std::sync::mpmc::Sender<T>","std::task::Waker","std::ptr::NonNull<T>","std::sync::atomic::AtomicPtr<T>","std::sync::mpsc::SyncSender<T>","std::env::Args","std::sync::RwLockReadGuard<'_, T>","std::sync::mpsc::Receiver<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::Arc<T>","std::thread::JoinHandle<T>","std::sys::unix::args::Args","std::rc::Weak<T>","std::boxed::ThinBox<T>","std::slice::Iter<'_, T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::RwLockWriteGuard<'_, T>","std::future::ResumeTy","std::cell::Cell<T>","std::ptr::Unique<T>","std::ptr::DynMetadata<Dyn>","std::collections::vec_deque::Drain<'_, T, A>","std::io::error::repr_bitpacked::Repr","std::io::IoSlice<'a>","std::env::ArgsOs","std::sync::RwLock<T>","<&T as std::marker::Send>","std::sync::Mutex<T>","std::collections::linked_list::IterMut<'_, T>","std::sync::mpsc::Sender<T>","std::sync::Weak<T>","std::sync::mpmc::Receiver<T>","std::sync::OnceLock<T>"]},"cache::imp::CachedGuard":{"T":["std::sync::atomic::AtomicPtr<T>","<*const T as std::fmt::Debug>","std::sync::Mutex<T>","std::thread::JoinHandle<T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::mpsc::Receiver<T>","std::rc::Weak<T>","std::env::ArgsOs","std::vec::Drain<'_, T, A>","std::ptr::NonNull<T>","std::sync::mpmc::Receiver<T>","std::ptr::DynMetadata<Dyn>","std::cell::RefCell<T>","std::sync::mpsc::SyncSender<T>","std::sync::OnceLock<T>","std::io::IoSlice<'a>","std::io::error::repr_bitpacked::Repr","std::vec::IntoIter<T, A>","std::ptr::Unique<T>","std::string::Drain<'_>","std::sync::mpmc::Sender<T>","std::sync::mpsc::Sender<T>","std::sys::unix::args::Args","std::sync::Weak<T>","std::env::Args","std::collections::linked_list::IterMut<'_, T>","std::slice::IterMut<'_, T>","std::future::ResumeTy","std::sync::RwLockReadGuard<'_, T>","std::collections::linked_list::Iter<'_, T>","std::slice::Iter<'_, T>","std::collections::linked_list::Cursor<'_, T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::MutexGuard<'_, T>","std::boxed::ThinBox<T>","std::io::IoSliceMut<'a>","std::task::Waker","std::collections::LinkedList<T>","std::cell::Cell<T>","std::sync::RwLockWriteGuard<'_, T>","std::sync::RwLock<T>","std::rc::Rc<T>","std::sync::Arc<T>"]},"dfa::Result":{"T":["backtrack::Cache","re_trait::Locations","compile::InstHole","pikevm::FollowEpsilon","re_bytes::Regex","compile::SuffixCacheKey","dfa::StateFlags","re_bytes::CaptureLocations","prog::InstSave","re_set::unicode::SetMatchesIter","prog::InstSplit","expand::Ref","exec::MatchNfaType","re_bytes::SubCaptureMatches","re_set::unicode::RegexSet","dfa::State","re_set::bytes::RegexSet","re_unicode::NoExpand","re_bytes::CaptureNames","sparse::SparseSet","prog::InstChar","prog::InstRanges","re_trait::SubCapturesPosIter","dfa::Result","re_set::bytes::SetMatches","literal::imp::FreqyPacked","re_unicode::CaptureLocations","literal::imp::LiteralSearcher","compile::MaybeInst","compile::SuffixCacheEntry","pikevm::Threads","prog::EmptyLook","exec::MatchType","error::Error","re_unicode::SubCaptureMatches","re_unicode::Regex","input::Char","literal::imp::SingleByteSet","dfa::EmptyFlags","exec::Exec","prog::InstBytes","re_set::unicode::SetMatches","backtrack::Job","literal::imp::BoyerMooreSearch","prog::Inst","input::CharInput","re_bytes::Match","re_unicode::CaptureNames","exec::MatchLiteralType","input::InputAt","re_bytes::NoExpand","input::ByteInput","dfa::Transitions","re_unicode::Match","prog::InstEmptyLook","literal::imp::Matcher","re_set::bytes::SetMatchesIter","std::clone::impls::<impl std::clone::Clone for &T>","dfa::Byte","prog::Program","expand::CaptureRef","re_builder::RegexOptions","pikevm::Cache"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt(p0, p1);
+<pikevm::Fsm<'r, I>>::fmt(p0, p1);
-----------------
src/pikevm.rs <pikevm::Cache as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Cache
+p0.clone();
+<pikevm::Cache as std::clone::Clone>::clone(p0);
+crate::<pikevm::Cache as std::clone::Clone>::clone(p0);
+<pikevm::Cache>::clone(p0);
-----------------
src/pikevm.rs <pikevm::Cache as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Cache
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pikevm::Cache as std::fmt::Debug>::fmt(p0, p1);
+crate::<pikevm::Cache as std::fmt::Debug>::fmt(p0, p1);
+<pikevm::Cache>::fmt(p0, p1);
-----------------
src/pikevm.rs <pikevm::Threads as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Threads
+p0.clone();
+<pikevm::Threads as std::clone::Clone>::clone(p0);
+crate::<pikevm::Threads as std::clone::Clone>::clone(p0);
+<pikevm::Threads>::clone(p0);
-----------------
src/pikevm.rs <pikevm::Threads as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pikevm::Threads as std::fmt::Debug>::fmt(p0, p1);
+crate::<pikevm::Threads as std::fmt::Debug>::fmt(p0, p1);
+<pikevm::Threads>::fmt(p0, p1);
-----------------
src/pikevm.rs <pikevm::FollowEpsilon as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::FollowEpsilon
+p0.clone();
+<pikevm::FollowEpsilon as std::clone::Clone>::clone(p0);
+crate::<pikevm::FollowEpsilon as std::clone::Clone>::clone(p0);
+<pikevm::FollowEpsilon>::clone(p0);
-----------------
src/pikevm.rs <pikevm::FollowEpsilon as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // pikevm::FollowEpsilon
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<pikevm::FollowEpsilon as std::fmt::Debug>::fmt(p0, p1);
+crate::<pikevm::FollowEpsilon as std::fmt::Debug>::fmt(p0, p1);
+<pikevm::FollowEpsilon>::fmt(p0, p1);
-----------------
src/pikevm.rs pikevm::Cache::new
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+pikevm::Cache::new(p0);
+crate::pikevm::Cache::new(p0);
+<pikevm::Cache>::new(p0);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::exec
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::exec":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::exec":{"I":["input::CharInput","<&'a T as input::Input>","input::ByteInput"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::cell::RefCell<exec::ProgramCacheInner>
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p4 = true; // None+bool
let mut p5 = MaybeUninit::uninit().assume_init(); // I
let mut p6 = 0usize; // None+usize
let mut p7 = 0usize; // None+usize
+pikevm::Fsm::<'r, I>::exec(p0, p1, p2, p3, p4, p5, p6, p7);
+crate::pikevm::Fsm::<'r, I>::exec(p0, p1, p2, p3, p4, p5, p6, p7);
+<pikevm::Fsm<'r, I>>::exec(p0, p1, p2, p3, p4, p5, p6, p7);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::exec_
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::exec_":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::exec_":{"I":["input::CharInput","input::ByteInput","<&'a T as input::Input>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p3 = &mut [true].as_mut_slice(); // None+[bool]
let mut p4 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p5 = true; // None+bool
let mut p6 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p7 = 0usize; // None+usize
+p0.exec_(p1, p2, p3, p4, p5, p6, p7);
+pikevm::Fsm::<'r, I>::exec_(p0, p1, p2, p3, p4, p5, p6, p7);
+crate::pikevm::Fsm::<'r, I>::exec_(p0, p1, p2, p3, p4, p5, p6, p7);
+<pikevm::Fsm<'r, I>>::exec_(p0, p1, p2, p3, p4, p5, p6, p7);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::step
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::step":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::step":{"I":["input::CharInput","<&'a T as input::Input>","input::ByteInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p2 = &mut [true].as_mut_slice(); // None+[bool]
let mut p3 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p4 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p5 = 0usize; // None+usize
let mut p6 = MaybeUninit::uninit().assume_init(); // input::InputAt
let mut p7 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.step(p1, p2, p3, p4, p5, p6, p7);
+pikevm::Fsm::<'r, I>::step(p0, p1, p2, p3, p4, p5, p6, p7);
+crate::pikevm::Fsm::<'r, I>::step(p0, p1, p2, p3, p4, p5, p6, p7);
+<pikevm::Fsm<'r, I>>::step(p0, p1, p2, p3, p4, p5, p6, p7);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::add
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::add":{"I":["std::marker::Sized","input::Input"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::add":{"I":["input::CharInput","input::ByteInput","<&'a T as input::Input>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = 0usize; // None+usize
let mut p4 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.add(p1, p2, p3, p4);
+pikevm::Fsm::<'r, I>::add(p0, p1, p2, p3, p4);
+crate::pikevm::Fsm::<'r, I>::add(p0, p1, p2, p3, p4);
+<pikevm::Fsm<'r, I>>::add(p0, p1, p2, p3, p4);
-----------------
src/pikevm.rs pikevm::Fsm::<'r, I>::add_step
'r
deps:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::add_step":{"I":["input::Input","std::marker::Sized"]}}
candidates:{"<&'a T as input::Input>":{},"pikevm::Fsm::<'r, I>::add_step":{"I":["<&'a T as input::Input>","input::ByteInput","input::CharInput"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Fsm<'r, I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // [std::option::Option<usize>]
let mut p3 = 0usize; // None+usize
let mut p4 = MaybeUninit::uninit().assume_init(); // input::InputAt
+p0.add_step(p1, p2, p3, p4);
+pikevm::Fsm::<'r, I>::add_step(p0, p1, p2, p3, p4);
+crate::pikevm::Fsm::<'r, I>::add_step(p0, p1, p2, p3, p4);
+<pikevm::Fsm<'r, I>>::add_step(p0, p1, p2, p3, p4);
-----------------
src/pikevm.rs pikevm::Threads::new
deps:{}
candidates:{}
+pikevm::Threads::new();
+crate::pikevm::Threads::new();
+<pikevm::Threads>::new();
-----------------
src/pikevm.rs pikevm::Threads::resize
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.resize(p1, p2);
+pikevm::Threads::resize(p0, p1, p2);
+crate::pikevm::Threads::resize(p0, p1, p2);
+<pikevm::Threads>::resize(p0, p1, p2);
-----------------
src/pikevm.rs pikevm::Threads::caps
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // pikevm::Threads
let mut p1 = 0usize; // None+usize
+p0.caps(p1);
+pikevm::Threads::caps(p0, p1);
+crate::pikevm::Threads::caps(p0, p1);
+<pikevm::Threads>::caps(p0, p1);
-----------------
src/prog.rs <prog::Program as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.clone();
+<prog::Program as std::clone::Clone>::clone(p0);
+crate::<prog::Program as std::clone::Clone>::clone(p0);
+<prog::Program>::clone(p0);
-----------------
src/prog.rs prog::Program::new
deps:{}
candidates:{}
+prog::Program::new();
+crate::prog::Program::new();
+<prog::Program>::new();
-----------------
src/prog.rs prog::Program::skip
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = 0usize; // None+usize
+p0.skip(p1);
+prog::Program::skip(p0, p1);
+crate::prog::Program::skip(p0, p1);
+<prog::Program>::skip(p0, p1);
-----------------
src/prog.rs prog::Program::leads_to_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = 0usize; // None+usize
+p0.leads_to_match(p1);
+prog::Program::leads_to_match(p0, p1);
+crate::prog::Program::leads_to_match(p0, p1);
+<prog::Program>::leads_to_match(p0, p1);
-----------------
src/prog.rs prog::Program::needs_dotstar
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.needs_dotstar();
+prog::Program::needs_dotstar(p0);
+crate::prog::Program::needs_dotstar(p0);
+<prog::Program>::needs_dotstar(p0);
-----------------
src/prog.rs prog::Program::uses_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.uses_bytes();
+prog::Program::uses_bytes(p0);
+crate::prog::Program::uses_bytes(p0);
+<prog::Program>::uses_bytes(p0);
-----------------
src/prog.rs prog::Program::only_utf8
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.only_utf8();
+prog::Program::only_utf8(p0);
+crate::prog::Program::only_utf8(p0);
+<prog::Program>::only_utf8(p0);
-----------------
src/prog.rs prog::Program::approximate_size
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.approximate_size();
+prog::Program::approximate_size(p0);
+crate::prog::Program::approximate_size(p0);
+<prog::Program>::approximate_size(p0);
-----------------
src/prog.rs <prog::Program as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.deref();
+<prog::Program as std::ops::Deref>::deref(p0);
+crate::<prog::Program as std::ops::Deref>::deref(p0);
+<prog::Program>::deref(p0);
-----------------
src/prog.rs <prog::Program as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::Program as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::Program as std::fmt::Debug>::fmt(p0, p1);
+<prog::Program>::fmt(p0, p1);
-----------------
src/prog.rs <&'a prog::Program as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Program
+p0.into_iter();
+<&'a prog::Program as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a prog::Program as std::iter::IntoIterator>::into_iter(p0);
+<&'a prog::Program>::into_iter(p0);
-----------------
src/prog.rs <prog::Inst as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Inst
+p0.clone();
+<prog::Inst as std::clone::Clone>::clone(p0);
+crate::<prog::Inst as std::clone::Clone>::clone(p0);
+<prog::Inst>::clone(p0);
-----------------
src/prog.rs <prog::Inst as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Inst
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::Inst as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::Inst as std::fmt::Debug>::fmt(p0, p1);
+<prog::Inst>::fmt(p0, p1);
-----------------
src/prog.rs prog::Inst::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::Inst
+p0.is_match();
+prog::Inst::is_match(p0);
+crate::prog::Inst::is_match(p0);
+<prog::Inst>::is_match(p0);
-----------------
src/prog.rs <prog::InstSave as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstSave
+p0.clone();
+<prog::InstSave as std::clone::Clone>::clone(p0);
+crate::<prog::InstSave as std::clone::Clone>::clone(p0);
+<prog::InstSave>::clone(p0);
-----------------
src/prog.rs <prog::InstSave as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstSave
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstSave as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstSave as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstSave>::fmt(p0, p1);
-----------------
src/prog.rs <prog::InstSplit as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstSplit
+p0.clone();
+<prog::InstSplit as std::clone::Clone>::clone(p0);
+crate::<prog::InstSplit as std::clone::Clone>::clone(p0);
+<prog::InstSplit>::clone(p0);
-----------------
src/prog.rs <prog::InstSplit as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstSplit
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstSplit as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstSplit as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstSplit>::fmt(p0, p1);
-----------------
src/prog.rs <prog::InstEmptyLook as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
+p0.clone();
+<prog::InstEmptyLook as std::clone::Clone>::clone(p0);
+crate::<prog::InstEmptyLook as std::clone::Clone>::clone(p0);
+<prog::InstEmptyLook>::clone(p0);
-----------------
src/prog.rs <prog::InstEmptyLook as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstEmptyLook
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstEmptyLook as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstEmptyLook as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstEmptyLook>::fmt(p0, p1);
-----------------
src/prog.rs <prog::EmptyLook as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
+p0.clone();
+<prog::EmptyLook as std::clone::Clone>::clone(p0);
+crate::<prog::EmptyLook as std::clone::Clone>::clone(p0);
+<prog::EmptyLook>::clone(p0);
-----------------
src/prog.rs <prog::EmptyLook as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::EmptyLook as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::EmptyLook as std::fmt::Debug>::fmt(p0, p1);
+<prog::EmptyLook>::fmt(p0, p1);
-----------------
src/prog.rs <prog::EmptyLook as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
let mut p1 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
+p0.eq(p1);
+<prog::EmptyLook as std::cmp::PartialEq>::eq(p0, p1);
+crate::<prog::EmptyLook as std::cmp::PartialEq>::eq(p0, p1);
+<prog::EmptyLook>::eq(p0, p1);
-----------------
src/prog.rs <prog::EmptyLook as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::EmptyLook
+p0.assert_receiver_is_total_eq();
+<prog::EmptyLook as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<prog::EmptyLook as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<prog::EmptyLook>::assert_receiver_is_total_eq(p0);
-----------------
src/prog.rs <prog::InstChar as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstChar
+p0.clone();
+<prog::InstChar as std::clone::Clone>::clone(p0);
+crate::<prog::InstChar as std::clone::Clone>::clone(p0);
+<prog::InstChar>::clone(p0);
-----------------
src/prog.rs <prog::InstChar as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstChar
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstChar as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstChar as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstChar>::fmt(p0, p1);
-----------------
src/prog.rs <prog::InstRanges as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstRanges
+p0.clone();
+<prog::InstRanges as std::clone::Clone>::clone(p0);
+crate::<prog::InstRanges as std::clone::Clone>::clone(p0);
+<prog::InstRanges>::clone(p0);
-----------------
src/prog.rs <prog::InstRanges as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstRanges
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstRanges as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstRanges as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstRanges>::fmt(p0, p1);
-----------------
src/prog.rs prog::InstRanges::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstRanges
let mut p1 = MaybeUninit::uninit().assume_init(); // input::Char
+p0.matches(p1);
+prog::InstRanges::matches(p0, p1);
+crate::prog::InstRanges::matches(p0, p1);
+<prog::InstRanges>::matches(p0, p1);
-----------------
src/prog.rs prog::InstRanges::num_chars
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstRanges
+p0.num_chars();
+prog::InstRanges::num_chars(p0);
+crate::prog::InstRanges::num_chars(p0);
+<prog::InstRanges>::num_chars(p0);
-----------------
src/prog.rs <prog::InstBytes as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstBytes
+p0.clone();
+<prog::InstBytes as std::clone::Clone>::clone(p0);
+crate::<prog::InstBytes as std::clone::Clone>::clone(p0);
+<prog::InstBytes>::clone(p0);
-----------------
src/prog.rs <prog::InstBytes as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstBytes
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<prog::InstBytes as std::fmt::Debug>::fmt(p0, p1);
+crate::<prog::InstBytes as std::fmt::Debug>::fmt(p0, p1);
+<prog::InstBytes>::fmt(p0, p1);
-----------------
src/prog.rs prog::InstBytes::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // prog::InstBytes
let mut p1 = 0u8; // None+u8
+p0.matches(p1);
+prog::InstBytes::matches(p0, p1);
+crate::prog::InstBytes::matches(p0, p1);
+<prog::InstBytes>::matches(p0, p1);
-----------------
src/re_builder.rs <re_builder::RegexOptions as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::RegexOptions
+p0.clone();
+<re_builder::RegexOptions as std::clone::Clone>::clone(p0);
+crate::<re_builder::RegexOptions as std::clone::Clone>::clone(p0);
+<re_builder::RegexOptions>::clone(p0);
-----------------
src/re_builder.rs <re_builder::RegexOptions as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::RegexOptions
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::RegexOptions as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::RegexOptions as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::RegexOptions>::fmt(p0, p1);
-----------------
src/re_builder.rs <re_builder::RegexOptions as std::default::Default>::default
deps:{}
candidates:{}
+<re_builder::RegexOptions as std::default::Default>::default();
+crate::<re_builder::RegexOptions as std::default::Default>::default();
+<re_builder::RegexOptions>::default();
-----------------
src/re_builder.rs <re_builder::bytes::RegexBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::bytes::RegexBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::bytes::RegexBuilder as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::bytes::RegexBuilder>::fmt(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_builder::bytes::RegexBuilder::new(&p0);
+crate::re_builder::bytes::RegexBuilder::new(&p0);
+<re_builder::bytes::RegexBuilder>::new(&p0);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
+p0.build();
+re_builder::bytes::RegexBuilder::build(p0);
+crate::re_builder::bytes::RegexBuilder::build(p0);
+<re_builder::bytes::RegexBuilder>::build(p0);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+re_builder::bytes::RegexBuilder::case_insensitive(p0, p1);
+crate::re_builder::bytes::RegexBuilder::case_insensitive(p0, p1);
+<re_builder::bytes::RegexBuilder>::case_insensitive(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+re_builder::bytes::RegexBuilder::multi_line(p0, p1);
+crate::re_builder::bytes::RegexBuilder::multi_line(p0, p1);
+<re_builder::bytes::RegexBuilder>::multi_line(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+re_builder::bytes::RegexBuilder::dot_matches_new_line(p0, p1);
+crate::re_builder::bytes::RegexBuilder::dot_matches_new_line(p0, p1);
+<re_builder::bytes::RegexBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+re_builder::bytes::RegexBuilder::swap_greed(p0, p1);
+crate::re_builder::bytes::RegexBuilder::swap_greed(p0, p1);
+<re_builder::bytes::RegexBuilder>::swap_greed(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+re_builder::bytes::RegexBuilder::ignore_whitespace(p0, p1);
+crate::re_builder::bytes::RegexBuilder::ignore_whitespace(p0, p1);
+<re_builder::bytes::RegexBuilder>::ignore_whitespace(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+re_builder::bytes::RegexBuilder::unicode(p0, p1);
+crate::re_builder::bytes::RegexBuilder::unicode(p0, p1);
+<re_builder::bytes::RegexBuilder>::unicode(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+re_builder::bytes::RegexBuilder::octal(p0, p1);
+crate::re_builder::bytes::RegexBuilder::octal(p0, p1);
+<re_builder::bytes::RegexBuilder>::octal(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+re_builder::bytes::RegexBuilder::size_limit(p0, p1);
+crate::re_builder::bytes::RegexBuilder::size_limit(p0, p1);
+<re_builder::bytes::RegexBuilder>::size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::dfa_size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = 0usize; // None+usize
+p0.dfa_size_limit(p1);
+re_builder::bytes::RegexBuilder::dfa_size_limit(p0, p1);
+crate::re_builder::bytes::RegexBuilder::dfa_size_limit(p0, p1);
+<re_builder::bytes::RegexBuilder>::dfa_size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::bytes::RegexBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::bytes::RegexBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+re_builder::bytes::RegexBuilder::nest_limit(p0, p1);
+crate::re_builder::bytes::RegexBuilder::nest_limit(p0, p1);
+<re_builder::bytes::RegexBuilder>::nest_limit(p0, p1);
-----------------
src/re_builder.rs <re_builder::unicode::RegexBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::unicode::RegexBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::unicode::RegexBuilder as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::unicode::RegexBuilder>::fmt(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_builder::unicode::RegexBuilder::new(&p0);
+crate::re_builder::unicode::RegexBuilder::new(&p0);
+<re_builder::unicode::RegexBuilder>::new(&p0);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
+p0.build();
+re_builder::unicode::RegexBuilder::build(p0);
+crate::re_builder::unicode::RegexBuilder::build(p0);
+<re_builder::unicode::RegexBuilder>::build(p0);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+re_builder::unicode::RegexBuilder::case_insensitive(p0, p1);
+crate::re_builder::unicode::RegexBuilder::case_insensitive(p0, p1);
+<re_builder::unicode::RegexBuilder>::case_insensitive(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+re_builder::unicode::RegexBuilder::multi_line(p0, p1);
+crate::re_builder::unicode::RegexBuilder::multi_line(p0, p1);
+<re_builder::unicode::RegexBuilder>::multi_line(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+re_builder::unicode::RegexBuilder::dot_matches_new_line(p0, p1);
+crate::re_builder::unicode::RegexBuilder::dot_matches_new_line(p0, p1);
+<re_builder::unicode::RegexBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+re_builder::unicode::RegexBuilder::swap_greed(p0, p1);
+crate::re_builder::unicode::RegexBuilder::swap_greed(p0, p1);
+<re_builder::unicode::RegexBuilder>::swap_greed(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+re_builder::unicode::RegexBuilder::ignore_whitespace(p0, p1);
+crate::re_builder::unicode::RegexBuilder::ignore_whitespace(p0, p1);
+<re_builder::unicode::RegexBuilder>::ignore_whitespace(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+re_builder::unicode::RegexBuilder::unicode(p0, p1);
+crate::re_builder::unicode::RegexBuilder::unicode(p0, p1);
+<re_builder::unicode::RegexBuilder>::unicode(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+re_builder::unicode::RegexBuilder::octal(p0, p1);
+crate::re_builder::unicode::RegexBuilder::octal(p0, p1);
+<re_builder::unicode::RegexBuilder>::octal(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+re_builder::unicode::RegexBuilder::size_limit(p0, p1);
+crate::re_builder::unicode::RegexBuilder::size_limit(p0, p1);
+<re_builder::unicode::RegexBuilder>::size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::dfa_size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = 0usize; // None+usize
+p0.dfa_size_limit(p1);
+re_builder::unicode::RegexBuilder::dfa_size_limit(p0, p1);
+crate::re_builder::unicode::RegexBuilder::dfa_size_limit(p0, p1);
+<re_builder::unicode::RegexBuilder>::dfa_size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::unicode::RegexBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::unicode::RegexBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+re_builder::unicode::RegexBuilder::nest_limit(p0, p1);
+crate::re_builder::unicode::RegexBuilder::nest_limit(p0, p1);
+<re_builder::unicode::RegexBuilder>::nest_limit(p0, p1);
-----------------
src/re_builder.rs <re_builder::set_bytes::RegexSetBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::set_bytes::RegexSetBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::set_bytes::RegexSetBuilder as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::fmt(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"re_builder::set_bytes::RegexSetBuilder::new":{"I":["std::iter::IntoIterator","std::marker::Sized"],"S":["std::convert::AsRef","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["re_trait::CaptureMatches","re_bytes::Matches","re_bytes::SubCaptureMatches","re_set::bytes::SetMatchesIntoIter","re_unicode::SubCaptureMatches","re_bytes::CaptureMatches","re_trait::SubCapturesPosIter","re_bytes::CaptureNames","dfa::InstPtrs","re_set::unicode::SetMatchesIntoIter","re_unicode::Matches","literal::imp::LiteralIter","re_bytes::SplitN","re_set::unicode::SetMatchesIter","re_set::bytes::SetMatchesIter","re_bytes::Split","<&mut I as std::iter::Iterator>","re_trait::Matches","re_unicode::SplitN","re_unicode::Split","re_unicode::CaptureMatches","re_unicode::CaptureNames"]},"re_builder::set_bytes::RegexSetBuilder::new":{"I":["<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>","re_set::bytes::SetMatches","<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","re_set::unicode::SetMatches"],"S":["std::ffi::CStr","std::ffi::CString","std::boxed::Box<T, A>","std::rc::Rc<T>","std::vec::IntoIter<T, A>","<&mut T as std::convert::AsRef<U>>","core::num::dec2flt::common::AsciiStr<'a>","std::sync::Arc<T>","std::borrow::Cow<'_, std::ffi::OsStr>","std::slice::Iter<'_, T>","std::slice::IterMut<'_, T>","std::borrow::Cow<'_, T>","std::vec::Drain<'a, T, A>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+re_builder::set_bytes::RegexSetBuilder::new(p0);
+crate::re_builder::set_bytes::RegexSetBuilder::new(p0);
+<re_builder::set_bytes::RegexSetBuilder>::new(p0);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
+p0.build();
+re_builder::set_bytes::RegexSetBuilder::build(p0);
+crate::re_builder::set_bytes::RegexSetBuilder::build(p0);
+<re_builder::set_bytes::RegexSetBuilder>::build(p0);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+re_builder::set_bytes::RegexSetBuilder::case_insensitive(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::case_insensitive(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::case_insensitive(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+re_builder::set_bytes::RegexSetBuilder::multi_line(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::multi_line(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::multi_line(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+re_builder::set_bytes::RegexSetBuilder::dot_matches_new_line(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::dot_matches_new_line(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+re_builder::set_bytes::RegexSetBuilder::swap_greed(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::swap_greed(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::swap_greed(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+re_builder::set_bytes::RegexSetBuilder::ignore_whitespace(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::ignore_whitespace(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::ignore_whitespace(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+re_builder::set_bytes::RegexSetBuilder::unicode(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::unicode(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::unicode(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+re_builder::set_bytes::RegexSetBuilder::octal(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::octal(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::octal(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+re_builder::set_bytes::RegexSetBuilder::size_limit(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::size_limit(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::dfa_size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = 0usize; // None+usize
+p0.dfa_size_limit(p1);
+re_builder::set_bytes::RegexSetBuilder::dfa_size_limit(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::dfa_size_limit(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::dfa_size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::set_bytes::RegexSetBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_bytes::RegexSetBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+re_builder::set_bytes::RegexSetBuilder::nest_limit(p0, p1);
+crate::re_builder::set_bytes::RegexSetBuilder::nest_limit(p0, p1);
+<re_builder::set_bytes::RegexSetBuilder>::nest_limit(p0, p1);
-----------------
src/re_builder.rs <re_builder::set_unicode::RegexSetBuilder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_builder::set_unicode::RegexSetBuilder as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_builder::set_unicode::RegexSetBuilder as std::fmt::Debug>::fmt(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::fmt(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"re_builder::set_unicode::RegexSetBuilder::new":{"I":["std::marker::Sized","std::iter::IntoIterator"],"S":["std::marker::Sized","std::convert::AsRef"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["re_unicode::SplitN","re_bytes::SubCaptureMatches","re_trait::SubCapturesPosIter","re_set::unicode::SetMatchesIter","re_set::bytes::SetMatchesIter","re_unicode::CaptureMatches","re_bytes::Matches","dfa::InstPtrs","<&mut I as std::iter::Iterator>","re_set::bytes::SetMatchesIntoIter","re_unicode::Split","re_unicode::SubCaptureMatches","re_bytes::CaptureNames","re_unicode::CaptureNames","re_trait::CaptureMatches","re_bytes::Split","literal::imp::LiteralIter","re_bytes::CaptureMatches","re_trait::Matches","re_unicode::Matches","re_bytes::SplitN","re_set::unicode::SetMatchesIntoIter"]},"re_builder::set_unicode::RegexSetBuilder::new":{"I":["<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>","re_set::bytes::SetMatches","<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>","re_set::unicode::SetMatches"],"S":["std::ffi::CStr","std::vec::Drain<'a, T, A>","std::boxed::Box<T, A>","std::slice::Iter<'_, T>","std::rc::Rc<T>","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, T>","std::borrow::Cow<'_, std::ffi::OsStr>","std::vec::IntoIter<T, A>","std::slice::IterMut<'_, T>","<&T as std::convert::AsRef<U>>","std::sync::Arc<T>","std::ffi::CString"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+re_builder::set_unicode::RegexSetBuilder::new(p0);
+crate::re_builder::set_unicode::RegexSetBuilder::new(p0);
+<re_builder::set_unicode::RegexSetBuilder>::new(p0);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::build
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
+p0.build();
+re_builder::set_unicode::RegexSetBuilder::build(p0);
+crate::re_builder::set_unicode::RegexSetBuilder::build(p0);
+<re_builder::set_unicode::RegexSetBuilder>::build(p0);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::case_insensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.case_insensitive(p1);
+re_builder::set_unicode::RegexSetBuilder::case_insensitive(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::case_insensitive(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::case_insensitive(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::multi_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.multi_line(p1);
+re_builder::set_unicode::RegexSetBuilder::multi_line(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::multi_line(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::multi_line(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::dot_matches_new_line
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.dot_matches_new_line(p1);
+re_builder::set_unicode::RegexSetBuilder::dot_matches_new_line(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::dot_matches_new_line(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::dot_matches_new_line(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::swap_greed
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.swap_greed(p1);
+re_builder::set_unicode::RegexSetBuilder::swap_greed(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::swap_greed(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::swap_greed(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::ignore_whitespace
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.ignore_whitespace(p1);
+re_builder::set_unicode::RegexSetBuilder::ignore_whitespace(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::ignore_whitespace(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::ignore_whitespace(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::unicode
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.unicode(p1);
+re_builder::set_unicode::RegexSetBuilder::unicode(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::unicode(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::unicode(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::octal
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = true; // None+bool
+p0.octal(p1);
+re_builder::set_unicode::RegexSetBuilder::octal(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::octal(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::octal(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = 0usize; // None+usize
+p0.size_limit(p1);
+re_builder::set_unicode::RegexSetBuilder::size_limit(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::size_limit(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::dfa_size_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = 0usize; // None+usize
+p0.dfa_size_limit(p1);
+re_builder::set_unicode::RegexSetBuilder::dfa_size_limit(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::dfa_size_limit(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::dfa_size_limit(p0, p1);
-----------------
src/re_builder.rs re_builder::set_unicode::RegexSetBuilder::nest_limit
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_builder::set_unicode::RegexSetBuilder
let mut p1 = 0u32; // None+u32
+p0.nest_limit(p1);
+re_builder::set_unicode::RegexSetBuilder::nest_limit(p0, p1);
+crate::re_builder::set_unicode::RegexSetBuilder::nest_limit(p0, p1);
+<re_builder::set_unicode::RegexSetBuilder>::nest_limit(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Match<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.clone();
+<re_bytes::Match<'t> as std::clone::Clone>::clone(p0);
+crate::<re_bytes::Match<'t> as std::clone::Clone>::clone(p0);
+<re_bytes::Match<'t>>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::Match<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Match<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Match<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Match<'t>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.assert_receiver_is_total_eq();
+<re_bytes::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<re_bytes::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<re_bytes::Match<'t>>::assert_receiver_is_total_eq(p0);
-----------------
src/re_bytes.rs <re_bytes::Match<'t> as std::cmp::PartialEq>::eq
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.eq(p1);
+<re_bytes::Match<'t> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<re_bytes::Match<'t> as std::cmp::PartialEq>::eq(p0, p1);
+<re_bytes::Match<'t>>::eq(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::start
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.start();
+re_bytes::Match::<'t>::start(p0);
+crate::re_bytes::Match::<'t>::start(p0);
+<re_bytes::Match<'t>>::start(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::end
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.end();
+re_bytes::Match::<'t>::end(p0);
+crate::re_bytes::Match::<'t>::end(p0);
+<re_bytes::Match<'t>>::end(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::range
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.range();
+re_bytes::Match::<'t>::range(p0);
+crate::re_bytes::Match::<'t>::range(p0);
+<re_bytes::Match<'t>>::range(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::as_bytes
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+p0.as_bytes();
+re_bytes::Match::<'t>::as_bytes(p0);
+crate::re_bytes::Match::<'t>::as_bytes(p0);
+<re_bytes::Match<'t>>::as_bytes(p0);
-----------------
src/re_bytes.rs re_bytes::Match::<'t>::new
't
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+re_bytes::Match::<'t>::new(p0, p1, p2);
+crate::re_bytes::Match::<'t>::new(p0, p1, p2);
+<re_bytes::Match<'t>>::new(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::<impl std::convert::From<re_bytes::Match<'t>> for std::ops::Range<usize>>::from
't
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_bytes::Match<'t>
+re_bytes::<impl std::convert::From<re_bytes::Match<'t>> for std::ops::Range<usize>>::from(p0);
+crate::re_bytes::<impl std::convert::From<re_bytes::Match<'t>> for std::ops::Range<usize>>::from(p0);
+<std::ops::Range<usize>>::from(p0);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.clone();
+<re_bytes::Regex as std::clone::Clone>::clone(p0);
+crate::<re_bytes::Regex as std::clone::Clone>::clone(p0);
+<re_bytes::Regex>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<re_bytes::Regex as std::fmt::Display>::fmt(p0, p1);
+crate::<re_bytes::Regex as std::fmt::Display>::fmt(p0, p1);
+<re_bytes::Regex>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Regex as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Regex as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Regex>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::convert::From<exec::Exec>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+<re_bytes::Regex as std::convert::From<exec::Exec>>::from(p0);
+crate::<re_bytes::Regex as std::convert::From<exec::Exec>>::from(p0);
+<re_bytes::Regex>::from(p0);
-----------------
src/re_bytes.rs <re_bytes::Regex as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<re_bytes::Regex as std::str::FromStr>::from_str(&p0);
+crate::<re_bytes::Regex as std::str::FromStr>::from_str(&p0);
+<re_bytes::Regex>::from_str(&p0);
-----------------
src/re_bytes.rs re_bytes::Regex::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_bytes::Regex::new(&p0);
+crate::re_bytes::Regex::new(&p0);
+<re_bytes::Regex>::new(&p0);
-----------------
src/re_bytes.rs re_bytes::Regex::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.is_match(p1);
+re_bytes::Regex::is_match(p0, p1);
+crate::re_bytes::Regex::is_match(p0, p1);
+<re_bytes::Regex>::is_match(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find(p1);
+re_bytes::Regex::find(p0, p1);
+crate::re_bytes::Regex::find(p0, p1);
+<re_bytes::Regex>::find(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::find_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find_iter(p1);
+re_bytes::Regex::find_iter(p0, p1);
+crate::re_bytes::Regex::find_iter(p0, p1);
+<re_bytes::Regex>::find_iter(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::captures
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.captures(p1);
+re_bytes::Regex::captures(p0, p1);
+crate::re_bytes::Regex::captures(p0, p1);
+<re_bytes::Regex>::captures(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::captures_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.captures_iter(p1);
+re_bytes::Regex::captures_iter(p0, p1);
+crate::re_bytes::Regex::captures_iter(p0, p1);
+<re_bytes::Regex>::captures_iter(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::split
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.split(p1);
+re_bytes::Regex::split(p0, p1);
+crate::re_bytes::Regex::split(p0, p1);
+<re_bytes::Regex>::split(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::splitn
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.splitn(p1, p2);
+re_bytes::Regex::splitn(p0, p1, p2);
+crate::re_bytes::Regex::splitn(p0, p1, p2);
+<re_bytes::Regex>::splitn(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::replace
deps:{"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"re_bytes::Regex::replace":{"R":["std::marker::Sized","re_bytes::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_bytes::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::IsWhitespace"]},"re_bytes::Regex::replace":{"R":["re_bytes::NoExpand","re_bytes::ReplacerRef","<F as re_bytes::Replacer>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = MaybeUninit::uninit().assume_init(); // R
+p0.replace(p1, p2);
+re_bytes::Regex::replace(p0, p1, p2);
+crate::re_bytes::Regex::replace(p0, p1, p2);
+<re_bytes::Regex>::replace(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::replace_all
deps:{"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"re_bytes::Regex::replace_all":{"R":["std::marker::Sized","re_bytes::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_bytes::Replacer>":{"F":["std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"]},"re_bytes::Regex::replace_all":{"R":["<F as re_bytes::Replacer>","re_bytes::ReplacerRef","re_bytes::NoExpand"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = MaybeUninit::uninit().assume_init(); // R
+p0.replace_all(p1, p2);
+re_bytes::Regex::replace_all(p0, p1, p2);
+crate::re_bytes::Regex::replace_all(p0, p1, p2);
+<re_bytes::Regex>::replace_all(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::replacen
deps:{"<F as re_bytes::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"re_bytes::Regex::replacen":{"R":["re_bytes::Replacer","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_bytes::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"re_bytes::Regex::replacen":{"R":["re_bytes::ReplacerRef","re_bytes::NoExpand","<F as re_bytes::Replacer>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // R
+p0.replacen(p1, p2, p3);
+re_bytes::Regex::replacen(p0, p1, p2, p3);
+crate::re_bytes::Regex::replacen(p0, p1, p2, p3);
+<re_bytes::Regex>::replacen(p0, p1, p2, p3);
-----------------
src/re_bytes.rs re_bytes::Regex::shortest_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.shortest_match(p1);
+re_bytes::Regex::shortest_match(p0, p1);
+crate::re_bytes::Regex::shortest_match(p0, p1);
+<re_bytes::Regex>::shortest_match(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Regex::shortest_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(p1, p2);
+re_bytes::Regex::shortest_match_at(p0, p1, p2);
+crate::re_bytes::Regex::shortest_match_at(p0, p1, p2);
+<re_bytes::Regex>::shortest_match_at(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::is_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.is_match_at(p1, p2);
+re_bytes::Regex::is_match_at(p0, p1, p2);
+crate::re_bytes::Regex::is_match_at(p0, p1, p2);
+<re_bytes::Regex>::is_match_at(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::find_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.find_at(p1, p2);
+re_bytes::Regex::find_at(p0, p1, p2);
+crate::re_bytes::Regex::find_at(p0, p1, p2);
+<re_bytes::Regex>::find_at(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::captures_read
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.captures_read(p1, p2);
+re_bytes::Regex::captures_read(p0, p1, p2);
+crate::re_bytes::Regex::captures_read(p0, p1, p2);
+<re_bytes::Regex>::captures_read(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Regex::captures_read_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, p2, p3);
+re_bytes::Regex::captures_read_at(p0, p1, p2, p3);
+crate::re_bytes::Regex::captures_read_at(p0, p1, p2, p3);
+<re_bytes::Regex>::captures_read_at(p0, p1, p2, p3);
-----------------
src/re_bytes.rs re_bytes::Regex::read_captures_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.read_captures_at(p1, p2, p3);
+re_bytes::Regex::read_captures_at(p0, p1, p2, p3);
+crate::re_bytes::Regex::read_captures_at(p0, p1, p2, p3);
+<re_bytes::Regex>::read_captures_at(p0, p1, p2, p3);
-----------------
src/re_bytes.rs re_bytes::Regex::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.as_str();
+re_bytes::Regex::as_str(p0);
+crate::re_bytes::Regex::as_str(p0);
+<re_bytes::Regex>::as_str(p0);
-----------------
src/re_bytes.rs re_bytes::Regex::capture_names
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.capture_names();
+re_bytes::Regex::capture_names(p0);
+crate::re_bytes::Regex::capture_names(p0);
+<re_bytes::Regex>::capture_names(p0);
-----------------
src/re_bytes.rs re_bytes::Regex::captures_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.captures_len();
+re_bytes::Regex::captures_len(p0);
+crate::re_bytes::Regex::captures_len(p0);
+<re_bytes::Regex>::captures_len(p0);
-----------------
src/re_bytes.rs re_bytes::Regex::capture_locations
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.capture_locations();
+re_bytes::Regex::capture_locations(p0);
+crate::re_bytes::Regex::capture_locations(p0);
+<re_bytes::Regex>::capture_locations(p0);
-----------------
src/re_bytes.rs re_bytes::Regex::locations
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Regex
+p0.locations();
+re_bytes::Regex::locations(p0);
+crate::re_bytes::Regex::locations(p0);
+<re_bytes::Regex>::locations(p0);
-----------------
src/re_bytes.rs <re_bytes::Matches<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Matches<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Matches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Matches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Matches<'r, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Matches<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::Matches<'r, 't>
+p0.next();
+<re_bytes::Matches<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::Matches<'r, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::Matches<'r, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureMatches<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::CaptureMatches<'r, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::CaptureMatches<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureMatches<'r, 't>
+p0.next();
+<re_bytes::CaptureMatches<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::CaptureMatches<'r, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::CaptureMatches<'r, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::Split<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Split<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Split<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Split<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Split<'r, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Split<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::Split<'r, 't>
+p0.next();
+<re_bytes::Split<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::Split<'r, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::Split<'r, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::SplitN<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::SplitN<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::SplitN<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::SplitN<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::SplitN<'r, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::SplitN<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::SplitN<'r, 't>
+p0.next();
+<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::SplitN<'r, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::SplitN<'r, 't> as std::iter::Iterator>::size_hint
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::SplitN<'r, 't>
+p0.size_hint();
+<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::size_hint(p0);
+crate::<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::size_hint(p0);
+<re_bytes::SplitN<'r, 't>>::size_hint(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::clone::Clone>::clone
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
+p0.clone();
+<re_bytes::CaptureNames<'r> as std::clone::Clone>::clone(p0);
+crate::<re_bytes::CaptureNames<'r> as std::clone::Clone>::clone(p0);
+<re_bytes::CaptureNames<'r>>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::fmt::Debug>::fmt
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::CaptureNames<'r> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::CaptureNames<'r> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::CaptureNames<'r>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::iter::Iterator>::next
'r
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
+p0.next();
+<re_bytes::CaptureNames<'r> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::CaptureNames<'r> as std::iter::Iterator>::next(p0);
+<re_bytes::CaptureNames<'r>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::iter::Iterator>::size_hint
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
+p0.size_hint();
+<re_bytes::CaptureNames<'r> as std::iter::Iterator>::size_hint(p0);
+crate::<re_bytes::CaptureNames<'r> as std::iter::Iterator>::size_hint(p0);
+<re_bytes::CaptureNames<'r>>::size_hint(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureNames<'r> as std::iter::Iterator>::count
'r
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_bytes::CaptureNames<'r>
+p0.count();
+<re_bytes::CaptureNames<'r> as std::iter::Iterator>::count(p0);
+crate::<re_bytes::CaptureNames<'r> as std::iter::Iterator>::count(p0);
+<re_bytes::CaptureNames<'r>>::count(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureLocations as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
+p0.clone();
+<re_bytes::CaptureLocations as std::clone::Clone>::clone(p0);
+crate::<re_bytes::CaptureLocations as std::clone::Clone>::clone(p0);
+<re_bytes::CaptureLocations>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::CaptureLocations as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::CaptureLocations as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::CaptureLocations as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::CaptureLocations>::fmt(p0, p1);
-----------------
src/re_bytes.rs re_bytes::CaptureLocations::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+re_bytes::CaptureLocations::get(p0, p1);
+crate::re_bytes::CaptureLocations::get(p0, p1);
+<re_bytes::CaptureLocations>::get(p0, p1);
-----------------
src/re_bytes.rs re_bytes::CaptureLocations::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
+p0.len();
+re_bytes::CaptureLocations::len(p0);
+crate::re_bytes::CaptureLocations::len(p0);
+<re_bytes::CaptureLocations>::len(p0);
-----------------
src/re_bytes.rs re_bytes::CaptureLocations::pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CaptureLocations
let mut p1 = 0usize; // None+usize
+p0.pos(p1);
+re_bytes::CaptureLocations::pos(p0, p1);
+crate::re_bytes::CaptureLocations::pos(p0, p1);
+<re_bytes::CaptureLocations>::pos(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::get
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+re_bytes::Captures::<'t>::get(p0, p1);
+crate::re_bytes::Captures::<'t>::get(p0, p1);
+<re_bytes::Captures<'t>>::get(p0, p1);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::name
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = "sample"; // None+&str
+p0.name(&p1);
+re_bytes::Captures::<'t>::name(p0, &p1);
+crate::re_bytes::Captures::<'t>::name(p0, &p1);
+<re_bytes::Captures<'t>>::name(p0, &p1);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::iter
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
+p0.iter();
+re_bytes::Captures::<'t>::iter(p0);
+crate::re_bytes::Captures::<'t>::iter(p0);
+<re_bytes::Captures<'t>>::iter(p0);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::expand
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.expand(p1, p2);
+re_bytes::Captures::<'t>::expand(p0, p1, p2);
+crate::re_bytes::Captures::<'t>::expand(p0, p1, p2);
+<re_bytes::Captures<'t>>::expand(p0, p1, p2);
-----------------
src/re_bytes.rs re_bytes::Captures::<'t>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
+p0.len();
+re_bytes::Captures::<'t>::len(p0);
+crate::re_bytes::Captures::<'t>::len(p0);
+<re_bytes::Captures<'t>>::len(p0);
-----------------
src/re_bytes.rs <re_bytes::Captures<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::Captures<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::Captures<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::Captures<'t>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::CapturesDebug<'c, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::CapturesDebug<'c, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Captures<'t> as std::ops::Index<usize>>::index
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = 0usize; // None+usize
+p0.index(p1);
+<re_bytes::Captures<'t> as std::ops::Index<usize>>::index(p0, p1);
+crate::<re_bytes::Captures<'t> as std::ops::Index<usize>>::index(p0, p1);
+<re_bytes::Captures<'t>>::index(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::Captures<'t> as std::ops::Index<&'i str>>::index
't,'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'t>
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+<re_bytes::Captures<'t> as std::ops::Index<&'i str>>::index(p0, &p1);
+crate::<re_bytes::Captures<'t> as std::ops::Index<&'i str>>::index(p0, &p1);
+<re_bytes::Captures<'t>>::index(p0, &p1);
-----------------
src/re_bytes.rs <re_bytes::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::SubCaptureMatches<'c, 't>
+p0.clone();
+<re_bytes::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone(p0);
+crate::<re_bytes::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone(p0);
+<re_bytes::SubCaptureMatches<'c, 't>>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::SubCaptureMatches<'c, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::SubCaptureMatches<'c, 't>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next
'c,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::SubCaptureMatches<'c, 't>
+p0.next();
+<re_bytes::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next(p0);
+crate::<re_bytes::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next(p0);
+<re_bytes::SubCaptureMatches<'c, 't>>::next(p0);
-----------------
src/re_bytes.rs <re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":{"R":["std::fmt::Debug"]},"backtrack::Bounded":{"I":["std::fmt::Debug","input::Input","std::marker::Sized"]},"cache::imp::Cached":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"cache::imp::CachedGuard":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"dfa::Result":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"pikevm::Fsm":{"I":["input::Input","std::marker::Sized","std::fmt::Debug"]},"re_trait::CaptureMatches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"std::clone::impls::<impl std::clone::Clone for &T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":{"R":["compile::MaybeInst","input::CharInput","literal::imp::SingleByteSet","dfa::Transitions","literal::imp::LiteralIter","re_bytes::Regex","dfa::Fsm","re_builder::bytes::RegexBuilder","dfa::TransitionsRow","exec::MatchType","re_builder::set_bytes::RegexSetBuilder","re_unicode::Regex","prog::InstBytes","backtrack::Bounded","cache::imp::CachedGuard","exec::ProgramCacheInner","dfa::Result","exec::ExecNoSyncStr","re_bytes::CaptureNames","re_set::unicode::SetMatches","re_set::bytes::SetMatches","re_unicode::CaptureNames","prog::InstSave","expand::CaptureRef","literal::imp::FreqyPacked","compile::Hole","re_bytes::Matches","literal::imp::Matcher","prog::InstSplit","re_set::unicode::SetMatchesIntoIter","re_bytes::CaptureMatches","re_bytes::Match","prog::EmptyLook","re_unicode::Match","prog::Program","re_bytes::NoExpand","re_unicode::SplitN","re_bytes::Captures","input::Char","compile::InstHole","dfa::StateFlags","re_bytes::CaptureLocations","<*mut T as std::fmt::Debug>","re_unicode::Captures","re_unicode::SubCaptureMatches","re_unicode::NoExpand","input::ByteInput","re_unicode::CapturesDebug","dfa::StateMap","compile::SuffixCacheKey","exec::MatchLiteralType","re_set::unicode::RegexSet","re_unicode::ReplacerRef","expand::Ref","exec::Exec","compile::SuffixCache","literal::imp::BoyerMooreSearch","error::Error","re_unicode::CaptureMatches","literal::imp::LiteralSearcher","compile::ByteClassSet","dfa::Cache","re_bytes::SplitN","re_trait::Matches","re_trait::Locations","re_bytes::SubCaptureMatches","compile::Patch","pikevm::Cache","input::InputAt","prog::InstChar","cache::imp::Cached","pikevm::FollowEpsilon","backtrack::Cache","re_bytes::Split","re_set::bytes::SetMatchesIter","re_builder::unicode::RegexBuilder","pikevm::Fsm","prog::Inst","compile::SuffixCacheEntry","re_set::bytes::SetMatchesIntoIter","re_bytes::CapturesDebug","re_set::bytes::RegexSet","dfa::Byte","dfa::EmptyFlags","prog::InstRanges","re_unicode::Split","pikevm::Threads","re_set::unicode::SetMatchesIter","re_builder::set_unicode::RegexSetBuilder","exec::MatchNfaType","exec::ExecNoSync","dfa::State","backtrack::Job","re_trait::CaptureMatches","dfa::CacheInner","exec::ExecReadOnly","prog::InstEmptyLook","sparse::SparseSet","re_bytes::ReplacerRef","re_unicode::Matches","re_unicode::CaptureLocations","re_builder::RegexOptions","re_trait::SubCapturesPosIter"]},"backtrack::Bounded":{"I":["input::CharInput","input::ByteInput"]},"cache::imp::Cached":{"T":["std::collections::linked_list::Iter<'_, T>","std::collections::linked_list::IterMut<'_, T>","std::sync::mpmc::Receiver<T>","std::cell::RefCell<T>","std::vec::Drain<'_, T, A>","std::sync::RwLockWriteGuard<'_, T>","std::sync::Arc<T>","std::sys::unix::args::Args","std::string::Drain<'_>","std::rc::Weak<T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::RwLock<T>","std::cell::Cell<T>","std::ptr::NonNull<T>","std::sync::MutexGuard<'_, T>","std::io::IoSlice<'a>","std::slice::IterMut<'_, T>","std::sync::Weak<T>","std::ptr::Unique<T>","std::boxed::ThinBox<T>","std::task::Waker","std::io::error::repr_bitpacked::Repr","std::thread::JoinHandle<T>","std::io::IoSliceMut<'a>","std::sync::atomic::AtomicPtr<T>","std::collections::linked_list::Cursor<'_, T>","std::collections::LinkedList<T>","std::ptr::DynMetadata<Dyn>","std::sync::OnceLock<T>","std::env::ArgsOs","std::slice::Iter<'_, T>","std::sync::RwLockReadGuard<'_, T>","std::collections::linked_list::CursorMut<'_, T>","<*const T as std::marker::Send>","std::future::ResumeTy","std::sync::Mutex<T>","std::env::Args","std::sync::mpsc::Receiver<T>","std::sync::mpsc::SyncSender<T>","std::vec::IntoIter<T, A>","std::rc::Rc<T>","std::sync::mpsc::Sender<T>","std::sync::mpmc::Sender<T>"]},"cache::imp::CachedGuard":{"T":["std::string::Drain<'_>","std::boxed::ThinBox<T>","std::vec::Drain<'_, T, A>","std::collections::linked_list::Iter<'_, T>","std::io::error::repr_bitpacked::Repr","std::ptr::Unique<T>","std::collections::linked_list::CursorMut<'_, T>","std::sync::mpmc::Sender<T>","std::vec::IntoIter<T, A>","std::sync::atomic::AtomicPtr<T>","std::sync::RwLock<T>","std::env::Args","std::thread::JoinHandle<T>","std::slice::Iter<'_, T>","std::sync::Weak<T>","std::sync::RwLockReadGuard<'_, T>","std::sync::Arc<T>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::OnceLock<T>","std::io::IoSliceMut<'a>","std::io::IoSlice<'a>","std::collections::LinkedList<T>","<*const T as std::fmt::Debug>","std::rc::Rc<T>","std::sys::unix::args::Args","std::slice::IterMut<'_, T>","std::sync::mpsc::SyncSender<T>","std::sync::MutexGuard<'_, T>","std::sync::Mutex<T>","std::sync::mpsc::Sender<T>","std::cell::RefCell<T>","std::sync::mpmc::Receiver<T>","std::collections::linked_list::IterMut<'_, T>","std::rc::Weak<T>","std::cell::Cell<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::mpsc::Receiver<T>","std::future::ResumeTy","std::env::ArgsOs","std::task::Waker","std::sync::RwLockWriteGuard<'_, T>","std::ptr::DynMetadata<Dyn>","std::ptr::NonNull<T>"]},"dfa::Result":{"T":["backtrack::Job","re_unicode::CaptureLocations","re_bytes::Regex","input::ByteInput","prog::InstBytes","compile::InstHole","prog::EmptyLook","input::CharInput","dfa::Transitions","pikevm::FollowEpsilon","re_set::bytes::RegexSet","literal::imp::SingleByteSet","dfa::StateFlags","pikevm::Threads","re_unicode::Match","re_bytes::CaptureNames","re_trait::SubCapturesPosIter","re_unicode::SubCaptureMatches","re_unicode::Regex","literal::imp::BoyerMooreSearch","<*mut T as std::fmt::Debug>","re_bytes::CaptureLocations","prog::InstRanges","backtrack::Cache","prog::InstChar","expand::Ref","dfa::EmptyFlags","literal::imp::LiteralSearcher","exec::MatchLiteralType","prog::Program","re_builder::RegexOptions","input::Char","re_bytes::SubCaptureMatches","compile::SuffixCacheEntry","error::Error","pikevm::Cache","re_set::unicode::RegexSet","re_unicode::CaptureNames","re_set::unicode::SetMatchesIter","re_trait::Locations","dfa::Result","dfa::State","compile::SuffixCacheKey","exec::MatchNfaType","re_set::unicode::SetMatches","input::InputAt","re_unicode::NoExpand","exec::Exec","expand::CaptureRef","re_set::bytes::SetMatchesIter","literal::imp::FreqyPacked","exec::MatchType","prog::Inst","re_bytes::Match","re_bytes::NoExpand","prog::InstSave","prog::InstEmptyLook","literal::imp::Matcher","re_set::bytes::SetMatches","prog::InstSplit","dfa::Byte","sparse::SparseSet","compile::MaybeInst"]},"pikevm::Fsm":{"I":["input::ByteInput","input::CharInput"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"std::clone::impls::<impl std::clone::Clone for &T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::ReplacerRef<'a, R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::ReplacerRef<'a, R>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append
'a
deps:{"<F as re_bytes::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append":{"R":["re_bytes::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_bytes::Replacer>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append":{"R":["<F as re_bytes::Replacer>","re_bytes::ReplacerRef","re_bytes::NoExpand"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::ReplacerRef<'a, R>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<re_bytes::ReplacerRef<'a, R>>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion
'a
deps:{"<F as re_bytes::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion":{"R":["re_bytes::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_bytes::Replacer>":{"F":["core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue"]},"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion":{"R":["<F as re_bytes::Replacer>","re_bytes::ReplacerRef","re_bytes::NoExpand"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::ReplacerRef<'a, R>
+p0.no_expansion();
+<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion(p0);
+crate::<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion(p0);
+<re_bytes::ReplacerRef<'a, R>>::no_expansion(p0);
-----------------
src/re_bytes.rs <&'a [u8] as re_bytes::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<&'a [u8] as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<&'a [u8] as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<&'a [u8]>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <&'a [u8] as re_bytes::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut [0u8].as_mut_slice(); // None+&'a [u8]
+p0.no_expansion();
+<&'a [u8] as re_bytes::Replacer>::no_expansion(p0);
+crate::<&'a [u8] as re_bytes::Replacer>::no_expansion(p0);
+<&'a [u8]>::no_expansion(p0);
-----------------
src/re_bytes.rs <F as re_bytes::Replacer>::replace_append
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<F as re_bytes::Replacer>::replace_append":{"F":["std::ops::FnMut","std::marker::Sized"],"T":["std::marker::Sized","std::convert::AsRef"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<F as re_bytes::Replacer>::replace_append":{"F":["core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"],"T":["<&mut T as std::convert::AsRef<U>>","std::vec::IntoIter<T, A>","std::slice::IterMut<'_, T>","std::slice::Iter<'_, T>","core::num::dec2flt::common::AsciiStr<'a>","std::vec::Drain<'a, T, A>","std::ffi::CString","std::ffi::CStr","std::boxed::Box<T, A>","std::borrow::Cow<'_, std::ffi::OsStr>","std::borrow::Cow<'_, T>","std::sync::Arc<T>","std::rc::Rc<T>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // F
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<F as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<F as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<F>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <re_bytes::NoExpand<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::NoExpand<'t>
+p0.clone();
+<re_bytes::NoExpand<'t> as std::clone::Clone>::clone(p0);
+crate::<re_bytes::NoExpand<'t> as std::clone::Clone>::clone(p0);
+<re_bytes::NoExpand<'t>>::clone(p0);
-----------------
src/re_bytes.rs <re_bytes::NoExpand<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_bytes::NoExpand<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_bytes::NoExpand<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_bytes::NoExpand<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_bytes::NoExpand<'t>>::fmt(p0, p1);
-----------------
src/re_bytes.rs <re_bytes::NoExpand<'t> as re_bytes::Replacer>::replace_append
't
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::NoExpand<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_bytes::Captures<'_>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.replace_append(p1, p2);
+<re_bytes::NoExpand<'t> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+crate::<re_bytes::NoExpand<'t> as re_bytes::Replacer>::replace_append(p0, p1, p2);
+<re_bytes::NoExpand<'t>>::replace_append(p0, p1, p2);
-----------------
src/re_bytes.rs <re_bytes::NoExpand<'t> as re_bytes::Replacer>::no_expansion
't
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_bytes::NoExpand<'t>
+p0.no_expansion();
+<re_bytes::NoExpand<'t> as re_bytes::Replacer>::no_expansion(p0);
+crate::<re_bytes::NoExpand<'t> as re_bytes::Replacer>::no_expansion(p0);
+<re_bytes::NoExpand<'t>>::no_expansion(p0);
-----------------
src/re_set.rs <re_set::unicode::RegexSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
+p0.clone();
+<re_set::unicode::RegexSet as std::clone::Clone>::clone(p0);
+crate::<re_set::unicode::RegexSet as std::clone::Clone>::clone(p0);
+<re_set::unicode::RegexSet>::clone(p0);
-----------------
src/re_set.rs re_set::unicode::RegexSet::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"re_set::unicode::RegexSet::new":{"I":["std::marker::Sized","std::iter::IntoIterator"],"S":["std::convert::AsRef","std::marker::Sized"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["re_set::unicode::SetMatchesIter","re_unicode::SplitN","re_set::bytes::SetMatchesIter","re_trait::SubCapturesPosIter","re_trait::CaptureMatches","re_unicode::Matches","re_trait::Matches","re_bytes::CaptureMatches","re_set::unicode::SetMatchesIntoIter","<&mut I as std::iter::Iterator>","re_bytes::Split","re_bytes::SubCaptureMatches","literal::imp::LiteralIter","re_bytes::Matches","re_unicode::CaptureNames","re_unicode::Split","dfa::InstPtrs","re_unicode::SubCaptureMatches","re_set::bytes::SetMatchesIntoIter","re_bytes::CaptureNames","re_unicode::CaptureMatches","re_bytes::SplitN"]},"re_set::unicode::RegexSet::new":{"I":["re_set::bytes::SetMatches","<&'a mut std::option::Option<T> as std::iter::IntoIterator>","re_set::unicode::SetMatches","<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>"],"S":["<&mut T as std::convert::AsRef<U>>","std::boxed::Box<T, A>","std::borrow::Cow<'_, std::ffi::OsStr>","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, T>","std::rc::Rc<T>","std::ffi::CStr","std::vec::Drain<'a, T, A>","std::slice::Iter<'_, T>","<&T as std::convert::AsRef<U>>","std::sync::Arc<T>","std::ffi::CString","std::slice::IterMut<'_, T>","std::vec::IntoIter<T, A>"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+re_set::unicode::RegexSet::new(p0);
+crate::re_set::unicode::RegexSet::new(p0);
+<re_set::unicode::RegexSet>::new(p0);
-----------------
src/re_set.rs re_set::unicode::RegexSet::empty
deps:{}
candidates:{}
+re_set::unicode::RegexSet::empty();
+crate::re_set::unicode::RegexSet::empty();
+<re_set::unicode::RegexSet>::empty();
-----------------
src/re_set.rs re_set::unicode::RegexSet::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = "sample"; // None+&str
+p0.is_match(&p1);
+re_set::unicode::RegexSet::is_match(p0, &p1);
+crate::re_set::unicode::RegexSet::is_match(p0, &p1);
+<re_set::unicode::RegexSet>::is_match(p0, &p1);
-----------------
src/re_set.rs re_set::unicode::RegexSet::is_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.is_match_at(&p1, p2);
+re_set::unicode::RegexSet::is_match_at(p0, &p1, p2);
+crate::re_set::unicode::RegexSet::is_match_at(p0, &p1, p2);
+<re_set::unicode::RegexSet>::is_match_at(p0, &p1, p2);
-----------------
src/re_set.rs re_set::unicode::RegexSet::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = "sample"; // None+&str
+p0.matches(&p1);
+re_set::unicode::RegexSet::matches(p0, &p1);
+crate::re_set::unicode::RegexSet::matches(p0, &p1);
+<re_set::unicode::RegexSet>::matches(p0, &p1);
-----------------
src/re_set.rs re_set::unicode::RegexSet::read_matches_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = "sample"; // None+&str
let mut p3 = 0usize; // None+usize
+p0.read_matches_at(p1, &p2, p3);
+re_set::unicode::RegexSet::read_matches_at(p0, p1, &p2, p3);
+crate::re_set::unicode::RegexSet::read_matches_at(p0, p1, &p2, p3);
+<re_set::unicode::RegexSet>::read_matches_at(p0, p1, &p2, p3);
-----------------
src/re_set.rs re_set::unicode::RegexSet::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
+p0.len();
+re_set::unicode::RegexSet::len(p0);
+crate::re_set::unicode::RegexSet::len(p0);
+<re_set::unicode::RegexSet>::len(p0);
-----------------
src/re_set.rs re_set::unicode::RegexSet::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
+p0.is_empty();
+re_set::unicode::RegexSet::is_empty(p0);
+crate::re_set::unicode::RegexSet::is_empty(p0);
+<re_set::unicode::RegexSet>::is_empty(p0);
-----------------
src/re_set.rs re_set::unicode::RegexSet::patterns
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
+p0.patterns();
+re_set::unicode::RegexSet::patterns(p0);
+crate::re_set::unicode::RegexSet::patterns(p0);
+<re_set::unicode::RegexSet>::patterns(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatches as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.clone();
+<re_set::unicode::SetMatches as std::clone::Clone>::clone(p0);
+crate::<re_set::unicode::SetMatches as std::clone::Clone>::clone(p0);
+<re_set::unicode::SetMatches>::clone(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatches as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::unicode::SetMatches as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::unicode::SetMatches as std::fmt::Debug>::fmt(p0, p1);
+<re_set::unicode::SetMatches>::fmt(p0, p1);
-----------------
src/re_set.rs re_set::unicode::SetMatches::matched_any
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.matched_any();
+re_set::unicode::SetMatches::matched_any(p0);
+crate::re_set::unicode::SetMatches::matched_any(p0);
+<re_set::unicode::SetMatches>::matched_any(p0);
-----------------
src/re_set.rs re_set::unicode::SetMatches::matched
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
let mut p1 = 0usize; // None+usize
+p0.matched(p1);
+re_set::unicode::SetMatches::matched(p0, p1);
+crate::re_set::unicode::SetMatches::matched(p0, p1);
+<re_set::unicode::SetMatches>::matched(p0, p1);
-----------------
src/re_set.rs re_set::unicode::SetMatches::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.len();
+re_set::unicode::SetMatches::len(p0);
+crate::re_set::unicode::SetMatches::len(p0);
+<re_set::unicode::SetMatches>::len(p0);
-----------------
src/re_set.rs re_set::unicode::SetMatches::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.iter();
+re_set::unicode::SetMatches::iter(p0);
+crate::re_set::unicode::SetMatches::iter(p0);
+<re_set::unicode::SetMatches>::iter(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.into_iter();
+<re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+crate::<re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+<re_set::unicode::SetMatches>::into_iter(p0);
-----------------
src/re_set.rs <&'a re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatches
+p0.into_iter();
+<&'a re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+<&'a re_set::unicode::SetMatches>::into_iter(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIntoIter as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIntoIter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::unicode::SetMatchesIntoIter as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::unicode::SetMatchesIntoIter as std::fmt::Debug>::fmt(p0, p1);
+<re_set::unicode::SetMatchesIntoIter>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIntoIter
+p0.next();
+<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::next(p0);
+crate::<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::next(p0);
+<re_set::unicode::SetMatchesIntoIter>::next(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::size_hint
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIntoIter
+p0.size_hint();
+<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::size_hint(p0);
+crate::<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::size_hint(p0);
+<re_set::unicode::SetMatchesIntoIter>::size_hint(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIntoIter
+p0.next_back();
+<re_set::unicode::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<re_set::unicode::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+<re_set::unicode::SetMatchesIntoIter>::next_back(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
+p0.clone();
+<re_set::unicode::SetMatchesIter<'a> as std::clone::Clone>::clone(p0);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::clone::Clone>::clone(p0);
+<re_set::unicode::SetMatchesIter<'a>>::clone(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::unicode::SetMatchesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<re_set::unicode::SetMatchesIter<'a>>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
+p0.next();
+<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::next(p0);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::next(p0);
+<re_set::unicode::SetMatchesIter<'a>>::next(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
+p0.size_hint();
+<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::size_hint(p0);
+<re_set::unicode::SetMatchesIter<'a>>::size_hint(p0);
-----------------
src/re_set.rs <re_set::unicode::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::unicode::SetMatchesIter<'a>
+p0.next_back();
+<re_set::unicode::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<re_set::unicode::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<re_set::unicode::SetMatchesIter<'a>>::next_back(p0);
-----------------
src/re_set.rs <re_set::unicode::RegexSet as std::convert::From<exec::Exec>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+<re_set::unicode::RegexSet as std::convert::From<exec::Exec>>::from(p0);
+crate::<re_set::unicode::RegexSet as std::convert::From<exec::Exec>>::from(p0);
+<re_set::unicode::RegexSet>::from(p0);
-----------------
src/re_set.rs <re_set::unicode::RegexSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::unicode::RegexSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::unicode::RegexSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::unicode::RegexSet as std::fmt::Debug>::fmt(p0, p1);
+<re_set::unicode::RegexSet>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::bytes::RegexSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
+p0.clone();
+<re_set::bytes::RegexSet as std::clone::Clone>::clone(p0);
+crate::<re_set::bytes::RegexSet as std::clone::Clone>::clone(p0);
+<re_set::bytes::RegexSet>::clone(p0);
-----------------
src/re_set.rs re_set::bytes::RegexSet::new
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"re_set::bytes::RegexSet::new":{"I":["std::iter::IntoIterator","std::marker::Sized"],"S":["std::marker::Sized","std::convert::AsRef"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"re_trait::Matches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a mut thread_local::CachedThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a mut thread_local::ThreadLocal<T> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&T as std::convert::AsRef<U>>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<I as std::iter::IntoIterator>":{"I":["re_set::bytes::SetMatchesIntoIter","re_set::bytes::SetMatchesIter","dfa::InstPtrs","re_trait::Matches","literal::imp::LiteralIter","re_bytes::Split","re_unicode::CaptureNames","re_bytes::CaptureMatches","re_bytes::Matches","re_unicode::Split","re_unicode::SubCaptureMatches","re_bytes::SubCaptureMatches","re_unicode::SplitN","re_bytes::SplitN","re_trait::CaptureMatches","re_trait::SubCapturesPosIter","re_unicode::Matches","<&mut I as std::iter::Iterator>","re_set::unicode::SetMatchesIntoIter","re_unicode::CaptureMatches","re_set::unicode::SetMatchesIter","re_bytes::CaptureNames"]},"re_set::bytes::RegexSet::new":{"I":["<&'a std::result::Result<T, E> as std::iter::IntoIterator>","<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>","re_set::bytes::SetMatches","re_set::unicode::SetMatches"],"S":["std::vec::Drain<'a, T, A>","std::borrow::Cow<'_, T>","std::slice::IterMut<'_, T>","std::vec::IntoIter<T, A>","std::rc::Rc<T>","std::sync::Arc<T>","core::num::dec2flt::common::AsciiStr<'a>","std::boxed::Box<T, A>","std::borrow::Cow<'_, std::ffi::OsStr>","std::ffi::CStr","<&mut T as std::convert::AsRef<U>>","std::slice::Iter<'_, T>","std::ffi::CString"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+re_set::bytes::RegexSet::new(p0);
+crate::re_set::bytes::RegexSet::new(p0);
+<re_set::bytes::RegexSet>::new(p0);
-----------------
src/re_set.rs re_set::bytes::RegexSet::empty
deps:{}
candidates:{}
+re_set::bytes::RegexSet::empty();
+crate::re_set::bytes::RegexSet::empty();
+<re_set::bytes::RegexSet>::empty();
-----------------
src/re_set.rs re_set::bytes::RegexSet::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.is_match(p1);
+re_set::bytes::RegexSet::is_match(p0, p1);
+crate::re_set::bytes::RegexSet::is_match(p0, p1);
+<re_set::bytes::RegexSet>::is_match(p0, p1);
-----------------
src/re_set.rs re_set::bytes::RegexSet::is_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p2 = 0usize; // None+usize
+p0.is_match_at(p1, p2);
+re_set::bytes::RegexSet::is_match_at(p0, p1, p2);
+crate::re_set::bytes::RegexSet::is_match_at(p0, p1, p2);
+<re_set::bytes::RegexSet>::is_match_at(p0, p1, p2);
-----------------
src/re_set.rs re_set::bytes::RegexSet::matches
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.matches(p1);
+re_set::bytes::RegexSet::matches(p0, p1);
+crate::re_set::bytes::RegexSet::matches(p0, p1);
+<re_set::bytes::RegexSet>::matches(p0, p1);
-----------------
src/re_set.rs re_set::bytes::RegexSet::read_matches_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = &mut [true].as_mut_slice(); // None+[bool]
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p3 = 0usize; // None+usize
+p0.read_matches_at(p1, p2, p3);
+re_set::bytes::RegexSet::read_matches_at(p0, p1, p2, p3);
+crate::re_set::bytes::RegexSet::read_matches_at(p0, p1, p2, p3);
+<re_set::bytes::RegexSet>::read_matches_at(p0, p1, p2, p3);
-----------------
src/re_set.rs re_set::bytes::RegexSet::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
+p0.len();
+re_set::bytes::RegexSet::len(p0);
+crate::re_set::bytes::RegexSet::len(p0);
+<re_set::bytes::RegexSet>::len(p0);
-----------------
src/re_set.rs re_set::bytes::RegexSet::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
+p0.is_empty();
+re_set::bytes::RegexSet::is_empty(p0);
+crate::re_set::bytes::RegexSet::is_empty(p0);
+<re_set::bytes::RegexSet>::is_empty(p0);
-----------------
src/re_set.rs re_set::bytes::RegexSet::patterns
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
+p0.patterns();
+re_set::bytes::RegexSet::patterns(p0);
+crate::re_set::bytes::RegexSet::patterns(p0);
+<re_set::bytes::RegexSet>::patterns(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatches as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.clone();
+<re_set::bytes::SetMatches as std::clone::Clone>::clone(p0);
+crate::<re_set::bytes::SetMatches as std::clone::Clone>::clone(p0);
+<re_set::bytes::SetMatches>::clone(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatches as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::bytes::SetMatches as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::bytes::SetMatches as std::fmt::Debug>::fmt(p0, p1);
+<re_set::bytes::SetMatches>::fmt(p0, p1);
-----------------
src/re_set.rs re_set::bytes::SetMatches::matched_any
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.matched_any();
+re_set::bytes::SetMatches::matched_any(p0);
+crate::re_set::bytes::SetMatches::matched_any(p0);
+<re_set::bytes::SetMatches>::matched_any(p0);
-----------------
src/re_set.rs re_set::bytes::SetMatches::matched
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
let mut p1 = 0usize; // None+usize
+p0.matched(p1);
+re_set::bytes::SetMatches::matched(p0, p1);
+crate::re_set::bytes::SetMatches::matched(p0, p1);
+<re_set::bytes::SetMatches>::matched(p0, p1);
-----------------
src/re_set.rs re_set::bytes::SetMatches::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.len();
+re_set::bytes::SetMatches::len(p0);
+crate::re_set::bytes::SetMatches::len(p0);
+<re_set::bytes::SetMatches>::len(p0);
-----------------
src/re_set.rs re_set::bytes::SetMatches::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.iter();
+re_set::bytes::SetMatches::iter(p0);
+crate::re_set::bytes::SetMatches::iter(p0);
+<re_set::bytes::SetMatches>::iter(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.into_iter();
+<re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+crate::<re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+<re_set::bytes::SetMatches>::into_iter(p0);
-----------------
src/re_set.rs <&'a re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatches
+p0.into_iter();
+<&'a re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter(p0);
+<&'a re_set::bytes::SetMatches>::into_iter(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIntoIter as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIntoIter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::bytes::SetMatchesIntoIter as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::bytes::SetMatchesIntoIter as std::fmt::Debug>::fmt(p0, p1);
+<re_set::bytes::SetMatchesIntoIter>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIntoIter
+p0.next();
+<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::next(p0);
+crate::<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::next(p0);
+<re_set::bytes::SetMatchesIntoIter>::next(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::size_hint
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIntoIter
+p0.size_hint();
+<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::size_hint(p0);
+crate::<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::size_hint(p0);
+<re_set::bytes::SetMatchesIntoIter>::size_hint(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIntoIter
+p0.next_back();
+<re_set::bytes::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<re_set::bytes::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+<re_set::bytes::SetMatchesIntoIter>::next_back(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
+p0.clone();
+<re_set::bytes::SetMatchesIter<'a> as std::clone::Clone>::clone(p0);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::clone::Clone>::clone(p0);
+<re_set::bytes::SetMatchesIter<'a>>::clone(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::bytes::SetMatchesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<re_set::bytes::SetMatchesIter<'a>>::fmt(p0, p1);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
+p0.next();
+<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::next(p0);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::next(p0);
+<re_set::bytes::SetMatchesIter<'a>>::next(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
+p0.size_hint();
+<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::size_hint(p0);
+<re_set::bytes::SetMatchesIter<'a>>::size_hint(p0);
-----------------
src/re_set.rs <re_set::bytes::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_set::bytes::SetMatchesIter<'a>
+p0.next_back();
+<re_set::bytes::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<re_set::bytes::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<re_set::bytes::SetMatchesIter<'a>>::next_back(p0);
-----------------
src/re_set.rs <re_set::bytes::RegexSet as std::convert::From<exec::Exec>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+<re_set::bytes::RegexSet as std::convert::From<exec::Exec>>::from(p0);
+crate::<re_set::bytes::RegexSet as std::convert::From<exec::Exec>>::from(p0);
+<re_set::bytes::RegexSet>::from(p0);
-----------------
src/re_set.rs <re_set::bytes::RegexSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_set::bytes::RegexSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_set::bytes::RegexSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_set::bytes::RegexSet as std::fmt::Debug>::fmt(p0, p1);
+<re_set::bytes::RegexSet>::fmt(p0, p1);
-----------------
src/re_trait.rs <re_trait::Locations as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
+p0.clone();
+<re_trait::Locations as std::clone::Clone>::clone(p0);
+crate::<re_trait::Locations as std::clone::Clone>::clone(p0);
+<re_trait::Locations>::clone(p0);
-----------------
src/re_trait.rs <re_trait::Locations as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_trait::Locations as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_trait::Locations as std::fmt::Debug>::fmt(p0, p1);
+<re_trait::Locations>::fmt(p0, p1);
-----------------
src/re_trait.rs re_trait::Locations::pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
let mut p1 = 0usize; // None+usize
+p0.pos(p1);
+re_trait::Locations::pos(p0, p1);
+crate::re_trait::Locations::pos(p0, p1);
+<re_trait::Locations>::pos(p0, p1);
-----------------
src/re_trait.rs re_trait::Locations::iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
+p0.iter();
+re_trait::Locations::iter(p0);
+crate::re_trait::Locations::iter(p0);
+<re_trait::Locations>::iter(p0);
-----------------
src/re_trait.rs re_trait::Locations::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Locations
+p0.len();
+re_trait::Locations::len(p0);
+crate::re_trait::Locations::len(p0);
+<re_trait::Locations>::len(p0);
-----------------
src/re_trait.rs re_trait::Locations::as_slots
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Locations
+p0.as_slots();
+re_trait::Locations::as_slots(p0);
+crate::re_trait::Locations::as_slots(p0);
+<re_trait::Locations>::as_slots(p0);
-----------------
src/re_trait.rs <re_trait::SubCapturesPosIter<'c> as std::clone::Clone>::clone
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::SubCapturesPosIter<'c>
+p0.clone();
+<re_trait::SubCapturesPosIter<'c> as std::clone::Clone>::clone(p0);
+crate::<re_trait::SubCapturesPosIter<'c> as std::clone::Clone>::clone(p0);
+<re_trait::SubCapturesPosIter<'c>>::clone(p0);
-----------------
src/re_trait.rs <re_trait::SubCapturesPosIter<'c> as std::fmt::Debug>::fmt
'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::SubCapturesPosIter<'c>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_trait::SubCapturesPosIter<'c> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_trait::SubCapturesPosIter<'c> as std::fmt::Debug>::fmt(p0, p1);
+<re_trait::SubCapturesPosIter<'c>>::fmt(p0, p1);
-----------------
src/re_trait.rs <re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::next
'c
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::SubCapturesPosIter<'c>
+p0.next();
+<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::next(p0);
+crate::<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::next(p0);
+<re_trait::SubCapturesPosIter<'c>>::next(p0);
-----------------
src/re_trait.rs <re_trait::Matches<'t, R> as std::fmt::Debug>::fmt
't
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_trait::Matches<'t, R> as std::fmt::Debug>::fmt":{"<R as re_trait::RegularExpression>::Text":["std::fmt::Debug"],"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"backtrack::Bounded":{"I":["std::marker::Sized","input::Input","std::fmt::Debug"]},"cache::imp::Cached":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"cache::imp::CachedGuard":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"dfa::Result":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"pikevm::Fsm":{"I":["input::Input","std::marker::Sized","std::fmt::Debug"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","re_trait::RegularExpression","std::fmt::Debug"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_trait::Matches<'t, R> as std::fmt::Debug>::fmt":{"<R as re_trait::RegularExpression>::Text":["prog::EmptyLook","re_trait::Locations","literal::imp::FreqyPacked","<*mut T as std::fmt::Debug>","re_builder::set_bytes::RegexSetBuilder","re_set::bytes::RegexSet","input::ByteInput","re_bytes::ReplacerRef","re_bytes::Matches","prog::InstSplit","compile::SuffixCacheKey","cache::imp::Cached","backtrack::Job","re_bytes::Captures","re_unicode::Regex","pikevm::Threads","expand::Ref","re_set::bytes::SetMatchesIntoIter","exec::MatchNfaType","re_unicode::Match","dfa::StateFlags","literal::imp::LiteralSearcher","prog::Program","prog::Inst","re_set::bytes::SetMatches","literal::imp::BoyerMooreSearch","re_set::bytes::SetMatchesIter","backtrack::Bounded","compile::MaybeInst","re_builder::bytes::RegexBuilder","dfa::TransitionsRow","re_bytes::Split","re_builder::unicode::RegexBuilder","re_unicode::SplitN","dfa::CacheInner","literal::imp::Matcher","re_unicode::CaptureMatches","re_bytes::CaptureNames","re_bytes::SubCaptureMatches","prog::InstBytes","input::Char","re_unicode::CaptureNames","exec::ExecReadOnly","re_unicode::Captures","compile::InstHole","input::InputAt","prog::InstSave","dfa::Byte","error::Error","prog::InstRanges","dfa::Transitions","re_set::unicode::SetMatchesIter","re_bytes::CaptureLocations","re_unicode::SubCaptureMatches","compile::SuffixCacheEntry","re_trait::CaptureMatches","re_set::unicode::RegexSet","dfa::Cache","compile::Hole","re_builder::RegexOptions","pikevm::FollowEpsilon","re_set::unicode::SetMatches","dfa::State","re_bytes::CapturesDebug","dfa::Fsm","re_trait::SubCapturesPosIter","exec::Exec","compile::SuffixCache","re_bytes::CaptureMatches","cache::imp::CachedGuard","re_bytes::Regex","dfa::StateMap","pikevm::Cache","exec::ExecNoSync","pikevm::Fsm","expand::CaptureRef","re_bytes::Match","re_bytes::NoExpand","compile::Patch","re_bytes::SplitN","exec::MatchLiteralType","re_builder::set_unicode::RegexSetBuilder","dfa::Result","re_unicode::Split","compile::ByteClassSet","input::CharInput","backtrack::Cache","exec::ProgramCacheInner","re_unicode::CapturesDebug","sparse::SparseSet","re_unicode::NoExpand","exec::ExecNoSyncStr","prog::InstEmptyLook","literal::imp::SingleByteSet","prog::InstChar","re_set::unicode::SetMatchesIntoIter","re_unicode::Matches","dfa::EmptyFlags","re_unicode::ReplacerRef","literal::imp::LiteralIter","re_unicode::CaptureLocations","re_trait::Matches","exec::MatchType"],"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"backtrack::Bounded":{"I":["input::ByteInput","input::CharInput"]},"cache::imp::Cached":{"T":["std::vec::Drain<'_, T, A>","std::ptr::DynMetadata<Dyn>","std::task::Waker","std::sync::mpmc::Receiver<T>","std::collections::vec_deque::Drain<'_, T, A>","std::ptr::Unique<T>","std::collections::linked_list::CursorMut<'_, T>","std::rc::Weak<T>","std::sync::mpsc::SyncSender<T>","std::sync::MutexGuard<'_, T>","std::cell::RefCell<T>","std::env::Args","std::sync::RwLockWriteGuard<'_, T>","std::sync::Arc<T>","std::thread::JoinHandle<T>","std::collections::linked_list::Cursor<'_, T>","std::io::IoSliceMut<'a>","std::slice::Iter<'_, T>","std::rc::Rc<T>","std::sync::RwLockReadGuard<'_, T>","std::sync::RwLock<T>","std::collections::linked_list::IterMut<'_, T>","std::sync::mpmc::Sender<T>","std::ptr::NonNull<T>","std::sync::atomic::AtomicPtr<T>","<*mut T as std::marker::Send>","std::sync::Mutex<T>","std::boxed::ThinBox<T>","std::collections::LinkedList<T>","std::env::ArgsOs","std::slice::IterMut<'_, T>","std::string::Drain<'_>","<&T as std::fmt::Debug>","std::cell::Cell<T>","std::io::IoSlice<'a>","std::sync::Weak<T>","std::io::error::repr_bitpacked::Repr","std::future::ResumeTy","std::sync::OnceLock<T>","std::sys::unix::args::Args","std::sync::mpsc::Receiver<T>","std::sync::mpsc::Sender<T>","std::collections::linked_list::Iter<'_, T>","std::vec::IntoIter<T, A>"]},"cache::imp::CachedGuard":{"T":["std::sync::mpsc::SyncSender<T>","std::collections::LinkedList<T>","std::future::ResumeTy","std::ptr::Unique<T>","std::env::Args","<&T as std::marker::Send>","std::vec::Drain<'_, T, A>","std::ptr::NonNull<T>","std::sync::RwLockWriteGuard<'_, T>","std::io::IoSliceMut<'a>","std::rc::Rc<T>","std::string::Drain<'_>","std::cell::RefCell<T>","std::slice::IterMut<'_, T>","std::sync::MutexGuard<'_, T>","std::sync::mpsc::Receiver<T>","std::thread::JoinHandle<T>","std::vec::IntoIter<T, A>","std::cell::Cell<T>","std::collections::linked_list::CursorMut<'_, T>","std::collections::vec_deque::Drain<'_, T, A>","std::collections::linked_list::IterMut<'_, T>","std::ptr::DynMetadata<Dyn>","std::task::Waker","std::sync::Mutex<T>","std::sync::mpmc::Sender<T>","std::sync::Arc<T>","std::sync::mpsc::Sender<T>","std::slice::Iter<'_, T>","std::sync::RwLock<T>","std::io::error::repr_bitpacked::Repr","std::sync::OnceLock<T>","std::sync::mpmc::Receiver<T>","std::sync::RwLockReadGuard<'_, T>","std::collections::linked_list::Iter<'_, T>","std::boxed::ThinBox<T>","std::sys::unix::args::Args","std::sync::Weak<T>","std::collections::linked_list::Cursor<'_, T>","std::rc::Weak<T>","std::env::ArgsOs","std::sync::atomic::AtomicPtr<T>","std::io::IoSlice<'a>"]},"dfa::Result":{"T":["re_unicode::Match","dfa::Result","re_bytes::Regex","error::Error","prog::Program","pikevm::Threads","input::ByteInput","exec::MatchType","literal::imp::FreqyPacked","dfa::State","re_bytes::CaptureNames","dfa::Byte","re_bytes::SubCaptureMatches","prog::InstSave","input::Char","re_unicode::NoExpand","re_builder::RegexOptions","literal::imp::SingleByteSet","pikevm::Cache","re_unicode::CaptureLocations","prog::EmptyLook","exec::MatchLiteralType","dfa::EmptyFlags","prog::InstEmptyLook","expand::Ref","prog::Inst","prog::InstRanges","re_set::bytes::SetMatchesIter","re_set::bytes::RegexSet","prog::InstBytes","pikevm::FollowEpsilon","backtrack::Cache","re_set::bytes::SetMatches","sparse::SparseSet","compile::InstHole","re_set::unicode::RegexSet","compile::SuffixCacheEntry","input::CharInput","re_unicode::SubCaptureMatches","backtrack::Job","dfa::Transitions","re_unicode::CaptureNames","prog::InstSplit","re_set::unicode::SetMatchesIter","re_trait::Locations","input::InputAt","re_unicode::Regex","prog::InstChar","<*const T as std::fmt::Debug>","re_bytes::CaptureLocations","expand::CaptureRef","re_bytes::NoExpand","literal::imp::Matcher","re_trait::SubCapturesPosIter","dfa::StateFlags","re_set::unicode::SetMatches","exec::Exec","literal::imp::BoyerMooreSearch","compile::MaybeInst","literal::imp::LiteralSearcher","re_bytes::Match","exec::MatchNfaType","compile::SuffixCacheKey"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"re_trait::Matches":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Matches<'t, R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_trait::Matches<'t, R> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_trait::Matches<'t, R> as std::fmt::Debug>::fmt(p0, p1);
+<re_trait::Matches<'t, R>>::fmt(p0, p1);
-----------------
src/re_trait.rs re_trait::Matches::<'t, R>::text
't
deps:{"re_trait::Matches::<'t, R>::text":{"R":["std::marker::Sized","re_trait::RegularExpression"]}}
candidates:{"re_trait::Matches::<'t, R>::text":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Matches<'t, R>
+p0.text();
+re_trait::Matches::<'t, R>::text(p0);
+crate::re_trait::Matches::<'t, R>::text(p0);
+<re_trait::Matches<'t, R>>::text(p0);
-----------------
src/re_trait.rs re_trait::Matches::<'t, R>::regex
't
deps:{"re_trait::Matches::<'t, R>::regex":{"R":["re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"re_trait::Matches::<'t, R>::regex":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::Matches<'t, R>
+p0.regex();
+re_trait::Matches::<'t, R>::regex(p0);
+crate::re_trait::Matches::<'t, R>::regex(p0);
+<re_trait::Matches<'t, R>>::regex(p0);
-----------------
src/re_trait.rs <re_trait::Matches<'t, R> as std::iter::Iterator>::next
't
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<re_trait::Matches<'t, R> as std::iter::Iterator>::next":{"<R as re_trait::RegularExpression>::Text":["std::convert::AsRef"],"R":["re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<re_trait::Matches<'t, R> as std::iter::Iterator>::next":{"<R as re_trait::RegularExpression>::Text":["std::slice::Iter<'_, T>","<&T as std::convert::AsRef<U>>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::borrow::Cow<'_, std::ffi::OsStr>","std::rc::Rc<T>","std::vec::Drain<'a, T, A>","std::ffi::CString","std::vec::IntoIter<T, A>","std::ffi::CStr","std::borrow::Cow<'_, T>","std::slice::IterMut<'_, T>","core::num::dec2flt::common::AsciiStr<'a>"],"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::Matches<'t, R>
+p0.next();
+<re_trait::Matches<'t, R> as std::iter::Iterator>::next(p0);
+crate::<re_trait::Matches<'t, R> as std::iter::Iterator>::next(p0);
+<re_trait::Matches<'t, R>>::next(p0);
-----------------
src/re_trait.rs <re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt
't
deps:{"<re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt":{"R":["re_trait::RegularExpression","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::CaptureMatches<'t, R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt(p0, p1);
+<re_trait::CaptureMatches<'t, R>>::fmt(p0, p1);
-----------------
src/re_trait.rs re_trait::CaptureMatches::<'t, R>::text
't
deps:{"re_trait::CaptureMatches::<'t, R>::text":{"R":["re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"re_trait::CaptureMatches::<'t, R>::text":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::CaptureMatches<'t, R>
+p0.text();
+re_trait::CaptureMatches::<'t, R>::text(p0);
+crate::re_trait::CaptureMatches::<'t, R>::text(p0);
+<re_trait::CaptureMatches<'t, R>>::text(p0);
-----------------
src/re_trait.rs re_trait::CaptureMatches::<'t, R>::regex
't
deps:{"re_trait::CaptureMatches::<'t, R>::regex":{"R":["std::marker::Sized","re_trait::RegularExpression"]}}
candidates:{"re_trait::CaptureMatches::<'t, R>::regex":{"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_trait::CaptureMatches<'t, R>
+p0.regex();
+re_trait::CaptureMatches::<'t, R>::regex(p0);
+crate::re_trait::CaptureMatches::<'t, R>::regex(p0);
+<re_trait::CaptureMatches<'t, R>>::regex(p0);
-----------------
src/re_trait.rs <re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next
't
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next":{"<R as re_trait::RegularExpression>::Text":["std::convert::AsRef"],"R":["re_trait::RegularExpression","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next":{"<R as re_trait::RegularExpression>::Text":["std::boxed::Box<T, A>","core::num::dec2flt::common::AsciiStr<'a>","std::borrow::Cow<'_, T>","std::vec::IntoIter<T, A>","std::sync::Arc<T>","std::ffi::CString","std::slice::Iter<'_, T>","std::rc::Rc<T>","std::ffi::CStr","std::borrow::Cow<'_, std::ffi::OsStr>","<&T as std::convert::AsRef<U>>","std::slice::IterMut<'_, T>","std::vec::Drain<'a, T, A>"],"R":["exec::ExecNoSyncStr","exec::ExecNoSync"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_trait::CaptureMatches<'t, R>
+p0.next();
+<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next(p0);
+crate::<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next(p0);
+<re_trait::CaptureMatches<'t, R>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::Match<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.clone();
+<re_unicode::Match<'t> as std::clone::Clone>::clone(p0);
+crate::<re_unicode::Match<'t> as std::clone::Clone>::clone(p0);
+<re_unicode::Match<'t>>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::Match<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Match<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Match<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Match<'t>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.assert_receiver_is_total_eq();
+<re_unicode::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<re_unicode::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<re_unicode::Match<'t>>::assert_receiver_is_total_eq(p0);
-----------------
src/re_unicode.rs <re_unicode::Match<'t> as std::cmp::PartialEq>::eq
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.eq(p1);
+<re_unicode::Match<'t> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<re_unicode::Match<'t> as std::cmp::PartialEq>::eq(p0, p1);
+<re_unicode::Match<'t>>::eq(p0, p1);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::start
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.start();
+re_unicode::Match::<'t>::start(p0);
+crate::re_unicode::Match::<'t>::start(p0);
+<re_unicode::Match<'t>>::start(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::end
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.end();
+re_unicode::Match::<'t>::end(p0);
+crate::re_unicode::Match::<'t>::end(p0);
+<re_unicode::Match<'t>>::end(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::range
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.range();
+re_unicode::Match::<'t>::range(p0);
+crate::re_unicode::Match::<'t>::range(p0);
+<re_unicode::Match<'t>>::range(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::as_str
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+p0.as_str();
+re_unicode::Match::<'t>::as_str(p0);
+crate::re_unicode::Match::<'t>::as_str(p0);
+<re_unicode::Match<'t>>::as_str(p0);
-----------------
src/re_unicode.rs re_unicode::Match::<'t>::new
't
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+re_unicode::Match::<'t>::new(&p0, p1, p2);
+crate::re_unicode::Match::<'t>::new(&p0, p1, p2);
+<re_unicode::Match<'t>>::new(&p0, p1, p2);
-----------------
src/re_unicode.rs re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for &'t str>::from
't
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for &'t str>::from(p0);
+crate::re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for &'t str>::from(p0);
+<&'t str>::from(p0);
-----------------
src/re_unicode.rs re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for std::ops::Range<usize>>::from
't
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_unicode::Match<'t>
+re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for std::ops::Range<usize>>::from(p0);
+crate::re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for std::ops::Range<usize>>::from(p0);
+<std::ops::Range<usize>>::from(p0);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.clone();
+<re_unicode::Regex as std::clone::Clone>::clone(p0);
+crate::<re_unicode::Regex as std::clone::Clone>::clone(p0);
+<re_unicode::Regex>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<re_unicode::Regex as std::fmt::Display>::fmt(p0, p1);
+crate::<re_unicode::Regex as std::fmt::Display>::fmt(p0, p1);
+<re_unicode::Regex>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Regex as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Regex as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Regex>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::convert::From<exec::Exec>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // exec::Exec
+<re_unicode::Regex as std::convert::From<exec::Exec>>::from(p0);
+crate::<re_unicode::Regex as std::convert::From<exec::Exec>>::from(p0);
+<re_unicode::Regex>::from(p0);
-----------------
src/re_unicode.rs <re_unicode::Regex as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<re_unicode::Regex as std::str::FromStr>::from_str(&p0);
+crate::<re_unicode::Regex as std::str::FromStr>::from_str(&p0);
+<re_unicode::Regex>::from_str(&p0);
-----------------
src/re_unicode.rs re_unicode::Regex::new
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+re_unicode::Regex::new(&p0);
+crate::re_unicode::Regex::new(&p0);
+<re_unicode::Regex>::new(&p0);
-----------------
src/re_unicode.rs re_unicode::Regex::is_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.is_match(&p1);
+re_unicode::Regex::is_match(p0, &p1);
+crate::re_unicode::Regex::is_match(p0, &p1);
+<re_unicode::Regex>::is_match(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::find
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.find(&p1);
+re_unicode::Regex::find(p0, &p1);
+crate::re_unicode::Regex::find(p0, &p1);
+<re_unicode::Regex>::find(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::find_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.find_iter(&p1);
+re_unicode::Regex::find_iter(p0, &p1);
+crate::re_unicode::Regex::find_iter(p0, &p1);
+<re_unicode::Regex>::find_iter(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::captures
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.captures(&p1);
+re_unicode::Regex::captures(p0, &p1);
+crate::re_unicode::Regex::captures(p0, &p1);
+<re_unicode::Regex>::captures(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::captures_iter
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.captures_iter(&p1);
+re_unicode::Regex::captures_iter(p0, &p1);
+crate::re_unicode::Regex::captures_iter(p0, &p1);
+<re_unicode::Regex>::captures_iter(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::split
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.split(&p1);
+re_unicode::Regex::split(p0, &p1);
+crate::re_unicode::Regex::split(p0, &p1);
+<re_unicode::Regex>::split(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::splitn
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.splitn(&p1, p2);
+re_unicode::Regex::splitn(p0, &p1, p2);
+crate::re_unicode::Regex::splitn(p0, &p1, p2);
+<re_unicode::Regex>::splitn(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::replace
deps:{"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"re_unicode::Regex::replace":{"R":["re_unicode::Replacer","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_unicode::Replacer>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"re_unicode::Regex::replace":{"R":["re_unicode::NoExpand","<F as re_unicode::Replacer>","re_unicode::ReplacerRef"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // R
+p0.replace(&p1, p2);
+re_unicode::Regex::replace(p0, &p1, p2);
+crate::re_unicode::Regex::replace(p0, &p1, p2);
+<re_unicode::Regex>::replace(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::replace_all
deps:{"<F as re_unicode::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"re_unicode::Regex::replace_all":{"R":["std::marker::Sized","re_unicode::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_unicode::Replacer>":{"F":["core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap"]},"re_unicode::Regex::replace_all":{"R":["re_unicode::ReplacerRef","<F as re_unicode::Replacer>","re_unicode::NoExpand"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // R
+p0.replace_all(&p1, p2);
+re_unicode::Regex::replace_all(p0, &p1, p2);
+crate::re_unicode::Regex::replace_all(p0, &p1, p2);
+<re_unicode::Regex>::replace_all(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::replacen
deps:{"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"re_unicode::Regex::replacen":{"R":["re_unicode::Replacer","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_unicode::Replacer>":{"F":["core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace"]},"re_unicode::Regex::replacen":{"R":["re_unicode::ReplacerRef","<F as re_unicode::Replacer>","re_unicode::NoExpand"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // R
+p0.replacen(&p1, p2, p3);
+re_unicode::Regex::replacen(p0, &p1, p2, p3);
+crate::re_unicode::Regex::replacen(p0, &p1, p2, p3);
+<re_unicode::Regex>::replacen(p0, &p1, p2, p3);
-----------------
src/re_unicode.rs re_unicode::Regex::shortest_match
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
+p0.shortest_match(&p1);
+re_unicode::Regex::shortest_match(p0, &p1);
+crate::re_unicode::Regex::shortest_match(p0, &p1);
+<re_unicode::Regex>::shortest_match(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Regex::shortest_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.shortest_match_at(&p1, p2);
+re_unicode::Regex::shortest_match_at(p0, &p1, p2);
+crate::re_unicode::Regex::shortest_match_at(p0, &p1, p2);
+<re_unicode::Regex>::shortest_match_at(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::is_match_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.is_match_at(&p1, p2);
+re_unicode::Regex::is_match_at(p0, &p1, p2);
+crate::re_unicode::Regex::is_match_at(p0, &p1, p2);
+<re_unicode::Regex>::is_match_at(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::find_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.find_at(&p1, p2);
+re_unicode::Regex::find_at(p0, &p1, p2);
+crate::re_unicode::Regex::find_at(p0, &p1, p2);
+<re_unicode::Regex>::find_at(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Regex::captures_read
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p2 = "sample"; // None+&str
+p0.captures_read(p1, &p2);
+re_unicode::Regex::captures_read(p0, p1, &p2);
+crate::re_unicode::Regex::captures_read(p0, p1, &p2);
+<re_unicode::Regex>::captures_read(p0, p1, &p2);
-----------------
src/re_unicode.rs re_unicode::Regex::captures_read_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p2 = "sample"; // None+&str
let mut p3 = 0usize; // None+usize
+p0.captures_read_at(p1, &p2, p3);
+re_unicode::Regex::captures_read_at(p0, p1, &p2, p3);
+crate::re_unicode::Regex::captures_read_at(p0, p1, &p2, p3);
+<re_unicode::Regex>::captures_read_at(p0, p1, &p2, p3);
-----------------
src/re_unicode.rs re_unicode::Regex::read_captures_at
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p2 = "sample"; // None+&str
let mut p3 = 0usize; // None+usize
+p0.read_captures_at(p1, &p2, p3);
+re_unicode::Regex::read_captures_at(p0, p1, &p2, p3);
+crate::re_unicode::Regex::read_captures_at(p0, p1, &p2, p3);
+<re_unicode::Regex>::read_captures_at(p0, p1, &p2, p3);
-----------------
src/re_unicode.rs re_unicode::Regex::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.as_str();
+re_unicode::Regex::as_str(p0);
+crate::re_unicode::Regex::as_str(p0);
+<re_unicode::Regex>::as_str(p0);
-----------------
src/re_unicode.rs re_unicode::Regex::capture_names
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.capture_names();
+re_unicode::Regex::capture_names(p0);
+crate::re_unicode::Regex::capture_names(p0);
+<re_unicode::Regex>::capture_names(p0);
-----------------
src/re_unicode.rs re_unicode::Regex::captures_len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.captures_len();
+re_unicode::Regex::captures_len(p0);
+crate::re_unicode::Regex::captures_len(p0);
+<re_unicode::Regex>::captures_len(p0);
-----------------
src/re_unicode.rs re_unicode::Regex::capture_locations
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.capture_locations();
+re_unicode::Regex::capture_locations(p0);
+crate::re_unicode::Regex::capture_locations(p0);
+<re_unicode::Regex>::capture_locations(p0);
-----------------
src/re_unicode.rs re_unicode::Regex::locations
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Regex
+p0.locations();
+re_unicode::Regex::locations(p0);
+crate::re_unicode::Regex::locations(p0);
+<re_unicode::Regex>::locations(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::clone::Clone>::clone
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
+p0.clone();
+<re_unicode::CaptureNames<'r> as std::clone::Clone>::clone(p0);
+crate::<re_unicode::CaptureNames<'r> as std::clone::Clone>::clone(p0);
+<re_unicode::CaptureNames<'r>>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::fmt::Debug>::fmt
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::CaptureNames<'r> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::CaptureNames<'r> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::CaptureNames<'r>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::iter::Iterator>::next
'r
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
+p0.next();
+<re_unicode::CaptureNames<'r> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::CaptureNames<'r> as std::iter::Iterator>::next(p0);
+<re_unicode::CaptureNames<'r>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::iter::Iterator>::size_hint
'r
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
+p0.size_hint();
+<re_unicode::CaptureNames<'r> as std::iter::Iterator>::size_hint(p0);
+crate::<re_unicode::CaptureNames<'r> as std::iter::Iterator>::size_hint(p0);
+<re_unicode::CaptureNames<'r>>::size_hint(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureNames<'r> as std::iter::Iterator>::count
'r
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // re_unicode::CaptureNames<'r>
+p0.count();
+<re_unicode::CaptureNames<'r> as std::iter::Iterator>::count(p0);
+crate::<re_unicode::CaptureNames<'r> as std::iter::Iterator>::count(p0);
+<re_unicode::CaptureNames<'r>>::count(p0);
-----------------
src/re_unicode.rs <re_unicode::Split<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Split<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Split<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Split<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Split<'r, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Split<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::Split<'r, 't>
+p0.next();
+<re_unicode::Split<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::Split<'r, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::Split<'r, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::SplitN<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::SplitN<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::SplitN<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::SplitN<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::SplitN<'r, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::SplitN<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::SplitN<'r, 't>
+p0.next();
+<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::SplitN<'r, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::SplitN<'r, 't> as std::iter::Iterator>::size_hint
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::SplitN<'r, 't>
+p0.size_hint();
+<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::size_hint(p0);
+crate::<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::size_hint(p0);
+<re_unicode::SplitN<'r, 't>>::size_hint(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureLocations as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
+p0.clone();
+<re_unicode::CaptureLocations as std::clone::Clone>::clone(p0);
+crate::<re_unicode::CaptureLocations as std::clone::Clone>::clone(p0);
+<re_unicode::CaptureLocations>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureLocations as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::CaptureLocations as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::CaptureLocations as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::CaptureLocations>::fmt(p0, p1);
-----------------
src/re_unicode.rs re_unicode::CaptureLocations::get
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+re_unicode::CaptureLocations::get(p0, p1);
+crate::re_unicode::CaptureLocations::get(p0, p1);
+<re_unicode::CaptureLocations>::get(p0, p1);
-----------------
src/re_unicode.rs re_unicode::CaptureLocations::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
+p0.len();
+re_unicode::CaptureLocations::len(p0);
+crate::re_unicode::CaptureLocations::len(p0);
+<re_unicode::CaptureLocations>::len(p0);
-----------------
src/re_unicode.rs re_unicode::CaptureLocations::pos
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureLocations
let mut p1 = 0usize; // None+usize
+p0.pos(p1);
+re_unicode::CaptureLocations::pos(p0, p1);
+crate::re_unicode::CaptureLocations::pos(p0, p1);
+<re_unicode::CaptureLocations>::pos(p0, p1);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::get
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = 0usize; // None+usize
+p0.get(p1);
+re_unicode::Captures::<'t>::get(p0, p1);
+crate::re_unicode::Captures::<'t>::get(p0, p1);
+<re_unicode::Captures<'t>>::get(p0, p1);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::name
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = "sample"; // None+&str
+p0.name(&p1);
+re_unicode::Captures::<'t>::name(p0, &p1);
+crate::re_unicode::Captures::<'t>::name(p0, &p1);
+<re_unicode::Captures<'t>>::name(p0, &p1);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::iter
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
+p0.iter();
+re_unicode::Captures::<'t>::iter(p0);
+crate::re_unicode::Captures::<'t>::iter(p0);
+<re_unicode::Captures<'t>>::iter(p0);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::expand
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = "sample"; // None+&str
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.expand(&p1, p2);
+re_unicode::Captures::<'t>::expand(p0, &p1, p2);
+crate::re_unicode::Captures::<'t>::expand(p0, &p1, p2);
+<re_unicode::Captures<'t>>::expand(p0, &p1, p2);
-----------------
src/re_unicode.rs re_unicode::Captures::<'t>::len
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
+p0.len();
+re_unicode::Captures::<'t>::len(p0);
+crate::re_unicode::Captures::<'t>::len(p0);
+<re_unicode::Captures<'t>>::len(p0);
-----------------
src/re_unicode.rs <re_unicode::Captures<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Captures<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Captures<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Captures<'t>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CapturesDebug<'c, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::CapturesDebug<'c, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Captures<'t> as std::ops::Index<usize>>::index
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = 0usize; // None+usize
+p0.index(p1);
+<re_unicode::Captures<'t> as std::ops::Index<usize>>::index(p0, p1);
+crate::<re_unicode::Captures<'t> as std::ops::Index<usize>>::index(p0, p1);
+<re_unicode::Captures<'t>>::index(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Captures<'t> as std::ops::Index<&'i str>>::index
't,'i
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'t>
let mut p1 = "sample"; // None+&str
+p0.index(&p1);
+<re_unicode::Captures<'t> as std::ops::Index<&'i str>>::index(p0, &p1);
+crate::<re_unicode::Captures<'t> as std::ops::Index<&'i str>>::index(p0, &p1);
+<re_unicode::Captures<'t>>::index(p0, &p1);
-----------------
src/re_unicode.rs <re_unicode::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::SubCaptureMatches<'c, 't>
+p0.clone();
+<re_unicode::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone(p0);
+crate::<re_unicode::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone(p0);
+<re_unicode::SubCaptureMatches<'c, 't>>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt
'c,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::SubCaptureMatches<'c, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::SubCaptureMatches<'c, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next
'c,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::SubCaptureMatches<'c, 't>
+p0.next();
+<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::SubCaptureMatches<'c, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::CaptureMatches<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::CaptureMatches<'r, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::CaptureMatches<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::CaptureMatches<'r, 't>
+p0.next();
+<re_unicode::CaptureMatches<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::CaptureMatches<'r, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::CaptureMatches<'r, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::Matches<'r, 't> as std::fmt::Debug>::fmt
'r,'t
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::Matches<'r, 't>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::Matches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::Matches<'r, 't> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::Matches<'r, 't>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::Matches<'r, 't> as std::iter::Iterator>::next
'r,'t
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::Matches<'r, 't>
+p0.next();
+<re_unicode::Matches<'r, 't> as std::iter::Iterator>::next(p0);
+crate::<re_unicode::Matches<'r, 't> as std::iter::Iterator>::next(p0);
+<re_unicode::Matches<'r, 't>>::next(p0);
-----------------
src/re_unicode.rs <re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":{"R":["std::fmt::Debug"]},"backtrack::Bounded":{"I":["std::marker::Sized","std::fmt::Debug","input::Input"]},"cache::imp::Cached":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"cache::imp::CachedGuard":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"dfa::Result":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"pikevm::Fsm":{"I":["std::marker::Sized","std::fmt::Debug","input::Input"]},"re_trait::CaptureMatches":{"R":["std::marker::Sized","std::fmt::Debug","re_trait::RegularExpression"]},"re_trait::Matches":{"R":["re_trait::RegularExpression","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&T as std::marker::Send>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":{"R":["re_unicode::Matches","prog::Program","compile::ByteClassSet","error::Error","re_unicode::CaptureNames","re_set::unicode::RegexSet","prog::InstChar","compile::MaybeInst","re_builder::set_bytes::RegexSetBuilder","re_unicode::CaptureLocations","literal::imp::LiteralSearcher","prog::InstSplit","pikevm::FollowEpsilon","expand::CaptureRef","cache::imp::Cached","re_bytes::CaptureMatches","dfa::StateFlags","re_bytes::CapturesDebug","input::InputAt","compile::SuffixCacheEntry","re_trait::Matches","re_builder::RegexOptions","compile::SuffixCacheKey","re_builder::unicode::RegexBuilder","re_bytes::Matches","re_unicode::Split","re_bytes::Regex","prog::InstSave","re_set::bytes::SetMatches","re_bytes::CaptureNames","re_trait::Locations","exec::MatchLiteralType","literal::imp::SingleByteSet","re_unicode::NoExpand","re_set::unicode::SetMatchesIntoIter","prog::Inst","backtrack::Cache","pikevm::Cache","re_builder::bytes::RegexBuilder","re_trait::CaptureMatches","exec::ExecNoSyncStr","exec::ProgramCacheInner","literal::imp::FreqyPacked","re_unicode::CaptureMatches","literal::imp::BoyerMooreSearch","input::CharInput","re_bytes::Split","input::ByteInput","re_bytes::SplitN","exec::Exec","re_unicode::SubCaptureMatches","dfa::EmptyFlags","re_bytes::Captures","re_trait::SubCapturesPosIter","dfa::StateMap","re_set::unicode::SetMatches","exec::MatchNfaType","prog::EmptyLook","re_set::unicode::SetMatchesIter","re_unicode::SplitN","exec::MatchType","re_bytes::Match","literal::imp::LiteralIter","re_unicode::Captures","re_unicode::Match","expand::Ref","dfa::CacheInner","compile::InstHole","input::Char","exec::ExecNoSync","re_bytes::CaptureLocations","re_unicode::ReplacerRef","prog::InstEmptyLook","dfa::TransitionsRow","re_unicode::Regex","re_unicode::CapturesDebug","re_set::bytes::SetMatchesIter","literal::imp::Matcher","re_set::bytes::RegexSet","backtrack::Bounded","dfa::Byte","cache::imp::CachedGuard","compile::SuffixCache","backtrack::Job","compile::Hole","exec::ExecReadOnly","dfa::State","re_bytes::ReplacerRef","re_bytes::NoExpand","sparse::SparseSet","dfa::Cache","pikevm::Fsm","dfa::Fsm","re_bytes::SubCaptureMatches","prog::InstRanges","re_builder::set_unicode::RegexSetBuilder","dfa::Result","re_set::bytes::SetMatchesIntoIter","<*mut T as std::fmt::Debug>","dfa::Transitions","prog::InstBytes","pikevm::Threads","compile::Patch"]},"backtrack::Bounded":{"I":["input::CharInput","input::ByteInput"]},"cache::imp::Cached":{"T":["std::sync::mpmc::Receiver<T>","std::sync::atomic::AtomicPtr<T>","std::collections::linked_list::CursorMut<'_, T>","std::io::IoSliceMut<'a>","std::sys::unix::args::Args","std::task::Waker","std::ptr::NonNull<T>","std::cell::RefCell<T>","std::string::Drain<'_>","std::rc::Weak<T>","std::collections::linked_list::Cursor<'_, T>","std::sync::RwLockReadGuard<'_, T>","std::sync::RwLockWriteGuard<'_, T>","std::ptr::Unique<T>","std::sync::mpsc::Receiver<T>","<*const T as std::marker::Send>","std::sync::mpsc::Sender<T>","std::env::Args","std::io::IoSlice<'a>","std::vec::Drain<'_, T, A>","std::collections::linked_list::Iter<'_, T>","std::future::ResumeTy","std::slice::Iter<'_, T>","std::sync::RwLock<T>","std::rc::Rc<T>","std::slice::IterMut<'_, T>","std::collections::vec_deque::Drain<'_, T, A>","std::collections::LinkedList<T>","std::cell::Cell<T>","std::collections::linked_list::IterMut<'_, T>","std::sync::mpsc::SyncSender<T>","std::vec::IntoIter<T, A>","std::sync::Weak<T>","<*mut T as std::marker::Send>","std::ptr::DynMetadata<Dyn>","std::env::ArgsOs","std::sync::Arc<T>","std::sync::OnceLock<T>","std::sync::MutexGuard<'_, T>","std::sync::mpmc::Sender<T>","std::sync::Mutex<T>","std::thread::JoinHandle<T>","std::boxed::ThinBox<T>","std::io::error::repr_bitpacked::Repr"]},"cache::imp::CachedGuard":{"T":["std::sync::mpmc::Sender<T>","std::collections::linked_list::Cursor<'_, T>","std::thread::JoinHandle<T>","std::vec::Drain<'_, T, A>","std::sync::RwLockWriteGuard<'_, T>","std::io::IoSlice<'a>","std::collections::vec_deque::Drain<'_, T, A>","std::sync::RwLockReadGuard<'_, T>","std::ptr::Unique<T>","std::rc::Weak<T>","std::sys::unix::args::Args","std::task::Waker","std::ptr::DynMetadata<Dyn>","std::io::IoSliceMut<'a>","<&T as std::marker::Send>","std::cell::Cell<T>","std::ptr::NonNull<T>","std::boxed::ThinBox<T>","std::env::ArgsOs","std::collections::LinkedList<T>","std::vec::IntoIter<T, A>","std::sync::mpsc::Receiver<T>","std::io::error::repr_bitpacked::Repr","std::string::Drain<'_>","std::future::ResumeTy","std::collections::linked_list::Iter<'_, T>","std::sync::Mutex<T>","std::collections::linked_list::CursorMut<'_, T>","std::slice::Iter<'_, T>","std::sync::mpsc::Sender<T>","std::collections::linked_list::IterMut<'_, T>","std::sync::MutexGuard<'_, T>","std::slice::IterMut<'_, T>","std::sync::Weak<T>","std::cell::RefCell<T>","std::sync::OnceLock<T>","std::sync::Arc<T>","std::sync::atomic::AtomicPtr<T>","std::rc::Rc<T>","std::sync::mpsc::SyncSender<T>","std::sync::RwLock<T>","std::sync::mpmc::Receiver<T>","std::env::Args"]},"dfa::Result":{"T":["re_trait::Locations","exec::Exec","prog::Inst","expand::Ref","error::Error","dfa::Result","exec::MatchLiteralType","re_builder::RegexOptions","prog::InstSave","re_set::bytes::SetMatchesIter","re_bytes::Regex","re_bytes::SubCaptureMatches","dfa::Byte","re_set::bytes::RegexSet","backtrack::Cache","re_set::unicode::SetMatchesIter","input::ByteInput","re_bytes::NoExpand","prog::EmptyLook","pikevm::Cache","re_unicode::CaptureLocations","input::Char","re_unicode::Match","re_bytes::CaptureLocations","re_unicode::SubCaptureMatches","dfa::State","re_set::unicode::RegexSet","backtrack::Job","compile::SuffixCacheKey","exec::MatchNfaType","pikevm::FollowEpsilon","re_set::unicode::SetMatches","compile::SuffixCacheEntry","re_bytes::CaptureNames","literal::imp::Matcher","dfa::EmptyFlags","re_unicode::Regex","exec::MatchType","expand::CaptureRef","compile::MaybeInst","literal::imp::BoyerMooreSearch","literal::imp::LiteralSearcher","compile::InstHole","re_set::bytes::SetMatches","prog::InstBytes","pikevm::Threads","re_trait::SubCapturesPosIter","literal::imp::SingleByteSet","prog::Program","<&mut T as std::fmt::Debug>","sparse::SparseSet","input::InputAt","input::CharInput","dfa::StateFlags","re_unicode::CaptureNames","re_unicode::NoExpand","re_bytes::Match","prog::InstRanges","prog::InstEmptyLook","prog::InstSplit","dfa::Transitions","prog::InstChar","literal::imp::FreqyPacked"]},"pikevm::Fsm":{"I":["input::CharInput","input::ByteInput"]},"re_trait::CaptureMatches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"re_trait::Matches":{"R":["exec::ExecNoSync","exec::ExecNoSyncStr"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::ReplacerRef<'a, R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::ReplacerRef<'a, R>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append
'a
deps:{"<F as re_unicode::Replacer>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append":{"R":["re_unicode::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_unicode::Replacer>":{"F":["core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue"]},"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append":{"R":["re_unicode::ReplacerRef","re_unicode::NoExpand","<F as re_unicode::Replacer>"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::ReplacerRef<'a, R>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<re_unicode::ReplacerRef<'a, R>>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion
'a
deps:{"<F as re_unicode::Replacer>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion":{"R":["re_unicode::Replacer"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as re_unicode::Replacer>":{"F":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion":{"R":["<F as re_unicode::Replacer>","re_unicode::NoExpand","re_unicode::ReplacerRef"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::ReplacerRef<'a, R>
+p0.no_expansion();
+<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion(p0);
+crate::<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion(p0);
+<re_unicode::ReplacerRef<'a, R>>::no_expansion(p0);
-----------------
src/re_unicode.rs <&'a str as re_unicode::Replacer>::replace_append
'a
deps:{}
candidates:{}
let mut p0 = &mut "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<&'a str as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<&'a str as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<&'a str>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <&'a str as re_unicode::Replacer>::no_expansion
'a
deps:{}
candidates:{}
let mut p0 = &mut "a"; // None+&'a str
+p0.no_expansion();
+<&'a str as re_unicode::Replacer>::no_expansion(p0);
+crate::<&'a str as re_unicode::Replacer>::no_expansion(p0);
+<&'a str>::no_expansion(p0);
-----------------
src/re_unicode.rs <F as re_unicode::Replacer>::replace_append
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<F as re_unicode::Replacer>::replace_append":{"F":["std::ops::FnMut","std::marker::Sized"],"T":["std::convert::AsRef","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<F as re_unicode::Replacer>::replace_append":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"],"T":["std::borrow::Cow<'_, std::ffi::OsStr>","std::sync::Arc<T>","std::slice::Iter<'_, T>","<&T as std::convert::AsRef<U>>","std::slice::IterMut<'_, T>","std::ffi::CString","std::vec::Drain<'a, T, A>","core::num::dec2flt::common::AsciiStr<'a>","std::vec::IntoIter<T, A>","std::rc::Rc<T>","std::borrow::Cow<'_, T>","std::boxed::Box<T, A>","std::ffi::CStr"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // F
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<F as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<F as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<F>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <re_unicode::NoExpand<'t> as std::clone::Clone>::clone
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::NoExpand<'t>
+p0.clone();
+<re_unicode::NoExpand<'t> as std::clone::Clone>::clone(p0);
+crate::<re_unicode::NoExpand<'t> as std::clone::Clone>::clone(p0);
+<re_unicode::NoExpand<'t>>::clone(p0);
-----------------
src/re_unicode.rs <re_unicode::NoExpand<'t> as std::fmt::Debug>::fmt
't
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // re_unicode::NoExpand<'t>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<re_unicode::NoExpand<'t> as std::fmt::Debug>::fmt(p0, p1);
+crate::<re_unicode::NoExpand<'t> as std::fmt::Debug>::fmt(p0, p1);
+<re_unicode::NoExpand<'t>>::fmt(p0, p1);
-----------------
src/re_unicode.rs <re_unicode::NoExpand<'t> as re_unicode::Replacer>::replace_append
't
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::NoExpand<'t>
let mut p1 = & MaybeUninit::uninit().assume_init(); // re_unicode::Captures<'_>
let mut p2 = &mut std::string::String::new(); // None+std::string::String
+p0.replace_append(p1, p2);
+<re_unicode::NoExpand<'t> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+crate::<re_unicode::NoExpand<'t> as re_unicode::Replacer>::replace_append(p0, p1, p2);
+<re_unicode::NoExpand<'t>>::replace_append(p0, p1, p2);
-----------------
src/re_unicode.rs <re_unicode::NoExpand<'t> as re_unicode::Replacer>::no_expansion
't
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // re_unicode::NoExpand<'t>
+p0.no_expansion();
+<re_unicode::NoExpand<'t> as re_unicode::Replacer>::no_expansion(p0);
+crate::<re_unicode::NoExpand<'t> as re_unicode::Replacer>::no_expansion(p0);
+<re_unicode::NoExpand<'t>>::no_expansion(p0);
-----------------
src/sparse.rs <sparse::SparseSet as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.clone();
+<sparse::SparseSet as std::clone::Clone>::clone(p0);
+crate::<sparse::SparseSet as std::clone::Clone>::clone(p0);
+<sparse::SparseSet>::clone(p0);
-----------------
src/sparse.rs sparse::SparseSet::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+sparse::SparseSet::new(p0);
+crate::sparse::SparseSet::new(p0);
+<sparse::SparseSet>::new(p0);
-----------------
src/sparse.rs sparse::SparseSet::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.len();
+sparse::SparseSet::len(p0);
+crate::sparse::SparseSet::len(p0);
+<sparse::SparseSet>::len(p0);
-----------------
src/sparse.rs sparse::SparseSet::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.is_empty();
+sparse::SparseSet::is_empty(p0);
+crate::sparse::SparseSet::is_empty(p0);
+<sparse::SparseSet>::is_empty(p0);
-----------------
src/sparse.rs sparse::SparseSet::capacity
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.capacity();
+sparse::SparseSet::capacity(p0);
+crate::sparse::SparseSet::capacity(p0);
+<sparse::SparseSet>::capacity(p0);
-----------------
src/sparse.rs sparse::SparseSet::insert
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p1 = 0usize; // None+usize
+p0.insert(p1);
+sparse::SparseSet::insert(p0, p1);
+crate::sparse::SparseSet::insert(p0, p1);
+<sparse::SparseSet>::insert(p0, p1);
-----------------
src/sparse.rs sparse::SparseSet::contains
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p1 = 0usize; // None+usize
+p0.contains(p1);
+sparse::SparseSet::contains(p0, p1);
+crate::sparse::SparseSet::contains(p0, p1);
+<sparse::SparseSet>::contains(p0, p1);
-----------------
src/sparse.rs sparse::SparseSet::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.clear();
+sparse::SparseSet::clear(p0);
+crate::sparse::SparseSet::clear(p0);
+<sparse::SparseSet>::clear(p0);
-----------------
src/sparse.rs <sparse::SparseSet as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<sparse::SparseSet as std::fmt::Debug>::fmt(p0, p1);
+crate::<sparse::SparseSet as std::fmt::Debug>::fmt(p0, p1);
+<sparse::SparseSet>::fmt(p0, p1);
-----------------
src/sparse.rs <sparse::SparseSet as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.deref();
+<sparse::SparseSet as std::ops::Deref>::deref(p0);
+crate::<sparse::SparseSet as std::ops::Deref>::deref(p0);
+<sparse::SparseSet>::deref(p0);
-----------------
src/sparse.rs <&'a sparse::SparseSet as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // sparse::SparseSet
+p0.into_iter();
+<&'a sparse::SparseSet as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a sparse::SparseSet as std::iter::IntoIterator>::into_iter(p0);
+<&'a sparse::SparseSet>::into_iter(p0);