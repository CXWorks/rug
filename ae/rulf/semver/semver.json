{"dependencies":{"<version::Identifier as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::Identifier"],"<version::Identifier as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::Identifier"],"<version::Identifier as std::cmp::Ord>::cmp":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::Identifier"],"<version::Identifier as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::Identifier"],"<version::Identifier as std::cmp::PartialOrd>::partial_cmp":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::Identifier"],"<version::Identifier as std::convert::From<semver_parser::version::Identifier>>::from":["alloc::raw_vec::RawVec","semver_parser::version::Identifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::Identifier"],"<version::Identifier as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","version::Identifier"],"<version::Identifier as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","version::Identifier"],"<version::Identifier as std::hash::Hash>::hash":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::Identifier"],"<version::SemVerError as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::SemVerError"],"<version::SemVerError as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::SemVerError"],"<version::SemVerError as std::cmp::PartialOrd>::partial_cmp":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::SemVerError"],"<version::SemVerError as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","version::SemVerError"],"<version::SemVerError as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec","version::SemVerError"],"<version::Version as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"<version::Version as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"<version::Version as std::cmp::Ord>::cmp":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"<version::Version as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"<version::Version as std::cmp::PartialOrd>::partial_cmp":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"<version::Version as std::convert::From<(u64, u64, u64)>>::from":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"<version::Version as std::convert::From<semver_parser::version::Version>>::from":["alloc::raw_vec::RawVec","semver_parser::version::Version","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"<version::Version as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version::Version"],"<version::Version as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version::Version"],"<version::Version as std::hash::Hash>::hash":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"<version::Version as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<version_req::Op as std::clone::Clone>::clone":["version_req::Op"],"<version_req::Op as std::cmp::Eq>::assert_receiver_is_total_eq":["version_req::Op"],"<version_req::Op as std::cmp::Ord>::cmp":["std::cmp::Ordering","version_req::Op"],"<version_req::Op as std::cmp::PartialEq>::eq":["version_req::Op"],"<version_req::Op as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","version_req::Op"],"<version_req::Op as std::convert::From<semver_parser::Op>>::from":["semver_parser::Op","version_req::Op"],"<version_req::Op as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","version_req::Op"],"<version_req::Op as std::fmt::Display>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","version_req::Op"],"<version_req::Op as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","version_req::Op"],"<version_req::Predicate as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Op","version_req::Predicate"],"<version_req::Predicate as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Op","version_req::Predicate"],"<version_req::Predicate as std::cmp::Ord>::cmp":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Op","version_req::Predicate"],"<version_req::Predicate as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Op","version_req::Predicate"],"<version_req::Predicate as std::cmp::PartialOrd>::partial_cmp":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Op","version_req::Predicate"],"<version_req::Predicate as std::convert::From<semver_parser::Comparator>>::from":["alloc::raw_vec::RawVec","semver_parser::Comparator","semver_parser::Op","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Op","version_req::Predicate"],"<version_req::Predicate as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version_req::Op","version_req::Predicate"],"<version_req::Predicate as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version_req::Op","version_req::Predicate"],"<version_req::Predicate as std::hash::Hash>::hash":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Op","version_req::Predicate"],"<version_req::Range as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Range"],"<version_req::Range as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Range"],"<version_req::Range as std::cmp::Ord>::cmp":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Range"],"<version_req::Range as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Range"],"<version_req::Range as std::cmp::PartialOrd>::partial_cmp":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Range"],"<version_req::Range as std::convert::From<semver_parser::Range>>::from":["alloc::raw_vec::RawVec","semver_parser::Compat","semver_parser::Range","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Range"],"<version_req::Range as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version_req::Range"],"<version_req::Range as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version_req::Range"],"<version_req::Range as std::hash::Hash>::hash":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Range"],"<version_req::ReqParseError as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::ReqParseError","version_req::VersionReq"],"<version_req::ReqParseError as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::ReqParseError","version_req::VersionReq"],"<version_req::ReqParseError as std::convert::From<std::string::String>>::from":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version_req::ReqParseError","version_req::VersionReq"],"<version_req::ReqParseError as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version_req::ReqParseError","version_req::VersionReq"],"<version_req::ReqParseError as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version_req::ReqParseError","version_req::VersionReq"],"<version_req::VersionReq as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"<version_req::VersionReq as std::cmp::Eq>::assert_receiver_is_total_eq":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"<version_req::VersionReq as std::cmp::Ord>::cmp":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::cmp::Ordering","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"<version_req::VersionReq as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"<version_req::VersionReq as std::cmp::PartialOrd>::partial_cmp":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"<version_req::VersionReq as std::convert::From<semver_parser::RangeSet>>::from":["alloc::raw_vec::RawVec","semver_parser::Compat","semver_parser::RangeSet","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"<version_req::VersionReq as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version_req::VersionReq"],"<version_req::VersionReq as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::vec::Vec","version_req::VersionReq"],"<version_req::VersionReq as std::hash::Hash>::hash":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::hash::Hasher","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"<version_req::VersionReq as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"version::Identifier":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::Identifier"],"version::SemVerError":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::SemVerError"],"version::Version":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"version::Version::clear_metadata":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"version::Version::increment_major":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"version::Version::increment_minor":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"version::Version::increment_patch":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"version::Version::is_prerelease":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"version::Version::new":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version"],"version::Version::parse":["std::marker::Sized","std::result::Result"],"version_req::<impl std::convert::From<semver_parser::Identifier> for version::Identifier>::from":["alloc::raw_vec::RawVec","semver_parser::Identifier","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec","version::Identifier"],"version_req::Op":["version_req::Op"],"version_req::Predicate":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Op","version_req::Predicate"],"version_req::Predicate::exact":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version","version_req::Op","version_req::Predicate"],"version_req::Predicate::has_exactly_one_match":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Op","version_req::Predicate"],"version_req::Predicate::matches":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version","version_req::Op","version_req::Predicate"],"version_req::Predicate::matches_exact":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version","version_req::Op","version_req::Predicate"],"version_req::Predicate::matches_greater":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version","version_req::Op","version_req::Predicate"],"version_req::Predicate::pre_tag_is_compatible":["alloc::raw_vec::RawVec","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version","version_req::Op","version_req::Predicate"],"version_req::Range":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::Range"],"version_req::Range::matches":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version","version_req::Range"],"version_req::Range::pre_tag_is_compatible":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version","version_req::Range"],"version_req::ReqParseError":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::ReqParseError","version_req::VersionReq"],"version_req::VersionReq":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"version_req::VersionReq::any":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"version_req::VersionReq::exact":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version","version_req::VersionReq"],"version_req::VersionReq::is_exact":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version_req::VersionReq"],"version_req::VersionReq::matches":["alloc::raw_vec::RawVec","semver_parser::Compat","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::vec::Vec","version::Version","version_req::VersionReq"],"version_req::VersionReq::parse":["std::marker::Sized","std::result::Result"],"version_req::VersionReq::parse_compat":["semver_parser::Compat","std::marker::Sized","std::result::Result"],"version_req::VersionReq::parse_deprecated":["std::marker::Sized","std::option::Option"]},"glob_path_import":{},"self_to_fn":{"version::Identifier":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl From<semver_parser::Identifier> for Identifier {\n    fn from(identifier: semver_parser::Identifier) -> Identifier {\n        match identifier {\n            semver_parser::Identifier::Numeric(n) => Identifier::Numeric(n),\n            semver_parser::Identifier::AlphaNumeric(s) => Identifier::AlphaNumeric(s),\n        }\n    }\n}","impl From<semver_parser::version::Identifier> for Identifier {\n    fn from(other: semver_parser::version::Identifier) -> Identifier {\n        match other {\n            semver_parser::version::Identifier::Numeric(n) => Identifier::Numeric(n),\n            semver_parser::version::Identifier::AlphaNumeric(s) => Identifier::AlphaNumeric(s),\n        }\n    }\n}","impl fmt::Display for Identifier {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Identifier::Numeric(ref n) => fmt::Display::fmt(n, f),\n            Identifier::AlphaNumeric(ref s) => fmt::Display::fmt(s, f),\n        }\n    }\n}"],"version::SemVerError":["Clone","Debug","PartialEq","PartialOrd","impl Error for SemVerError {}","impl fmt::Display for SemVerError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            SemVerError::ParseError(ref m) => write!(f, \"{}\", m),\n        }\n    }\n}"],"version::Version":["Clone","Debug","Eq","impl From<(u64, u64, u64)> for Version {\n    fn from(tuple: (u64, u64, u64)) -> Version {\n        let (major, minor, patch) = tuple;\n        Version::new(major, minor, patch)\n    }\n}","impl From<semver_parser::version::Version> for Version {\n    fn from(other: semver_parser::version::Version) -> Version {\n        Version {\n            major: other.major,\n            minor: other.minor,\n            patch: other.patch,\n            pre: other.pre.into_iter().map(From::from).collect(),\n            build: other.build.into_iter().map(From::from).collect(),\n        }\n    }\n}","impl Version {\n    /// Contructs the simple case without pre or build.\n    pub fn new(major: u64, minor: u64, patch: u64) -> Version {\n        Version {\n            major,\n            minor,\n            patch,\n            pre: Vec::new(),\n            build: Vec::new(),\n        }\n    }\n\n    /// Parse a string into a semver object.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error variant if the input could not be parsed as a semver object.\n    ///\n    /// In general, this means that the provided string does not conform to the\n    /// [semver spec][semver].\n    ///\n    /// An error for overflow is returned if any numeric component is larger than what can be\n    /// stored in `u64`.\n    ///\n    /// The following are examples for other common error causes:\n    ///\n    /// * `1.0` - too few numeric components are used. Exactly 3 are expected.\n    /// * `1.0.01` - a numeric component has a leading zero.\n    /// * `1.0.foo` - uses a non-numeric components where one is expected.\n    /// * `1.0.0foo` - metadata is not separated using a legal character like, `+` or `-`.\n    /// * `1.0.0+foo_123` - contains metadata with an illegal character (`_`).\n    ///   Legal characters for metadata include `a-z`, `A-Z`, `0-9`, `-`, and `.` (dot).\n    ///\n    /// [semver]: https://semver.org\n    pub fn parse(version: &str) -> Result<Version> {\n        let res = semver_parser::version::parse(version);\n\n        match res {\n            // Convert plain String error into proper ParseError\n            Err(e) => Err(SemVerError::ParseError(e.to_string())),\n            Ok(v) => Ok(From::from(v)),\n        }\n    }\n\n    /// Clears the build metadata\n    fn clear_metadata(&mut self) {\n        self.build = Vec::new();\n        self.pre = Vec::new();\n    }\n\n    /// Increments the patch number for this Version (Must be mutable)\n    pub fn increment_patch(&mut self) {\n        self.patch += 1;\n        self.clear_metadata();\n    }\n\n    /// Increments the minor version number for this Version (Must be mutable)\n    ///\n    /// As instructed by section 7 of the spec, the patch number is reset to 0.\n    pub fn increment_minor(&mut self) {\n        self.minor += 1;\n        self.patch = 0;\n        self.clear_metadata();\n    }\n\n    /// Increments the major version number for this Version (Must be mutable)\n    ///\n    /// As instructed by section 8 of the spec, the minor and patch numbers are\n    /// reset to 0\n    pub fn increment_major(&mut self) {\n        self.major += 1;\n        self.minor = 0;\n        self.patch = 0;\n        self.clear_metadata();\n    }\n\n    /// Checks to see if the current Version is in pre-release status\n    pub fn is_prerelease(&self) -> bool {\n        !self.pre.is_empty()\n    }\n}","impl cmp::Ord for Version {\n    fn cmp(&self, other: &Version) -> Ordering {\n        match self.major.cmp(&other.major) {\n            Ordering::Equal => {}\n            r => return r,\n        }\n\n        match self.minor.cmp(&other.minor) {\n            Ordering::Equal => {}\n            r => return r,\n        }\n\n        match self.patch.cmp(&other.patch) {\n            Ordering::Equal => {}\n            r => return r,\n        }\n\n        // NB: semver spec says 0.0.0-pre < 0.0.0\n        // but the version of ord defined for vec\n        // says that [] < [pre] so we alter it here\n        match (self.pre.len(), other.pre.len()) {\n            (0, 0) => Ordering::Equal,\n            (0, _) => Ordering::Greater,\n            (_, 0) => Ordering::Less,\n            (_, _) => self.pre.cmp(&other.pre),\n        }\n    }\n}","impl cmp::PartialEq for Version {\n    #[inline]\n    fn eq(&self, other: &Version) -> bool {\n        // We should ignore build metadata here, otherwise versions v1 and v2\n        // can exist such that !(v1 < v2) && !(v1 > v2) && v1 != v2, which\n        // violate strict total ordering rules.\n        self.major == other.major\n            && self.minor == other.minor\n            && self.patch == other.patch\n            && self.pre == other.pre\n    }\n}","impl cmp::PartialOrd for Version {\n    fn partial_cmp(&self, other: &Version) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl fmt::Display for Version {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut result = format!(\"{}.{}.{}\", self.major, self.minor, self.patch);\n\n        if !self.pre.is_empty() {\n            result.push_str(\"-\");\n            for (i, x) in self.pre.iter().enumerate() {\n                if i != 0 {\n                    result.push_str(\".\");\n                }\n                result.push_str(format!(\"{}\", x).as_ref());\n            }\n        }\n        if !self.build.is_empty() {\n            result.push_str(\"+\");\n            for (i, x) in self.build.iter().enumerate() {\n                if i != 0 {\n                    result.push_str(\".\");\n                }\n                result.push_str(format!(\"{}\", x).as_ref());\n            }\n        }\n\n        f.pad(result.as_ref())?;\n        Ok(())\n    }\n}","impl hash::Hash for Version {\n    fn hash<H: hash::Hasher>(&self, into: &mut H) {\n        self.major.hash(into);\n        self.minor.hash(into);\n        self.patch.hash(into);\n        self.pre.hash(into);\n    }\n}","impl str::FromStr for Version {\n    type Err = SemVerError;\n\n    fn from_str(s: &str) -> Result<Version> {\n        Version::parse(s)\n    }\n}"],"version_req::Op":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl From<semver_parser::Op> for Op {\n    fn from(op: semver_parser::Op) -> Op {\n        match op {\n            semver_parser::Op::Eq => Op::Ex,\n            semver_parser::Op::Gt => Op::Gt,\n            semver_parser::Op::Gte => Op::GtEq,\n            semver_parser::Op::Lt => Op::Lt,\n            semver_parser::Op::Lte => Op::LtEq,\n        }\n    }\n}","impl fmt::Display for Op {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Ex => write!(fmt, \"=\")?,\n            Gt => write!(fmt, \">\")?,\n            GtEq => write!(fmt, \">=\")?,\n            Lt => write!(fmt, \"<\")?,\n            LtEq => write!(fmt, \"<=\")?,\n        }\n        Ok(())\n    }\n}"],"version_req::Predicate":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl From<semver_parser::Comparator> for Predicate {\n    fn from(comparator: semver_parser::Comparator) -> Predicate {\n        Predicate {\n            op: From::from(comparator.op),\n            major: comparator.major,\n            minor: comparator.minor,\n            patch: comparator.patch,\n            pre: comparator.pre.into_iter().map(From::from).collect(),\n        }\n    }\n}","impl Predicate {\n    fn exact(version: &Version) -> Predicate {\n        Predicate {\n            op: Ex,\n            major: version.major,\n            minor: version.minor,\n            patch: version.patch,\n            pre: version.pre.clone(),\n        }\n    }\n\n    /// `matches()` takes a `Version` and determines if it matches this particular `Predicate`.\n    pub fn matches(&self, ver: &Version) -> bool {\n        match self.op {\n            Ex => self.matches_exact(ver),\n            Gt => self.matches_greater(ver),\n            GtEq => self.matches_exact(ver) || self.matches_greater(ver),\n            Lt => !self.matches_exact(ver) && !self.matches_greater(ver),\n            LtEq => !self.matches_greater(ver),\n        }\n    }\n\n    fn matches_exact(&self, ver: &Version) -> bool {\n        self.major == ver.major\n            && self.minor == ver.minor\n            && self.patch == ver.patch\n            && self.pre == ver.pre\n    }\n\n    // https://docs.npmjs.com/misc/semver#prerelease-tags\n    fn pre_tag_is_compatible(&self, ver: &Version) -> bool {\n        // If a version has a prerelease tag (for example, 1.2.3-alpha.3) then it will\n        // only be\n        // allowed to satisfy comparator sets if at least one comparator with the same\n        // [major,\n        // minor, patch] tuple also has a prerelease tag.\n        !ver.is_prerelease()\n            || (self.major == ver.major\n                && self.minor == ver.minor\n                && self.patch == ver.patch\n                && !self.pre.is_empty())\n    }\n\n    fn matches_greater(&self, ver: &Version) -> bool {\n        if self.major != ver.major {\n            return ver.major > self.major;\n        }\n\n        if self.minor != ver.minor {\n            return ver.minor > self.minor;\n        }\n\n        if self.patch != ver.patch {\n            return ver.patch > self.patch;\n        }\n\n        if !self.pre.is_empty() {\n            return ver.pre.is_empty() || ver.pre > self.pre;\n        }\n\n        false\n    }\n\n    fn has_exactly_one_match(&self) -> bool {\n        self.op == Ex\n    }\n}","impl fmt::Display for Predicate {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            fmt,\n            \"{}{}.{}.{}\",\n            self.op, self.major, self.minor, self.patch\n        )?;\n\n        if !self.pre.is_empty() {\n            write!(fmt, \"-\")?;\n            for (i, x) in self.pre.iter().enumerate() {\n                if i != 0 {\n                    write!(fmt, \".\")?\n                }\n                write!(fmt, \"{}\", x)?;\n            }\n        }\n\n        Ok(())\n    }\n}"],"version_req::Range":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl From<semver_parser::Range> for Range {\n    fn from(range: semver_parser::Range) -> Range {\n        Range {\n            predicates: range.comparator_set.into_iter().map(From::from).collect(),\n            compat: range.compat,\n        }\n    }\n}","impl Range {\n    fn matches(&self, ver: &Version) -> bool {\n        self.predicates.iter().all(|p| p.matches(ver))\n    }\n\n    fn pre_tag_is_compatible(&self, ver: &Version) -> bool {\n        self.predicates.iter().any(|p| p.pre_tag_is_compatible(ver))\n    }\n}","impl fmt::Display for Range {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        for (i, ref pred) in self.predicates.iter().enumerate() {\n            if i == 0 {\n                write!(fmt, \"{}\", pred)?;\n            } else if self.compat == Compat::Npm {\n                // Node does not expect commas between predicates\n                write!(fmt, \" {}\", pred)?;\n            } else {\n                write!(fmt, \", {}\", pred)?;\n            }\n        }\n        Ok(())\n    }\n}"],"version_req::ReqParseError":["Clone","Debug","PartialEq","impl Error for ReqParseError {}","impl From<String> for ReqParseError {\n    fn from(other: String) -> ReqParseError {\n        match &*other {\n            \"Null is not a valid VersionReq\" => ReqParseError::InvalidVersionRequirement,\n            \"VersionReq did not parse properly.\" => ReqParseError::OpAlreadySet,\n            _ => ReqParseError::InvalidVersionRequirement,\n        }\n    }\n}","impl fmt::Display for ReqParseError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let msg = match self {\n            InvalidVersionRequirement => \"the given version requirement is invalid\",\n            OpAlreadySet => {\n                \"you have already provided an operation, such as =, ~, or ^; only use one\"\n            }\n            InvalidSigil => \"the sigil you have written is not correct\",\n            VersionComponentsMustBeNumeric => \"version components must be numeric\",\n            InvalidIdentifier => \"invalid identifier\",\n            MajorVersionRequired => \"at least a major version number is required\",\n            UnimplementedVersionRequirement => {\n                \"the given version requirement is not implemented, yet\"\n            }\n            DeprecatedVersionRequirement(_) => \"This requirement is deprecated\",\n        };\n        msg.fmt(f)\n    }\n}"],"version_req::VersionReq":["Clone","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl From<semver_parser::RangeSet> for VersionReq {\n    fn from(range_set: semver_parser::RangeSet) -> VersionReq {\n        VersionReq {\n            ranges: range_set.ranges.into_iter().map(From::from).collect(),\n            compat: range_set.compat,\n        }\n    }\n}","impl VersionReq {\n    /// `any()` is a factory method which creates a `VersionReq` with no constraints. In other\n    /// words, any version will match against it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use semver::VersionReq;\n    ///\n    /// let anything = VersionReq::any();\n    /// ```\n    pub fn any() -> VersionReq {\n        VersionReq {\n            ranges: vec![],\n            compat: Compat::Cargo,\n        }\n    }\n\n    /// `parse()` is the main constructor of a `VersionReq`. It takes a string like `\"^1.2.3\"`\n    /// and turns it into a `VersionReq` that matches that particular constraint.\n    ///\n    /// A `Result` is returned which contains a [`ReqParseError`] if there was a problem parsing the\n    /// `VersionReq`.\n    /// [`ReqParseError`]: enum.ReqParseError.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use semver::VersionReq;\n    ///\n    /// let version = VersionReq::parse(\"=1.2.3\");\n    /// let version = VersionReq::parse(\">1.2.3\");\n    /// let version = VersionReq::parse(\"<1.2.3\");\n    /// let version = VersionReq::parse(\"~1.2.3\");\n    /// let version = VersionReq::parse(\"^1.2.3\");\n    /// let version = VersionReq::parse(\"1.2.3\"); // synonym for ^1.2.3\n    /// let version = VersionReq::parse(\"<=1.2.3\");\n    /// let version = VersionReq::parse(\">=1.2.3\");\n    /// ```\n    ///\n    /// This example demonstrates error handling, and will panic.\n    ///\n    /// ```should_panic\n    /// use semver::VersionReq;\n    ///\n    /// let version = match VersionReq::parse(\"not a version\") {\n    ///     Ok(version) => version,\n    ///     Err(e) => panic!(\"There was a problem parsing: {}\", e),\n    /// };\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// Returns an error variant if the input could not be parsed as a semver requirement.\n    ///\n    /// Examples of common error causes are as follows:\n    ///\n    /// * `\\0` - an invalid version requirement is used.\n    /// * `>= >= 1.2.3` - multiple operations are used. Only use one.\n    /// * `>== 1.2.3` - an invalid operation is used.\n    /// * `a.0.0` - version components are not numeric.\n    /// * `1.2.3-` - an invalid identifier is present.\n    /// * `>=` - major version was not specified. At least a major version is required.\n    /// * `0.2*` - deprecated requirement syntax. Equivalent would be `0.2.*`.\n    ///\n    /// You may also encounter an `UnimplementedVersionRequirement` error, which indicates that a\n    /// given requirement syntax is not yet implemented in this crate.\n    pub fn parse(input: &str) -> Result<VersionReq, ReqParseError> {\n        let range_set = input.parse::<RangeSet>();\n\n        if let Ok(v) = range_set {\n            return Ok(From::from(v));\n        }\n\n        match VersionReq::parse_deprecated(input) {\n            Some(v) => Err(ReqParseError::DeprecatedVersionRequirement(v)),\n            None => Err(From::from(range_set.err().unwrap())),\n        }\n    }\n\n    // TODO: better docs for this\n    /// `parse_compat()` is like `parse()`, but it takes an extra argument for compatibility with\n    /// other semver implementations, and turns that into a `VersionReq` that matches the\n    /// particular constraint and compatibility.\n    ///\n    /// A `Result` is returned which contains a [`ReqParseError`] if there was a problem parsing the\n    /// `VersionReq`.\n    /// [`ReqParseError`]: enum.ReqParseError.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// extern crate semver_parser;\n    /// use semver::VersionReq;\n    /// use semver_parser::Compat;\n    ///\n    /// # fn main() {\n    ///     let cargo_version = VersionReq::parse_compat(\"1.2.3\", Compat::Cargo);\n    ///     let npm_version = VersionReq::parse_compat(\"1.2.3\", Compat::Npm);\n    /// # }\n    /// ```\n    pub fn parse_compat(input: &str, compat: Compat) -> Result<VersionReq, ReqParseError> {\n        let range_set = RangeSet::parse(input, compat);\n\n        if let Ok(v) = range_set {\n            return Ok(From::from(v));\n        }\n\n        match VersionReq::parse_deprecated(input) {\n            Some(v) => Err(ReqParseError::DeprecatedVersionRequirement(v)),\n            None => Err(From::from(range_set.err().unwrap())),\n        }\n    }\n\n    fn parse_deprecated(version: &str) -> Option<VersionReq> {\n        match version {\n            \".*\" => Some(VersionReq::any()),\n            \"0.1.0.\" => Some(VersionReq::parse(\"0.1.0\").unwrap()),\n            \"0.3.1.3\" => Some(VersionReq::parse(\"0.3.13\").unwrap()),\n            \"0.2*\" => Some(VersionReq::parse(\"0.2.*\").unwrap()),\n            \"*.0\" => Some(VersionReq::any()),\n            _ => None,\n        }\n    }\n\n    /// `exact()` is a factory method which creates a `VersionReq` with one exact constraint.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use semver::VersionReq;\n    /// use semver::Version;\n    ///\n    /// let version = Version { major: 1, minor: 1, patch: 1, pre: vec![], build: vec![] };\n    /// let exact = VersionReq::exact(&version);\n    /// ```\n    pub fn exact(version: &Version) -> VersionReq {\n        VersionReq {\n            ranges: vec![Range {\n                predicates: vec![Predicate::exact(version)],\n                compat: Compat::Cargo,\n            }],\n            compat: Compat::Cargo,\n        }\n    }\n\n    /// `matches()` matches a given [`Version`] against this `VersionReq`.\n    /// [`Version`]: struct.Version.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use semver::VersionReq;\n    /// use semver::Version;\n    ///\n    /// let version = Version { major: 1, minor: 1, patch: 1, pre: vec![], build: vec![] };\n    /// let exact = VersionReq::exact(&version);\n    ///\n    /// assert!(exact.matches(&version));\n    /// ```\n    pub fn matches(&self, version: &Version) -> bool {\n        // no ranges means anything matches\n        if self.ranges.is_empty() {\n            return true;\n        }\n\n        self.ranges\n            .iter()\n            .any(|r| r.matches(version) && r.pre_tag_is_compatible(version))\n    }\n\n    /// `is_exact()` returns `true` if there is exactly one version which could match this\n    /// `VersionReq`. If `false` is returned, it is possible that there may still only be exactly\n    /// one version which could match this `VersionReq`. This function is intended do allow\n    /// short-circuiting more complex logic where being able to handle only the possibility of a\n    /// single exact version may be cheaper.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use semver::ReqParseError;\n    /// use semver::VersionReq;\n    ///\n    /// fn use_is_exact() -> Result<(), ReqParseError> {\n    ///   assert!(VersionReq::parse(\"=1.0.0\")?.is_exact());\n    ///   assert!(!VersionReq::parse(\"=1.0\")?.is_exact());\n    ///   assert!(!VersionReq::parse(\">=1.0.0\")?.is_exact());\n    ///   Ok(())\n    /// }\n    ///\n    /// use_is_exact().unwrap();\n    /// ```\n    pub fn is_exact(&self) -> bool {\n        if let [range] = self.ranges.as_slice() {\n            if let [predicate] = range.predicates.as_slice() {\n                return predicate.has_exactly_one_match();\n            }\n        }\n\n        false\n    }\n}","impl fmt::Display for VersionReq {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        if self.ranges.is_empty() {\n            write!(fmt, \"*\")?;\n        } else {\n            for (i, ref pred) in self.ranges.iter().enumerate() {\n                if i == 0 {\n                    write!(fmt, \"{}\", pred)?;\n                } else {\n                    write!(fmt, \" || {}\", pred)?;\n                }\n            }\n        }\n\n        Ok(())\n    }\n}","impl str::FromStr for VersionReq {\n    type Err = ReqParseError;\n\n    fn from_str(s: &str) -> Result<VersionReq, ReqParseError> {\n        VersionReq::parse(s)\n    }\n}"]},"single_path_import":{"semver_parser::Compat":"Compat","version::Identifier":"Identifier","version::Identifier::AlphaNumeric":"AlphaNumeric","version::Identifier::Numeric":"Numeric","version::SemVerError":"SemVerError","version::Version":"Version","version_req::ReqParseError":"ReqParseError","version_req::VersionReq":"VersionReq"},"srcs":{"<version::Identifier as std::convert::From<semver_parser::version::Identifier>>::from":["fn from(other: semver_parser::version::Identifier) -> Identifier{\n        match other {\n            semver_parser::version::Identifier::Numeric(n) => Identifier::Numeric(n),\n            semver_parser::version::Identifier::AlphaNumeric(s) => Identifier::AlphaNumeric(s),\n        }\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Identifier as std::fmt::Display>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {\n            Identifier::Numeric(ref n) => fmt::Display::fmt(n, f),\n            Identifier::AlphaNumeric(ref s) => fmt::Display::fmt(s, f),\n        }\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::SemVerError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            SemVerError::ParseError(ref m) => write!(f, \"{}\", m),\n        }\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Version) -> Ordering{\n        match self.major.cmp(&other.major) {\n            Ordering::Equal => {}\n            r => return r,\n        }\n\n        match self.minor.cmp(&other.minor) {\n            Ordering::Equal => {}\n            r => return r,\n        }\n\n        match self.patch.cmp(&other.patch) {\n            Ordering::Equal => {}\n            r => return r,\n        }\n\n        // NB: semver spec says 0.0.0-pre < 0.0.0\n        // but the version of ord defined for vec\n        // says that [] < [pre] so we alter it here\n        match (self.pre.len(), other.pre.len()) {\n            (0, 0) => Ordering::Equal,\n            (0, _) => Ordering::Greater,\n            (_, 0) => Ordering::Less,\n            (_, _) => self.pre.cmp(&other.pre),\n        }\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &Version) -> bool{\n        // We should ignore build metadata here, otherwise versions v1 and v2\n        // can exist such that !(v1 < v2) && !(v1 > v2) && v1 != v2, which\n        // violate strict total ordering rules.\n        self.major == other.major\n            && self.minor == other.minor\n            && self.patch == other.patch\n            && self.pre == other.pre\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Version) -> Option<Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::convert::From<(u64, u64, u64)>>::from":["fn from(tuple: (u64, u64, u64)) -> Version{\n        let (major, minor, patch) = tuple;\n        Version::new(major, minor, patch)\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::convert::From<semver_parser::version::Version>>::from":["fn from(other: semver_parser::version::Version) -> Version{\n        Version {\n            major: other.major,\n            minor: other.minor,\n            patch: other.patch,\n            pre: other.pre.into_iter().map(From::from).collect(),\n            build: other.build.into_iter().map(From::from).collect(),\n        }\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::fmt::Display>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let mut result = format!(\"{}.{}.{}\", self.major, self.minor, self.patch);\n\n        if !self.pre.is_empty() {\n            result.push_str(\"-\");\n            for (i, x) in self.pre.iter().enumerate() {\n                if i != 0 {\n                    result.push_str(\".\");\n                }\n                result.push_str(format!(\"{}\", x).as_ref());\n            }\n        }\n        if !self.build.is_empty() {\n            result.push_str(\"+\");\n            for (i, x) in self.build.iter().enumerate() {\n                if i != 0 {\n                    result.push_str(\".\");\n                }\n                result.push_str(format!(\"{}\", x).as_ref());\n            }\n        }\n\n        f.pad(result.as_ref())?;\n        Ok(())\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::hash::Hash>::hash":["fn hash<H: hash::Hasher>(&self, into: &mut H){\n        self.major.hash(into);\n        self.minor.hash(into);\n        self.patch.hash(into);\n        self.pre.hash(into);\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version::Version as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Version>{\n        Version::parse(s)\n    }","Real(LocalPath(\"src/version.rs\"))"],"<version_req::Op as std::convert::From<semver_parser::Op>>::from":["fn from(op: semver_parser::Op) -> Op{\n        match op {\n            semver_parser::Op::Eq => Op::Ex,\n            semver_parser::Op::Gt => Op::Gt,\n            semver_parser::Op::Gte => Op::GtEq,\n            semver_parser::Op::Lt => Op::Lt,\n            semver_parser::Op::Lte => Op::LtEq,\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::Op as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        match *self {\n            Ex => write!(fmt, \"=\")?,\n            Gt => write!(fmt, \">\")?,\n            GtEq => write!(fmt, \">=\")?,\n            Lt => write!(fmt, \"<\")?,\n            LtEq => write!(fmt, \"<=\")?,\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::Predicate as std::convert::From<semver_parser::Comparator>>::from":["fn from(comparator: semver_parser::Comparator) -> Predicate{\n        Predicate {\n            op: From::from(comparator.op),\n            major: comparator.major,\n            minor: comparator.minor,\n            patch: comparator.patch,\n            pre: comparator.pre.into_iter().map(From::from).collect(),\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::Predicate as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            fmt,\n            \"{}{}.{}.{}\",\n            self.op, self.major, self.minor, self.patch\n        )?;\n\n        if !self.pre.is_empty() {\n            write!(fmt, \"-\")?;\n            for (i, x) in self.pre.iter().enumerate() {\n                if i != 0 {\n                    write!(fmt, \".\")?\n                }\n                write!(fmt, \"{}\", x)?;\n            }\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::Range as std::convert::From<semver_parser::Range>>::from":["fn from(range: semver_parser::Range) -> Range{\n        Range {\n            predicates: range.comparator_set.into_iter().map(From::from).collect(),\n            compat: range.compat,\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::Range as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        for (i, ref pred) in self.predicates.iter().enumerate() {\n            if i == 0 {\n                write!(fmt, \"{}\", pred)?;\n            } else if self.compat == Compat::Npm {\n                // Node does not expect commas between predicates\n                write!(fmt, \" {}\", pred)?;\n            } else {\n                write!(fmt, \", {}\", pred)?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::ReqParseError as std::convert::From<std::string::String>>::from":["fn from(other: String) -> ReqParseError{\n        match &*other {\n            \"Null is not a valid VersionReq\" => ReqParseError::InvalidVersionRequirement,\n            \"VersionReq did not parse properly.\" => ReqParseError::OpAlreadySet,\n            _ => ReqParseError::InvalidVersionRequirement,\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::ReqParseError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let msg = match self {\n            InvalidVersionRequirement => \"the given version requirement is invalid\",\n            OpAlreadySet => {\n                \"you have already provided an operation, such as =, ~, or ^; only use one\"\n            }\n            InvalidSigil => \"the sigil you have written is not correct\",\n            VersionComponentsMustBeNumeric => \"version components must be numeric\",\n            InvalidIdentifier => \"invalid identifier\",\n            MajorVersionRequired => \"at least a major version number is required\",\n            UnimplementedVersionRequirement => {\n                \"the given version requirement is not implemented, yet\"\n            }\n            DeprecatedVersionRequirement(_) => \"This requirement is deprecated\",\n        };\n        msg.fmt(f)\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::VersionReq as std::convert::From<semver_parser::RangeSet>>::from":["fn from(range_set: semver_parser::RangeSet) -> VersionReq{\n        VersionReq {\n            ranges: range_set.ranges.into_iter().map(From::from).collect(),\n            compat: range_set.compat,\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::VersionReq as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        if self.ranges.is_empty() {\n            write!(fmt, \"*\")?;\n        } else {\n            for (i, ref pred) in self.ranges.iter().enumerate() {\n                if i == 0 {\n                    write!(fmt, \"{}\", pred)?;\n                } else {\n                    write!(fmt, \" || {}\", pred)?;\n                }\n            }\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"<version_req::VersionReq as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<VersionReq, ReqParseError>{\n        VersionReq::parse(s)\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version::Identifier":["/// An identifier in the pre-release or build metadata.\n///\n/// See sections 9 and 10 of the spec for more about pre-release identifers and\n/// build metadata.\npub enum Identifier {\n    /// An identifier that's solely numbers.\n    Numeric(u64),\n    /// An identifier with letters and numbers.\n    AlphaNumeric(String),\n}","Real(LocalPath(\"src/version.rs\"))"],"version::SemVerError":["/// An error type for this crate\n///\n/// Currently, just a generic error. Will make this nicer later.\npub enum SemVerError {\n    /// An error ocurred while parsing.\n    ParseError(String),\n}","Real(LocalPath(\"src/version.rs\"))"],"version::Version":["/// Represents a version number conforming to the semantic versioning scheme.\npub struct Version {\n    /// The major version, to be incremented on incompatible changes.\n    pub major: u64,\n    /// The minor version, to be incremented when functionality is added in a\n    /// backwards-compatible manner.\n    pub minor: u64,\n    /// The patch version, to be incremented when backwards-compatible bug\n    /// fixes are made.\n    pub patch: u64,\n    /// The pre-release version identifier, if one exists.\n    pub pre: Vec<Identifier>,\n    /// The build metadata, ignored when determining version precedence.\n    pub build: Vec<Identifier>,\n}","Real(LocalPath(\"src/version.rs\"))"],"version::Version::clear_metadata":["/// Clears the build metadata\nfn clear_metadata(&mut self){\n        self.build = Vec::new();\n        self.pre = Vec::new();\n    }","Real(LocalPath(\"src/version.rs\"))"],"version::Version::increment_major":["/// Increments the major version number for this Version (Must be mutable)\n///\n/// As instructed by section 8 of the spec, the minor and patch numbers are\n/// reset to 0\npub fn increment_major(&mut self){\n        self.major += 1;\n        self.minor = 0;\n        self.patch = 0;\n        self.clear_metadata();\n    }","Real(LocalPath(\"src/version.rs\"))"],"version::Version::increment_minor":["/// Increments the minor version number for this Version (Must be mutable)\n///\n/// As instructed by section 7 of the spec, the patch number is reset to 0.\npub fn increment_minor(&mut self){\n        self.minor += 1;\n        self.patch = 0;\n        self.clear_metadata();\n    }","Real(LocalPath(\"src/version.rs\"))"],"version::Version::increment_patch":["/// Increments the patch number for this Version (Must be mutable)\npub fn increment_patch(&mut self){\n        self.patch += 1;\n        self.clear_metadata();\n    }","Real(LocalPath(\"src/version.rs\"))"],"version::Version::is_prerelease":["/// Checks to see if the current Version is in pre-release status\npub fn is_prerelease(&self) -> bool{\n        !self.pre.is_empty()\n    }","Real(LocalPath(\"src/version.rs\"))"],"version::Version::new":["/// Contructs the simple case without pre or build.\npub fn new(major: u64, minor: u64, patch: u64) -> Version{\n        Version {\n            major,\n            minor,\n            patch,\n            pre: Vec::new(),\n            build: Vec::new(),\n        }\n    }","Real(LocalPath(\"src/version.rs\"))"],"version::Version::parse":["/// Parse a string into a semver object.\n///\n/// # Errors\n///\n/// Returns an error variant if the input could not be parsed as a semver object.\n///\n/// In general, this means that the provided string does not conform to the\n/// [semver spec][semver].\n///\n/// An error for overflow is returned if any numeric component is larger than what can be\n/// stored in `u64`.\n///\n/// The following are examples for other common error causes:\n///\n/// * `1.0` - too few numeric components are used. Exactly 3 are expected.\n/// * `1.0.01` - a numeric component has a leading zero.\n/// * `1.0.foo` - uses a non-numeric components where one is expected.\n/// * `1.0.0foo` - metadata is not separated using a legal character like, `+` or `-`.\n/// * `1.0.0+foo_123` - contains metadata with an illegal character (`_`).\n///   Legal characters for metadata include `a-z`, `A-Z`, `0-9`, `-`, and `.` (dot).\n///\n/// [semver]: https://semver.org\npub fn parse(version: &str) -> Result<Version>{\n        let res = semver_parser::version::parse(version);\n\n        match res {\n            // Convert plain String error into proper ParseError\n            Err(e) => Err(SemVerError::ParseError(e.to_string())),\n            Ok(v) => Ok(From::from(v)),\n        }\n    }","Real(LocalPath(\"src/version.rs\"))"],"version_req::<impl std::convert::From<semver_parser::Identifier> for version::Identifier>::from":["fn from(identifier: semver_parser::Identifier) -> Identifier{\n        match identifier {\n            semver_parser::Identifier::Numeric(n) => Identifier::Numeric(n),\n            semver_parser::Identifier::AlphaNumeric(s) => Identifier::AlphaNumeric(s),\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Op":["enum Op {\n    Ex,   // Exact\n    Gt,   // Greater than\n    GtEq, // Greater than or equal to\n    Lt,   // Less than\n    LtEq, // Less than or equal to\n}","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Predicate":["struct Predicate {\n    op: Op,\n    major: u64,\n    minor: u64,\n    patch: u64,\n    pre: Vec<Identifier>,\n}","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Predicate::exact":["fn exact(version: &Version) -> Predicate{\n        Predicate {\n            op: Ex,\n            major: version.major,\n            minor: version.minor,\n            patch: version.patch,\n            pre: version.pre.clone(),\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Predicate::has_exactly_one_match":["fn has_exactly_one_match(&self) -> bool{\n        self.op == Ex\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Predicate::matches":["/// `matches()` takes a `Version` and determines if it matches this particular `Predicate`.\npub fn matches(&self, ver: &Version) -> bool{\n        match self.op {\n            Ex => self.matches_exact(ver),\n            Gt => self.matches_greater(ver),\n            GtEq => self.matches_exact(ver) || self.matches_greater(ver),\n            Lt => !self.matches_exact(ver) && !self.matches_greater(ver),\n            LtEq => !self.matches_greater(ver),\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Predicate::matches_exact":["fn matches_exact(&self, ver: &Version) -> bool{\n        self.major == ver.major\n            && self.minor == ver.minor\n            && self.patch == ver.patch\n            && self.pre == ver.pre\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Predicate::matches_greater":["fn matches_greater(&self, ver: &Version) -> bool{\n        if self.major != ver.major {\n            return ver.major > self.major;\n        }\n\n        if self.minor != ver.minor {\n            return ver.minor > self.minor;\n        }\n\n        if self.patch != ver.patch {\n            return ver.patch > self.patch;\n        }\n\n        if !self.pre.is_empty() {\n            return ver.pre.is_empty() || ver.pre > self.pre;\n        }\n\n        false\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Predicate::pre_tag_is_compatible":["fn pre_tag_is_compatible(&self, ver: &Version) -> bool{\n        // If a version has a prerelease tag (for example, 1.2.3-alpha.3) then it will\n        // only be\n        // allowed to satisfy comparator sets if at least one comparator with the same\n        // [major,\n        // minor, patch] tuple also has a prerelease tag.\n        !ver.is_prerelease()\n            || (self.major == ver.major\n                && self.minor == ver.minor\n                && self.patch == ver.patch\n                && !self.pre.is_empty())\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Range":["struct Range {\n    predicates: Vec<Predicate>,\n    compat: Compat,\n}","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Range::matches":["fn matches(&self, ver: &Version) -> bool{\n        self.predicates.iter().all(|p| p.matches(ver))\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::Range::pre_tag_is_compatible":["fn pre_tag_is_compatible(&self, ver: &Version) -> bool{\n        self.predicates.iter().any(|p| p.pre_tag_is_compatible(ver))\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::ReqParseError":["/// A `ReqParseError` is returned from methods which parse a string into a [`VersionReq`]. Each\n/// enumeration is one of the possible errors that can occur.\n/// [`VersionReq`]: struct.VersionReq.html\npub enum ReqParseError {\n    /// The given version requirement is invalid.\n    InvalidVersionRequirement,\n    /// You have already provided an operation, such as `=`, `~`, or `^`. Only use one.\n    OpAlreadySet,\n    /// The sigil you have written is not correct.\n    InvalidSigil,\n    /// All components of a version must be numeric.\n    VersionComponentsMustBeNumeric,\n    /// There was an error parsing an identifier.\n    InvalidIdentifier,\n    /// At least a major version is required.\n    MajorVersionRequired,\n    /// An unimplemented version requirement.\n    UnimplementedVersionRequirement,\n    /// This form of requirement is deprecated.\n    DeprecatedVersionRequirement(VersionReq),\n}","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::VersionReq":["/// A `VersionReq` is a struct containing a list of ranges that can apply to ranges of version\n/// numbers. Matching operations can then be done with the `VersionReq` against a particular\n/// version to see if it satisfies some or all of the constraints.\npub struct VersionReq {\n    ranges: Vec<Range>,\n    compat: Compat, // defaults to Cargo\n}","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::VersionReq::any":["/// `any()` is a factory method which creates a `VersionReq` with no constraints. In other\n/// words, any version will match against it.\n///\n/// # Examples\n///\n/// ```\n/// use semver::VersionReq;\n///\n/// let anything = VersionReq::any();\n/// ```\npub fn any() -> VersionReq{\n        VersionReq {\n            ranges: vec![],\n            compat: Compat::Cargo,\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::VersionReq::exact":["/// `exact()` is a factory method which creates a `VersionReq` with one exact constraint.\n///\n/// # Examples\n///\n/// ```\n/// use semver::VersionReq;\n/// use semver::Version;\n///\n/// let version = Version { major: 1, minor: 1, patch: 1, pre: vec![], build: vec![] };\n/// let exact = VersionReq::exact(&version);\n/// ```\npub fn exact(version: &Version) -> VersionReq{\n        VersionReq {\n            ranges: vec![Range {\n                predicates: vec![Predicate::exact(version)],\n                compat: Compat::Cargo,\n            }],\n            compat: Compat::Cargo,\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::VersionReq::is_exact":["/// `is_exact()` returns `true` if there is exactly one version which could match this\n/// `VersionReq`. If `false` is returned, it is possible that there may still only be exactly\n/// one version which could match this `VersionReq`. This function is intended do allow\n/// short-circuiting more complex logic where being able to handle only the possibility of a\n/// single exact version may be cheaper.\n///\n/// # Examples\n///\n/// ```\n/// use semver::ReqParseError;\n/// use semver::VersionReq;\n///\n/// fn use_is_exact() -> Result<(), ReqParseError> {\n///   assert!(VersionReq::parse(\"=1.0.0\")?.is_exact());\n///   assert!(!VersionReq::parse(\"=1.0\")?.is_exact());\n///   assert!(!VersionReq::parse(\">=1.0.0\")?.is_exact());\n///   Ok(())\n/// }\n///\n/// use_is_exact().unwrap();\n/// ```\npub fn is_exact(&self) -> bool{\n        if let [range] = self.ranges.as_slice() {\n            if let [predicate] = range.predicates.as_slice() {\n                return predicate.has_exactly_one_match();\n            }\n        }\n\n        false\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::VersionReq::matches":["/// `matches()` matches a given [`Version`] against this `VersionReq`.\n/// [`Version`]: struct.Version.html\n///\n/// # Examples\n///\n/// ```\n/// use semver::VersionReq;\n/// use semver::Version;\n///\n/// let version = Version { major: 1, minor: 1, patch: 1, pre: vec![], build: vec![] };\n/// let exact = VersionReq::exact(&version);\n///\n/// assert!(exact.matches(&version));\n/// ```\npub fn matches(&self, version: &Version) -> bool{\n        // no ranges means anything matches\n        if self.ranges.is_empty() {\n            return true;\n        }\n\n        self.ranges\n            .iter()\n            .any(|r| r.matches(version) && r.pre_tag_is_compatible(version))\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::VersionReq::parse":["/// `parse()` is the main constructor of a `VersionReq`. It takes a string like `\"^1.2.3\"`\n/// and turns it into a `VersionReq` that matches that particular constraint.\n///\n/// A `Result` is returned which contains a [`ReqParseError`] if there was a problem parsing the\n/// `VersionReq`.\n/// [`ReqParseError`]: enum.ReqParseError.html\n///\n/// # Examples\n///\n/// ```\n/// use semver::VersionReq;\n///\n/// let version = VersionReq::parse(\"=1.2.3\");\n/// let version = VersionReq::parse(\">1.2.3\");\n/// let version = VersionReq::parse(\"<1.2.3\");\n/// let version = VersionReq::parse(\"~1.2.3\");\n/// let version = VersionReq::parse(\"^1.2.3\");\n/// let version = VersionReq::parse(\"1.2.3\"); // synonym for ^1.2.3\n/// let version = VersionReq::parse(\"<=1.2.3\");\n/// let version = VersionReq::parse(\">=1.2.3\");\n/// ```\n///\n/// This example demonstrates error handling, and will panic.\n///\n/// ```should_panic\n/// use semver::VersionReq;\n///\n/// let version = match VersionReq::parse(\"not a version\") {\n///     Ok(version) => version,\n///     Err(e) => panic!(\"There was a problem parsing: {}\", e),\n/// };\n/// ```\n///\n/// # Errors\n///\n/// Returns an error variant if the input could not be parsed as a semver requirement.\n///\n/// Examples of common error causes are as follows:\n///\n/// * `\\0` - an invalid version requirement is used.\n/// * `>= >= 1.2.3` - multiple operations are used. Only use one.\n/// * `>== 1.2.3` - an invalid operation is used.\n/// * `a.0.0` - version components are not numeric.\n/// * `1.2.3-` - an invalid identifier is present.\n/// * `>=` - major version was not specified. At least a major version is required.\n/// * `0.2*` - deprecated requirement syntax. Equivalent would be `0.2.*`.\n///\n/// You may also encounter an `UnimplementedVersionRequirement` error, which indicates that a\n/// given requirement syntax is not yet implemented in this crate.\npub fn parse(input: &str) -> Result<VersionReq, ReqParseError>{\n        let range_set = input.parse::<RangeSet>();\n\n        if let Ok(v) = range_set {\n            return Ok(From::from(v));\n        }\n\n        match VersionReq::parse_deprecated(input) {\n            Some(v) => Err(ReqParseError::DeprecatedVersionRequirement(v)),\n            None => Err(From::from(range_set.err().unwrap())),\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::VersionReq::parse_compat":["/// `parse_compat()` is like `parse()`, but it takes an extra argument for compatibility with\n/// other semver implementations, and turns that into a `VersionReq` that matches the\n/// particular constraint and compatibility.\n///\n/// A `Result` is returned which contains a [`ReqParseError`] if there was a problem parsing the\n/// `VersionReq`.\n/// [`ReqParseError`]: enum.ReqParseError.html\n///\n/// # Examples\n///\n/// ```\n/// extern crate semver_parser;\n/// use semver::VersionReq;\n/// use semver_parser::Compat;\n///\n/// # fn main() {\n///     let cargo_version = VersionReq::parse_compat(\"1.2.3\", Compat::Cargo);\n///     let npm_version = VersionReq::parse_compat(\"1.2.3\", Compat::Npm);\n/// # }\n/// ```\npub fn parse_compat(input: &str, compat: Compat) -> Result<VersionReq, ReqParseError>{\n        let range_set = RangeSet::parse(input, compat);\n\n        if let Ok(v) = range_set {\n            return Ok(From::from(v));\n        }\n\n        match VersionReq::parse_deprecated(input) {\n            Some(v) => Err(ReqParseError::DeprecatedVersionRequirement(v)),\n            None => Err(From::from(range_set.err().unwrap())),\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"],"version_req::VersionReq::parse_deprecated":["fn parse_deprecated(version: &str) -> Option<VersionReq>{\n        match version {\n            \".*\" => Some(VersionReq::any()),\n            \"0.1.0.\" => Some(VersionReq::parse(\"0.1.0\").unwrap()),\n            \"0.3.1.3\" => Some(VersionReq::parse(\"0.3.13\").unwrap()),\n            \"0.2*\" => Some(VersionReq::parse(\"0.2.*\").unwrap()),\n            \"*.0\" => Some(VersionReq::any()),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/version_req.rs\"))"]},"struct_constructor":{"bool":["eq","has_exactly_one_match","is_exact","is_prerelease","matches","matches_exact","matches_greater","pre_tag_is_compatible"],"std::cmp::Ordering":["cmp","partial_cmp"],"version::Identifier":["clone","from"],"version::SemVerError":["clone"],"version::Version":["clone","from","from_str","new","parse"],"version_req::Op":["clone","from"],"version_req::Predicate":["clone","exact","from"],"version_req::Range":["clone","from"],"version_req::ReqParseError":["clone","from"],"version_req::VersionReq":["any","clone","exact","from","from_str","parse","parse_compat","parse_deprecated"]},"struct_to_trait":{"version::Identifier":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"version::SemVerError":["std::clone::Clone","std::cmp::PartialEq","std::cmp::PartialOrd","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralPartialEq"],"version::Version":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::str::FromStr"],"version_req::Op":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"version_req::Predicate":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"version_req::Range":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"version_req::ReqParseError":["std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralPartialEq"],"version_req::VersionReq":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"]},"targets":{"<version::Identifier as std::convert::From<semver_parser::version::Identifier>>::from":["from","Real(LocalPath(\"src/version.rs\"))","std::convert::From"],"<version::Identifier as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version.rs\"))","std::fmt::Display"],"<version::SemVerError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version.rs\"))","std::fmt::Display"],"<version::Version as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/version.rs\"))","std::cmp::Ord"],"<version::Version as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/version.rs\"))","std::cmp::PartialEq"],"<version::Version as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/version.rs\"))","std::cmp::PartialOrd"],"<version::Version as std::convert::From<(u64, u64, u64)>>::from":["from","Real(LocalPath(\"src/version.rs\"))","std::convert::From"],"<version::Version as std::convert::From<semver_parser::version::Version>>::from":["from","Real(LocalPath(\"src/version.rs\"))","std::convert::From"],"<version::Version as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version.rs\"))","std::fmt::Display"],"<version::Version as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/version.rs\"))","std::hash::Hash"],"<version::Version as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/version.rs\"))","std::str::FromStr"],"<version_req::Op as std::convert::From<semver_parser::Op>>::from":["from","Real(LocalPath(\"src/version_req.rs\"))","std::convert::From"],"<version_req::Op as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version_req.rs\"))","std::fmt::Display"],"<version_req::Predicate as std::convert::From<semver_parser::Comparator>>::from":["from","Real(LocalPath(\"src/version_req.rs\"))","std::convert::From"],"<version_req::Predicate as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version_req.rs\"))","std::fmt::Display"],"<version_req::Range as std::convert::From<semver_parser::Range>>::from":["from","Real(LocalPath(\"src/version_req.rs\"))","std::convert::From"],"<version_req::Range as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version_req.rs\"))","std::fmt::Display"],"<version_req::ReqParseError as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"src/version_req.rs\"))","std::convert::From"],"<version_req::ReqParseError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version_req.rs\"))","std::fmt::Display"],"<version_req::VersionReq as std::convert::From<semver_parser::RangeSet>>::from":["from","Real(LocalPath(\"src/version_req.rs\"))","std::convert::From"],"<version_req::VersionReq as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/version_req.rs\"))","std::fmt::Display"],"<version_req::VersionReq as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/version_req.rs\"))","std::str::FromStr"],"version::Version::clear_metadata":["clear_metadata","Real(LocalPath(\"src/version.rs\"))",""],"version::Version::increment_major":["increment_major","Real(LocalPath(\"src/version.rs\"))",""],"version::Version::increment_minor":["increment_minor","Real(LocalPath(\"src/version.rs\"))",""],"version::Version::increment_patch":["increment_patch","Real(LocalPath(\"src/version.rs\"))",""],"version::Version::is_prerelease":["is_prerelease","Real(LocalPath(\"src/version.rs\"))",""],"version::Version::new":["new","Real(LocalPath(\"src/version.rs\"))",""],"version::Version::parse":["parse","Real(LocalPath(\"src/version.rs\"))",""],"version_req::<impl std::convert::From<semver_parser::Identifier> for version::Identifier>::from":["from","Real(LocalPath(\"src/version_req.rs\"))","std::convert::From"],"version_req::Predicate::exact":["exact","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::Predicate::has_exactly_one_match":["has_exactly_one_match","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::Predicate::matches":["matches","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::Predicate::matches_exact":["matches_exact","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::Predicate::matches_greater":["matches_greater","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::Predicate::pre_tag_is_compatible":["pre_tag_is_compatible","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::Range::matches":["matches","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::Range::pre_tag_is_compatible":["pre_tag_is_compatible","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::VersionReq::any":["any","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::VersionReq::exact":["exact","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::VersionReq::is_exact":["is_exact","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::VersionReq::matches":["matches","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::VersionReq::parse":["parse","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::VersionReq::parse_compat":["parse_compat","Real(LocalPath(\"src/version_req.rs\"))",""],"version_req::VersionReq::parse_deprecated":["parse_deprecated","Real(LocalPath(\"src/version_req.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["version::Identifier","version::SemVerError","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::ReqParseError","version_req::VersionReq"],"std::cmp::Eq":["version::Identifier","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::VersionReq"],"std::cmp::Ord":["version::Identifier","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::VersionReq"],"std::cmp::PartialEq":["version::Identifier","version::SemVerError","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::ReqParseError","version_req::VersionReq"],"std::cmp::PartialOrd":["version::Identifier","version::SemVerError","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::VersionReq"],"std::convert::From":["version::Identifier","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::ReqParseError","version_req::VersionReq"],"std::error::Error":["version::SemVerError","version_req::ReqParseError"],"std::fmt::Debug":["version::Identifier","version::SemVerError","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::ReqParseError","version_req::VersionReq"],"std::fmt::Display":["version::Identifier","version::SemVerError","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::ReqParseError","version_req::VersionReq"],"std::hash::Hash":["version::Identifier","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::VersionReq"],"std::marker::StructuralEq":["version::Identifier","version::Version","version_req::Op","version_req::Predicate","version_req::Range","version_req::VersionReq"],"std::marker::StructuralPartialEq":["version::Identifier","version::SemVerError","version_req::Op","version_req::Predicate","version_req::Range","version_req::ReqParseError","version_req::VersionReq"],"std::str::FromStr":["version::Version","version_req::VersionReq"]},"type_to_def_path":{"version::Identifier":"version::Identifier","version::SemVerError":"version::SemVerError","version::Version":"version::Version","version_req::Op":"version_req::Op","version_req::Predicate":"version_req::Predicate","version_req::Range":"version_req::Range","version_req::ReqParseError":"version_req::ReqParseError","version_req::VersionReq":"version_req::VersionReq"}}