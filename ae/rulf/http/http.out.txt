-----------------
src/header/map.rs header::map::remove_extra_value
deps:{"header::map::remove_extra_value":{"T":["std::marker::Sized"]}}
candidates:{"header::map::remove_extra_value":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::RawLinks<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<header::map::ExtraValue<T>>
let mut p2 = 0usize; // None+usize
+header::map::remove_extra_value(p0, p1, p2);
+crate::header::map::remove_extra_value(p0, p1, p2);
+crate::header::map::remove_extra_value(p0, p1, p2);
-----------------
src/header/map.rs header::map::drain_all_extra_values
deps:{"header::map::drain_all_extra_values":{"T":["std::marker::Sized"]}}
candidates:{"header::map::drain_all_extra_values":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::RawLinks<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<header::map::ExtraValue<T>>
let mut p2 = 0usize; // None+usize
+header::map::drain_all_extra_values(p0, p1, p2);
+crate::header::map::drain_all_extra_values(p0, p1, p2);
+crate::header::map::drain_all_extra_values(p0, p1, p2);
-----------------
src/header/map.rs header::map::do_insert_phase_two
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // [header::map::Pos]
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // header::map::Pos
+header::map::do_insert_phase_two(p0, p1, p2);
+crate::header::map::do_insert_phase_two(p0, p1, p2);
+crate::header::map::do_insert_phase_two(p0, p1, p2);
-----------------
src/header/map.rs header::map::append_value
deps:{"header::map::append_value":{"T":["std::marker::Sized"]}}
candidates:{"header::map::append_value":{"T":["RUG_ANY"]}}
let mut p0 = 0usize; // None+usize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::Bucket<T>
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<header::map::ExtraValue<T>>
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+header::map::append_value(p0, p1, p2, p3);
+crate::header::map::append_value(p0, p1, p2, p3);
+crate::header::map::append_value(p0, p1, p2, p3);
-----------------
src/header/map.rs header::map::usable_capacity
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+header::map::usable_capacity(p0);
+crate::header::map::usable_capacity(p0);
+crate::header::map::usable_capacity(p0);
-----------------
src/header/map.rs header::map::to_raw_capacity
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+header::map::to_raw_capacity(p0);
+crate::header::map::to_raw_capacity(p0);
+crate::header::map::to_raw_capacity(p0);
-----------------
src/header/map.rs header::map::desired_pos
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = MaybeUninit::uninit().assume_init(); // header::map::HashValue
+header::map::desired_pos(p0, p1);
+crate::header::map::desired_pos(p0, p1);
+crate::header::map::desired_pos(p0, p1);
-----------------
src/header/map.rs header::map::probe_distance
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = MaybeUninit::uninit().assume_init(); // header::map::HashValue
let mut p2 = 0usize; // None+usize
+header::map::probe_distance(p0, p1, p2);
+crate::header::map::probe_distance(p0, p1, p2);
+crate::header::map::probe_distance(p0, p1, p2);
-----------------
src/header/map.rs header::map::hash_elem_using
deps:{"header::map::hash_elem_using":{"K":["std::hash::Hash"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::hash::Hash","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
candidates:{"header::map::hash_elem_using":{"K":["uri::authority::Authority","uri::scheme::Scheme","method::Inner","header::name::HdrName","uri::Uri","byte_str::ByteStr","std::hash::impls::<impl std::hash::Hash for &mut T>","header::name::Repr","method::extension::AllocatedExtension","header::name::MaybeLower","method::extension::InlineExtension","header::name::StandardHeader","header::name::Custom","version::Http","method::Method","header::value::HeaderValue","status::StatusCode","header::name::HeaderName","version::Version"]},"header::name::Repr":{"T":["header::name::StandardHeader","std::clone::impls::<impl std::clone::Clone for *mut T>","version::Version","header::name::Repr","byte_str::ByteStr","header::name::Custom"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Danger
let mut p1 = & MaybeUninit::uninit().assume_init(); // K
+header::map::hash_elem_using(p0, p1);
+crate::header::map::hash_elem_using(p0, p1);
+crate::header::map::hash_elem_using(p0, p1);
-----------------
src/header/name.rs header::name::parse_hdr
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = &mut [0u8;1]; // None+[u8; 64]
let mut p2 = & [0u8;1]; // None+[u8; 256]
+header::name::parse_hdr(p0, p1, p2);
+crate::header::name::parse_hdr(p0, p1, p2);
+crate::header::name::parse_hdr(p0, p1, p2);
-----------------
src/header/name.rs header::name::eq_ignore_ascii_case
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+header::name::eq_ignore_ascii_case(p0, p1);
+crate::header::name::eq_ignore_ascii_case(p0, p1);
+crate::header::name::eq_ignore_ascii_case(p0, p1);
-----------------
src/header/value.rs header::value::is_visible_ascii
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+header::value::is_visible_ascii(p0);
+crate::header::value::is_visible_ascii(p0);
+crate::header::value::is_visible_ascii(p0);
-----------------
src/header/value.rs header::value::is_valid
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+header::value::is_valid(p0);
+crate::header::value::is_valid(p0);
+crate::header::value::is_valid(p0);
-----------------
src/method.rs method::extension::write_checked
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
+method::extension::write_checked(p0, p1);
+crate::method::extension::write_checked(p0, p1);
+crate::method::extension::write_checked(p0, p1);
-----------------
src/status.rs status::canonical_reason
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+status::canonical_reason(p0);
+crate::status::canonical_reason(p0);
+crate::status::canonical_reason(p0);
-----------------
src/uri/authority.rs uri::authority::host
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+uri::authority::host(&p0);
+crate::uri::authority::host(&p0);
+crate::uri::authority::host(&p0);
-----------------
src/uri/authority.rs uri::authority::create_authority
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"uri::authority::create_authority":{"B":["std::convert::AsRef","std::marker::Sized"],"F":["std::marker::Sized","std::ops::FnOnce"]},"uri::port::Port":{"T":["std::marker::Sized","std::fmt::Debug","std::convert::AsRef"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"uri::authority::create_authority":{"B":["<&T as std::convert::AsRef<U>>","uri::scheme::Scheme","method::Method","uri::port::Port","uri::authority::Authority","header::value::HeaderValue"],"F":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::panic::AssertUnwindSafe<F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"uri::port::Port":{"T":["uri::authority::Authority","method::Method","uri::port::Port","header::value::HeaderValue","<&T as std::convert::AsRef<U>>","uri::scheme::Scheme"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // B
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+uri::authority::create_authority(p0, p1);
+crate::uri::authority::create_authority(p0, p1);
+crate::uri::authority::create_authority(p0, p1);
-----------------
src/uri/mod.rs uri::parse_full
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // bytes::Bytes
+uri::parse_full(p0);
+crate::uri::parse_full(p0);
+crate::uri::parse_full(p0);
-----------------
src/lib.rs _assert_types
deps:{}
candidates:{}
+_assert_types();
+crate::_assert_types();
+crate::_assert_types();
-----------------
src/lib.rs _assert_types::assert_send
deps:{"<&T as std::marker::Send>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"_assert_types::assert_send":{"T":["std::marker::Send","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug","std::marker::Sync"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::marker::Send","std::marker::Sync","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync"]}}
candidates:{"<&T as std::marker::Send>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"_assert_types::assert_send":{"T":["header::map::ValueDrain","header::map::Drain","header::map::ValueIterMut","<&T as std::marker::Send>","<*mut T as std::marker::Send>","header::map::Iter","header::map::IterMut"]},"header::map::Drain":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::Iter","header::map::ValueDrain","<*const T as std::marker::Send>","header::map::Drain"]},"header::map::Iter":{"T":["header::map::ValueIterMut","header::map::ValueDrain","<*const T as std::fmt::Debug>","header::map::Drain","header::map::Iter","header::map::IterMut"]},"header::map::IterMut":{"T":["header::map::ValueDrain","header::map::IterMut","header::map::Iter","header::map::Drain","header::map::ValueIterMut","<*mut T as std::marker::Send>"]},"header::map::ValueDrain":{"T":["header::map::Drain","<*const T as std::fmt::Debug>","header::map::Iter","header::map::ValueDrain","header::map::IterMut","header::map::ValueIterMut"]},"header::map::ValueIterMut":{"T":["header::map::ValueIterMut","header::map::Drain","header::map::Iter","header::map::IterMut","<*mut T as std::marker::Send>","header::map::ValueDrain"]}}
+_assert_types::assert_send();
+crate::_assert_types::assert_send();
+crate::_assert_types::assert_send();
-----------------
src/lib.rs _assert_types::assert_sync
deps:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"_assert_types::assert_sync":{"T":["std::marker::Sized","std::marker::Sync"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized"]},"header::map::IterMut":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"_assert_types::assert_sync":{"T":["header::map::Drain","header::map::Iter","header::map::ValueIterMut","header::map::IterMut","<*mut T as std::marker::Sync>","header::map::ValueDrain"]},"header::map::Drain":{"T":["header::map::Drain","header::map::ValueDrain","header::map::IterMut","<*const T as std::fmt::Debug>","header::map::Iter","header::map::ValueIterMut"]},"header::map::Iter":{"T":["header::map::ValueDrain","header::map::IterMut","header::map::Iter","<*const T as std::fmt::Debug>","header::map::ValueIterMut","header::map::Drain"]},"header::map::IterMut":{"T":["header::map::Iter","header::map::ValueIterMut","header::map::ValueDrain","header::map::IterMut","header::map::Drain","<*mut T as std::marker::Send>"]},"header::map::ValueDrain":{"T":["<*const T as std::fmt::Debug>","header::map::Drain","header::map::ValueIterMut","header::map::Iter","header::map::IterMut","header::map::ValueDrain"]},"header::map::ValueIterMut":{"T":["<*mut T as std::marker::Sync>","header::map::IterMut","header::map::Iter","header::map::ValueIterMut","header::map::ValueDrain","header::map::Drain"]}}
+_assert_types::assert_sync();
+crate::_assert_types::assert_sync();
+crate::_assert_types::assert_sync();
-----------------
src/header/map.rs header::map::into_header_name::Sealed::insert
deps:{"header::map::into_header_name::Sealed::insert":{"Self":["header::map::into_header_name::Sealed"],"T":["std::marker::Sized"]}}
candidates:{"header::map::into_header_name::Sealed::insert":{"Self":["header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1, p2);
+header::map::into_header_name::Sealed::insert(p0, p1, p2);
+crate::header::map::into_header_name::Sealed::insert(p0, p1, p2);
+crate::header::map::into_header_name::Sealed::insert(p0, p1, p2);
-----------------
src/header/map.rs header::map::into_header_name::Sealed::append
deps:{"header::map::into_header_name::Sealed::append":{"Self":["header::map::into_header_name::Sealed"],"T":["std::marker::Sized"]}}
candidates:{"header::map::into_header_name::Sealed::append":{"Self":["header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.append(p1, p2);
+header::map::into_header_name::Sealed::append(p0, p1, p2);
+crate::header::map::into_header_name::Sealed::append(p0, p1, p2);
+crate::header::map::into_header_name::Sealed::append(p0, p1, p2);
-----------------
src/header/map.rs header::map::into_header_name::Sealed::entry
deps:{"header::map::into_header_name::Sealed::entry":{"Self":["header::map::into_header_name::Sealed"],"T":["std::marker::Sized"]}}
candidates:{"header::map::into_header_name::Sealed::entry":{"Self":["header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.entry(p1);
+header::map::into_header_name::Sealed::entry(p0, p1);
+crate::header::map::into_header_name::Sealed::entry(p0, p1);
+crate::header::map::into_header_name::Sealed::entry(p0, p1);
-----------------
src/header/map.rs header::map::as_header_name::Sealed::try_entry
deps:{"header::map::as_header_name::Sealed::try_entry":{"Self":["header::map::as_header_name::Sealed"],"T":["std::marker::Sized"]}}
candidates:{"header::map::as_header_name::Sealed::try_entry":{"Self":["std::string::String","header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.try_entry(p1);
+header::map::as_header_name::Sealed::try_entry(p0, p1);
+crate::header::map::as_header_name::Sealed::try_entry(p0, p1);
+crate::header::map::as_header_name::Sealed::try_entry(p0, p1);
-----------------
src/header/map.rs header::map::as_header_name::Sealed::find
deps:{"header::map::as_header_name::Sealed::find":{"Self":["header::map::as_header_name::Sealed"],"T":["std::marker::Sized"]}}
candidates:{"header::map::as_header_name::Sealed::find":{"Self":["header::name::HeaderName","std::string::String"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.find(p1);
+header::map::as_header_name::Sealed::find(p0, p1);
+crate::header::map::as_header_name::Sealed::find(p0, p1);
+crate::header::map::as_header_name::Sealed::find(p0, p1);
-----------------
src/header/map.rs header::map::as_header_name::Sealed::as_str
deps:{"header::map::as_header_name::Sealed::as_str":{"Self":["header::map::as_header_name::Sealed"]}}
candidates:{"header::map::as_header_name::Sealed::as_str":{"Self":["header::name::HeaderName","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.as_str();
+header::map::as_header_name::Sealed::as_str(p0);
+crate::header::map::as_header_name::Sealed::as_str(p0);
+crate::header::map::as_header_name::Sealed::as_str(p0);
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::clone::Clone>::clone
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::HeaderMap<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Send","std::marker::Sized","std::marker::Sync","std::fmt::Debug"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::convert::TryFrom","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::marker::Sized","std::hash::Hash","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"request::Request":{"T":["std::default::Default","std::marker::Sized","std::fmt::Debug"]},"response::Response":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"uri::port::Port":{"T":["std::convert::AsRef","std::fmt::Debug","std::marker::Sized"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::HeaderMap<T> as std::clone::Clone>::clone":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","version::Version","header::map::Cursor","header::map::RawLinks","uri::scheme::Protocol","header::map::Danger","std::clone::impls::<impl std::clone::Clone for *const T>","uri::authority::Authority","header::map::HeaderMap","header::map::Bucket","header::map::Pos","header::map::ExtraValue","byte_str::ByteStr","header::name::Custom","method::Inner","uri::scheme::Scheme","method::extension::InlineExtension","header::value::HeaderValue","header::map::Link","status::StatusCode","method::Method","header::map::Links","uri::scheme::Scheme2","method::extension::AllocatedExtension","header::name::Repr","header::name::HeaderName","header::name::StandardHeader","uri::path::PathAndQuery","header::map::HashValue","uri::Uri","header::name::MaybeLower","version::Http"]},"header::map::Bucket":{"T":["uri::path::PathAndQuery","uri::authority::Authority","uri::scheme::Protocol","header::map::Link","method::Method","header::map::Bucket","std::clone::impls::<impl std::clone::Clone for *mut T>","header::name::Custom","header::name::StandardHeader","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::Links","uri::Uri","header::name::Repr","version::Version","header::map::HeaderMap","header::map::ExtraValue","header::map::Cursor","header::value::HeaderValue","status::StatusCode","header::map::HashValue","header::name::HeaderName","byte_str::ByteStr","header::name::MaybeLower","header::map::RawLinks"]},"header::map::Drain":{"T":["header::map::IterMut","header::map::Iter","header::map::Drain","<*const T as std::marker::Send>","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::Entry":{"T":["uri::Parts","uri::scheme::Scheme2","header::map::Values","header::map::ValueDrain","header::map::Keys","header::map::Entry","uri::InvalidUri","header::map::ExtraValue","header::value::InvalidHeaderValue","header::map::ValueIter","request::Builder","status::InvalidStatusCode","header::name::MaybeLower","response::Parts","method::InvalidMethod","status::StatusCode","header::map::Cursor","header::value::HeaderValue","extensions::Extensions","header::map::ValuesMut","header::map::HeaderMap","header::map::Drain","header::name::InvalidHeaderName","header::map::VacantEntry","uri::scheme::Scheme","<*const T as std::fmt::Debug>","header::name::HdrName","request::Request","header::name::Custom","header::map::HashValue","header::name::StandardHeader","byte_str::ByteStr","header::map::Links","response::Builder","uri::path::PathAndQuery","header::map::OccupiedEntry","response::Response","version::Version","uri::InvalidUriParts","header::map::Link","uri::authority::Authority","uri::scheme::Protocol","uri::ErrorKind","header::value::ToStrError","uri::Uri","method::Method","header::name::Repr","header::map::IterMut","request::Parts","uri::builder::Builder","header::map::Bucket","header::map::ValueIterMut","header::map::IntoIter","uri::port::Port","header::map::GetAll","header::map::Iter","header::map::RawLinks","header::name::HeaderName","error::Error"]},"header::map::ExtraValue":{"T":["<&mut T as std::fmt::Debug>","header::name::HeaderName","uri::scheme::Protocol","uri::Uri","header::name::Repr","uri::authority::Authority","byte_str::ByteStr","header::map::Link","uri::scheme::Scheme","status::StatusCode","header::map::Bucket","version::Version","header::map::HashValue","header::map::Cursor","method::Method","uri::scheme::Scheme2","header::name::Custom","header::map::Links","uri::path::PathAndQuery","header::name::StandardHeader","header::value::HeaderValue","header::name::MaybeLower","header::map::RawLinks","header::map::ExtraValue","header::map::HeaderMap"]},"header::map::GetAll":{"T":["header::map::HeaderMap","header::map::Link","header::map::Cursor","header::name::Custom","header::name::Repr","<*mut T as std::fmt::Debug>","byte_str::ByteStr","header::name::StandardHeader","uri::ErrorKind","header::map::GetAll","version::Version","header::map::HashValue"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["response::Response","request::Request","uri::scheme::Protocol","uri::authority::Authority","header::name::HdrName","header::map::GetAll","header::name::Repr","header::map::Entry","header::value::ToStrError","header::map::IntoIter","header::map::Drain","uri::InvalidUriParts","header::map::Values","uri::ErrorKind","header::map::IterMut","header::map::RawLinks","header::name::MaybeLower","header::map::HashValue","header::map::Link","uri::Parts","header::map::OccupiedEntry","header::value::InvalidHeaderValue","error::Error","uri::scheme::Scheme2","header::map::Cursor","uri::builder::Builder","header::name::StandardHeader","header::map::ValueDrain","header::map::ValueIter","header::name::InvalidHeaderName","response::Builder","method::InvalidMethod","header::name::HeaderName","header::map::ValueIterMut","header::map::Iter","header::map::HeaderMap","header::map::Links","uri::InvalidUri","uri::scheme::Scheme","version::Version","uri::port::Port","status::StatusCode","header::map::Bucket","header::map::ValuesMut","status::InvalidStatusCode","uri::Uri","header::name::Custom","header::map::ExtraValue","<*const T as std::fmt::Debug>","method::Method","byte_str::ByteStr","uri::path::PathAndQuery","header::map::Keys","response::Parts","header::map::VacantEntry","extensions::Extensions","request::Parts","request::Builder","header::value::HeaderValue"]},"header::map::Iter":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::Iter","header::map::Drain","header::map::ValueDrain","<*mut T as std::fmt::Debug>"]},"header::map::IterMut":{"T":["header::map::IterMut","header::map::Drain","header::map::ValueIterMut","header::map::ValueDrain","header::map::Iter","<*const T as std::marker::Send>"]},"header::map::Keys":{"T":["header::map::Entry","uri::path::PathAndQuery","uri::port::Port","method::Method","header::value::InvalidHeaderValue","header::map::Cursor","uri::ErrorKind","header::name::MaybeLower","version::Version","header::map::ExtraValue","uri::Uri","header::map::ValuesMut","uri::scheme::Protocol","uri::authority::Authority","header::map::Keys","header::map::ValueIter","extensions::Extensions","uri::Parts","header::map::ValueIterMut","response::Parts","header::map::VacantEntry","<&T as std::fmt::Debug>","header::map::Bucket","header::name::Repr","header::map::HeaderMap","header::name::InvalidHeaderName","header::map::IntoIter","response::Response","header::map::HashValue","header::name::StandardHeader","request::Parts","request::Builder","byte_str::ByteStr","header::map::IterMut","header::value::ToStrError","response::Builder","method::InvalidMethod","uri::InvalidUriParts","status::StatusCode","header::map::Link","uri::InvalidUri","uri::scheme::Scheme","error::Error","header::map::RawLinks","header::map::Drain","uri::builder::Builder","header::map::Links","status::InvalidStatusCode","header::name::HdrName","uri::scheme::Scheme2","header::map::GetAll","header::name::HeaderName","header::map::OccupiedEntry","header::map::ValueDrain","header::map::Iter","request::Request","header::name::Custom","header::value::HeaderValue","header::map::Values"]},"header::map::OccupiedEntry":{"T":["uri::ErrorKind","response::Response","<&T as std::fmt::Debug>","header::map::HashValue","request::Builder","header::map::IterMut","version::Version","header::map::Values","header::map::OccupiedEntry","header::map::ValueIterMut","error::Error","header::name::HdrName","status::StatusCode","header::name::InvalidHeaderName","header::map::Bucket","header::value::ToStrError","header::map::IntoIter","header::map::GetAll","uri::authority::Authority","header::map::Iter","uri::scheme::Scheme","header::map::Link","uri::InvalidUri","header::name::Repr","uri::scheme::Scheme2","header::name::StandardHeader","uri::path::PathAndQuery","header::map::Entry","uri::Uri","header::map::Drain","header::map::ExtraValue","method::InvalidMethod","extensions::Extensions","header::name::HeaderName","header::value::InvalidHeaderValue","status::InvalidStatusCode","header::map::Links","header::name::Custom","response::Parts","header::map::VacantEntry","header::map::Keys","header::map::HeaderMap","uri::scheme::Protocol","uri::Parts","request::Parts","header::map::ValueIter","byte_str::ByteStr","header::map::ValueDrain","uri::builder::Builder","uri::InvalidUriParts","request::Request","header::map::RawLinks","header::name::MaybeLower","header::value::HeaderValue","method::Method","header::map::ValuesMut","header::map::Cursor","uri::port::Port","response::Builder"]},"header::map::RawLinks":{"T":["uri::scheme::Scheme","uri::path::PathAndQuery","uri::authority::Authority","response::Parts","method::InvalidMethod","status::InvalidStatusCode","uri::ErrorKind","request::Parts","header::map::ValuesMut","header::name::Custom","header::map::ValueIterMut","uri::Uri","request::Request","header::map::ValueDrain","header::map::IterMut","header::map::Bucket","uri::builder::Builder","uri::scheme::Scheme2","header::map::OccupiedEntry","request::Builder","error::Error","header::map::GetAll","<*const T as std::fmt::Debug>","header::map::Values","header::map::Cursor","header::map::HashValue","header::name::MaybeLower","status::StatusCode","uri::port::Port","header::name::Repr","uri::scheme::Protocol","header::value::ToStrError","header::name::StandardHeader","byte_str::ByteStr","header::map::ExtraValue","header::map::IntoIter","method::Method","header::map::RawLinks","version::Version","response::Builder","header::value::InvalidHeaderValue","header::map::Keys","extensions::Extensions","uri::Parts","header::map::Entry","uri::InvalidUriParts","header::map::Drain","header::name::InvalidHeaderName","header::map::Link","header::map::HeaderMap","header::name::HeaderName","header::map::VacantEntry","uri::InvalidUri","header::name::HdrName","header::map::Iter","response::Response","header::map::Links","header::map::ValueIter","header::value::HeaderValue"]},"header::map::VacantEntry":{"T":["header::map::GetAll","status::StatusCode","header::map::ExtraValue","uri::Parts","header::value::InvalidHeaderValue","header::map::IntoIter","header::map::HashValue","header::map::ValuesMut","uri::port::Port","header::name::Repr","header::map::RawLinks","uri::Uri","method::Method","uri::InvalidUriParts","header::value::ToStrError","header::map::Drain","header::name::StandardHeader","uri::ErrorKind","method::InvalidMethod","request::Request","header::map::Iter","<*const T as std::fmt::Debug>","uri::path::PathAndQuery","response::Response","header::name::MaybeLower","header::map::ValueDrain","header::map::Cursor","uri::scheme::Protocol","extensions::Extensions","version::Version","request::Parts","header::map::Link","header::map::VacantEntry","header::map::Keys","byte_str::ByteStr","uri::authority::Authority","uri::builder::Builder","header::name::InvalidHeaderName","request::Builder","status::InvalidStatusCode","uri::scheme::Scheme2","header::name::HeaderName","uri::InvalidUri","header::name::HdrName","header::map::HeaderMap","response::Parts","error::Error","header::value::HeaderValue","response::Builder","header::map::OccupiedEntry","uri::scheme::Scheme","header::map::Links","header::map::Bucket","header::map::ValueIter","header::map::IterMut","header::map::ValueIterMut","header::map::Values","header::map::Entry","header::name::Custom"]},"header::map::ValueDrain":{"T":["header::map::IterMut","header::map::Iter","header::map::Drain","<*mut T as std::fmt::Debug>","header::map::ValueDrain","header::map::ValueIterMut"]},"header::map::ValueIter":{"T":["header::map::HashValue","uri::InvalidUri","header::map::Links","uri::port::Port","header::name::HeaderName","uri::InvalidUriParts","response::Builder","error::Error","header::map::HeaderMap","uri::builder::Builder","header::name::Custom","request::Parts","uri::scheme::Scheme2","uri::Uri","extensions::Extensions","uri::scheme::Scheme","header::name::MaybeLower","header::name::InvalidHeaderName","header::value::ToStrError","header::map::Drain","status::StatusCode","byte_str::ByteStr","header::value::InvalidHeaderValue","header::map::Values","request::Request","header::map::ValueIterMut","header::map::Iter","header::map::Bucket","header::map::OccupiedEntry","header::value::HeaderValue","request::Builder","header::name::HdrName","method::InvalidMethod","header::map::Cursor","header::map::ValueIter","header::map::RawLinks","header::map::GetAll","header::map::Link","<&mut T as std::fmt::Debug>","header::map::ExtraValue","header::map::Keys","method::Method","uri::authority::Authority","header::map::ValueDrain","response::Response","uri::scheme::Protocol","uri::ErrorKind","uri::Parts","header::map::IterMut","header::map::VacantEntry","header::name::Repr","header::name::StandardHeader","header::map::Entry","header::map::ValuesMut","version::Version","status::InvalidStatusCode","response::Parts","uri::path::PathAndQuery","header::map::IntoIter"]},"header::map::ValueIterMut":{"T":["header::map::ValueIterMut","header::map::IterMut","<*const T as std::fmt::Debug>","header::map::ValueDrain","header::map::Iter","header::map::Drain"]},"header::map::Values":{"T":["<*mut T as std::fmt::Debug>","response::Response","uri::Parts","header::value::ToStrError","uri::builder::Builder","header::map::ValueIterMut","header::map::VacantEntry","header::name::HdrName","uri::scheme::Scheme","uri::port::Port","error::Error","version::Version","uri::InvalidUriParts","uri::Uri","header::name::InvalidHeaderName","uri::authority::Authority","extensions::Extensions","header::map::Links","uri::scheme::Protocol","header::name::MaybeLower","uri::ErrorKind","header::map::HeaderMap","header::map::IntoIter","header::name::StandardHeader","response::Builder","header::map::ExtraValue","header::map::Link","header::map::Bucket","uri::scheme::Scheme2","uri::path::PathAndQuery","header::map::GetAll","header::name::Repr","header::name::HeaderName","uri::InvalidUri","header::map::ValueDrain","method::Method","header::name::Custom","header::value::InvalidHeaderValue","header::map::Iter","header::map::Cursor","response::Parts","header::map::Values","header::map::ValuesMut","header::map::RawLinks","header::map::Drain","request::Parts","header::map::Keys","request::Builder","header::map::OccupiedEntry","status::InvalidStatusCode","header::map::IterMut","method::InvalidMethod","header::map::HashValue","header::map::ValueIter","header::map::Entry","request::Request","byte_str::ByteStr","status::StatusCode","header::value::HeaderValue"]},"header::map::ValuesMut":{"T":["header::map::Values","status::InvalidStatusCode","extensions::Extensions","header::name::Repr","uri::Uri","method::Method","header::map::Keys","byte_str::ByteStr","header::name::StandardHeader","uri::scheme::Protocol","uri::ErrorKind","header::map::OccupiedEntry","header::map::IterMut","error::Error","uri::authority::Authority","header::name::HeaderName","uri::Parts","header::value::HeaderValue","header::value::InvalidHeaderValue","uri::path::PathAndQuery","header::name::InvalidHeaderName","method::InvalidMethod","header::map::VacantEntry","uri::scheme::Scheme","request::Request","<&mut T as std::fmt::Debug>","header::map::Drain","uri::InvalidUri","header::map::ExtraValue","version::Version","uri::InvalidUriParts","header::map::ValueIter","header::map::ValueDrain","response::Response","header::map::Link","header::map::Entry","header::map::Iter","header::map::Bucket","header::map::HashValue","header::map::ValueIterMut","header::map::IntoIter","header::value::ToStrError","request::Parts","header::map::RawLinks","header::map::ValuesMut","header::map::Cursor","request::Builder","uri::port::Port","uri::scheme::Scheme2","header::map::HeaderMap","uri::builder::Builder","header::name::MaybeLower","header::name::Custom","header::map::Links","header::name::HdrName","header::map::GetAll","response::Parts","response::Builder","status::StatusCode"]},"header::name::Repr":{"T":["header::name::Repr","header::name::StandardHeader","byte_str::ByteStr","std::clone::impls::<impl std::clone::Clone for *mut T>","version::Version","header::name::Custom"]},"request::Request":{"T":["request::Request","header::map::HeaderMap","extensions::Extensions","uri::Parts","method::Method","uri::builder::Builder","response::Response","uri::Uri","status::StatusCode","request::Builder","response::Builder","version::Version"]},"response::Response":{"T":["method::Method","request::Builder","version::Version","uri::builder::Builder","response::Response","status::StatusCode","uri::Uri","response::Builder","extensions::Extensions","header::map::HeaderMap","uri::Parts","request::Request"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"uri::port::Port":{"T":["method::Method","header::value::HeaderValue","<&T as std::convert::AsRef<U>>","uri::authority::Authority","uri::scheme::Scheme","uri::port::Port"]},"uri::scheme::Scheme2":{"T":["header::map::Cursor","uri::path::PathAndQuery","header::name::Custom","std::boxed::Box<byte_str::ByteStr>","uri::authority::Authority","header::map::RawLinks","header::map::Link","header::map::Links","uri::scheme::Scheme","header::name::Repr","uri::Uri","header::map::HashValue","status::StatusCode","version::Version","uri::scheme::Protocol","header::map::HeaderMap","<*mut T as std::fmt::Debug>","header::value::HeaderValue","header::map::ExtraValue","method::Method","header::map::Bucket","uri::scheme::Scheme2","header::name::StandardHeader","header::name::MaybeLower","byte_str::ByteStr","header::name::HeaderName"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.clone();
+<header::map::HeaderMap<T> as std::clone::Clone>::clone(p0);
+crate::<header::map::HeaderMap<T> as std::clone::Clone>::clone(p0);
+<header::map::HeaderMap<T>>::clone(p0);
-----------------
src/header/map.rs <header::map::Iter<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Iter<'a, T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"header::map::Drain":{"T":["std::marker::Sync","std::marker::Send","std::marker::Sized","std::fmt::Debug"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::convert::TryFrom","std::marker::Sized","std::fmt::Debug"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::marker::Sized"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::name::Repr":{"T":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::hash::Hash"]},"request::Request":{"T":["std::fmt::Debug","std::default::Default","std::marker::Sized"]},"response::Response":{"T":["std::default::Default","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"uri::port::Port":{"T":["std::convert::AsRef","std::fmt::Debug","std::marker::Sized"]},"uri::scheme::Scheme2":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Iter<'a, T> as std::fmt::Debug>::fmt":{"T":["status::StatusCode","header::name::Custom","header::map::GetAll","header::map::ExtraValue","version::Version","byte_str::ByteStr","header::map::ValuesMut","header::map::Entry","header::map::RawLinks","header::name::MaybeLower","uri::InvalidUri","header::map::HashValue","header::map::ValueIterMut","header::name::StandardHeader","header::map::Drain","header::value::ToStrError","header::value::HeaderValue","uri::scheme::Scheme","uri::Parts","uri::builder::Builder","uri::ErrorKind","header::map::ValueDrain","header::name::InvalidHeaderName","header::value::InvalidHeaderValue","header::map::Keys","request::Request","uri::path::PathAndQuery","header::map::IntoIter","header::name::HdrName","extensions::Extensions","header::map::VacantEntry","response::Parts","error::Error","response::Response","uri::Uri","<*const T as std::fmt::Debug>","header::map::Iter","response::Builder","uri::port::Port","header::name::Repr","method::InvalidMethod","header::map::Bucket","status::InvalidStatusCode","header::map::HeaderMap","uri::authority::Authority","request::Builder","header::map::Cursor","header::name::HeaderName","header::map::ValueIter","header::map::Links","header::map::Values","uri::InvalidUriParts","header::map::Link","request::Parts","method::Method","uri::scheme::Protocol","header::map::OccupiedEntry","header::map::IterMut","uri::scheme::Scheme2"]},"header::map::Bucket":{"T":["header::name::Custom","header::value::HeaderValue","status::StatusCode","header::name::StandardHeader","version::Version","header::name::Repr","header::map::Link","byte_str::ByteStr","uri::path::PathAndQuery","uri::scheme::Protocol","uri::Uri","<*const T as std::fmt::Debug>","header::map::HeaderMap","header::map::RawLinks","uri::scheme::Scheme","header::map::Cursor","header::map::Links","uri::scheme::Scheme2","header::map::HashValue","header::map::ExtraValue","header::name::MaybeLower","method::Method","uri::authority::Authority","header::map::Bucket","header::name::HeaderName"]},"header::map::Drain":{"T":["header::map::ValueDrain","header::map::ValueIterMut","<*mut T as std::marker::Send>","header::map::Drain","header::map::IterMut","header::map::Iter"]},"header::map::Entry":{"T":["method::InvalidMethod","uri::Parts","header::map::GetAll","uri::scheme::Protocol","header::name::HeaderName","version::Version","status::InvalidStatusCode","response::Parts","header::value::InvalidHeaderValue","header::map::HashValue","<&T as std::fmt::Debug>","header::map::Cursor","header::name::Custom","uri::InvalidUri","response::Builder","uri::builder::Builder","header::map::Drain","uri::port::Port","header::map::ValuesMut","header::map::RawLinks","uri::InvalidUriParts","header::map::ValueIterMut","header::map::IterMut","uri::scheme::Scheme","header::map::VacantEntry","request::Builder","uri::ErrorKind","extensions::Extensions","header::name::MaybeLower","header::map::Entry","error::Error","request::Parts","header::map::OccupiedEntry","uri::scheme::Scheme2","method::Method","uri::authority::Authority","header::name::InvalidHeaderName","status::StatusCode","uri::Uri","header::map::Keys","header::map::Link","header::name::HdrName","header::value::HeaderValue","header::map::ExtraValue","header::map::Iter","byte_str::ByteStr","header::map::Links","header::map::HeaderMap","request::Request","uri::path::PathAndQuery","header::map::ValueIter","header::name::Repr","header::map::Values","header::map::Bucket","header::map::IntoIter","header::value::ToStrError","response::Response","header::name::StandardHeader","header::map::ValueDrain"]},"header::map::ExtraValue":{"T":["status::StatusCode","uri::scheme::Scheme","uri::authority::Authority","header::map::Bucket","version::Version","header::map::HeaderMap","header::name::HeaderName","header::map::RawLinks","header::map::HashValue","header::name::Repr","header::name::MaybeLower","header::map::ExtraValue","header::map::Links","header::map::Cursor","header::name::StandardHeader","uri::scheme::Scheme2","<&T as std::fmt::Debug>","header::name::Custom","header::value::HeaderValue","byte_str::ByteStr","uri::Uri","method::Method","uri::scheme::Protocol","uri::path::PathAndQuery","header::map::Link"]},"header::map::GetAll":{"T":["header::map::Cursor","header::name::StandardHeader","version::Version","byte_str::ByteStr","header::name::Custom","header::map::HeaderMap","std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>","header::map::HashValue","header::map::Link","uri::ErrorKind","header::name::Repr","header::map::GetAll"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::Keys","header::name::Custom","header::map::IterMut","uri::InvalidUriParts","header::map::VacantEntry","header::map::ValueIter","byte_str::ByteStr","uri::scheme::Scheme2","extensions::Extensions","response::Parts","header::name::MaybeLower","header::map::Iter","<&mut T as std::fmt::Debug>","header::map::Links","header::map::RawLinks","status::InvalidStatusCode","header::name::InvalidHeaderName","uri::port::Port","header::map::Entry","header::map::Values","request::Request","uri::Parts","header::map::ValueIterMut","header::name::HdrName","header::name::StandardHeader","request::Builder","header::name::Repr","header::map::Drain","uri::builder::Builder","status::StatusCode","header::map::HeaderMap","method::InvalidMethod","header::value::ToStrError","uri::ErrorKind","header::map::GetAll","uri::Uri","header::map::IntoIter","header::map::ExtraValue","uri::scheme::Protocol","header::map::Cursor","header::map::HashValue","response::Response","uri::authority::Authority","header::name::HeaderName","header::value::HeaderValue","uri::InvalidUri","error::Error","header::map::Link","header::map::Bucket","header::map::ValuesMut","version::Version","header::map::OccupiedEntry","request::Parts","uri::scheme::Scheme","method::Method","uri::path::PathAndQuery","header::map::ValueDrain","response::Builder","header::value::InvalidHeaderValue"]},"header::map::Iter":{"T":["header::map::IterMut","<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Drain","header::map::Iter","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["<*mut T as std::marker::Sync>","header::map::IterMut","header::map::Iter","header::map::Drain","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::Keys":{"T":["header::map::Cursor","header::map::Drain","request::Parts","uri::InvalidUriParts","header::map::HashValue","header::map::IntoIter","header::name::StandardHeader","header::name::InvalidHeaderName","header::value::ToStrError","byte_str::ByteStr","header::map::OccupiedEntry","uri::Uri","header::name::HeaderName","header::map::ValueDrain","status::InvalidStatusCode","header::name::MaybeLower","uri::path::PathAndQuery","header::map::GetAll","method::InvalidMethod","extensions::Extensions","header::value::HeaderValue","request::Request","header::map::ValuesMut","status::StatusCode","uri::scheme::Scheme2","header::name::Repr","header::map::Link","header::map::RawLinks","header::map::Keys","<&mut T as std::fmt::Debug>","header::map::ExtraValue","header::map::VacantEntry","uri::builder::Builder","header::value::InvalidHeaderValue","uri::authority::Authority","header::map::HeaderMap","uri::scheme::Protocol","header::map::Values","header::map::ValueIter","response::Parts","header::map::Bucket","uri::Parts","header::map::ValueIterMut","error::Error","header::map::Entry","header::map::Links","request::Builder","uri::ErrorKind","method::Method","header::map::Iter","uri::port::Port","response::Builder","header::name::Custom","uri::InvalidUri","response::Response","version::Version","header::name::HdrName","uri::scheme::Scheme","header::map::IterMut"]},"header::map::OccupiedEntry":{"T":["uri::scheme::Scheme","method::Method","byte_str::ByteStr","response::Builder","uri::InvalidUri","header::map::Cursor","header::map::ExtraValue","header::name::MaybeLower","header::map::HeaderMap","status::StatusCode","version::Version","header::map::Bucket","header::map::Links","uri::authority::Authority","header::value::ToStrError","header::map::Values","uri::ErrorKind","extensions::Extensions","<*const T as std::fmt::Debug>","header::name::InvalidHeaderName","header::map::ValuesMut","header::value::HeaderValue","error::Error","header::map::GetAll","response::Response","header::map::ValueDrain","header::map::ValueIterMut","uri::path::PathAndQuery","header::name::Custom","header::map::Drain","header::name::HdrName","uri::builder::Builder","header::map::IntoIter","header::map::RawLinks","header::map::VacantEntry","uri::Uri","header::map::ValueIter","uri::Parts","header::name::HeaderName","header::map::Link","uri::port::Port","header::map::Iter","request::Parts","uri::scheme::Scheme2","status::InvalidStatusCode","uri::InvalidUriParts","header::map::IterMut","header::name::Repr","header::value::InvalidHeaderValue","request::Builder","uri::scheme::Protocol","header::map::Entry","response::Parts","header::name::StandardHeader","header::map::Keys","method::InvalidMethod","header::map::HashValue","header::map::OccupiedEntry","request::Request"]},"header::map::RawLinks":{"T":["header::map::ExtraValue","byte_str::ByteStr","header::map::RawLinks","response::Response","uri::authority::Authority","response::Builder","header::value::ToStrError","uri::scheme::Scheme2","header::name::StandardHeader","header::map::ValuesMut","header::map::Bucket","uri::InvalidUriParts","header::name::MaybeLower","request::Request","header::map::GetAll","header::value::InvalidHeaderValue","header::map::Drain","header::name::InvalidHeaderName","header::map::Link","header::map::IterMut","header::map::Iter","status::InvalidStatusCode","uri::scheme::Scheme","header::map::Cursor","method::Method","uri::path::PathAndQuery","header::map::Keys","header::map::ValueIter","method::InvalidMethod","header::name::HdrName","uri::builder::Builder","error::Error","header::map::HashValue","request::Parts","<*mut T as std::fmt::Debug>","header::value::HeaderValue","uri::scheme::Protocol","header::map::ValueIterMut","extensions::Extensions","header::map::IntoIter","header::map::VacantEntry","header::name::Custom","header::map::HeaderMap","header::name::Repr","response::Parts","uri::Uri","header::name::HeaderName","status::StatusCode","header::map::Entry","request::Builder","header::map::Links","header::map::OccupiedEntry","header::map::ValueDrain","uri::Parts","uri::ErrorKind","header::map::Values","uri::port::Port","version::Version","uri::InvalidUri"]},"header::map::VacantEntry":{"T":["method::Method","header::map::GetAll","header::map::Bucket","header::map::ValuesMut","header::value::ToStrError","uri::port::Port","uri::scheme::Scheme","uri::authority::Authority","header::map::Keys","uri::scheme::Scheme2","response::Response","header::map::HeaderMap","response::Parts","error::Error","method::InvalidMethod","header::map::Values","uri::path::PathAndQuery","header::map::HashValue","header::value::HeaderValue","extensions::Extensions","status::StatusCode","header::name::InvalidHeaderName","uri::ErrorKind","header::map::Links","uri::Parts","<&T as std::fmt::Debug>","header::map::Iter","header::name::Repr","header::map::RawLinks","header::name::StandardHeader","header::map::IntoIter","header::map::Cursor","header::map::ValueIter","header::map::ExtraValue","response::Builder","header::name::HeaderName","header::map::IterMut","header::map::Entry","request::Parts","uri::Uri","header::name::HdrName","byte_str::ByteStr","header::name::Custom","uri::InvalidUri","header::name::MaybeLower","header::map::ValueDrain","uri::scheme::Protocol","header::map::VacantEntry","uri::builder::Builder","header::map::ValueIterMut","request::Request","header::map::OccupiedEntry","version::Version","request::Builder","status::InvalidStatusCode","uri::InvalidUriParts","header::value::InvalidHeaderValue","header::map::Drain","header::map::Link"]},"header::map::ValueDrain":{"T":["header::map::IterMut","header::map::Iter","<*mut T as std::fmt::Debug>","header::map::Drain","header::map::ValueDrain","header::map::ValueIterMut"]},"header::map::ValueIter":{"T":["header::name::MaybeLower","request::Parts","header::map::ValuesMut","header::name::Custom","response::Builder","header::name::StandardHeader","header::map::HashValue","uri::path::PathAndQuery","request::Builder","header::map::Cursor","uri::Parts","header::name::Repr","header::map::ExtraValue","header::value::HeaderValue","header::map::Keys","header::name::HeaderName","header::map::Values","status::InvalidStatusCode","header::value::InvalidHeaderValue","uri::scheme::Scheme","error::Error","method::InvalidMethod","header::map::Link","uri::port::Port","header::map::OccupiedEntry","header::map::RawLinks","header::map::VacantEntry","method::Method","uri::authority::Authority","header::map::Drain","status::StatusCode","uri::InvalidUriParts","uri::builder::Builder","header::map::Entry","header::value::ToStrError","header::map::IntoIter","uri::scheme::Scheme2","header::map::ValueIterMut","version::Version","header::map::GetAll","header::map::ValueDrain","response::Response","header::name::HdrName","header::map::Links","<&T as std::fmt::Debug>","header::map::Iter","byte_str::ByteStr","header::map::HeaderMap","uri::ErrorKind","request::Request","uri::scheme::Protocol","header::map::Bucket","uri::InvalidUri","header::name::InvalidHeaderName","response::Parts","header::map::ValueIter","header::map::IterMut","uri::Uri","extensions::Extensions"]},"header::map::ValueIterMut":{"T":["header::map::ValueIterMut","header::map::Drain","header::map::IterMut","header::map::ValueDrain","header::map::Iter","<*const T as std::marker::Sync>"]},"header::map::Values":{"T":["version::Version","uri::path::PathAndQuery","uri::scheme::Protocol","error::Error","header::map::HashValue","header::name::Repr","header::value::ToStrError","header::name::StandardHeader","header::map::Cursor","header::map::Keys","header::name::Custom","header::map::Links","header::map::RawLinks","status::InvalidStatusCode","status::StatusCode","header::map::ValuesMut","header::map::ValueDrain","response::Response","response::Parts","header::map::Iter","header::name::HdrName","uri::scheme::Scheme2","header::map::Values","method::Method","header::map::Link","header::value::HeaderValue","header::map::HeaderMap","method::InvalidMethod","extensions::Extensions","header::map::ValueIterMut","header::name::InvalidHeaderName","byte_str::ByteStr","request::Request","request::Builder","header::name::MaybeLower","header::map::ValueIter","header::map::OccupiedEntry","uri::port::Port","header::map::IntoIter","header::name::HeaderName","header::map::Drain","request::Parts","uri::builder::Builder","header::map::VacantEntry","uri::InvalidUriParts","header::map::Entry","uri::Uri","uri::scheme::Scheme","uri::authority::Authority","uri::ErrorKind","response::Builder","header::map::IterMut","header::map::GetAll","header::map::ExtraValue","<&T as std::fmt::Debug>","uri::InvalidUri","header::value::InvalidHeaderValue","uri::Parts","header::map::Bucket"]},"header::map::ValuesMut":{"T":["header::map::VacantEntry","response::Parts","status::InvalidStatusCode","header::name::MaybeLower","version::Version","header::map::IterMut","uri::builder::Builder","uri::ErrorKind","header::name::Repr","header::map::Iter","header::map::ValueDrain","header::map::Entry","header::map::ValueIterMut","uri::authority::Authority","header::map::OccupiedEntry","header::value::ToStrError","method::InvalidMethod","error::Error","response::Builder","header::map::Drain","header::map::HeaderMap","header::name::InvalidHeaderName","header::map::IntoIter","header::map::Cursor","header::value::HeaderValue","header::value::InvalidHeaderValue","uri::InvalidUri","header::map::Bucket","uri::InvalidUriParts","header::name::Custom","header::name::HdrName","byte_str::ByteStr","uri::Parts","header::map::ValuesMut","header::map::Values","uri::path::PathAndQuery","response::Response","method::Method","request::Builder","<*const T as std::fmt::Debug>","header::map::Keys","header::name::StandardHeader","request::Parts","uri::scheme::Scheme","uri::scheme::Protocol","status::StatusCode","uri::scheme::Scheme2","header::map::RawLinks","header::map::Links","header::name::HeaderName","header::map::ExtraValue","header::map::Link","uri::Uri","uri::port::Port","header::map::GetAll","extensions::Extensions","request::Request","header::map::HashValue","header::map::ValueIter"]},"header::name::Repr":{"T":["header::name::Repr","header::name::StandardHeader","header::name::Custom","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","byte_str::ByteStr","version::Version"]},"request::Request":{"T":["response::Response","version::Version","uri::Parts","request::Request","uri::builder::Builder","uri::Uri","request::Builder","method::Method","status::StatusCode","extensions::Extensions","response::Builder","header::map::HeaderMap"]},"response::Response":{"T":["request::Builder","uri::Parts","header::map::HeaderMap","uri::builder::Builder","uri::Uri","extensions::Extensions","version::Version","response::Builder","request::Request","response::Response","status::StatusCode","method::Method"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"uri::port::Port":{"T":["uri::port::Port","uri::authority::Authority","<&T as std::convert::AsRef<U>>","uri::scheme::Scheme","header::value::HeaderValue","method::Method"]},"uri::scheme::Scheme2":{"T":["status::StatusCode","header::map::ExtraValue","header::name::MaybeLower","header::map::HashValue","header::map::Links","header::map::Cursor","header::name::Repr","byte_str::ByteStr","header::name::HeaderName","header::name::Custom","header::map::HeaderMap","header::map::RawLinks","uri::scheme::Scheme2","std::boxed::Box<byte_str::ByteStr>","header::map::Bucket","header::map::Link","version::Version","uri::authority::Authority","<&T as std::fmt::Debug>","method::Method","uri::scheme::Protocol","uri::scheme::Scheme","header::value::HeaderValue","uri::path::PathAndQuery","header::name::StandardHeader","uri::Uri"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Iter<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::Iter<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::Iter<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::Iter<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::IterMut<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::IterMut<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::convert::TryFrom","std::clone::Clone"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sync","std::marker::Sized"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::name::Repr":{"T":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::hash::Hash","std::cmp::Eq","std::marker::Sized"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::default::Default","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::IterMut<'a, T> as std::fmt::Debug>::fmt":{"T":["header::name::Custom","header::map::Cursor","uri::scheme::Scheme2","header::map::IterMut","uri::authority::Authority","byte_str::ByteStr","header::map::Link","header::map::Keys","header::name::StandardHeader","version::Version","header::map::ValuesMut","header::map::ValueIterMut","request::Builder","error::Error","header::map::IntoIter","extensions::Extensions","header::map::ValueDrain","uri::port::Port","header::map::RawLinks","status::InvalidStatusCode","header::map::Links","header::name::HdrName","uri::ErrorKind","response::Response","method::InvalidMethod","header::map::Drain","method::Method","header::map::VacantEntry","header::map::OccupiedEntry","uri::InvalidUri","header::map::ExtraValue","response::Builder","header::value::InvalidHeaderValue","header::map::Values","header::map::HeaderMap","header::value::HeaderValue","header::map::HashValue","header::map::Iter","header::name::HeaderName","uri::Uri","<*const T as std::fmt::Debug>","uri::Parts","header::name::InvalidHeaderName","header::name::Repr","uri::InvalidUriParts","request::Parts","uri::path::PathAndQuery","header::value::ToStrError","status::StatusCode","header::map::Entry","header::map::Bucket","header::map::GetAll","response::Parts","header::map::ValueIter","uri::builder::Builder","request::Request","header::name::MaybeLower","uri::scheme::Scheme","uri::scheme::Protocol"]},"header::map::Bucket":{"T":["header::name::MaybeLower","header::map::RawLinks","header::map::HashValue","header::name::Repr","byte_str::ByteStr","status::StatusCode","header::name::HeaderName","header::map::HeaderMap","header::map::Bucket","uri::scheme::Scheme2","version::Version","header::value::HeaderValue","uri::scheme::Protocol","header::map::ExtraValue","uri::Uri","header::name::StandardHeader","uri::path::PathAndQuery","header::name::Custom","std::clone::impls::<impl std::clone::Clone for *const T>","method::Method","header::map::Link","header::map::Cursor","uri::authority::Authority","uri::scheme::Scheme","header::map::Links"]},"header::map::Drain":{"T":["header::map::IterMut","header::map::Drain","header::map::ValueIterMut","<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Iter"]},"header::map::Entry":{"T":["header::map::OccupiedEntry","response::Parts","request::Parts","version::Version","method::Method","uri::port::Port","uri::Uri","header::name::Custom","header::map::HashValue","uri::scheme::Scheme","error::Error","header::name::Repr","header::value::ToStrError","header::map::Values","header::map::ValueIter","header::map::ValueDrain","uri::InvalidUri","header::map::Cursor","header::map::GetAll","request::Builder","method::InvalidMethod","byte_str::ByteStr","header::map::IterMut","status::InvalidStatusCode","uri::Parts","header::map::ExtraValue","header::map::ValuesMut","header::map::VacantEntry","<*const T as std::fmt::Debug>","status::StatusCode","header::name::MaybeLower","header::name::HeaderName","response::Builder","request::Request","extensions::Extensions","header::map::Keys","header::map::Iter","header::name::StandardHeader","uri::path::PathAndQuery","uri::scheme::Protocol","header::map::Drain","header::map::Link","header::map::ValueIterMut","header::map::HeaderMap","header::name::InvalidHeaderName","header::map::Bucket","header::map::Links","response::Response","header::value::HeaderValue","uri::scheme::Scheme2","header::map::RawLinks","uri::authority::Authority","header::map::Entry","uri::InvalidUriParts","header::name::HdrName","header::map::IntoIter","header::value::InvalidHeaderValue","uri::builder::Builder","uri::ErrorKind"]},"header::map::ExtraValue":{"T":["header::value::HeaderValue","uri::authority::Authority","header::map::Links","header::map::Link","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::ExtraValue","status::StatusCode","byte_str::ByteStr","header::map::Bucket","header::map::HeaderMap","header::name::StandardHeader","uri::path::PathAndQuery","std::clone::impls::<impl std::clone::Clone for &mut T>","header::name::Repr","uri::scheme::Protocol","header::name::MaybeLower","method::Method","version::Version","header::map::HashValue","header::name::HeaderName","header::map::Cursor","header::map::RawLinks","uri::Uri","header::name::Custom"]},"header::map::GetAll":{"T":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::name::Repr","header::name::Custom","header::map::GetAll","header::map::Link","header::name::StandardHeader","version::Version","byte_str::ByteStr","header::map::HeaderMap","header::map::Cursor","header::map::HashValue","uri::ErrorKind"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::GetAll","header::map::VacantEntry","uri::builder::Builder","header::name::HdrName","uri::scheme::Scheme2","header::map::ExtraValue","response::Builder","request::Parts","header::name::HeaderName","uri::port::Port","header::map::IterMut","version::Version","header::name::Repr","header::value::InvalidHeaderValue","response::Response","header::map::Drain","byte_str::ByteStr","header::map::Cursor","header::map::Values","uri::ErrorKind","uri::InvalidUriParts","header::map::ValueIter","uri::InvalidUri","uri::authority::Authority","status::InvalidStatusCode","method::Method","header::name::Custom","request::Request","header::map::HashValue","header::map::ValuesMut","header::map::Keys","uri::Parts","request::Builder","header::name::StandardHeader","header::value::ToStrError","header::map::IntoIter","header::map::OccupiedEntry","uri::scheme::Protocol","header::value::HeaderValue","uri::Uri","header::name::MaybeLower","method::InvalidMethod","header::map::Iter","header::map::ValueIterMut","header::map::HeaderMap","header::map::RawLinks","header::name::InvalidHeaderName","status::StatusCode","error::Error","header::map::Link","header::map::Links","extensions::Extensions","header::map::ValueDrain","<&mut T as std::fmt::Debug>","header::map::Bucket","uri::path::PathAndQuery","header::map::Entry","uri::scheme::Scheme","response::Parts"]},"header::map::Iter":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::Drain","header::map::ValueDrain","<*mut T as std::fmt::Debug>","header::map::Iter"]},"header::map::IterMut":{"T":["header::map::ValueDrain","header::map::Iter","header::map::ValueIterMut","<*mut T as std::fmt::Debug>","header::map::IterMut","header::map::Drain"]},"header::map::Keys":{"T":["header::map::Bucket","header::name::StandardHeader","header::name::Repr","header::name::HdrName","status::InvalidStatusCode","header::map::Link","response::Parts","request::Builder","uri::ErrorKind","header::map::ExtraValue","uri::scheme::Scheme","method::InvalidMethod","header::map::Keys","header::map::Entry","header::map::Links","header::map::IntoIter","uri::scheme::Scheme2","request::Request","uri::port::Port","header::map::Values","header::map::ValuesMut","header::map::RawLinks","error::Error","response::Response","status::StatusCode","header::map::ValueIterMut","uri::builder::Builder","header::map::OccupiedEntry","header::map::IterMut","method::Method","header::value::InvalidHeaderValue","response::Builder","header::map::GetAll","uri::scheme::Protocol","header::name::HeaderName","uri::path::PathAndQuery","uri::InvalidUriParts","uri::InvalidUri","uri::Uri","<*mut T as std::fmt::Debug>","header::map::ValueIter","header::map::ValueDrain","header::map::VacantEntry","uri::Parts","request::Parts","header::value::ToStrError","header::name::InvalidHeaderName","header::map::Cursor","header::value::HeaderValue","header::name::Custom","header::map::HashValue","version::Version","byte_str::ByteStr","header::name::MaybeLower","uri::authority::Authority","header::map::Drain","header::map::Iter","extensions::Extensions","header::map::HeaderMap"]},"header::map::OccupiedEntry":{"T":["uri::scheme::Scheme","header::map::Drain","error::Error","uri::Uri","header::name::HdrName","method::InvalidMethod","header::map::HashValue","uri::Parts","header::map::Link","header::map::Bucket","uri::InvalidUriParts","uri::InvalidUri","header::map::ValuesMut","header::value::ToStrError","header::map::Entry","header::map::Links","status::InvalidStatusCode","header::map::Iter","header::map::RawLinks","byte_str::ByteStr","status::StatusCode","uri::scheme::Protocol","uri::builder::Builder","response::Builder","extensions::Extensions","header::value::InvalidHeaderValue","header::map::ValueIterMut","header::name::Custom","header::map::ExtraValue","uri::authority::Authority","<&mut T as std::fmt::Debug>","uri::ErrorKind","header::map::HeaderMap","uri::scheme::Scheme2","header::name::Repr","response::Response","request::Request","version::Version","header::map::GetAll","uri::port::Port","header::value::HeaderValue","header::map::Values","header::map::ValueIter","header::map::VacantEntry","uri::path::PathAndQuery","header::map::ValueDrain","header::map::OccupiedEntry","header::map::Cursor","header::map::Keys","header::name::HeaderName","request::Builder","header::name::StandardHeader","header::map::IntoIter","header::map::IterMut","response::Parts","header::name::MaybeLower","header::name::InvalidHeaderName","request::Parts","method::Method"]},"header::map::RawLinks":{"T":["uri::Uri","header::map::IterMut","header::name::Custom","uri::port::Port","header::value::HeaderValue","version::Version","extensions::Extensions","header::map::GetAll","header::map::Links","header::map::Values","uri::ErrorKind","<&mut T as std::fmt::Debug>","request::Parts","header::map::Drain","status::InvalidStatusCode","header::map::ValueIterMut","header::name::HdrName","header::value::InvalidHeaderValue","header::name::Repr","header::map::RawLinks","byte_str::ByteStr","response::Parts","header::name::InvalidHeaderName","header::map::Iter","uri::builder::Builder","header::map::ExtraValue","uri::InvalidUri","uri::authority::Authority","header::name::HeaderName","header::map::HashValue","header::map::VacantEntry","error::Error","header::map::IntoIter","header::map::Link","method::Method","uri::InvalidUriParts","header::map::HeaderMap","header::map::ValueIter","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::Entry","uri::Parts","header::value::ToStrError","header::name::StandardHeader","request::Request","header::map::Cursor","header::map::OccupiedEntry","header::map::ValuesMut","header::name::MaybeLower","status::StatusCode","header::map::ValueDrain","uri::scheme::Protocol","header::map::Keys","response::Response","uri::path::PathAndQuery","method::InvalidMethod","header::map::Bucket","response::Builder","request::Builder"]},"header::map::VacantEntry":{"T":["byte_str::ByteStr","uri::InvalidUri","header::value::HeaderValue","header::map::GetAll","uri::Parts","uri::scheme::Protocol","request::Parts","header::map::Entry","header::map::ValueDrain","header::map::HashValue","version::Version","header::name::Repr","uri::port::Port","error::Error","header::map::Iter","status::StatusCode","request::Builder","header::name::InvalidHeaderName","header::map::RawLinks","header::map::Keys","header::name::Custom","header::map::Links","header::map::VacantEntry","method::Method","status::InvalidStatusCode","<&T as std::fmt::Debug>","header::name::StandardHeader","header::map::ValuesMut","uri::builder::Builder","header::value::InvalidHeaderValue","header::map::ExtraValue","uri::scheme::Scheme","header::map::Bucket","request::Request","header::map::ValueIterMut","response::Builder","uri::path::PathAndQuery","response::Parts","header::name::HeaderName","header::map::ValueIter","method::InvalidMethod","header::map::Values","uri::authority::Authority","uri::scheme::Scheme2","header::name::HdrName","uri::ErrorKind","header::map::Link","header::map::IntoIter","header::map::Cursor","header::map::IterMut","header::name::MaybeLower","header::map::Drain","response::Response","extensions::Extensions","header::map::HeaderMap","header::value::ToStrError","header::map::OccupiedEntry","uri::Uri","uri::InvalidUriParts"]},"header::map::ValueDrain":{"T":["header::map::Drain","header::map::ValueDrain","<*mut T as std::marker::Send>","header::map::ValueIterMut","header::map::IterMut","header::map::Iter"]},"header::map::ValueIter":{"T":["uri::scheme::Protocol","<*const T as std::fmt::Debug>","header::name::HdrName","header::map::IterMut","header::name::MaybeLower","request::Builder","header::map::Iter","header::value::HeaderValue","uri::scheme::Scheme2","header::map::HashValue","header::map::HeaderMap","header::map::GetAll","header::map::Bucket","uri::InvalidUri","request::Request","byte_str::ByteStr","response::Parts","header::map::ExtraValue","header::map::OccupiedEntry","header::map::ValueIterMut","header::value::ToStrError","version::Version","header::name::StandardHeader","request::Parts","header::map::Values","uri::path::PathAndQuery","header::name::HeaderName","header::map::ValuesMut","uri::builder::Builder","status::StatusCode","response::Response","header::name::Repr","header::map::Entry","header::name::Custom","status::InvalidStatusCode","header::value::InvalidHeaderValue","uri::authority::Authority","header::map::ValueIter","header::map::Link","uri::Parts","response::Builder","extensions::Extensions","header::name::InvalidHeaderName","uri::port::Port","error::Error","header::map::IntoIter","header::map::Cursor","header::map::RawLinks","header::map::Links","uri::InvalidUriParts","method::InvalidMethod","header::map::VacantEntry","header::map::Drain","header::map::Keys","header::map::ValueDrain","method::Method","uri::Uri","uri::ErrorKind","uri::scheme::Scheme"]},"header::map::ValueIterMut":{"T":["header::map::Drain","header::map::IterMut","header::map::ValueIterMut","<*mut T as std::fmt::Debug>","header::map::Iter","header::map::ValueDrain"]},"header::map::Values":{"T":["method::InvalidMethod","header::map::Link","status::StatusCode","header::name::MaybeLower","uri::scheme::Scheme","uri::scheme::Scheme2","header::name::StandardHeader","header::map::ValueIter","header::name::HeaderName","response::Builder","header::map::VacantEntry","<*mut T as std::fmt::Debug>","uri::port::Port","header::map::ValuesMut","extensions::Extensions","response::Parts","header::map::Keys","header::map::IntoIter","uri::authority::Authority","header::map::Bucket","header::value::HeaderValue","header::name::InvalidHeaderName","header::map::Drain","header::value::InvalidHeaderValue","method::Method","header::map::Entry","uri::Parts","error::Error","status::InvalidStatusCode","uri::scheme::Protocol","header::name::Custom","header::map::IterMut","header::map::Iter","header::map::Cursor","header::map::ExtraValue","header::map::RawLinks","request::Parts","response::Response","uri::ErrorKind","uri::Uri","uri::path::PathAndQuery","version::Version","byte_str::ByteStr","request::Request","uri::builder::Builder","header::name::HdrName","header::map::ValueDrain","header::map::OccupiedEntry","header::map::GetAll","header::map::Values","header::map::HashValue","uri::InvalidUri","header::map::ValueIterMut","header::map::HeaderMap","header::value::ToStrError","header::name::Repr","request::Builder","header::map::Links","uri::InvalidUriParts"]},"header::map::ValuesMut":{"T":["uri::port::Port","response::Parts","header::map::Keys","<*mut T as std::fmt::Debug>","header::map::IntoIter","header::map::HeaderMap","header::map::IterMut","header::map::VacantEntry","header::map::RawLinks","header::map::Bucket","header::map::ValueIter","header::map::ValueIterMut","request::Parts","error::Error","extensions::Extensions","uri::path::PathAndQuery","response::Response","method::Method","header::map::ValuesMut","method::InvalidMethod","byte_str::ByteStr","header::value::HeaderValue","uri::Uri","version::Version","header::map::Values","header::name::Custom","header::name::HeaderName","header::map::Link","header::name::InvalidHeaderName","uri::authority::Authority","header::map::Drain","header::map::Iter","header::name::StandardHeader","header::value::ToStrError","header::value::InvalidHeaderValue","status::StatusCode","uri::builder::Builder","uri::ErrorKind","uri::scheme::Scheme","header::map::ExtraValue","header::map::ValueDrain","uri::scheme::Protocol","uri::Parts","header::name::MaybeLower","header::map::HashValue","uri::InvalidUri","header::map::Entry","request::Builder","header::name::Repr","header::map::OccupiedEntry","header::map::GetAll","response::Builder","header::name::HdrName","header::map::Cursor","request::Request","status::InvalidStatusCode","uri::InvalidUriParts","uri::scheme::Scheme2","header::map::Links"]},"header::name::Repr":{"T":["header::name::Repr","header::name::Custom","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","byte_str::ByteStr","version::Version","header::name::StandardHeader"]},"request::Request":{"T":["version::Version","response::Builder","request::Request","uri::Uri","header::map::HeaderMap","response::Response","extensions::Extensions","method::Method","status::StatusCode","request::Builder","uri::builder::Builder","uri::Parts"]},"response::Response":{"T":["method::Method","status::StatusCode","uri::Parts","response::Builder","uri::builder::Builder","uri::Uri","extensions::Extensions","request::Request","response::Response","header::map::HeaderMap","version::Version","request::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["uri::scheme::Scheme","uri::port::Port","method::Method","uri::authority::Authority","<&mut T as std::fmt::Debug>","header::value::HeaderValue"]},"uri::scheme::Scheme2":{"T":["uri::scheme::Scheme","header::name::Custom","uri::scheme::Scheme2","uri::path::PathAndQuery","uri::scheme::Protocol","header::map::ExtraValue","std::clone::impls::<impl std::clone::Clone for &mut T>","version::Version","uri::Uri","header::map::Bucket","byte_str::ByteStr","status::StatusCode","header::map::HeaderMap","header::name::Repr","header::map::Cursor","header::map::Link","method::Method","header::map::Links","header::name::HeaderName","uri::authority::Authority","header::map::HashValue","std::boxed::Box<byte_str::ByteStr>","header::value::HeaderValue","header::map::RawLinks","header::name::StandardHeader","header::name::MaybeLower"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::IterMut<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::IterMut<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::IterMut<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::IterMut<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::IntoIter<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::IntoIter<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Send","std::marker::Sync"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::GetAll":{"T":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::convert::TryFrom"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Send","std::marker::Sync","std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::marker::Sized","std::hash::Hash","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::marker::Sized","std::fmt::Debug","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::IntoIter<T> as std::fmt::Debug>::fmt":{"T":["method::Method","status::InvalidStatusCode","uri::InvalidUriParts","header::map::GetAll","header::value::ToStrError","uri::ErrorKind","response::Builder","uri::authority::Authority","header::map::OccupiedEntry","header::map::RawLinks","<*mut T as std::fmt::Debug>","header::name::StandardHeader","uri::scheme::Scheme2","header::map::Iter","header::map::Cursor","status::StatusCode","version::Version","byte_str::ByteStr","header::name::Repr","header::map::Bucket","response::Response","header::map::ValueDrain","uri::scheme::Scheme","method::InvalidMethod","header::map::IterMut","header::map::ExtraValue","header::map::HashValue","header::map::HeaderMap","uri::path::PathAndQuery","header::map::Entry","header::map::Drain","request::Request","uri::builder::Builder","error::Error","<&T as std::fmt::Debug>","uri::port::Port","header::map::ValueIterMut","header::name::Custom","header::map::Links","uri::InvalidUri","uri::Uri","header::name::MaybeLower","header::map::VacantEntry","extensions::Extensions","header::map::Keys","response::Parts","header::name::HeaderName","header::map::ValuesMut","header::map::Link","header::name::HdrName","header::name::InvalidHeaderName","header::value::InvalidHeaderValue","header::map::ValueIter","header::map::Values","request::Parts","request::Builder","header::value::HeaderValue","uri::Parts","header::map::IntoIter","uri::scheme::Protocol"]},"header::map::Bucket":{"T":["header::map::Links","header::map::HashValue","header::name::MaybeLower","header::name::Repr","method::Method","header::map::RawLinks","uri::scheme::Protocol","header::map::ExtraValue","header::name::StandardHeader","header::name::HeaderName","uri::path::PathAndQuery","uri::Uri","byte_str::ByteStr","header::value::HeaderValue","header::map::HeaderMap","uri::scheme::Scheme2","header::map::Link","header::map::Cursor","header::name::Custom","<&T as std::fmt::Debug>","uri::scheme::Scheme","uri::authority::Authority","header::map::Bucket","version::Version","status::StatusCode"]},"header::map::Drain":{"T":["header::map::Iter","header::map::Drain","<*mut T as std::fmt::Debug>","header::map::ValueDrain","header::map::ValueIterMut","header::map::IterMut"]},"header::map::Entry":{"T":["header::map::Iter","version::Version","header::name::StandardHeader","uri::path::PathAndQuery","header::value::HeaderValue","header::map::IntoIter","header::map::Link","method::InvalidMethod","extensions::Extensions","header::name::Repr","header::map::ValueIterMut","<&mut T as std::fmt::Debug>","header::map::VacantEntry","uri::scheme::Scheme","header::map::GetAll","request::Builder","header::map::Values","header::map::Links","uri::scheme::Protocol","header::name::InvalidHeaderName","header::name::MaybeLower","header::value::InvalidHeaderValue","uri::port::Port","uri::InvalidUri","header::map::Keys","header::map::HeaderMap","header::map::RawLinks","header::map::ExtraValue","header::map::Bucket","status::InvalidStatusCode","header::map::OccupiedEntry","header::map::ValueDrain","byte_str::ByteStr","response::Response","error::Error","header::map::IterMut","header::map::Drain","response::Parts","uri::builder::Builder","header::map::ValuesMut","header::value::ToStrError","method::Method","header::map::HashValue","header::name::HeaderName","uri::ErrorKind","header::name::HdrName","response::Builder","request::Request","header::map::ValueIter","uri::Parts","header::map::Entry","uri::authority::Authority","header::name::Custom","request::Parts","uri::InvalidUriParts","uri::scheme::Scheme2","header::map::Cursor","uri::Uri","status::StatusCode"]},"header::map::ExtraValue":{"T":["uri::scheme::Protocol","method::Method","status::StatusCode","uri::Uri","<&mut T as std::fmt::Debug>","header::name::Custom","version::Version","header::map::Cursor","header::value::HeaderValue","header::map::RawLinks","header::map::HeaderMap","header::name::StandardHeader","uri::authority::Authority","uri::scheme::Scheme2","header::map::Links","header::name::Repr","header::map::Link","header::map::ExtraValue","header::map::HashValue","uri::scheme::Scheme","header::name::MaybeLower","byte_str::ByteStr","header::map::Bucket","uri::path::PathAndQuery","header::name::HeaderName"]},"header::map::GetAll":{"T":["header::map::GetAll","uri::ErrorKind","header::map::HeaderMap","header::map::Link","header::map::Cursor","byte_str::ByteStr","header::name::Custom","std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>","header::map::HashValue","header::name::StandardHeader","header::name::Repr","version::Version"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["uri::builder::Builder","response::Builder","header::name::HdrName","header::map::ValueIter","header::name::InvalidHeaderName","uri::InvalidUri","header::map::RawLinks","uri::scheme::Protocol","header::value::HeaderValue","error::Error","header::map::Values","byte_str::ByteStr","header::map::IterMut","response::Response","uri::Parts","version::Version","uri::scheme::Scheme","header::map::Keys","header::name::HeaderName","request::Builder","uri::port::Port","header::map::ExtraValue","header::map::IntoIter","header::map::HeaderMap","header::name::StandardHeader","method::InvalidMethod","response::Parts","header::map::Bucket","header::map::Cursor","status::InvalidStatusCode","<&T as std::fmt::Debug>","uri::InvalidUriParts","header::map::ValuesMut","header::map::Links","header::value::ToStrError","uri::path::PathAndQuery","method::Method","header::map::Drain","header::value::InvalidHeaderValue","header::name::Custom","header::name::Repr","extensions::Extensions","status::StatusCode","header::map::Link","header::map::GetAll","request::Request","uri::authority::Authority","uri::Uri","request::Parts","header::name::MaybeLower","uri::ErrorKind","header::map::HashValue","header::map::Entry","uri::scheme::Scheme2","header::map::ValueIterMut","header::map::VacantEntry","header::map::OccupiedEntry","header::map::ValueDrain","header::map::Iter"]},"header::map::Iter":{"T":["header::map::ValueDrain","header::map::ValueIterMut","header::map::Iter","<*mut T as std::fmt::Debug>","header::map::IterMut","header::map::Drain"]},"header::map::IterMut":{"T":["<*mut T as std::fmt::Debug>","header::map::Drain","header::map::IterMut","header::map::Iter","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::Keys":{"T":["request::Builder","uri::Uri","header::map::Cursor","<&mut T as std::fmt::Debug>","request::Parts","header::map::OccupiedEntry","header::map::IntoIter","header::map::GetAll","uri::port::Port","uri::scheme::Scheme","byte_str::ByteStr","uri::InvalidUri","method::Method","header::name::HeaderName","header::map::Bucket","header::map::Keys","header::name::Custom","header::map::ValuesMut","header::map::IterMut","extensions::Extensions","uri::authority::Authority","header::map::RawLinks","header::name::MaybeLower","method::InvalidMethod","header::map::VacantEntry","header::name::Repr","header::map::Drain","header::map::ValueDrain","uri::scheme::Scheme2","header::value::ToStrError","header::map::Link","status::InvalidStatusCode","uri::ErrorKind","uri::Parts","header::name::StandardHeader","error::Error","status::StatusCode","header::map::Entry","uri::path::PathAndQuery","header::name::HdrName","uri::builder::Builder","header::map::ValueIter","header::map::Iter","header::value::InvalidHeaderValue","header::map::ValueIterMut","header::map::Links","uri::scheme::Protocol","header::map::HashValue","header::name::InvalidHeaderName","response::Builder","header::map::ExtraValue","request::Request","response::Parts","header::map::Values","header::map::HeaderMap","response::Response","version::Version","header::value::HeaderValue","uri::InvalidUriParts"]},"header::map::OccupiedEntry":{"T":["uri::InvalidUriParts","request::Builder","<*const T as std::fmt::Debug>","method::Method","version::Version","header::map::Drain","header::map::OccupiedEntry","header::value::ToStrError","header::name::HeaderName","header::map::Values","header::map::Entry","error::Error","uri::scheme::Protocol","header::name::Repr","status::InvalidStatusCode","header::map::IterMut","header::value::HeaderValue","header::name::InvalidHeaderName","response::Parts","status::StatusCode","uri::Parts","uri::scheme::Scheme","header::name::HdrName","header::map::RawLinks","header::map::ValueIterMut","header::map::Link","header::map::Keys","header::name::Custom","response::Response","header::map::HashValue","header::name::MaybeLower","uri::builder::Builder","header::map::Cursor","header::map::IntoIter","header::map::ValueDrain","header::map::ExtraValue","header::map::GetAll","header::value::InvalidHeaderValue","header::map::Links","uri::path::PathAndQuery","header::name::StandardHeader","request::Request","response::Builder","uri::authority::Authority","uri::ErrorKind","header::map::HeaderMap","byte_str::ByteStr","header::map::ValuesMut","method::InvalidMethod","header::map::Iter","uri::scheme::Scheme2","header::map::ValueIter","uri::port::Port","request::Parts","uri::Uri","extensions::Extensions","header::map::VacantEntry","header::map::Bucket","uri::InvalidUri"]},"header::map::RawLinks":{"T":["status::StatusCode","header::map::Bucket","header::map::Values","uri::authority::Authority","error::Error","uri::port::Port","header::name::InvalidHeaderName","header::map::Drain","header::name::HdrName","request::Request","response::Response","header::name::HeaderName","header::map::ValueDrain","byte_str::ByteStr","header::map::Entry","header::map::RawLinks","header::map::IterMut","header::value::InvalidHeaderValue","header::map::GetAll","uri::builder::Builder","header::map::Link","request::Builder","uri::path::PathAndQuery","header::map::OccupiedEntry","uri::scheme::Protocol","header::map::VacantEntry","request::Parts","header::map::HeaderMap","header::map::ValuesMut","header::map::HashValue","uri::ErrorKind","method::Method","version::Version","uri::InvalidUri","header::value::HeaderValue","uri::scheme::Scheme","uri::scheme::Scheme2","header::map::ValueIter","header::map::Cursor","uri::InvalidUriParts","header::map::ValueIterMut","header::name::MaybeLower","header::map::IntoIter","uri::Uri","response::Builder","header::map::Keys","extensions::Extensions","header::map::Links","<&mut T as std::fmt::Debug>","header::name::Repr","response::Parts","header::map::Iter","method::InvalidMethod","uri::Parts","header::map::ExtraValue","status::InvalidStatusCode","header::value::ToStrError","header::name::StandardHeader","header::name::Custom"]},"header::map::VacantEntry":{"T":["method::InvalidMethod","header::map::ValueIterMut","header::name::Custom","header::map::GetAll","header::value::InvalidHeaderValue","header::value::HeaderValue","method::Method","error::Error","header::map::Drain","uri::scheme::Scheme","header::name::HeaderName","byte_str::ByteStr","uri::port::Port","uri::Uri","uri::InvalidUriParts","header::map::Keys","header::map::ValueIter","header::map::Links","header::name::HdrName","header::map::Values","response::Parts","request::Request","uri::scheme::Protocol","<&T as std::fmt::Debug>","uri::Parts","header::map::OccupiedEntry","status::InvalidStatusCode","header::map::ValueDrain","response::Response","header::map::Iter","header::map::Entry","header::name::MaybeLower","uri::authority::Authority","uri::path::PathAndQuery","header::map::Cursor","header::map::RawLinks","header::map::HeaderMap","header::map::VacantEntry","header::map::ValuesMut","header::map::HashValue","header::map::Bucket","uri::InvalidUri","request::Parts","header::name::Repr","request::Builder","header::map::Link","header::name::StandardHeader","header::map::IntoIter","header::map::ExtraValue","extensions::Extensions","header::map::IterMut","version::Version","uri::builder::Builder","uri::ErrorKind","status::StatusCode","header::value::ToStrError","header::name::InvalidHeaderName","response::Builder","uri::scheme::Scheme2"]},"header::map::ValueDrain":{"T":["header::map::ValueIterMut","<*const T as std::marker::Sync>","header::map::ValueDrain","header::map::IterMut","header::map::Drain","header::map::Iter"]},"header::map::ValueIter":{"T":["status::InvalidStatusCode","header::map::OccupiedEntry","uri::ErrorKind","uri::scheme::Protocol","header::map::HashValue","header::name::StandardHeader","header::name::MaybeLower","header::map::IntoIter","request::Parts","header::map::Link","method::InvalidMethod","response::Builder","header::map::Bucket","uri::InvalidUri","uri::path::PathAndQuery","header::map::Cursor","uri::InvalidUriParts","header::value::HeaderValue","header::map::Entry","status::StatusCode","method::Method","header::map::ValueIterMut","extensions::Extensions","response::Parts","header::name::HdrName","header::name::Custom","<&T as std::fmt::Debug>","header::map::IterMut","request::Builder","header::name::HeaderName","header::map::ValuesMut","response::Response","header::map::ValueDrain","header::map::Values","header::map::ExtraValue","request::Request","uri::port::Port","header::value::ToStrError","byte_str::ByteStr","error::Error","header::value::InvalidHeaderValue","uri::authority::Authority","uri::builder::Builder","header::map::HeaderMap","uri::scheme::Scheme2","uri::Parts","version::Version","uri::Uri","header::map::VacantEntry","header::name::Repr","header::map::Iter","header::map::ValueIter","header::map::Keys","header::map::GetAll","header::map::Drain","header::map::RawLinks","uri::scheme::Scheme","header::name::InvalidHeaderName","header::map::Links"]},"header::map::ValueIterMut":{"T":["header::map::Iter","header::map::Drain","header::map::ValueIterMut","<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::IterMut"]},"header::map::Values":{"T":["response::Parts","header::value::InvalidHeaderValue","method::Method","request::Parts","request::Request","header::map::Iter","header::map::Links","header::value::HeaderValue","header::name::HdrName","uri::ErrorKind","header::name::Repr","header::map::Entry","uri::InvalidUriParts","error::Error","header::map::IntoIter","header::map::Link","header::map::ValueIter","header::map::RawLinks","response::Builder","header::map::VacantEntry","uri::port::Port","header::map::ExtraValue","header::map::Keys","header::name::Custom","header::map::OccupiedEntry","request::Builder","uri::Parts","header::name::HeaderName","header::map::HeaderMap","uri::Uri","header::map::Cursor","header::map::IterMut","header::name::StandardHeader","header::map::GetAll","<*const T as std::fmt::Debug>","uri::InvalidUri","uri::scheme::Scheme2","uri::builder::Builder","header::value::ToStrError","header::map::Values","header::name::InvalidHeaderName","response::Response","version::Version","header::map::Drain","byte_str::ByteStr","extensions::Extensions","uri::scheme::Protocol","method::InvalidMethod","header::name::MaybeLower","header::map::ValueIterMut","status::InvalidStatusCode","header::map::Bucket","header::map::ValueDrain","uri::scheme::Scheme","header::map::ValuesMut","status::StatusCode","uri::path::PathAndQuery","uri::authority::Authority","header::map::HashValue"]},"header::map::ValuesMut":{"T":["uri::port::Port","header::map::OccupiedEntry","header::map::HeaderMap","header::name::MaybeLower","uri::InvalidUri","header::map::Links","uri::Parts","header::map::IterMut","header::name::HeaderName","version::Version","header::map::Bucket","uri::ErrorKind","uri::Uri","uri::scheme::Scheme","header::map::ExtraValue","response::Parts","response::Response","header::map::Iter","header::value::ToStrError","uri::authority::Authority","header::map::VacantEntry","header::name::InvalidHeaderName","header::value::InvalidHeaderValue","uri::scheme::Protocol","response::Builder","header::map::GetAll","status::StatusCode","header::name::StandardHeader","<*const T as std::fmt::Debug>","header::map::Cursor","header::map::HashValue","header::name::Custom","method::Method","header::map::ValuesMut","header::name::HdrName","header::value::HeaderValue","header::map::Entry","error::Error","byte_str::ByteStr","uri::builder::Builder","header::map::ValueIterMut","request::Request","status::InvalidStatusCode","header::map::Link","header::map::IntoIter","header::map::Values","header::name::Repr","header::map::ValueIter","request::Parts","extensions::Extensions","method::InvalidMethod","uri::scheme::Scheme2","header::map::RawLinks","header::map::Keys","header::map::Drain","uri::InvalidUriParts","request::Builder","uri::path::PathAndQuery","header::map::ValueDrain"]},"header::name::Repr":{"T":["byte_str::ByteStr","std::clone::impls::<impl std::clone::Clone for *const T>","version::Version","header::name::Custom","header::name::Repr","header::name::StandardHeader"]},"request::Request":{"T":["uri::Uri","response::Response","version::Version","status::StatusCode","request::Builder","request::Request","uri::Parts","extensions::Extensions","method::Method","header::map::HeaderMap","response::Builder","uri::builder::Builder"]},"response::Response":{"T":["request::Builder","response::Builder","header::map::HeaderMap","method::Method","request::Request","version::Version","response::Response","status::StatusCode","uri::Parts","uri::Uri","extensions::Extensions","uri::builder::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["<&mut T as std::convert::AsRef<U>>","uri::port::Port","method::Method","header::value::HeaderValue","uri::scheme::Scheme","uri::authority::Authority"]},"uri::scheme::Scheme2":{"T":["header::value::HeaderValue","status::StatusCode","uri::authority::Authority","header::name::Custom","method::Method","uri::scheme::Protocol","header::map::Links","uri::path::PathAndQuery","std::boxed::Box<byte_str::ByteStr>","uri::scheme::Scheme2","header::map::Bucket","header::name::StandardHeader","header::name::HeaderName","header::name::MaybeLower","header::map::HeaderMap","uri::scheme::Scheme","header::name::Repr","uri::Uri","version::Version","<*const T as std::fmt::Debug>","byte_str::ByteStr","header::map::Link","header::map::Cursor","header::map::HashValue","header::map::ExtraValue","header::map::RawLinks"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::IntoIter<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::IntoIter<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::IntoIter<T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::IntoIter<T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::Keys<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Keys<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::convert::TryFrom","std::cmp::PartialEq","std::cmp::Eq"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug","std::marker::Sync"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::hash::Hash","std::cmp::Eq"]},"request::Request":{"T":["std::default::Default","std::marker::Sized","std::fmt::Debug"]},"response::Response":{"T":["std::default::Default","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Keys<'a, T> as std::fmt::Debug>::fmt":{"T":["header::map::IterMut","header::map::IntoIter","header::map::Cursor","status::InvalidStatusCode","header::value::InvalidHeaderValue","header::map::ExtraValue","status::StatusCode","header::map::GetAll","header::value::ToStrError","header::name::Custom","header::map::Drain","uri::scheme::Protocol","header::map::HeaderMap","request::Builder","request::Request","uri::Uri","byte_str::ByteStr","header::value::HeaderValue","header::name::Repr","uri::Parts","header::map::HashValue","header::map::Link","uri::scheme::Scheme2","uri::port::Port","header::map::VacantEntry","header::map::Iter","version::Version","uri::ErrorKind","<&T as std::fmt::Debug>","response::Response","header::name::InvalidHeaderName","header::map::Values","header::map::Bucket","error::Error","header::name::HdrName","header::map::ValuesMut","uri::builder::Builder","header::map::ValueIterMut","<*const T as std::fmt::Debug>","method::InvalidMethod","header::name::StandardHeader","header::name::MaybeLower","method::Method","request::Parts","uri::InvalidUriParts","uri::authority::Authority","uri::InvalidUri","header::name::HeaderName","header::map::ValueDrain","response::Builder","extensions::Extensions","header::map::ValueIter","uri::scheme::Scheme","header::map::RawLinks","header::map::Links","header::map::Entry","uri::path::PathAndQuery","response::Parts","header::map::Keys","header::map::OccupiedEntry"]},"header::map::Bucket":{"T":["header::map::HeaderMap","<*mut T as std::fmt::Debug>","header::name::Repr","method::Method","header::map::Cursor","uri::Uri","header::map::Link","status::StatusCode","header::name::HeaderName","byte_str::ByteStr","header::map::RawLinks","uri::scheme::Scheme","header::map::Links","uri::scheme::Scheme2","uri::scheme::Protocol","header::map::ExtraValue","header::value::HeaderValue","header::map::Bucket","header::map::HashValue","uri::path::PathAndQuery","header::name::Custom","header::name::StandardHeader","uri::authority::Authority","header::name::MaybeLower","version::Version"]},"header::map::Drain":{"T":["header::map::ValueIterMut","header::map::Drain","<*mut T as std::marker::Send>","header::map::ValueDrain","header::map::IterMut","header::map::Iter"]},"header::map::Entry":{"T":["request::Builder","version::Version","header::map::HashValue","method::Method","header::value::ToStrError","header::map::ValueIter","request::Parts","header::map::ValuesMut","header::map::Keys","header::name::InvalidHeaderName","header::map::Values","uri::authority::Authority","header::map::ExtraValue","header::map::Cursor","header::map::Drain","header::value::InvalidHeaderValue","uri::scheme::Scheme","header::name::HdrName","header::name::Repr","response::Parts","status::StatusCode","uri::InvalidUri","header::map::Iter","uri::Uri","header::map::GetAll","header::map::HeaderMap","request::Request","uri::scheme::Scheme2","header::map::OccupiedEntry","header::map::IntoIter","uri::path::PathAndQuery","header::map::Link","header::name::MaybeLower","header::name::HeaderName","header::map::Bucket","uri::ErrorKind","status::InvalidStatusCode","header::name::Custom","uri::port::Port","header::map::Entry","header::map::ValueDrain","error::Error","uri::scheme::Protocol","method::InvalidMethod","response::Response","byte_str::ByteStr","header::map::Links","header::value::HeaderValue","uri::InvalidUriParts","uri::builder::Builder","header::map::IterMut","header::map::VacantEntry","response::Builder","uri::Parts","extensions::Extensions","<&mut T as std::fmt::Debug>","header::map::RawLinks","header::name::StandardHeader","header::map::ValueIterMut"]},"header::map::ExtraValue":{"T":["version::Version","status::StatusCode","header::name::MaybeLower","header::name::Custom","uri::scheme::Scheme","uri::Uri","std::clone::impls::<impl std::clone::Clone for *const T>","header::name::Repr","header::name::StandardHeader","header::map::Bucket","header::map::Cursor","method::Method","header::name::HeaderName","header::map::Links","uri::scheme::Scheme2","header::map::RawLinks","uri::scheme::Protocol","uri::path::PathAndQuery","header::map::Link","header::map::ExtraValue","header::map::HeaderMap","header::map::HashValue","header::value::HeaderValue","byte_str::ByteStr","uri::authority::Authority"]},"header::map::GetAll":{"T":["header::map::Link","header::map::GetAll","version::Version","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::name::Custom","header::map::HashValue","uri::ErrorKind","header::map::HeaderMap","byte_str::ByteStr","header::name::Repr","header::name::StandardHeader","header::map::Cursor"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["header::map::Bucket","uri::scheme::Scheme","version::Version","header::map::ValueIter","header::name::HdrName","header::map::Cursor","uri::path::PathAndQuery","header::map::ValuesMut","header::map::ExtraValue","header::map::Values","uri::scheme::Scheme2","header::map::ValueDrain","method::Method","response::Response","header::map::ValueIterMut","header::value::InvalidHeaderValue","header::map::HashValue","header::name::StandardHeader","header::name::Custom","header::map::Iter","byte_str::ByteStr","status::InvalidStatusCode","extensions::Extensions","header::map::IterMut","header::map::Keys","uri::InvalidUri","header::value::HeaderValue","request::Request","header::map::Entry","uri::builder::Builder","uri::Uri","header::map::IntoIter","header::map::HeaderMap","header::name::Repr","header::value::ToStrError","method::InvalidMethod","uri::port::Port","uri::Parts","request::Builder","<*const T as std::fmt::Debug>","header::map::Drain","response::Parts","response::Builder","header::map::Link","uri::InvalidUriParts","error::Error","uri::scheme::Protocol","header::map::RawLinks","header::map::VacantEntry","uri::ErrorKind","uri::authority::Authority","request::Parts","header::map::OccupiedEntry","header::name::InvalidHeaderName","header::name::HeaderName","status::StatusCode","header::map::Links","header::name::MaybeLower","header::map::GetAll"]},"header::map::Iter":{"T":["header::map::IterMut","header::map::Iter","header::map::ValueDrain","header::map::ValueIterMut","<*const T as std::marker::Sync>","header::map::Drain"]},"header::map::IterMut":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::Drain","<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Iter"]},"header::map::Keys":{"T":["header::map::Link","error::Error","header::map::VacantEntry","uri::ErrorKind","header::map::RawLinks","header::value::ToStrError","uri::InvalidUri","header::name::Custom","uri::scheme::Protocol","header::value::InvalidHeaderValue","uri::authority::Authority","header::map::Iter","header::name::InvalidHeaderName","header::map::ValueIter","header::name::Repr","uri::scheme::Scheme","<&mut T as std::fmt::Debug>","uri::InvalidUriParts","uri::builder::Builder","header::map::Values","version::Version","header::map::HeaderMap","header::map::Entry","header::map::ExtraValue","uri::path::PathAndQuery","status::InvalidStatusCode","header::map::IntoIter","uri::Parts","extensions::Extensions","header::map::GetAll","uri::port::Port","header::map::ValuesMut","header::map::HashValue","header::name::StandardHeader","header::map::Bucket","header::map::ValueIterMut","response::Parts","header::name::MaybeLower","response::Response","header::map::OccupiedEntry","uri::Uri","request::Builder","status::StatusCode","request::Request","request::Parts","header::name::HdrName","header::map::Cursor","response::Builder","header::map::Links","method::InvalidMethod","header::map::IterMut","header::map::ValueDrain","header::map::Keys","header::map::Drain","method::Method","header::value::HeaderValue","header::name::HeaderName","uri::scheme::Scheme2","byte_str::ByteStr"]},"header::map::OccupiedEntry":{"T":["method::InvalidMethod","header::map::ExtraValue","uri::InvalidUri","extensions::Extensions","header::name::InvalidHeaderName","header::name::Custom","uri::authority::Authority","header::value::HeaderValue","header::map::IterMut","header::map::Iter","header::map::ValueDrain","uri::ErrorKind","header::map::Links","header::map::Values","header::map::Cursor","header::map::Keys","header::name::MaybeLower","uri::scheme::Protocol","header::map::OccupiedEntry","<&mut T as std::fmt::Debug>","header::map::ValueIterMut","header::map::VacantEntry","header::map::HeaderMap","request::Parts","uri::port::Port","status::InvalidStatusCode","header::name::StandardHeader","header::map::RawLinks","header::map::Drain","uri::path::PathAndQuery","header::map::ValueIter","uri::builder::Builder","response::Builder","header::map::Entry","request::Request","header::name::HdrName","status::StatusCode","uri::InvalidUriParts","uri::scheme::Scheme2","header::name::HeaderName","header::map::Bucket","header::map::HashValue","header::value::ToStrError","header::map::ValuesMut","header::map::IntoIter","uri::Parts","request::Builder","header::map::Link","header::name::Repr","byte_str::ByteStr","error::Error","version::Version","response::Parts","header::map::GetAll","header::value::InvalidHeaderValue","uri::scheme::Scheme","method::Method","response::Response","uri::Uri"]},"header::map::RawLinks":{"T":["header::map::Keys","header::map::GetAll","header::name::MaybeLower","header::map::ExtraValue","request::Builder","header::name::HdrName","request::Parts","header::map::ValueIterMut","method::Method","header::name::Repr","header::value::InvalidHeaderValue","header::map::RawLinks","uri::port::Port","header::map::Values","header::map::HeaderMap","header::name::HeaderName","uri::Uri","header::map::OccupiedEntry","status::StatusCode","uri::authority::Authority","<*mut T as std::fmt::Debug>","header::map::Links","uri::scheme::Scheme","uri::scheme::Scheme2","method::InvalidMethod","uri::ErrorKind","uri::Parts","header::map::Link","response::Response","header::map::ValueIter","header::map::Iter","header::map::VacantEntry","header::map::Bucket","uri::path::PathAndQuery","uri::scheme::Protocol","header::map::IntoIter","header::value::HeaderValue","request::Request","error::Error","extensions::Extensions","uri::InvalidUri","header::map::HashValue","uri::InvalidUriParts","byte_str::ByteStr","header::map::ValuesMut","header::name::StandardHeader","header::name::Custom","response::Parts","status::InvalidStatusCode","header::map::IterMut","header::map::Entry","header::value::ToStrError","response::Builder","uri::builder::Builder","header::name::InvalidHeaderName","header::map::ValueDrain","header::map::Cursor","version::Version","header::map::Drain"]},"header::map::VacantEntry":{"T":["uri::authority::Authority","uri::port::Port","header::map::OccupiedEntry","uri::scheme::Scheme","header::value::ToStrError","header::map::HashValue","header::name::Repr","uri::scheme::Scheme2","header::map::Values","header::name::StandardHeader","uri::Uri","header::value::InvalidHeaderValue","header::map::ValuesMut","header::map::Link","header::name::Custom","request::Builder","method::Method","header::map::IterMut","header::map::ValueDrain","status::StatusCode","uri::path::PathAndQuery","header::map::Drain","uri::ErrorKind","request::Parts","header::name::HeaderName","header::name::InvalidHeaderName","<&mut T as std::fmt::Debug>","header::name::HdrName","status::InvalidStatusCode","header::map::Cursor","response::Parts","header::map::ExtraValue","header::map::ValueIterMut","uri::InvalidUri","header::map::GetAll","header::map::RawLinks","byte_str::ByteStr","header::value::HeaderValue","header::map::Iter","error::Error","version::Version","uri::scheme::Protocol","extensions::Extensions","header::map::Links","uri::InvalidUriParts","header::map::ValueIter","uri::Parts","header::map::VacantEntry","header::map::Entry","response::Builder","header::map::Bucket","response::Response","request::Request","method::InvalidMethod","header::map::IntoIter","header::map::Keys","header::map::HeaderMap","header::name::MaybeLower","uri::builder::Builder"]},"header::map::ValueDrain":{"T":["header::map::Drain","header::map::Iter","header::map::IterMut","<*mut T as std::fmt::Debug>","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::ValueIter":{"T":["header::map::Drain","header::map::Iter","header::name::Repr","header::map::GetAll","uri::authority::Authority","header::map::Bucket","request::Builder","header::map::HeaderMap","header::map::ValueIter","header::name::InvalidHeaderName","uri::builder::Builder","uri::port::Port","status::StatusCode","header::value::InvalidHeaderValue","header::name::StandardHeader","uri::scheme::Protocol","status::InvalidStatusCode","header::map::Keys","header::map::Link","response::Builder","extensions::Extensions","header::map::ValuesMut","header::value::HeaderValue","header::name::HdrName","uri::Uri","request::Request","header::map::ExtraValue","uri::path::PathAndQuery","header::map::ValueDrain","<&mut T as std::fmt::Debug>","error::Error","uri::InvalidUriParts","header::map::Links","uri::scheme::Scheme","response::Response","byte_str::ByteStr","header::map::Cursor","header::map::IterMut","uri::InvalidUri","uri::scheme::Scheme2","header::map::IntoIter","uri::ErrorKind","header::name::MaybeLower","header::value::ToStrError","request::Parts","response::Parts","header::map::RawLinks","header::map::OccupiedEntry","method::InvalidMethod","header::map::VacantEntry","header::map::ValueIterMut","version::Version","uri::Parts","header::name::Custom","method::Method","header::map::Values","header::map::Entry","header::name::HeaderName","header::map::HashValue"]},"header::map::ValueIterMut":{"T":["header::map::Iter","header::map::ValueIterMut","header::map::IterMut","<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Drain"]},"header::map::Values":{"T":["header::map::ValueIter","header::map::Entry","header::map::Drain","status::StatusCode","header::map::OccupiedEntry","uri::ErrorKind","header::map::VacantEntry","header::name::HeaderName","header::name::InvalidHeaderName","byte_str::ByteStr","header::name::StandardHeader","response::Response","uri::authority::Authority","uri::Parts","uri::scheme::Scheme","uri::path::PathAndQuery","header::map::ExtraValue","header::map::HeaderMap","header::map::Links","method::InvalidMethod","uri::InvalidUri","request::Builder","header::name::HdrName","status::InvalidStatusCode","error::Error","request::Request","header::value::ToStrError","header::name::Custom","header::map::Cursor","response::Builder","uri::scheme::Protocol","header::map::Keys","header::map::Link","header::name::Repr","header::name::MaybeLower","header::map::IterMut","extensions::Extensions","header::map::Bucket","header::map::IntoIter","uri::InvalidUriParts","header::map::GetAll","uri::port::Port","response::Parts","header::map::Iter","request::Parts","header::map::RawLinks","header::map::ValueDrain","header::value::InvalidHeaderValue","header::map::HashValue","header::value::HeaderValue","uri::scheme::Scheme2","header::map::ValueIterMut","uri::Uri","method::Method","<&mut T as std::fmt::Debug>","version::Version","header::map::ValuesMut","header::map::Values","uri::builder::Builder"]},"header::map::ValuesMut":{"T":["header::map::IterMut","response::Response","header::map::ValueIterMut","uri::Uri","uri::scheme::Scheme2","header::value::HeaderValue","uri::Parts","header::map::Link","header::map::ValueIter","uri::scheme::Protocol","header::map::Cursor","header::map::ValueDrain","header::map::GetAll","header::map::Values","header::map::VacantEntry","header::map::RawLinks","header::name::Custom","header::name::MaybeLower","header::name::Repr","header::map::Keys","method::InvalidMethod","request::Builder","header::map::Drain","header::map::IntoIter","header::map::ValuesMut","error::Error","<&mut T as std::fmt::Debug>","uri::InvalidUri","uri::authority::Authority","header::value::InvalidHeaderValue","header::map::Entry","response::Builder","header::map::Iter","response::Parts","uri::port::Port","header::map::HashValue","header::map::ExtraValue","header::map::Bucket","method::Method","byte_str::ByteStr","uri::path::PathAndQuery","header::map::HeaderMap","status::StatusCode","header::value::ToStrError","uri::scheme::Scheme","request::Parts","header::name::InvalidHeaderName","header::map::OccupiedEntry","uri::ErrorKind","extensions::Extensions","header::name::StandardHeader","version::Version","header::name::HdrName","uri::InvalidUriParts","header::map::Links","header::name::HeaderName","request::Request","status::InvalidStatusCode","uri::builder::Builder"]},"header::name::Repr":{"T":["version::Version","header::name::Custom","header::name::Repr","header::name::StandardHeader","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","byte_str::ByteStr"]},"request::Request":{"T":["response::Builder","version::Version","extensions::Extensions","response::Response","uri::builder::Builder","request::Builder","header::map::HeaderMap","status::StatusCode","request::Request","uri::Uri","method::Method","uri::Parts"]},"response::Response":{"T":["method::Method","status::StatusCode","extensions::Extensions","response::Response","request::Request","version::Version","header::map::HeaderMap","uri::Uri","response::Builder","uri::Parts","uri::builder::Builder","request::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["uri::port::Port","uri::authority::Authority","header::value::HeaderValue","<&mut T as std::fmt::Debug>","method::Method","uri::scheme::Scheme"]},"uri::scheme::Scheme2":{"T":["header::name::StandardHeader","header::map::HashValue","header::map::Cursor","header::name::Custom","uri::scheme::Scheme2","header::map::Link","method::Method","uri::authority::Authority","std::boxed::Box<byte_str::ByteStr>","uri::Uri","version::Version","status::StatusCode","header::map::Links","header::map::HeaderMap","header::value::HeaderValue","std::clone::impls::<impl std::clone::Clone for *const T>","header::name::MaybeLower","header::map::ExtraValue","header::name::HeaderName","header::map::Bucket","byte_str::ByteStr","uri::scheme::Protocol","uri::scheme::Scheme","uri::path::PathAndQuery","header::map::RawLinks","header::name::Repr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Keys<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::Keys<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::Keys<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::Keys<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::Values<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Values<'a, T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::convert::TryFrom","std::cmp::PartialEq","std::fmt::Debug"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::marker::Send"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::hash::Hash"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::convert::AsRef","std::fmt::Debug","std::marker::Sized"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Values<'a, T> as std::fmt::Debug>::fmt":{"T":["uri::authority::Authority","header::map::Links","uri::scheme::Scheme2","uri::Parts","<*mut T as std::fmt::Debug>","header::map::ValueDrain","uri::scheme::Scheme","request::Request","response::Builder","method::InvalidMethod","uri::InvalidUriParts","header::name::InvalidHeaderName","method::Method","status::InvalidStatusCode","header::map::Cursor","header::name::Custom","header::map::IterMut","byte_str::ByteStr","uri::builder::Builder","uri::InvalidUri","request::Parts","header::name::HdrName","header::value::InvalidHeaderValue","header::map::OccupiedEntry","uri::Uri","<&mut T as std::fmt::Debug>","header::map::Bucket","header::map::Keys","uri::path::PathAndQuery","header::map::ValueIterMut","header::map::Entry","header::map::Drain","header::name::MaybeLower","uri::ErrorKind","header::name::HeaderName","header::map::RawLinks","header::map::IntoIter","header::map::GetAll","header::map::ExtraValue","header::map::HeaderMap","header::value::ToStrError","header::map::HashValue","uri::port::Port","header::value::HeaderValue","header::map::ValueIter","version::Version","header::map::Iter","request::Builder","header::name::Repr","header::map::Values","extensions::Extensions","header::map::ValuesMut","response::Parts","response::Response","header::map::Link","status::StatusCode","error::Error","header::map::VacantEntry","header::name::StandardHeader","uri::scheme::Protocol"]},"header::map::Bucket":{"T":["method::Method","header::value::HeaderValue","uri::path::PathAndQuery","header::map::ExtraValue","header::name::MaybeLower","header::name::Repr","uri::scheme::Scheme2","header::map::HashValue","header::name::StandardHeader","header::map::Bucket","uri::scheme::Protocol","header::name::Custom","uri::scheme::Scheme","status::StatusCode","header::map::HeaderMap","uri::authority::Authority","header::map::Links","header::name::HeaderName","version::Version","uri::Uri","byte_str::ByteStr","header::map::RawLinks","header::map::Link","header::map::Cursor","std::clone::impls::<impl std::clone::Clone for *const T>"]},"header::map::Drain":{"T":["<*const T as std::marker::Send>","header::map::Iter","header::map::IterMut","header::map::Drain","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::Entry":{"T":["header::value::InvalidHeaderValue","header::name::StandardHeader","uri::builder::Builder","header::map::ValueIter","header::name::HdrName","uri::scheme::Protocol","<*mut T as std::fmt::Debug>","extensions::Extensions","header::map::Links","header::map::Keys","header::name::InvalidHeaderName","header::map::OccupiedEntry","uri::Uri","method::InvalidMethod","header::map::GetAll","uri::Parts","header::name::Repr","error::Error","uri::authority::Authority","uri::path::PathAndQuery","header::map::HashValue","uri::port::Port","header::map::Values","header::map::RawLinks","header::map::ValueIterMut","header::map::IterMut","version::Version","request::Builder","uri::scheme::Scheme2","request::Request","header::map::Entry","header::value::HeaderValue","header::map::HeaderMap","byte_str::ByteStr","header::map::Cursor","header::name::HeaderName","header::map::Drain","response::Response","header::name::MaybeLower","response::Parts","header::map::Iter","header::name::Custom","uri::ErrorKind","uri::InvalidUri","response::Builder","status::InvalidStatusCode","header::map::ValuesMut","header::value::ToStrError","header::map::VacantEntry","header::map::Bucket","uri::InvalidUriParts","status::StatusCode","header::map::ValueDrain","header::map::Link","request::Parts","header::map::ExtraValue","header::map::IntoIter","uri::scheme::Scheme","method::Method"]},"header::map::ExtraValue":{"T":["header::map::HeaderMap","header::map::Bucket","header::name::MaybeLower","method::Method","header::map::HashValue","uri::path::PathAndQuery","header::name::Repr","uri::authority::Authority","uri::scheme::Scheme","status::StatusCode","header::map::Link","header::name::Custom","<&mut T as std::fmt::Debug>","header::value::HeaderValue","header::name::HeaderName","header::name::StandardHeader","uri::Uri","header::map::Cursor","uri::scheme::Protocol","header::map::ExtraValue","header::map::RawLinks","header::map::Links","byte_str::ByteStr","uri::scheme::Scheme2","version::Version"]},"header::map::GetAll":{"T":["header::map::Cursor","uri::ErrorKind","header::name::StandardHeader","version::Version","header::map::Link","header::name::Repr","byte_str::ByteStr","header::map::HeaderMap","header::name::Custom","<*const T as std::fmt::Debug>","header::map::GetAll","header::map::HashValue"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::Links","request::Builder","uri::path::PathAndQuery","request::Request","version::Version","header::map::Cursor","header::map::GetAll","response::Builder","header::map::OccupiedEntry","header::name::Repr","uri::Uri","header::map::ValueIterMut","uri::InvalidUri","header::map::HeaderMap","error::Error","header::name::Custom","uri::builder::Builder","header::name::HeaderName","header::map::ValueDrain","uri::scheme::Protocol","header::map::VacantEntry","header::map::Link","header::map::HashValue","method::InvalidMethod","header::map::Keys","header::value::InvalidHeaderValue","status::InvalidStatusCode","uri::port::Port","header::map::ValuesMut","header::name::MaybeLower","header::value::ToStrError","header::map::Iter","response::Parts","header::map::RawLinks","header::map::Entry","header::map::Drain","status::StatusCode","response::Response","request::Parts","header::map::Bucket","uri::Parts","<&mut T as std::fmt::Debug>","uri::ErrorKind","uri::scheme::Scheme2","header::name::HdrName","extensions::Extensions","byte_str::ByteStr","uri::authority::Authority","header::value::HeaderValue","header::map::IntoIter","method::Method","header::map::ExtraValue","header::name::StandardHeader","uri::scheme::Scheme","header::map::IterMut","header::name::InvalidHeaderName","header::map::Values","header::map::ValueIter","uri::InvalidUriParts"]},"header::map::Iter":{"T":["header::map::IterMut","header::map::Iter","<*mut T as std::fmt::Debug>","header::map::Drain","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::IterMut":{"T":["header::map::IterMut","<*mut T as std::fmt::Debug>","header::map::ValueDrain","header::map::Iter","header::map::Drain","header::map::ValueIterMut"]},"header::map::Keys":{"T":["header::map::HashValue","response::Response","header::map::VacantEntry","uri::InvalidUriParts","header::map::IterMut","header::map::OccupiedEntry","uri::authority::Authority","uri::path::PathAndQuery","header::map::Keys","header::map::ValuesMut","status::StatusCode","header::name::HeaderName","request::Parts","header::value::InvalidHeaderValue","header::map::Entry","header::map::ValueIter","<&mut T as std::fmt::Debug>","header::map::ExtraValue","header::map::Bucket","header::map::ValueDrain","request::Request","header::map::Drain","response::Builder","uri::Parts","header::value::ToStrError","uri::scheme::Scheme","header::map::ValueIterMut","byte_str::ByteStr","header::map::IntoIter","header::name::HdrName","header::map::Link","header::value::HeaderValue","header::map::GetAll","header::name::MaybeLower","response::Parts","header::map::HeaderMap","header::map::Links","header::map::Values","request::Builder","extensions::Extensions","header::name::Custom","uri::InvalidUri","uri::builder::Builder","method::Method","error::Error","uri::ErrorKind","uri::Uri","header::map::RawLinks","uri::scheme::Scheme2","version::Version","header::name::Repr","status::InvalidStatusCode","header::map::Cursor","header::map::Iter","header::name::InvalidHeaderName","method::InvalidMethod","uri::scheme::Protocol","header::name::StandardHeader","uri::port::Port"]},"header::map::OccupiedEntry":{"T":["header::value::ToStrError","header::map::Bucket","header::map::ValuesMut","uri::ErrorKind","header::map::IntoIter","status::StatusCode","byte_str::ByteStr","request::Parts","response::Builder","uri::scheme::Protocol","header::map::IterMut","response::Parts","uri::port::Port","header::map::Drain","header::map::HeaderMap","header::name::HdrName","method::Method","header::name::StandardHeader","header::map::HashValue","header::map::ValueIterMut","header::map::Entry","version::Version","uri::builder::Builder","header::map::OccupiedEntry","header::map::ValueDrain","<&mut T as std::fmt::Debug>","request::Request","uri::scheme::Scheme2","header::map::Cursor","uri::Parts","uri::scheme::Scheme","uri::authority::Authority","header::map::Values","header::name::InvalidHeaderName","method::InvalidMethod","header::value::HeaderValue","header::name::Repr","status::InvalidStatusCode","header::map::Keys","header::name::MaybeLower","response::Response","uri::path::PathAndQuery","uri::Uri","header::value::InvalidHeaderValue","header::map::Iter","request::Builder","header::map::Links","header::map::ValueIter","uri::InvalidUriParts","uri::InvalidUri","header::map::GetAll","header::map::ExtraValue","extensions::Extensions","error::Error","header::map::VacantEntry","header::map::RawLinks","header::map::Link","header::name::Custom","header::name::HeaderName"]},"header::map::RawLinks":{"T":["header::map::Link","header::name::StandardHeader","header::name::MaybeLower","header::map::Bucket","response::Parts","header::name::HeaderName","uri::builder::Builder","header::map::ValueIterMut","header::map::Entry","header::map::ValueIter","header::map::ExtraValue","version::Version","request::Parts","header::map::OccupiedEntry","header::map::HeaderMap","uri::scheme::Scheme","header::map::ValuesMut","request::Request","status::InvalidStatusCode","uri::authority::Authority","header::map::ValueDrain","uri::ErrorKind","uri::Uri","header::map::Links","header::map::VacantEntry","response::Response","uri::Parts","uri::port::Port","uri::path::PathAndQuery","response::Builder","header::map::IntoIter","byte_str::ByteStr","header::map::Values","header::value::ToStrError","status::StatusCode","header::name::Repr","header::map::Iter","header::map::HashValue","header::name::InvalidHeaderName","header::map::Drain","header::map::IterMut","error::Error","extensions::Extensions","method::Method","request::Builder","uri::InvalidUriParts","uri::scheme::Protocol","header::value::HeaderValue","method::InvalidMethod","uri::scheme::Scheme2","header::value::InvalidHeaderValue","header::map::Keys","header::name::HdrName","header::map::GetAll","header::map::RawLinks","uri::InvalidUri","<&mut T as std::fmt::Debug>","header::name::Custom","header::map::Cursor"]},"header::map::VacantEntry":{"T":["response::Builder","uri::builder::Builder","header::map::VacantEntry","header::map::RawLinks","version::Version","header::name::Repr","header::map::IterMut","header::map::Cursor","error::Error","header::name::HeaderName","header::name::Custom","response::Response","header::map::HashValue","extensions::Extensions","header::value::HeaderValue","response::Parts","method::InvalidMethod","request::Parts","header::map::ValueIterMut","uri::Parts","byte_str::ByteStr","request::Request","header::map::GetAll","header::map::Iter","header::value::InvalidHeaderValue","uri::ErrorKind","uri::InvalidUriParts","uri::InvalidUri","header::map::Values","uri::port::Port","header::map::ValueDrain","<&mut T as std::fmt::Debug>","uri::scheme::Scheme","header::map::Keys","header::map::Entry","uri::authority::Authority","header::map::ExtraValue","header::name::HdrName","header::name::StandardHeader","header::name::InvalidHeaderName","status::InvalidStatusCode","uri::scheme::Protocol","header::map::Drain","header::map::Links","request::Builder","uri::Uri","method::Method","header::map::ValueIter","uri::path::PathAndQuery","header::map::OccupiedEntry","header::map::ValuesMut","header::value::ToStrError","header::name::MaybeLower","header::map::Bucket","header::map::IntoIter","header::map::HeaderMap","status::StatusCode","uri::scheme::Scheme2","header::map::Link"]},"header::map::ValueDrain":{"T":["header::map::Drain","header::map::Iter","<*mut T as std::marker::Sync>","header::map::IterMut","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::ValueIter":{"T":["response::Builder","status::InvalidStatusCode","header::map::ValueIterMut","header::name::StandardHeader","uri::scheme::Protocol","uri::path::PathAndQuery","header::map::Link","uri::Uri","request::Request","header::value::HeaderValue","header::map::Cursor","header::map::HashValue","header::value::ToStrError","uri::port::Port","uri::builder::Builder","header::map::Iter","status::StatusCode","request::Parts","header::name::HdrName","header::map::HeaderMap","header::value::InvalidHeaderValue","header::name::InvalidHeaderName","header::name::HeaderName","header::name::MaybeLower","header::name::Custom","header::map::ValueIter","method::InvalidMethod","uri::InvalidUri","uri::InvalidUriParts","header::map::ExtraValue","method::Method","header::map::Keys","response::Parts","uri::Parts","header::map::Entry","header::map::ValuesMut","header::map::OccupiedEntry","uri::scheme::Scheme","header::map::ValueDrain","header::map::Links","error::Error","uri::ErrorKind","header::name::Repr","header::map::VacantEntry","uri::scheme::Scheme2","response::Response","uri::authority::Authority","header::map::Values","header::map::RawLinks","byte_str::ByteStr","extensions::Extensions","header::map::Drain","header::map::IntoIter","version::Version","header::map::GetAll","header::map::Bucket","request::Builder","header::map::IterMut","<*mut T as std::fmt::Debug>"]},"header::map::ValueIterMut":{"T":["header::map::Iter","<*mut T as std::marker::Sync>","header::map::ValueIterMut","header::map::ValueDrain","header::map::Drain","header::map::IterMut"]},"header::map::Values":{"T":["header::map::HashValue","header::map::Values","header::map::ExtraValue","uri::port::Port","header::map::RawLinks","error::Error","header::map::Entry","header::map::ValuesMut","status::StatusCode","response::Builder","header::map::HeaderMap","header::map::ValueIter","header::map::Iter","header::map::IterMut","header::value::HeaderValue","header::map::Keys","uri::InvalidUriParts","extensions::Extensions","header::map::Bucket","response::Parts","request::Request","header::name::Custom","uri::scheme::Protocol","uri::builder::Builder","header::map::IntoIter","header::name::HdrName","header::map::ValueDrain","byte_str::ByteStr","header::map::GetAll","header::map::Cursor","header::map::Links","status::InvalidStatusCode","uri::InvalidUri","uri::scheme::Scheme","uri::ErrorKind","uri::Parts","header::map::VacantEntry","request::Parts","header::map::OccupiedEntry","uri::path::PathAndQuery","header::name::StandardHeader","header::value::InvalidHeaderValue","uri::scheme::Scheme2","header::value::ToStrError","header::name::InvalidHeaderName","header::name::Repr","method::Method","header::map::Link","<&T as std::fmt::Debug>","uri::authority::Authority","uri::Uri","header::map::ValueIterMut","response::Response","method::InvalidMethod","header::name::HeaderName","header::name::MaybeLower","header::map::Drain","version::Version","request::Builder"]},"header::map::ValuesMut":{"T":["response::Parts","header::value::InvalidHeaderValue","header::map::Iter","header::name::HeaderName","uri::InvalidUri","uri::builder::Builder","header::name::Custom","header::map::VacantEntry","header::map::Links","<&mut T as std::fmt::Debug>","header::value::HeaderValue","header::map::OccupiedEntry","method::InvalidMethod","request::Parts","version::Version","header::map::HashValue","response::Response","error::Error","request::Builder","header::map::Values","header::map::ValueIter","header::map::GetAll","header::name::Repr","status::InvalidStatusCode","extensions::Extensions","header::map::Link","header::map::RawLinks","header::map::HeaderMap","response::Builder","header::map::IterMut","header::name::InvalidHeaderName","uri::authority::Authority","uri::InvalidUriParts","method::Method","header::map::ValueIterMut","status::StatusCode","header::name::HdrName","header::name::StandardHeader","header::map::IntoIter","uri::Parts","uri::scheme::Scheme2","header::name::MaybeLower","uri::Uri","uri::port::Port","header::map::Drain","header::map::Keys","request::Request","uri::scheme::Protocol","header::map::Cursor","header::map::ExtraValue","header::map::ValueDrain","header::map::ValuesMut","uri::path::PathAndQuery","header::value::ToStrError","header::map::Bucket","byte_str::ByteStr","header::map::Entry","uri::ErrorKind","uri::scheme::Scheme"]},"header::name::Repr":{"T":["header::name::Repr","version::Version","byte_str::ByteStr","header::name::StandardHeader","std::hash::impls::<impl std::hash::Hash for *mut T>","header::name::Custom"]},"request::Request":{"T":["version::Version","uri::Parts","uri::builder::Builder","response::Builder","method::Method","extensions::Extensions","request::Request","request::Builder","response::Response","header::map::HeaderMap","status::StatusCode","uri::Uri"]},"response::Response":{"T":["response::Builder","response::Response","uri::Uri","status::StatusCode","uri::Parts","request::Builder","method::Method","header::map::HeaderMap","uri::builder::Builder","extensions::Extensions","request::Request","version::Version"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["uri::scheme::Scheme","<&mut T as std::fmt::Debug>","method::Method","header::value::HeaderValue","uri::authority::Authority","uri::port::Port"]},"uri::scheme::Scheme2":{"T":["uri::path::PathAndQuery","method::Method","header::value::HeaderValue","uri::scheme::Scheme2","uri::scheme::Scheme","byte_str::ByteStr","version::Version","header::map::RawLinks","header::name::Repr","uri::authority::Authority","header::name::Custom","std::boxed::Box<byte_str::ByteStr>","<*mut T as std::fmt::Debug>","uri::Uri","header::name::StandardHeader","header::name::MaybeLower","header::map::ExtraValue","header::map::HashValue","status::StatusCode","header::map::Link","uri::scheme::Protocol","header::map::Links","header::map::HeaderMap","header::map::Cursor","header::name::HeaderName","header::map::Bucket"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Values<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::Values<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::Values<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::Values<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::ValuesMut<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ValuesMut<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Send","std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::convert::TryFrom","std::marker::Sized"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::hash::Hash","std::clone::Clone","std::marker::Sized"]},"request::Request":{"T":["std::fmt::Debug","std::default::Default","std::marker::Sized"]},"response::Response":{"T":["std::fmt::Debug","std::default::Default","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ValuesMut<'a, T> as std::fmt::Debug>::fmt":{"T":["header::name::MaybeLower","uri::scheme::Protocol","<&T as std::fmt::Debug>","header::map::OccupiedEntry","header::value::HeaderValue","uri::InvalidUriParts","response::Builder","header::map::VacantEntry","header::map::Keys","uri::builder::Builder","header::map::Values","header::map::Drain","header::map::IntoIter","header::map::Cursor","header::map::ValueIter","uri::Parts","error::Error","header::map::Entry","header::map::HeaderMap","header::map::GetAll","header::value::InvalidHeaderValue","header::name::Repr","uri::ErrorKind","uri::Uri","header::map::ValueIterMut","header::name::Custom","response::Response","header::name::HdrName","header::map::Link","uri::authority::Authority","<*const T as std::fmt::Debug>","header::map::Bucket","version::Version","header::map::ExtraValue","uri::path::PathAndQuery","request::Request","header::name::StandardHeader","method::InvalidMethod","status::InvalidStatusCode","uri::port::Port","uri::scheme::Scheme","extensions::Extensions","request::Parts","header::map::Links","header::map::HashValue","uri::scheme::Scheme2","method::Method","header::map::ValueDrain","header::name::HeaderName","header::map::IterMut","header::name::InvalidHeaderName","response::Parts","header::value::ToStrError","request::Builder","byte_str::ByteStr","header::map::RawLinks","uri::InvalidUri","header::map::Iter","status::StatusCode","header::map::ValuesMut"]},"header::map::Bucket":{"T":["header::name::Custom","uri::scheme::Scheme","header::map::Links","header::name::StandardHeader","version::Version","method::Method","header::name::MaybeLower","header::map::ExtraValue","header::map::HeaderMap","header::map::Cursor","header::map::RawLinks","<&mut T as std::fmt::Debug>","header::map::HashValue","uri::scheme::Protocol","header::name::Repr","byte_str::ByteStr","header::map::Link","uri::path::PathAndQuery","header::map::Bucket","header::value::HeaderValue","status::StatusCode","header::name::HeaderName","uri::authority::Authority","uri::Uri","uri::scheme::Scheme2"]},"header::map::Drain":{"T":["header::map::Iter","header::map::ValueDrain","<*const T as std::marker::Send>","header::map::ValueIterMut","header::map::IterMut","header::map::Drain"]},"header::map::Entry":{"T":["header::map::VacantEntry","header::name::HdrName","header::name::InvalidHeaderName","uri::port::Port","method::Method","header::map::ValueIterMut","header::map::ValuesMut","uri::InvalidUriParts","header::map::Cursor","header::name::MaybeLower","header::map::HashValue","byte_str::ByteStr","error::Error","version::Version","<&T as std::fmt::Debug>","extensions::Extensions","header::map::IterMut","request::Request","uri::scheme::Scheme","uri::path::PathAndQuery","status::StatusCode","response::Parts","uri::InvalidUri","header::map::ValueIter","uri::scheme::Protocol","header::name::HeaderName","header::map::Link","header::map::Bucket","header::name::StandardHeader","header::map::ValueDrain","header::map::HeaderMap","header::map::Entry","header::map::GetAll","header::map::Values","header::name::Repr","header::map::RawLinks","header::map::Iter","uri::authority::Authority","header::map::Links","request::Builder","header::map::OccupiedEntry","request::Parts","uri::ErrorKind","method::InvalidMethod","header::map::IntoIter","uri::Uri","status::InvalidStatusCode","header::value::HeaderValue","header::value::InvalidHeaderValue","header::map::ExtraValue","header::map::Keys","response::Builder","header::name::Custom","uri::scheme::Scheme2","header::value::ToStrError","uri::Parts","uri::builder::Builder","response::Response","header::map::Drain"]},"header::map::ExtraValue":{"T":["header::name::Custom","uri::Uri","header::name::MaybeLower","uri::scheme::Protocol","status::StatusCode","uri::scheme::Scheme2","header::map::Link","version::Version","header::value::HeaderValue","uri::authority::Authority","header::name::HeaderName","byte_str::ByteStr","header::name::Repr","header::map::RawLinks","header::map::Links","uri::path::PathAndQuery","header::map::HashValue","header::map::Bucket","uri::scheme::Scheme","method::Method","std::clone::impls::<impl std::clone::Clone for &T>","header::map::ExtraValue","header::map::Cursor","header::map::HeaderMap","header::name::StandardHeader"]},"header::map::GetAll":{"T":["header::map::Cursor","header::map::GetAll","byte_str::ByteStr","std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>","header::map::HeaderMap","header::name::Repr","header::map::HashValue","version::Version","header::name::StandardHeader","header::name::Custom","header::map::Link","uri::ErrorKind"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["header::value::InvalidHeaderValue","uri::port::Port","uri::authority::Authority","uri::InvalidUri","header::map::IterMut","uri::scheme::Scheme2","header::map::Entry","uri::path::PathAndQuery","<*const T as std::fmt::Debug>","header::map::Values","header::map::ValueDrain","uri::scheme::Protocol","method::Method","header::map::ExtraValue","header::name::MaybeLower","header::map::Link","header::map::IntoIter","uri::Uri","header::value::ToStrError","header::map::Links","uri::Parts","status::InvalidStatusCode","header::map::HashValue","header::name::Custom","header::map::ValueIter","header::name::Repr","header::map::Bucket","header::name::HdrName","version::Version","response::Parts","uri::scheme::Scheme","uri::ErrorKind","header::map::Drain","response::Response","header::map::RawLinks","header::map::OccupiedEntry","header::map::ValueIterMut","header::map::Cursor","header::name::StandardHeader","uri::InvalidUriParts","extensions::Extensions","header::map::Iter","header::name::HeaderName","header::map::VacantEntry","header::map::ValuesMut","byte_str::ByteStr","header::map::GetAll","request::Parts","status::StatusCode","request::Request","method::InvalidMethod","uri::builder::Builder","error::Error","response::Builder","header::name::InvalidHeaderName","header::map::Keys","header::map::HeaderMap","request::Builder","header::value::HeaderValue"]},"header::map::Iter":{"T":["header::map::ValueDrain","header::map::Iter","header::map::IterMut","header::map::Drain","<*mut T as std::marker::Sync>","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["header::map::Drain","header::map::Iter","<*const T as std::fmt::Debug>","header::map::ValueIterMut","header::map::ValueDrain","header::map::IterMut"]},"header::map::Keys":{"T":["header::map::RawLinks","header::map::VacantEntry","header::map::Cursor","method::Method","header::map::ValueIterMut","uri::authority::Authority","uri::path::PathAndQuery","response::Response","header::map::OccupiedEntry","status::InvalidStatusCode","header::name::StandardHeader","extensions::Extensions","<&mut T as std::fmt::Debug>","header::value::HeaderValue","header::map::ExtraValue","header::name::HdrName","header::map::Entry","method::InvalidMethod","header::name::Repr","uri::builder::Builder","header::map::Keys","uri::InvalidUri","uri::scheme::Scheme2","header::name::HeaderName","uri::Uri","uri::InvalidUriParts","header::name::MaybeLower","response::Parts","header::value::ToStrError","uri::scheme::Scheme","header::map::ValueIter","header::map::Link","header::map::Drain","header::map::Links","header::map::Bucket","request::Builder","header::map::HashValue","header::value::InvalidHeaderValue","response::Builder","status::StatusCode","header::map::HeaderMap","uri::scheme::Protocol","header::map::IterMut","header::map::ValueDrain","uri::ErrorKind","header::name::InvalidHeaderName","request::Parts","uri::port::Port","header::map::GetAll","request::Request","header::map::IntoIter","header::map::Values","error::Error","version::Version","uri::Parts","header::name::Custom","byte_str::ByteStr","header::map::ValuesMut","header::map::Iter"]},"header::map::OccupiedEntry":{"T":["header::map::ValuesMut","header::map::Cursor","header::value::InvalidHeaderValue","error::Error","header::name::Custom","header::name::InvalidHeaderName","header::name::MaybeLower","uri::path::PathAndQuery","method::InvalidMethod","header::name::Repr","header::map::Keys","method::Method","version::Version","header::map::ExtraValue","uri::InvalidUriParts","header::value::ToStrError","header::value::HeaderValue","header::map::VacantEntry","uri::authority::Authority","header::name::HdrName","header::map::GetAll","uri::Uri","uri::scheme::Scheme2","header::map::Links","header::name::StandardHeader","header::map::Iter","header::map::RawLinks","status::InvalidStatusCode","uri::port::Port","uri::scheme::Protocol","header::map::Bucket","<&mut T as std::fmt::Debug>","uri::builder::Builder","extensions::Extensions","request::Builder","header::map::IntoIter","uri::ErrorKind","header::map::HeaderMap","header::map::Link","request::Parts","header::map::Entry","uri::scheme::Scheme","uri::InvalidUri","byte_str::ByteStr","header::map::ValueIter","header::map::OccupiedEntry","response::Parts","header::map::IterMut","header::map::HashValue","header::name::HeaderName","uri::Parts","response::Response","header::map::Values","header::map::Drain","header::map::ValueIterMut","status::StatusCode","header::map::ValueDrain","request::Request","response::Builder"]},"header::map::RawLinks":{"T":["header::map::IterMut","<&T as std::fmt::Debug>","extensions::Extensions","header::name::StandardHeader","uri::Uri","header::map::ValueIter","header::value::HeaderValue","method::InvalidMethod","header::name::MaybeLower","header::map::ValueDrain","status::InvalidStatusCode","header::map::Values","header::map::IntoIter","header::map::Iter","response::Parts","header::map::Bucket","header::map::Cursor","request::Request","response::Response","uri::builder::Builder","header::map::ExtraValue","header::map::HashValue","uri::path::PathAndQuery","uri::authority::Authority","status::StatusCode","header::map::RawLinks","uri::port::Port","uri::InvalidUri","header::value::InvalidHeaderValue","header::value::ToStrError","header::map::OccupiedEntry","header::map::Keys","header::map::ValueIterMut","uri::ErrorKind","header::name::Custom","header::map::Link","byte_str::ByteStr","header::map::VacantEntry","error::Error","version::Version","uri::scheme::Protocol","header::name::Repr","uri::scheme::Scheme2","uri::InvalidUriParts","header::map::ValuesMut","response::Builder","header::map::Entry","request::Parts","header::map::HeaderMap","header::map::Drain","uri::Parts","method::Method","header::map::Links","header::name::HeaderName","header::name::HdrName","header::map::GetAll","uri::scheme::Scheme","header::name::InvalidHeaderName","request::Builder"]},"header::map::VacantEntry":{"T":["header::map::Cursor","header::map::RawLinks","uri::port::Port","byte_str::ByteStr","extensions::Extensions","method::Method","header::name::MaybeLower","request::Builder","header::map::HeaderMap","uri::scheme::Scheme2","header::map::Keys","header::map::ExtraValue","header::map::Drain","uri::scheme::Protocol","header::map::ValueIterMut","response::Builder","header::map::Bucket","request::Parts","version::Version","request::Request","header::map::Link","header::name::Repr","header::name::InvalidHeaderName","uri::Uri","response::Response","header::map::OccupiedEntry","uri::InvalidUri","uri::authority::Authority","uri::Parts","header::value::ToStrError","header::map::HashValue","header::value::HeaderValue","uri::InvalidUriParts","error::Error","header::map::Values","header::map::Iter","header::name::StandardHeader","header::name::HeaderName","uri::builder::Builder","header::value::InvalidHeaderValue","<*mut T as std::fmt::Debug>","header::name::Custom","header::map::VacantEntry","header::map::ValuesMut","uri::ErrorKind","header::map::Links","response::Parts","header::map::IntoIter","uri::path::PathAndQuery","method::InvalidMethod","header::map::ValueIter","header::map::ValueDrain","uri::scheme::Scheme","header::map::Entry","header::name::HdrName","status::InvalidStatusCode","status::StatusCode","header::map::GetAll","header::map::IterMut"]},"header::map::ValueDrain":{"T":["header::map::Drain","header::map::ValueIterMut","<*mut T as std::marker::Send>","header::map::Iter","header::map::ValueDrain","header::map::IterMut"]},"header::map::ValueIter":{"T":["header::map::Values","header::name::InvalidHeaderName","header::name::MaybeLower","header::name::Custom","uri::Uri","header::map::HeaderMap","error::Error","byte_str::ByteStr","request::Request","status::InvalidStatusCode","status::StatusCode","header::map::ValueIterMut","header::map::ValueIter","<*mut T as std::fmt::Debug>","header::value::HeaderValue","uri::InvalidUriParts","uri::InvalidUri","response::Response","response::Parts","header::name::StandardHeader","request::Builder","header::map::Entry","uri::port::Port","header::map::Drain","header::map::Keys","method::InvalidMethod","uri::scheme::Protocol","header::map::Links","response::Builder","uri::path::PathAndQuery","header::value::ToStrError","header::map::Link","header::map::OccupiedEntry","header::name::Repr","uri::builder::Builder","header::map::Iter","uri::ErrorKind","header::name::HdrName","header::map::ValueDrain","header::value::InvalidHeaderValue","header::map::GetAll","header::map::IntoIter","method::Method","version::Version","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::Cursor","header::map::IterMut","uri::Parts","header::map::Bucket","header::map::ExtraValue","header::map::VacantEntry","header::map::HashValue","header::map::RawLinks","request::Parts","header::name::HeaderName","extensions::Extensions","uri::authority::Authority","header::map::ValuesMut"]},"header::map::ValueIterMut":{"T":["header::map::Iter","header::map::ValueDrain","header::map::ValueIterMut","header::map::Drain","<*const T as std::marker::Sync>","header::map::IterMut"]},"header::map::Values":{"T":["uri::port::Port","header::name::InvalidHeaderName","header::map::ValuesMut","uri::scheme::Scheme","header::value::HeaderValue","uri::Uri","header::map::ValueDrain","method::Method","header::map::IterMut","status::StatusCode","header::map::ExtraValue","response::Builder","response::Parts","status::InvalidStatusCode","header::name::Repr","uri::InvalidUriParts","header::name::StandardHeader","response::Response","header::map::IntoIter","header::map::ValueIter","header::map::Bucket","header::value::InvalidHeaderValue","header::map::Iter","header::map::GetAll","header::map::HeaderMap","header::map::HashValue","request::Builder","header::map::VacantEntry","header::name::HeaderName","uri::ErrorKind","header::map::RawLinks","uri::authority::Authority","header::map::Values","request::Parts","byte_str::ByteStr","uri::Parts","header::map::Drain","header::value::ToStrError","uri::scheme::Scheme2","header::name::HdrName","header::map::OccupiedEntry","extensions::Extensions","header::name::MaybeLower","request::Request","header::map::Links","version::Version","header::name::Custom","header::map::Link","header::map::Keys","uri::InvalidUri","error::Error","method::InvalidMethod","header::map::ValueIterMut","uri::path::PathAndQuery","<&mut T as std::fmt::Debug>","uri::scheme::Protocol","header::map::Cursor","uri::builder::Builder","header::map::Entry"]},"header::map::ValuesMut":{"T":["header::value::ToStrError","header::map::HashValue","header::map::ValuesMut","header::name::HdrName","uri::path::PathAndQuery","header::map::Cursor","header::name::Custom","header::map::Links","header::name::InvalidHeaderName","header::map::IterMut","uri::authority::Authority","version::Version","uri::InvalidUriParts","header::map::OccupiedEntry","header::value::HeaderValue","header::map::GetAll","header::name::MaybeLower","<&mut T as std::fmt::Debug>","header::value::InvalidHeaderValue","header::map::IntoIter","header::name::StandardHeader","header::map::VacantEntry","extensions::Extensions","header::map::Drain","header::name::HeaderName","status::StatusCode","status::InvalidStatusCode","uri::InvalidUri","header::map::ValueIter","header::map::Iter","header::map::ValueIterMut","header::map::ValueDrain","byte_str::ByteStr","uri::scheme::Scheme","method::InvalidMethod","header::map::HeaderMap","uri::port::Port","header::map::Entry","request::Builder","uri::Uri","uri::scheme::Scheme2","uri::scheme::Protocol","uri::builder::Builder","response::Builder","header::map::Link","uri::ErrorKind","method::Method","header::map::RawLinks","header::map::Values","header::name::Repr","response::Response","request::Request","header::map::Keys","request::Parts","header::map::Bucket","response::Parts","error::Error","uri::Parts","header::map::ExtraValue"]},"header::name::Repr":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","header::name::StandardHeader","header::name::Custom","version::Version","byte_str::ByteStr","header::name::Repr"]},"request::Request":{"T":["uri::Uri","request::Request","response::Builder","extensions::Extensions","header::map::HeaderMap","version::Version","status::StatusCode","response::Response","request::Builder","uri::builder::Builder","uri::Parts","method::Method"]},"response::Response":{"T":["response::Builder","method::Method","request::Builder","version::Version","request::Request","uri::builder::Builder","status::StatusCode","header::map::HeaderMap","uri::Uri","extensions::Extensions","uri::Parts","response::Response"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"uri::port::Port":{"T":["uri::port::Port","<&T as std::fmt::Debug>","uri::scheme::Scheme","method::Method","header::value::HeaderValue","uri::authority::Authority"]},"uri::scheme::Scheme2":{"T":["uri::path::PathAndQuery","uri::scheme::Scheme2","std::boxed::Box<byte_str::ByteStr>","uri::authority::Authority","uri::Uri","header::map::Cursor","header::name::Repr","header::map::Bucket","header::map::HashValue","<*mut T as std::fmt::Debug>","method::Method","version::Version","header::name::StandardHeader","header::map::RawLinks","header::map::ExtraValue","header::name::MaybeLower","header::map::Link","header::name::Custom","header::name::HeaderName","header::value::HeaderValue","header::map::Links","uri::scheme::Protocol","status::StatusCode","uri::scheme::Scheme","byte_str::ByteStr","header::map::HeaderMap"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::ValuesMut<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::ValuesMut<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::ValuesMut<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::ValuesMut<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::Drain<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Drain<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::convert::TryFrom","std::marker::Sized"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::marker::Sized"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::hash::Hash","std::cmp::Eq","std::marker::Sized"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"uri::port::Port":{"T":["std::fmt::Debug","std::marker::Sized","std::convert::AsRef"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Drain<'a, T> as std::fmt::Debug>::fmt":{"T":["header::map::HeaderMap","request::Request","method::Method","header::name::HdrName","header::map::IterMut","header::map::OccupiedEntry","byte_str::ByteStr","header::name::StandardHeader","header::value::InvalidHeaderValue","header::name::Repr","header::value::HeaderValue","version::Version","header::map::ValueDrain","method::InvalidMethod","uri::ErrorKind","header::map::Keys","header::map::Drain","header::map::Entry","header::name::InvalidHeaderName","header::map::ExtraValue","header::name::Custom","uri::scheme::Scheme","response::Parts","header::map::Link","header::map::IntoIter","status::StatusCode","extensions::Extensions","header::map::ValueIterMut","header::map::HashValue","request::Parts","header::map::ValuesMut","header::name::HeaderName","header::map::RawLinks","uri::Uri","uri::port::Port","uri::Parts","header::map::Values","header::map::Links","header::value::ToStrError","header::name::MaybeLower","uri::InvalidUri","header::map::Cursor","uri::builder::Builder","uri::scheme::Protocol","response::Builder","request::Builder","header::map::VacantEntry","uri::path::PathAndQuery","header::map::Iter","header::map::GetAll","error::Error","response::Response","header::map::Bucket","uri::scheme::Scheme2","<*mut T as std::fmt::Debug>","header::map::ValueIter","status::InvalidStatusCode","<*const T as std::fmt::Debug>","uri::authority::Authority","uri::InvalidUriParts"]},"header::map::Bucket":{"T":["header::map::Bucket","uri::scheme::Scheme","header::map::ExtraValue","header::map::Cursor","uri::authority::Authority","header::name::HeaderName","byte_str::ByteStr","header::name::Custom","header::map::HeaderMap","uri::scheme::Scheme2","method::Method","status::StatusCode","header::map::Link","header::map::RawLinks","header::map::Links","header::name::MaybeLower","header::value::HeaderValue","header::name::Repr","uri::path::PathAndQuery","header::name::StandardHeader","<&T as std::fmt::Debug>","uri::scheme::Protocol","version::Version","header::map::HashValue","uri::Uri"]},"header::map::Drain":{"T":["<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Iter","header::map::ValueIterMut","header::map::Drain","header::map::IterMut"]},"header::map::Entry":{"T":["header::map::RawLinks","header::map::Iter","header::map::GetAll","header::name::HeaderName","response::Parts","header::map::IntoIter","uri::port::Port","uri::path::PathAndQuery","header::name::Repr","header::name::HdrName","uri::Parts","header::value::HeaderValue","header::name::Custom","header::map::Keys","version::Version","<*const T as std::fmt::Debug>","status::StatusCode","request::Builder","header::name::MaybeLower","header::map::Values","uri::InvalidUriParts","header::name::StandardHeader","method::Method","uri::scheme::Scheme","header::map::IterMut","header::map::Cursor","header::name::InvalidHeaderName","uri::scheme::Scheme2","uri::Uri","uri::authority::Authority","header::value::ToStrError","header::map::ValueIter","error::Error","header::map::ValuesMut","byte_str::ByteStr","header::map::ValueIterMut","header::map::HashValue","response::Response","status::InvalidStatusCode","request::Parts","uri::InvalidUri","header::map::Entry","header::map::OccupiedEntry","header::map::HeaderMap","uri::builder::Builder","header::map::VacantEntry","header::map::Bucket","header::value::InvalidHeaderValue","header::map::Link","uri::ErrorKind","method::InvalidMethod","request::Request","header::map::ExtraValue","header::map::ValueDrain","extensions::Extensions","header::map::Links","response::Builder","header::map::Drain","uri::scheme::Protocol"]},"header::map::ExtraValue":{"T":["<&T as std::fmt::Debug>","header::map::HashValue","header::map::Cursor","uri::scheme::Scheme","status::StatusCode","header::name::MaybeLower","header::name::Repr","header::map::Links","uri::authority::Authority","header::map::Bucket","header::map::HeaderMap","uri::scheme::Scheme2","header::map::RawLinks","header::name::StandardHeader","method::Method","header::name::Custom","header::map::ExtraValue","uri::Uri","header::map::Link","byte_str::ByteStr","uri::path::PathAndQuery","uri::scheme::Protocol","version::Version","header::name::HeaderName","header::value::HeaderValue"]},"header::map::GetAll":{"T":["header::map::GetAll","header::name::Repr","header::name::Custom","header::map::Cursor","header::map::Link","<*const T as std::fmt::Debug>","byte_str::ByteStr","header::map::HeaderMap","header::map::HashValue","header::name::StandardHeader","uri::ErrorKind","version::Version"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["uri::scheme::Scheme","header::map::RawLinks","header::map::VacantEntry","header::map::Values","error::Error","header::name::MaybeLower","uri::Uri","header::name::HeaderName","header::map::GetAll","uri::ErrorKind","header::name::InvalidHeaderName","header::map::HashValue","header::value::InvalidHeaderValue","version::Version","uri::InvalidUriParts","header::map::ValuesMut","header::map::Entry","header::map::IntoIter","header::map::HeaderMap","uri::Parts","uri::scheme::Protocol","header::map::ExtraValue","header::name::Custom","header::map::ValueIterMut","uri::authority::Authority","header::name::StandardHeader","header::map::OccupiedEntry","byte_str::ByteStr","status::StatusCode","header::map::Cursor","extensions::Extensions","method::InvalidMethod","uri::port::Port","header::name::Repr","header::map::ValueDrain","header::name::HdrName","status::InvalidStatusCode","header::map::Iter","request::Parts","header::map::IterMut","header::map::Links","header::value::HeaderValue","method::Method","header::map::ValueIter","header::map::Drain","response::Parts","request::Builder","response::Builder","request::Request","<*const T as std::fmt::Debug>","response::Response","header::value::ToStrError","header::map::Link","uri::path::PathAndQuery","uri::scheme::Scheme2","header::map::Keys","uri::builder::Builder","header::map::Bucket","uri::InvalidUri"]},"header::map::Iter":{"T":["<*const T as std::fmt::Debug>","header::map::ValueIterMut","header::map::IterMut","header::map::Iter","header::map::ValueDrain","header::map::Drain"]},"header::map::IterMut":{"T":["header::map::ValueDrain","<*const T as std::fmt::Debug>","header::map::IterMut","header::map::ValueIterMut","header::map::Drain","header::map::Iter"]},"header::map::Keys":{"T":["header::name::HdrName","request::Builder","header::map::HashValue","header::map::Link","header::map::ValueIterMut","<*mut T as std::fmt::Debug>","extensions::Extensions","header::name::Repr","header::map::Drain","uri::Uri","header::map::Entry","header::map::ExtraValue","header::name::HeaderName","status::StatusCode","header::map::Iter","uri::authority::Authority","uri::port::Port","uri::builder::Builder","header::map::ValueDrain","header::name::InvalidHeaderName","method::Method","header::map::Cursor","uri::InvalidUriParts","header::map::ValueIter","header::map::ValuesMut","header::map::HeaderMap","uri::scheme::Scheme","uri::path::PathAndQuery","response::Parts","header::map::OccupiedEntry","header::name::StandardHeader","response::Builder","status::InvalidStatusCode","uri::InvalidUri","header::value::ToStrError","header::map::Links","uri::Parts","header::map::Keys","uri::scheme::Scheme2","header::map::Values","header::map::Bucket","uri::ErrorKind","header::value::HeaderValue","header::value::InvalidHeaderValue","header::name::Custom","header::map::VacantEntry","header::map::RawLinks","header::name::MaybeLower","header::map::IntoIter","request::Parts","version::Version","response::Response","byte_str::ByteStr","header::map::IterMut","method::InvalidMethod","uri::scheme::Protocol","header::map::GetAll","error::Error","request::Request"]},"header::map::OccupiedEntry":{"T":["header::map::Links","header::map::Link","status::StatusCode","header::map::Entry","uri::builder::Builder","header::name::HdrName","uri::scheme::Scheme2","header::name::Repr","header::map::ValueIter","header::map::ValueDrain","header::map::OccupiedEntry","header::map::HeaderMap","header::map::HashValue","header::name::HeaderName","response::Builder","request::Request","status::InvalidStatusCode","extensions::Extensions","uri::authority::Authority","header::map::Drain","header::map::IntoIter","header::map::Keys","version::Version","header::map::VacantEntry","uri::scheme::Scheme","uri::scheme::Protocol","uri::path::PathAndQuery","header::map::Iter","request::Builder","byte_str::ByteStr","header::name::InvalidHeaderName","header::map::GetAll","header::map::Values","<&mut T as std::fmt::Debug>","header::value::ToStrError","header::value::InvalidHeaderValue","error::Error","response::Response","uri::Uri","header::name::MaybeLower","header::map::RawLinks","response::Parts","request::Parts","header::map::Bucket","header::map::Cursor","header::value::HeaderValue","header::name::StandardHeader","uri::ErrorKind","uri::InvalidUri","method::InvalidMethod","method::Method","header::map::ValuesMut","uri::Parts","uri::InvalidUriParts","header::map::ValueIterMut","header::map::IterMut","header::name::Custom","header::map::ExtraValue","uri::port::Port"]},"header::map::RawLinks":{"T":["header::map::IterMut","uri::builder::Builder","header::map::HeaderMap","version::Version","uri::scheme::Protocol","uri::Parts","header::name::HdrName","header::map::GetAll","header::name::StandardHeader","header::map::OccupiedEntry","header::map::HashValue","header::map::Links","method::Method","request::Request","header::map::VacantEntry","status::StatusCode","uri::authority::Authority","request::Builder","header::map::Cursor","uri::path::PathAndQuery","request::Parts","header::map::ValuesMut","response::Builder","uri::InvalidUriParts","header::map::Values","header::map::IntoIter","header::map::ExtraValue","uri::Uri","header::map::Iter","error::Error","extensions::Extensions","response::Response","uri::ErrorKind","header::name::InvalidHeaderName","status::InvalidStatusCode","header::map::Link","header::map::ValueDrain","header::map::Bucket","uri::port::Port","uri::scheme::Scheme","header::name::MaybeLower","header::map::Keys","header::map::Entry","header::map::Drain","method::InvalidMethod","byte_str::ByteStr","header::map::ValueIter","header::map::ValueIterMut","uri::scheme::Scheme2","<&mut T as std::fmt::Debug>","uri::InvalidUri","response::Parts","header::value::ToStrError","header::name::Custom","header::map::RawLinks","header::value::InvalidHeaderValue","header::name::HeaderName","header::name::Repr","header::value::HeaderValue"]},"header::map::VacantEntry":{"T":["header::name::HeaderName","header::map::OccupiedEntry","header::value::HeaderValue","response::Response","request::Request","uri::scheme::Scheme2","header::map::IntoIter","header::value::InvalidHeaderValue","uri::scheme::Scheme","response::Builder","status::StatusCode","header::name::MaybeLower","header::map::Entry","header::name::InvalidHeaderName","header::map::Cursor","extensions::Extensions","uri::scheme::Protocol","header::map::RawLinks","header::name::Repr","header::value::ToStrError","header::map::IterMut","uri::port::Port","header::map::ValueIter","header::name::HdrName","header::map::Links","header::map::GetAll","method::Method","uri::builder::Builder","uri::InvalidUriParts","header::map::ExtraValue","request::Builder","uri::path::PathAndQuery","response::Parts","uri::Parts","header::map::Bucket","header::map::VacantEntry","header::map::Drain","status::InvalidStatusCode","header::name::Custom","error::Error","header::name::StandardHeader","header::map::ValueDrain","header::map::Keys","uri::ErrorKind","header::map::HeaderMap","<&T as std::fmt::Debug>","header::map::Values","uri::InvalidUri","header::map::ValueIterMut","method::InvalidMethod","byte_str::ByteStr","version::Version","header::map::HashValue","uri::Uri","uri::authority::Authority","header::map::Link","header::map::ValuesMut","header::map::Iter","request::Parts"]},"header::map::ValueDrain":{"T":["header::map::Drain","header::map::ValueIterMut","header::map::ValueDrain","header::map::Iter","<*const T as std::marker::Send>","header::map::IterMut"]},"header::map::ValueIter":{"T":["header::map::GetAll","<*const T as std::fmt::Debug>","header::map::Keys","header::map::Iter","header::value::InvalidHeaderValue","method::InvalidMethod","header::map::VacantEntry","header::map::Link","uri::scheme::Scheme","header::name::Repr","uri::ErrorKind","uri::scheme::Scheme2","uri::port::Port","status::StatusCode","header::name::InvalidHeaderName","method::Method","error::Error","uri::scheme::Protocol","header::map::ValueIterMut","request::Parts","response::Response","header::map::IntoIter","header::map::ValueIter","header::map::HashValue","uri::path::PathAndQuery","header::map::HeaderMap","extensions::Extensions","byte_str::ByteStr","header::name::MaybeLower","uri::builder::Builder","header::map::ExtraValue","uri::InvalidUriParts","header::value::HeaderValue","request::Request","request::Builder","header::value::ToStrError","uri::Parts","header::map::RawLinks","uri::InvalidUri","uri::Uri","status::InvalidStatusCode","header::map::ValuesMut","header::map::ValueDrain","header::name::HeaderName","header::map::Entry","uri::authority::Authority","header::map::Links","header::name::Custom","header::map::Drain","header::name::StandardHeader","header::map::Bucket","response::Builder","response::Parts","version::Version","header::map::Values","header::map::IterMut","header::name::HdrName","header::map::OccupiedEntry","header::map::Cursor"]},"header::map::ValueIterMut":{"T":["header::map::Iter","header::map::ValueDrain","header::map::Drain","header::map::IterMut","<*mut T as std::marker::Send>","header::map::ValueIterMut"]},"header::map::Values":{"T":["header::map::Entry","uri::Uri","uri::Parts","header::value::InvalidHeaderValue","header::map::ValueDrain","uri::authority::Authority","header::map::Keys","status::StatusCode","response::Builder","method::InvalidMethod","<*const T as std::fmt::Debug>","version::Version","uri::port::Port","header::name::Custom","header::map::RawLinks","extensions::Extensions","response::Parts","header::name::InvalidHeaderName","request::Request","header::map::Drain","header::map::HashValue","uri::scheme::Scheme2","uri::builder::Builder","header::value::HeaderValue","request::Parts","uri::InvalidUri","byte_str::ByteStr","status::InvalidStatusCode","header::name::MaybeLower","header::map::Link","header::map::Bucket","header::map::GetAll","header::map::ValueIter","header::name::Repr","header::map::ValuesMut","header::name::StandardHeader","header::name::HeaderName","header::map::OccupiedEntry","header::map::Values","header::map::ExtraValue","header::map::IntoIter","uri::ErrorKind","header::name::HdrName","header::map::VacantEntry","header::map::IterMut","header::map::ValueIterMut","uri::scheme::Protocol","response::Response","header::map::HeaderMap","method::Method","header::value::ToStrError","header::map::Cursor","header::map::Links","request::Builder","error::Error","uri::scheme::Scheme","header::map::Iter","uri::path::PathAndQuery","uri::InvalidUriParts"]},"header::map::ValuesMut":{"T":["header::map::ExtraValue","header::map::Values","header::map::VacantEntry","uri::ErrorKind","header::name::Custom","header::map::GetAll","uri::scheme::Scheme2","header::map::ValueIter","header::map::OccupiedEntry","header::map::ValuesMut","request::Builder","uri::authority::Authority","response::Parts","request::Parts","status::StatusCode","header::map::Link","header::value::HeaderValue","uri::Uri","uri::builder::Builder","header::map::Entry","header::map::Bucket","header::name::HdrName","response::Response","header::map::ValueIterMut","uri::InvalidUri","header::name::MaybeLower","header::map::HashValue","uri::path::PathAndQuery","header::map::IterMut","header::map::HeaderMap","uri::scheme::Protocol","header::map::RawLinks","header::name::Repr","header::name::StandardHeader","header::map::Keys","header::map::Drain","method::InvalidMethod","header::name::InvalidHeaderName","header::map::Iter","uri::scheme::Scheme","<&T as std::fmt::Debug>","response::Builder","byte_str::ByteStr","request::Request","header::value::InvalidHeaderValue","uri::Parts","header::map::ValueDrain","extensions::Extensions","header::map::Cursor","uri::InvalidUriParts","version::Version","header::map::IntoIter","error::Error","method::Method","header::name::HeaderName","header::value::ToStrError","header::map::Links","status::InvalidStatusCode","uri::port::Port"]},"header::name::Repr":{"T":["version::Version","header::name::StandardHeader","header::name::Custom","header::name::Repr","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","byte_str::ByteStr"]},"request::Request":{"T":["uri::builder::Builder","uri::Uri","response::Builder","extensions::Extensions","request::Builder","response::Response","version::Version","method::Method","header::map::HeaderMap","status::StatusCode","request::Request","uri::Parts"]},"response::Response":{"T":["method::Method","uri::Parts","version::Version","request::Builder","header::map::HeaderMap","extensions::Extensions","request::Request","status::StatusCode","uri::builder::Builder","uri::Uri","response::Response","response::Builder"]},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"uri::port::Port":{"T":["uri::port::Port","uri::scheme::Scheme","method::Method","header::value::HeaderValue","uri::authority::Authority","<&mut T as std::fmt::Debug>"]},"uri::scheme::Scheme2":{"T":["uri::path::PathAndQuery","uri::Uri","header::map::Links","std::boxed::Box<byte_str::ByteStr>","uri::scheme::Scheme2","<&mut T as std::fmt::Debug>","header::value::HeaderValue","header::map::HashValue","header::map::RawLinks","header::name::Custom","header::map::HeaderMap","header::name::HeaderName","method::Method","byte_str::ByteStr","header::map::Bucket","version::Version","uri::scheme::Scheme","header::name::Repr","header::map::Link","header::name::StandardHeader","header::map::Cursor","header::name::MaybeLower","status::StatusCode","uri::authority::Authority","header::map::ExtraValue","uri::scheme::Protocol"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Drain<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::Drain<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::Drain<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::Drain<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::GetAll<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::GetAll<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"header::map::Drain":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::clone::Clone","std::marker::Sized","std::convert::TryFrom","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::hash::Hash"]},"request::Request":{"T":["std::default::Default","std::fmt::Debug","std::marker::Sized"]},"response::Response":{"T":["std::marker::Sized","std::fmt::Debug","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::GetAll<'a, T> as std::fmt::Debug>::fmt":{"T":["uri::port::Port","extensions::Extensions","header::map::RawLinks","header::name::InvalidHeaderName","request::Request","header::map::Iter","uri::builder::Builder","response::Builder","method::InvalidMethod","header::map::Link","uri::InvalidUriParts","header::map::ValueDrain","header::map::HashValue","status::InvalidStatusCode","header::name::HdrName","uri::scheme::Scheme","header::map::VacantEntry","<*mut T as std::fmt::Debug>","header::map::OccupiedEntry","method::Method","header::map::ValuesMut","header::value::InvalidHeaderValue","version::Version","header::map::HeaderMap","uri::ErrorKind","uri::authority::Authority","header::map::Links","header::map::Drain","header::value::HeaderValue","header::value::ToStrError","header::map::Cursor","uri::scheme::Scheme2","header::map::Keys","error::Error","uri::Parts","header::name::MaybeLower","response::Parts","status::StatusCode","header::map::Values","header::name::StandardHeader","header::name::Custom","header::map::Entry","<&mut T as std::fmt::Debug>","header::map::ExtraValue","uri::Uri","header::name::Repr","header::map::IntoIter","response::Response","header::map::ValueIter","uri::scheme::Protocol","byte_str::ByteStr","header::map::Bucket","header::map::ValueIterMut","uri::path::PathAndQuery","header::name::HeaderName","request::Parts","request::Builder","uri::InvalidUri","header::map::GetAll","header::map::IterMut"]},"header::map::Bucket":{"T":["uri::scheme::Scheme","header::map::ExtraValue","header::map::HashValue","header::map::HeaderMap","uri::scheme::Scheme2","std::clone::impls::<impl std::clone::Clone for *const T>","uri::scheme::Protocol","uri::path::PathAndQuery","byte_str::ByteStr","header::name::Custom","method::Method","header::value::HeaderValue","header::name::Repr","header::name::StandardHeader","header::name::MaybeLower","status::StatusCode","header::map::Bucket","header::name::HeaderName","header::map::RawLinks","header::map::Links","version::Version","header::map::Link","uri::authority::Authority","header::map::Cursor","uri::Uri"]},"header::map::Drain":{"T":["<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Drain","header::map::IterMut","header::map::ValueIterMut","header::map::Iter"]},"header::map::Entry":{"T":["header::map::Link","method::InvalidMethod","uri::builder::Builder","header::name::HdrName","uri::Parts","uri::port::Port","header::value::ToStrError","uri::scheme::Scheme2","header::map::ValuesMut","<*const T as std::fmt::Debug>","header::map::Entry","header::name::HeaderName","header::name::StandardHeader","header::name::InvalidHeaderName","header::map::ValueIter","request::Request","uri::scheme::Scheme","header::map::RawLinks","header::value::HeaderValue","response::Builder","extensions::Extensions","uri::InvalidUriParts","header::name::Repr","header::map::Drain","header::map::OccupiedEntry","uri::path::PathAndQuery","response::Parts","method::Method","header::map::Values","request::Builder","uri::authority::Authority","header::map::IntoIter","status::InvalidStatusCode","header::map::Keys","uri::InvalidUri","header::map::Links","response::Response","uri::ErrorKind","uri::scheme::Protocol","header::map::Bucket","error::Error","header::map::IterMut","header::map::ValueIterMut","header::map::Cursor","status::StatusCode","header::map::ExtraValue","header::map::GetAll","byte_str::ByteStr","header::map::ValueDrain","header::map::HeaderMap","header::value::InvalidHeaderValue","header::map::HashValue","request::Parts","header::name::Custom","header::map::Iter","uri::Uri","header::name::MaybeLower","header::map::VacantEntry","version::Version"]},"header::map::ExtraValue":{"T":["header::map::HeaderMap","method::Method","header::map::Cursor","header::map::HashValue","uri::path::PathAndQuery","header::map::Bucket","uri::scheme::Scheme2","header::map::Links","header::name::MaybeLower","<*const T as std::fmt::Debug>","header::name::Custom","header::map::RawLinks","byte_str::ByteStr","header::value::HeaderValue","header::name::StandardHeader","header::name::HeaderName","status::StatusCode","uri::Uri","uri::scheme::Protocol","version::Version","uri::authority::Authority","header::map::ExtraValue","header::name::Repr","header::map::Link","uri::scheme::Scheme"]},"header::map::GetAll":{"T":["header::map::HeaderMap","header::map::GetAll","header::name::Repr","header::map::HashValue","header::map::Cursor","header::name::Custom","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::name::StandardHeader","byte_str::ByteStr","uri::ErrorKind","header::map::Link","version::Version"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["header::map::Cursor","uri::Uri","header::map::ValuesMut","header::map::ValueDrain","request::Request","method::InvalidMethod","header::value::HeaderValue","extensions::Extensions","header::map::RawLinks","header::map::OccupiedEntry","error::Error","version::Version","response::Parts","status::StatusCode","uri::scheme::Scheme","<*mut T as std::fmt::Debug>","byte_str::ByteStr","header::map::ValueIter","uri::path::PathAndQuery","header::map::HashValue","status::InvalidStatusCode","header::map::Keys","header::name::InvalidHeaderName","uri::Parts","header::name::HeaderName","uri::InvalidUri","uri::scheme::Scheme2","header::map::GetAll","uri::port::Port","header::map::Bucket","uri::authority::Authority","method::Method","header::name::StandardHeader","header::map::ValueIterMut","uri::scheme::Protocol","header::map::Entry","request::Builder","header::map::VacantEntry","uri::InvalidUriParts","header::name::MaybeLower","header::map::ExtraValue","response::Builder","header::name::Custom","header::map::IterMut","header::map::Values","header::map::IntoIter","header::map::Iter","uri::builder::Builder","uri::ErrorKind","header::map::Link","response::Response","header::value::ToStrError","request::Parts","header::map::HeaderMap","header::value::InvalidHeaderValue","header::name::Repr","header::map::Links","header::map::Drain","header::name::HdrName"]},"header::map::Iter":{"T":["header::map::Iter","header::map::IterMut","header::map::Drain","header::map::ValueDrain","<*const T as std::marker::Sync>","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["<*const T as std::marker::Send>","header::map::ValueDrain","header::map::IterMut","header::map::Drain","header::map::Iter","header::map::ValueIterMut"]},"header::map::Keys":{"T":["extensions::Extensions","uri::InvalidUri","header::name::MaybeLower","header::map::ValuesMut","status::StatusCode","header::map::GetAll","header::map::Keys","header::map::HashValue","uri::scheme::Scheme2","method::InvalidMethod","header::name::HdrName","error::Error","uri::path::PathAndQuery","header::value::HeaderValue","header::map::Links","uri::port::Port","uri::InvalidUriParts","response::Response","uri::authority::Authority","status::InvalidStatusCode","request::Parts","header::map::IterMut","version::Version","header::map::Iter","request::Builder","<*const T as std::fmt::Debug>","method::Method","uri::Parts","header::map::ValueIterMut","uri::Uri","header::map::RawLinks","uri::ErrorKind","uri::builder::Builder","header::map::Bucket","header::map::IntoIter","byte_str::ByteStr","uri::scheme::Scheme","request::Request","header::name::InvalidHeaderName","response::Parts","response::Builder","header::map::Entry","header::name::Repr","header::map::HeaderMap","header::map::Cursor","header::name::StandardHeader","header::map::OccupiedEntry","header::map::VacantEntry","header::value::ToStrError","header::map::ValueIter","header::map::Drain","header::map::ExtraValue","header::map::Values","header::map::ValueDrain","header::value::InvalidHeaderValue","header::map::Link","header::name::Custom","uri::scheme::Protocol","header::name::HeaderName"]},"header::map::OccupiedEntry":{"T":["response::Builder","header::map::RawLinks","header::name::InvalidHeaderName","<&mut T as std::fmt::Debug>","uri::port::Port","uri::scheme::Scheme","header::value::HeaderValue","request::Parts","byte_str::ByteStr","header::name::StandardHeader","header::value::ToStrError","status::InvalidStatusCode","header::name::Custom","header::value::InvalidHeaderValue","header::map::IntoIter","header::map::IterMut","uri::InvalidUri","method::Method","header::map::HashValue","header::map::Iter","header::map::Links","uri::scheme::Protocol","version::Version","request::Request","header::map::ValueIter","uri::ErrorKind","uri::InvalidUriParts","header::map::Values","header::name::Repr","uri::builder::Builder","uri::path::PathAndQuery","status::StatusCode","error::Error","header::map::OccupiedEntry","response::Parts","header::map::GetAll","uri::Parts","header::map::ValuesMut","header::map::Entry","uri::Uri","header::map::Link","header::map::HeaderMap","method::InvalidMethod","header::map::Cursor","header::map::Bucket","extensions::Extensions","uri::scheme::Scheme2","header::map::Drain","header::map::ExtraValue","request::Builder","header::name::HeaderName","header::map::VacantEntry","response::Response","header::map::ValueIterMut","header::map::ValueDrain","header::map::Keys","header::name::HdrName","uri::authority::Authority","header::name::MaybeLower"]},"header::map::RawLinks":{"T":["header::map::ValueIterMut","response::Response","status::StatusCode","header::map::RawLinks","header::map::Links","uri::Uri","uri::Parts","header::map::Bucket","uri::port::Port","response::Parts","header::map::HashValue","header::name::HeaderName","uri::scheme::Protocol","header::map::Link","uri::path::PathAndQuery","uri::ErrorKind","method::InvalidMethod","header::map::HeaderMap","header::map::ValueIter","uri::scheme::Scheme2","version::Version","error::Error","uri::scheme::Scheme","header::map::Drain","header::name::Custom","header::name::HdrName","uri::InvalidUriParts","header::map::VacantEntry","header::value::HeaderValue","extensions::Extensions","header::map::ValueDrain","header::map::Entry","header::value::ToStrError","header::map::Keys","request::Builder","header::name::MaybeLower","header::name::InvalidHeaderName","byte_str::ByteStr","status::InvalidStatusCode","header::map::ValuesMut","header::map::Iter","request::Parts","request::Request","header::map::GetAll","uri::authority::Authority","uri::InvalidUri","method::Method","header::value::InvalidHeaderValue","header::map::ExtraValue","header::name::StandardHeader","<&T as std::fmt::Debug>","header::map::IntoIter","header::map::Values","header::map::IterMut","header::map::Cursor","header::map::OccupiedEntry","response::Builder","header::name::Repr","uri::builder::Builder"]},"header::map::VacantEntry":{"T":["response::Response","header::map::Links","uri::scheme::Protocol","<&mut T as std::fmt::Debug>","header::map::Drain","header::map::GetAll","header::name::HeaderName","header::value::HeaderValue","header::name::HdrName","header::name::InvalidHeaderName","uri::scheme::Scheme","header::map::OccupiedEntry","header::value::ToStrError","version::Version","header::map::ValueIterMut","uri::InvalidUriParts","header::map::RawLinks","request::Builder","request::Parts","header::map::HeaderMap","header::map::Entry","header::map::Values","response::Builder","header::name::Custom","uri::Parts","header::map::Link","uri::builder::Builder","status::InvalidStatusCode","extensions::Extensions","header::map::Bucket","header::name::Repr","header::map::Keys","status::StatusCode","uri::scheme::Scheme2","header::map::ExtraValue","uri::ErrorKind","uri::path::PathAndQuery","header::map::IterMut","byte_str::ByteStr","request::Request","header::map::Cursor","response::Parts","header::map::Iter","uri::authority::Authority","method::Method","header::name::MaybeLower","header::map::HashValue","header::map::ValueDrain","header::map::ValueIter","uri::InvalidUri","method::InvalidMethod","header::map::VacantEntry","header::value::InvalidHeaderValue","header::name::StandardHeader","uri::port::Port","header::map::IntoIter","uri::Uri","error::Error","header::map::ValuesMut"]},"header::map::ValueDrain":{"T":["header::map::IterMut","<*mut T as std::marker::Send>","header::map::Iter","header::map::ValueIterMut","header::map::ValueDrain","header::map::Drain"]},"header::map::ValueIter":{"T":["method::Method","method::InvalidMethod","status::InvalidStatusCode","header::map::Values","header::map::ValuesMut","header::name::StandardHeader","header::map::Links","<*mut T as std::fmt::Debug>","uri::authority::Authority","request::Request","header::map::Cursor","uri::InvalidUri","header::map::ValueIter","header::map::IntoIter","header::name::InvalidHeaderName","uri::scheme::Scheme","header::map::ValueIterMut","header::name::Custom","header::name::HdrName","response::Parts","header::name::MaybeLower","byte_str::ByteStr","header::map::Link","status::StatusCode","extensions::Extensions","header::map::Iter","uri::builder::Builder","header::name::HeaderName","uri::ErrorKind","header::map::Drain","request::Builder","header::map::GetAll","header::map::ExtraValue","header::map::Keys","uri::Uri","header::value::InvalidHeaderValue","header::value::ToStrError","header::map::OccupiedEntry","header::value::HeaderValue","uri::Parts","uri::path::PathAndQuery","header::map::HeaderMap","header::map::Bucket","error::Error","header::map::RawLinks","uri::InvalidUriParts","header::map::IterMut","header::map::VacantEntry","response::Response","header::map::Entry","uri::port::Port","header::map::ValueDrain","header::name::Repr","response::Builder","uri::scheme::Protocol","header::map::HashValue","request::Parts","version::Version","uri::scheme::Scheme2"]},"header::map::ValueIterMut":{"T":["header::map::ValueIterMut","header::map::Iter","header::map::IterMut","header::map::ValueDrain","header::map::Drain","<*const T as std::marker::Sync>"]},"header::map::Values":{"T":["uri::Uri","uri::authority::Authority","header::value::ToStrError","request::Request","header::map::OccupiedEntry","uri::path::PathAndQuery","header::map::ExtraValue","header::name::MaybeLower","header::map::ValueIterMut","<*const T as std::fmt::Debug>","uri::builder::Builder","header::value::HeaderValue","uri::InvalidUri","header::map::Links","method::InvalidMethod","uri::scheme::Protocol","uri::ErrorKind","method::Method","header::map::HashValue","header::name::HdrName","header::map::Values","error::Error","header::name::Repr","status::StatusCode","header::map::Link","header::map::Cursor","response::Response","uri::scheme::Scheme","status::InvalidStatusCode","header::map::ValueDrain","version::Version","response::Parts","header::map::Bucket","uri::Parts","uri::scheme::Scheme2","request::Builder","request::Parts","byte_str::ByteStr","header::map::RawLinks","uri::InvalidUriParts","header::map::VacantEntry","header::map::Entry","header::map::ValuesMut","header::map::GetAll","header::map::Drain","header::map::Keys","header::name::StandardHeader","header::map::IntoIter","header::map::HeaderMap","header::name::Custom","header::name::InvalidHeaderName","header::map::IterMut","extensions::Extensions","header::value::InvalidHeaderValue","header::map::Iter","header::map::ValueIter","uri::port::Port","response::Builder","header::name::HeaderName"]},"header::map::ValuesMut":{"T":["header::map::HashValue","header::map::Values","<*mut T as std::fmt::Debug>","header::map::Iter","status::InvalidStatusCode","header::map::OccupiedEntry","status::StatusCode","header::map::ValueDrain","uri::scheme::Scheme","header::value::HeaderValue","request::Parts","header::map::Link","request::Request","header::name::HeaderName","header::map::ValueIterMut","uri::scheme::Scheme2","header::map::Keys","header::name::Repr","request::Builder","extensions::Extensions","uri::builder::Builder","header::value::InvalidHeaderValue","header::value::ToStrError","header::map::Links","uri::InvalidUriParts","header::map::GetAll","uri::port::Port","header::map::ExtraValue","header::name::StandardHeader","header::name::Custom","method::Method","uri::path::PathAndQuery","header::name::HdrName","uri::scheme::Protocol","response::Builder","header::map::ValuesMut","header::map::Drain","header::map::IntoIter","uri::Parts","method::InvalidMethod","uri::Uri","header::map::Bucket","header::name::MaybeLower","header::map::ValueIter","header::map::RawLinks","header::map::Cursor","response::Response","uri::ErrorKind","header::map::IterMut","header::map::VacantEntry","header::map::Entry","version::Version","uri::InvalidUri","error::Error","header::name::InvalidHeaderName","uri::authority::Authority","response::Parts","byte_str::ByteStr","header::map::HeaderMap"]},"header::name::Repr":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","version::Version","byte_str::ByteStr","header::name::Custom","header::name::StandardHeader","header::name::Repr"]},"request::Request":{"T":["uri::builder::Builder","method::Method","extensions::Extensions","uri::Uri","status::StatusCode","uri::Parts","header::map::HeaderMap","request::Builder","response::Response","response::Builder","version::Version","request::Request"]},"response::Response":{"T":["request::Builder","version::Version","request::Request","header::map::HeaderMap","status::StatusCode","response::Response","response::Builder","method::Method","uri::Parts","uri::builder::Builder","extensions::Extensions","uri::Uri"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["<&mut T as std::convert::AsRef<U>>","header::value::HeaderValue","uri::authority::Authority","uri::scheme::Scheme","uri::port::Port","method::Method"]},"uri::scheme::Scheme2":{"T":["header::map::HashValue","uri::scheme::Scheme2","uri::authority::Authority","byte_str::ByteStr","uri::scheme::Scheme","header::map::Bucket","header::map::HeaderMap","header::name::HeaderName","header::map::Link","uri::scheme::Protocol","header::map::Links","header::value::HeaderValue","header::name::StandardHeader","<&mut T as std::fmt::Debug>","uri::Uri","header::name::Custom","method::Method","header::name::Repr","header::map::Cursor","version::Version","header::name::MaybeLower","header::map::RawLinks","status::StatusCode","uri::path::PathAndQuery","header::map::ExtraValue","std::boxed::Box<byte_str::ByteStr>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::GetAll<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::GetAll<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::GetAll<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::GetAll<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::Entry<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Entry<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::clone::Clone","std::fmt::Debug","std::convert::TryFrom","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized"]},"header::map::IterMut":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sized","std::marker::Sync"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Entry<'a, T> as std::fmt::Debug>::fmt":{"T":["header::map::Bucket","uri::builder::Builder","header::map::Values","uri::InvalidUri","header::map::ValueDrain","<*const T as std::fmt::Debug>","header::name::StandardHeader","header::map::OccupiedEntry","response::Response","header::map::RawLinks","header::value::ToStrError","error::Error","uri::Uri","byte_str::ByteStr","header::map::Cursor","header::map::Drain","method::InvalidMethod","uri::path::PathAndQuery","header::map::Link","uri::Parts","header::name::HdrName","header::map::VacantEntry","header::name::MaybeLower","header::map::ValueIterMut","uri::ErrorKind","header::map::ExtraValue","header::value::HeaderValue","method::Method","uri::authority::Authority","status::StatusCode","header::map::Keys","header::map::ValueIter","request::Request","header::map::HashValue","header::map::Entry","header::name::HeaderName","uri::scheme::Scheme2","header::map::Iter","header::map::IterMut","uri::InvalidUriParts","uri::scheme::Scheme","header::name::InvalidHeaderName","uri::scheme::Protocol","request::Builder","header::map::Links","extensions::Extensions","header::name::Repr","response::Builder","header::map::HeaderMap","header::map::ValuesMut","status::InvalidStatusCode","uri::port::Port","header::map::GetAll","version::Version","header::name::Custom","header::map::IntoIter","response::Parts","header::value::InvalidHeaderValue","request::Parts"]},"header::map::Bucket":{"T":["method::Method","uri::scheme::Scheme2","header::map::RawLinks","header::map::Bucket","header::value::HeaderValue","std::clone::impls::<impl std::clone::Clone for &T>","header::name::Repr","header::name::StandardHeader","header::map::Links","uri::path::PathAndQuery","uri::authority::Authority","byte_str::ByteStr","version::Version","header::name::HeaderName","header::map::HeaderMap","uri::Uri","header::name::Custom","uri::scheme::Protocol","uri::scheme::Scheme","header::name::MaybeLower","header::map::Link","status::StatusCode","header::map::ExtraValue","header::map::HashValue","header::map::Cursor"]},"header::map::Drain":{"T":["header::map::IterMut","header::map::Iter","header::map::ValueDrain","header::map::ValueIterMut","header::map::Drain","<*const T as std::marker::Send>"]},"header::map::Entry":{"T":["version::Version","header::name::InvalidHeaderName","uri::authority::Authority","uri::port::Port","header::map::Keys","header::map::HeaderMap","status::InvalidStatusCode","header::map::ValueDrain","response::Parts","header::map::Drain","error::Error","request::Builder","header::value::ToStrError","uri::builder::Builder","header::map::VacantEntry","header::map::GetAll","header::value::HeaderValue","header::name::MaybeLower","request::Request","uri::Parts","header::map::Iter","extensions::Extensions","header::map::IntoIter","header::name::HdrName","status::StatusCode","header::map::Entry","header::map::RawLinks","header::map::Cursor","header::map::ValuesMut","method::Method","byte_str::ByteStr","response::Response","header::map::HashValue","header::map::Link","header::map::Links","header::name::HeaderName","header::map::ExtraValue","response::Builder","header::map::ValueIterMut","uri::path::PathAndQuery","header::name::Custom","method::InvalidMethod","header::map::Bucket","header::name::StandardHeader","header::value::InvalidHeaderValue","uri::InvalidUriParts","request::Parts","header::name::Repr","uri::scheme::Scheme","header::map::Values","uri::Uri","<&mut T as std::fmt::Debug>","header::map::ValueIter","header::map::OccupiedEntry","uri::InvalidUri","uri::scheme::Protocol","header::map::IterMut","uri::ErrorKind","uri::scheme::Scheme2"]},"header::map::ExtraValue":{"T":["uri::authority::Authority","header::name::StandardHeader","header::map::ExtraValue","header::map::Links","header::name::Repr","status::StatusCode","uri::scheme::Scheme2","header::map::Link","header::map::HashValue","header::map::Cursor","header::name::HeaderName","uri::Uri","header::name::Custom","byte_str::ByteStr","uri::scheme::Scheme","header::map::Bucket","header::map::HeaderMap","uri::scheme::Protocol","header::name::MaybeLower","method::Method","version::Version","header::map::RawLinks","std::clone::impls::<impl std::clone::Clone for *const T>","uri::path::PathAndQuery","header::value::HeaderValue"]},"header::map::GetAll":{"T":["byte_str::ByteStr","header::name::Repr","header::map::GetAll","header::map::Link","uri::ErrorKind","header::name::StandardHeader","header::name::Custom","header::map::Cursor","version::Version","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::map::HashValue","header::map::HeaderMap"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["status::StatusCode","header::map::ValueDrain","header::name::HdrName","header::map::HeaderMap","uri::Parts","header::map::ExtraValue","header::map::Entry","error::Error","header::value::InvalidHeaderValue","byte_str::ByteStr","header::map::Link","uri::authority::Authority","status::InvalidStatusCode","uri::scheme::Scheme","header::map::IntoIter","uri::scheme::Scheme2","header::map::ValuesMut","uri::ErrorKind","header::map::Links","header::map::Values","uri::port::Port","header::map::Bucket","request::Builder","request::Request","uri::InvalidUriParts","header::name::Custom","header::name::StandardHeader","uri::scheme::Protocol","header::map::IterMut","header::map::HashValue","header::name::MaybeLower","method::InvalidMethod","request::Parts","header::value::HeaderValue","extensions::Extensions","uri::InvalidUri","header::name::InvalidHeaderName","version::Version","header::map::ValueIterMut","uri::builder::Builder","response::Builder","header::value::ToStrError","<*const T as std::fmt::Debug>","response::Response","uri::path::PathAndQuery","header::map::GetAll","header::map::Cursor","header::name::Repr","response::Parts","header::map::RawLinks","header::map::OccupiedEntry","header::map::Keys","uri::Uri","header::map::ValueIter","method::Method","header::map::VacantEntry","header::map::Iter","header::name::HeaderName","header::map::Drain"]},"header::map::Iter":{"T":["header::map::ValueIterMut","header::map::IterMut","<*const T as std::marker::Sync>","header::map::Drain","header::map::ValueDrain","header::map::Iter"]},"header::map::IterMut":{"T":["header::map::ValueDrain","header::map::Drain","header::map::IterMut","header::map::Iter","<*mut T as std::marker::Sync>","header::map::ValueIterMut"]},"header::map::Keys":{"T":["header::map::GetAll","header::map::Bucket","header::value::InvalidHeaderValue","uri::InvalidUriParts","uri::port::Port","request::Builder","uri::Uri","response::Builder","header::map::ValueIterMut","uri::ErrorKind","status::InvalidStatusCode","response::Parts","header::map::Link","error::Error","header::value::HeaderValue","request::Request","header::map::ValueDrain","header::map::Cursor","extensions::Extensions","request::Parts","header::map::VacantEntry","version::Version","header::map::IterMut","header::map::Links","uri::builder::Builder","header::name::Custom","header::map::HeaderMap","header::name::HeaderName","header::map::Iter","header::name::HdrName","header::value::ToStrError","header::map::Drain","header::name::MaybeLower","uri::scheme::Protocol","uri::scheme::Scheme2","header::name::StandardHeader","header::map::Keys","header::map::ValueIter","header::map::Values","status::StatusCode","header::map::OccupiedEntry","uri::InvalidUri","<&mut T as std::fmt::Debug>","uri::scheme::Scheme","byte_str::ByteStr","header::name::Repr","header::map::RawLinks","header::map::ValuesMut","uri::path::PathAndQuery","response::Response","header::name::InvalidHeaderName","uri::Parts","method::Method","header::map::ExtraValue","header::map::IntoIter","header::map::HashValue","method::InvalidMethod","header::map::Entry","uri::authority::Authority"]},"header::map::OccupiedEntry":{"T":["uri::scheme::Protocol","header::map::OccupiedEntry","header::map::HeaderMap","header::map::ExtraValue","header::map::ValueIterMut","status::InvalidStatusCode","uri::port::Port","response::Builder","uri::scheme::Scheme","header::map::Values","uri::ErrorKind","version::Version","uri::scheme::Scheme2","header::map::Cursor","header::map::GetAll","header::name::InvalidHeaderName","header::map::ValuesMut","header::name::Repr","header::name::HdrName","request::Parts","uri::InvalidUri","header::name::HeaderName","request::Request","method::Method","header::map::Entry","header::map::ValueDrain","uri::Uri","header::name::Custom","header::map::Links","status::StatusCode","<&T as std::fmt::Debug>","header::map::Iter","header::map::ValueIter","method::InvalidMethod","header::value::HeaderValue","extensions::Extensions","response::Response","header::value::InvalidHeaderValue","header::map::VacantEntry","request::Builder","header::map::IterMut","uri::InvalidUriParts","header::map::RawLinks","header::name::MaybeLower","byte_str::ByteStr","uri::path::PathAndQuery","uri::Parts","error::Error","header::value::ToStrError","response::Parts","header::map::IntoIter","header::map::Keys","header::map::Bucket","header::map::Drain","uri::builder::Builder","header::name::StandardHeader","header::map::Link","uri::authority::Authority","header::map::HashValue"]},"header::map::RawLinks":{"T":["header::map::Keys","uri::builder::Builder","header::map::OccupiedEntry","header::map::Iter","header::value::InvalidHeaderValue","header::map::HeaderMap","byte_str::ByteStr","uri::ErrorKind","header::map::ValueIter","header::map::Link","header::map::IntoIter","header::name::Repr","error::Error","header::name::MaybeLower","header::map::Links","header::map::ValuesMut","header::value::HeaderValue","extensions::Extensions","method::InvalidMethod","<*const T as std::fmt::Debug>","header::map::Values","uri::port::Port","header::name::InvalidHeaderName","uri::Parts","header::name::HeaderName","version::Version","uri::InvalidUri","response::Parts","header::map::IterMut","request::Parts","status::InvalidStatusCode","header::name::StandardHeader","header::map::Drain","header::map::Entry","uri::scheme::Protocol","header::map::ValueDrain","method::Method","response::Builder","header::map::RawLinks","header::map::Cursor","uri::authority::Authority","uri::scheme::Scheme","uri::path::PathAndQuery","request::Builder","header::map::VacantEntry","header::name::HdrName","header::map::ValueIterMut","uri::InvalidUriParts","header::map::ExtraValue","header::map::GetAll","uri::scheme::Scheme2","header::name::Custom","response::Response","header::map::Bucket","status::StatusCode","request::Request","uri::Uri","header::value::ToStrError","header::map::HashValue"]},"header::map::VacantEntry":{"T":["method::Method","header::map::RawLinks","error::Error","uri::scheme::Scheme2","uri::path::PathAndQuery","header::map::ValueDrain","uri::port::Port","header::map::IntoIter","header::map::Keys","header::map::HashValue","method::InvalidMethod","header::map::Iter","version::Version","uri::Uri","response::Builder","response::Response","header::map::HeaderMap","header::name::Custom","byte_str::ByteStr","uri::InvalidUriParts","uri::ErrorKind","header::map::Bucket","header::map::Link","header::name::StandardHeader","header::map::ValueIter","header::map::GetAll","header::map::ValuesMut","<&T as std::fmt::Debug>","response::Parts","header::map::IterMut","uri::authority::Authority","uri::scheme::Scheme","header::name::Repr","header::value::InvalidHeaderValue","header::map::Drain","extensions::Extensions","request::Request","uri::InvalidUri","header::name::HdrName","header::name::InvalidHeaderName","uri::scheme::Protocol","header::map::Entry","header::value::HeaderValue","header::value::ToStrError","header::map::ExtraValue","header::name::HeaderName","request::Parts","uri::builder::Builder","header::map::Links","status::InvalidStatusCode","header::name::MaybeLower","header::map::Values","uri::Parts","status::StatusCode","request::Builder","header::map::VacantEntry","header::map::Cursor","header::map::ValueIterMut","header::map::OccupiedEntry"]},"header::map::ValueDrain":{"T":["header::map::ValueDrain","header::map::ValueIterMut","<*const T as std::marker::Sync>","header::map::Drain","header::map::IterMut","header::map::Iter"]},"header::map::ValueIter":{"T":["response::Builder","header::map::Values","header::map::OccupiedEntry","response::Parts","uri::scheme::Scheme2","header::map::VacantEntry","uri::Parts","header::name::HdrName","uri::scheme::Protocol","uri::path::PathAndQuery","uri::port::Port","header::name::StandardHeader","header::value::HeaderValue","header::map::Drain","header::value::InvalidHeaderValue","uri::InvalidUriParts","status::StatusCode","header::name::MaybeLower","header::map::Link","method::Method","method::InvalidMethod","header::map::Links","header::name::Custom","header::map::ValueDrain","extensions::Extensions","header::map::HeaderMap","header::map::ValueIterMut","uri::scheme::Scheme","uri::InvalidUri","error::Error","<&T as std::fmt::Debug>","header::map::Cursor","header::map::RawLinks","uri::builder::Builder","response::Response","request::Parts","header::value::ToStrError","header::name::HeaderName","header::map::IterMut","request::Builder","header::map::ValueIter","byte_str::ByteStr","uri::ErrorKind","uri::authority::Authority","header::map::ValuesMut","header::map::Bucket","header::map::GetAll","header::map::Iter","uri::Uri","header::map::HashValue","header::map::Keys","header::name::Repr","status::InvalidStatusCode","header::map::Entry","header::map::IntoIter","header::name::InvalidHeaderName","header::map::ExtraValue","version::Version","request::Request"]},"header::map::ValueIterMut":{"T":["header::map::Iter","header::map::ValueDrain","<*const T as std::marker::Sync>","header::map::IterMut","header::map::ValueIterMut","header::map::Drain"]},"header::map::Values":{"T":["status::StatusCode","header::map::IntoIter","header::map::Values","header::map::OccupiedEntry","header::name::HeaderName","header::map::HashValue","uri::InvalidUriParts","request::Request","request::Parts","header::map::Bucket","header::map::ValueIter","header::map::ValuesMut","uri::port::Port","header::map::Entry","extensions::Extensions","status::InvalidStatusCode","header::map::Iter","header::map::Drain","header::map::ValueDrain","header::map::VacantEntry","uri::builder::Builder","header::map::IterMut","header::name::Custom","error::Error","header::name::StandardHeader","uri::Parts","header::map::Cursor","uri::scheme::Scheme","header::value::HeaderValue","uri::InvalidUri","response::Builder","header::map::Links","uri::scheme::Protocol","method::Method","request::Builder","header::map::Link","uri::Uri","byte_str::ByteStr","header::name::Repr","uri::authority::Authority","header::value::InvalidHeaderValue","header::map::Keys","header::name::InvalidHeaderName","header::map::RawLinks","<&mut T as std::fmt::Debug>","header::name::MaybeLower","method::InvalidMethod","header::map::ExtraValue","header::value::ToStrError","header::map::HeaderMap","uri::ErrorKind","uri::scheme::Scheme2","header::map::GetAll","uri::path::PathAndQuery","response::Response","response::Parts","header::name::HdrName","header::map::ValueIterMut","version::Version"]},"header::map::ValuesMut":{"T":["header::map::GetAll","uri::InvalidUri","uri::scheme::Scheme","header::name::MaybeLower","header::map::ValueIterMut","header::value::InvalidHeaderValue","header::name::HeaderName","header::map::OccupiedEntry","header::map::Entry","header::map::Drain","uri::Parts","header::name::Repr","method::InvalidMethod","header::map::ValueIter","header::value::HeaderValue","uri::ErrorKind","uri::scheme::Protocol","header::map::ValuesMut","header::map::Cursor","header::map::RawLinks","byte_str::ByteStr","header::map::VacantEntry","error::Error","header::map::Keys","<&mut T as std::fmt::Debug>","header::map::ValueDrain","header::map::Bucket","header::map::HashValue","uri::builder::Builder","response::Response","header::map::Links","header::name::InvalidHeaderName","status::StatusCode","header::map::IntoIter","status::InvalidStatusCode","header::map::Link","response::Builder","request::Request","header::map::ExtraValue","method::Method","header::name::StandardHeader","header::name::Custom","uri::Uri","uri::scheme::Scheme2","header::map::Values","extensions::Extensions","uri::InvalidUriParts","uri::authority::Authority","request::Parts","request::Builder","header::name::HdrName","response::Parts","header::map::IterMut","uri::path::PathAndQuery","header::map::Iter","uri::port::Port","header::value::ToStrError","version::Version","header::map::HeaderMap"]},"header::name::Repr":{"T":["header::name::Custom","byte_str::ByteStr","<*mut T as std::fmt::Debug>","header::name::Repr","header::name::StandardHeader","version::Version"]},"request::Request":{"T":["extensions::Extensions","version::Version","status::StatusCode","method::Method","request::Request","uri::Parts","response::Response","uri::Uri","header::map::HeaderMap","response::Builder","uri::builder::Builder","request::Builder"]},"response::Response":{"T":["uri::Uri","request::Builder","uri::builder::Builder","uri::Parts","response::Builder","method::Method","request::Request","status::StatusCode","extensions::Extensions","header::map::HeaderMap","version::Version","response::Response"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["<&T as std::fmt::Debug>","uri::authority::Authority","uri::port::Port","header::value::HeaderValue","uri::scheme::Scheme","method::Method"]},"uri::scheme::Scheme2":{"T":["header::name::Custom","uri::Uri","header::name::HeaderName","version::Version","header::map::Cursor","uri::authority::Authority","header::name::StandardHeader","uri::path::PathAndQuery","header::map::ExtraValue","header::map::RawLinks","header::value::HeaderValue","header::map::Bucket","header::name::Repr","byte_str::ByteStr","method::Method","header::name::MaybeLower","uri::scheme::Scheme","std::boxed::Box<byte_str::ByteStr>","header::map::HashValue","std::clone::impls::<impl std::clone::Clone for *const T>","uri::scheme::Protocol","header::map::Links","header::map::HeaderMap","status::StatusCode","header::map::Link","uri::scheme::Scheme2"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Entry<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::Entry<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::Entry<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::Entry<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::VacantEntry<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::VacantEntry<'a, T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Bucket":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::convert::TryFrom"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Send","std::marker::Sync"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Send","std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::marker::Sized","std::clone::Clone"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::convert::AsRef","std::fmt::Debug","std::marker::Sized"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::VacantEntry<'a, T> as std::fmt::Debug>::fmt":{"T":["header::map::GetAll","method::Method","response::Response","response::Builder","header::map::ValueIter","status::InvalidStatusCode","header::value::HeaderValue","header::map::OccupiedEntry","version::Version","header::map::HashValue","header::map::Link","header::map::ValuesMut","header::map::VacantEntry","uri::port::Port","extensions::Extensions","header::map::HeaderMap","header::map::ExtraValue","request::Parts","uri::InvalidUriParts","<&T as std::fmt::Debug>","error::Error","response::Parts","uri::Parts","uri::path::PathAndQuery","header::map::Drain","header::map::ValueIterMut","uri::builder::Builder","header::map::Keys","status::StatusCode","header::name::HeaderName","byte_str::ByteStr","uri::ErrorKind","header::map::Iter","<*mut T as std::fmt::Debug>","header::name::InvalidHeaderName","header::name::Repr","header::map::IterMut","header::map::RawLinks","header::value::ToStrError","uri::scheme::Protocol","request::Request","header::name::HdrName","header::map::Bucket","header::map::Cursor","header::map::ValueDrain","header::map::Links","uri::scheme::Scheme2","header::name::Custom","method::InvalidMethod","header::value::InvalidHeaderValue","header::map::Values","header::name::StandardHeader","header::name::MaybeLower","header::map::IntoIter","uri::Uri","header::map::Entry","uri::scheme::Scheme","request::Builder","uri::InvalidUri","uri::authority::Authority"]},"header::map::Bucket":{"T":["header::name::Repr","version::Version","header::map::ExtraValue","header::map::Cursor","header::value::HeaderValue","method::Method","byte_str::ByteStr","header::name::HeaderName","uri::authority::Authority","header::map::RawLinks","header::map::Link","header::map::HeaderMap","uri::path::PathAndQuery","header::name::StandardHeader","uri::scheme::Scheme","header::map::Links","std::clone::impls::<impl std::clone::Clone for *const T>","uri::scheme::Protocol","header::map::Bucket","status::StatusCode","uri::Uri","header::name::Custom","header::map::HashValue","header::name::MaybeLower","uri::scheme::Scheme2"]},"header::map::Drain":{"T":["header::map::Drain","header::map::IterMut","<*mut T as std::marker::Sync>","header::map::Iter","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::Entry":{"T":["response::Parts","uri::InvalidUriParts","method::Method","request::Parts","header::name::StandardHeader","header::map::ValuesMut","method::InvalidMethod","header::value::HeaderValue","uri::ErrorKind","header::map::ValueDrain","header::map::ValueIterMut","header::map::Links","header::map::ExtraValue","uri::scheme::Scheme2","error::Error","uri::builder::Builder","extensions::Extensions","uri::scheme::Scheme","header::map::Cursor","<*const T as std::fmt::Debug>","header::map::Bucket","header::map::ValueIter","byte_str::ByteStr","header::map::OccupiedEntry","header::name::HdrName","response::Builder","header::map::VacantEntry","header::value::ToStrError","header::name::InvalidHeaderName","header::name::Repr","header::map::HeaderMap","version::Version","header::map::IterMut","uri::port::Port","header::map::Values","header::value::InvalidHeaderValue","uri::InvalidUri","response::Response","header::map::Link","header::map::Keys","request::Request","uri::Uri","header::map::Entry","header::map::RawLinks","uri::path::PathAndQuery","uri::scheme::Protocol","header::name::MaybeLower","status::InvalidStatusCode","header::map::Drain","uri::Parts","header::map::GetAll","header::name::Custom","header::map::Iter","header::map::HashValue","uri::authority::Authority","status::StatusCode","header::name::HeaderName","header::map::IntoIter","request::Builder"]},"header::map::ExtraValue":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","uri::Uri","header::map::Link","header::map::ExtraValue","header::name::MaybeLower","version::Version","header::name::Custom","uri::scheme::Scheme2","uri::scheme::Protocol","uri::path::PathAndQuery","header::value::HeaderValue","byte_str::ByteStr","status::StatusCode","method::Method","header::map::HashValue","header::map::HeaderMap","header::name::Repr","header::name::HeaderName","header::map::Cursor","header::map::Links","header::map::RawLinks","header::name::StandardHeader","uri::scheme::Scheme","header::map::Bucket","uri::authority::Authority"]},"header::map::GetAll":{"T":["header::map::GetAll","uri::ErrorKind","version::Version","header::name::StandardHeader","byte_str::ByteStr","header::map::HashValue","header::name::Custom","header::name::Repr","header::map::Link","header::map::Cursor","header::map::HeaderMap","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["header::map::Cursor","header::map::Links","uri::ErrorKind","header::name::MaybeLower","uri::path::PathAndQuery","header::value::HeaderValue","header::name::HeaderName","status::InvalidStatusCode","header::map::Drain","error::Error","header::map::Iter","header::map::HeaderMap","response::Response","request::Parts","header::map::HashValue","header::map::IntoIter","header::map::VacantEntry","method::Method","uri::InvalidUri","header::name::InvalidHeaderName","uri::Uri","header::value::ToStrError","header::map::ValuesMut","extensions::Extensions","header::map::OccupiedEntry","header::map::ValueDrain","version::Version","uri::InvalidUriParts","header::map::Entry","header::map::Bucket","header::map::Link","header::value::InvalidHeaderValue","uri::port::Port","header::name::HdrName","header::map::ValueIter","header::name::StandardHeader","header::name::Repr","response::Parts","header::map::Keys","uri::builder::Builder","byte_str::ByteStr","method::InvalidMethod","request::Request","response::Builder","<*mut T as std::fmt::Debug>","header::map::RawLinks","uri::Parts","header::map::Values","uri::scheme::Scheme","header::map::IterMut","uri::scheme::Protocol","uri::authority::Authority","request::Builder","header::map::ValueIterMut","header::map::ExtraValue","header::name::Custom","uri::scheme::Scheme2","header::map::GetAll","status::StatusCode"]},"header::map::Iter":{"T":["header::map::ValueIterMut","header::map::IterMut","header::map::ValueDrain","header::map::Iter","header::map::Drain","<*mut T as std::fmt::Debug>"]},"header::map::IterMut":{"T":["header::map::ValueDrain","header::map::IterMut","header::map::Iter","header::map::Drain","<*const T as std::fmt::Debug>","header::map::ValueIterMut"]},"header::map::Keys":{"T":["uri::builder::Builder","header::map::Link","extensions::Extensions","<*const T as std::fmt::Debug>","header::value::InvalidHeaderValue","uri::port::Port","header::name::Repr","error::Error","uri::InvalidUriParts","header::map::HashValue","header::map::Bucket","header::map::GetAll","byte_str::ByteStr","header::map::ValueIter","uri::path::PathAndQuery","uri::scheme::Protocol","header::map::Entry","header::map::ValuesMut","header::map::Values","header::name::HdrName","response::Builder","header::map::Drain","uri::ErrorKind","method::Method","uri::authority::Authority","header::name::Custom","header::value::HeaderValue","uri::scheme::Scheme2","header::map::ValueIterMut","header::map::IterMut","header::map::RawLinks","method::InvalidMethod","header::map::OccupiedEntry","version::Version","header::name::StandardHeader","status::InvalidStatusCode","uri::InvalidUri","header::value::ToStrError","response::Response","header::map::ExtraValue","header::name::HeaderName","request::Builder","header::map::Iter","header::map::ValueDrain","uri::Uri","response::Parts","uri::Parts","header::name::MaybeLower","header::map::Links","header::map::VacantEntry","request::Parts","status::StatusCode","header::map::Keys","header::map::Cursor","header::map::HeaderMap","header::map::IntoIter","uri::scheme::Scheme","request::Request","header::name::InvalidHeaderName"]},"header::map::OccupiedEntry":{"T":["header::map::Iter","header::map::Links","header::map::IterMut","header::map::HeaderMap","header::map::IntoIter","uri::scheme::Scheme2","header::map::Bucket","status::InvalidStatusCode","uri::Parts","header::map::HashValue","method::Method","header::map::Link","header::name::HeaderName","header::map::Keys","uri::path::PathAndQuery","response::Builder","byte_str::ByteStr","header::map::Cursor","method::InvalidMethod","header::map::Drain","extensions::Extensions","header::name::MaybeLower","header::map::Values","header::name::Custom","uri::InvalidUri","header::value::HeaderValue","error::Error","response::Response","header::name::Repr","header::map::GetAll","status::StatusCode","uri::scheme::Protocol","header::map::ValueIter","header::name::InvalidHeaderName","header::name::HdrName","request::Request","version::Version","uri::scheme::Scheme","response::Parts","header::map::Entry","uri::Uri","header::map::ExtraValue","uri::port::Port","header::map::ValueDrain","request::Builder","header::map::ValuesMut","uri::builder::Builder","header::map::RawLinks","<&mut T as std::fmt::Debug>","header::value::InvalidHeaderValue","header::value::ToStrError","header::name::StandardHeader","header::map::VacantEntry","uri::ErrorKind","header::map::OccupiedEntry","uri::InvalidUriParts","uri::authority::Authority","request::Parts","header::map::ValueIterMut"]},"header::map::RawLinks":{"T":["header::map::ExtraValue","header::map::Entry","uri::builder::Builder","uri::scheme::Scheme","uri::port::Port","method::InvalidMethod","header::map::Cursor","header::name::MaybeLower","header::name::StandardHeader","header::map::RawLinks","header::name::HdrName","header::name::Repr","uri::scheme::Protocol","header::map::Iter","header::map::Links","header::map::VacantEntry","header::map::OccupiedEntry","header::map::Link","header::name::InvalidHeaderName","header::map::ValuesMut","header::map::ValueIter","header::map::IntoIter","<&T as std::fmt::Debug>","header::name::HeaderName","request::Parts","header::map::HeaderMap","header::value::ToStrError","response::Builder","header::map::ValueIterMut","response::Parts","header::map::Bucket","byte_str::ByteStr","status::StatusCode","uri::ErrorKind","uri::path::PathAndQuery","header::value::InvalidHeaderValue","uri::InvalidUri","header::map::Values","response::Response","uri::authority::Authority","header::map::IterMut","extensions::Extensions","uri::Uri","header::value::HeaderValue","status::InvalidStatusCode","version::Version","method::Method","header::map::Drain","error::Error","header::map::GetAll","uri::scheme::Scheme2","header::map::ValueDrain","header::map::Keys","header::map::HashValue","header::name::Custom","request::Request","uri::Parts","uri::InvalidUriParts","request::Builder"]},"header::map::VacantEntry":{"T":["header::name::StandardHeader","status::InvalidStatusCode","uri::scheme::Protocol","header::map::Values","header::value::HeaderValue","request::Request","header::map::ValueIter","header::map::OccupiedEntry","header::map::RawLinks","header::map::IterMut","header::map::Link","request::Builder","uri::port::Port","header::map::IntoIter","header::name::Repr","uri::scheme::Scheme2","header::name::MaybeLower","header::map::Iter","header::name::HeaderName","header::name::Custom","error::Error","header::map::HashValue","header::map::Keys","header::map::Cursor","header::map::ValueDrain","method::Method","uri::authority::Authority","version::Version","header::map::GetAll","header::map::Bucket","status::StatusCode","header::map::ValueIterMut","header::value::ToStrError","uri::InvalidUriParts","uri::scheme::Scheme","uri::InvalidUri","header::name::InvalidHeaderName","<&mut T as std::fmt::Debug>","header::map::ValuesMut","response::Builder","byte_str::ByteStr","header::map::ExtraValue","uri::path::PathAndQuery","extensions::Extensions","header::value::InvalidHeaderValue","uri::Parts","header::map::Entry","method::InvalidMethod","header::map::VacantEntry","response::Parts","header::name::HdrName","request::Parts","header::map::HeaderMap","uri::ErrorKind","header::map::Drain","uri::Uri","header::map::Links","uri::builder::Builder","response::Response"]},"header::map::ValueDrain":{"T":["header::map::ValueDrain","header::map::IterMut","header::map::Iter","header::map::Drain","<*const T as std::marker::Send>","header::map::ValueIterMut"]},"header::map::ValueIter":{"T":["request::Builder","header::map::ValueIterMut","header::map::RawLinks","header::map::Links","header::map::Cursor","header::value::ToStrError","header::map::HashValue","header::map::Iter","byte_str::ByteStr","uri::port::Port","request::Request","uri::scheme::Scheme","header::map::ExtraValue","header::name::Repr","response::Parts","header::value::InvalidHeaderValue","header::map::ValuesMut","header::name::StandardHeader","<*mut T as std::fmt::Debug>","extensions::Extensions","header::map::Bucket","uri::scheme::Protocol","uri::path::PathAndQuery","header::name::HeaderName","header::map::IntoIter","header::map::Link","uri::builder::Builder","header::map::IterMut","header::map::Drain","response::Builder","uri::ErrorKind","header::map::Values","header::map::HeaderMap","header::name::Custom","method::Method","header::name::MaybeLower","response::Response","header::map::ValueIter","version::Version","header::map::Entry","error::Error","uri::authority::Authority","header::map::GetAll","header::name::InvalidHeaderName","header::name::HdrName","status::InvalidStatusCode","uri::InvalidUri","header::map::Keys","uri::InvalidUriParts","header::map::VacantEntry","header::map::OccupiedEntry","uri::Parts","request::Parts","header::value::HeaderValue","header::map::ValueDrain","uri::Uri","uri::scheme::Scheme2","method::InvalidMethod","status::StatusCode"]},"header::map::ValueIterMut":{"T":["header::map::ValueIterMut","header::map::ValueDrain","<*mut T as std::fmt::Debug>","header::map::Iter","header::map::IterMut","header::map::Drain"]},"header::map::Values":{"T":["uri::Uri","request::Request","header::map::Values","header::name::InvalidHeaderName","header::map::Link","header::name::HdrName","header::value::HeaderValue","uri::scheme::Scheme","header::map::HeaderMap","error::Error","header::map::Drain","header::map::IntoIter","header::map::Keys","uri::scheme::Scheme2","header::map::ValuesMut","uri::builder::Builder","header::value::ToStrError","header::name::StandardHeader","header::map::ValueDrain","header::name::Custom","uri::InvalidUriParts","uri::path::PathAndQuery","header::map::RawLinks","byte_str::ByteStr","header::map::VacantEntry","header::value::InvalidHeaderValue","header::map::Links","uri::Parts","uri::authority::Authority","header::name::Repr","status::InvalidStatusCode","request::Parts","uri::ErrorKind","header::map::IterMut","header::name::MaybeLower","uri::InvalidUri","method::InvalidMethod","response::Builder","response::Response","extensions::Extensions","header::map::Cursor","header::map::Iter","method::Method","header::map::OccupiedEntry","header::map::GetAll","<&mut T as std::fmt::Debug>","uri::scheme::Protocol","status::StatusCode","header::map::Entry","header::name::HeaderName","uri::port::Port","header::map::ValueIter","request::Builder","header::map::ValueIterMut","header::map::HashValue","header::map::Bucket","version::Version","header::map::ExtraValue","response::Parts"]},"header::map::ValuesMut":{"T":["uri::builder::Builder","extensions::Extensions","header::map::ValueDrain","uri::Parts","header::map::ExtraValue","uri::scheme::Scheme2","header::map::ValuesMut","uri::path::PathAndQuery","uri::Uri","method::Method","header::map::Values","header::map::RawLinks","response::Response","header::name::HeaderName","header::map::HeaderMap","uri::InvalidUriParts","request::Builder","header::map::IntoIter","uri::authority::Authority","header::map::Link","uri::scheme::Scheme","header::value::HeaderValue","header::map::Iter","status::InvalidStatusCode","header::name::Repr","header::name::MaybeLower","version::Version","header::map::Keys","method::InvalidMethod","response::Builder","header::value::InvalidHeaderValue","uri::ErrorKind","header::map::OccupiedEntry","header::map::Entry","header::map::GetAll","byte_str::ByteStr","header::map::Cursor","header::map::Links","header::map::HashValue","uri::port::Port","header::map::IterMut","header::name::StandardHeader","header::map::ValueIterMut","header::name::Custom","header::value::ToStrError","header::name::InvalidHeaderName","request::Parts","header::map::ValueIter","uri::scheme::Protocol","response::Parts","header::map::VacantEntry","request::Request","header::map::Bucket","error::Error","header::map::Drain","<&mut T as std::fmt::Debug>","uri::InvalidUri","header::name::HdrName","status::StatusCode"]},"header::name::Repr":{"T":["header::name::Custom","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","byte_str::ByteStr","header::name::Repr","header::name::StandardHeader","version::Version"]},"request::Request":{"T":["request::Request","extensions::Extensions","request::Builder","header::map::HeaderMap","response::Response","version::Version","uri::Uri","response::Builder","method::Method","uri::builder::Builder","status::StatusCode","uri::Parts"]},"response::Response":{"T":["response::Builder","version::Version","request::Builder","uri::builder::Builder","request::Request","method::Method","response::Response","uri::Uri","uri::Parts","status::StatusCode","header::map::HeaderMap","extensions::Extensions"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["uri::port::Port","uri::scheme::Scheme","uri::authority::Authority","<&T as std::fmt::Debug>","method::Method","header::value::HeaderValue"]},"uri::scheme::Scheme2":{"T":["uri::scheme::Scheme2","byte_str::ByteStr","header::map::Links","header::map::ExtraValue","version::Version","header::value::HeaderValue","uri::path::PathAndQuery","header::map::Cursor","header::name::MaybeLower","header::name::Custom","uri::Uri","header::name::Repr","std::clone::impls::<impl std::clone::Clone for *mut T>","header::map::HashValue","header::name::StandardHeader","uri::scheme::Protocol","uri::scheme::Scheme","header::map::Link","header::map::HeaderMap","std::boxed::Box<byte_str::ByteStr>","method::Method","header::name::HeaderName","header::map::RawLinks","header::map::Bucket","uri::authority::Authority","status::StatusCode"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::VacantEntry<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::VacantEntry<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::VacantEntry<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::VacantEntry<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::OccupiedEntry<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::OccupiedEntry<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::convert::TryFrom"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::marker::Send"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::marker::Send","std::marker::Sync","std::fmt::Debug"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::hash::Hash","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::fmt::Debug","std::default::Default","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"uri::port::Port":{"T":["std::fmt::Debug","std::convert::AsRef","std::marker::Sized"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::OccupiedEntry<'a, T> as std::fmt::Debug>::fmt":{"T":["extensions::Extensions","request::Parts","error::Error","uri::builder::Builder","header::map::IterMut","header::name::HeaderName","response::Parts","header::map::Bucket","method::Method","uri::Parts","header::map::Values","header::name::Custom","header::value::ToStrError","byte_str::ByteStr","header::map::ValueIterMut","uri::ErrorKind","header::map::ValueDrain","header::map::ValuesMut","header::map::IntoIter","uri::Uri","header::value::InvalidHeaderValue","header::map::Link","uri::InvalidUri","header::map::OccupiedEntry","version::Version","method::InvalidMethod","header::map::GetAll","request::Request","header::map::Drain","header::map::ExtraValue","header::name::InvalidHeaderName","header::name::MaybeLower","<*mut T as std::fmt::Debug>","response::Response","header::map::Links","header::map::Iter","uri::path::PathAndQuery","header::map::Entry","status::InvalidStatusCode","header::map::Cursor","header::map::ValueIter","request::Builder","uri::scheme::Protocol","status::StatusCode","uri::scheme::Scheme","header::map::HeaderMap","<&T as std::fmt::Debug>","header::name::StandardHeader","header::name::HdrName","header::value::HeaderValue","header::name::Repr","response::Builder","header::map::VacantEntry","uri::scheme::Scheme2","header::map::Keys","header::map::RawLinks","uri::authority::Authority","header::map::HashValue","uri::InvalidUriParts","uri::port::Port"]},"header::map::Bucket":{"T":["header::map::Link","uri::scheme::Scheme","uri::Uri","header::map::Links","version::Version","<*mut T as std::fmt::Debug>","header::map::Cursor","header::map::HeaderMap","uri::path::PathAndQuery","byte_str::ByteStr","uri::scheme::Scheme2","header::map::HashValue","header::value::HeaderValue","uri::authority::Authority","header::map::RawLinks","header::name::StandardHeader","uri::scheme::Protocol","header::name::Custom","method::Method","header::name::HeaderName","header::map::Bucket","header::name::MaybeLower","status::StatusCode","header::map::ExtraValue","header::name::Repr"]},"header::map::Drain":{"T":["header::map::IterMut","header::map::Iter","header::map::Drain","<*const T as std::marker::Sync>","header::map::ValueDrain","header::map::ValueIterMut"]},"header::map::Entry":{"T":["response::Builder","header::map::Drain","header::map::Iter","header::map::Values","uri::scheme::Protocol","header::map::HeaderMap","header::map::ValueDrain","header::map::ValueIter","response::Parts","header::map::IterMut","uri::path::PathAndQuery","header::map::GetAll","header::map::Cursor","header::map::HashValue","header::name::HeaderName","uri::ErrorKind","extensions::Extensions","request::Request","header::map::Bucket","uri::authority::Authority","header::value::ToStrError","response::Response","uri::port::Port","header::name::Repr","header::map::ValuesMut","header::map::VacantEntry","header::name::HdrName","header::map::RawLinks","uri::scheme::Scheme2","uri::builder::Builder","<&mut T as std::fmt::Debug>","header::map::OccupiedEntry","status::StatusCode","version::Version","method::InvalidMethod","header::map::ValueIterMut","header::name::MaybeLower","header::map::Link","request::Builder","header::value::HeaderValue","header::value::InvalidHeaderValue","method::Method","request::Parts","header::map::Entry","header::name::Custom","header::map::Links","uri::Uri","header::map::Keys","error::Error","uri::InvalidUriParts","header::name::InvalidHeaderName","uri::scheme::Scheme","byte_str::ByteStr","uri::InvalidUri","header::map::ExtraValue","header::name::StandardHeader","header::map::IntoIter","status::InvalidStatusCode","uri::Parts"]},"header::map::ExtraValue":{"T":["header::map::Links","std::clone::impls::<impl std::clone::Clone for &mut T>","header::name::Custom","uri::scheme::Scheme2","uri::scheme::Protocol","uri::authority::Authority","header::map::Link","status::StatusCode","header::map::Cursor","header::map::Bucket","method::Method","header::value::HeaderValue","header::map::HeaderMap","header::map::RawLinks","version::Version","header::map::ExtraValue","uri::path::PathAndQuery","header::name::Repr","header::name::MaybeLower","uri::scheme::Scheme","byte_str::ByteStr","header::name::StandardHeader","uri::Uri","header::name::HeaderName","header::map::HashValue"]},"header::map::GetAll":{"T":["header::name::StandardHeader","header::map::Link","<*mut T as std::fmt::Debug>","header::map::HeaderMap","version::Version","uri::ErrorKind","header::map::HashValue","header::map::GetAll","header::name::Custom","header::name::Repr","header::map::Cursor","byte_str::ByteStr"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::IterMut","header::map::ValuesMut","header::map::Link","uri::scheme::Protocol","header::map::GetAll","method::Method","response::Builder","uri::InvalidUri","header::map::ValueDrain","header::map::Values","uri::InvalidUriParts","response::Parts","header::value::InvalidHeaderValue","header::name::MaybeLower","header::name::StandardHeader","header::name::Custom","header::map::OccupiedEntry","header::map::Iter","header::name::HeaderName","header::value::HeaderValue","request::Request","status::InvalidStatusCode","uri::path::PathAndQuery","header::map::ExtraValue","header::map::Drain","status::StatusCode","extensions::Extensions","uri::scheme::Scheme2","header::map::VacantEntry","header::value::ToStrError","header::map::ValueIterMut","header::map::RawLinks","uri::ErrorKind","request::Builder","uri::port::Port","header::map::Entry","header::map::Links","header::map::HeaderMap","header::name::HdrName","header::map::Cursor","header::map::Keys","version::Version","byte_str::ByteStr","uri::scheme::Scheme","header::map::ValueIter","request::Parts","response::Response","uri::Parts","uri::builder::Builder","<&mut T as std::fmt::Debug>","header::name::InvalidHeaderName","uri::authority::Authority","uri::Uri","header::name::Repr","header::map::Bucket","method::InvalidMethod","header::map::IntoIter","header::map::HashValue","error::Error"]},"header::map::Iter":{"T":["header::map::Iter","header::map::ValueDrain","header::map::Drain","header::map::IterMut","header::map::ValueIterMut","<*const T as std::fmt::Debug>"]},"header::map::IterMut":{"T":["header::map::ValueIterMut","<*const T as std::marker::Send>","header::map::ValueDrain","header::map::IterMut","header::map::Drain","header::map::Iter"]},"header::map::Keys":{"T":["header::name::InvalidHeaderName","header::value::InvalidHeaderValue","byte_str::ByteStr","request::Parts","response::Builder","header::map::GetAll","<*const T as std::fmt::Debug>","header::name::HdrName","uri::scheme::Scheme2","uri::builder::Builder","response::Parts","uri::Uri","header::name::StandardHeader","status::InvalidStatusCode","header::map::Links","header::map::IntoIter","method::InvalidMethod","header::map::Cursor","header::name::Custom","header::map::Keys","error::Error","request::Request","uri::Parts","uri::scheme::Scheme","header::map::Bucket","header::map::ExtraValue","header::map::ValueIter","header::map::Drain","version::Version","uri::port::Port","header::map::Values","header::map::IterMut","request::Builder","uri::path::PathAndQuery","header::name::Repr","header::value::HeaderValue","uri::ErrorKind","extensions::Extensions","uri::scheme::Protocol","uri::InvalidUriParts","header::map::Iter","header::map::ValueDrain","method::Method","status::StatusCode","header::map::ValueIterMut","header::map::OccupiedEntry","header::map::Entry","header::map::HeaderMap","uri::InvalidUri","header::map::VacantEntry","header::map::Link","header::map::RawLinks","header::map::HashValue","uri::authority::Authority","header::value::ToStrError","response::Response","header::name::MaybeLower","header::name::HeaderName","header::map::ValuesMut"]},"header::map::OccupiedEntry":{"T":["header::map::HashValue","header::map::Drain","header::name::MaybeLower","method::Method","status::InvalidStatusCode","method::InvalidMethod","header::name::Custom","request::Builder","uri::ErrorKind","header::map::Iter","uri::port::Port","version::Version","uri::path::PathAndQuery","request::Parts","uri::scheme::Scheme","<&mut T as std::fmt::Debug>","header::map::Bucket","header::value::InvalidHeaderValue","uri::Uri","uri::scheme::Scheme2","header::map::HeaderMap","header::map::GetAll","header::map::ValueDrain","uri::builder::Builder","header::map::RawLinks","header::name::InvalidHeaderName","header::map::VacantEntry","header::name::HeaderName","header::map::Keys","header::map::ValueIterMut","uri::scheme::Protocol","header::map::Link","uri::Parts","response::Parts","byte_str::ByteStr","request::Request","uri::authority::Authority","status::StatusCode","response::Builder","header::value::HeaderValue","header::map::Values","header::name::Repr","header::map::Cursor","header::map::Entry","header::map::Links","header::map::ExtraValue","error::Error","header::map::IntoIter","response::Response","uri::InvalidUri","header::value::ToStrError","extensions::Extensions","header::name::StandardHeader","header::map::OccupiedEntry","header::map::ValueIter","header::map::IterMut","header::name::HdrName","header::map::ValuesMut","uri::InvalidUriParts"]},"header::map::RawLinks":{"T":["uri::Uri","header::map::ValuesMut","header::map::IntoIter","response::Parts","header::map::Entry","header::map::Keys","header::map::Link","header::map::HeaderMap","header::map::Drain","header::map::Iter","uri::path::PathAndQuery","uri::builder::Builder","header::map::OccupiedEntry","header::map::Values","uri::scheme::Scheme","header::map::ValueIterMut","uri::ErrorKind","header::map::IterMut","header::name::Custom","method::Method","header::map::ValueIter","status::InvalidStatusCode","header::map::RawLinks","version::Version","<*mut T as std::fmt::Debug>","uri::scheme::Scheme2","status::StatusCode","header::map::ValueDrain","header::value::InvalidHeaderValue","request::Builder","error::Error","uri::InvalidUriParts","header::value::ToStrError","header::value::HeaderValue","byte_str::ByteStr","response::Response","uri::Parts","header::map::ExtraValue","header::name::InvalidHeaderName","header::name::HdrName","response::Builder","uri::InvalidUri","uri::authority::Authority","header::map::Bucket","header::name::HeaderName","request::Request","header::map::VacantEntry","header::map::Links","uri::scheme::Protocol","extensions::Extensions","header::name::StandardHeader","header::map::GetAll","request::Parts","header::name::Repr","header::name::MaybeLower","method::InvalidMethod","header::map::Cursor","uri::port::Port","header::map::HashValue"]},"header::map::VacantEntry":{"T":["uri::InvalidUriParts","uri::port::Port","byte_str::ByteStr","header::map::HashValue","error::Error","response::Parts","header::map::Cursor","header::name::HeaderName","header::map::Entry","uri::builder::Builder","method::InvalidMethod","request::Request","uri::authority::Authority","header::map::IterMut","header::map::HeaderMap","header::value::InvalidHeaderValue","header::map::Links","uri::scheme::Protocol","header::name::Repr","uri::Uri","header::name::Custom","method::Method","uri::InvalidUri","header::map::ValueDrain","header::map::Link","header::map::ExtraValue","header::map::Values","header::name::StandardHeader","header::map::RawLinks","request::Builder","status::InvalidStatusCode","uri::Parts","header::map::ValuesMut","<&T as std::fmt::Debug>","header::map::Keys","version::Version","header::map::ValueIterMut","status::StatusCode","uri::scheme::Scheme","uri::ErrorKind","header::name::MaybeLower","response::Response","uri::scheme::Scheme2","header::map::ValueIter","header::value::HeaderValue","header::value::ToStrError","header::map::GetAll","header::map::Iter","header::map::Bucket","uri::path::PathAndQuery","request::Parts","header::map::IntoIter","header::name::InvalidHeaderName","header::map::VacantEntry","header::map::Drain","header::map::OccupiedEntry","header::name::HdrName","response::Builder","extensions::Extensions"]},"header::map::ValueDrain":{"T":["header::map::ValueIterMut","header::map::IterMut","<*mut T as std::marker::Send>","header::map::Iter","header::map::ValueDrain","header::map::Drain"]},"header::map::ValueIter":{"T":["request::Parts","header::map::Entry","header::map::HeaderMap","header::map::ValueDrain","header::map::Drain","uri::path::PathAndQuery","uri::Parts","header::name::HdrName","header::map::RawLinks","header::map::IterMut","uri::port::Port","uri::InvalidUriParts","header::map::ValueIter","header::map::OccupiedEntry","header::map::Cursor","header::map::ExtraValue","header::name::Repr","method::InvalidMethod","header::value::HeaderValue","header::map::Keys","header::name::HeaderName","uri::Uri","header::map::HashValue","header::map::Links","header::map::GetAll","extensions::Extensions","request::Request","uri::scheme::Protocol","method::Method","uri::scheme::Scheme","status::StatusCode","header::map::Bucket","request::Builder","error::Error","header::value::ToStrError","header::name::MaybeLower","uri::authority::Authority","header::map::Iter","uri::builder::Builder","header::name::InvalidHeaderName","header::value::InvalidHeaderValue","byte_str::ByteStr","header::map::ValuesMut","header::name::Custom","response::Response","uri::scheme::Scheme2","response::Builder","header::map::VacantEntry","header::map::ValueIterMut","header::map::IntoIter","header::map::Link","uri::ErrorKind","response::Parts","status::InvalidStatusCode","version::Version","<&T as std::fmt::Debug>","uri::InvalidUri","header::name::StandardHeader","header::map::Values"]},"header::map::ValueIterMut":{"T":["header::map::Iter","header::map::ValueDrain","header::map::Drain","<*mut T as std::fmt::Debug>","header::map::IterMut","header::map::ValueIterMut"]},"header::map::Values":{"T":["uri::scheme::Scheme","header::map::GetAll","header::map::Links","request::Builder","method::InvalidMethod","header::map::IntoIter","header::map::Cursor","status::StatusCode","extensions::Extensions","uri::path::PathAndQuery","version::Version","header::map::ValueIterMut","uri::builder::Builder","header::map::Link","request::Request","header::name::HdrName","byte_str::ByteStr","header::map::OccupiedEntry","uri::Parts","header::name::Repr","uri::InvalidUri","error::Error","header::map::Bucket","header::map::Values","uri::scheme::Protocol","uri::InvalidUriParts","header::map::IterMut","header::value::InvalidHeaderValue","uri::scheme::Scheme2","uri::authority::Authority","uri::Uri","header::map::Keys","header::map::ExtraValue","header::name::InvalidHeaderName","response::Parts","header::map::Entry","<&mut T as std::fmt::Debug>","header::map::VacantEntry","header::map::Iter","header::name::HeaderName","status::InvalidStatusCode","request::Parts","header::name::StandardHeader","header::map::RawLinks","uri::port::Port","header::value::HeaderValue","uri::ErrorKind","header::map::ValuesMut","header::map::HeaderMap","response::Builder","header::map::Drain","method::Method","response::Response","header::value::ToStrError","header::map::ValueDrain","header::name::MaybeLower","header::map::ValueIter","header::name::Custom","header::map::HashValue"]},"header::map::ValuesMut":{"T":["header::map::Entry","method::Method","header::map::ValueDrain","uri::path::PathAndQuery","request::Builder","header::map::Iter","header::map::Bucket","uri::Parts","uri::port::Port","header::map::RawLinks","uri::builder::Builder","error::Error","header::map::ValueIter","response::Parts","uri::scheme::Protocol","uri::scheme::Scheme2","header::map::OccupiedEntry","uri::authority::Authority","response::Builder","header::map::ValuesMut","header::name::HeaderName","header::map::IterMut","uri::InvalidUri","request::Request","header::value::InvalidHeaderValue","extensions::Extensions","header::map::IntoIter","response::Response","header::map::Drain","header::name::Repr","header::map::HashValue","header::map::GetAll","status::InvalidStatusCode","header::map::ExtraValue","header::value::ToStrError","header::map::Cursor","header::name::Custom","header::name::StandardHeader","header::map::VacantEntry","header::name::HdrName","uri::ErrorKind","version::Version","uri::InvalidUriParts","header::name::MaybeLower","uri::scheme::Scheme","header::name::InvalidHeaderName","header::map::HeaderMap","header::map::ValueIterMut","header::map::Keys","method::InvalidMethod","request::Parts","status::StatusCode","byte_str::ByteStr","uri::Uri","header::map::Link","<&mut T as std::fmt::Debug>","header::value::HeaderValue","header::map::Values","header::map::Links"]},"header::name::Repr":{"T":["header::name::Custom","std::hash::impls::<impl std::hash::Hash for *const T>","header::name::Repr","byte_str::ByteStr","header::name::StandardHeader","version::Version"]},"request::Request":{"T":["uri::Uri","response::Builder","method::Method","extensions::Extensions","request::Builder","uri::builder::Builder","header::map::HeaderMap","uri::Parts","status::StatusCode","version::Version","request::Request","response::Response"]},"response::Response":{"T":["request::Builder","uri::Uri","uri::builder::Builder","header::map::HeaderMap","response::Builder","extensions::Extensions","status::StatusCode","request::Request","version::Version","method::Method","uri::Parts","response::Response"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"uri::port::Port":{"T":["uri::authority::Authority","uri::port::Port","uri::scheme::Scheme","header::value::HeaderValue","method::Method","<&T as std::convert::AsRef<U>>"]},"uri::scheme::Scheme2":{"T":["header::name::StandardHeader","header::name::HeaderName","uri::authority::Authority","header::name::Repr","uri::Uri","header::name::Custom","uri::scheme::Scheme","header::map::Links","method::Method","header::value::HeaderValue","header::map::HeaderMap","header::map::RawLinks","header::map::Bucket","header::map::ExtraValue","uri::path::PathAndQuery","header::map::HashValue","version::Version","status::StatusCode","byte_str::ByteStr","uri::scheme::Scheme2","header::map::Link","uri::scheme::Protocol","header::map::Cursor","std::clone::impls::<impl std::clone::Clone for *mut T>","header::name::MaybeLower","std::boxed::Box<byte_str::ByteStr>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::OccupiedEntry<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::OccupiedEntry<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::OccupiedEntry<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::ValueIter<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ValueIter<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized"]},"header::map::IterMut":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::marker::Send"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::hash::Hash","std::marker::Sized"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::default::Default","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::fmt::Debug","std::convert::AsRef"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ValueIter<'a, T> as std::fmt::Debug>::fmt":{"T":["header::name::Repr","<&T as std::fmt::Debug>","uri::port::Port","header::map::RawLinks","header::map::Iter","header::map::ExtraValue","header::map::Cursor","header::map::HeaderMap","header::map::Keys","header::value::ToStrError","header::map::Values","method::InvalidMethod","header::map::ValuesMut","request::Request","error::Error","uri::scheme::Scheme","header::map::ValueDrain","uri::ErrorKind","header::value::InvalidHeaderValue","uri::scheme::Scheme2","header::map::HashValue","header::map::IntoIter","header::name::MaybeLower","header::name::Custom","uri::builder::Builder","uri::InvalidUriParts","<*mut T as std::fmt::Debug>","uri::path::PathAndQuery","uri::Uri","header::map::Drain","uri::InvalidUri","header::name::HeaderName","uri::scheme::Protocol","method::Method","header::name::HdrName","header::map::OccupiedEntry","header::map::Link","uri::authority::Authority","request::Parts","status::InvalidStatusCode","header::map::ValueIter","header::map::Entry","header::value::HeaderValue","extensions::Extensions","uri::Parts","status::StatusCode","header::map::IterMut","response::Parts","response::Response","header::map::Links","header::name::StandardHeader","request::Builder","header::map::Bucket","version::Version","response::Builder","header::name::InvalidHeaderName","header::map::ValueIterMut","byte_str::ByteStr","header::map::VacantEntry","header::map::GetAll"]},"header::map::Bucket":{"T":["header::map::RawLinks","header::map::Bucket","header::map::HashValue","uri::scheme::Protocol","uri::authority::Authority","uri::scheme::Scheme","header::map::ExtraValue","uri::scheme::Scheme2","header::map::HeaderMap","header::map::Links","header::name::Custom","version::Version","method::Method","std::clone::impls::<impl std::clone::Clone for &T>","header::name::Repr","uri::path::PathAndQuery","header::name::MaybeLower","byte_str::ByteStr","header::map::Cursor","header::map::Link","header::name::StandardHeader","header::value::HeaderValue","header::name::HeaderName","uri::Uri","status::StatusCode"]},"header::map::Drain":{"T":["header::map::IterMut","<*mut T as std::marker::Send>","header::map::Iter","header::map::ValueIterMut","header::map::Drain","header::map::ValueDrain"]},"header::map::Entry":{"T":["error::Error","header::map::ValueDrain","response::Response","method::Method","uri::Uri","header::map::Keys","uri::authority::Authority","header::map::Cursor","header::name::Custom","status::StatusCode","version::Version","header::map::ValueIterMut","header::map::Entry","header::value::InvalidHeaderValue","header::map::Values","header::map::HashValue","header::name::HdrName","header::map::ValuesMut","header::map::IntoIter","uri::path::PathAndQuery","header::map::Link","uri::InvalidUri","request::Request","header::map::HeaderMap","header::map::OccupiedEntry","response::Parts","response::Builder","header::name::InvalidHeaderName","header::map::ValueIter","header::map::Drain","header::map::IterMut","header::map::Iter","status::InvalidStatusCode","request::Builder","header::value::HeaderValue","header::map::VacantEntry","uri::scheme::Scheme2","header::map::GetAll","header::map::Links","uri::port::Port","header::name::HeaderName","uri::builder::Builder","method::InvalidMethod","uri::scheme::Scheme","header::map::Bucket","header::name::StandardHeader","request::Parts","header::map::RawLinks","uri::scheme::Protocol","header::name::Repr","uri::InvalidUriParts","<*mut T as std::fmt::Debug>","extensions::Extensions","uri::ErrorKind","header::value::ToStrError","header::name::MaybeLower","header::map::ExtraValue","byte_str::ByteStr","uri::Parts"]},"header::map::ExtraValue":{"T":["method::Method","<&mut T as std::fmt::Debug>","header::map::RawLinks","uri::authority::Authority","header::map::Cursor","version::Version","header::map::Bucket","header::map::ExtraValue","header::name::HeaderName","header::map::Link","header::name::Repr","uri::scheme::Scheme2","header::name::StandardHeader","header::name::MaybeLower","header::map::HashValue","status::StatusCode","header::map::Links","uri::scheme::Scheme","uri::path::PathAndQuery","byte_str::ByteStr","header::name::Custom","header::map::HeaderMap","header::value::HeaderValue","uri::Uri","uri::scheme::Protocol"]},"header::map::GetAll":{"T":["header::map::HashValue","header::map::GetAll","header::map::Cursor","version::Version","header::map::Link","uri::ErrorKind","header::name::StandardHeader","byte_str::ByteStr","header::map::HeaderMap","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::name::Repr","header::name::Custom"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::Drain","header::name::StandardHeader","uri::InvalidUri","request::Parts","uri::builder::Builder","uri::port::Port","header::map::Cursor","header::map::Entry","status::InvalidStatusCode","header::map::Link","header::name::InvalidHeaderName","<*const T as std::fmt::Debug>","header::map::Links","uri::ErrorKind","response::Builder","request::Builder","uri::InvalidUriParts","header::map::ValuesMut","header::map::OccupiedEntry","status::StatusCode","header::map::RawLinks","header::name::Custom","uri::authority::Authority","header::map::VacantEntry","header::map::Values","version::Version","header::map::IntoIter","request::Request","uri::scheme::Protocol","response::Parts","byte_str::ByteStr","header::map::Iter","header::value::HeaderValue","header::map::ValueDrain","uri::scheme::Scheme","response::Response","extensions::Extensions","header::map::ValueIterMut","header::name::HdrName","header::map::ValueIter","header::map::HeaderMap","uri::path::PathAndQuery","header::map::GetAll","uri::Uri","header::value::InvalidHeaderValue","header::name::Repr","method::Method","header::map::Keys","header::map::IterMut","uri::Parts","header::name::HeaderName","header::map::Bucket","method::InvalidMethod","header::map::ExtraValue","header::map::HashValue","error::Error","header::name::MaybeLower","uri::scheme::Scheme2","header::value::ToStrError"]},"header::map::Iter":{"T":["header::map::Iter","header::map::ValueDrain","header::map::IterMut","<*const T as std::marker::Sync>","header::map::Drain","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["header::map::Drain","header::map::ValueDrain","header::map::ValueIterMut","<*const T as std::marker::Sync>","header::map::IterMut","header::map::Iter"]},"header::map::Keys":{"T":["response::Builder","header::name::StandardHeader","header::map::IntoIter","header::map::Values","header::map::ValuesMut","header::map::GetAll","header::map::IterMut","uri::Uri","uri::Parts","response::Response","header::map::Drain","header::name::HeaderName","version::Version","uri::builder::Builder","extensions::Extensions","request::Request","uri::InvalidUriParts","method::Method","header::map::RawLinks","error::Error","request::Builder","request::Parts","uri::scheme::Protocol","uri::authority::Authority","uri::scheme::Scheme2","uri::InvalidUri","header::value::ToStrError","byte_str::ByteStr","header::map::Keys","header::map::HeaderMap","header::name::Custom","method::InvalidMethod","header::name::Repr","header::map::Bucket","status::InvalidStatusCode","header::value::HeaderValue","header::map::ValueIter","header::map::VacantEntry","uri::ErrorKind","status::StatusCode","response::Parts","header::name::MaybeLower","header::map::Links","header::map::Iter","header::map::ValueDrain","header::map::ValueIterMut","header::map::Cursor","header::map::HashValue","header::map::ExtraValue","header::map::OccupiedEntry","<&mut T as std::fmt::Debug>","uri::scheme::Scheme","uri::path::PathAndQuery","header::name::InvalidHeaderName","header::map::Entry","header::value::InvalidHeaderValue","uri::port::Port","header::map::Link","header::name::HdrName"]},"header::map::OccupiedEntry":{"T":["header::value::InvalidHeaderValue","header::map::Iter","uri::authority::Authority","header::map::IterMut","header::map::ValueIterMut","uri::Parts","uri::scheme::Protocol","header::map::VacantEntry","uri::builder::Builder","header::map::GetAll","header::map::ValueIter","header::map::OccupiedEntry","status::StatusCode","header::value::HeaderValue","header::map::Entry","header::map::ValueDrain","version::Version","byte_str::ByteStr","header::map::HashValue","<*mut T as std::fmt::Debug>","error::Error","status::InvalidStatusCode","header::map::Link","method::Method","header::map::ExtraValue","request::Parts","response::Parts","response::Response","header::map::ValuesMut","header::map::Cursor","header::map::Values","header::name::Repr","header::map::HeaderMap","header::map::Bucket","uri::InvalidUri","header::name::MaybeLower","header::name::HeaderName","method::InvalidMethod","header::map::Links","header::map::RawLinks","uri::path::PathAndQuery","header::map::Drain","response::Builder","uri::port::Port","header::name::InvalidHeaderName","uri::scheme::Scheme","header::name::StandardHeader","header::map::Keys","uri::InvalidUriParts","header::map::IntoIter","uri::scheme::Scheme2","extensions::Extensions","request::Request","header::name::HdrName","uri::Uri","header::value::ToStrError","header::name::Custom","request::Builder","uri::ErrorKind"]},"header::map::RawLinks":{"T":["method::InvalidMethod","header::value::InvalidHeaderValue","header::map::OccupiedEntry","header::map::GetAll","header::map::RawLinks","response::Response","header::map::IntoIter","status::InvalidStatusCode","header::map::VacantEntry","header::map::Values","uri::InvalidUriParts","request::Request","request::Parts","header::name::HdrName","header::map::Keys","uri::builder::Builder","header::map::HeaderMap","header::value::HeaderValue","header::map::Bucket","uri::InvalidUri","header::map::Link","header::map::Iter","uri::ErrorKind","header::map::Drain","header::name::MaybeLower","header::map::ExtraValue","uri::scheme::Scheme","extensions::Extensions","header::name::StandardHeader","uri::scheme::Scheme2","uri::port::Port","version::Version","method::Method","header::value::ToStrError","header::map::IterMut","error::Error","header::map::ValueIter","uri::Uri","uri::authority::Authority","request::Builder","header::map::Entry","uri::Parts","header::name::HeaderName","uri::scheme::Protocol","header::map::Links","header::map::ValuesMut","header::map::ValueIterMut","header::map::Cursor","response::Parts","byte_str::ByteStr","header::map::HashValue","status::StatusCode","header::name::Custom","header::name::InvalidHeaderName","uri::path::PathAndQuery","header::name::Repr","<*const T as std::fmt::Debug>","header::map::ValueDrain","response::Builder"]},"header::map::VacantEntry":{"T":["status::StatusCode","uri::Parts","header::map::ValuesMut","request::Request","header::map::OccupiedEntry","status::InvalidStatusCode","request::Parts","uri::ErrorKind","header::value::InvalidHeaderValue","uri::scheme::Protocol","header::map::HeaderMap","byte_str::ByteStr","header::map::RawLinks","header::map::ValueIterMut","uri::scheme::Scheme2","header::map::Entry","<&T as std::fmt::Debug>","header::map::Iter","uri::Uri","header::value::HeaderValue","response::Builder","header::name::StandardHeader","header::map::ValueIter","version::Version","header::map::ValueDrain","uri::port::Port","request::Builder","header::map::IterMut","header::map::ExtraValue","uri::authority::Authority","uri::path::PathAndQuery","uri::InvalidUri","header::value::ToStrError","header::name::HeaderName","header::name::HdrName","header::map::Bucket","header::map::Cursor","uri::scheme::Scheme","response::Parts","extensions::Extensions","header::map::IntoIter","header::map::Keys","method::Method","header::map::GetAll","uri::builder::Builder","header::map::Link","header::name::Custom","header::map::Values","method::InvalidMethod","header::map::HashValue","uri::InvalidUriParts","header::map::Drain","header::map::VacantEntry","response::Response","header::map::Links","header::name::InvalidHeaderName","header::name::MaybeLower","header::name::Repr","error::Error"]},"header::map::ValueDrain":{"T":["header::map::Drain","header::map::Iter","header::map::IterMut","<*mut T as std::marker::Send>","header::map::ValueDrain","header::map::ValueIterMut"]},"header::map::ValueIter":{"T":["header::map::Link","uri::Parts","uri::InvalidUriParts","response::Response","header::map::Entry","uri::builder::Builder","uri::ErrorKind","uri::path::PathAndQuery","response::Parts","header::name::MaybeLower","uri::InvalidUri","<*mut T as std::fmt::Debug>","uri::Uri","status::StatusCode","header::map::Cursor","version::Version","header::name::Repr","header::map::RawLinks","uri::scheme::Protocol","header::map::Drain","header::map::ValuesMut","header::map::Values","header::map::OccupiedEntry","uri::authority::Authority","extensions::Extensions","header::map::HashValue","header::map::Bucket","method::InvalidMethod","header::value::ToStrError","header::map::Links","header::name::HeaderName","header::name::HdrName","header::map::Keys","request::Parts","uri::port::Port","header::map::GetAll","header::value::HeaderValue","header::map::IterMut","status::InvalidStatusCode","header::value::InvalidHeaderValue","header::name::InvalidHeaderName","header::map::VacantEntry","method::Method","byte_str::ByteStr","header::map::ExtraValue","header::name::Custom","header::map::ValueDrain","response::Builder","header::map::IntoIter","uri::scheme::Scheme","request::Builder","header::map::ValueIter","uri::scheme::Scheme2","header::map::Iter","error::Error","header::map::HeaderMap","request::Request","header::map::ValueIterMut","header::name::StandardHeader"]},"header::map::ValueIterMut":{"T":["header::map::IterMut","header::map::Iter","header::map::ValueIterMut","<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Drain"]},"header::map::Values":{"T":["header::map::Bucket","header::name::Repr","request::Builder","error::Error","uri::InvalidUri","uri::InvalidUriParts","header::name::HdrName","uri::scheme::Scheme","header::map::ValueIter","request::Request","method::InvalidMethod","header::map::Cursor","header::map::VacantEntry","header::map::HashValue","header::name::StandardHeader","header::name::Custom","header::name::MaybeLower","uri::scheme::Protocol","uri::Uri","header::map::HeaderMap","header::map::Drain","method::Method","request::Parts","uri::ErrorKind","header::name::HeaderName","header::map::Keys","<*mut T as std::fmt::Debug>","version::Version","header::map::ValueDrain","uri::builder::Builder","response::Builder","header::map::OccupiedEntry","header::map::Values","uri::port::Port","header::map::IntoIter","header::map::ValuesMut","header::map::GetAll","header::value::ToStrError","uri::scheme::Scheme2","header::map::ExtraValue","header::map::Link","status::InvalidStatusCode","header::map::IterMut","header::value::InvalidHeaderValue","header::map::Entry","header::map::RawLinks","status::StatusCode","uri::authority::Authority","header::value::HeaderValue","uri::Parts","header::map::Iter","header::name::InvalidHeaderName","uri::path::PathAndQuery","response::Parts","header::map::ValueIterMut","byte_str::ByteStr","header::map::Links","extensions::Extensions","response::Response"]},"header::map::ValuesMut":{"T":["method::Method","header::map::ExtraValue","header::map::Links","header::map::GetAll","uri::scheme::Scheme","header::map::HeaderMap","response::Builder","header::name::Repr","uri::scheme::Protocol","status::InvalidStatusCode","header::map::HashValue","header::map::ValueDrain","uri::Uri","uri::port::Port","header::map::Bucket","request::Request","uri::builder::Builder","header::name::StandardHeader","header::value::InvalidHeaderValue","header::name::Custom","header::name::HeaderName","response::Response","header::map::Drain","<*const T as std::fmt::Debug>","header::map::IntoIter","header::map::Keys","header::name::InvalidHeaderName","header::name::MaybeLower","method::InvalidMethod","header::map::Link","header::map::IterMut","header::value::ToStrError","request::Builder","uri::scheme::Scheme2","byte_str::ByteStr","header::map::VacantEntry","status::StatusCode","response::Parts","header::map::Iter","header::value::HeaderValue","request::Parts","header::map::ValuesMut","uri::path::PathAndQuery","header::map::RawLinks","header::map::Values","header::map::Entry","header::map::ValueIter","uri::InvalidUriParts","version::Version","extensions::Extensions","uri::ErrorKind","uri::InvalidUri","header::map::Cursor","error::Error","uri::authority::Authority","header::map::ValueIterMut","header::name::HdrName","header::map::OccupiedEntry","uri::Parts"]},"header::name::Repr":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","byte_str::ByteStr","header::name::StandardHeader","version::Version","header::name::Repr","header::name::Custom"]},"request::Request":{"T":["header::map::HeaderMap","request::Request","uri::Parts","method::Method","version::Version","uri::Uri","request::Builder","uri::builder::Builder","extensions::Extensions","status::StatusCode","response::Builder","response::Response"]},"response::Response":{"T":["uri::Parts","response::Response","method::Method","header::map::HeaderMap","uri::builder::Builder","status::StatusCode","version::Version","extensions::Extensions","request::Request","request::Builder","response::Builder","uri::Uri"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["header::value::HeaderValue","method::Method","uri::scheme::Scheme","<&T as std::fmt::Debug>","uri::port::Port","uri::authority::Authority"]},"uri::scheme::Scheme2":{"T":["header::name::Custom","header::map::ExtraValue","header::value::HeaderValue","uri::scheme::Protocol","uri::path::PathAndQuery","uri::scheme::Scheme2","header::name::StandardHeader","header::name::MaybeLower","uri::scheme::Scheme","header::map::HashValue","header::map::Links","uri::authority::Authority","status::StatusCode","header::map::Cursor","byte_str::ByteStr","std::boxed::Box<byte_str::ByteStr>","header::map::RawLinks","header::map::Bucket","method::Method","<*mut T as std::fmt::Debug>","header::map::Link","version::Version","header::name::HeaderName","header::name::Repr","header::map::HeaderMap","uri::Uri"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::ValueIter<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::ValueIter<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::ValueIter<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::ValueIter<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::ValueIterMut<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ValueIterMut<'a, T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::marker::Sync","std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::name::Repr":{"T":["std::marker::Sized","std::hash::Hash","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"request::Request":{"T":["std::marker::Sized","std::fmt::Debug","std::default::Default"]},"response::Response":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::fmt::Debug","std::convert::AsRef"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ValueIterMut<'a, T> as std::fmt::Debug>::fmt":{"T":["uri::path::PathAndQuery","uri::port::Port","header::map::Values","header::map::Links","header::map::ValuesMut","header::name::InvalidHeaderName","header::map::Keys","method::InvalidMethod","uri::scheme::Protocol","header::map::Link","header::map::ValueIterMut","header::map::IterMut","header::value::ToStrError","request::Parts","header::name::MaybeLower","method::Method","header::map::VacantEntry","header::map::OccupiedEntry","version::Version","uri::Parts","uri::ErrorKind","status::InvalidStatusCode","header::map::Drain","header::map::ExtraValue","response::Response","request::Builder","header::name::HdrName","header::map::HeaderMap","uri::InvalidUri","error::Error","header::map::GetAll","header::name::Repr","response::Builder","extensions::Extensions","header::map::RawLinks","uri::Uri","header::map::IntoIter","<&T as std::fmt::Debug>","header::map::ValueIter","header::name::StandardHeader","uri::scheme::Scheme","uri::builder::Builder","request::Request","byte_str::ByteStr","<*mut T as std::fmt::Debug>","header::map::Cursor","status::StatusCode","header::map::Bucket","header::name::HeaderName","header::value::HeaderValue","uri::authority::Authority","header::map::ValueDrain","uri::InvalidUriParts","header::map::Iter","header::name::Custom","uri::scheme::Scheme2","header::value::InvalidHeaderValue","header::map::HashValue","header::map::Entry","response::Parts"]},"header::map::Bucket":{"T":["std::clone::impls::<impl std::clone::Clone for &T>","header::map::Link","header::map::RawLinks","uri::scheme::Protocol","method::Method","header::value::HeaderValue","uri::path::PathAndQuery","header::map::HeaderMap","header::name::HeaderName","byte_str::ByteStr","header::map::Links","uri::Uri","uri::scheme::Scheme","header::map::ExtraValue","header::name::MaybeLower","status::StatusCode","uri::scheme::Scheme2","header::name::Repr","header::map::Cursor","header::map::Bucket","header::map::HashValue","version::Version","uri::authority::Authority","header::name::Custom","header::name::StandardHeader"]},"header::map::Drain":{"T":["header::map::ValueIterMut","header::map::Iter","header::map::ValueDrain","<*const T as std::marker::Sync>","header::map::Drain","header::map::IterMut"]},"header::map::Entry":{"T":["header::map::VacantEntry","header::map::Drain","header::map::Keys","header::name::Custom","byte_str::ByteStr","uri::port::Port","response::Builder","error::Error","header::value::ToStrError","header::map::GetAll","header::name::HdrName","header::name::MaybeLower","header::map::Cursor","status::InvalidStatusCode","uri::scheme::Scheme","response::Response","header::name::HeaderName","header::map::Bucket","header::map::OccupiedEntry","request::Builder","uri::scheme::Scheme2","uri::ErrorKind","header::map::Link","header::map::Links","request::Request","header::map::Entry","header::value::InvalidHeaderValue","status::StatusCode","header::map::ValueDrain","header::map::ValueIterMut","header::map::Values","method::InvalidMethod","header::map::IntoIter","uri::scheme::Protocol","response::Parts","header::value::HeaderValue","header::name::InvalidHeaderName","method::Method","version::Version","header::name::Repr","uri::authority::Authority","header::name::StandardHeader","uri::path::PathAndQuery","extensions::Extensions","uri::InvalidUriParts","header::map::ValuesMut","header::map::HeaderMap","header::map::Iter","uri::InvalidUri","uri::Uri","header::map::HashValue","uri::builder::Builder","header::map::RawLinks","uri::Parts","header::map::IterMut","header::map::ValueIter","request::Parts","<*mut T as std::fmt::Debug>","header::map::ExtraValue"]},"header::map::ExtraValue":{"T":["header::map::ExtraValue","header::map::HashValue","uri::authority::Authority","byte_str::ByteStr","header::map::RawLinks","header::map::Cursor","version::Version","header::value::HeaderValue","header::map::Bucket","status::StatusCode","uri::scheme::Protocol","header::name::StandardHeader","header::name::HeaderName","uri::scheme::Scheme","header::name::MaybeLower","<&T as std::fmt::Debug>","uri::path::PathAndQuery","header::map::Links","header::map::Link","header::map::HeaderMap","method::Method","header::name::Repr","uri::Uri","uri::scheme::Scheme2","header::name::Custom"]},"header::map::GetAll":{"T":["header::name::StandardHeader","header::name::Repr","<*const T as std::fmt::Debug>","header::map::HashValue","header::map::Cursor","header::name::Custom","header::map::Link","version::Version","header::map::GetAll","header::map::HeaderMap","byte_str::ByteStr","uri::ErrorKind"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["uri::path::PathAndQuery","response::Builder","header::map::ValueDrain","header::name::HeaderName","header::map::HashValue","header::map::VacantEntry","status::InvalidStatusCode","header::map::ValueIterMut","header::map::Iter","uri::Uri","<*const T as std::fmt::Debug>","header::map::ValuesMut","status::StatusCode","request::Parts","header::map::Drain","method::Method","uri::port::Port","request::Builder","header::map::IterMut","header::name::Repr","header::map::RawLinks","method::InvalidMethod","header::map::IntoIter","header::value::InvalidHeaderValue","header::name::MaybeLower","header::map::Bucket","header::name::InvalidHeaderName","byte_str::ByteStr","header::map::Cursor","uri::scheme::Protocol","header::map::GetAll","header::map::Entry","header::map::ValueIter","request::Request","header::map::Link","version::Version","error::Error","header::map::Values","uri::authority::Authority","response::Response","uri::builder::Builder","header::name::StandardHeader","uri::ErrorKind","header::map::ExtraValue","header::map::Keys","extensions::Extensions","header::map::HeaderMap","header::value::HeaderValue","header::name::HdrName","uri::InvalidUriParts","uri::scheme::Scheme2","uri::Parts","header::value::ToStrError","header::map::Links","uri::scheme::Scheme","uri::InvalidUri","header::name::Custom","response::Parts","header::map::OccupiedEntry"]},"header::map::Iter":{"T":["<*mut T as std::fmt::Debug>","header::map::Drain","header::map::Iter","header::map::ValueIterMut","header::map::IterMut","header::map::ValueDrain"]},"header::map::IterMut":{"T":["header::map::Iter","header::map::ValueIterMut","header::map::ValueDrain","header::map::Drain","header::map::IterMut","<*const T as std::fmt::Debug>"]},"header::map::Keys":{"T":["uri::Uri","uri::InvalidUri","response::Builder","request::Builder","header::name::HeaderName","header::map::Cursor","<&T as std::fmt::Debug>","header::map::Links","uri::scheme::Protocol","header::name::MaybeLower","header::map::RawLinks","uri::scheme::Scheme2","uri::builder::Builder","response::Response","error::Error","header::map::HeaderMap","header::map::ExtraValue","response::Parts","uri::port::Port","header::map::ValuesMut","uri::path::PathAndQuery","uri::authority::Authority","header::map::IntoIter","header::map::ValueDrain","header::name::Custom","header::map::Values","uri::Parts","method::Method","header::map::ValueIterMut","header::map::Iter","header::map::OccupiedEntry","header::map::Entry","header::name::HdrName","header::map::HashValue","header::value::HeaderValue","status::StatusCode","header::map::Drain","header::map::Keys","header::map::IterMut","header::map::VacantEntry","request::Request","status::InvalidStatusCode","header::map::GetAll","method::InvalidMethod","version::Version","header::name::Repr","header::value::InvalidHeaderValue","header::name::StandardHeader","byte_str::ByteStr","request::Parts","uri::InvalidUriParts","header::map::Link","header::name::InvalidHeaderName","extensions::Extensions","header::map::ValueIter","header::value::ToStrError","uri::scheme::Scheme","header::map::Bucket","uri::ErrorKind"]},"header::map::OccupiedEntry":{"T":["header::map::Links","uri::scheme::Protocol","method::InvalidMethod","header::map::VacantEntry","byte_str::ByteStr","status::StatusCode","uri::InvalidUri","header::map::Cursor","header::value::HeaderValue","header::map::HeaderMap","uri::Parts","header::value::InvalidHeaderValue","extensions::Extensions","header::map::Keys","header::map::GetAll","uri::port::Port","header::name::StandardHeader","uri::builder::Builder","request::Request","response::Response","header::name::InvalidHeaderName","uri::path::PathAndQuery","header::map::Values","header::name::HdrName","header::map::ValueIter","header::map::Drain","header::map::ValueDrain","response::Parts","header::map::Link","header::map::ExtraValue","request::Builder","<*const T as std::fmt::Debug>","method::Method","uri::scheme::Scheme2","header::map::Entry","header::map::RawLinks","header::map::ValuesMut","header::name::HeaderName","uri::InvalidUriParts","header::map::OccupiedEntry","uri::Uri","error::Error","header::name::Custom","request::Parts","uri::scheme::Scheme","version::Version","status::InvalidStatusCode","header::name::Repr","header::name::MaybeLower","header::map::Iter","header::map::Bucket","header::map::IntoIter","uri::authority::Authority","uri::ErrorKind","header::value::ToStrError","header::map::HashValue","response::Builder","header::map::IterMut","header::map::ValueIterMut"]},"header::map::RawLinks":{"T":["header::map::GetAll","status::StatusCode","uri::path::PathAndQuery","uri::scheme::Scheme","header::name::HeaderName","uri::InvalidUri","uri::scheme::Protocol","header::map::Cursor","header::map::RawLinks","header::map::ValuesMut","uri::InvalidUriParts","header::map::HashValue","header::name::MaybeLower","method::InvalidMethod","response::Parts","uri::Parts","header::map::Bucket","status::InvalidStatusCode","response::Response","header::map::IterMut","uri::ErrorKind","method::Method","uri::authority::Authority","header::value::InvalidHeaderValue","header::map::Entry","byte_str::ByteStr","header::name::HdrName","<*mut T as std::fmt::Debug>","header::map::Links","version::Version","uri::scheme::Scheme2","header::map::ExtraValue","error::Error","header::map::ValueIterMut","header::map::Drain","header::map::ValueIter","header::value::ToStrError","header::name::StandardHeader","header::map::Keys","header::map::Link","uri::builder::Builder","uri::port::Port","header::name::Repr","header::map::Values","request::Builder","header::name::Custom","header::map::OccupiedEntry","header::map::Iter","uri::Uri","header::map::ValueDrain","header::map::VacantEntry","header::name::InvalidHeaderName","response::Builder","request::Request","header::map::HeaderMap","request::Parts","header::map::IntoIter","header::value::HeaderValue","extensions::Extensions"]},"header::map::VacantEntry":{"T":["response::Parts","version::Version","request::Request","header::name::Repr","error::Error","header::map::Link","header::map::ValueDrain","uri::scheme::Scheme","uri::Parts","header::map::GetAll","uri::builder::Builder","method::Method","header::map::ValueIter","header::map::Iter","header::value::InvalidHeaderValue","response::Response","header::map::ExtraValue","header::map::Bucket","uri::InvalidUriParts","byte_str::ByteStr","header::name::HdrName","header::map::HeaderMap","header::map::ValuesMut","header::name::InvalidHeaderName","header::map::ValueIterMut","request::Parts","header::map::RawLinks","<&T as std::fmt::Debug>","uri::Uri","uri::scheme::Protocol","header::map::Values","request::Builder","uri::scheme::Scheme2","status::InvalidStatusCode","header::map::IntoIter","uri::port::Port","status::StatusCode","header::name::Custom","extensions::Extensions","header::name::MaybeLower","uri::authority::Authority","header::map::HashValue","response::Builder","header::map::Drain","header::map::OccupiedEntry","header::map::Links","header::map::IterMut","header::value::HeaderValue","uri::ErrorKind","header::map::Cursor","header::name::StandardHeader","header::map::Keys","header::value::ToStrError","uri::InvalidUri","uri::path::PathAndQuery","method::InvalidMethod","header::map::VacantEntry","header::name::HeaderName","header::map::Entry"]},"header::map::ValueDrain":{"T":["header::map::ValueDrain","<*const T as std::fmt::Debug>","header::map::Iter","header::map::ValueIterMut","header::map::IterMut","header::map::Drain"]},"header::map::ValueIter":{"T":["<*mut T as std::fmt::Debug>","uri::port::Port","header::map::HeaderMap","header::map::Keys","response::Builder","uri::ErrorKind","header::map::Drain","header::name::HeaderName","header::map::ValueIter","header::value::HeaderValue","header::value::ToStrError","uri::InvalidUri","uri::InvalidUriParts","header::map::IntoIter","request::Builder","header::map::Values","status::StatusCode","header::map::Links","uri::scheme::Scheme","header::map::HashValue","request::Parts","header::map::ExtraValue","header::map::Link","header::value::InvalidHeaderValue","header::name::StandardHeader","uri::scheme::Protocol","uri::Parts","response::Parts","header::map::RawLinks","response::Response","header::map::IterMut","header::name::Custom","uri::builder::Builder","uri::scheme::Scheme2","header::name::HdrName","error::Error","uri::authority::Authority","header::map::Bucket","header::map::Entry","uri::path::PathAndQuery","version::Version","method::Method","header::map::GetAll","byte_str::ByteStr","request::Request","header::map::Cursor","extensions::Extensions","header::map::Iter","header::map::ValueDrain","method::InvalidMethod","status::InvalidStatusCode","header::name::Repr","header::name::MaybeLower","header::name::InvalidHeaderName","header::map::OccupiedEntry","header::map::ValueIterMut","uri::Uri","header::map::VacantEntry","header::map::ValuesMut"]},"header::map::ValueIterMut":{"T":["header::map::Drain","header::map::Iter","header::map::ValueDrain","header::map::IterMut","header::map::ValueIterMut","<*mut T as std::fmt::Debug>"]},"header::map::Values":{"T":["header::map::Iter","method::InvalidMethod","uri::scheme::Protocol","header::map::ExtraValue","header::map::HashValue","uri::path::PathAndQuery","request::Parts","uri::Uri","request::Request","header::map::VacantEntry","uri::port::Port","header::value::ToStrError","header::map::IntoIter","header::map::Link","uri::scheme::Scheme2","uri::InvalidUriParts","header::value::InvalidHeaderValue","response::Parts","header::value::HeaderValue","status::InvalidStatusCode","header::map::Cursor","request::Builder","uri::ErrorKind","header::map::Entry","header::map::Values","header::name::InvalidHeaderName","header::name::MaybeLower","header::map::Links","header::map::ValueDrain","header::map::GetAll","uri::scheme::Scheme","uri::authority::Authority","response::Response","header::map::Drain","uri::Parts","header::map::Bucket","status::StatusCode","header::name::HdrName","header::map::ValuesMut","uri::InvalidUri","header::name::Custom","header::map::ValueIterMut","response::Builder","header::map::RawLinks","header::name::HeaderName","extensions::Extensions","header::name::StandardHeader","header::map::ValueIter","header::map::OccupiedEntry","byte_str::ByteStr","error::Error","<&T as std::fmt::Debug>","method::Method","version::Version","header::map::Keys","header::map::IterMut","header::name::Repr","header::map::HeaderMap","uri::builder::Builder"]},"header::map::ValuesMut":{"T":["request::Parts","header::map::Cursor","header::map::Values","byte_str::ByteStr","header::name::HeaderName","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::ExtraValue","header::map::ValueIter","header::map::ValuesMut","header::name::Custom","header::name::InvalidHeaderName","uri::scheme::Protocol","header::name::HdrName","<&mut T as std::fmt::Debug>","uri::port::Port","header::map::ValueDrain","header::name::Repr","uri::authority::Authority","extensions::Extensions","header::map::Link","header::name::StandardHeader","header::name::MaybeLower","status::StatusCode","response::Builder","header::map::Iter","header::map::VacantEntry","header::map::HeaderMap","response::Response","header::map::RawLinks","method::Method","uri::path::PathAndQuery","header::map::GetAll","uri::ErrorKind","uri::Parts","status::InvalidStatusCode","header::value::InvalidHeaderValue","uri::Uri","response::Parts","header::map::Bucket","header::map::Links","uri::InvalidUriParts","uri::InvalidUri","header::value::ToStrError","header::map::ValueIterMut","request::Request","uri::builder::Builder","header::map::HashValue","request::Builder","header::map::OccupiedEntry","header::map::Entry","header::value::HeaderValue","header::map::Drain","method::InvalidMethod","version::Version","header::map::IterMut","error::Error","header::map::IntoIter","header::map::Keys"]},"header::name::Repr":{"T":["header::name::Custom","version::Version","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","byte_str::ByteStr","header::name::Repr","header::name::StandardHeader"]},"request::Request":{"T":["status::StatusCode","response::Builder","uri::builder::Builder","request::Builder","response::Response","method::Method","uri::Parts","header::map::HeaderMap","uri::Uri","version::Version","extensions::Extensions","request::Request"]},"response::Response":{"T":["uri::Uri","extensions::Extensions","request::Builder","method::Method","request::Request","status::StatusCode","uri::builder::Builder","version::Version","response::Response","response::Builder","uri::Parts","header::map::HeaderMap"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["method::Method","<&T as std::convert::AsRef<U>>","uri::scheme::Scheme","header::value::HeaderValue","uri::authority::Authority","uri::port::Port"]},"uri::scheme::Scheme2":{"T":["header::map::Bucket","header::map::Cursor","header::map::HashValue","byte_str::ByteStr","uri::scheme::Protocol","version::Version","uri::scheme::Scheme","method::Method","uri::scheme::Scheme2","header::name::HeaderName","header::map::Link","header::map::HeaderMap","uri::authority::Authority","header::map::ExtraValue","header::map::Links","uri::Uri","uri::path::PathAndQuery","header::name::Repr","header::name::StandardHeader","std::boxed::Box<byte_str::ByteStr>","header::value::HeaderValue","header::name::Custom","<&T as std::fmt::Debug>","header::map::RawLinks","header::name::MaybeLower","status::StatusCode"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::ValueIterMut<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::ValueIterMut<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::ValueIterMut<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::ValueIterMut<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::ValueDrain<'a, T> as std::fmt::Debug>::fmt
'a
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ValueDrain<'a, T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Bucket":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::convert::TryFrom","std::cmp::Eq","std::cmp::PartialEq"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Send","std::marker::Sync"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::marker::Sync","std::marker::Send","std::marker::Sized","std::fmt::Debug"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::hash::Hash","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"request::Request":{"T":["std::default::Default","std::fmt::Debug","std::marker::Sized"]},"response::Response":{"T":["std::default::Default","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::convert::AsRef","std::fmt::Debug","std::marker::Sized"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ValueDrain<'a, T> as std::fmt::Debug>::fmt":{"T":["header::map::OccupiedEntry","header::map::Entry","response::Response","header::map::RawLinks","header::map::Values","uri::path::PathAndQuery","header::map::Links","header::map::Bucket","response::Builder","status::StatusCode","header::map::ValuesMut","header::map::Drain","header::map::ValueDrain","<*mut T as std::fmt::Debug>","header::value::InvalidHeaderValue","header::name::MaybeLower","status::InvalidStatusCode","uri::scheme::Scheme","uri::authority::Authority","uri::Uri","header::map::Keys","header::map::Cursor","header::value::ToStrError","header::map::Link","header::name::InvalidHeaderName","header::map::HashValue","uri::ErrorKind","request::Builder","uri::scheme::Protocol","uri::Parts","header::map::ValueIterMut","header::map::ExtraValue","uri::InvalidUri","extensions::Extensions","byte_str::ByteStr","method::InvalidMethod","header::name::HeaderName","header::name::Repr","uri::scheme::Scheme2","request::Request","header::name::HdrName","error::Error","uri::port::Port","uri::InvalidUriParts","method::Method","uri::builder::Builder","header::map::HeaderMap","header::name::StandardHeader","header::map::VacantEntry","header::map::IterMut","request::Parts","version::Version","header::map::IntoIter","response::Parts","header::map::GetAll","header::value::HeaderValue","header::map::ValueIter","header::name::Custom","header::map::Iter"]},"header::map::Bucket":{"T":["header::map::Link","byte_str::ByteStr","uri::path::PathAndQuery","header::name::MaybeLower","header::name::Repr","header::name::StandardHeader","std::clone::impls::<impl std::clone::Clone for &T>","uri::authority::Authority","header::map::Links","header::map::Cursor","uri::scheme::Protocol","header::map::RawLinks","header::map::HeaderMap","method::Method","uri::Uri","status::StatusCode","uri::scheme::Scheme2","header::name::HeaderName","header::map::Bucket","header::name::Custom","version::Version","header::map::HashValue","header::value::HeaderValue","uri::scheme::Scheme","header::map::ExtraValue"]},"header::map::Drain":{"T":["header::map::Iter","header::map::ValueIterMut","header::map::IterMut","header::map::Drain","<*const T as std::marker::Sync>","header::map::ValueDrain"]},"header::map::Entry":{"T":["header::name::HdrName","header::name::HeaderName","header::map::ValueDrain","header::map::ValuesMut","method::InvalidMethod","uri::builder::Builder","header::map::OccupiedEntry","header::map::VacantEntry","status::StatusCode","header::map::IterMut","header::map::ExtraValue","uri::port::Port","response::Builder","uri::scheme::Scheme","status::InvalidStatusCode","uri::scheme::Scheme2","uri::Parts","header::map::RawLinks","header::map::Keys","header::map::ValueIter","uri::authority::Authority","header::map::Link","request::Builder","error::Error","header::map::Cursor","method::Method","header::map::Links","header::map::Values","version::Version","response::Response","header::name::Repr","response::Parts","request::Parts","header::name::MaybeLower","header::map::ValueIterMut","extensions::Extensions","uri::ErrorKind","header::map::Entry","uri::InvalidUri","uri::scheme::Protocol","header::map::HashValue","header::name::Custom","header::map::IntoIter","byte_str::ByteStr","uri::Uri","header::map::HeaderMap","request::Request","uri::InvalidUriParts","header::map::Drain","uri::path::PathAndQuery","header::map::Bucket","header::map::GetAll","header::value::InvalidHeaderValue","<&T as std::fmt::Debug>","header::name::InvalidHeaderName","header::value::HeaderValue","header::value::ToStrError","header::map::Iter","header::name::StandardHeader"]},"header::map::ExtraValue":{"T":["header::map::RawLinks","header::name::HeaderName","std::clone::impls::<impl std::clone::Clone for *mut T>","byte_str::ByteStr","header::map::ExtraValue","header::map::HeaderMap","uri::scheme::Scheme","version::Version","header::map::Cursor","method::Method","header::value::HeaderValue","status::StatusCode","uri::Uri","header::name::MaybeLower","uri::scheme::Protocol","uri::path::PathAndQuery","header::name::StandardHeader","uri::scheme::Scheme2","header::name::Custom","header::name::Repr","header::map::Bucket","uri::authority::Authority","header::map::Link","header::map::Links","header::map::HashValue"]},"header::map::GetAll":{"T":["header::map::Cursor","header::map::Link","header::map::HeaderMap","header::name::Custom","uri::ErrorKind","header::name::Repr","byte_str::ByteStr","version::Version","header::map::GetAll","header::map::HashValue","std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>","header::name::StandardHeader"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["response::Response","header::map::Iter","header::name::StandardHeader","header::value::HeaderValue","header::name::HeaderName","response::Parts","header::name::Repr","uri::path::PathAndQuery","status::StatusCode","method::InvalidMethod","uri::scheme::Protocol","header::map::Cursor","header::map::Bucket","uri::Uri","header::map::IterMut","header::name::HdrName","byte_str::ByteStr","header::map::OccupiedEntry","status::InvalidStatusCode","uri::scheme::Scheme2","response::Builder","uri::ErrorKind","header::map::Entry","header::map::ValueIterMut","header::map::ValueDrain","uri::port::Port","header::value::InvalidHeaderValue","request::Parts","header::map::HashValue","header::map::HeaderMap","header::name::Custom","error::Error","header::map::Links","uri::authority::Authority","header::map::Link","extensions::Extensions","header::map::ExtraValue","header::value::ToStrError","header::name::InvalidHeaderName","header::name::MaybeLower","uri::builder::Builder","header::map::ValueIter","method::Method","uri::Parts","header::map::GetAll","<&mut T as std::fmt::Debug>","header::map::RawLinks","header::map::Values","uri::scheme::Scheme","uri::InvalidUriParts","request::Request","header::map::IntoIter","header::map::VacantEntry","uri::InvalidUri","header::map::ValuesMut","header::map::Drain","version::Version","header::map::Keys","request::Builder"]},"header::map::Iter":{"T":["header::map::Drain","header::map::Iter","<*const T as std::fmt::Debug>","header::map::IterMut","header::map::ValueDrain","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["header::map::Iter","header::map::ValueDrain","header::map::IterMut","header::map::ValueIterMut","<*const T as std::marker::Send>","header::map::Drain"]},"header::map::Keys":{"T":["header::value::InvalidHeaderValue","header::map::OccupiedEntry","method::InvalidMethod","request::Builder","header::map::IntoIter","header::map::Links","header::name::HeaderName","uri::InvalidUri","uri::port::Port","uri::InvalidUriParts","header::name::Repr","header::map::HeaderMap","uri::builder::Builder","uri::scheme::Scheme","status::StatusCode","header::map::ValuesMut","request::Parts","header::map::Entry","method::Method","header::name::InvalidHeaderName","status::InvalidStatusCode","header::map::GetAll","header::map::ExtraValue","header::map::VacantEntry","header::map::RawLinks","header::map::Values","uri::path::PathAndQuery","error::Error","uri::scheme::Protocol","version::Version","header::name::Custom","header::value::ToStrError","uri::scheme::Scheme2","extensions::Extensions","header::map::Keys","uri::Parts","header::map::Cursor","header::map::IterMut","request::Request","response::Response","response::Parts","uri::ErrorKind","header::name::MaybeLower","byte_str::ByteStr","<&T as std::fmt::Debug>","response::Builder","header::map::ValueIter","header::map::Drain","header::name::StandardHeader","header::name::HdrName","uri::authority::Authority","uri::Uri","header::map::Link","header::map::ValueIterMut","header::map::Iter","header::map::HashValue","header::map::ValueDrain","header::map::Bucket","header::value::HeaderValue"]},"header::map::OccupiedEntry":{"T":["version::Version","header::map::ExtraValue","response::Parts","request::Parts","response::Response","header::name::MaybeLower","header::map::IntoIter","method::Method","uri::scheme::Scheme2","uri::scheme::Scheme","method::InvalidMethod","<&T as std::fmt::Debug>","header::map::HashValue","uri::ErrorKind","header::map::HeaderMap","header::map::GetAll","header::map::ValueDrain","uri::builder::Builder","header::map::OccupiedEntry","byte_str::ByteStr","header::map::Values","status::InvalidStatusCode","uri::authority::Authority","uri::scheme::Protocol","header::name::Repr","header::map::ValuesMut","uri::port::Port","header::map::Iter","header::map::ValueIterMut","header::map::ValueIter","uri::InvalidUriParts","status::StatusCode","request::Request","request::Builder","header::map::Drain","header::map::Link","error::Error","header::value::InvalidHeaderValue","uri::path::PathAndQuery","header::map::VacantEntry","uri::Uri","header::map::Keys","header::name::HdrName","uri::Parts","extensions::Extensions","header::map::Bucket","header::name::Custom","header::map::IterMut","header::value::ToStrError","header::name::HeaderName","header::map::Cursor","header::map::Links","header::value::HeaderValue","header::map::Entry","header::map::RawLinks","response::Builder","header::name::StandardHeader","uri::InvalidUri","header::name::InvalidHeaderName"]},"header::map::RawLinks":{"T":["header::map::OccupiedEntry","response::Parts","header::map::Entry","header::map::ExtraValue","header::map::HashValue","header::name::HdrName","method::Method","header::value::HeaderValue","uri::port::Port","uri::scheme::Scheme","header::map::Iter","header::map::IntoIter","uri::InvalidUri","uri::Uri","header::map::IterMut","uri::builder::Builder","header::map::Cursor","header::map::ValuesMut","header::map::Bucket","header::map::ValueIter","header::name::MaybeLower","method::InvalidMethod","status::InvalidStatusCode","uri::InvalidUriParts","header::map::ValueIterMut","uri::path::PathAndQuery","uri::scheme::Protocol","response::Response","request::Builder","header::value::ToStrError","extensions::Extensions","response::Builder","uri::ErrorKind","header::map::GetAll","header::map::Links","uri::authority::Authority","status::StatusCode","error::Error","header::name::InvalidHeaderName","header::map::HeaderMap","header::value::InvalidHeaderValue","header::name::HeaderName","header::name::Repr","header::map::ValueDrain","header::map::Link","uri::scheme::Scheme2","request::Request","header::name::Custom","<*const T as std::fmt::Debug>","header::map::Values","header::map::VacantEntry","header::map::RawLinks","header::map::Keys","uri::Parts","header::map::Drain","request::Parts","header::name::StandardHeader","version::Version","byte_str::ByteStr"]},"header::map::VacantEntry":{"T":["extensions::Extensions","header::name::InvalidHeaderName","header::name::StandardHeader","header::value::HeaderValue","uri::InvalidUri","header::name::HdrName","uri::ErrorKind","header::map::IterMut","response::Response","uri::builder::Builder","header::map::IntoIter","request::Builder","header::map::ValueIterMut","header::map::Link","header::map::HashValue","request::Parts","header::name::Repr","header::map::Keys","header::map::ValuesMut","header::value::ToStrError","byte_str::ByteStr","header::map::Bucket","uri::Parts","header::map::OccupiedEntry","method::Method","header::map::ValueIter","<*const T as std::fmt::Debug>","header::map::RawLinks","uri::authority::Authority","header::map::VacantEntry","error::Error","uri::scheme::Scheme","method::InvalidMethod","response::Builder","header::map::GetAll","uri::InvalidUriParts","response::Parts","header::name::Custom","header::name::MaybeLower","header::map::Cursor","header::map::ExtraValue","uri::scheme::Protocol","uri::Uri","header::name::HeaderName","header::value::InvalidHeaderValue","header::map::Entry","header::map::Values","status::InvalidStatusCode","header::map::ValueDrain","uri::scheme::Scheme2","header::map::Iter","version::Version","status::StatusCode","header::map::HeaderMap","header::map::Drain","uri::path::PathAndQuery","request::Request","header::map::Links","uri::port::Port"]},"header::map::ValueDrain":{"T":["header::map::Drain","<*const T as std::fmt::Debug>","header::map::ValueDrain","header::map::Iter","header::map::ValueIterMut","header::map::IterMut"]},"header::map::ValueIter":{"T":["request::Builder","header::map::IntoIter","header::map::HashValue","header::name::InvalidHeaderName","header::map::ValueIterMut","uri::scheme::Scheme","header::map::Drain","header::name::MaybeLower","header::name::Repr","method::InvalidMethod","uri::Uri","header::map::Link","header::map::ValuesMut","header::map::HeaderMap","header::map::Values","header::name::StandardHeader","method::Method","header::name::HdrName","extensions::Extensions","uri::scheme::Scheme2","header::map::OccupiedEntry","header::map::Links","header::name::HeaderName","uri::port::Port","request::Request","uri::InvalidUriParts","byte_str::ByteStr","request::Parts","response::Parts","header::map::VacantEntry","uri::InvalidUri","header::value::InvalidHeaderValue","header::map::ValueIter","uri::builder::Builder","header::map::ExtraValue","header::map::Bucket","status::StatusCode","uri::ErrorKind","response::Response","<&T as std::fmt::Debug>","uri::Parts","uri::scheme::Protocol","error::Error","header::map::Entry","header::value::ToStrError","status::InvalidStatusCode","header::map::Cursor","version::Version","header::value::HeaderValue","header::map::IterMut","header::map::Iter","response::Builder","header::map::RawLinks","header::name::Custom","header::map::GetAll","header::map::ValueDrain","uri::path::PathAndQuery","uri::authority::Authority","header::map::Keys"]},"header::map::ValueIterMut":{"T":["<*mut T as std::fmt::Debug>","header::map::Drain","header::map::IterMut","header::map::ValueIterMut","header::map::ValueDrain","header::map::Iter"]},"header::map::Values":{"T":["version::Version","header::map::HashValue","method::InvalidMethod","response::Response","header::name::Repr","header::map::RawLinks","header::map::ValueIter","uri::ErrorKind","header::map::Cursor","header::name::Custom","header::value::InvalidHeaderValue","uri::builder::Builder","header::name::StandardHeader","header::map::ValuesMut","header::map::GetAll","status::InvalidStatusCode","header::map::OccupiedEntry","header::map::ValueDrain","method::Method","uri::path::PathAndQuery","uri::scheme::Scheme2","uri::port::Port","<*mut T as std::fmt::Debug>","header::map::IntoIter","header::map::HeaderMap","request::Request","uri::InvalidUriParts","header::map::Drain","header::name::InvalidHeaderName","uri::InvalidUri","header::name::HeaderName","byte_str::ByteStr","uri::scheme::Protocol","header::name::HdrName","uri::Parts","header::value::ToStrError","header::map::IterMut","request::Builder","header::value::HeaderValue","extensions::Extensions","uri::authority::Authority","header::map::Links","request::Parts","response::Builder","response::Parts","status::StatusCode","error::Error","uri::Uri","header::map::Entry","header::map::Link","header::map::Values","header::map::VacantEntry","header::map::ExtraValue","header::map::ValueIterMut","header::map::Bucket","header::map::Iter","uri::scheme::Scheme","header::name::MaybeLower","header::map::Keys"]},"header::map::ValuesMut":{"T":["header::map::Iter","status::InvalidStatusCode","extensions::Extensions","header::map::ValueIterMut","header::value::ToStrError","uri::port::Port","header::value::InvalidHeaderValue","byte_str::ByteStr","header::map::ValueIter","header::map::HashValue","header::map::ValueDrain","request::Request","header::map::Keys","response::Response","version::Version","header::map::Link","<*mut T as std::fmt::Debug>","request::Parts","uri::scheme::Scheme2","header::map::RawLinks","uri::path::PathAndQuery","error::Error","uri::ErrorKind","header::map::Bucket","uri::Uri","header::map::Drain","method::Method","header::value::HeaderValue","header::map::IterMut","header::map::HeaderMap","header::name::MaybeLower","header::map::Cursor","header::map::GetAll","header::map::OccupiedEntry","header::name::StandardHeader","response::Builder","uri::scheme::Protocol","header::name::HdrName","uri::Parts","header::map::Links","header::map::VacantEntry","header::name::InvalidHeaderName","uri::scheme::Scheme","header::map::IntoIter","header::map::Entry","request::Builder","response::Parts","uri::authority::Authority","header::map::Values","header::name::Custom","header::map::ValuesMut","uri::builder::Builder","uri::InvalidUriParts","header::map::ExtraValue","header::name::Repr","method::InvalidMethod","status::StatusCode","header::name::HeaderName","uri::InvalidUri"]},"header::name::Repr":{"T":["header::name::Repr","version::Version","byte_str::ByteStr","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::name::Custom","header::name::StandardHeader"]},"request::Request":{"T":["extensions::Extensions","response::Response","uri::Uri","response::Builder","uri::builder::Builder","method::Method","status::StatusCode","request::Builder","uri::Parts","header::map::HeaderMap","version::Version","request::Request"]},"response::Response":{"T":["status::StatusCode","response::Response","response::Builder","request::Request","version::Version","uri::Uri","method::Method","uri::builder::Builder","uri::Parts","request::Builder","extensions::Extensions","header::map::HeaderMap"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["uri::authority::Authority","method::Method","<&T as std::convert::AsRef<U>>","header::value::HeaderValue","uri::port::Port","uri::scheme::Scheme"]},"uri::scheme::Scheme2":{"T":["header::map::HeaderMap","header::map::Links","uri::path::PathAndQuery","std::boxed::Box<byte_str::ByteStr>","header::name::StandardHeader","header::value::HeaderValue","header::map::RawLinks","method::Method","header::map::Bucket","header::name::MaybeLower","version::Version","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::ExtraValue","header::map::Cursor","status::StatusCode","header::map::Link","header::name::HeaderName","header::map::HashValue","uri::authority::Authority","std::clone::impls::<impl std::clone::Clone for *const T>","uri::Uri","uri::scheme::Protocol","header::name::Custom","byte_str::ByteStr","header::name::Repr"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::ValueDrain<'a, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::ValueDrain<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::ValueDrain<'a, T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::ValueDrain<'a, T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::Cursor as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Cursor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::Cursor as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::Cursor as std::fmt::Debug>::fmt(p0, p1);
+<header::map::Cursor>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::Cursor as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Cursor
+p0.clone();
+<header::map::Cursor as std::clone::Clone>::clone(p0);
+crate::<header::map::Cursor as std::clone::Clone>::clone(p0);
+<header::map::Cursor>::clone(p0);
-----------------
src/header/map.rs <header::map::Cursor as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Cursor
+p0.assert_receiver_is_total_eq();
+<header::map::Cursor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<header::map::Cursor as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<header::map::Cursor>::assert_receiver_is_total_eq(p0);
-----------------
src/header/map.rs <header::map::Cursor as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Cursor
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::Cursor
+p0.eq(p1);
+<header::map::Cursor as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::map::Cursor as std::cmp::PartialEq>::eq(p0, p1);
+<header::map::Cursor>::eq(p0, p1);
-----------------
src/header/map.rs <header::map::Pos as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Pos
+p0.clone();
+<header::map::Pos as std::clone::Clone>::clone(p0);
+crate::<header::map::Pos as std::clone::Clone>::clone(p0);
+<header::map::Pos>::clone(p0);
-----------------
src/header/map.rs <header::map::HashValue as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HashValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::HashValue as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::HashValue as std::fmt::Debug>::fmt(p0, p1);
+<header::map::HashValue>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::HashValue as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HashValue
+p0.clone();
+<header::map::HashValue as std::clone::Clone>::clone(p0);
+crate::<header::map::HashValue as std::clone::Clone>::clone(p0);
+<header::map::HashValue>::clone(p0);
-----------------
src/header/map.rs <header::map::HashValue as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HashValue
+p0.assert_receiver_is_total_eq();
+<header::map::HashValue as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<header::map::HashValue as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<header::map::HashValue>::assert_receiver_is_total_eq(p0);
-----------------
src/header/map.rs <header::map::HashValue as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HashValue
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::HashValue
+p0.eq(p1);
+<header::map::HashValue as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::map::HashValue as std::cmp::PartialEq>::eq(p0, p1);
+<header::map::HashValue>::eq(p0, p1);
-----------------
src/header/map.rs <header::map::Bucket<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Bucket<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sync","std::marker::Sized"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::fmt::Debug","std::convert::TryFrom","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized"]},"header::map::IterMut":{"T":["std::marker::Sync","std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::hash::Hash","std::fmt::Debug","std::marker::Sized"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::fmt::Debug","std::convert::AsRef"]},"uri::scheme::Scheme2":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Bucket<T> as std::fmt::Debug>::fmt":{"T":["response::Builder","header::map::Iter","header::value::ToStrError","request::Parts","header::value::InvalidHeaderValue","request::Request","status::StatusCode","request::Builder","header::map::Keys","extensions::Extensions","header::map::ValueIterMut","header::map::ValueIter","header::name::Repr","uri::port::Port","status::InvalidStatusCode","header::map::Bucket","header::map::RawLinks","header::map::GetAll","header::name::StandardHeader","uri::scheme::Protocol","header::map::IterMut","header::map::IntoIter","uri::Parts","uri::ErrorKind","method::Method","header::map::ValueDrain","<&T as std::fmt::Debug>","header::map::Drain","header::name::Custom","uri::Uri","error::Error","header::name::MaybeLower","header::map::Link","uri::scheme::Scheme","uri::authority::Authority","header::value::HeaderValue","uri::path::PathAndQuery","version::Version","method::InvalidMethod","uri::builder::Builder","header::name::HeaderName","header::map::HeaderMap","header::map::Entry","uri::InvalidUri","header::name::InvalidHeaderName","response::Response","uri::InvalidUriParts","uri::scheme::Scheme2","header::map::ExtraValue","header::map::OccupiedEntry","header::map::Values","header::map::HashValue","response::Parts","header::map::ValuesMut","header::map::Links","header::name::HdrName","<&mut T as std::fmt::Debug>","byte_str::ByteStr","header::map::Cursor","header::map::VacantEntry"]},"header::map::Bucket":{"T":["header::map::Links","header::value::HeaderValue","std::clone::impls::<impl std::clone::Clone for &T>","header::name::HeaderName","header::map::RawLinks","method::Method","header::name::MaybeLower","version::Version","header::name::Repr","uri::scheme::Scheme2","header::map::HeaderMap","header::name::StandardHeader","uri::Uri","header::map::ExtraValue","header::map::Cursor","header::map::Link","header::map::HashValue","byte_str::ByteStr","header::map::Bucket","uri::scheme::Scheme","uri::scheme::Protocol","uri::authority::Authority","uri::path::PathAndQuery","status::StatusCode","header::name::Custom"]},"header::map::Drain":{"T":["<*const T as std::fmt::Debug>","header::map::ValueIterMut","header::map::Iter","header::map::Drain","header::map::ValueDrain","header::map::IterMut"]},"header::map::Entry":{"T":["header::map::Cursor","header::map::Keys","header::map::IntoIter","header::name::HeaderName","header::map::Iter","header::name::StandardHeader","byte_str::ByteStr","header::map::Bucket","header::map::ValueDrain","uri::scheme::Protocol","response::Response","request::Builder","header::map::ExtraValue","uri::InvalidUri","header::map::Values","header::map::Entry","uri::builder::Builder","response::Parts","uri::scheme::Scheme","header::map::ValuesMut","header::name::MaybeLower","method::Method","extensions::Extensions","header::map::OccupiedEntry","header::value::HeaderValue","header::map::ValueIter","header::map::RawLinks","method::InvalidMethod","header::name::Custom","uri::scheme::Scheme2","header::map::HeaderMap","uri::port::Port","header::map::Drain","header::map::GetAll","header::map::HashValue","header::name::InvalidHeaderName","header::value::InvalidHeaderValue","<*const T as std::fmt::Debug>","header::value::ToStrError","uri::Parts","header::map::VacantEntry","version::Version","header::map::Links","error::Error","request::Request","header::name::Repr","status::StatusCode","header::map::Link","header::name::HdrName","uri::Uri","response::Builder","header::map::IterMut","request::Parts","uri::ErrorKind","uri::InvalidUriParts","uri::authority::Authority","header::map::ValueIterMut","status::InvalidStatusCode","uri::path::PathAndQuery"]},"header::map::ExtraValue":{"T":["uri::path::PathAndQuery","header::name::Repr","header::map::HeaderMap","uri::Uri","byte_str::ByteStr","header::name::Custom","header::map::Links","header::map::RawLinks","header::map::HashValue","header::map::ExtraValue","uri::scheme::Protocol","uri::scheme::Scheme2","header::value::HeaderValue","method::Method","version::Version","header::map::Cursor","<*const T as std::fmt::Debug>","header::name::MaybeLower","header::map::Bucket","uri::authority::Authority","uri::scheme::Scheme","header::map::Link","header::name::StandardHeader","status::StatusCode","header::name::HeaderName"]},"header::map::GetAll":{"T":["uri::ErrorKind","header::map::HeaderMap","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::map::HashValue","byte_str::ByteStr","header::map::GetAll","header::name::Custom","version::Version","header::name::Repr","header::name::StandardHeader","header::map::Link","header::map::Cursor"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["byte_str::ByteStr","response::Builder","response::Response","uri::ErrorKind","<*const T as std::fmt::Debug>","header::map::RawLinks","header::name::HeaderName","header::name::HdrName","header::map::ValueDrain","header::map::Entry","header::value::HeaderValue","status::InvalidStatusCode","header::map::ExtraValue","header::map::Keys","header::map::Bucket","version::Version","status::StatusCode","header::value::ToStrError","header::map::Link","uri::InvalidUri","request::Builder","header::map::Links","header::map::ValueIterMut","uri::authority::Authority","header::map::Values","uri::path::PathAndQuery","error::Error","header::name::Custom","method::Method","uri::Parts","header::map::IterMut","uri::scheme::Protocol","header::map::Drain","request::Parts","header::map::VacantEntry","header::name::StandardHeader","header::map::IntoIter","header::map::ValuesMut","header::map::HeaderMap","uri::InvalidUriParts","header::map::ValueIter","header::name::Repr","header::map::OccupiedEntry","header::map::Cursor","uri::builder::Builder","header::name::MaybeLower","header::map::GetAll","uri::scheme::Scheme","request::Request","method::InvalidMethod","uri::Uri","response::Parts","uri::scheme::Scheme2","header::map::Iter","header::map::HashValue","header::name::InvalidHeaderName","uri::port::Port","header::value::InvalidHeaderValue","extensions::Extensions"]},"header::map::Iter":{"T":["<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::IterMut","header::map::Iter","header::map::Drain","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["header::map::ValueIterMut","header::map::Iter","header::map::Drain","header::map::IterMut","<*mut T as std::fmt::Debug>","header::map::ValueDrain"]},"header::map::Keys":{"T":["header::map::Link","response::Parts","extensions::Extensions","header::name::MaybeLower","version::Version","header::map::IterMut","header::map::Links","header::map::Keys","header::map::Cursor","header::map::Entry","uri::port::Port","header::value::HeaderValue","uri::scheme::Scheme","header::map::Drain","response::Response","header::map::VacantEntry","byte_str::ByteStr","header::value::ToStrError","header::map::HeaderMap","header::map::Values","header::name::HdrName","header::value::InvalidHeaderValue","uri::InvalidUri","method::Method","header::map::Iter","uri::builder::Builder","header::map::ValueIterMut","request::Builder","request::Parts","uri::scheme::Protocol","header::map::OccupiedEntry","header::map::Bucket","header::map::RawLinks","uri::Parts","method::InvalidMethod","header::name::StandardHeader","status::StatusCode","header::map::ValuesMut","uri::InvalidUriParts","request::Request","response::Builder","uri::authority::Authority","uri::path::PathAndQuery","uri::scheme::Scheme2","header::map::ValueIter","header::name::InvalidHeaderName","header::name::Repr","header::name::Custom","header::map::IntoIter","error::Error","uri::ErrorKind","header::map::ExtraValue","header::name::HeaderName","<&mut T as std::fmt::Debug>","uri::Uri","header::map::ValueDrain","header::map::HashValue","header::map::GetAll","status::InvalidStatusCode"]},"header::map::OccupiedEntry":{"T":["version::Version","uri::scheme::Scheme2","header::name::StandardHeader","header::name::HeaderName","header::value::HeaderValue","header::map::Values","response::Parts","uri::path::PathAndQuery","header::map::GetAll","status::InvalidStatusCode","uri::scheme::Protocol","uri::Uri","header::map::ExtraValue","uri::ErrorKind","header::map::HeaderMap","uri::scheme::Scheme","header::map::IterMut","header::map::ValueDrain","header::map::Cursor","method::InvalidMethod","uri::InvalidUri","header::value::InvalidHeaderValue","byte_str::ByteStr","header::map::Links","request::Builder","header::map::Link","uri::InvalidUriParts","header::map::Drain","header::map::HashValue","header::map::ValuesMut","error::Error","header::name::Custom","uri::Parts","uri::port::Port","<&T as std::fmt::Debug>","header::name::InvalidHeaderName","request::Request","response::Response","header::value::ToStrError","header::map::IntoIter","header::map::OccupiedEntry","header::map::Iter","response::Builder","method::Method","request::Parts","header::map::Keys","header::map::VacantEntry","header::map::Entry","uri::builder::Builder","header::map::ValueIter","header::map::RawLinks","uri::authority::Authority","header::name::HdrName","header::name::MaybeLower","header::map::Bucket","extensions::Extensions","header::name::Repr","status::StatusCode","header::map::ValueIterMut"]},"header::map::RawLinks":{"T":["header::map::IterMut","header::map::ValueDrain","header::name::InvalidHeaderName","header::map::Entry","version::Version","header::map::HeaderMap","status::InvalidStatusCode","method::Method","request::Parts","request::Request","header::map::GetAll","error::Error","header::map::OccupiedEntry","header::name::HeaderName","header::name::Custom","response::Response","header::map::Keys","response::Builder","header::map::Cursor","header::map::Links","uri::scheme::Protocol","header::name::MaybeLower","request::Builder","header::map::Iter","byte_str::ByteStr","header::map::ValuesMut","uri::ErrorKind","status::StatusCode","<*const T as std::fmt::Debug>","uri::Parts","header::name::Repr","header::map::IntoIter","method::InvalidMethod","header::map::Bucket","uri::builder::Builder","header::map::HashValue","header::value::InvalidHeaderValue","response::Parts","header::map::VacantEntry","header::value::HeaderValue","header::map::ExtraValue","uri::scheme::Scheme2","header::map::Values","header::map::ValueIterMut","header::value::ToStrError","uri::InvalidUri","uri::port::Port","extensions::Extensions","header::name::HdrName","uri::scheme::Scheme","header::map::Link","header::map::Drain","header::name::StandardHeader","header::map::RawLinks","header::map::ValueIter","uri::Uri","uri::authority::Authority","uri::InvalidUriParts","uri::path::PathAndQuery"]},"header::map::VacantEntry":{"T":["header::map::VacantEntry","header::name::Repr","header::name::Custom","uri::InvalidUri","header::map::Link","header::map::ValueIter","header::map::Bucket","uri::Parts","uri::ErrorKind","uri::path::PathAndQuery","header::map::IntoIter","header::name::HdrName","uri::builder::Builder","extensions::Extensions","response::Builder","uri::port::Port","header::map::GetAll","header::map::ValueDrain","header::map::RawLinks","method::InvalidMethod","header::map::ValuesMut","header::name::InvalidHeaderName","header::map::ExtraValue","header::value::ToStrError","header::map::IterMut","header::map::Values","status::StatusCode","header::map::Drain","header::map::HeaderMap","header::map::Iter","uri::scheme::Scheme","version::Version","header::map::Cursor","request::Builder","header::map::HashValue","uri::InvalidUriParts","header::name::HeaderName","header::name::MaybeLower","header::map::ValueIterMut","<&T as std::fmt::Debug>","uri::scheme::Protocol","uri::scheme::Scheme2","header::map::Links","method::Method","header::map::Entry","header::name::StandardHeader","status::InvalidStatusCode","request::Request","byte_str::ByteStr","header::value::HeaderValue","header::map::Keys","response::Parts","request::Parts","uri::authority::Authority","response::Response","header::value::InvalidHeaderValue","uri::Uri","header::map::OccupiedEntry","error::Error"]},"header::map::ValueDrain":{"T":["header::map::ValueIterMut","header::map::ValueDrain","<*mut T as std::fmt::Debug>","header::map::Iter","header::map::Drain","header::map::IterMut"]},"header::map::ValueIter":{"T":["request::Request","header::map::Links","response::Response","header::name::Repr","header::map::Values","header::map::Cursor","header::name::HdrName","status::StatusCode","header::map::ValuesMut","header::map::ValueIterMut","uri::path::PathAndQuery","request::Builder","response::Parts","header::map::RawLinks","header::name::Custom","uri::scheme::Scheme2","header::map::Entry","header::map::ValueIter","header::map::ExtraValue","uri::Uri","uri::ErrorKind","uri::Parts","uri::scheme::Scheme","uri::builder::Builder","header::map::GetAll","method::InvalidMethod","header::map::Iter","uri::scheme::Protocol","header::map::ValueDrain","uri::InvalidUriParts","uri::port::Port","error::Error","header::map::OccupiedEntry","header::map::HashValue","header::map::Keys","extensions::Extensions","header::name::HeaderName","version::Version","status::InvalidStatusCode","header::map::Bucket","header::value::ToStrError","header::name::StandardHeader","header::map::Drain","<&T as std::fmt::Debug>","header::value::InvalidHeaderValue","header::map::Link","header::map::VacantEntry","uri::InvalidUri","header::name::MaybeLower","header::map::IntoIter","header::name::InvalidHeaderName","method::Method","request::Parts","header::map::HeaderMap","header::map::IterMut","header::value::HeaderValue","byte_str::ByteStr","uri::authority::Authority","response::Builder"]},"header::map::ValueIterMut":{"T":["header::map::IterMut","header::map::Iter","header::map::ValueIterMut","header::map::Drain","<*mut T as std::fmt::Debug>","header::map::ValueDrain"]},"header::map::Values":{"T":["header::name::InvalidHeaderName","request::Parts","request::Builder","uri::scheme::Protocol","header::name::Repr","uri::InvalidUriParts","method::InvalidMethod","uri::path::PathAndQuery","header::map::GetAll","uri::ErrorKind","header::name::StandardHeader","header::map::Drain","header::map::OccupiedEntry","uri::builder::Builder","header::map::ValueIter","status::InvalidStatusCode","header::map::ValueDrain","header::map::VacantEntry","header::map::RawLinks","response::Parts","header::value::HeaderValue","header::value::ToStrError","header::map::ExtraValue","header::name::MaybeLower","header::map::Values","header::name::HeaderName","header::map::HashValue","header::map::Cursor","header::name::HdrName","uri::authority::Authority","header::map::Bucket","uri::port::Port","response::Response","uri::scheme::Scheme","header::map::ValueIterMut","header::value::InvalidHeaderValue","header::map::Link","version::Version","<*const T as std::fmt::Debug>","request::Request","header::map::ValuesMut","header::map::Keys","method::Method","uri::Uri","header::map::Entry","header::map::Iter","byte_str::ByteStr","header::map::HeaderMap","extensions::Extensions","status::StatusCode","header::map::Links","uri::InvalidUri","header::name::Custom","header::map::IntoIter","response::Builder","uri::Parts","uri::scheme::Scheme2","error::Error","header::map::IterMut"]},"header::map::ValuesMut":{"T":["header::map::Cursor","header::map::OccupiedEntry","header::name::Custom","uri::port::Port","uri::scheme::Scheme2","header::map::RawLinks","version::Version","uri::InvalidUriParts","uri::authority::Authority","uri::scheme::Protocol","uri::InvalidUri","header::map::ValueIter","header::value::InvalidHeaderValue","response::Parts","uri::builder::Builder","extensions::Extensions","header::map::ExtraValue","uri::path::PathAndQuery","<&T as std::fmt::Debug>","uri::ErrorKind","response::Response","header::name::InvalidHeaderName","header::map::IntoIter","status::InvalidStatusCode","header::map::Keys","header::name::StandardHeader","header::name::HeaderName","request::Parts","response::Builder","header::map::VacantEntry","uri::scheme::Scheme","uri::Parts","method::InvalidMethod","header::map::Values","uri::Uri","header::value::ToStrError","header::name::Repr","request::Builder","header::name::MaybeLower","header::map::HeaderMap","header::map::ValueIterMut","header::value::HeaderValue","status::StatusCode","header::map::Drain","header::map::Bucket","header::map::ValuesMut","request::Request","header::map::ValueDrain","header::map::Links","header::map::HashValue","byte_str::ByteStr","header::map::Entry","header::map::IterMut","header::map::GetAll","header::map::Iter","method::Method","error::Error","header::map::Link","header::name::HdrName"]},"header::name::Repr":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","header::name::Custom","header::name::StandardHeader","header::name::Repr","version::Version","byte_str::ByteStr"]},"request::Request":{"T":["uri::builder::Builder","header::map::HeaderMap","status::StatusCode","uri::Uri","method::Method","uri::Parts","response::Builder","request::Builder","request::Request","extensions::Extensions","response::Response","version::Version"]},"response::Response":{"T":["uri::Uri","extensions::Extensions","uri::Parts","status::StatusCode","method::Method","uri::builder::Builder","request::Builder","response::Builder","request::Request","header::map::HeaderMap","response::Response","version::Version"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["<&mut T as std::fmt::Debug>","uri::authority::Authority","uri::scheme::Scheme","method::Method","uri::port::Port","header::value::HeaderValue"]},"uri::scheme::Scheme2":{"T":["version::Version","header::name::Repr","uri::scheme::Scheme","std::boxed::Box<byte_str::ByteStr>","uri::scheme::Protocol","header::map::RawLinks","header::map::Bucket","header::name::Custom","std::clone::impls::<impl std::clone::Clone for &T>","header::name::MaybeLower","header::map::HeaderMap","method::Method","header::map::Link","header::map::Links","header::map::ExtraValue","header::map::HashValue","byte_str::ByteStr","uri::scheme::Scheme2","header::name::StandardHeader","header::value::HeaderValue","uri::authority::Authority","uri::Uri","status::StatusCode","header::name::HeaderName","uri::path::PathAndQuery","header::map::Cursor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Bucket<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::Bucket<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::Bucket<T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::Bucket<T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::Bucket<T> as std::clone::Clone>::clone
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Bucket<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized","std::clone::Clone"]},"header::map::Bucket":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized"]},"header::map::IterMut":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::marker::Sized","std::fmt::Debug"]},"request::Request":{"T":["std::marker::Sized","std::fmt::Debug","std::default::Default"]},"response::Response":{"T":["std::default::Default","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::Bucket<T> as std::clone::Clone>::clone":{"T":["method::extension::AllocatedExtension","header::map::HashValue","header::value::HeaderValue","header::map::Cursor","version::Version","header::name::Custom","header::map::Links","method::extension::InlineExtension","header::name::Repr","header::map::ExtraValue","method::Inner","status::StatusCode","std::clone::impls::<impl std::clone::Clone for *mut T>","header::map::Danger","version::Http","header::map::Link","header::name::StandardHeader","uri::scheme::Protocol","uri::scheme::Scheme","byte_str::ByteStr","header::map::Bucket","uri::path::PathAndQuery","uri::authority::Authority","header::name::HeaderName","uri::Uri","header::name::MaybeLower","header::map::HeaderMap","method::Method","header::map::RawLinks","uri::scheme::Scheme2","header::map::Pos"]},"header::map::Bucket":{"T":["status::StatusCode","header::map::Links","method::Method","header::map::HeaderMap","version::Version","uri::scheme::Protocol","header::name::Custom","header::map::HashValue","uri::authority::Authority","byte_str::ByteStr","uri::path::PathAndQuery","uri::Uri","header::map::Bucket","header::name::MaybeLower","header::name::HeaderName","std::clone::impls::<impl std::clone::Clone for *mut T>","header::name::StandardHeader","header::name::Repr","header::map::ExtraValue","header::map::RawLinks","header::map::Link","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::Cursor","header::value::HeaderValue"]},"header::map::Drain":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::ValueDrain","<*const T as std::fmt::Debug>","header::map::Iter","header::map::Drain"]},"header::map::Entry":{"T":["version::Version","header::map::Links","request::Builder","header::map::ExtraValue","header::map::RawLinks","uri::scheme::Scheme","header::map::IterMut","response::Response","header::map::Keys","header::map::HeaderMap","header::map::ValuesMut","uri::authority::Authority","header::name::Custom","header::map::HashValue","uri::path::PathAndQuery","uri::InvalidUri","header::map::ValueDrain","extensions::Extensions","header::name::Repr","<&T as std::fmt::Debug>","request::Request","header::name::InvalidHeaderName","header::map::IntoIter","method::InvalidMethod","byte_str::ByteStr","header::value::InvalidHeaderValue","header::name::MaybeLower","error::Error","header::map::Values","header::map::Iter","header::value::ToStrError","header::map::Entry","response::Parts","header::value::HeaderValue","header::map::OccupiedEntry","request::Parts","status::StatusCode","header::name::HeaderName","uri::scheme::Protocol","uri::Parts","header::map::Drain","header::map::VacantEntry","method::Method","header::map::ValueIter","header::map::Bucket","uri::Uri","status::InvalidStatusCode","uri::ErrorKind","uri::InvalidUriParts","header::map::ValueIterMut","uri::scheme::Scheme2","uri::port::Port","uri::builder::Builder","header::name::HdrName","header::map::GetAll","response::Builder","header::map::Cursor","header::name::StandardHeader","header::map::Link"]},"header::map::ExtraValue":{"T":["header::name::HeaderName","header::map::Cursor","version::Version","header::map::Bucket","uri::path::PathAndQuery","header::map::RawLinks","uri::scheme::Scheme2","header::name::StandardHeader","header::map::HashValue","status::StatusCode","header::map::HeaderMap","uri::scheme::Scheme","method::Method","byte_str::ByteStr","header::map::Links","header::value::HeaderValue","uri::scheme::Protocol","uri::authority::Authority","header::name::Repr","header::map::Link","header::name::Custom","std::clone::impls::<impl std::clone::Clone for *const T>","header::map::ExtraValue","header::name::MaybeLower","uri::Uri"]},"header::map::GetAll":{"T":["header::name::Repr","header::name::Custom","std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>","version::Version","header::map::Link","header::map::GetAll","header::map::HashValue","header::name::StandardHeader","uri::ErrorKind","byte_str::ByteStr","header::map::HeaderMap","header::map::Cursor"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["request::Request","header::map::HashValue","header::map::Iter","header::map::ValueIter","uri::port::Port","header::map::Links","request::Builder","response::Parts","header::map::Cursor","header::map::ValuesMut","header::map::ValueIterMut","byte_str::ByteStr","uri::Parts","version::Version","error::Error","header::map::VacantEntry","uri::InvalidUriParts","header::map::Keys","header::map::GetAll","extensions::Extensions","response::Response","header::map::HeaderMap","header::map::Drain","header::map::ValueDrain","header::name::Repr","uri::scheme::Protocol","method::Method","uri::builder::Builder","uri::scheme::Scheme2","header::value::ToStrError","method::InvalidMethod","header::name::HeaderName","status::InvalidStatusCode","uri::InvalidUri","uri::path::PathAndQuery","header::name::StandardHeader","header::name::Custom","uri::Uri","status::StatusCode","header::map::Link","header::map::Entry","header::name::MaybeLower","header::map::RawLinks","header::value::HeaderValue","header::name::InvalidHeaderName","header::map::ExtraValue","header::map::IterMut","uri::authority::Authority","uri::scheme::Scheme","header::map::Values","header::name::HdrName","uri::ErrorKind","header::map::OccupiedEntry","header::value::InvalidHeaderValue","request::Parts","response::Builder","header::map::Bucket","<*const T as std::fmt::Debug>","header::map::IntoIter"]},"header::map::Iter":{"T":["header::map::Drain","header::map::IterMut","header::map::Iter","<*const T as std::fmt::Debug>","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::IterMut":{"T":["header::map::ValueDrain","header::map::Drain","header::map::IterMut","header::map::ValueIterMut","<*const T as std::marker::Send>","header::map::Iter"]},"header::map::Keys":{"T":["header::map::RawLinks","header::map::ValuesMut","uri::scheme::Scheme2","header::map::ExtraValue","header::map::Links","header::name::MaybeLower","uri::authority::Authority","header::map::Entry","error::Error","<*mut T as std::fmt::Debug>","header::name::HeaderName","response::Parts","uri::scheme::Scheme","uri::port::Port","header::map::ValueIter","request::Builder","header::map::Values","header::map::Drain","uri::InvalidUriParts","uri::builder::Builder","header::value::InvalidHeaderValue","method::Method","uri::path::PathAndQuery","header::value::HeaderValue","uri::InvalidUri","header::map::Cursor","version::Version","header::map::GetAll","header::map::HeaderMap","status::StatusCode","status::InvalidStatusCode","uri::Parts","header::map::VacantEntry","header::name::HdrName","extensions::Extensions","header::map::ValueDrain","byte_str::ByteStr","header::map::Bucket","uri::Uri","uri::ErrorKind","header::map::Keys","request::Parts","header::map::IterMut","header::map::Iter","header::name::Repr","request::Request","header::name::Custom","response::Builder","method::InvalidMethod","header::map::Link","header::map::OccupiedEntry","header::value::ToStrError","response::Response","header::map::ValueIterMut","header::map::HashValue","header::name::InvalidHeaderName","uri::scheme::Protocol","header::map::IntoIter","header::name::StandardHeader"]},"header::map::OccupiedEntry":{"T":["header::name::InvalidHeaderName","error::Error","header::map::Cursor","byte_str::ByteStr","header::map::RawLinks","response::Builder","header::name::StandardHeader","header::map::VacantEntry","uri::path::PathAndQuery","uri::InvalidUriParts","header::value::HeaderValue","version::Version","uri::builder::Builder","request::Parts","method::Method","header::map::ExtraValue","method::InvalidMethod","header::map::Links","header::map::Entry","header::map::IterMut","request::Request","header::name::Repr","header::map::ValueIter","status::InvalidStatusCode","header::name::HeaderName","<*const T as std::fmt::Debug>","extensions::Extensions","header::name::MaybeLower","header::map::IntoIter","uri::scheme::Scheme","header::name::HdrName","header::map::Iter","header::map::Drain","request::Builder","status::StatusCode","header::map::Link","uri::InvalidUri","response::Response","header::value::ToStrError","header::map::Bucket","uri::ErrorKind","uri::Uri","header::map::ValueIterMut","uri::scheme::Scheme2","header::map::HashValue","response::Parts","uri::authority::Authority","header::name::Custom","header::value::InvalidHeaderValue","header::map::Keys","uri::port::Port","header::map::Values","header::map::ValuesMut","header::map::GetAll","header::map::OccupiedEntry","uri::Parts","header::map::ValueDrain","uri::scheme::Protocol","header::map::HeaderMap"]},"header::map::RawLinks":{"T":["header::name::Custom","header::map::Values","uri::InvalidUriParts","uri::scheme::Scheme","response::Parts","uri::Parts","uri::Uri","header::map::ValueIterMut","uri::scheme::Scheme2","header::value::InvalidHeaderValue","uri::InvalidUri","request::Parts","header::map::IntoIter","response::Response","error::Error","header::map::Link","byte_str::ByteStr","uri::path::PathAndQuery","header::name::HeaderName","header::map::HeaderMap","status::InvalidStatusCode","header::name::MaybeLower","header::value::ToStrError","header::map::ValueIter","version::Version","extensions::Extensions","header::value::HeaderValue","header::map::GetAll","method::InvalidMethod","uri::port::Port","uri::builder::Builder","header::map::ExtraValue","header::map::OccupiedEntry","header::name::InvalidHeaderName","header::map::ValueDrain","response::Builder","header::map::Cursor","header::map::Links","header::name::StandardHeader","request::Builder","header::name::Repr","method::Method","header::map::Keys","header::name::HdrName","uri::authority::Authority","status::StatusCode","uri::scheme::Protocol","header::map::Entry","header::map::HashValue","request::Request","uri::ErrorKind","header::map::Bucket","<*mut T as std::fmt::Debug>","header::map::Drain","header::map::IterMut","header::map::VacantEntry","header::map::Iter","header::map::ValuesMut","header::map::RawLinks"]},"header::map::VacantEntry":{"T":["request::Parts","header::value::ToStrError","version::Version","uri::InvalidUri","method::Method","uri::scheme::Protocol","header::map::ValueDrain","request::Builder","header::name::StandardHeader","header::map::Drain","status::StatusCode","uri::scheme::Scheme","header::map::Iter","header::map::Entry","header::map::HeaderMap","error::Error","extensions::Extensions","uri::authority::Authority","header::map::IntoIter","header::map::Cursor","header::map::GetAll","header::map::Link","status::InvalidStatusCode","header::map::ValuesMut","header::map::OccupiedEntry","header::map::ValueIter","response::Response","header::name::HeaderName","response::Parts","request::Request","uri::path::PathAndQuery","header::map::IterMut","header::map::ValueIterMut","header::map::VacantEntry","uri::scheme::Scheme2","header::value::InvalidHeaderValue","uri::builder::Builder","uri::InvalidUriParts","header::map::Links","header::name::Custom","header::value::HeaderValue","header::map::RawLinks","uri::ErrorKind","header::name::InvalidHeaderName","header::map::ExtraValue","byte_str::ByteStr","header::map::HashValue","uri::Uri","header::map::Keys","<*const T as std::fmt::Debug>","header::name::HdrName","method::InvalidMethod","uri::Parts","header::map::Bucket","uri::port::Port","response::Builder","header::name::Repr","header::name::MaybeLower","header::map::Values"]},"header::map::ValueDrain":{"T":["header::map::IterMut","header::map::Iter","header::map::Drain","<*const T as std::fmt::Debug>","header::map::ValueDrain","header::map::ValueIterMut"]},"header::map::ValueIter":{"T":["header::map::Links","header::map::GetAll","header::map::RawLinks","header::map::Iter","byte_str::ByteStr","header::map::Link","uri::InvalidUri","header::map::Values","uri::builder::Builder","header::map::Drain","uri::authority::Authority","header::name::MaybeLower","header::map::ValueIterMut","header::map::Bucket","header::map::IterMut","header::map::OccupiedEntry","response::Response","extensions::Extensions","header::map::Keys","<&T as std::fmt::Debug>","header::map::HeaderMap","header::map::Entry","request::Builder","header::map::HashValue","header::name::StandardHeader","uri::port::Port","method::Method","header::map::IntoIter","uri::scheme::Scheme","header::value::InvalidHeaderValue","request::Parts","method::InvalidMethod","header::name::Custom","header::name::HeaderName","status::StatusCode","version::Version","response::Parts","status::InvalidStatusCode","header::map::ValueIter","response::Builder","uri::path::PathAndQuery","error::Error","uri::Parts","header::map::VacantEntry","uri::Uri","header::name::HdrName","uri::ErrorKind","header::map::ExtraValue","header::name::Repr","header::value::HeaderValue","uri::scheme::Protocol","header::map::ValuesMut","request::Request","header::map::Cursor","header::name::InvalidHeaderName","uri::InvalidUriParts","header::map::ValueDrain","header::value::ToStrError","uri::scheme::Scheme2"]},"header::map::ValueIterMut":{"T":["header::map::IterMut","header::map::ValueDrain","<*mut T as std::marker::Sync>","header::map::Drain","header::map::Iter","header::map::ValueIterMut"]},"header::map::Values":{"T":["method::InvalidMethod","header::map::Values","header::map::ExtraValue","header::value::HeaderValue","uri::InvalidUriParts","byte_str::ByteStr","header::map::Keys","header::name::Repr","header::map::Cursor","uri::scheme::Protocol","header::map::Links","uri::Parts","header::value::InvalidHeaderValue","request::Parts","header::map::Iter","status::StatusCode","header::map::IterMut","uri::port::Port","header::name::HeaderName","version::Version","header::map::HeaderMap","uri::builder::Builder","uri::authority::Authority","error::Error","header::map::HashValue","method::Method","header::map::Entry","extensions::Extensions","response::Parts","header::map::RawLinks","header::name::HdrName","header::map::Link","header::name::StandardHeader","uri::ErrorKind","header::value::ToStrError","uri::scheme::Scheme2","header::name::InvalidHeaderName","header::name::MaybeLower","header::map::OccupiedEntry","header::map::GetAll","header::map::IntoIter","response::Response","status::InvalidStatusCode","header::map::Bucket","uri::path::PathAndQuery","header::name::Custom","header::map::ValuesMut","header::map::ValueDrain","header::map::ValueIter","request::Builder","header::map::VacantEntry","uri::scheme::Scheme","header::map::Drain","response::Builder","uri::InvalidUri","request::Request","header::map::ValueIterMut","uri::Uri","<&mut T as std::fmt::Debug>"]},"header::map::ValuesMut":{"T":["header::map::Link","header::value::HeaderValue","header::map::IntoIter","<&mut T as std::fmt::Debug>","response::Parts","header::map::VacantEntry","header::map::IterMut","uri::scheme::Scheme2","header::map::ExtraValue","header::map::GetAll","status::StatusCode","byte_str::ByteStr","header::map::HeaderMap","header::name::HdrName","header::name::StandardHeader","method::Method","uri::authority::Authority","request::Builder","header::map::Drain","method::InvalidMethod","extensions::Extensions","response::Response","header::map::Iter","uri::Uri","uri::scheme::Scheme","status::InvalidStatusCode","error::Error","uri::path::PathAndQuery","header::map::Keys","header::map::HashValue","request::Request","uri::InvalidUriParts","header::map::RawLinks","request::Parts","uri::ErrorKind","version::Version","header::map::Values","header::map::ValueIter","header::name::Custom","header::name::Repr","header::name::HeaderName","header::value::ToStrError","header::map::OccupiedEntry","header::name::InvalidHeaderName","header::map::Bucket","uri::port::Port","uri::builder::Builder","response::Builder","header::name::MaybeLower","header::map::Cursor","header::value::InvalidHeaderValue","uri::InvalidUri","uri::Parts","uri::scheme::Protocol","header::map::ValueDrain","header::map::Entry","header::map::ValueIterMut","header::map::Links","header::map::ValuesMut"]},"header::name::Repr":{"T":["header::name::Repr","header::name::Custom","version::Version","header::name::StandardHeader","byte_str::ByteStr","std::clone::impls::<impl std::clone::Clone for *const T>"]},"request::Request":{"T":["version::Version","extensions::Extensions","method::Method","header::map::HeaderMap","uri::builder::Builder","request::Builder","response::Builder","status::StatusCode","response::Response","uri::Parts","uri::Uri","request::Request"]},"response::Response":{"T":["request::Request","method::Method","extensions::Extensions","request::Builder","status::StatusCode","header::map::HeaderMap","uri::Uri","response::Response","uri::builder::Builder","response::Builder","uri::Parts","version::Version"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"uri::port::Port":{"T":["<&mut T as std::fmt::Debug>","method::Method","uri::port::Port","uri::scheme::Scheme","header::value::HeaderValue","uri::authority::Authority"]},"uri::scheme::Scheme2":{"T":["header::value::HeaderValue","header::name::MaybeLower","header::map::ExtraValue","<*mut T as std::fmt::Debug>","header::map::Cursor","uri::scheme::Protocol","header::map::RawLinks","uri::Uri","status::StatusCode","uri::path::PathAndQuery","uri::scheme::Scheme","header::map::HeaderMap","header::map::Bucket","header::name::Custom","uri::scheme::Scheme2","header::map::Link","method::Method","std::boxed::Box<byte_str::ByteStr>","header::map::HashValue","byte_str::ByteStr","header::name::HeaderName","header::name::Repr","uri::authority::Authority","header::map::Links","header::name::StandardHeader","version::Version"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Bucket<T>
+p0.clone();
+<header::map::Bucket<T> as std::clone::Clone>::clone(p0);
+crate::<header::map::Bucket<T> as std::clone::Clone>::clone(p0);
+<header::map::Bucket<T>>::clone(p0);
-----------------
src/header/map.rs <header::map::Links as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Links
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::Links as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::Links as std::fmt::Debug>::fmt(p0, p1);
+<header::map::Links>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::Links as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Links
+p0.clone();
+<header::map::Links as std::clone::Clone>::clone(p0);
+crate::<header::map::Links as std::clone::Clone>::clone(p0);
+<header::map::Links>::clone(p0);
-----------------
src/header/map.rs <header::map::RawLinks<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<header::map::RawLinks<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"header::map::Drain":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::convert::TryFrom","std::cmp::PartialEq","std::clone::Clone"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug","std::marker::Sync"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::marker::Send","std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::name::Repr":{"T":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::hash::Hash","std::marker::Sized","std::cmp::Eq"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::default::Default","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::convert::AsRef","std::marker::Sized","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<header::map::RawLinks<T> as std::fmt::Debug>::fmt":{"T":["uri::scheme::Scheme","uri::InvalidUri","header::map::Keys","uri::builder::Builder","<*const T as std::fmt::Debug>","header::name::InvalidHeaderName","uri::scheme::Protocol","status::InvalidStatusCode","header::map::RawLinks","header::name::Repr","status::StatusCode","request::Parts","uri::Uri","header::map::IterMut","header::map::Cursor","extensions::Extensions","request::Builder","header::map::HeaderMap","method::InvalidMethod","header::map::ValueDrain","error::Error","uri::path::PathAndQuery","response::Response","header::map::Bucket","method::Method","header::map::Links","header::map::Entry","header::map::ValueIter","header::map::ExtraValue","header::map::Values","uri::port::Port","header::name::HdrName","header::map::VacantEntry","<*mut T as std::fmt::Debug>","header::name::HeaderName","response::Builder","header::value::InvalidHeaderValue","uri::scheme::Scheme2","header::name::StandardHeader","uri::ErrorKind","header::value::ToStrError","header::name::MaybeLower","header::map::HashValue","header::map::ValueIterMut","version::Version","uri::authority::Authority","uri::InvalidUriParts","header::map::ValuesMut","response::Parts","header::map::OccupiedEntry","uri::Parts","header::map::GetAll","header::map::Link","byte_str::ByteStr","header::map::Drain","header::value::HeaderValue","header::map::IntoIter","header::map::Iter","request::Request","header::name::Custom"]},"header::map::Bucket":{"T":["header::map::HeaderMap","std::clone::impls::<impl std::clone::Clone for &mut T>","header::map::ExtraValue","header::name::StandardHeader","header::name::MaybeLower","header::map::Bucket","uri::scheme::Scheme","uri::scheme::Scheme2","header::map::Cursor","header::map::HashValue","uri::Uri","status::StatusCode","header::name::HeaderName","method::Method","header::name::Custom","header::map::Link","header::name::Repr","uri::scheme::Protocol","header::value::HeaderValue","version::Version","header::map::Links","uri::authority::Authority","uri::path::PathAndQuery","header::map::RawLinks","byte_str::ByteStr"]},"header::map::Drain":{"T":["header::map::Iter","header::map::ValueIterMut","header::map::ValueDrain","header::map::Drain","<*mut T as std::fmt::Debug>","header::map::IterMut"]},"header::map::Entry":{"T":["header::map::ValuesMut","uri::ErrorKind","request::Request","uri::builder::Builder","error::Error","header::map::Cursor","uri::path::PathAndQuery","uri::Uri","header::name::Custom","status::InvalidStatusCode","header::map::HeaderMap","byte_str::ByteStr","uri::port::Port","header::name::StandardHeader","version::Version","uri::scheme::Scheme2","request::Builder","uri::scheme::Scheme","header::map::HashValue","header::map::VacantEntry","header::map::Bucket","uri::InvalidUriParts","header::map::Links","extensions::Extensions","response::Builder","header::map::IntoIter","header::map::RawLinks","response::Response","response::Parts","request::Parts","method::Method","header::value::InvalidHeaderValue","method::InvalidMethod","header::name::InvalidHeaderName","header::map::ValueIter","header::name::HeaderName","header::map::Drain","header::map::Iter","uri::scheme::Protocol","header::value::HeaderValue","header::map::ValueIterMut","header::name::HdrName","header::map::Keys","uri::Parts","header::map::IterMut","header::map::GetAll","uri::authority::Authority","header::map::OccupiedEntry","header::map::Entry","header::map::ExtraValue","header::map::Link","header::map::Values","<&T as std::fmt::Debug>","uri::InvalidUri","header::name::MaybeLower","status::StatusCode","header::map::ValueDrain","header::name::Repr","header::value::ToStrError"]},"header::map::ExtraValue":{"T":["uri::Uri","header::map::Links","method::Method","header::name::Custom","header::map::RawLinks","uri::scheme::Scheme2","status::StatusCode","header::map::Cursor","header::name::MaybeLower","header::map::Bucket","header::name::Repr","uri::scheme::Protocol","header::map::ExtraValue","header::map::HashValue","header::map::HeaderMap","uri::authority::Authority","std::clone::impls::<impl std::clone::Clone for &T>","byte_str::ByteStr","uri::scheme::Scheme","uri::path::PathAndQuery","version::Version","header::value::HeaderValue","header::name::StandardHeader","header::map::Link","header::name::HeaderName"]},"header::map::GetAll":{"T":["header::name::Repr","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::map::GetAll","header::name::StandardHeader","header::map::HeaderMap","header::map::HashValue","uri::ErrorKind","version::Version","header::name::Custom","header::map::Link","byte_str::ByteStr","header::map::Cursor"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::Values","header::map::VacantEntry","header::map::Cursor","header::map::HashValue","extensions::Extensions","method::Method","header::map::Links","status::StatusCode","header::map::GetAll","error::Error","header::map::ValueDrain","header::map::OccupiedEntry","uri::path::PathAndQuery","uri::InvalidUriParts","uri::authority::Authority","header::name::HeaderName","request::Request","request::Parts","byte_str::ByteStr","header::map::HeaderMap","method::InvalidMethod","header::map::ValuesMut","uri::scheme::Scheme","header::value::ToStrError","uri::builder::Builder","request::Builder","header::map::IntoIter","header::value::HeaderValue","header::name::Repr","header::name::MaybeLower","header::map::ValueIter","header::map::Drain","header::name::HdrName","uri::Uri","header::name::InvalidHeaderName","status::InvalidStatusCode","uri::port::Port","header::map::Keys","header::name::StandardHeader","header::map::ValueIterMut","uri::InvalidUri","header::map::Link","header::map::IterMut","header::map::Bucket","header::value::InvalidHeaderValue","version::Version","response::Response","response::Builder","response::Parts","header::map::Iter","<&mut T as std::fmt::Debug>","uri::ErrorKind","uri::scheme::Protocol","header::map::RawLinks","header::name::Custom","header::map::Entry","uri::scheme::Scheme2","header::map::ExtraValue","uri::Parts"]},"header::map::Iter":{"T":["header::map::Iter","header::map::Drain","<*const T as std::marker::Sync>","header::map::ValueDrain","header::map::ValueIterMut","header::map::IterMut"]},"header::map::IterMut":{"T":["header::map::ValueIterMut","header::map::ValueDrain","header::map::Drain","header::map::Iter","header::map::IterMut","<*const T as std::fmt::Debug>"]},"header::map::Keys":{"T":["header::map::Iter","header::map::ValuesMut","header::map::ValueIter","header::map::OccupiedEntry","uri::ErrorKind","uri::Uri","header::map::ExtraValue","header::map::Entry","header::map::VacantEntry","uri::scheme::Protocol","header::name::InvalidHeaderName","<*mut T as std::fmt::Debug>","request::Request","header::map::IntoIter","method::Method","header::map::ValueIterMut","error::Error","header::map::Drain","header::value::ToStrError","status::StatusCode","method::InvalidMethod","header::map::HashValue","uri::InvalidUriParts","header::map::Keys","header::map::ValueDrain","header::map::Bucket","status::InvalidStatusCode","header::map::Links","extensions::Extensions","byte_str::ByteStr","header::name::HeaderName","header::map::Cursor","header::map::Link","header::map::HeaderMap","uri::Parts","uri::scheme::Scheme","response::Builder","header::name::Repr","header::value::InvalidHeaderValue","header::name::MaybeLower","uri::scheme::Scheme2","header::map::RawLinks","response::Response","header::value::HeaderValue","uri::builder::Builder","uri::InvalidUri","request::Builder","uri::path::PathAndQuery","response::Parts","request::Parts","header::map::IterMut","uri::port::Port","header::map::Values","header::name::HdrName","header::name::StandardHeader","header::map::GetAll","header::name::Custom","uri::authority::Authority","version::Version"]},"header::map::OccupiedEntry":{"T":["uri::path::PathAndQuery","header::map::Cursor","byte_str::ByteStr","header::map::HashValue","uri::builder::Builder","header::map::ExtraValue","header::name::HeaderName","uri::ErrorKind","extensions::Extensions","response::Parts","header::map::OccupiedEntry","response::Builder","header::name::HdrName","status::StatusCode","uri::InvalidUri","<*mut T as std::fmt::Debug>","uri::InvalidUriParts","uri::port::Port","header::value::HeaderValue","error::Error","header::map::Keys","header::map::Entry","header::map::Values","header::map::IterMut","header::name::StandardHeader","header::value::InvalidHeaderValue","uri::Uri","header::map::ValueIter","header::map::Links","header::map::HeaderMap","header::name::InvalidHeaderName","uri::Parts","method::Method","header::name::MaybeLower","header::map::IntoIter","uri::scheme::Scheme2","header::map::Link","header::map::Bucket","request::Parts","header::map::Drain","header::map::GetAll","header::name::Repr","header::map::RawLinks","response::Response","uri::scheme::Scheme","header::value::ToStrError","uri::authority::Authority","header::map::ValueIterMut","request::Builder","header::map::Iter","header::map::VacantEntry","header::map::ValuesMut","header::name::Custom","header::map::ValueDrain","uri::scheme::Protocol","method::InvalidMethod","status::InvalidStatusCode","version::Version","request::Request"]},"header::map::RawLinks":{"T":["header::map::ValueDrain","header::map::GetAll","header::map::HeaderMap","status::InvalidStatusCode","header::map::ExtraValue","<*const T as std::fmt::Debug>","error::Error","uri::InvalidUri","uri::port::Port","response::Parts","uri::ErrorKind","header::map::ValueIterMut","version::Version","header::map::Entry","extensions::Extensions","header::value::InvalidHeaderValue","header::map::Values","header::map::OccupiedEntry","header::map::ValuesMut","method::InvalidMethod","header::map::VacantEntry","header::map::RawLinks","header::name::HeaderName","response::Response","uri::scheme::Protocol","status::StatusCode","header::value::HeaderValue","uri::builder::Builder","header::map::Keys","uri::path::PathAndQuery","request::Builder","header::map::Iter","header::map::IntoIter","request::Request","uri::authority::Authority","uri::scheme::Scheme2","header::name::InvalidHeaderName","uri::Uri","header::map::Cursor","header::map::Link","header::name::StandardHeader","header::map::ValueIter","header::name::MaybeLower","header::name::HdrName","header::value::ToStrError","header::map::Links","byte_str::ByteStr","header::map::Bucket","header::map::Drain","method::Method","header::map::HashValue","header::name::Repr","header::map::IterMut","request::Parts","response::Builder","header::name::Custom","uri::Parts","uri::scheme::Scheme","uri::InvalidUriParts"]},"header::map::VacantEntry":{"T":["header::map::IntoIter","response::Response","uri::builder::Builder","header::map::OccupiedEntry","header::value::HeaderValue","header::map::ValueIter","uri::scheme::Scheme","uri::InvalidUri","response::Parts","request::Request","header::map::HashValue","method::InvalidMethod","byte_str::ByteStr","error::Error","uri::ErrorKind","response::Builder","uri::path::PathAndQuery","<*mut T as std::fmt::Debug>","uri::authority::Authority","header::map::HeaderMap","header::map::ValueIterMut","status::StatusCode","header::map::Entry","header::map::Cursor","header::name::StandardHeader","header::name::HeaderName","header::name::Custom","header::map::ValueDrain","status::InvalidStatusCode","method::Method","version::Version","extensions::Extensions","header::value::ToStrError","header::map::Values","header::name::MaybeLower","header::map::Keys","header::map::Iter","request::Parts","header::name::InvalidHeaderName","header::map::GetAll","header::name::HdrName","header::name::Repr","request::Builder","header::value::InvalidHeaderValue","header::map::Drain","header::map::RawLinks","uri::InvalidUriParts","header::map::Link","uri::Uri","uri::scheme::Protocol","header::map::Links","header::map::VacantEntry","uri::scheme::Scheme2","header::map::IterMut","header::map::ExtraValue","uri::Parts","uri::port::Port","header::map::Bucket","header::map::ValuesMut"]},"header::map::ValueDrain":{"T":["<*mut T as std::marker::Send>","header::map::Drain","header::map::Iter","header::map::ValueIterMut","header::map::IterMut","header::map::ValueDrain"]},"header::map::ValueIter":{"T":["method::InvalidMethod","method::Method","header::map::ExtraValue","header::name::InvalidHeaderName","header::map::Entry","header::map::RawLinks","request::Request","uri::InvalidUri","header::map::ValueDrain","header::name::Custom","header::map::Iter","header::map::HashValue","uri::scheme::Scheme2","header::name::Repr","<*const T as std::fmt::Debug>","uri::port::Port","uri::path::PathAndQuery","uri::Uri","extensions::Extensions","header::map::ValuesMut","uri::builder::Builder","header::map::Values","header::value::ToStrError","error::Error","header::map::Cursor","uri::authority::Authority","header::map::Drain","uri::Parts","header::map::HeaderMap","header::map::IntoIter","header::map::GetAll","header::name::StandardHeader","header::value::HeaderValue","version::Version","uri::ErrorKind","header::map::Bucket","header::map::VacantEntry","header::value::InvalidHeaderValue","header::name::HdrName","uri::scheme::Protocol","uri::InvalidUriParts","byte_str::ByteStr","header::map::IterMut","request::Parts","response::Builder","header::map::Keys","header::name::MaybeLower","header::map::ValueIterMut","response::Response","request::Builder","status::StatusCode","response::Parts","header::name::HeaderName","uri::scheme::Scheme","header::map::Link","header::map::ValueIter","header::map::Links","header::map::OccupiedEntry","status::InvalidStatusCode"]},"header::map::ValueIterMut":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::ValueDrain","header::map::Iter","<*const T as std::marker::Send>","header::map::Drain"]},"header::map::Values":{"T":["<&mut T as std::fmt::Debug>","status::StatusCode","uri::ErrorKind","header::map::IterMut","uri::Parts","header::map::Iter","request::Request","header::map::ValueIter","version::Version","response::Response","byte_str::ByteStr","method::Method","header::name::MaybeLower","error::Error","uri::path::PathAndQuery","request::Builder","uri::InvalidUriParts","status::InvalidStatusCode","request::Parts","header::map::ValueDrain","header::map::Bucket","uri::scheme::Scheme2","header::map::Cursor","header::value::HeaderValue","response::Parts","header::map::Drain","header::map::RawLinks","uri::scheme::Scheme","header::name::HdrName","method::InvalidMethod","header::map::HeaderMap","uri::port::Port","header::name::Repr","uri::scheme::Protocol","header::map::Entry","header::map::OccupiedEntry","header::name::InvalidHeaderName","header::map::Values","header::map::HashValue","uri::authority::Authority","header::map::ValuesMut","header::name::HeaderName","header::map::Link","uri::builder::Builder","extensions::Extensions","response::Builder","header::map::Keys","header::map::ValueIterMut","header::map::IntoIter","header::map::GetAll","uri::InvalidUri","uri::Uri","header::name::StandardHeader","header::value::ToStrError","header::map::VacantEntry","header::value::InvalidHeaderValue","header::map::ExtraValue","header::name::Custom","header::map::Links"]},"header::map::ValuesMut":{"T":["response::Response","uri::Parts","header::map::HashValue","header::map::Links","header::map::GetAll","extensions::Extensions","header::map::Drain","header::name::HdrName","header::map::Keys","uri::InvalidUriParts","header::name::InvalidHeaderName","uri::ErrorKind","header::map::Bucket","uri::Uri","header::map::OccupiedEntry","uri::builder::Builder","status::InvalidStatusCode","uri::scheme::Protocol","byte_str::ByteStr","header::map::Iter","header::name::Repr","header::map::IntoIter","<&T as std::fmt::Debug>","header::value::InvalidHeaderValue","header::map::Entry","version::Version","header::map::Link","header::map::ValueIterMut","request::Request","uri::authority::Authority","header::map::Values","method::InvalidMethod","response::Parts","header::map::Cursor","request::Builder","header::map::IterMut","header::name::Custom","header::map::ValuesMut","uri::scheme::Scheme2","header::map::RawLinks","method::Method","header::value::ToStrError","request::Parts","header::value::HeaderValue","header::map::VacantEntry","status::StatusCode","header::map::ValueDrain","header::name::HeaderName","header::map::HeaderMap","uri::port::Port","response::Builder","header::map::ValueIter","header::name::StandardHeader","header::map::ExtraValue","header::name::MaybeLower","uri::scheme::Scheme","uri::path::PathAndQuery","uri::InvalidUri","error::Error"]},"header::name::Repr":{"T":["std::hash::impls::<impl std::hash::Hash for *const T>","header::name::Custom","version::Version","header::name::Repr","byte_str::ByteStr","header::name::StandardHeader"]},"request::Request":{"T":["uri::Uri","response::Response","method::Method","extensions::Extensions","uri::Parts","request::Builder","request::Request","response::Builder","version::Version","status::StatusCode","uri::builder::Builder","header::map::HeaderMap"]},"response::Response":{"T":["extensions::Extensions","uri::Parts","request::Builder","request::Request","uri::Uri","response::Response","uri::builder::Builder","header::map::HeaderMap","status::StatusCode","version::Version","response::Builder","method::Method"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["uri::scheme::Scheme","<&T as std::convert::AsRef<U>>","method::Method","uri::port::Port","header::value::HeaderValue","uri::authority::Authority"]},"uri::scheme::Scheme2":{"T":["header::map::Cursor","byte_str::ByteStr","version::Version","<*const T as std::fmt::Debug>","header::map::Bucket","header::name::MaybeLower","header::map::HeaderMap","header::map::ExtraValue","status::StatusCode","header::name::HeaderName","uri::scheme::Scheme","header::map::RawLinks","std::boxed::Box<byte_str::ByteStr>","uri::scheme::Protocol","uri::path::PathAndQuery","header::name::Repr","uri::Uri","uri::scheme::Scheme2","header::map::Link","method::Method","header::map::HashValue","header::name::StandardHeader","uri::authority::Authority","header::name::Custom","header::value::HeaderValue","header::map::Links"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::RawLinks<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::RawLinks<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::RawLinks<T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::RawLinks<T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::ExtraValue<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ExtraValue<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Bucket":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::GetAll":{"T":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Send","std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::clone::Clone","std::hash::Hash","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ExtraValue<T> as std::fmt::Debug>::fmt":{"T":["uri::ErrorKind","<&mut T as std::fmt::Debug>","uri::path::PathAndQuery","header::map::Cursor","header::map::Drain","header::value::InvalidHeaderValue","uri::scheme::Protocol","header::value::HeaderValue","header::map::IterMut","error::Error","uri::port::Port","header::map::HashValue","header::name::HeaderName","version::Version","uri::authority::Authority","header::map::ValueDrain","header::map::VacantEntry","header::name::InvalidHeaderName","header::map::Link","header::map::RawLinks","response::Builder","header::name::StandardHeader","method::Method","<&T as std::fmt::Debug>","header::map::GetAll","uri::scheme::Scheme","header::map::ExtraValue","header::map::OccupiedEntry","uri::Parts","header::map::Links","request::Request","header::name::Custom","response::Parts","header::name::Repr","extensions::Extensions","header::value::ToStrError","byte_str::ByteStr","uri::scheme::Scheme2","uri::builder::Builder","status::StatusCode","header::map::HeaderMap","header::map::Keys","header::map::Bucket","request::Parts","header::map::Values","header::map::Iter","method::InvalidMethod","uri::InvalidUriParts","request::Builder","header::map::ValuesMut","uri::InvalidUri","status::InvalidStatusCode","header::name::HdrName","header::name::MaybeLower","header::map::Entry","header::map::ValueIterMut","response::Response","uri::Uri","header::map::ValueIter","header::map::IntoIter"]},"header::map::Bucket":{"T":["header::map::Cursor","header::map::ExtraValue","header::map::HashValue","uri::authority::Authority","<&mut T as std::fmt::Debug>","uri::scheme::Scheme","header::map::Link","uri::scheme::Scheme2","uri::path::PathAndQuery","header::name::Repr","header::map::Bucket","header::map::HeaderMap","method::Method","header::name::StandardHeader","header::map::Links","header::map::RawLinks","header::name::MaybeLower","header::value::HeaderValue","uri::Uri","header::name::HeaderName","status::StatusCode","header::name::Custom","uri::scheme::Protocol","version::Version","byte_str::ByteStr"]},"header::map::Drain":{"T":["<*const T as std::fmt::Debug>","header::map::Iter","header::map::ValueIterMut","header::map::Drain","header::map::IterMut","header::map::ValueDrain"]},"header::map::Entry":{"T":["uri::InvalidUriParts","version::Version","header::name::InvalidHeaderName","method::Method","header::map::Entry","status::StatusCode","header::value::ToStrError","response::Response","header::map::Drain","header::map::Cursor","<*mut T as std::fmt::Debug>","header::map::GetAll","header::map::Links","uri::ErrorKind","header::name::MaybeLower","uri::path::PathAndQuery","header::map::ValueIter","header::map::ValueIterMut","header::name::HdrName","header::map::Iter","header::map::ValueDrain","method::InvalidMethod","header::name::StandardHeader","request::Request","header::value::HeaderValue","response::Builder","header::map::Values","header::name::Custom","header::map::ValuesMut","header::map::Keys","request::Builder","header::map::IntoIter","uri::builder::Builder","header::map::VacantEntry","uri::scheme::Scheme2","header::map::Bucket","status::InvalidStatusCode","header::map::OccupiedEntry","header::map::HashValue","response::Parts","extensions::Extensions","header::map::ExtraValue","error::Error","header::map::Link","uri::port::Port","header::map::HeaderMap","header::map::RawLinks","uri::InvalidUri","request::Parts","header::map::IterMut","byte_str::ByteStr","header::name::Repr","uri::Parts","uri::authority::Authority","header::value::InvalidHeaderValue","uri::scheme::Protocol","uri::scheme::Scheme","header::name::HeaderName","uri::Uri"]},"header::map::ExtraValue":{"T":["header::map::HashValue","header::map::HeaderMap","header::name::MaybeLower","header::map::Cursor","header::map::Link","uri::scheme::Scheme2","uri::Uri","uri::authority::Authority","byte_str::ByteStr","status::StatusCode","std::clone::impls::<impl std::clone::Clone for &T>","uri::scheme::Protocol","uri::scheme::Scheme","header::value::HeaderValue","header::map::Bucket","method::Method","version::Version","header::map::ExtraValue","header::name::Custom","header::name::Repr","uri::path::PathAndQuery","header::map::Links","header::name::StandardHeader","header::map::RawLinks","header::name::HeaderName"]},"header::map::GetAll":{"T":["header::name::Repr","version::Version","header::map::Cursor","header::map::HashValue","header::map::GetAll","header::map::HeaderMap","header::name::Custom","byte_str::ByteStr","header::map::Link","header::name::StandardHeader","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","uri::ErrorKind"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["byte_str::ByteStr","header::map::Keys","header::name::HdrName","header::name::HeaderName","uri::scheme::Protocol","uri::scheme::Scheme2","header::map::HashValue","header::map::ValuesMut","header::map::RawLinks","uri::path::PathAndQuery","<*const T as std::fmt::Debug>","response::Builder","header::map::Drain","header::map::IntoIter","header::map::GetAll","header::map::HeaderMap","header::map::Link","uri::Parts","header::name::StandardHeader","uri::port::Port","method::InvalidMethod","uri::ErrorKind","uri::Uri","header::map::Entry","request::Parts","response::Parts","version::Version","uri::authority::Authority","header::map::IterMut","header::name::MaybeLower","header::map::ValueIter","header::map::OccupiedEntry","extensions::Extensions","header::map::Iter","status::InvalidStatusCode","response::Response","header::map::Cursor","status::StatusCode","header::name::Repr","header::value::HeaderValue","uri::scheme::Scheme","uri::builder::Builder","header::map::ExtraValue","header::name::InvalidHeaderName","header::map::Links","request::Builder","header::map::Values","error::Error","method::Method","uri::InvalidUri","uri::InvalidUriParts","header::value::ToStrError","header::name::Custom","request::Request","header::map::Bucket","header::map::VacantEntry","header::map::ValueIterMut","header::map::ValueDrain","header::value::InvalidHeaderValue"]},"header::map::Iter":{"T":["<*const T as std::fmt::Debug>","header::map::Iter","header::map::IterMut","header::map::ValueIterMut","header::map::ValueDrain","header::map::Drain"]},"header::map::IterMut":{"T":["<*mut T as std::marker::Send>","header::map::Drain","header::map::ValueDrain","header::map::Iter","header::map::ValueIterMut","header::map::IterMut"]},"header::map::Keys":{"T":["header::map::Links","uri::ErrorKind","header::map::Link","uri::InvalidUri","header::map::Cursor","uri::authority::Authority","status::InvalidStatusCode","header::map::ValueIterMut","header::value::HeaderValue","header::name::Custom","response::Builder","uri::scheme::Scheme2","<&T as std::fmt::Debug>","header::map::RawLinks","header::name::MaybeLower","uri::InvalidUriParts","response::Response","method::Method","header::map::ValuesMut","request::Request","header::map::ExtraValue","status::StatusCode","header::map::Iter","uri::Uri","uri::scheme::Protocol","header::value::InvalidHeaderValue","header::map::IterMut","header::name::HeaderName","response::Parts","header::map::VacantEntry","request::Parts","header::map::HeaderMap","header::name::HdrName","header::map::Keys","header::map::ValueIter","header::map::GetAll","header::map::Bucket","header::name::InvalidHeaderName","header::map::Drain","uri::path::PathAndQuery","uri::Parts","version::Version","uri::port::Port","header::map::HashValue","method::InvalidMethod","header::map::ValueDrain","extensions::Extensions","header::map::Values","header::name::StandardHeader","error::Error","header::map::OccupiedEntry","header::map::Entry","header::value::ToStrError","uri::scheme::Scheme","header::name::Repr","byte_str::ByteStr","uri::builder::Builder","header::map::IntoIter","request::Builder"]},"header::map::OccupiedEntry":{"T":["byte_str::ByteStr","header::map::Drain","uri::builder::Builder","header::name::Repr","header::value::InvalidHeaderValue","header::map::ValuesMut","header::map::Links","uri::InvalidUriParts","status::InvalidStatusCode","method::Method","header::map::ValueIter","header::map::Bucket","uri::InvalidUri","header::map::ValueIterMut","extensions::Extensions","header::value::ToStrError","uri::scheme::Scheme","header::map::ValueDrain","header::name::HdrName","response::Parts","request::Builder","header::map::Entry","request::Request","error::Error","method::InvalidMethod","header::map::GetAll","header::map::IntoIter","status::StatusCode","header::map::Keys","header::map::RawLinks","header::name::InvalidHeaderName","uri::port::Port","uri::Parts","header::name::HeaderName","uri::scheme::Scheme2","header::map::Iter","response::Builder","version::Version","uri::path::PathAndQuery","header::value::HeaderValue","<*const T as std::fmt::Debug>","uri::scheme::Protocol","header::map::IterMut","header::name::MaybeLower","header::map::Cursor","header::map::HeaderMap","header::map::HashValue","header::name::Custom","request::Parts","header::name::StandardHeader","header::map::Values","uri::Uri","uri::ErrorKind","header::map::OccupiedEntry","response::Response","header::map::Link","header::map::ExtraValue","uri::authority::Authority","header::map::VacantEntry"]},"header::map::RawLinks":{"T":["header::map::IntoIter","uri::Uri","header::map::Iter","header::map::Values","header::map::HeaderMap","header::map::Link","header::value::ToStrError","uri::port::Port","header::map::ValueDrain","header::name::HdrName","uri::scheme::Protocol","uri::authority::Authority","header::value::HeaderValue","response::Builder","header::name::InvalidHeaderName","uri::Parts","header::map::RawLinks","error::Error","header::map::GetAll","extensions::Extensions","header::name::HeaderName","uri::scheme::Scheme2","header::map::HashValue","header::map::Drain","header::name::Repr","header::name::Custom","<&T as std::fmt::Debug>","header::map::ExtraValue","header::name::MaybeLower","uri::builder::Builder","method::Method","uri::path::PathAndQuery","header::value::InvalidHeaderValue","header::map::Entry","header::map::VacantEntry","uri::InvalidUri","header::map::OccupiedEntry","uri::ErrorKind","request::Request","header::map::Keys","status::InvalidStatusCode","header::map::ValueIter","header::map::ValuesMut","version::Version","response::Parts","uri::scheme::Scheme","response::Response","status::StatusCode","request::Builder","method::InvalidMethod","header::map::ValueIterMut","header::map::Bucket","header::map::IterMut","header::name::StandardHeader","header::map::Links","header::map::Cursor","request::Parts","uri::InvalidUriParts","byte_str::ByteStr"]},"header::map::VacantEntry":{"T":["header::map::ValuesMut","uri::scheme::Scheme2","byte_str::ByteStr","uri::scheme::Protocol","request::Parts","header::map::ExtraValue","header::map::Drain","header::name::HdrName","header::value::HeaderValue","header::map::Cursor","uri::Uri","header::value::ToStrError","uri::scheme::Scheme","header::name::HeaderName","request::Builder","response::Parts","uri::InvalidUriParts","header::map::HashValue","uri::InvalidUri","uri::Parts","uri::ErrorKind","header::value::InvalidHeaderValue","header::name::Custom","header::map::VacantEntry","response::Builder","header::map::GetAll","request::Request","method::Method","header::name::Repr","response::Response","header::map::Values","header::map::Keys","uri::port::Port","header::map::ValueIter","header::map::ValueDrain","header::map::IntoIter","header::map::HeaderMap","extensions::Extensions","status::StatusCode","version::Version","header::map::ValueIterMut","status::InvalidStatusCode","header::name::MaybeLower","uri::builder::Builder","header::map::IterMut","method::InvalidMethod","uri::authority::Authority","header::map::OccupiedEntry","header::map::RawLinks","header::name::StandardHeader","header::map::Entry","header::map::Link","header::map::Bucket","<*mut T as std::fmt::Debug>","header::map::Links","header::map::Iter","uri::path::PathAndQuery","header::name::InvalidHeaderName","error::Error"]},"header::map::ValueDrain":{"T":["header::map::ValueIterMut","header::map::Drain","<*mut T as std::fmt::Debug>","header::map::Iter","header::map::ValueDrain","header::map::IterMut"]},"header::map::ValueIter":{"T":["response::Builder","request::Builder","<*const T as std::fmt::Debug>","header::map::ExtraValue","uri::InvalidUriParts","header::map::ValueDrain","status::InvalidStatusCode","uri::authority::Authority","uri::Parts","header::map::Values","uri::scheme::Scheme","uri::InvalidUri","header::map::ValueIter","uri::ErrorKind","header::map::Cursor","header::map::Keys","header::map::VacantEntry","header::value::InvalidHeaderValue","uri::Uri","header::map::Link","header::map::ValuesMut","header::map::IntoIter","header::map::Bucket","uri::scheme::Protocol","status::StatusCode","header::map::Entry","response::Response","header::map::ValueIterMut","header::map::HeaderMap","uri::port::Port","request::Request","header::name::Repr","header::map::OccupiedEntry","request::Parts","header::name::MaybeLower","method::Method","header::name::Custom","error::Error","header::value::HeaderValue","uri::path::PathAndQuery","extensions::Extensions","uri::scheme::Scheme2","method::InvalidMethod","header::name::StandardHeader","byte_str::ByteStr","header::map::Links","header::map::GetAll","header::name::InvalidHeaderName","header::name::HeaderName","version::Version","header::map::Drain","header::map::Iter","header::map::IterMut","header::map::RawLinks","response::Parts","uri::builder::Builder","header::value::ToStrError","header::name::HdrName","header::map::HashValue"]},"header::map::ValueIterMut":{"T":["<*mut T as std::fmt::Debug>","header::map::ValueIterMut","header::map::Drain","header::map::Iter","header::map::IterMut","header::map::ValueDrain"]},"header::map::Values":{"T":["method::Method","uri::Uri","uri::scheme::Scheme2","header::map::ValueDrain","header::map::IntoIter","header::value::HeaderValue","header::map::Links","uri::scheme::Scheme","header::name::HeaderName","uri::InvalidUriParts","extensions::Extensions","header::name::MaybeLower","header::map::GetAll","header::map::Entry","header::map::Drain","response::Parts","header::map::Keys","response::Response","uri::ErrorKind","header::map::IterMut","uri::Parts","header::name::Repr","header::value::ToStrError","uri::port::Port","request::Request","header::map::RawLinks","uri::path::PathAndQuery","<*const T as std::fmt::Debug>","header::map::ValuesMut","header::map::ValueIter","header::name::InvalidHeaderName","header::map::VacantEntry","header::map::Values","header::map::Bucket","uri::authority::Authority","header::map::OccupiedEntry","header::name::StandardHeader","status::InvalidStatusCode","header::map::HashValue","header::map::ValueIterMut","header::map::Iter","uri::scheme::Protocol","version::Version","response::Builder","method::InvalidMethod","error::Error","uri::InvalidUri","header::value::InvalidHeaderValue","header::name::Custom","header::name::HdrName","request::Parts","byte_str::ByteStr","request::Builder","header::map::ExtraValue","header::map::Link","uri::builder::Builder","header::map::Cursor","status::StatusCode","header::map::HeaderMap"]},"header::map::ValuesMut":{"T":["header::name::StandardHeader","header::map::ExtraValue","header::name::InvalidHeaderName","uri::scheme::Scheme2","header::map::Link","request::Builder","header::map::ValueIter","uri::InvalidUri","header::value::InvalidHeaderValue","uri::authority::Authority","header::name::HdrName","header::map::Links","header::map::Bucket","header::map::RawLinks","request::Parts","header::name::Repr","<&T as std::fmt::Debug>","byte_str::ByteStr","extensions::Extensions","error::Error","version::Version","header::map::IterMut","response::Response","header::map::ValueDrain","header::map::OccupiedEntry","header::name::MaybeLower","uri::builder::Builder","request::Request","header::name::HeaderName","header::map::HeaderMap","header::map::Values","header::map::Entry","response::Builder","method::InvalidMethod","response::Parts","header::name::Custom","uri::ErrorKind","header::map::Drain","header::map::IntoIter","method::Method","uri::Uri","uri::InvalidUriParts","header::map::ValuesMut","header::map::HashValue","status::InvalidStatusCode","header::map::VacantEntry","header::map::Iter","header::map::ValueIterMut","header::value::HeaderValue","status::StatusCode","header::value::ToStrError","header::map::Cursor","uri::scheme::Scheme","uri::Parts","header::map::Keys","uri::path::PathAndQuery","uri::port::Port","header::map::GetAll","uri::scheme::Protocol"]},"header::name::Repr":{"T":["header::name::StandardHeader","header::name::Repr","header::name::Custom","<*mut T as std::fmt::Debug>","version::Version","byte_str::ByteStr"]},"request::Request":{"T":["uri::Parts","request::Request","method::Method","response::Builder","request::Builder","header::map::HeaderMap","version::Version","extensions::Extensions","uri::builder::Builder","response::Response","uri::Uri","status::StatusCode"]},"response::Response":{"T":["response::Response","version::Version","uri::Parts","method::Method","request::Request","uri::Uri","status::StatusCode","request::Builder","extensions::Extensions","response::Builder","header::map::HeaderMap","uri::builder::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"uri::port::Port":{"T":["method::Method","uri::port::Port","<&mut T as std::convert::AsRef<U>>","uri::scheme::Scheme","header::value::HeaderValue","uri::authority::Authority"]},"uri::scheme::Scheme2":{"T":["header::map::Link","header::map::ExtraValue","header::map::Bucket","header::map::Cursor","header::map::HashValue","header::name::Custom","uri::path::PathAndQuery","header::map::HeaderMap","header::name::MaybeLower","std::boxed::Box<byte_str::ByteStr>","header::map::RawLinks","uri::Uri","header::name::Repr","<*mut T as std::fmt::Debug>","header::name::HeaderName","uri::scheme::Scheme2","uri::scheme::Scheme","version::Version","status::StatusCode","uri::authority::Authority","uri::scheme::Protocol","header::name::StandardHeader","byte_str::ByteStr","method::Method","header::map::Links","header::value::HeaderValue"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::ExtraValue<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::ExtraValue<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::ExtraValue<T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::ExtraValue<T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::ExtraValue<T> as std::clone::Clone>::clone
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ExtraValue<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"header::map::Drain":{"T":["std::marker::Sync","std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::convert::TryFrom","std::cmp::Eq","std::fmt::Debug"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::marker::Send","std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Send","std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::fmt::Debug","std::clone::Clone","std::hash::Hash","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::fmt::Debug","std::default::Default","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::fmt::Debug","std::marker::Sized","std::convert::AsRef"]},"uri::scheme::Scheme2":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::map::ExtraValue<T> as std::clone::Clone>::clone":{"T":["method::extension::InlineExtension","header::map::Links","method::Inner","header::map::Danger","header::name::StandardHeader","header::map::ExtraValue","header::name::MaybeLower","std::clone::impls::<impl std::clone::Clone for &mut T>","uri::authority::Authority","uri::Uri","header::value::HeaderValue","header::map::Pos","header::map::HeaderMap","header::name::Repr","uri::scheme::Scheme","header::map::Link","header::map::Bucket","uri::path::PathAndQuery","header::map::HashValue","version::Http","uri::scheme::Protocol","header::name::Custom","uri::scheme::Scheme2","header::map::RawLinks","header::name::HeaderName","method::Method","byte_str::ByteStr","version::Version","header::map::Cursor","std::clone::impls::<impl std::clone::Clone for *const T>","method::extension::AllocatedExtension","status::StatusCode"]},"header::map::Bucket":{"T":["header::name::StandardHeader","status::StatusCode","uri::authority::Authority","header::value::HeaderValue","byte_str::ByteStr","std::clone::impls::<impl std::clone::Clone for &mut T>","method::Method","header::map::Cursor","header::map::RawLinks","header::map::ExtraValue","version::Version","header::name::HeaderName","header::map::Link","uri::scheme::Scheme","header::map::Bucket","header::map::HeaderMap","uri::path::PathAndQuery","uri::Uri","uri::scheme::Protocol","header::map::Links","uri::scheme::Scheme2","header::name::Repr","header::name::Custom","header::map::HashValue","header::name::MaybeLower"]},"header::map::Drain":{"T":["header::map::ValueIterMut","header::map::ValueDrain","header::map::Iter","header::map::IterMut","<*mut T as std::fmt::Debug>","header::map::Drain"]},"header::map::Entry":{"T":["header::map::Link","header::map::Values","byte_str::ByteStr","response::Parts","header::name::StandardHeader","header::map::Keys","uri::builder::Builder","error::Error","header::map::Cursor","uri::scheme::Scheme2","header::map::HeaderMap","header::name::Custom","request::Parts","uri::Uri","method::Method","header::map::IntoIter","header::name::Repr","uri::scheme::Protocol","status::StatusCode","<*mut T as std::fmt::Debug>","request::Request","header::map::IterMut","header::value::HeaderValue","response::Builder","uri::InvalidUriParts","header::map::Bucket","header::map::GetAll","uri::authority::Authority","response::Response","extensions::Extensions","method::InvalidMethod","header::map::ExtraValue","uri::port::Port","header::map::RawLinks","header::name::MaybeLower","header::name::HdrName","uri::InvalidUri","header::map::HashValue","status::InvalidStatusCode","header::map::Drain","header::map::ValueIterMut","request::Builder","uri::path::PathAndQuery","uri::scheme::Scheme","header::value::ToStrError","header::map::ValueDrain","header::map::Links","header::value::InvalidHeaderValue","header::map::Entry","header::map::Iter","uri::Parts","header::map::VacantEntry","header::name::HeaderName","header::name::InvalidHeaderName","uri::ErrorKind","version::Version","header::map::ValueIter","header::map::ValuesMut","header::map::OccupiedEntry"]},"header::map::ExtraValue":{"T":["header::map::Cursor","uri::authority::Authority","header::name::StandardHeader","uri::Uri","header::map::Link","header::name::MaybeLower","header::name::Custom","byte_str::ByteStr","header::map::Links","status::StatusCode","std::clone::impls::<impl std::clone::Clone for *mut T>","header::map::RawLinks","version::Version","header::value::HeaderValue","header::map::ExtraValue","header::name::Repr","header::map::HashValue","header::map::HeaderMap","uri::scheme::Scheme2","uri::path::PathAndQuery","uri::scheme::Scheme","uri::scheme::Protocol","method::Method","header::map::Bucket","header::name::HeaderName"]},"header::map::GetAll":{"T":["header::name::StandardHeader","header::map::Link","header::name::Repr","byte_str::ByteStr","version::Version","header::map::HeaderMap","header::map::GetAll","header::map::HashValue","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","uri::ErrorKind","header::name::Custom","header::map::Cursor"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["request::Parts","header::map::ValuesMut","header::map::Keys","header::map::ValueIterMut","response::Response","header::map::Links","header::name::StandardHeader","header::value::ToStrError","header::value::InvalidHeaderValue","header::map::Link","response::Parts","uri::port::Port","error::Error","header::map::HashValue","uri::authority::Authority","header::name::Repr","header::map::Iter","header::map::GetAll","status::InvalidStatusCode","uri::Parts","header::map::IntoIter","extensions::Extensions","header::map::ExtraValue","header::map::RawLinks","header::map::OccupiedEntry","header::map::VacantEntry","header::map::HeaderMap","uri::scheme::Protocol","method::Method","header::name::HdrName","uri::ErrorKind","header::map::Drain","<*mut T as std::fmt::Debug>","uri::InvalidUriParts","header::name::InvalidHeaderName","header::map::Bucket","uri::InvalidUri","uri::path::PathAndQuery","request::Request","header::map::Cursor","uri::builder::Builder","header::map::IterMut","response::Builder","header::value::HeaderValue","header::map::Entry","byte_str::ByteStr","version::Version","request::Builder","header::name::MaybeLower","header::map::ValueIter","header::name::HeaderName","status::StatusCode","header::map::Values","uri::Uri","uri::scheme::Scheme","method::InvalidMethod","header::map::ValueDrain","uri::scheme::Scheme2","header::name::Custom"]},"header::map::Iter":{"T":["header::map::ValueDrain","header::map::Iter","<*const T as std::fmt::Debug>","header::map::IterMut","header::map::ValueIterMut","header::map::Drain"]},"header::map::IterMut":{"T":["header::map::Iter","header::map::IterMut","header::map::Drain","header::map::ValueDrain","header::map::ValueIterMut","<*const T as std::marker::Sync>"]},"header::map::Keys":{"T":["header::name::InvalidHeaderName","status::InvalidStatusCode","header::map::RawLinks","header::map::Drain","response::Parts","uri::Parts","header::map::VacantEntry","request::Parts","response::Response","header::map::IntoIter","header::value::ToStrError","header::map::HeaderMap","header::map::Link","header::map::ValueDrain","header::map::IterMut","header::map::Iter","header::map::ValueIter","header::map::Bucket","request::Builder","header::map::Keys","method::Method","header::map::ExtraValue","uri::ErrorKind","uri::authority::Authority","<*mut T as std::fmt::Debug>","request::Request","uri::builder::Builder","header::map::GetAll","response::Builder","header::name::HdrName","header::name::HeaderName","header::map::HashValue","byte_str::ByteStr","uri::Uri","version::Version","header::value::HeaderValue","uri::InvalidUri","header::value::InvalidHeaderValue","header::map::ValueIterMut","uri::InvalidUriParts","header::name::StandardHeader","uri::port::Port","header::map::Values","error::Error","uri::scheme::Scheme2","header::name::Repr","header::name::Custom","header::map::Entry","header::map::Links","status::StatusCode","uri::scheme::Scheme","uri::path::PathAndQuery","extensions::Extensions","header::name::MaybeLower","header::map::ValuesMut","method::InvalidMethod","header::map::Cursor","uri::scheme::Protocol","header::map::OccupiedEntry"]},"header::map::OccupiedEntry":{"T":["header::name::Repr","header::name::MaybeLower","uri::builder::Builder","header::map::Cursor","header::map::ValuesMut","header::map::ValueDrain","header::name::StandardHeader","<&mut T as std::fmt::Debug>","header::name::Custom","header::value::InvalidHeaderValue","header::map::OccupiedEntry","header::map::HashValue","uri::InvalidUri","header::map::Links","request::Parts","header::map::ValueIter","header::value::HeaderValue","method::InvalidMethod","response::Parts","header::map::ExtraValue","uri::scheme::Scheme2","header::name::HdrName","header::map::IterMut","header::map::Link","header::map::Iter","status::InvalidStatusCode","byte_str::ByteStr","header::map::VacantEntry","header::map::IntoIter","response::Builder","uri::ErrorKind","version::Version","uri::Uri","status::StatusCode","header::map::GetAll","response::Response","request::Request","header::name::InvalidHeaderName","uri::port::Port","uri::InvalidUriParts","uri::path::PathAndQuery","header::map::ValueIterMut","uri::Parts","error::Error","header::map::Drain","header::value::ToStrError","header::map::Values","header::map::Keys","method::Method","extensions::Extensions","header::name::HeaderName","request::Builder","header::map::Bucket","uri::authority::Authority","header::map::HeaderMap","uri::scheme::Scheme","uri::scheme::Protocol","header::map::RawLinks","header::map::Entry"]},"header::map::RawLinks":{"T":["uri::scheme::Protocol","header::name::HeaderName","header::map::IntoIter","byte_str::ByteStr","header::name::HdrName","header::map::ValueIter","uri::scheme::Scheme","header::map::IterMut","header::value::InvalidHeaderValue","header::map::Cursor","header::map::ValueIterMut","version::Version","status::InvalidStatusCode","header::value::ToStrError","response::Parts","uri::InvalidUriParts","method::Method","uri::path::PathAndQuery","uri::Uri","header::map::OccupiedEntry","method::InvalidMethod","request::Request","header::map::Link","header::map::ValuesMut","header::name::Repr","header::map::VacantEntry","header::name::MaybeLower","uri::scheme::Scheme2","header::map::RawLinks","header::name::Custom","header::map::Links","header::map::Keys","header::map::Entry","header::map::HashValue","extensions::Extensions","header::map::Iter","<*mut T as std::fmt::Debug>","uri::builder::Builder","header::map::Values","header::map::Drain","header::map::ValueDrain","header::map::HeaderMap","request::Builder","error::Error","uri::Parts","uri::ErrorKind","request::Parts","header::value::HeaderValue","status::StatusCode","response::Response","uri::InvalidUri","header::map::GetAll","uri::authority::Authority","header::name::StandardHeader","header::name::InvalidHeaderName","uri::port::Port","header::map::Bucket","header::map::ExtraValue","response::Builder"]},"header::map::VacantEntry":{"T":["method::Method","header::name::Repr","header::name::StandardHeader","uri::ErrorKind","header::map::HeaderMap","response::Parts","status::InvalidStatusCode","method::InvalidMethod","header::map::RawLinks","header::map::Iter","header::value::HeaderValue","header::map::ValuesMut","response::Response","header::map::ValueIter","header::map::Keys","status::StatusCode","uri::Parts","error::Error","header::map::IterMut","response::Builder","extensions::Extensions","header::map::Cursor","header::map::Link","header::map::Bucket","request::Builder","uri::port::Port","header::value::InvalidHeaderValue","version::Version","header::map::Drain","uri::builder::Builder","header::map::Values","uri::InvalidUri","uri::authority::Authority","header::name::HeaderName","header::name::HdrName","uri::Uri","header::name::Custom","header::value::ToStrError","request::Parts","header::map::IntoIter","header::map::ValueDrain","byte_str::ByteStr","uri::scheme::Scheme2","uri::InvalidUriParts","header::map::ValueIterMut","header::map::ExtraValue","request::Request","header::map::Links","header::map::GetAll","header::name::InvalidHeaderName","header::map::HashValue","header::map::VacantEntry","uri::path::PathAndQuery","header::map::Entry","header::map::OccupiedEntry","uri::scheme::Protocol","header::name::MaybeLower","<*const T as std::fmt::Debug>","uri::scheme::Scheme"]},"header::map::ValueDrain":{"T":["header::map::Iter","header::map::ValueDrain","header::map::IterMut","header::map::ValueIterMut","header::map::Drain","<*mut T as std::marker::Send>"]},"header::map::ValueIter":{"T":["uri::port::Port","header::name::StandardHeader","uri::scheme::Scheme","extensions::Extensions","uri::InvalidUriParts","header::map::Cursor","byte_str::ByteStr","header::name::HeaderName","method::Method","uri::builder::Builder","error::Error","header::value::HeaderValue","header::map::ValueIter","header::name::InvalidHeaderName","uri::path::PathAndQuery","method::InvalidMethod","request::Builder","uri::InvalidUri","header::map::RawLinks","status::InvalidStatusCode","header::value::InvalidHeaderValue","header::map::Iter","header::map::Values","header::value::ToStrError","header::map::Entry","response::Parts","response::Response","header::name::MaybeLower","header::map::GetAll","header::map::HeaderMap","header::name::Repr","header::map::ValuesMut","uri::Parts","header::map::ExtraValue","header::map::OccupiedEntry","header::map::ValueIterMut","header::map::VacantEntry","response::Builder","request::Request","header::map::Link","request::Parts","header::map::Bucket","header::map::Links","header::map::Drain","status::StatusCode","header::name::Custom","header::map::Keys","header::map::IntoIter","header::map::HashValue","uri::scheme::Protocol","header::map::ValueDrain","header::map::IterMut","uri::Uri","header::name::HdrName","uri::scheme::Scheme2","<&T as std::fmt::Debug>","version::Version","uri::authority::Authority","uri::ErrorKind"]},"header::map::ValueIterMut":{"T":["<*const T as std::fmt::Debug>","header::map::Iter","header::map::ValueDrain","header::map::ValueIterMut","header::map::Drain","header::map::IterMut"]},"header::map::Values":{"T":["request::Builder","uri::InvalidUri","uri::Uri","header::map::Links","header::name::HdrName","header::value::ToStrError","response::Builder","header::map::OccupiedEntry","version::Version","header::map::Entry","uri::ErrorKind","uri::builder::Builder","<&T as std::fmt::Debug>","header::name::InvalidHeaderName","header::map::Bucket","byte_str::ByteStr","header::value::InvalidHeaderValue","header::map::Keys","uri::path::PathAndQuery","header::map::Cursor","uri::port::Port","response::Parts","header::map::IterMut","uri::scheme::Scheme2","header::name::MaybeLower","method::Method","header::name::Custom","header::map::HeaderMap","uri::Parts","status::StatusCode","status::InvalidStatusCode","uri::authority::Authority","header::map::ValuesMut","error::Error","header::map::ValueIterMut","header::map::ExtraValue","extensions::Extensions","header::map::IntoIter","header::map::Drain","header::name::HeaderName","uri::InvalidUriParts","header::map::Link","header::map::Iter","header::map::ValueIter","header::map::ValueDrain","header::map::RawLinks","header::name::Repr","header::map::HashValue","header::map::Values","request::Request","header::name::StandardHeader","uri::scheme::Scheme","method::InvalidMethod","uri::scheme::Protocol","header::map::VacantEntry","header::value::HeaderValue","header::map::GetAll","request::Parts","response::Response"]},"header::map::ValuesMut":{"T":["header::map::HeaderMap","uri::InvalidUriParts","status::InvalidStatusCode","header::name::MaybeLower","response::Response","header::map::ValueIterMut","header::map::Drain","header::map::IntoIter","uri::path::PathAndQuery","method::Method","header::map::HashValue","uri::Parts","header::map::Links","header::map::ExtraValue","header::map::Entry","uri::scheme::Scheme","byte_str::ByteStr","header::map::ValuesMut","header::name::InvalidHeaderName","header::name::HdrName","uri::ErrorKind","extensions::Extensions","header::map::OccupiedEntry","header::map::RawLinks","method::InvalidMethod","uri::builder::Builder","<*const T as std::fmt::Debug>","header::value::HeaderValue","uri::authority::Authority","response::Parts","header::name::Custom","header::map::Cursor","header::map::Iter","uri::scheme::Protocol","status::StatusCode","header::map::IterMut","header::name::Repr","header::value::InvalidHeaderValue","header::name::StandardHeader","header::value::ToStrError","header::map::Bucket","header::map::Values","error::Error","uri::Uri","header::map::Link","header::map::Keys","header::map::VacantEntry","version::Version","uri::port::Port","header::map::ValueDrain","request::Request","uri::scheme::Scheme2","request::Builder","header::map::GetAll","uri::InvalidUri","request::Parts","response::Builder","header::name::HeaderName","header::map::ValueIter"]},"header::name::Repr":{"T":["header::name::Custom","<*const T as std::fmt::Debug>","byte_str::ByteStr","header::name::Repr","header::name::StandardHeader","version::Version"]},"request::Request":{"T":["request::Builder","header::map::HeaderMap","extensions::Extensions","uri::Uri","uri::builder::Builder","request::Request","method::Method","version::Version","uri::Parts","response::Response","response::Builder","status::StatusCode"]},"response::Response":{"T":["header::map::HeaderMap","extensions::Extensions","method::Method","response::Builder","status::StatusCode","response::Response","version::Version","request::Builder","uri::builder::Builder","request::Request","uri::Uri","uri::Parts"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["uri::scheme::Scheme","method::Method","uri::port::Port","uri::authority::Authority","<&T as std::convert::AsRef<U>>","header::value::HeaderValue"]},"uri::scheme::Scheme2":{"T":["uri::scheme::Scheme2","header::name::Repr","header::map::Bucket","header::name::StandardHeader","header::map::HashValue","byte_str::ByteStr","header::map::RawLinks","uri::scheme::Scheme","header::map::Cursor","header::map::Links","header::value::HeaderValue","uri::scheme::Protocol","uri::Uri","uri::path::PathAndQuery","uri::authority::Authority","header::name::Custom","header::name::HeaderName","header::map::Link","version::Version","std::clone::impls::<impl std::clone::Clone for *const T>","header::map::ExtraValue","status::StatusCode","header::name::MaybeLower","method::Method","header::map::HeaderMap","std::boxed::Box<byte_str::ByteStr>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::ExtraValue<T>
+p0.clone();
+<header::map::ExtraValue<T> as std::clone::Clone>::clone(p0);
+crate::<header::map::ExtraValue<T> as std::clone::Clone>::clone(p0);
+<header::map::ExtraValue<T>>::clone(p0);
-----------------
src/header/map.rs <header::map::Link as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Link
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::Link as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::Link as std::fmt::Debug>::fmt(p0, p1);
+<header::map::Link>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::Link as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Link
+p0.clone();
+<header::map::Link as std::clone::Clone>::clone(p0);
+crate::<header::map::Link as std::clone::Clone>::clone(p0);
+<header::map::Link>::clone(p0);
-----------------
src/header/map.rs <header::map::Link as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Link
+p0.assert_receiver_is_total_eq();
+<header::map::Link as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<header::map::Link as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<header::map::Link>::assert_receiver_is_total_eq(p0);
-----------------
src/header/map.rs <header::map::Link as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Link
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::Link
+p0.eq(p1);
+<header::map::Link as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::map::Link as std::cmp::PartialEq>::eq(p0, p1);
+<header::map::Link>::eq(p0, p1);
-----------------
src/header/map.rs <header::map::Danger as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Danger
+p0.clone();
+<header::map::Danger as std::clone::Clone>::clone(p0);
+crate::<header::map::Danger as std::clone::Clone>::clone(p0);
+<header::map::Danger>::clone(p0);
-----------------
src/header/map.rs header::map::HeaderMap::new
deps:{}
candidates:{}
+header::map::HeaderMap::new();
+crate::header::map::HeaderMap::new();
+<header::map::HeaderMap>::new();
-----------------
src/header/map.rs header::map::HeaderMap::<T>::with_capacity
deps:{"header::map::HeaderMap::<T>::with_capacity":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::with_capacity":{"T":["RUG_ANY"]}}
let mut p0 = 0usize; // None+usize
+header::map::HeaderMap::<T>::with_capacity(p0);
+crate::header::map::HeaderMap::<T>::with_capacity(p0);
+<header::map::HeaderMap<T>>::with_capacity(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::len
deps:{"header::map::HeaderMap::<T>::len":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::len":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.len();
+header::map::HeaderMap::<T>::len(p0);
+crate::header::map::HeaderMap::<T>::len(p0);
+<header::map::HeaderMap<T>>::len(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::keys_len
deps:{"header::map::HeaderMap::<T>::keys_len":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::keys_len":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.keys_len();
+header::map::HeaderMap::<T>::keys_len(p0);
+crate::header::map::HeaderMap::<T>::keys_len(p0);
+<header::map::HeaderMap<T>>::keys_len(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::is_empty
deps:{"header::map::HeaderMap::<T>::is_empty":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::is_empty":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.is_empty();
+header::map::HeaderMap::<T>::is_empty(p0);
+crate::header::map::HeaderMap::<T>::is_empty(p0);
+<header::map::HeaderMap<T>>::is_empty(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::clear
deps:{"header::map::HeaderMap::<T>::clear":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::clear":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.clear();
+header::map::HeaderMap::<T>::clear(p0);
+crate::header::map::HeaderMap::<T>::clear(p0);
+<header::map::HeaderMap<T>>::clear(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::capacity
deps:{"header::map::HeaderMap::<T>::capacity":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::capacity":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.capacity();
+header::map::HeaderMap::<T>::capacity(p0);
+crate::header::map::HeaderMap::<T>::capacity(p0);
+<header::map::HeaderMap<T>>::capacity(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::reserve
deps:{"header::map::HeaderMap::<T>::reserve":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::reserve":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = 0usize; // None+usize
+p0.reserve(p1);
+header::map::HeaderMap::<T>::reserve(p0, p1);
+crate::header::map::HeaderMap::<T>::reserve(p0, p1);
+<header::map::HeaderMap<T>>::reserve(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::get
deps:{"header::map::HeaderMap::<T>::get":{"K":["header::map::as_header_name::AsHeaderName","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::get":{"K":["std::string::String","header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.get(p1);
+header::map::HeaderMap::<T>::get(p0, p1);
+crate::header::map::HeaderMap::<T>::get(p0, p1);
+<header::map::HeaderMap<T>>::get(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::get2
deps:{"header::map::HeaderMap::<T>::get2":{"K":["std::marker::Sized","header::map::as_header_name::AsHeaderName"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::get2":{"K":["header::name::HeaderName","std::string::String"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // K
+p0.get2(p1);
+header::map::HeaderMap::<T>::get2(p0, p1);
+crate::header::map::HeaderMap::<T>::get2(p0, p1);
+<header::map::HeaderMap<T>>::get2(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::get_mut
deps:{"header::map::HeaderMap::<T>::get_mut":{"K":["std::marker::Sized","header::map::as_header_name::AsHeaderName"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::get_mut":{"K":["std::string::String","header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.get_mut(p1);
+header::map::HeaderMap::<T>::get_mut(p0, p1);
+crate::header::map::HeaderMap::<T>::get_mut(p0, p1);
+<header::map::HeaderMap<T>>::get_mut(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::get_all
deps:{"header::map::HeaderMap::<T>::get_all":{"K":["header::map::as_header_name::AsHeaderName","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::get_all":{"K":["std::string::String","header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.get_all(p1);
+header::map::HeaderMap::<T>::get_all(p0, p1);
+crate::header::map::HeaderMap::<T>::get_all(p0, p1);
+<header::map::HeaderMap<T>>::get_all(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::contains_key
deps:{"header::map::HeaderMap::<T>::contains_key":{"K":["header::map::as_header_name::AsHeaderName","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::contains_key":{"K":["header::name::HeaderName","std::string::String"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.contains_key(p1);
+header::map::HeaderMap::<T>::contains_key(p0, p1);
+crate::header::map::HeaderMap::<T>::contains_key(p0, p1);
+<header::map::HeaderMap<T>>::contains_key(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::iter
deps:{"header::map::HeaderMap::<T>::iter":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.iter();
+header::map::HeaderMap::<T>::iter(p0);
+crate::header::map::HeaderMap::<T>::iter(p0);
+<header::map::HeaderMap<T>>::iter(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::iter_mut
deps:{"header::map::HeaderMap::<T>::iter_mut":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::iter_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.iter_mut();
+header::map::HeaderMap::<T>::iter_mut(p0);
+crate::header::map::HeaderMap::<T>::iter_mut(p0);
+<header::map::HeaderMap<T>>::iter_mut(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::keys
deps:{"header::map::HeaderMap::<T>::keys":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::keys":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.keys();
+header::map::HeaderMap::<T>::keys(p0);
+crate::header::map::HeaderMap::<T>::keys(p0);
+<header::map::HeaderMap<T>>::keys(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::values
deps:{"header::map::HeaderMap::<T>::values":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::values":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.values();
+header::map::HeaderMap::<T>::values(p0);
+crate::header::map::HeaderMap::<T>::values(p0);
+<header::map::HeaderMap<T>>::values(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::values_mut
deps:{"header::map::HeaderMap::<T>::values_mut":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::values_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.values_mut();
+header::map::HeaderMap::<T>::values_mut(p0);
+crate::header::map::HeaderMap::<T>::values_mut(p0);
+<header::map::HeaderMap<T>>::values_mut(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::drain
deps:{"header::map::HeaderMap::<T>::drain":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::drain":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.drain();
+header::map::HeaderMap::<T>::drain(p0);
+crate::header::map::HeaderMap::<T>::drain(p0);
+<header::map::HeaderMap<T>>::drain(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::value_iter
deps:{"header::map::HeaderMap::<T>::value_iter":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::value_iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.value_iter(p1);
+header::map::HeaderMap::<T>::value_iter(p0, p1);
+crate::header::map::HeaderMap::<T>::value_iter(p0, p1);
+<header::map::HeaderMap<T>>::value_iter(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::value_iter_mut
deps:{"header::map::HeaderMap::<T>::value_iter_mut":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::value_iter_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = 0usize; // None+usize
+p0.value_iter_mut(p1);
+header::map::HeaderMap::<T>::value_iter_mut(p0, p1);
+crate::header::map::HeaderMap::<T>::value_iter_mut(p0, p1);
+<header::map::HeaderMap<T>>::value_iter_mut(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::entry
deps:{"header::map::HeaderMap::<T>::entry":{"K":["std::marker::Sized","header::map::into_header_name::IntoHeaderName"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::entry":{"K":["header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.entry(p1);
+header::map::HeaderMap::<T>::entry(p0, p1);
+crate::header::map::HeaderMap::<T>::entry(p0, p1);
+<header::map::HeaderMap<T>>::entry(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::try_entry
deps:{"header::map::HeaderMap::<T>::try_entry":{"K":["header::map::as_header_name::AsHeaderName","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::try_entry":{"K":["header::name::HeaderName","std::string::String"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.try_entry(p1);
+header::map::HeaderMap::<T>::try_entry(p0, p1);
+crate::header::map::HeaderMap::<T>::try_entry(p0, p1);
+<header::map::HeaderMap<T>>::try_entry(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::entry2
deps:{"<*mut T as std::fmt::Debug>":{},"header::map::GetAll":{"T":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::convert::TryFrom","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap::<T>::entry2":{"K":["std::marker::Sized","std::hash::Hash","std::convert::Into"],"T":["std::marker::Sized"],"header::name::HeaderName":["std::cmp::PartialEq"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::hash::Hash","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"header::map::GetAll":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","header::name::Custom","header::map::Cursor","header::map::GetAll","byte_str::ByteStr","header::name::Repr","header::map::Link","header::map::HeaderMap","version::Version","header::map::HashValue","uri::ErrorKind","header::name::StandardHeader"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::HeaderMap::<T>::entry2":{"K":["gimli::read::endian_slice::EndianSlice<'input, Endian>"],"T":["RUG_ANY"],"header::name::HeaderName":["header::name::StandardHeader","header::name::Custom","header::map::Link","header::map::Cursor","version::Http","header::map::HeaderMap","header::name::Repr","header::map::HashValue","uri::ErrorKind","version::Version","method::extension::InlineExtension","byte_str::ByteStr","method::extension::AllocatedExtension","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::map::GetAll","method::Inner"]},"header::name::Repr":{"T":["version::Version","<*mut T as std::fmt::Debug>","header::name::Repr","byte_str::ByteStr","header::name::Custom","header::name::StandardHeader"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.entry2(p1);
+header::map::HeaderMap::<T>::entry2(p0, p1);
+crate::header::map::HeaderMap::<T>::entry2(p0, p1);
+<header::map::HeaderMap<T>>::entry2(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::insert
deps:{"header::map::HeaderMap::<T>::insert":{"K":["std::marker::Sized","header::map::into_header_name::IntoHeaderName"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::insert":{"K":["header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1, p2);
+header::map::HeaderMap::<T>::insert(p0, p1, p2);
+crate::header::map::HeaderMap::<T>::insert(p0, p1, p2);
+<header::map::HeaderMap<T>>::insert(p0, p1, p2);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::insert2
deps:{"<*const T as std::fmt::Debug>":{},"header::map::GetAll":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::convert::TryFrom","std::cmp::PartialEq"]},"header::map::HeaderMap::<T>::insert2":{"K":["std::hash::Hash","std::convert::Into","std::marker::Sized"],"T":["std::marker::Sized"],"header::name::HeaderName":["std::cmp::PartialEq"]},"header::name::Repr":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::hash::Hash","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"header::map::GetAll":{"T":["header::map::HeaderMap","header::name::Repr","header::map::HashValue","header::name::StandardHeader","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::map::Cursor","version::Version","byte_str::ByteStr","header::map::Link","header::name::Custom","header::map::GetAll","uri::ErrorKind"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::HeaderMap::<T>::insert2":{"K":["gimli::read::endian_slice::EndianSlice<'input, Endian>"],"T":["RUG_ANY"],"header::name::HeaderName":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::name::Repr","header::name::StandardHeader","header::map::Cursor","version::Http","byte_str::ByteStr","uri::ErrorKind","header::map::HeaderMap","version::Version","header::name::Custom","method::Inner","header::map::GetAll","header::map::Link","header::map::HashValue","method::extension::AllocatedExtension","method::extension::InlineExtension"]},"header::name::Repr":{"T":["header::name::Custom","header::name::Repr","header::name::StandardHeader","std::clone::impls::<impl std::clone::Clone for *const T>","version::Version","byte_str::ByteStr"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert2(p1, p2);
+header::map::HeaderMap::<T>::insert2(p0, p1, p2);
+crate::header::map::HeaderMap::<T>::insert2(p0, p1, p2);
+<header::map::HeaderMap<T>>::insert2(p0, p1, p2);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::insert_occupied
deps:{"header::map::HeaderMap::<T>::insert_occupied":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::insert_occupied":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert_occupied(p1, p2);
+header::map::HeaderMap::<T>::insert_occupied(p0, p1, p2);
+crate::header::map::HeaderMap::<T>::insert_occupied(p0, p1, p2);
+<header::map::HeaderMap<T>>::insert_occupied(p0, p1, p2);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::insert_occupied_mult
deps:{"header::map::HeaderMap::<T>::insert_occupied_mult":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::insert_occupied_mult":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert_occupied_mult(p1, p2);
+header::map::HeaderMap::<T>::insert_occupied_mult(p0, p1, p2);
+crate::header::map::HeaderMap::<T>::insert_occupied_mult(p0, p1, p2);
+<header::map::HeaderMap<T>>::insert_occupied_mult(p0, p1, p2);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::append
deps:{"header::map::HeaderMap::<T>::append":{"K":["std::marker::Sized","header::map::into_header_name::IntoHeaderName"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::append":{"K":["header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.append(p1, p2);
+header::map::HeaderMap::<T>::append(p0, p1, p2);
+crate::header::map::HeaderMap::<T>::append(p0, p1, p2);
+<header::map::HeaderMap<T>>::append(p0, p1, p2);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::append2
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::convert::TryFrom","std::cmp::PartialEq","std::cmp::Eq"]},"header::map::HeaderMap::<T>::append2":{"K":["std::hash::Hash","std::convert::Into","std::marker::Sized"],"T":["std::marker::Sized"],"header::name::HeaderName":["std::cmp::PartialEq"]},"header::name::Repr":{"T":["std::hash::Hash","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"header::map::GetAll":{"T":["version::Version","header::name::StandardHeader","header::map::HeaderMap","header::map::GetAll","header::name::Custom","header::map::Cursor","header::name::Repr","header::map::Link","header::map::HashValue","std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>","uri::ErrorKind","byte_str::ByteStr"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::HeaderMap::<T>::append2":{"K":["gimli::read::endian_slice::EndianSlice<'input, Endian>"],"T":["RUG_ANY"],"header::name::HeaderName":["method::extension::InlineExtension","header::map::HeaderMap","version::Http","method::Inner","version::Version","header::name::StandardHeader","uri::ErrorKind","header::map::HashValue","header::name::Repr","header::name::Custom","header::map::Cursor","header::map::GetAll","byte_str::ByteStr","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::map::Link","method::extension::AllocatedExtension"]},"header::name::Repr":{"T":["version::Version","header::name::StandardHeader","header::name::Repr","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","header::name::Custom","byte_str::ByteStr"]},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.append2(p1, p2);
+header::map::HeaderMap::<T>::append2(p0, p1, p2);
+crate::header::map::HeaderMap::<T>::append2(p0, p1, p2);
+<header::map::HeaderMap<T>>::append2(p0, p1, p2);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::find
deps:{"<*const T as std::fmt::Debug>":{},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::clone::Clone","std::convert::TryFrom","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"header::map::HeaderMap::<T>::find":{"K":["std::hash::Hash","std::convert::Into"],"T":["std::marker::Sized"],"header::name::HeaderName":["std::cmp::PartialEq"]},"header::name::Repr":{"T":["std::fmt::Debug","std::hash::Hash","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"header::map::GetAll":{"T":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","header::map::Link","header::name::StandardHeader","byte_str::ByteStr","header::map::HeaderMap","header::map::GetAll","version::Version","header::name::Repr","uri::ErrorKind","header::map::Cursor","header::name::Custom","header::map::HashValue"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::HeaderMap::<T>::find":{"K":["gimli::read::endian_slice::EndianSlice<'input, Endian>"],"T":["RUG_ANY"],"header::name::HeaderName":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","header::name::Custom","header::map::GetAll","version::Http","header::name::Repr","byte_str::ByteStr","method::extension::AllocatedExtension","header::map::HashValue","header::name::StandardHeader","header::map::Cursor","method::extension::InlineExtension","method::Inner","uri::ErrorKind","header::map::Link","version::Version","header::map::HeaderMap"]},"header::name::Repr":{"T":["header::name::StandardHeader","header::name::Custom","header::name::Repr","<*const T as std::fmt::Debug>","byte_str::ByteStr","version::Version"]},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // K
+p0.find(p1);
+header::map::HeaderMap::<T>::find(p0, p1);
+crate::header::map::HeaderMap::<T>::find(p0, p1);
+<header::map::HeaderMap<T>>::find(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::insert_phase_two
deps:{"header::map::HeaderMap::<T>::insert_phase_two":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::insert_phase_two":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p2 = MaybeUninit::uninit().assume_init(); // T
let mut p3 = MaybeUninit::uninit().assume_init(); // header::map::HashValue
let mut p4 = 0usize; // None+usize
let mut p5 = true; // None+bool
+p0.insert_phase_two(p1, p2, p3, p4, p5);
+header::map::HeaderMap::<T>::insert_phase_two(p0, p1, p2, p3, p4, p5);
+crate::header::map::HeaderMap::<T>::insert_phase_two(p0, p1, p2, p3, p4, p5);
+<header::map::HeaderMap<T>>::insert_phase_two(p0, p1, p2, p3, p4, p5);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::remove
deps:{"header::map::HeaderMap::<T>::remove":{"K":["std::marker::Sized","header::map::as_header_name::AsHeaderName"],"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::remove":{"K":["std::string::String","header::name::HeaderName"],"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.remove(p1);
+header::map::HeaderMap::<T>::remove(p0, p1);
+crate::header::map::HeaderMap::<T>::remove(p0, p1);
+<header::map::HeaderMap<T>>::remove(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::remove_found
deps:{"header::map::HeaderMap::<T>::remove_found":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::remove_found":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.remove_found(p1, p2);
+header::map::HeaderMap::<T>::remove_found(p0, p1, p2);
+crate::header::map::HeaderMap::<T>::remove_found(p0, p1, p2);
+<header::map::HeaderMap<T>>::remove_found(p0, p1, p2);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::remove_extra_value
deps:{"header::map::HeaderMap::<T>::remove_extra_value":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::remove_extra_value":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = 0usize; // None+usize
+p0.remove_extra_value(p1);
+header::map::HeaderMap::<T>::remove_extra_value(p0, p1);
+crate::header::map::HeaderMap::<T>::remove_extra_value(p0, p1);
+<header::map::HeaderMap<T>>::remove_extra_value(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::remove_all_extra_values
deps:{"header::map::HeaderMap::<T>::remove_all_extra_values":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::remove_all_extra_values":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = 0usize; // None+usize
+p0.remove_all_extra_values(p1);
+header::map::HeaderMap::<T>::remove_all_extra_values(p0, p1);
+crate::header::map::HeaderMap::<T>::remove_all_extra_values(p0, p1);
+<header::map::HeaderMap<T>>::remove_all_extra_values(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::insert_entry
deps:{"header::map::HeaderMap::<T>::insert_entry":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::insert_entry":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // header::map::HashValue
let mut p2 = MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p3 = MaybeUninit::uninit().assume_init(); // T
+p0.insert_entry(p1, p2, p3);
+header::map::HeaderMap::<T>::insert_entry(p0, p1, p2, p3);
+crate::header::map::HeaderMap::<T>::insert_entry(p0, p1, p2, p3);
+<header::map::HeaderMap<T>>::insert_entry(p0, p1, p2, p3);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::rebuild
deps:{"header::map::HeaderMap::<T>::rebuild":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::rebuild":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.rebuild();
+header::map::HeaderMap::<T>::rebuild(p0);
+crate::header::map::HeaderMap::<T>::rebuild(p0);
+<header::map::HeaderMap<T>>::rebuild(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::reinsert_entry_in_order
deps:{"header::map::HeaderMap::<T>::reinsert_entry_in_order":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::reinsert_entry_in_order":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // header::map::Pos
+p0.reinsert_entry_in_order(p1);
+header::map::HeaderMap::<T>::reinsert_entry_in_order(p0, p1);
+crate::header::map::HeaderMap::<T>::reinsert_entry_in_order(p0, p1);
+<header::map::HeaderMap<T>>::reinsert_entry_in_order(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::reserve_one
deps:{"header::map::HeaderMap::<T>::reserve_one":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::reserve_one":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.reserve_one();
+header::map::HeaderMap::<T>::reserve_one(p0);
+crate::header::map::HeaderMap::<T>::reserve_one(p0);
+<header::map::HeaderMap<T>>::reserve_one(p0);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::grow
deps:{"header::map::HeaderMap::<T>::grow":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::grow":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = 0usize; // None+usize
+p0.grow(p1);
+header::map::HeaderMap::<T>::grow(p0, p1);
+crate::header::map::HeaderMap::<T>::grow(p0, p1);
+<header::map::HeaderMap<T>>::grow(p0, p1);
-----------------
src/header/map.rs header::map::HeaderMap::<T>::raw_links
deps:{"header::map::HeaderMap::<T>::raw_links":{"T":["std::marker::Sized"]}}
candidates:{"header::map::HeaderMap::<T>::raw_links":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.raw_links();
+header::map::HeaderMap::<T>::raw_links(p0);
+crate::header::map::HeaderMap::<T>::raw_links(p0);
+<header::map::HeaderMap<T>>::raw_links(p0);
-----------------
src/header/map.rs <&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.into_iter();
+<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter(p0);
+<&'a header::map::HeaderMap<T>>::into_iter(p0);
-----------------
src/header/map.rs <&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.into_iter();
+<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter(p0);
+<&'a mut header::map::HeaderMap<T>>::into_iter(p0);
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter
deps:{"<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.into_iter();
+<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter(p0);
+<header::map::HeaderMap<T>>::into_iter(p0);
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>":{},"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter":{"I":["std::iter::IntoIterator","std::marker::Sized"],"T":["std::marker::Sized"]},"header::map::Bucket":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::clone::Clone","std::convert::TryFrom","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::marker::Send"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Send","std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::hash::Hash"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::fmt::Debug","std::convert::AsRef","std::marker::Sized"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>":{},"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["header::map::ValueDrain","header::map::Drain","<&mut I as std::iter::Iterator>","header::map::ValueIterMut","header::map::Iter","header::map::Values","header::map::IterMut","header::map::IntoIter","header::map::ValuesMut","header::map::ValueIter","header::map::Keys"]},"<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter":{"I":["<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>","header::map::HeaderMap","header::map::OccupiedEntry","header::map::GetAll","<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>"],"T":["RUG_ANY"]},"header::map::Bucket":{"T":["byte_str::ByteStr","header::map::Cursor","header::map::Links","version::Version","uri::scheme::Protocol","<*mut T as std::fmt::Debug>","header::name::StandardHeader","uri::authority::Authority","header::name::HeaderName","header::map::HeaderMap","header::map::ExtraValue","header::map::Link","header::name::Custom","method::Method","header::name::MaybeLower","uri::path::PathAndQuery","header::map::Bucket","uri::scheme::Scheme","header::map::RawLinks","status::StatusCode","uri::scheme::Scheme2","header::value::HeaderValue","header::map::HashValue","uri::Uri","header::name::Repr"]},"header::map::Drain":{"T":["header::map::ValueDrain","header::map::Drain","header::map::ValueIterMut","<*const T as std::fmt::Debug>","header::map::Iter","header::map::IterMut"]},"header::map::Entry":{"T":["uri::scheme::Scheme","<&T as std::fmt::Debug>","header::map::Keys","request::Builder","uri::Uri","header::map::ValueIterMut","header::map::Drain","header::map::VacantEntry","header::map::Iter","header::map::Bucket","header::map::HeaderMap","header::map::Cursor","header::name::HdrName","header::map::RawLinks","uri::InvalidUri","header::map::IntoIter","header::map::Entry","uri::path::PathAndQuery","header::map::IterMut","header::name::Repr","header::map::GetAll","header::map::ExtraValue","status::StatusCode","byte_str::ByteStr","status::InvalidStatusCode","response::Response","uri::scheme::Protocol","header::name::Custom","uri::scheme::Scheme2","uri::Parts","uri::authority::Authority","uri::port::Port","header::name::StandardHeader","response::Builder","header::value::ToStrError","method::InvalidMethod","error::Error","extensions::Extensions","header::map::Links","request::Request","header::name::HeaderName","header::map::OccupiedEntry","header::map::HashValue","uri::builder::Builder","request::Parts","uri::InvalidUriParts","method::Method","header::map::ValuesMut","header::name::InvalidHeaderName","header::value::InvalidHeaderValue","version::Version","header::map::ValueIter","header::map::ValueDrain","header::map::Values","response::Parts","header::value::HeaderValue","header::map::Link","header::name::MaybeLower","uri::ErrorKind"]},"header::map::ExtraValue":{"T":["method::Method","header::map::Cursor","header::map::ExtraValue","header::map::HeaderMap","uri::authority::Authority","header::name::StandardHeader","header::name::Custom","version::Version","header::map::HashValue","uri::Uri","header::name::MaybeLower","std::clone::impls::<impl std::clone::Clone for &mut T>","uri::scheme::Protocol","header::map::Bucket","uri::scheme::Scheme2","header::value::HeaderValue","header::map::Link","header::name::Repr","uri::scheme::Scheme","byte_str::ByteStr","header::map::Links","header::map::RawLinks","status::StatusCode","header::name::HeaderName","uri::path::PathAndQuery"]},"header::map::GetAll":{"T":["header::map::Cursor","header::map::HashValue","version::Version","uri::ErrorKind","header::name::StandardHeader","header::map::HeaderMap","header::map::GetAll","byte_str::ByteStr","header::name::Custom","header::name::Repr","header::map::Link","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::name::InvalidHeaderName","header::map::IterMut","header::map::ValueIter","header::map::Link","header::map::GetAll","header::map::RawLinks","status::StatusCode","header::map::OccupiedEntry","header::name::HdrName","uri::port::Port","uri::authority::Authority","response::Builder","header::value::InvalidHeaderValue","byte_str::ByteStr","uri::Parts","header::map::ValueIterMut","response::Parts","uri::path::PathAndQuery","header::value::ToStrError","header::name::Custom","header::map::VacantEntry","header::map::Values","header::map::Links","response::Response","header::map::ValueDrain","header::map::HashValue","uri::scheme::Scheme","version::Version","header::map::IntoIter","uri::Uri","header::map::Entry","header::value::HeaderValue","uri::scheme::Scheme2","uri::InvalidUriParts","header::map::Bucket","header::name::HeaderName","error::Error","header::map::Drain","request::Parts","header::name::StandardHeader","status::InvalidStatusCode","request::Builder","request::Request","header::map::Iter","uri::ErrorKind","extensions::Extensions","uri::InvalidUri","header::map::ExtraValue","header::map::Cursor","<&mut T as std::fmt::Debug>","header::name::MaybeLower","header::map::ValuesMut","uri::builder::Builder","header::map::HeaderMap","uri::scheme::Protocol","header::name::Repr","method::InvalidMethod","method::Method","header::map::Keys"]},"header::map::Iter":{"T":["<*mut T as std::fmt::Debug>","header::map::IterMut","header::map::Drain","header::map::ValueIterMut","header::map::Iter","header::map::ValueDrain"]},"header::map::IterMut":{"T":["header::map::Iter","header::map::Drain","header::map::IterMut","header::map::ValueIterMut","<*mut T as std::marker::Sync>","header::map::ValueDrain"]},"header::map::Keys":{"T":["header::map::Values","header::name::HeaderName","response::Response","error::Error","header::name::Custom","method::Method","header::map::Drain","uri::ErrorKind","header::map::Bucket","uri::Uri","status::StatusCode","request::Request","header::name::InvalidHeaderName","header::map::IntoIter","header::map::Link","uri::InvalidUriParts","uri::path::PathAndQuery","uri::Parts","header::map::Iter","header::map::GetAll","header::name::MaybeLower","header::value::HeaderValue","header::map::ExtraValue","header::name::Repr","uri::builder::Builder","header::map::HeaderMap","request::Parts","method::InvalidMethod","header::map::Entry","header::map::ValuesMut","uri::authority::Authority","extensions::Extensions","<*const T as std::fmt::Debug>","header::map::OccupiedEntry","header::map::ValueIterMut","byte_str::ByteStr","uri::scheme::Protocol","header::map::Cursor","version::Version","response::Builder","header::map::ValueDrain","response::Parts","header::name::StandardHeader","uri::scheme::Scheme2","uri::InvalidUri","request::Builder","header::map::RawLinks","header::value::ToStrError","header::map::VacantEntry","header::map::Keys","uri::scheme::Scheme","header::map::IterMut","uri::port::Port","status::InvalidStatusCode","header::map::ValueIter","header::name::HdrName","header::map::HashValue","header::map::Links","header::value::InvalidHeaderValue"]},"header::map::OccupiedEntry":{"T":["<*mut T as std::fmt::Debug>","header::name::HdrName","header::name::InvalidHeaderName","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::Values","uri::InvalidUriParts","header::map::Entry","uri::Parts","header::map::HashValue","method::Method","uri::ErrorKind","header::map::IntoIter","header::map::OccupiedEntry","request::Parts","header::map::Links","header::map::Link","header::name::MaybeLower","header::value::HeaderValue","header::map::IterMut","header::map::RawLinks","request::Builder","header::map::ValueDrain","method::InvalidMethod","header::map::GetAll","error::Error","request::Request","uri::Uri","response::Builder","byte_str::ByteStr","response::Response","uri::authority::Authority","header::map::Drain","header::map::VacantEntry","header::name::Custom","uri::path::PathAndQuery","header::map::ValuesMut","header::map::Iter","header::map::ExtraValue","extensions::Extensions","uri::InvalidUri","status::StatusCode","uri::port::Port","status::InvalidStatusCode","header::map::Bucket","response::Parts","header::name::StandardHeader","uri::scheme::Protocol","header::name::Repr","header::value::InvalidHeaderValue","header::value::ToStrError","uri::builder::Builder","header::map::Keys","version::Version","header::map::Cursor","header::map::HeaderMap","header::name::HeaderName","header::map::ValueIter","header::map::ValueIterMut"]},"header::map::RawLinks":{"T":["method::InvalidMethod","header::name::InvalidHeaderName","header::map::ValueIter","response::Builder","header::map::ValueIterMut","header::name::MaybeLower","header::map::Links","uri::scheme::Scheme","uri::scheme::Scheme2","header::map::Bucket","header::name::Custom","header::map::Link","uri::authority::Authority","header::map::Drain","header::map::Values","header::map::Iter","header::map::VacantEntry","header::map::OccupiedEntry","header::map::IterMut","status::StatusCode","header::value::ToStrError","header::name::Repr","uri::Uri","uri::scheme::Protocol","response::Parts","<*mut T as std::fmt::Debug>","header::name::HdrName","version::Version","byte_str::ByteStr","header::value::HeaderValue","header::name::HeaderName","header::map::RawLinks","header::map::ExtraValue","header::map::IntoIter","request::Builder","header::map::HeaderMap","status::InvalidStatusCode","uri::ErrorKind","uri::port::Port","uri::InvalidUriParts","header::map::Entry","header::map::HashValue","header::map::ValueDrain","header::name::StandardHeader","request::Parts","uri::Parts","uri::builder::Builder","response::Response","header::map::GetAll","uri::InvalidUri","error::Error","method::Method","extensions::Extensions","request::Request","header::map::Keys","uri::path::PathAndQuery","header::value::InvalidHeaderValue","header::map::ValuesMut","header::map::Cursor"]},"header::map::VacantEntry":{"T":["header::value::HeaderValue","uri::InvalidUriParts","header::map::HeaderMap","header::map::GetAll","method::InvalidMethod","header::map::ExtraValue","header::map::Links","header::map::Drain","request::Parts","header::value::ToStrError","uri::authority::Authority","uri::ErrorKind","header::map::HashValue","response::Builder","uri::Parts","header::map::ValueIterMut","header::map::VacantEntry","request::Request","extensions::Extensions","byte_str::ByteStr","error::Error","header::map::Cursor","header::map::RawLinks","uri::InvalidUri","header::map::Values","header::name::StandardHeader","uri::path::PathAndQuery","header::map::Bucket","header::name::HdrName","header::name::MaybeLower","uri::port::Port","header::map::Keys","uri::builder::Builder","header::map::Iter","header::map::IntoIter","uri::scheme::Scheme","header::map::IterMut","header::map::OccupiedEntry","version::Version","header::name::Custom","header::name::HeaderName","<*mut T as std::fmt::Debug>","header::map::ValueIter","header::map::Entry","uri::Uri","status::InvalidStatusCode","uri::scheme::Scheme2","header::map::ValueDrain","header::name::Repr","uri::scheme::Protocol","header::map::Link","status::StatusCode","method::Method","header::value::InvalidHeaderValue","request::Builder","header::name::InvalidHeaderName","header::map::ValuesMut","response::Parts","response::Response"]},"header::map::ValueDrain":{"T":["header::map::ValueDrain","header::map::Drain","header::map::IterMut","header::map::ValueIterMut","header::map::Iter","<*mut T as std::fmt::Debug>"]},"header::map::ValueIter":{"T":["header::name::InvalidHeaderName","header::map::HashValue","<*mut T as std::fmt::Debug>","header::map::HeaderMap","uri::InvalidUriParts","version::Version","uri::InvalidUri","uri::port::Port","header::map::Link","response::Parts","uri::scheme::Scheme","header::map::Keys","uri::Uri","header::map::Drain","header::map::OccupiedEntry","header::name::Custom","header::map::ValueIterMut","header::map::GetAll","header::map::ValueDrain","status::InvalidStatusCode","extensions::Extensions","header::name::HeaderName","header::map::RawLinks","status::StatusCode","header::value::HeaderValue","header::map::VacantEntry","header::map::ExtraValue","method::InvalidMethod","header::map::IterMut","uri::Parts","header::name::StandardHeader","request::Builder","header::map::ValuesMut","uri::path::PathAndQuery","header::name::HdrName","method::Method","uri::authority::Authority","header::map::Cursor","uri::scheme::Protocol","header::map::ValueIter","header::map::Bucket","header::value::InvalidHeaderValue","header::name::MaybeLower","response::Builder","header::name::Repr","error::Error","header::map::IntoIter","uri::builder::Builder","header::map::Links","header::map::Iter","request::Request","header::value::ToStrError","request::Parts","byte_str::ByteStr","uri::scheme::Scheme2","uri::ErrorKind","header::map::Entry","response::Response","header::map::Values"]},"header::map::ValueIterMut":{"T":["header::map::Drain","<*mut T as std::marker::Sync>","header::map::IterMut","header::map::ValueIterMut","header::map::ValueDrain","header::map::Iter"]},"header::map::Values":{"T":["error::Error","response::Builder","uri::Uri","header::map::IterMut","uri::authority::Authority","header::map::Drain","header::name::Custom","header::value::HeaderValue","header::map::HeaderMap","uri::scheme::Scheme","header::name::HeaderName","uri::scheme::Scheme2","header::map::Link","header::map::Entry","extensions::Extensions","uri::scheme::Protocol","header::map::ValueIter","response::Response","version::Version","header::map::Values","request::Request","status::StatusCode","<*mut T as std::fmt::Debug>","uri::Parts","request::Builder","uri::InvalidUri","header::map::RawLinks","header::map::Cursor","uri::builder::Builder","header::map::Iter","header::map::ValueDrain","header::map::Keys","header::map::ExtraValue","byte_str::ByteStr","header::map::VacantEntry","header::name::InvalidHeaderName","header::map::OccupiedEntry","uri::port::Port","header::map::ValueIterMut","uri::ErrorKind","method::InvalidMethod","header::map::Bucket","header::name::Repr","header::map::GetAll","uri::InvalidUriParts","header::name::HdrName","header::map::ValuesMut","status::InvalidStatusCode","header::value::ToStrError","header::value::InvalidHeaderValue","response::Parts","header::name::StandardHeader","header::map::HashValue","header::map::IntoIter","header::name::MaybeLower","header::map::Links","uri::path::PathAndQuery","request::Parts","method::Method"]},"header::map::ValuesMut":{"T":["header::value::HeaderValue","byte_str::ByteStr","method::InvalidMethod","uri::scheme::Protocol","uri::Parts","error::Error","header::value::InvalidHeaderValue","status::InvalidStatusCode","response::Parts","version::Version","header::map::Link","header::map::Bucket","header::map::Iter","uri::builder::Builder","uri::port::Port","header::name::MaybeLower","response::Response","uri::scheme::Scheme","header::map::Cursor","header::map::Drain","header::name::HeaderName","header::map::ValuesMut","uri::ErrorKind","header::map::HashValue","header::name::StandardHeader","header::name::Custom","header::map::ValueIter","extensions::Extensions","<*const T as std::fmt::Debug>","header::map::VacantEntry","header::map::Values","header::name::InvalidHeaderName","header::map::GetAll","header::name::HdrName","header::map::IntoIter","request::Parts","header::map::Keys","header::value::ToStrError","header::map::IterMut","header::map::ValueIterMut","status::StatusCode","uri::authority::Authority","header::map::ExtraValue","response::Builder","uri::Uri","header::map::OccupiedEntry","uri::path::PathAndQuery","request::Request","header::map::HeaderMap","request::Builder","method::Method","uri::scheme::Scheme2","uri::InvalidUri","header::map::RawLinks","header::map::ValueDrain","uri::InvalidUriParts","header::map::Links","header::map::Entry","header::name::Repr"]},"header::name::Repr":{"T":["header::name::Custom","header::name::StandardHeader","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","byte_str::ByteStr","version::Version","header::name::Repr"]},"request::Request":{"T":["response::Builder","method::Method","version::Version","uri::Parts","request::Request","uri::Uri","header::map::HeaderMap","status::StatusCode","request::Builder","uri::builder::Builder","extensions::Extensions","response::Response"]},"response::Response":{"T":["uri::Uri","request::Builder","status::StatusCode","response::Builder","version::Version","uri::Parts","extensions::Extensions","method::Method","request::Request","response::Response","header::map::HeaderMap","uri::builder::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["header::value::HeaderValue","uri::authority::Authority","uri::scheme::Scheme","<&T as std::fmt::Debug>","uri::port::Port","method::Method"]},"uri::scheme::Scheme2":{"T":["uri::scheme::Scheme2","header::map::HashValue","header::map::ExtraValue","uri::scheme::Protocol","header::map::Cursor","header::name::MaybeLower","version::Version","header::map::Bucket","method::Method","<&mut T as std::fmt::Debug>","header::map::Link","uri::path::PathAndQuery","header::name::StandardHeader","header::name::Repr","byte_str::ByteStr","header::map::Links","uri::authority::Authority","header::name::Custom","std::boxed::Box<byte_str::ByteStr>","uri::Uri","uri::scheme::Scheme","header::value::HeaderValue","header::map::RawLinks","status::StatusCode","header::map::HeaderMap","header::name::HeaderName"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter(p0);
+crate::<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter(p0);
+<header::map::HeaderMap<T>>::from_iter(p0);
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V>>>::try_from
'a
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V>>>::try_from":{"<T as std::convert::TryFrom<&'a V>>::Error":["std::convert::Into"],"<header::name::HeaderName as std::convert::TryFrom<&'a K>>::Error":["std::convert::Into"],"K":["std::marker::Sized","std::cmp::Eq","std::hash::Hash"],"T":["std::marker::Sized","std::convert::TryFrom"],"V":["std::marker::Sized"],"header::name::HeaderName":["std::convert::TryFrom"]},"header::map::HeaderMap":{"T":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::convert::TryFrom"]},"header::name::Repr":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::hash::Hash","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V>>>::try_from":{"<T as std::convert::TryFrom<&'a V>>::Error":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError"],"<header::name::HeaderName as std::convert::TryFrom<&'a K>>::Error":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>"],"K":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","status::StatusCode","header::name::StandardHeader","version::Version","method::Method","uri::authority::Authority","std::hash::impls::<impl std::hash::Hash for *mut T>","std::hash::impls::<impl std::hash::Hash for *const T>","method::extension::AllocatedExtension","version::Http","header::name::Repr","method::extension::InlineExtension","header::name::Custom","header::value::HeaderValue","method::Inner","byte_str::ByteStr","header::name::HeaderName","uri::Uri","uri::scheme::Scheme"],"T":["header::map::HeaderMap","<T as std::convert::TryFrom<U>>"],"V":["RUG_ANY"],"header::name::HeaderName":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::name::Repr":{"T":["std::clone::impls::<impl std::clone::Clone for *mut T>","version::Version","header::name::StandardHeader","header::name::Custom","byte_str::ByteStr","header::name::Repr"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::collections::HashMap<K, V>
+<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V>>>::try_from(p0);
+crate::<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V>>>::try_from(p0);
+<header::map::HeaderMap<T>>::try_from(p0);
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>":{},"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend":{"I":["std::iter::IntoIterator","std::marker::Sized"],"T":["std::marker::Sized"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Sync","std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::convert::TryFrom"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::marker::Sized"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::marker::Send"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash"]},"request::Request":{"T":["std::fmt::Debug","std::default::Default","std::marker::Sized"]},"response::Response":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>":{},"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["header::map::ValueDrain","header::map::ValuesMut","header::map::Drain","header::map::IterMut","header::map::ValueIter","<&mut I as std::iter::Iterator>","header::map::IntoIter","header::map::Values","header::map::Iter","header::map::Keys","header::map::ValueIterMut"]},"<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend":{"I":["<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>","header::map::OccupiedEntry","header::map::GetAll","<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","header::map::HeaderMap"],"T":["RUG_ANY"]},"header::map::Bucket":{"T":["header::map::HeaderMap","uri::scheme::Protocol","version::Version","header::name::StandardHeader","header::map::Cursor","header::name::Repr","uri::authority::Authority","header::map::Bucket","method::Method","uri::scheme::Scheme2","std::clone::impls::<impl std::clone::Clone for &T>","uri::path::PathAndQuery","header::map::RawLinks","byte_str::ByteStr","status::StatusCode","header::map::Link","header::name::HeaderName","header::name::MaybeLower","header::value::HeaderValue","header::map::HashValue","header::map::ExtraValue","uri::scheme::Scheme","header::name::Custom","uri::Uri","header::map::Links"]},"header::map::Drain":{"T":["header::map::Iter","header::map::Drain","<*const T as std::fmt::Debug>","header::map::ValueDrain","header::map::IterMut","header::map::ValueIterMut"]},"header::map::Entry":{"T":["byte_str::ByteStr","header::value::InvalidHeaderValue","header::map::ValueDrain","header::map::GetAll","header::name::MaybeLower","request::Parts","header::name::InvalidHeaderName","header::map::Links","header::map::Cursor","status::StatusCode","header::value::ToStrError","header::map::ValueIterMut","header::name::HdrName","header::map::IterMut","method::Method","uri::ErrorKind","request::Request","header::map::RawLinks","header::map::IntoIter","header::name::Custom","version::Version","uri::port::Port","uri::scheme::Scheme","header::value::HeaderValue","uri::InvalidUriParts","request::Builder","header::map::VacantEntry","header::map::Iter","uri::scheme::Scheme2","header::name::Repr","header::map::Values","header::map::ExtraValue","header::map::Link","extensions::Extensions","header::map::Bucket","uri::scheme::Protocol","uri::path::PathAndQuery","response::Parts","header::name::HeaderName","response::Builder","<*mut T as std::fmt::Debug>","uri::builder::Builder","header::map::Keys","uri::Uri","method::InvalidMethod","response::Response","header::map::ValuesMut","header::map::OccupiedEntry","header::map::Drain","header::map::Entry","header::map::HeaderMap","error::Error","header::name::StandardHeader","uri::InvalidUri","uri::authority::Authority","status::InvalidStatusCode","header::map::ValueIter","header::map::HashValue","uri::Parts"]},"header::map::ExtraValue":{"T":["header::name::Repr","version::Version","header::map::Cursor","uri::path::PathAndQuery","header::value::HeaderValue","header::map::ExtraValue","header::map::HeaderMap","header::name::StandardHeader","<*const T as std::fmt::Debug>","header::map::RawLinks","byte_str::ByteStr","header::map::Bucket","uri::authority::Authority","header::map::Links","header::name::MaybeLower","status::StatusCode","uri::scheme::Scheme2","uri::scheme::Scheme","uri::Uri","uri::scheme::Protocol","method::Method","header::map::HashValue","header::name::Custom","header::name::HeaderName","header::map::Link"]},"header::map::GetAll":{"T":["byte_str::ByteStr","header::name::Custom","header::map::Cursor","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","version::Version","header::map::GetAll","header::map::HashValue","header::map::HeaderMap","header::name::StandardHeader","uri::ErrorKind","header::map::Link","header::name::Repr"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::HashValue","header::map::IntoIter","error::Error","header::map::ValueIter","request::Builder","uri::authority::Authority","header::name::Custom","header::map::Values","header::name::HdrName","header::value::HeaderValue","header::map::HeaderMap","status::InvalidStatusCode","header::name::InvalidHeaderName","header::map::VacantEntry","status::StatusCode","response::Response","uri::port::Port","header::value::InvalidHeaderValue","header::name::Repr","response::Parts","method::Method","uri::scheme::Scheme2","header::value::ToStrError","header::map::ValueIterMut","uri::Uri","uri::InvalidUri","response::Builder","header::name::HeaderName","header::map::Links","header::map::Link","header::map::Drain","method::InvalidMethod","uri::builder::Builder","uri::scheme::Protocol","uri::path::PathAndQuery","header::map::Cursor","uri::Parts","header::map::Bucket","request::Parts","header::map::RawLinks","header::name::StandardHeader","<&T as std::fmt::Debug>","header::map::Keys","version::Version","header::name::MaybeLower","byte_str::ByteStr","uri::InvalidUriParts","header::map::Iter","header::map::OccupiedEntry","header::map::IterMut","request::Request","header::map::GetAll","extensions::Extensions","header::map::ValueDrain","header::map::ExtraValue","uri::ErrorKind","header::map::ValuesMut","header::map::Entry","uri::scheme::Scheme"]},"header::map::Iter":{"T":["header::map::Drain","<*const T as std::fmt::Debug>","header::map::ValueDrain","header::map::IterMut","header::map::Iter","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["header::map::Drain","header::map::ValueIterMut","header::map::Iter","header::map::IterMut","header::map::ValueDrain","<*mut T as std::fmt::Debug>"]},"header::map::Keys":{"T":["uri::builder::Builder","header::map::Bucket","uri::Parts","status::InvalidStatusCode","header::map::Iter","uri::scheme::Scheme2","request::Builder","header::map::Link","header::map::ValueIter","uri::InvalidUriParts","header::map::ExtraValue","header::name::StandardHeader","uri::port::Port","header::map::ValueDrain","header::name::Custom","uri::authority::Authority","method::InvalidMethod","header::name::HeaderName","header::map::IterMut","header::name::HdrName","header::map::Entry","<&mut T as std::fmt::Debug>","uri::ErrorKind","header::map::VacantEntry","byte_str::ByteStr","response::Builder","error::Error","header::name::MaybeLower","header::name::InvalidHeaderName","header::value::HeaderValue","header::name::Repr","header::map::IntoIter","header::map::Keys","version::Version","request::Request","response::Parts","header::map::Links","header::map::GetAll","uri::InvalidUri","method::Method","extensions::Extensions","header::map::Cursor","uri::scheme::Scheme","header::map::Values","header::map::ValueIterMut","header::value::InvalidHeaderValue","uri::scheme::Protocol","uri::Uri","header::map::RawLinks","header::map::Drain","header::map::ValuesMut","header::map::HashValue","status::StatusCode","uri::path::PathAndQuery","header::map::HeaderMap","header::map::OccupiedEntry","request::Parts","header::value::ToStrError","response::Response"]},"header::map::OccupiedEntry":{"T":["<*mut T as std::fmt::Debug>","request::Builder","response::Response","uri::scheme::Scheme2","header::name::HeaderName","uri::ErrorKind","header::value::HeaderValue","header::map::IntoIter","header::map::ValueIterMut","header::map::ExtraValue","header::name::HdrName","extensions::Extensions","response::Parts","request::Request","header::map::Link","uri::Parts","header::map::Bucket","uri::scheme::Protocol","header::map::ValueDrain","header::map::GetAll","request::Parts","uri::path::PathAndQuery","header::map::ValueIter","uri::port::Port","header::map::Iter","response::Builder","version::Version","header::name::StandardHeader","status::InvalidStatusCode","header::value::InvalidHeaderValue","header::map::Values","error::Error","header::map::Drain","header::map::Entry","header::name::InvalidHeaderName","header::map::Links","header::map::VacantEntry","uri::InvalidUriParts","header::map::Cursor","uri::InvalidUri","header::map::HashValue","uri::scheme::Scheme","header::map::IterMut","header::map::OccupiedEntry","uri::authority::Authority","byte_str::ByteStr","header::map::Keys","method::InvalidMethod","header::map::HeaderMap","header::map::RawLinks","header::value::ToStrError","status::StatusCode","uri::builder::Builder","header::name::MaybeLower","uri::Uri","header::name::Repr","header::name::Custom","header::map::ValuesMut","method::Method"]},"header::map::RawLinks":{"T":["uri::scheme::Scheme2","header::name::StandardHeader","response::Parts","header::map::Bucket","header::map::ExtraValue","header::map::Links","header::map::Keys","uri::Uri","header::map::Link","uri::scheme::Scheme","extensions::Extensions","header::map::HashValue","uri::scheme::Protocol","uri::Parts","header::map::IterMut","header::map::Entry","uri::InvalidUriParts","request::Request","uri::port::Port","header::map::VacantEntry","header::name::HeaderName","header::map::ValuesMut","<&mut T as std::fmt::Debug>","request::Parts","header::name::Repr","header::name::HdrName","header::name::MaybeLower","error::Error","uri::path::PathAndQuery","request::Builder","method::InvalidMethod","status::StatusCode","header::map::Iter","header::value::HeaderValue","response::Builder","uri::InvalidUri","header::map::GetAll","header::map::Values","uri::authority::Authority","method::Method","header::map::RawLinks","uri::ErrorKind","header::map::HeaderMap","status::InvalidStatusCode","header::name::InvalidHeaderName","header::map::ValueIterMut","byte_str::ByteStr","header::value::ToStrError","header::map::ValueIter","header::map::Cursor","header::map::OccupiedEntry","header::map::IntoIter","header::value::InvalidHeaderValue","version::Version","header::map::Drain","uri::builder::Builder","header::map::ValueDrain","header::name::Custom","response::Response"]},"header::map::VacantEntry":{"T":["header::map::Values","header::map::ValueIterMut","header::name::Repr","uri::scheme::Scheme2","header::map::Link","response::Response","header::name::HeaderName","header::map::HeaderMap","header::value::ToStrError","header::map::Links","header::map::ValuesMut","header::map::Cursor","<*const T as std::fmt::Debug>","header::map::Drain","header::map::Bucket","request::Parts","uri::ErrorKind","header::map::IntoIter","header::map::ValueIter","uri::path::PathAndQuery","header::name::StandardHeader","header::map::GetAll","method::Method","header::map::IterMut","status::StatusCode","uri::InvalidUri","header::name::MaybeLower","method::InvalidMethod","header::name::InvalidHeaderName","response::Parts","request::Request","uri::port::Port","status::InvalidStatusCode","header::value::HeaderValue","uri::Parts","error::Error","header::map::Entry","header::name::Custom","uri::Uri","header::map::OccupiedEntry","header::map::VacantEntry","version::Version","header::map::Keys","uri::scheme::Protocol","byte_str::ByteStr","uri::InvalidUriParts","header::map::ExtraValue","uri::builder::Builder","request::Builder","header::map::Iter","uri::authority::Authority","header::value::InvalidHeaderValue","header::name::HdrName","header::map::RawLinks","response::Builder","extensions::Extensions","header::map::HashValue","uri::scheme::Scheme","header::map::ValueDrain"]},"header::map::ValueDrain":{"T":["header::map::Iter","<*const T as std::fmt::Debug>","header::map::ValueIterMut","header::map::ValueDrain","header::map::IterMut","header::map::Drain"]},"header::map::ValueIter":{"T":["header::map::Cursor","uri::scheme::Scheme","header::name::HdrName","uri::authority::Authority","header::map::IntoIter","header::name::Repr","uri::scheme::Protocol","header::map::HashValue","header::value::HeaderValue","header::name::InvalidHeaderName","header::map::Keys","header::name::MaybeLower","request::Builder","header::map::ValueIter","header::map::ValuesMut","header::map::ExtraValue","response::Response","header::value::ToStrError","header::map::VacantEntry","header::name::HeaderName","uri::scheme::Scheme2","header::map::HeaderMap","method::InvalidMethod","status::StatusCode","header::map::Drain","version::Version","header::map::Iter","uri::InvalidUriParts","header::map::Values","response::Parts","uri::ErrorKind","header::map::Links","request::Parts","extensions::Extensions","response::Builder","header::name::StandardHeader","header::map::RawLinks","uri::port::Port","header::map::ValueIterMut","header::map::Bucket","uri::InvalidUri","header::name::Custom","uri::Parts","header::map::ValueDrain","uri::builder::Builder","method::Method","header::map::OccupiedEntry","error::Error","byte_str::ByteStr","header::map::GetAll","header::map::Entry","uri::Uri","uri::path::PathAndQuery","<*const T as std::fmt::Debug>","request::Request","header::map::IterMut","header::map::Link","header::value::InvalidHeaderValue","status::InvalidStatusCode"]},"header::map::ValueIterMut":{"T":["header::map::ValueIterMut","header::map::IterMut","header::map::Iter","header::map::ValueDrain","<*mut T as std::fmt::Debug>","header::map::Drain"]},"header::map::Values":{"T":["method::Method","header::map::ValueIter","extensions::Extensions","uri::scheme::Scheme","header::map::IterMut","byte_str::ByteStr","header::map::RawLinks","header::map::Bucket","header::value::ToStrError","header::name::InvalidHeaderName","method::InvalidMethod","status::StatusCode","request::Parts","header::map::Links","header::map::IntoIter","header::map::Values","header::map::GetAll","error::Error","uri::Parts","uri::InvalidUri","header::map::Keys","header::map::HashValue","header::name::StandardHeader","uri::Uri","response::Builder","uri::ErrorKind","header::map::Iter","response::Parts","header::value::InvalidHeaderValue","uri::InvalidUriParts","uri::builder::Builder","header::map::Link","header::map::VacantEntry","header::name::HdrName","status::InvalidStatusCode","header::map::OccupiedEntry","request::Request","<*const T as std::fmt::Debug>","header::map::Entry","header::name::HeaderName","header::map::ValueIterMut","request::Builder","version::Version","header::map::ValueDrain","uri::authority::Authority","header::value::HeaderValue","uri::path::PathAndQuery","uri::port::Port","response::Response","header::name::MaybeLower","header::map::ExtraValue","header::map::HeaderMap","header::name::Custom","header::map::ValuesMut","uri::scheme::Scheme2","header::map::Cursor","header::name::Repr","header::map::Drain","uri::scheme::Protocol"]},"header::map::ValuesMut":{"T":["header::map::Cursor","method::InvalidMethod","uri::Uri","status::StatusCode","response::Builder","uri::InvalidUriParts","header::name::InvalidHeaderName","status::InvalidStatusCode","header::map::Link","uri::port::Port","<*mut T as std::fmt::Debug>","uri::Parts","header::map::GetAll","uri::scheme::Scheme2","version::Version","error::Error","method::Method","header::name::StandardHeader","header::value::InvalidHeaderValue","header::map::ValueDrain","header::map::Entry","request::Request","header::name::HdrName","header::map::Links","header::map::ValueIterMut","byte_str::ByteStr","response::Parts","header::map::IterMut","header::map::ValueIter","extensions::Extensions","header::map::Bucket","header::map::Keys","header::map::HeaderMap","header::map::HashValue","uri::scheme::Protocol","uri::InvalidUri","header::map::Iter","request::Builder","header::map::OccupiedEntry","header::name::Repr","header::map::Values","header::value::ToStrError","header::name::MaybeLower","uri::authority::Authority","uri::path::PathAndQuery","request::Parts","header::map::ExtraValue","header::map::ValuesMut","header::map::RawLinks","uri::ErrorKind","header::map::VacantEntry","response::Response","header::map::Drain","header::value::HeaderValue","header::name::HeaderName","uri::scheme::Scheme","uri::builder::Builder","header::map::IntoIter","header::name::Custom"]},"header::name::Repr":{"T":["byte_str::ByteStr","header::name::Repr","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","header::name::Custom","header::name::StandardHeader","version::Version"]},"request::Request":{"T":["response::Response","request::Builder","response::Builder","uri::builder::Builder","version::Version","header::map::HeaderMap","method::Method","uri::Uri","uri::Parts","extensions::Extensions","status::StatusCode","request::Request"]},"response::Response":{"T":["request::Builder","method::Method","uri::Uri","status::StatusCode","header::map::HeaderMap","response::Response","uri::Parts","request::Request","version::Version","response::Builder","extensions::Extensions","uri::builder::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["header::value::HeaderValue","uri::scheme::Scheme","<&T as std::fmt::Debug>","uri::authority::Authority","method::Method","uri::port::Port"]},"uri::scheme::Scheme2":{"T":["<&T as std::fmt::Debug>","version::Version","header::map::Bucket","std::boxed::Box<byte_str::ByteStr>","uri::scheme::Scheme","header::map::HashValue","header::map::RawLinks","uri::Uri","uri::path::PathAndQuery","header::map::Link","uri::scheme::Scheme2","header::value::HeaderValue","status::StatusCode","header::map::Links","header::name::Repr","header::name::MaybeLower","method::Method","header::name::HeaderName","header::name::Custom","header::map::Cursor","uri::authority::Authority","uri::scheme::Protocol","header::name::StandardHeader","byte_str::ByteStr","header::map::ExtraValue","header::map::HeaderMap"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extend(p1);
+<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend(p0, p1);
+crate::<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend(p0, p1);
+<header::map::HeaderMap<T>>::extend(p0, p1);
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>":{},"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend":{"I":["std::marker::Sized","std::iter::IntoIterator"],"T":["std::marker::Sized"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::IterMut":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::marker::Sized"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::name::Repr":{"T":["std::hash::Hash","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::fmt::Debug","std::convert::AsRef","std::marker::Sized"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>":{},"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>":{},"<&T as std::fmt::Debug>":{},"<&mut I as std::iter::Iterator>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<I as std::iter::IntoIterator>":{"I":["header::map::ValueIterMut","header::map::Iter","header::map::IntoIter","header::map::IterMut","header::map::Keys","<&mut I as std::iter::Iterator>","header::map::ValueDrain","header::map::Values","header::map::ValuesMut","header::map::ValueIter","header::map::Drain"]},"<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend":{"I":["header::map::HeaderMap","<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>","<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>","header::map::OccupiedEntry","header::map::GetAll"],"T":["RUG_ANY"]},"header::map::Bucket":{"T":["uri::scheme::Protocol","version::Version","std::clone::impls::<impl std::clone::Clone for &mut T>","uri::path::PathAndQuery","header::name::MaybeLower","header::name::Custom","status::StatusCode","header::name::HeaderName","header::value::HeaderValue","uri::authority::Authority","header::name::Repr","byte_str::ByteStr","header::map::Link","header::map::ExtraValue","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::Cursor","header::map::Bucket","uri::Uri","header::name::StandardHeader","header::map::HashValue","header::map::HeaderMap","header::map::RawLinks","header::map::Links","method::Method"]},"header::map::Drain":{"T":["header::map::IterMut","header::map::ValueIterMut","<*const T as std::fmt::Debug>","header::map::Drain","header::map::Iter","header::map::ValueDrain"]},"header::map::Entry":{"T":["header::value::InvalidHeaderValue","uri::InvalidUriParts","header::name::InvalidHeaderName","response::Parts","header::map::Link","request::Builder","status::InvalidStatusCode","header::map::Entry","header::name::HeaderName","header::map::HashValue","byte_str::ByteStr","method::Method","header::map::VacantEntry","version::Version","header::map::Bucket","uri::authority::Authority","uri::Parts","header::map::ValueDrain","error::Error","header::map::ExtraValue","header::value::ToStrError","uri::port::Port","request::Request","request::Parts","header::name::Custom","uri::scheme::Protocol","response::Builder","header::map::Keys","uri::builder::Builder","uri::path::PathAndQuery","header::map::ValueIter","header::name::HdrName","header::map::ValuesMut","header::map::OccupiedEntry","uri::Uri","header::map::Values","header::map::Links","header::map::IterMut","method::InvalidMethod","uri::scheme::Scheme2","header::map::ValueIterMut","uri::ErrorKind","response::Response","header::map::RawLinks","header::name::StandardHeader","<*mut T as std::fmt::Debug>","header::name::Repr","header::map::HeaderMap","header::map::IntoIter","header::map::Cursor","header::map::Iter","header::map::Drain","uri::scheme::Scheme","header::map::GetAll","extensions::Extensions","header::name::MaybeLower","header::value::HeaderValue","status::StatusCode","uri::InvalidUri"]},"header::map::ExtraValue":{"T":["header::name::Repr","header::map::Link","uri::path::PathAndQuery","method::Method","header::map::Links","uri::scheme::Protocol","status::StatusCode","header::value::HeaderValue","header::map::ExtraValue","header::name::StandardHeader","header::map::Bucket","<*mut T as std::fmt::Debug>","header::map::HashValue","header::map::RawLinks","header::map::HeaderMap","uri::scheme::Scheme2","uri::Uri","byte_str::ByteStr","header::name::HeaderName","header::name::MaybeLower","uri::scheme::Scheme","header::map::Cursor","version::Version","header::name::Custom","uri::authority::Authority"]},"header::map::GetAll":{"T":["byte_str::ByteStr","header::map::Cursor","version::Version","header::map::GetAll","header::map::HashValue","header::map::HeaderMap","header::name::Repr","header::name::StandardHeader","header::name::Custom","header::map::Link","uri::ErrorKind","<*const T as std::fmt::Debug>"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["header::name::InvalidHeaderName","uri::ErrorKind","header::map::HashValue","status::InvalidStatusCode","header::map::ValuesMut","header::map::IterMut","response::Response","uri::Uri","uri::scheme::Scheme","header::name::Repr","request::Builder","byte_str::ByteStr","uri::authority::Authority","header::name::MaybeLower","request::Parts","header::map::HeaderMap","uri::path::PathAndQuery","method::InvalidMethod","header::map::Values","header::map::Links","status::StatusCode","header::name::Custom","header::map::OccupiedEntry","header::map::ValueIter","header::name::StandardHeader","uri::InvalidUri","uri::scheme::Protocol","error::Error","header::map::Keys","<&T as std::fmt::Debug>","header::map::GetAll","uri::Parts","header::map::Iter","version::Version","header::map::Bucket","uri::InvalidUriParts","header::map::RawLinks","header::map::IntoIter","header::map::ValueDrain","header::value::InvalidHeaderValue","header::name::HdrName","header::value::HeaderValue","uri::builder::Builder","header::map::VacantEntry","header::value::ToStrError","request::Request","header::map::ExtraValue","header::map::Cursor","header::map::Entry","header::map::ValueIterMut","header::name::HeaderName","uri::port::Port","extensions::Extensions","header::map::Link","header::map::Drain","response::Parts","uri::scheme::Scheme2","response::Builder","method::Method"]},"header::map::Iter":{"T":["header::map::IterMut","<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Drain","header::map::Iter","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["<*mut T as std::fmt::Debug>","header::map::IterMut","header::map::ValueDrain","header::map::ValueIterMut","header::map::Iter","header::map::Drain"]},"header::map::Keys":{"T":["header::map::Values","header::map::ValueIterMut","header::map::HashValue","response::Response","header::map::IntoIter","header::map::Cursor","header::map::VacantEntry","method::InvalidMethod","uri::scheme::Protocol","header::map::Entry","header::map::OccupiedEntry","response::Builder","uri::scheme::Scheme","request::Parts","byte_str::ByteStr","header::map::ValueIter","header::value::InvalidHeaderValue","header::map::Bucket","header::map::RawLinks","request::Request","uri::Parts","header::name::Custom","<&mut T as std::fmt::Debug>","header::map::GetAll","header::map::Iter","header::map::ExtraValue","uri::ErrorKind","header::map::ValueDrain","header::map::HeaderMap","uri::path::PathAndQuery","version::Version","uri::InvalidUri","header::name::StandardHeader","header::name::InvalidHeaderName","header::map::IterMut","uri::builder::Builder","status::InvalidStatusCode","uri::authority::Authority","header::name::MaybeLower","error::Error","request::Builder","uri::port::Port","header::value::ToStrError","header::name::Repr","header::map::Drain","uri::scheme::Scheme2","header::name::HdrName","header::value::HeaderValue","uri::Uri","header::map::Links","header::name::HeaderName","header::map::ValuesMut","header::map::Link","uri::InvalidUriParts","method::Method","status::StatusCode","extensions::Extensions","header::map::Keys","response::Parts"]},"header::map::OccupiedEntry":{"T":["response::Parts","header::map::IterMut","header::map::ValueIter","header::name::StandardHeader","header::value::InvalidHeaderValue","version::Version","header::name::InvalidHeaderName","header::map::ExtraValue","byte_str::ByteStr","error::Error","header::name::HeaderName","uri::builder::Builder","header::map::IntoIter","uri::authority::Authority","uri::Parts","header::map::Values","header::map::Links","uri::ErrorKind","header::map::Drain","header::name::Repr","uri::InvalidUri","request::Builder","header::map::Link","header::map::Entry","header::map::RawLinks","uri::Uri","header::map::ValuesMut","header::map::GetAll","request::Request","method::InvalidMethod","header::map::ValueDrain","status::StatusCode","status::InvalidStatusCode","response::Builder","response::Response","header::map::OccupiedEntry","header::name::Custom","<&mut T as std::fmt::Debug>","header::map::HeaderMap","header::map::HashValue","header::map::Bucket","method::Method","uri::scheme::Scheme2","header::map::Cursor","uri::scheme::Scheme","header::map::ValueIterMut","header::name::HdrName","uri::port::Port","header::map::Keys","uri::path::PathAndQuery","header::value::HeaderValue","uri::scheme::Protocol","header::value::ToStrError","header::name::MaybeLower","request::Parts","uri::InvalidUriParts","extensions::Extensions","header::map::Iter","header::map::VacantEntry"]},"header::map::RawLinks":{"T":["header::map::Cursor","uri::InvalidUri","uri::scheme::Protocol","request::Builder","header::map::Links","uri::scheme::Scheme2","error::Error","uri::Parts","header::name::HeaderName","response::Response","header::map::HashValue","header::map::VacantEntry","response::Parts","method::Method","extensions::Extensions","header::name::InvalidHeaderName","response::Builder","header::map::RawLinks","uri::authority::Authority","header::map::Drain","header::map::Iter","header::map::Values","header::name::Repr","uri::Uri","header::value::HeaderValue","header::map::Bucket","status::InvalidStatusCode","header::map::ExtraValue","header::map::ValueIterMut","header::map::OccupiedEntry","header::name::MaybeLower","uri::port::Port","header::map::ValueDrain","uri::scheme::Scheme","header::map::IntoIter","request::Parts","header::value::ToStrError","header::map::ValueIter","version::Version","request::Request","header::map::Link","byte_str::ByteStr","header::map::HeaderMap","uri::InvalidUriParts","header::map::Entry","<*mut T as std::fmt::Debug>","header::value::InvalidHeaderValue","header::map::Keys","uri::ErrorKind","status::StatusCode","header::name::StandardHeader","uri::path::PathAndQuery","uri::builder::Builder","header::map::ValuesMut","method::InvalidMethod","header::map::IterMut","header::name::HdrName","header::name::Custom","header::map::GetAll"]},"header::map::VacantEntry":{"T":["extensions::Extensions","header::map::OccupiedEntry","header::value::InvalidHeaderValue","header::map::Drain","header::map::ValueDrain","response::Response","response::Builder","header::map::Bucket","header::name::Custom","request::Request","uri::builder::Builder","header::name::InvalidHeaderName","header::map::Links","header::name::Repr","header::map::VacantEntry","header::map::Entry","method::Method","uri::InvalidUri","uri::scheme::Protocol","uri::Parts","header::map::Link","header::value::HeaderValue","header::map::HeaderMap","request::Parts","header::map::ExtraValue","uri::Uri","header::map::Iter","request::Builder","method::InvalidMethod","header::map::HashValue","header::map::ValueIterMut","header::map::GetAll","status::InvalidStatusCode","header::map::IterMut","byte_str::ByteStr","header::map::Values","uri::port::Port","header::map::RawLinks","uri::scheme::Scheme2","status::StatusCode","header::map::Keys","uri::InvalidUriParts","header::map::Cursor","header::name::StandardHeader","header::name::MaybeLower","response::Parts","header::map::IntoIter","uri::authority::Authority","header::map::ValuesMut","header::name::HdrName","header::value::ToStrError","version::Version","header::name::HeaderName","uri::scheme::Scheme","error::Error","uri::path::PathAndQuery","header::map::ValueIter","<&mut T as std::fmt::Debug>","uri::ErrorKind"]},"header::map::ValueDrain":{"T":["header::map::Drain","header::map::IterMut","header::map::Iter","header::map::ValueIterMut","<*mut T as std::marker::Send>","header::map::ValueDrain"]},"header::map::ValueIter":{"T":["uri::InvalidUri","header::value::InvalidHeaderValue","method::InvalidMethod","header::name::Custom","header::map::Iter","header::map::Drain","response::Response","uri::InvalidUriParts","header::map::HashValue","header::map::GetAll","uri::path::PathAndQuery","header::map::Values","uri::builder::Builder","header::name::HeaderName","header::name::MaybeLower","header::map::Links","<&mut T as std::fmt::Debug>","uri::authority::Authority","uri::Parts","header::name::StandardHeader","header::name::InvalidHeaderName","header::map::ValueIter","header::value::ToStrError","request::Request","uri::ErrorKind","header::map::IntoIter","status::StatusCode","header::map::VacantEntry","header::value::HeaderValue","header::map::Link","header::map::HeaderMap","header::map::Entry","header::map::Bucket","header::name::HdrName","version::Version","request::Parts","response::Builder","response::Parts","error::Error","header::map::RawLinks","extensions::Extensions","header::name::Repr","method::Method","uri::scheme::Scheme","header::map::OccupiedEntry","uri::scheme::Scheme2","status::InvalidStatusCode","uri::port::Port","header::map::ValueIterMut","byte_str::ByteStr","request::Builder","header::map::IterMut","uri::Uri","header::map::ValuesMut","header::map::ValueDrain","header::map::Cursor","header::map::ExtraValue","uri::scheme::Protocol","header::map::Keys"]},"header::map::ValueIterMut":{"T":["<*mut T as std::marker::Sync>","header::map::Drain","header::map::IterMut","header::map::ValueDrain","header::map::ValueIterMut","header::map::Iter"]},"header::map::Values":{"T":["header::map::Values","header::map::Keys","uri::path::PathAndQuery","uri::Parts","extensions::Extensions","header::map::HashValue","header::name::StandardHeader","uri::builder::Builder","header::map::OccupiedEntry","uri::scheme::Scheme","response::Builder","version::Version","header::name::HeaderName","header::name::HdrName","header::map::Entry","request::Request","header::name::MaybeLower","uri::port::Port","uri::Uri","header::map::IterMut","header::value::InvalidHeaderValue","header::map::Link","<&T as std::fmt::Debug>","header::map::ExtraValue","method::InvalidMethod","uri::authority::Authority","header::map::HeaderMap","header::map::Bucket","header::map::VacantEntry","uri::scheme::Scheme2","error::Error","byte_str::ByteStr","request::Builder","header::map::ValuesMut","header::map::Links","header::map::RawLinks","header::map::ValueIterMut","uri::InvalidUriParts","response::Parts","request::Parts","header::name::Custom","header::value::ToStrError","header::name::InvalidHeaderName","header::map::Drain","header::map::Iter","header::value::HeaderValue","header::map::ValueIter","uri::scheme::Protocol","header::map::ValueDrain","status::StatusCode","header::name::Repr","uri::InvalidUri","status::InvalidStatusCode","header::map::Cursor","header::map::GetAll","uri::ErrorKind","response::Response","method::Method","header::map::IntoIter"]},"header::map::ValuesMut":{"T":["uri::port::Port","uri::authority::Authority","header::name::HeaderName","version::Version","header::name::Repr","header::map::Bucket","uri::scheme::Scheme2","request::Request","header::map::ValueIterMut","header::map::ValuesMut","header::name::InvalidHeaderName","header::map::Drain","header::map::Iter","error::Error","header::name::MaybeLower","header::value::ToStrError","header::name::StandardHeader","uri::scheme::Protocol","uri::Parts","header::value::InvalidHeaderValue","uri::Uri","status::StatusCode","header::map::ValueIter","header::map::Link","header::map::OccupiedEntry","header::map::IntoIter","uri::scheme::Scheme","byte_str::ByteStr","uri::InvalidUri","header::name::Custom","header::map::Cursor","header::map::GetAll","status::InvalidStatusCode","response::Response","header::map::VacantEntry","header::map::IterMut","header::map::ExtraValue","<*const T as std::fmt::Debug>","response::Builder","header::map::Keys","header::map::HeaderMap","response::Parts","uri::ErrorKind","extensions::Extensions","header::map::RawLinks","uri::builder::Builder","header::name::HdrName","uri::path::PathAndQuery","method::Method","header::map::HashValue","header::map::Entry","uri::InvalidUriParts","header::value::HeaderValue","header::map::Values","method::InvalidMethod","request::Builder","header::map::Links","header::map::ValueDrain","request::Parts"]},"header::name::Repr":{"T":["header::name::Custom","byte_str::ByteStr","header::name::Repr","version::Version","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","header::name::StandardHeader"]},"request::Request":{"T":["uri::builder::Builder","method::Method","response::Builder","request::Builder","request::Request","uri::Parts","response::Response","header::map::HeaderMap","version::Version","status::StatusCode","uri::Uri","extensions::Extensions"]},"response::Response":{"T":["method::Method","extensions::Extensions","uri::Parts","request::Request","response::Builder","response::Response","version::Version","uri::Uri","status::StatusCode","uri::builder::Builder","header::map::HeaderMap","request::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["uri::authority::Authority","<&T as std::fmt::Debug>","method::Method","uri::port::Port","header::value::HeaderValue","uri::scheme::Scheme"]},"uri::scheme::Scheme2":{"T":["std::boxed::Box<byte_str::ByteStr>","byte_str::ByteStr","std::clone::impls::<impl std::clone::Clone for &T>","header::name::Repr","uri::authority::Authority","header::map::Link","uri::scheme::Protocol","header::map::Links","header::name::Custom","header::map::RawLinks","uri::Uri","header::name::HeaderName","header::map::HashValue","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::Bucket","header::map::Cursor","header::map::ExtraValue","header::name::StandardHeader","method::Method","version::Version","header::name::MaybeLower","uri::path::PathAndQuery","status::StatusCode","header::map::HeaderMap","header::value::HeaderValue"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.extend(p1);
+<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend(p0, p1);
+crate::<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend(p0, p1);
+<header::map::HeaderMap<T>>::extend(p0, p1);
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::cmp::PartialEq>::eq
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq":{"T":["std::cmp::PartialEq","std::marker::Sized"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::convert::TryFrom"]},"header::name::Repr":{"T":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::hash::Hash"]},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq":{"T":["header::map::Cursor","header::map::GetAll","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","method::extension::AllocatedExtension","method::extension::InlineExtension","uri::ErrorKind","version::Http","byte_str::ByteStr","header::name::Repr","method::Inner","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","header::name::Custom","header::map::Link","header::name::StandardHeader","header::map::HashValue","header::map::HeaderMap","version::Version"]},"header::map::GetAll":{"T":["header::map::Link","header::name::Repr","header::map::HashValue","header::name::StandardHeader","header::map::HeaderMap","header::map::GetAll","byte_str::ByteStr","version::Version","<*const T as std::fmt::Debug>","header::name::Custom","header::map::Cursor","uri::ErrorKind"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::name::Repr":{"T":["header::name::Custom","byte_str::ByteStr","std::hash::impls::<impl std::hash::Hash for *const T>","version::Version","header::name::Repr","header::name::StandardHeader"]},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.eq(p1);
+<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq(p0, p1);
+<header::map::HeaderMap<T>>::eq(p0, p1);
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::HeaderMap<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::IterMut":{"T":["std::marker::Sync","std::marker::Send","std::marker::Sized","std::fmt::Debug"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::marker::Sync","std::marker::Sized","std::marker::Send","std::fmt::Debug"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::hash::Hash","std::marker::Sized","std::cmp::Eq"]},"request::Request":{"T":["std::default::Default","std::fmt::Debug","std::marker::Sized"]},"response::Response":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::map::HeaderMap<T> as std::fmt::Debug>::fmt":{"T":["request::Request","uri::path::PathAndQuery","header::map::IntoIter","header::name::MaybeLower","header::value::ToStrError","header::map::ExtraValue","status::StatusCode","uri::scheme::Protocol","header::map::HashValue","header::name::InvalidHeaderName","<&T as std::fmt::Debug>","status::InvalidStatusCode","uri::port::Port","error::Error","uri::authority::Authority","header::value::HeaderValue","uri::InvalidUriParts","response::Response","header::map::ValueIter","header::name::StandardHeader","header::map::Entry","header::map::Bucket","header::map::IterMut","uri::ErrorKind","uri::Parts","request::Parts","header::map::ValueDrain","header::map::OccupiedEntry","header::map::HeaderMap","uri::Uri","version::Version","header::name::HdrName","header::map::ValueIterMut","header::map::Link","response::Builder","response::Parts","header::name::Custom","header::map::Keys","header::map::Cursor","method::Method","header::name::HeaderName","header::map::GetAll","byte_str::ByteStr","header::map::Iter","<&mut T as std::fmt::Debug>","uri::scheme::Scheme2","header::map::Values","uri::scheme::Scheme","uri::InvalidUri","header::map::ValuesMut","header::name::Repr","extensions::Extensions","request::Builder","header::value::InvalidHeaderValue","header::map::RawLinks","uri::builder::Builder","header::map::VacantEntry","header::map::Links","header::map::Drain","method::InvalidMethod"]},"header::map::Bucket":{"T":["header::map::Link","status::StatusCode","byte_str::ByteStr","uri::Uri","header::map::ExtraValue","uri::scheme::Scheme2","header::name::Repr","header::value::HeaderValue","header::map::Bucket","uri::scheme::Scheme","header::map::Cursor","header::name::MaybeLower","method::Method","header::name::HeaderName","version::Version","<&T as std::fmt::Debug>","header::map::HeaderMap","uri::authority::Authority","header::map::RawLinks","uri::scheme::Protocol","header::map::HashValue","header::name::Custom","header::name::StandardHeader","uri::path::PathAndQuery","header::map::Links"]},"header::map::Drain":{"T":["header::map::ValueIterMut","header::map::IterMut","header::map::Iter","header::map::ValueDrain","header::map::Drain","<*const T as std::marker::Send>"]},"header::map::Entry":{"T":["header::map::Iter","header::map::Keys","uri::scheme::Scheme","header::map::Cursor","header::name::HeaderName","header::name::StandardHeader","uri::Parts","header::map::HeaderMap","header::name::InvalidHeaderName","response::Parts","response::Response","header::value::ToStrError","header::map::Values","request::Parts","uri::InvalidUri","header::map::ValueIterMut","header::map::ValueIter","header::map::Bucket","method::Method","error::Error","uri::port::Port","uri::ErrorKind","uri::path::PathAndQuery","header::value::HeaderValue","uri::builder::Builder","header::map::RawLinks","uri::Uri","status::StatusCode","<&T as std::fmt::Debug>","header::map::Links","header::name::MaybeLower","header::name::HdrName","header::map::Drain","uri::InvalidUriParts","header::map::ValueDrain","uri::scheme::Protocol","header::map::ExtraValue","header::map::Link","header::name::Repr","uri::authority::Authority","header::map::VacantEntry","extensions::Extensions","status::InvalidStatusCode","header::map::ValuesMut","header::map::IntoIter","header::name::Custom","header::map::GetAll","request::Builder","header::value::InvalidHeaderValue","byte_str::ByteStr","uri::scheme::Scheme2","header::map::IterMut","header::map::HashValue","response::Builder","header::map::Entry","request::Request","header::map::OccupiedEntry","version::Version","method::InvalidMethod"]},"header::map::ExtraValue":{"T":["header::map::HashValue","header::map::Link","uri::scheme::Scheme2","byte_str::ByteStr","header::map::RawLinks","header::name::StandardHeader","header::map::Bucket","header::value::HeaderValue","uri::authority::Authority","header::map::Links","header::map::Cursor","header::map::ExtraValue","uri::path::PathAndQuery","header::name::MaybeLower","version::Version","method::Method","<*const T as std::fmt::Debug>","header::name::Repr","uri::Uri","uri::scheme::Protocol","status::StatusCode","header::name::Custom","header::map::HeaderMap","header::name::HeaderName","uri::scheme::Scheme"]},"header::map::GetAll":{"T":["version::Version","header::name::Repr","header::name::Custom","<*const T as std::fmt::Debug>","header::map::GetAll","byte_str::ByteStr","header::map::HeaderMap","header::map::Link","uri::ErrorKind","header::map::HashValue","header::name::StandardHeader","header::map::Cursor"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::name::InvalidHeaderName","status::InvalidStatusCode","header::map::GetAll","version::Version","header::map::ValueIter","header::map::OccupiedEntry","method::Method","header::name::HdrName","response::Response","header::map::Link","uri::port::Port","header::map::IterMut","uri::scheme::Protocol","header::map::Links","header::map::RawLinks","header::name::StandardHeader","uri::builder::Builder","uri::Uri","header::map::Values","error::Error","uri::authority::Authority","header::map::Drain","header::map::HeaderMap","uri::Parts","header::map::Bucket","header::value::ToStrError","header::name::MaybeLower","method::InvalidMethod","status::StatusCode","uri::scheme::Scheme2","request::Parts","header::map::VacantEntry","extensions::Extensions","header::map::Iter","request::Builder","header::value::HeaderValue","header::map::ExtraValue","header::map::ValuesMut","header::map::HashValue","header::value::InvalidHeaderValue","header::map::IntoIter","uri::InvalidUriParts","header::name::HeaderName","<&T as std::fmt::Debug>","response::Parts","header::map::ValueDrain","uri::InvalidUri","response::Builder","uri::scheme::Scheme","header::map::Keys","header::name::Custom","header::map::ValueIterMut","uri::path::PathAndQuery","uri::ErrorKind","byte_str::ByteStr","request::Request","header::name::Repr","header::map::Entry","header::map::Cursor"]},"header::map::Iter":{"T":["header::map::ValueIterMut","header::map::ValueDrain","<*mut T as std::marker::Sync>","header::map::Iter","header::map::IterMut","header::map::Drain"]},"header::map::IterMut":{"T":["header::map::IterMut","header::map::Drain","<*const T as std::fmt::Debug>","header::map::ValueDrain","header::map::ValueIterMut","header::map::Iter"]},"header::map::Keys":{"T":["header::map::VacantEntry","uri::scheme::Scheme","header::map::OccupiedEntry","header::name::HeaderName","uri::Parts","header::map::ValueDrain","uri::ErrorKind","uri::port::Port","header::map::IterMut","uri::InvalidUri","uri::builder::Builder","status::InvalidStatusCode","header::map::ValueIter","header::map::IntoIter","header::name::HdrName","header::map::Links","response::Parts","header::map::Entry","response::Response","header::map::ValuesMut","version::Version","header::map::RawLinks","header::map::Iter","header::value::ToStrError","uri::Uri","header::map::HashValue","header::map::Keys","header::map::Bucket","header::value::InvalidHeaderValue","header::map::HeaderMap","uri::path::PathAndQuery","header::map::Values","header::map::ValueIterMut","uri::authority::Authority","uri::scheme::Protocol","header::map::Drain","header::value::HeaderValue","header::name::MaybeLower","header::name::StandardHeader","request::Builder","request::Request","extensions::Extensions","header::map::Link","byte_str::ByteStr","header::name::InvalidHeaderName","response::Builder","uri::InvalidUriParts","header::map::ExtraValue","error::Error","<&mut T as std::fmt::Debug>","method::InvalidMethod","header::name::Repr","uri::scheme::Scheme2","request::Parts","status::StatusCode","header::map::Cursor","header::map::GetAll","method::Method","header::name::Custom"]},"header::map::OccupiedEntry":{"T":["uri::Uri","header::map::IntoIter","header::name::InvalidHeaderName","response::Response","uri::scheme::Scheme2","header::map::Iter","uri::scheme::Scheme","request::Parts","header::map::VacantEntry","header::name::MaybeLower","header::name::Repr","uri::InvalidUriParts","uri::port::Port","header::map::Link","header::map::Keys","header::name::StandardHeader","uri::ErrorKind","header::map::OccupiedEntry","uri::authority::Authority","header::value::ToStrError","status::InvalidStatusCode","header::map::ValueIter","header::value::HeaderValue","header::map::Drain","method::Method","uri::InvalidUri","header::map::HashValue","header::map::Bucket","status::StatusCode","version::Version","header::map::IterMut","uri::scheme::Protocol","header::map::Entry","extensions::Extensions","uri::builder::Builder","header::value::InvalidHeaderValue","header::map::ValueDrain","<*mut T as std::fmt::Debug>","response::Parts","header::map::Values","request::Request","method::InvalidMethod","header::map::Cursor","byte_str::ByteStr","header::name::HdrName","header::map::ValuesMut","request::Builder","header::map::ExtraValue","header::map::RawLinks","header::map::GetAll","header::name::HeaderName","response::Builder","error::Error","header::map::Links","header::name::Custom","uri::path::PathAndQuery","header::map::ValueIterMut","uri::Parts","header::map::HeaderMap"]},"header::map::RawLinks":{"T":["request::Builder","header::value::InvalidHeaderValue","header::map::RawLinks","header::map::Iter","response::Builder","response::Response","uri::scheme::Scheme2","uri::InvalidUri","method::Method","method::InvalidMethod","header::map::Bucket","header::map::ValuesMut","request::Parts","byte_str::ByteStr","header::map::Cursor","status::StatusCode","header::name::HeaderName","header::map::ExtraValue","<&mut T as std::fmt::Debug>","header::name::Repr","header::map::Values","version::Version","header::map::ValueDrain","header::map::VacantEntry","status::InvalidStatusCode","uri::Parts","response::Parts","uri::scheme::Protocol","header::map::OccupiedEntry","uri::Uri","uri::builder::Builder","uri::path::PathAndQuery","header::name::InvalidHeaderName","header::map::GetAll","header::map::ValueIter","header::map::Keys","header::map::Entry","uri::InvalidUriParts","header::map::HeaderMap","header::name::HdrName","header::map::IntoIter","header::map::ValueIterMut","uri::port::Port","uri::scheme::Scheme","header::value::ToStrError","uri::ErrorKind","header::map::IterMut","header::map::Link","header::map::Links","header::name::StandardHeader","request::Request","uri::authority::Authority","header::name::Custom","error::Error","header::map::Drain","header::value::HeaderValue","header::map::HashValue","extensions::Extensions","header::name::MaybeLower"]},"header::map::VacantEntry":{"T":["header::map::OccupiedEntry","header::map::Cursor","header::map::ValueIter","header::map::ValueIterMut","uri::ErrorKind","header::map::GetAll","header::map::IterMut","header::map::ExtraValue","header::name::Repr","uri::authority::Authority","method::InvalidMethod","uri::Uri","version::Version","extensions::Extensions","uri::InvalidUriParts","response::Parts","header::map::Iter","header::name::StandardHeader","request::Request","status::InvalidStatusCode","header::value::HeaderValue","error::Error","header::map::ValueDrain","header::map::ValuesMut","uri::InvalidUri","header::value::InvalidHeaderValue","header::map::Bucket","uri::scheme::Scheme","header::value::ToStrError","<&T as std::fmt::Debug>","uri::scheme::Scheme2","header::map::HeaderMap","status::StatusCode","header::map::IntoIter","response::Response","header::name::InvalidHeaderName","header::map::Values","uri::path::PathAndQuery","uri::port::Port","request::Builder","header::map::Link","uri::Parts","method::Method","header::map::Drain","header::name::MaybeLower","header::map::VacantEntry","header::map::Keys","header::name::HeaderName","response::Builder","header::map::RawLinks","uri::scheme::Protocol","header::map::Entry","header::map::HashValue","request::Parts","header::name::Custom","header::name::HdrName","header::map::Links","byte_str::ByteStr","uri::builder::Builder"]},"header::map::ValueDrain":{"T":["header::map::ValueDrain","header::map::IterMut","header::map::Iter","header::map::Drain","<*const T as std::marker::Sync>","header::map::ValueIterMut"]},"header::map::ValueIter":{"T":["response::Response","byte_str::ByteStr","uri::ErrorKind","header::map::Values","header::map::ValueDrain","header::value::HeaderValue","header::name::Repr","uri::builder::Builder","header::map::ExtraValue","header::name::Custom","header::map::Link","<*const T as std::fmt::Debug>","error::Error","response::Parts","status::InvalidStatusCode","header::map::Links","header::map::OccupiedEntry","header::name::HeaderName","header::name::MaybeLower","header::map::Drain","header::value::InvalidHeaderValue","header::map::Bucket","header::map::ValueIterMut","header::map::GetAll","header::map::IntoIter","header::map::Keys","method::Method","header::map::IterMut","uri::scheme::Scheme2","header::map::ValuesMut","extensions::Extensions","header::name::InvalidHeaderName","header::map::Iter","uri::authority::Authority","header::map::VacantEntry","request::Parts","request::Request","uri::scheme::Protocol","request::Builder","uri::path::PathAndQuery","header::map::HashValue","response::Builder","uri::Uri","method::InvalidMethod","uri::port::Port","version::Version","uri::InvalidUriParts","header::value::ToStrError","header::name::StandardHeader","uri::Parts","header::map::ValueIter","header::map::Cursor","header::map::Entry","header::map::RawLinks","header::map::HeaderMap","uri::InvalidUri","status::StatusCode","header::name::HdrName","uri::scheme::Scheme"]},"header::map::ValueIterMut":{"T":["header::map::IterMut","header::map::Drain","header::map::Iter","<*mut T as std::fmt::Debug>","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::Values":{"T":["header::map::Values","header::map::GetAll","uri::path::PathAndQuery","request::Parts","error::Error","header::map::Cursor","version::Version","header::map::VacantEntry","uri::Uri","header::map::Entry","request::Request","header::map::ValueIter","header::name::HeaderName","uri::InvalidUri","header::map::Keys","response::Parts","header::map::HeaderMap","header::name::StandardHeader","status::InvalidStatusCode","uri::port::Port","header::map::RawLinks","method::InvalidMethod","header::name::InvalidHeaderName","uri::scheme::Scheme","header::map::Drain","header::map::IntoIter","header::map::OccupiedEntry","method::Method","header::map::ValueDrain","header::map::ExtraValue","uri::builder::Builder","header::value::InvalidHeaderValue","response::Response","header::map::Iter","extensions::Extensions","header::value::ToStrError","uri::InvalidUriParts","<&mut T as std::fmt::Debug>","header::map::ValuesMut","request::Builder","uri::Parts","header::name::Repr","status::StatusCode","header::name::Custom","header::map::IterMut","uri::ErrorKind","uri::authority::Authority","header::map::Bucket","uri::scheme::Protocol","header::map::HashValue","header::map::ValueIterMut","byte_str::ByteStr","header::map::Link","uri::scheme::Scheme2","header::map::Links","header::value::HeaderValue","response::Builder","header::name::MaybeLower","header::name::HdrName"]},"header::map::ValuesMut":{"T":["header::map::Cursor","header::name::InvalidHeaderName","header::map::IntoIter","header::map::OccupiedEntry","header::map::Entry","uri::authority::Authority","header::name::HdrName","uri::builder::Builder","uri::ErrorKind","response::Builder","header::value::ToStrError","header::name::Repr","error::Error","uri::Parts","header::map::ExtraValue","request::Builder","uri::Uri","response::Parts","status::StatusCode","response::Response","method::InvalidMethod","method::Method","uri::scheme::Scheme","version::Version","header::value::HeaderValue","header::map::Bucket","header::map::Links","<*const T as std::fmt::Debug>","header::name::StandardHeader","extensions::Extensions","uri::path::PathAndQuery","header::map::Values","uri::port::Port","header::map::IterMut","header::map::ValuesMut","header::map::RawLinks","uri::scheme::Scheme2","header::name::Custom","status::InvalidStatusCode","header::map::Drain","request::Request","uri::InvalidUri","byte_str::ByteStr","header::map::ValueDrain","header::map::ValueIterMut","uri::InvalidUriParts","header::name::HeaderName","header::map::Iter","header::value::InvalidHeaderValue","header::map::Keys","header::map::HashValue","header::map::ValueIter","header::map::GetAll","header::map::HeaderMap","uri::scheme::Protocol","request::Parts","header::name::MaybeLower","header::map::Link","header::map::VacantEntry"]},"header::name::Repr":{"T":["byte_str::ByteStr","version::Version","header::name::Repr","header::name::StandardHeader","header::name::Custom","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"request::Request":{"T":["request::Builder","response::Builder","method::Method","uri::Uri","extensions::Extensions","response::Response","uri::builder::Builder","uri::Parts","version::Version","status::StatusCode","header::map::HeaderMap","request::Request"]},"response::Response":{"T":["header::map::HeaderMap","extensions::Extensions","method::Method","request::Builder","uri::Uri","status::StatusCode","response::Response","uri::Parts","response::Builder","version::Version","request::Request","uri::builder::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"uri::port::Port":{"T":["header::value::HeaderValue","uri::authority::Authority","<&mut T as std::convert::AsRef<U>>","uri::scheme::Scheme","uri::port::Port","method::Method"]},"uri::scheme::Scheme2":{"T":["header::map::Links","<*const T as std::fmt::Debug>","header::name::Custom","status::StatusCode","header::value::HeaderValue","header::name::MaybeLower","header::map::Cursor","uri::scheme::Scheme","byte_str::ByteStr","uri::Uri","header::name::HeaderName","header::map::RawLinks","header::name::Repr","version::Version","header::name::StandardHeader","header::map::Link","header::map::ExtraValue","uri::scheme::Protocol","uri::scheme::Scheme2","header::map::HeaderMap","uri::authority::Authority","std::boxed::Box<byte_str::ByteStr>","header::map::HashValue","header::map::Bucket","method::Method","uri::path::PathAndQuery"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::map::HeaderMap<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::map::HeaderMap<T> as std::fmt::Debug>::fmt(p0, p1);
+<header::map::HeaderMap<T>>::fmt(p0, p1);
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::default::Default>::default
deps:{"<header::map::HeaderMap<T> as std::default::Default>::default":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::HeaderMap<T> as std::default::Default>::default":{"T":["RUG_ANY"]}}
+<header::map::HeaderMap<T> as std::default::Default>::default();
+crate::<header::map::HeaderMap<T> as std::default::Default>::default();
+<header::map::HeaderMap<T>>::default();
-----------------
src/header/map.rs <header::map::HeaderMap<T> as std::ops::Index<K>>::index
'a
deps:{"<header::map::HeaderMap<T> as std::ops::Index<K>>::index":{"K":["header::map::as_header_name::AsHeaderName","std::marker::Sized"],"T":["std::marker::Sized"]}}
candidates:{"<header::map::HeaderMap<T> as std::ops::Index<K>>::index":{"K":["header::name::HeaderName","std::string::String"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.index(p1);
+<header::map::HeaderMap<T> as std::ops::Index<K>>::index(p0, p1);
+crate::<header::map::HeaderMap<T> as std::ops::Index<K>>::index(p0, p1);
+<header::map::HeaderMap<T>>::index(p0, p1);
-----------------
src/header/map.rs <header::map::Iter<'a, T> as std::iter::Iterator>::next
'a
deps:{"<header::map::Iter<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::Iter<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::Iter<'a, T>
+p0.next();
+<header::map::Iter<'a, T> as std::iter::Iterator>::next(p0);
+crate::<header::map::Iter<'a, T> as std::iter::Iterator>::next(p0);
+<header::map::Iter<'a, T>>::next(p0);
-----------------
src/header/map.rs <header::map::Iter<'a, T> as std::iter::Iterator>::size_hint
'a
deps:{"<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Iter<'a, T>
+p0.size_hint();
+<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint(p0);
+crate::<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint(p0);
+<header::map::Iter<'a, T>>::size_hint(p0);
-----------------
src/header/map.rs header::map::IterMut::<'a, T>::next_unsafe
'a
deps:{"header::map::IterMut::<'a, T>::next_unsafe":{"T":["std::marker::Sized"]}}
candidates:{"header::map::IterMut::<'a, T>::next_unsafe":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::IterMut<'a, T>
+p0.next_unsafe();
+header::map::IterMut::<'a, T>::next_unsafe(p0);
+crate::header::map::IterMut::<'a, T>::next_unsafe(p0);
+<header::map::IterMut<'a, T>>::next_unsafe(p0);
-----------------
src/header/map.rs <header::map::IterMut<'a, T> as std::iter::Iterator>::next
'a
deps:{"<header::map::IterMut<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::IterMut<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::IterMut<'a, T>
+p0.next();
+<header::map::IterMut<'a, T> as std::iter::Iterator>::next(p0);
+crate::<header::map::IterMut<'a, T> as std::iter::Iterator>::next(p0);
+<header::map::IterMut<'a, T>>::next(p0);
-----------------
src/header/map.rs <header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint
'a
deps:{"<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::IterMut<'a, T>
+p0.size_hint();
+<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint(p0);
+crate::<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint(p0);
+<header::map::IterMut<'a, T>>::size_hint(p0);
-----------------
src/header/map.rs <header::map::Keys<'a, T> as std::iter::Iterator>::next
'a
deps:{"<header::map::Keys<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::Keys<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::Keys<'a, T>
+p0.next();
+<header::map::Keys<'a, T> as std::iter::Iterator>::next(p0);
+crate::<header::map::Keys<'a, T> as std::iter::Iterator>::next(p0);
+<header::map::Keys<'a, T>>::next(p0);
-----------------
src/header/map.rs <header::map::Keys<'a, T> as std::iter::Iterator>::size_hint
'a
deps:{"<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Keys<'a, T>
+p0.size_hint();
+<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint(p0);
+crate::<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint(p0);
+<header::map::Keys<'a, T>>::size_hint(p0);
-----------------
src/header/map.rs <header::map::Values<'a, T> as std::iter::Iterator>::next
'a
deps:{"<header::map::Values<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::Values<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::Values<'a, T>
+p0.next();
+<header::map::Values<'a, T> as std::iter::Iterator>::next(p0);
+crate::<header::map::Values<'a, T> as std::iter::Iterator>::next(p0);
+<header::map::Values<'a, T>>::next(p0);
-----------------
src/header/map.rs <header::map::Values<'a, T> as std::iter::Iterator>::size_hint
'a
deps:{"<header::map::Values<'a, T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::Values<'a, T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Values<'a, T>
+p0.size_hint();
+<header::map::Values<'a, T> as std::iter::Iterator>::size_hint(p0);
+crate::<header::map::Values<'a, T> as std::iter::Iterator>::size_hint(p0);
+<header::map::Values<'a, T>>::size_hint(p0);
-----------------
src/header/map.rs <header::map::ValuesMut<'a, T> as std::iter::Iterator>::next
'a
deps:{"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::ValuesMut<'a, T>
+p0.next();
+<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next(p0);
+crate::<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next(p0);
+<header::map::ValuesMut<'a, T>>::next(p0);
-----------------
src/header/map.rs <header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint
'a
deps:{"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::ValuesMut<'a, T>
+p0.size_hint();
+<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint(p0);
+crate::<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint(p0);
+<header::map::ValuesMut<'a, T>>::size_hint(p0);
-----------------
src/header/map.rs <header::map::Drain<'a, T> as std::iter::Iterator>::next
'a
deps:{"<header::map::Drain<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::Drain<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::Drain<'a, T>
+p0.next();
+<header::map::Drain<'a, T> as std::iter::Iterator>::next(p0);
+crate::<header::map::Drain<'a, T> as std::iter::Iterator>::next(p0);
+<header::map::Drain<'a, T>>::next(p0);
-----------------
src/header/map.rs <header::map::Drain<'a, T> as std::iter::Iterator>::size_hint
'a
deps:{"<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Drain<'a, T>
+p0.size_hint();
+<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint(p0);
+crate::<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint(p0);
+<header::map::Drain<'a, T>>::size_hint(p0);
-----------------
src/header/map.rs <header::map::Drain<'a, T> as std::ops::Drop>::drop
'a
deps:{"<header::map::Drain<'a, T> as std::ops::Drop>::drop":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::Drain<'a, T> as std::ops::Drop>::drop":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::Drain<'a, T>
+p0.drop();
+<header::map::Drain<'a, T> as std::ops::Drop>::drop(p0);
+crate::<header::map::Drain<'a, T> as std::ops::Drop>::drop(p0);
+<header::map::Drain<'a, T>>::drop(p0);
-----------------
src/header/map.rs header::map::Entry::<'a, T>::or_insert
'a
deps:{"header::map::Entry::<'a, T>::or_insert":{"T":["std::marker::Sized"]}}
candidates:{"header::map::Entry::<'a, T>::or_insert":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::Entry<'a, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.or_insert(p1);
+header::map::Entry::<'a, T>::or_insert(p0, p1);
+crate::header::map::Entry::<'a, T>::or_insert(p0, p1);
+<header::map::Entry<'a, T>>::or_insert(p0, p1);
-----------------
src/header/map.rs header::map::Entry::<'a, T>::or_insert_with
'a
deps:{"header::map::Entry::<'a, T>::or_insert_with":{"F":["std::ops::FnOnce","std::marker::Sized"],"T":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"header::map::Entry::<'a, T>::or_insert_with":{"F":["core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>"],"T":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::Entry<'a, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.or_insert_with(p1);
+header::map::Entry::<'a, T>::or_insert_with(p0, p1);
+crate::header::map::Entry::<'a, T>::or_insert_with(p0, p1);
+<header::map::Entry<'a, T>>::or_insert_with(p0, p1);
-----------------
src/header/map.rs header::map::Entry::<'a, T>::key
'a
deps:{"header::map::Entry::<'a, T>::key":{"T":["std::marker::Sized"]}}
candidates:{"header::map::Entry::<'a, T>::key":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Entry<'a, T>
+p0.key();
+header::map::Entry::<'a, T>::key(p0);
+crate::header::map::Entry::<'a, T>::key(p0);
+<header::map::Entry<'a, T>>::key(p0);
-----------------
src/header/map.rs header::map::VacantEntry::<'a, T>::key
'a
deps:{"header::map::VacantEntry::<'a, T>::key":{"T":["std::marker::Sized"]}}
candidates:{"header::map::VacantEntry::<'a, T>::key":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::VacantEntry<'a, T>
+p0.key();
+header::map::VacantEntry::<'a, T>::key(p0);
+crate::header::map::VacantEntry::<'a, T>::key(p0);
+<header::map::VacantEntry<'a, T>>::key(p0);
-----------------
src/header/map.rs header::map::VacantEntry::<'a, T>::into_key
'a
deps:{"header::map::VacantEntry::<'a, T>::into_key":{"T":["std::marker::Sized"]}}
candidates:{"header::map::VacantEntry::<'a, T>::into_key":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::VacantEntry<'a, T>
+p0.into_key();
+header::map::VacantEntry::<'a, T>::into_key(p0);
+crate::header::map::VacantEntry::<'a, T>::into_key(p0);
+<header::map::VacantEntry<'a, T>>::into_key(p0);
-----------------
src/header/map.rs header::map::VacantEntry::<'a, T>::insert
'a
deps:{"header::map::VacantEntry::<'a, T>::insert":{"T":["std::marker::Sized"]}}
candidates:{"header::map::VacantEntry::<'a, T>::insert":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::VacantEntry<'a, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1);
+header::map::VacantEntry::<'a, T>::insert(p0, p1);
+crate::header::map::VacantEntry::<'a, T>::insert(p0, p1);
+<header::map::VacantEntry<'a, T>>::insert(p0, p1);
-----------------
src/header/map.rs header::map::VacantEntry::<'a, T>::insert_entry
'a
deps:{"header::map::VacantEntry::<'a, T>::insert_entry":{"T":["std::marker::Sized"]}}
candidates:{"header::map::VacantEntry::<'a, T>::insert_entry":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::VacantEntry<'a, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.insert_entry(p1);
+header::map::VacantEntry::<'a, T>::insert_entry(p0, p1);
+crate::header::map::VacantEntry::<'a, T>::insert_entry(p0, p1);
+<header::map::VacantEntry<'a, T>>::insert_entry(p0, p1);
-----------------
src/header/map.rs header::map::GetAll::<'a, T>::iter
'a
deps:{"header::map::GetAll::<'a, T>::iter":{"T":["std::marker::Sized"]}}
candidates:{"header::map::GetAll::<'a, T>::iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::GetAll<'a, T>
+p0.iter();
+header::map::GetAll::<'a, T>::iter(p0);
+crate::header::map::GetAll::<'a, T>::iter(p0);
+<header::map::GetAll<'a, T>>::iter(p0);
-----------------
src/header/map.rs <header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq
'a
deps:{"<*const T as std::fmt::Debug>":{},"<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq":{"T":["std::marker::Sized","std::cmp::PartialEq"]},"header::map::GetAll":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::convert::TryFrom","std::marker::Sized"]},"header::name::Repr":{"T":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::fmt::Debug"]},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq":{"T":["byte_str::ByteStr","header::name::Custom","header::map::Cursor","header::map::HashValue","version::Version","header::map::GetAll","header::name::StandardHeader","header::map::Link","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::map::HeaderMap","method::extension::InlineExtension","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","version::Http","uri::ErrorKind","method::Inner","header::name::Repr","method::extension::AllocatedExtension"]},"header::map::GetAll":{"T":["header::map::HeaderMap","std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>","uri::ErrorKind","version::Version","header::name::StandardHeader","header::map::GetAll","header::name::Repr","byte_str::ByteStr","header::map::Cursor","header::map::HashValue","header::name::Custom","header::map::Link"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::name::Repr":{"T":["byte_str::ByteStr","version::Version","std::hash::impls::<impl std::hash::Hash for *const T>","header::name::Repr","header::name::StandardHeader","header::name::Custom"]},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::GetAll<'a, T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::GetAll<'a, T>
+p0.eq(p1);
+<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq(p0, p1);
+<header::map::GetAll<'a, T>>::eq(p0, p1);
-----------------
src/header/map.rs <header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::GetAll<'a, T>
+p0.into_iter();
+<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+<header::map::GetAll<'a, T>>::into_iter(p0);
-----------------
src/header/map.rs <&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter
'a,'b
deps:{"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::GetAll<'a, T>
+p0.into_iter();
+<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+<&'b header::map::GetAll<'a, T>>::into_iter(p0);
-----------------
src/header/map.rs <header::map::ValueIter<'a, T> as std::iter::Iterator>::next
'a
deps:{"<header::map::ValueIter<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValueIter<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::ValueIter<'a, T>
+p0.next();
+<header::map::ValueIter<'a, T> as std::iter::Iterator>::next(p0);
+crate::<header::map::ValueIter<'a, T> as std::iter::Iterator>::next(p0);
+<header::map::ValueIter<'a, T>>::next(p0);
-----------------
src/header/map.rs <header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint
'a
deps:{"<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::ValueIter<'a, T>
+p0.size_hint();
+<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint(p0);
+crate::<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint(p0);
+<header::map::ValueIter<'a, T>>::size_hint(p0);
-----------------
src/header/map.rs <header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{"<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::ValueIter<'a, T>
+p0.next_back();
+<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back(p0);
+<header::map::ValueIter<'a, T>>::next_back(p0);
-----------------
src/header/map.rs <header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next
'a
deps:{"<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::ValueIterMut<'a, T>
+p0.next();
+<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next(p0);
+crate::<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next(p0);
+<header::map::ValueIterMut<'a, T>>::next(p0);
-----------------
src/header/map.rs <header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{"<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::ValueIterMut<'a, T>
+p0.next_back();
+<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back(p0);
+<header::map::ValueIterMut<'a, T>>::next_back(p0);
-----------------
src/header/map.rs <header::map::IntoIter<T> as std::iter::Iterator>::next
deps:{"<header::map::IntoIter<T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::IntoIter<T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::IntoIter<T>
+p0.next();
+<header::map::IntoIter<T> as std::iter::Iterator>::next(p0);
+crate::<header::map::IntoIter<T> as std::iter::Iterator>::next(p0);
+<header::map::IntoIter<T>>::next(p0);
-----------------
src/header/map.rs <header::map::IntoIter<T> as std::iter::Iterator>::size_hint
deps:{"<header::map::IntoIter<T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::IntoIter<T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::IntoIter<T>
+p0.size_hint();
+<header::map::IntoIter<T> as std::iter::Iterator>::size_hint(p0);
+crate::<header::map::IntoIter<T> as std::iter::Iterator>::size_hint(p0);
+<header::map::IntoIter<T>>::size_hint(p0);
-----------------
src/header/map.rs <header::map::IntoIter<T> as std::ops::Drop>::drop
deps:{"<header::map::IntoIter<T> as std::ops::Drop>::drop":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::IntoIter<T> as std::ops::Drop>::drop":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::IntoIter<T>
+p0.drop();
+<header::map::IntoIter<T> as std::ops::Drop>::drop(p0);
+crate::<header::map::IntoIter<T> as std::ops::Drop>::drop(p0);
+<header::map::IntoIter<T>>::drop(p0);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::key
'a
deps:{"header::map::OccupiedEntry::<'a, T>::key":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::key":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.key();
+header::map::OccupiedEntry::<'a, T>::key(p0);
+crate::header::map::OccupiedEntry::<'a, T>::key(p0);
+<header::map::OccupiedEntry<'a, T>>::key(p0);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::get
'a
deps:{"header::map::OccupiedEntry::<'a, T>::get":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::get":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.get();
+header::map::OccupiedEntry::<'a, T>::get(p0);
+crate::header::map::OccupiedEntry::<'a, T>::get(p0);
+<header::map::OccupiedEntry<'a, T>>::get(p0);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::get_mut
'a
deps:{"header::map::OccupiedEntry::<'a, T>::get_mut":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::get_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.get_mut();
+header::map::OccupiedEntry::<'a, T>::get_mut(p0);
+crate::header::map::OccupiedEntry::<'a, T>::get_mut(p0);
+<header::map::OccupiedEntry<'a, T>>::get_mut(p0);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::into_mut
'a
deps:{"header::map::OccupiedEntry::<'a, T>::into_mut":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::into_mut":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.into_mut();
+header::map::OccupiedEntry::<'a, T>::into_mut(p0);
+crate::header::map::OccupiedEntry::<'a, T>::into_mut(p0);
+<header::map::OccupiedEntry<'a, T>>::into_mut(p0);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::insert
'a
deps:{"header::map::OccupiedEntry::<'a, T>::insert":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::insert":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1);
+header::map::OccupiedEntry::<'a, T>::insert(p0, p1);
+crate::header::map::OccupiedEntry::<'a, T>::insert(p0, p1);
+<header::map::OccupiedEntry<'a, T>>::insert(p0, p1);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::insert_mult
'a
deps:{"header::map::OccupiedEntry::<'a, T>::insert_mult":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::insert_mult":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.insert_mult(p1);
+header::map::OccupiedEntry::<'a, T>::insert_mult(p0, p1);
+crate::header::map::OccupiedEntry::<'a, T>::insert_mult(p0, p1);
+<header::map::OccupiedEntry<'a, T>>::insert_mult(p0, p1);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::append
'a
deps:{"header::map::OccupiedEntry::<'a, T>::append":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::append":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.append(p1);
+header::map::OccupiedEntry::<'a, T>::append(p0, p1);
+crate::header::map::OccupiedEntry::<'a, T>::append(p0, p1);
+<header::map::OccupiedEntry<'a, T>>::append(p0, p1);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::remove
'a
deps:{"header::map::OccupiedEntry::<'a, T>::remove":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::remove":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.remove();
+header::map::OccupiedEntry::<'a, T>::remove(p0);
+crate::header::map::OccupiedEntry::<'a, T>::remove(p0);
+<header::map::OccupiedEntry<'a, T>>::remove(p0);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::remove_entry
'a
deps:{"header::map::OccupiedEntry::<'a, T>::remove_entry":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::remove_entry":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.remove_entry();
+header::map::OccupiedEntry::<'a, T>::remove_entry(p0);
+crate::header::map::OccupiedEntry::<'a, T>::remove_entry(p0);
+<header::map::OccupiedEntry<'a, T>>::remove_entry(p0);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::remove_entry_mult
'a
deps:{"header::map::OccupiedEntry::<'a, T>::remove_entry_mult":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::remove_entry_mult":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.remove_entry_mult();
+header::map::OccupiedEntry::<'a, T>::remove_entry_mult(p0);
+crate::header::map::OccupiedEntry::<'a, T>::remove_entry_mult(p0);
+<header::map::OccupiedEntry<'a, T>>::remove_entry_mult(p0);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::iter
'a
deps:{"header::map::OccupiedEntry::<'a, T>::iter":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.iter();
+header::map::OccupiedEntry::<'a, T>::iter(p0);
+crate::header::map::OccupiedEntry::<'a, T>::iter(p0);
+<header::map::OccupiedEntry<'a, T>>::iter(p0);
-----------------
src/header/map.rs header::map::OccupiedEntry::<'a, T>::iter_mut
'a
deps:{"header::map::OccupiedEntry::<'a, T>::iter_mut":{"T":["std::marker::Sized"]}}
candidates:{"header::map::OccupiedEntry::<'a, T>::iter_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.iter_mut();
+header::map::OccupiedEntry::<'a, T>::iter_mut(p0);
+crate::header::map::OccupiedEntry::<'a, T>::iter_mut(p0);
+<header::map::OccupiedEntry<'a, T>>::iter_mut(p0);
-----------------
src/header/map.rs <header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter
'a
deps:{"<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.into_iter();
+<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+<header::map::OccupiedEntry<'a, T>>::into_iter(p0);
-----------------
src/header/map.rs <&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter
'a,'b
deps:{"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.into_iter();
+<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+<&'b header::map::OccupiedEntry<'a, T>>::into_iter(p0);
-----------------
src/header/map.rs <&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter
'a,'b
deps:{"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["std::marker::Sized"]}}
candidates:{"<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::OccupiedEntry<'a, T>
+p0.into_iter();
+<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter(p0);
+<&'b mut header::map::OccupiedEntry<'a, T>>::into_iter(p0);
-----------------
src/header/map.rs <header::map::ValueDrain<'a, T> as std::iter::Iterator>::next
'a
deps:{"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::ValueDrain<'a, T>
+p0.next();
+<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next(p0);
+crate::<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next(p0);
+<header::map::ValueDrain<'a, T>>::next(p0);
-----------------
src/header/map.rs <header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint
'a
deps:{"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::ValueDrain<'a, T>
+p0.size_hint();
+<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint(p0);
+crate::<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint(p0);
+<header::map::ValueDrain<'a, T>>::size_hint(p0);
-----------------
src/header/map.rs <header::map::ValueDrain<'a, T> as std::ops::Drop>::drop
'a
deps:{"<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::ValueDrain<'a, T>
+p0.drop();
+<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop(p0);
+crate::<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop(p0);
+<header::map::ValueDrain<'a, T>>::drop(p0);
-----------------
src/header/map.rs <header::map::RawLinks<T> as std::clone::Clone>::clone
deps:{"<header::map::RawLinks<T> as std::clone::Clone>::clone":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::RawLinks<T> as std::clone::Clone>::clone":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::RawLinks<T>
+p0.clone();
+<header::map::RawLinks<T> as std::clone::Clone>::clone(p0);
+crate::<header::map::RawLinks<T> as std::clone::Clone>::clone(p0);
+<header::map::RawLinks<T>>::clone(p0);
-----------------
src/header/map.rs <header::map::RawLinks<T> as std::ops::Index<usize>>::index
deps:{"<header::map::RawLinks<T> as std::ops::Index<usize>>::index":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::RawLinks<T> as std::ops::Index<usize>>::index":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::RawLinks<T>
let mut p1 = 0usize; // None+usize
+p0.index(p1);
+<header::map::RawLinks<T> as std::ops::Index<usize>>::index(p0, p1);
+crate::<header::map::RawLinks<T> as std::ops::Index<usize>>::index(p0, p1);
+<header::map::RawLinks<T>>::index(p0, p1);
-----------------
src/header/map.rs <header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut
deps:{"<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut":{"T":["std::marker::Sized"]}}
candidates:{"<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::RawLinks<T>
let mut p1 = 0usize; // None+usize
+p0.index_mut(p1);
+<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut(p0, p1);
+crate::<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut(p0, p1);
+<header::map::RawLinks<T>>::index_mut(p0, p1);
-----------------
src/header/map.rs header::map::Pos::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
let mut p1 = MaybeUninit::uninit().assume_init(); // header::map::HashValue
+header::map::Pos::new(p0, p1);
+crate::header::map::Pos::new(p0, p1);
+<header::map::Pos>::new(p0, p1);
-----------------
src/header/map.rs header::map::Pos::none
deps:{}
candidates:{}
+header::map::Pos::none();
+crate::header::map::Pos::none();
+<header::map::Pos>::none();
-----------------
src/header/map.rs header::map::Pos::is_some
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Pos
+p0.is_some();
+header::map::Pos::is_some(p0);
+crate::header::map::Pos::is_some(p0);
+<header::map::Pos>::is_some(p0);
-----------------
src/header/map.rs header::map::Pos::is_none
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Pos
+p0.is_none();
+header::map::Pos::is_none(p0);
+crate::header::map::Pos::is_none(p0);
+<header::map::Pos>::is_none(p0);
-----------------
src/header/map.rs header::map::Pos::resolve
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Pos
+p0.resolve();
+header::map::Pos::resolve(p0);
+crate::header::map::Pos::resolve(p0);
+<header::map::Pos>::resolve(p0);
-----------------
src/header/map.rs header::map::Danger::is_red
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Danger
+p0.is_red();
+header::map::Danger::is_red(p0);
+crate::header::map::Danger::is_red(p0);
+<header::map::Danger>::is_red(p0);
-----------------
src/header/map.rs header::map::Danger::to_red
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::Danger
+p0.to_red();
+header::map::Danger::to_red(p0);
+crate::header::map::Danger::to_red(p0);
+<header::map::Danger>::to_red(p0);
-----------------
src/header/map.rs header::map::Danger::is_yellow
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::map::Danger
+p0.is_yellow();
+header::map::Danger::is_yellow(p0);
+crate::header::map::Danger::is_yellow(p0);
+<header::map::Danger>::is_yellow(p0);
-----------------
src/header/map.rs header::map::Danger::to_yellow
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::Danger
+p0.to_yellow();
+header::map::Danger::to_yellow(p0);
+crate::header::map::Danger::to_yellow(p0);
+<header::map::Danger>::to_yellow(p0);
-----------------
src/header/map.rs header::map::Danger::to_green
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::map::Danger
+p0.to_green();
+header::map::Danger::to_green(p0);
+crate::header::map::Danger::to_green(p0);
+<header::map::Danger>::to_green(p0);
-----------------
src/header/map.rs <header::name::HeaderName as header::map::into_header_name::Sealed>::insert
deps:{"<header::name::HeaderName as header::map::into_header_name::Sealed>::insert":{"T":["std::marker::Sized"]}}
candidates:{"<header::name::HeaderName as header::map::into_header_name::Sealed>::insert":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1, p2);
+<header::name::HeaderName as header::map::into_header_name::Sealed>::insert(p0, p1, p2);
+crate::<header::name::HeaderName as header::map::into_header_name::Sealed>::insert(p0, p1, p2);
+<header::name::HeaderName>::insert(p0, p1, p2);
-----------------
src/header/map.rs <header::name::HeaderName as header::map::into_header_name::Sealed>::append
deps:{"<header::name::HeaderName as header::map::into_header_name::Sealed>::append":{"T":["std::marker::Sized"]}}
candidates:{"<header::name::HeaderName as header::map::into_header_name::Sealed>::append":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.append(p1, p2);
+<header::name::HeaderName as header::map::into_header_name::Sealed>::append(p0, p1, p2);
+crate::<header::name::HeaderName as header::map::into_header_name::Sealed>::append(p0, p1, p2);
+<header::name::HeaderName>::append(p0, p1, p2);
-----------------
src/header/map.rs <header::name::HeaderName as header::map::into_header_name::Sealed>::entry
deps:{"<header::name::HeaderName as header::map::into_header_name::Sealed>::entry":{"T":["std::marker::Sized"]}}
candidates:{"<header::name::HeaderName as header::map::into_header_name::Sealed>::entry":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.entry(p1);
+<header::name::HeaderName as header::map::into_header_name::Sealed>::entry(p0, p1);
+crate::<header::name::HeaderName as header::map::into_header_name::Sealed>::entry(p0, p1);
+<header::name::HeaderName>::entry(p0, p1);
-----------------
src/header/map.rs <&'a header::name::HeaderName as header::map::into_header_name::Sealed>::insert
'a
deps:{"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::insert":{"T":["std::marker::Sized"]}}
candidates:{"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::insert":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1, p2);
+<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::insert(p0, p1, p2);
+crate::<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::insert(p0, p1, p2);
+<&'a header::name::HeaderName>::insert(p0, p1, p2);
-----------------
src/header/map.rs <&'a header::name::HeaderName as header::map::into_header_name::Sealed>::append
'a
deps:{"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::append":{"T":["std::marker::Sized"]}}
candidates:{"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::append":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.append(p1, p2);
+<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::append(p0, p1, p2);
+crate::<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::append(p0, p1, p2);
+<&'a header::name::HeaderName>::append(p0, p1, p2);
-----------------
src/header/map.rs <&'a header::name::HeaderName as header::map::into_header_name::Sealed>::entry
'a
deps:{"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::entry":{"T":["std::marker::Sized"]}}
candidates:{"<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::entry":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.entry(p1);
+<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::entry(p0, p1);
+crate::<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::entry(p0, p1);
+<&'a header::name::HeaderName>::entry(p0, p1);
-----------------
src/header/map.rs <&'static str as header::map::into_header_name::Sealed>::insert
deps:{"<&'static str as header::map::into_header_name::Sealed>::insert":{"T":["std::marker::Sized"]}}
candidates:{"<&'static str as header::map::into_header_name::Sealed>::insert":{"T":["RUG_ANY"]}}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1, p2);
+<&'static str as header::map::into_header_name::Sealed>::insert(&p0, p1, p2);
+crate::<&'static str as header::map::into_header_name::Sealed>::insert(&p0, p1, p2);
+<&'static str>::insert(&p0, p1, p2);
-----------------
src/header/map.rs <&'static str as header::map::into_header_name::Sealed>::append
deps:{"<&'static str as header::map::into_header_name::Sealed>::append":{"T":["std::marker::Sized"]}}
candidates:{"<&'static str as header::map::into_header_name::Sealed>::append":{"T":["RUG_ANY"]}}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
let mut p2 = MaybeUninit::uninit().assume_init(); // T
+p0.append(p1, p2);
+<&'static str as header::map::into_header_name::Sealed>::append(&p0, p1, p2);
+crate::<&'static str as header::map::into_header_name::Sealed>::append(&p0, p1, p2);
+<&'static str>::append(&p0, p1, p2);
-----------------
src/header/map.rs <&'static str as header::map::into_header_name::Sealed>::entry
deps:{"<&'static str as header::map::into_header_name::Sealed>::entry":{"T":["std::marker::Sized"]}}
candidates:{"<&'static str as header::map::into_header_name::Sealed>::entry":{"T":["RUG_ANY"]}}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.entry(p1);
+<&'static str as header::map::into_header_name::Sealed>::entry(&p0, p1);
+crate::<&'static str as header::map::into_header_name::Sealed>::entry(&p0, p1);
+<&'static str>::entry(&p0, p1);
-----------------
src/header/map.rs <header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry
deps:{"<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry":{"T":["std::marker::Sized"]}}
candidates:{"<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.try_entry(p1);
+<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry(p0, p1);
+crate::<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry(p0, p1);
+<header::name::HeaderName>::try_entry(p0, p1);
-----------------
src/header/map.rs <header::name::HeaderName as header::map::as_header_name::Sealed>::find
deps:{"<header::name::HeaderName as header::map::as_header_name::Sealed>::find":{"T":["std::marker::Sized"]}}
candidates:{"<header::name::HeaderName as header::map::as_header_name::Sealed>::find":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.find(p1);
+<header::name::HeaderName as header::map::as_header_name::Sealed>::find(p0, p1);
+crate::<header::name::HeaderName as header::map::as_header_name::Sealed>::find(p0, p1);
+<header::name::HeaderName>::find(p0, p1);
-----------------
src/header/map.rs <header::name::HeaderName as header::map::as_header_name::Sealed>::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.as_str();
+<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str(p0);
+crate::<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str(p0);
+<header::name::HeaderName>::as_str(p0);
-----------------
src/header/map.rs <&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry
'a
deps:{"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry":{"T":["std::marker::Sized"]}}
candidates:{"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.try_entry(p1);
+<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry(p0, p1);
+crate::<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry(p0, p1);
+<&'a header::name::HeaderName>::try_entry(p0, p1);
-----------------
src/header/map.rs <&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find
'a
deps:{"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find":{"T":["std::marker::Sized"]}}
candidates:{"<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.find(p1);
+<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find(p0, p1);
+crate::<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find(p0, p1);
+<&'a header::name::HeaderName>::find(p0, p1);
-----------------
src/header/map.rs <&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.as_str();
+<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str(p0);
+crate::<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str(p0);
+<&'a header::name::HeaderName>::as_str(p0);
-----------------
src/header/map.rs <&'a str as header::map::as_header_name::Sealed>::try_entry
'a
deps:{"<&'a str as header::map::as_header_name::Sealed>::try_entry":{"T":["std::marker::Sized"]}}
candidates:{"<&'a str as header::map::as_header_name::Sealed>::try_entry":{"T":["RUG_ANY"]}}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.try_entry(p1);
+<&'a str as header::map::as_header_name::Sealed>::try_entry(&p0, p1);
+crate::<&'a str as header::map::as_header_name::Sealed>::try_entry(&p0, p1);
+<&'a str>::try_entry(&p0, p1);
-----------------
src/header/map.rs <&'a str as header::map::as_header_name::Sealed>::find
'a
deps:{"<&'a str as header::map::as_header_name::Sealed>::find":{"T":["std::marker::Sized"]}}
candidates:{"<&'a str as header::map::as_header_name::Sealed>::find":{"T":["RUG_ANY"]}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.find(p1);
+<&'a str as header::map::as_header_name::Sealed>::find(p0, p1);
+crate::<&'a str as header::map::as_header_name::Sealed>::find(p0, p1);
+<&'a str>::find(p0, p1);
-----------------
src/header/map.rs <&'a str as header::map::as_header_name::Sealed>::as_str
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.as_str();
+<&'a str as header::map::as_header_name::Sealed>::as_str(p0);
+crate::<&'a str as header::map::as_header_name::Sealed>::as_str(p0);
+<&'a str>::as_str(p0);
-----------------
src/header/map.rs <std::string::String as header::map::as_header_name::Sealed>::try_entry
deps:{"<std::string::String as header::map::as_header_name::Sealed>::try_entry":{"T":["std::marker::Sized"]}}
candidates:{"<std::string::String as header::map::as_header_name::Sealed>::try_entry":{"T":["RUG_ANY"]}}
let mut p0 = std::string::String::new(); // None+std::string::String
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.try_entry(p1);
+<std::string::String as header::map::as_header_name::Sealed>::try_entry(p0, p1);
+crate::<std::string::String as header::map::as_header_name::Sealed>::try_entry(p0, p1);
+<std::string::String>::try_entry(p0, p1);
-----------------
src/header/map.rs <std::string::String as header::map::as_header_name::Sealed>::find
deps:{"<std::string::String as header::map::as_header_name::Sealed>::find":{"T":["std::marker::Sized"]}}
candidates:{"<std::string::String as header::map::as_header_name::Sealed>::find":{"T":["RUG_ANY"]}}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.find(p1);
+<std::string::String as header::map::as_header_name::Sealed>::find(p0, p1);
+crate::<std::string::String as header::map::as_header_name::Sealed>::find(p0, p1);
+<std::string::String>::find(p0, p1);
-----------------
src/header/map.rs <std::string::String as header::map::as_header_name::Sealed>::as_str
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+p0.as_str();
+<std::string::String as header::map::as_header_name::Sealed>::as_str(p0);
+crate::<std::string::String as header::map::as_header_name::Sealed>::as_str(p0);
+<std::string::String>::as_str(p0);
-----------------
src/header/map.rs <&'a std::string::String as header::map::as_header_name::Sealed>::try_entry
'a
deps:{"<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry":{"T":["std::marker::Sized"]}}
candidates:{"<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry":{"T":["RUG_ANY"]}}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.try_entry(p1);
+<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry(p0, p1);
+crate::<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry(p0, p1);
+<&'a std::string::String>::try_entry(p0, p1);
-----------------
src/header/map.rs <&'a std::string::String as header::map::as_header_name::Sealed>::find
'a
deps:{"<&'a std::string::String as header::map::as_header_name::Sealed>::find":{"T":["std::marker::Sized"]}}
candidates:{"<&'a std::string::String as header::map::as_header_name::Sealed>::find":{"T":["RUG_ANY"]}}
let mut p0 = & std::string::String::new(); // None+&'a std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::map::HeaderMap<T>
+p0.find(p1);
+<&'a std::string::String as header::map::as_header_name::Sealed>::find(p0, p1);
+crate::<&'a std::string::String as header::map::as_header_name::Sealed>::find(p0, p1);
+<&'a std::string::String>::find(p0, p1);
-----------------
src/header/map.rs <&'a std::string::String as header::map::as_header_name::Sealed>::as_str
'a
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+&'a std::string::String
+p0.as_str();
+<&'a std::string::String as header::map::as_header_name::Sealed>::as_str(p0);
+crate::<&'a std::string::String as header::map::as_header_name::Sealed>::as_str(p0);
+<&'a std::string::String>::as_str(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.clone();
+<header::name::HeaderName as std::clone::Clone>::clone(p0);
+crate::<header::name::HeaderName as std::clone::Clone>::clone(p0);
+<header::name::HeaderName>::clone(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.assert_receiver_is_total_eq();
+<header::name::HeaderName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<header::name::HeaderName as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<header::name::HeaderName>::assert_receiver_is_total_eq(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.eq(p1);
+<header::name::HeaderName as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::name::HeaderName as std::cmp::PartialEq>::eq(p0, p1);
+<header::name::HeaderName>::eq(p0, p1);
-----------------
src/header/name.rs <header::name::HeaderName as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<header::name::HeaderName as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<header::name::HeaderName as std::hash::Hash>::hash":{"__H":["extensions::IdHasher","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<header::name::HeaderName as std::hash::Hash>::hash(p0, p1);
+crate::<header::name::HeaderName as std::hash::Hash>::hash(p0, p1);
+<header::name::HeaderName>::hash(p0, p1);
-----------------
src/header/name.rs <header::name::HdrName<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HdrName<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::name::HdrName<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::name::HdrName<'a> as std::fmt::Debug>::fmt(p0, p1);
+<header::name::HdrName<'a>>::fmt(p0, p1);
-----------------
src/header/name.rs <header::name::HdrName<'a> as std::hash::Hash>::hash
'a
deps:{"<&mut H as std::hash::Hasher>":{},"<header::name::HdrName<'a> as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<header::name::HdrName<'a> as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HdrName<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<header::name::HdrName<'a> as std::hash::Hash>::hash(p0, p1);
+crate::<header::name::HdrName<'a> as std::hash::Hash>::hash(p0, p1);
+<header::name::HdrName<'a>>::hash(p0, p1);
-----------------
src/header/name.rs <header::name::Repr<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::name::Repr<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::Drain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::convert::TryFrom","std::clone::Clone"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Sized","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::hash::Hash","std::fmt::Debug"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<header::name::Repr<T> as std::fmt::Debug>::fmt":{"T":["uri::port::Port","version::Version","uri::scheme::Scheme","header::map::ValueDrain","header::name::Custom","header::map::IntoIter","byte_str::ByteStr","header::value::ToStrError","uri::Parts","request::Parts","header::name::MaybeLower","uri::ErrorKind","header::map::Links","uri::scheme::Protocol","header::name::Repr","header::name::InvalidHeaderName","header::value::HeaderValue","header::map::GetAll","header::map::Link","uri::path::PathAndQuery","uri::InvalidUriParts","header::map::OccupiedEntry","<&T as std::fmt::Debug>","uri::authority::Authority","uri::builder::Builder","response::Response","header::map::Drain","method::Method","header::name::HeaderName","header::map::VacantEntry","request::Builder","response::Parts","header::map::ValuesMut","header::map::Bucket","header::map::Values","uri::scheme::Scheme2","header::map::RawLinks","uri::InvalidUri","error::Error","method::InvalidMethod","header::map::HeaderMap","uri::Uri","status::StatusCode","header::name::HdrName","header::map::IterMut","extensions::Extensions","header::map::ValueIterMut","header::map::Keys","response::Builder","request::Request","header::name::StandardHeader","header::map::ExtraValue","<*const T as std::fmt::Debug>","status::InvalidStatusCode","header::value::InvalidHeaderValue","header::map::Iter","header::map::Cursor","header::map::ValueIter","header::map::HashValue","header::map::Entry"]},"header::map::Bucket":{"T":["header::map::RawLinks","uri::path::PathAndQuery","header::map::Link","header::value::HeaderValue","uri::Uri","header::map::Cursor","header::name::MaybeLower","header::map::HeaderMap","uri::scheme::Scheme","header::name::Custom","header::map::Bucket","status::StatusCode","uri::authority::Authority","std::clone::impls::<impl std::clone::Clone for *mut T>","uri::scheme::Scheme2","header::name::StandardHeader","header::map::Links","header::name::Repr","header::map::HashValue","byte_str::ByteStr","header::name::HeaderName","uri::scheme::Protocol","header::map::ExtraValue","method::Method","version::Version"]},"header::map::Drain":{"T":["header::map::ValueIterMut","header::map::IterMut","<*const T as std::marker::Send>","header::map::Iter","header::map::ValueDrain","header::map::Drain"]},"header::map::Entry":{"T":["extensions::Extensions","uri::Uri","header::map::Values","header::map::Links","status::StatusCode","version::Version","header::map::GetAll","header::map::ValuesMut","status::InvalidStatusCode","uri::path::PathAndQuery","uri::Parts","header::map::Entry","response::Response","uri::scheme::Scheme","header::map::OccupiedEntry","header::name::HeaderName","request::Parts","error::Error","header::name::Repr","header::value::HeaderValue","request::Request","header::map::Link","header::map::Keys","response::Builder","header::name::HdrName","uri::ErrorKind","header::map::ValueIterMut","header::map::ExtraValue","uri::scheme::Protocol","header::name::Custom","method::Method","header::map::HeaderMap","uri::builder::Builder","header::value::InvalidHeaderValue","header::map::IntoIter","header::map::ValueDrain","header::map::Drain","uri::port::Port","header::map::HashValue","header::name::InvalidHeaderName","uri::authority::Authority","uri::InvalidUri","header::map::Cursor","header::map::Iter","<*mut T as std::fmt::Debug>","header::map::ValueIter","header::name::MaybeLower","header::map::VacantEntry","header::map::Bucket","header::value::ToStrError","response::Parts","header::name::StandardHeader","header::map::RawLinks","header::map::IterMut","uri::scheme::Scheme2","method::InvalidMethod","byte_str::ByteStr","request::Builder","uri::InvalidUriParts"]},"header::map::ExtraValue":{"T":["header::map::RawLinks","status::StatusCode","header::name::Custom","header::value::HeaderValue","uri::scheme::Scheme","uri::scheme::Scheme2","header::map::ExtraValue","header::map::Bucket","header::name::Repr","std::clone::impls::<impl std::clone::Clone for &T>","uri::authority::Authority","header::name::HeaderName","header::map::Links","version::Version","header::name::StandardHeader","header::map::HashValue","uri::scheme::Protocol","header::map::Link","byte_str::ByteStr","uri::path::PathAndQuery","header::map::HeaderMap","uri::Uri","method::Method","header::map::Cursor","header::name::MaybeLower"]},"header::map::GetAll":{"T":["<*mut T as std::fmt::Debug>","header::map::Link","header::name::Repr","header::map::HeaderMap","byte_str::ByteStr","version::Version","header::name::Custom","header::map::Cursor","header::map::GetAll","uri::ErrorKind","header::map::HashValue","header::name::StandardHeader"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::map::IntoIter":{"T":["header::map::RawLinks","uri::Parts","header::map::Cursor","method::InvalidMethod","header::map::ValueIterMut","uri::Uri","uri::scheme::Protocol","header::map::HashValue","header::map::ExtraValue","uri::scheme::Scheme","header::map::HeaderMap","header::value::HeaderValue","extensions::Extensions","request::Parts","header::map::GetAll","uri::port::Port","header::map::IntoIter","status::StatusCode","version::Version","response::Builder","header::name::HeaderName","header::name::Repr","error::Error","uri::InvalidUriParts","header::value::InvalidHeaderValue","request::Request","uri::InvalidUri","header::map::Links","header::map::VacantEntry","uri::authority::Authority","method::Method","header::value::ToStrError","header::name::Custom","header::map::IterMut","uri::scheme::Scheme2","status::InvalidStatusCode","response::Parts","header::map::Bucket","header::map::Keys","header::map::ValueDrain","header::name::MaybeLower","<*const T as std::fmt::Debug>","header::map::Iter","header::name::InvalidHeaderName","header::name::HdrName","uri::builder::Builder","header::map::Link","byte_str::ByteStr","uri::path::PathAndQuery","request::Builder","header::map::OccupiedEntry","uri::ErrorKind","header::map::Values","header::map::ValueIter","header::map::Entry","header::map::Drain","header::name::StandardHeader","header::map::ValuesMut","response::Response"]},"header::map::Iter":{"T":["header::map::IterMut","header::map::Drain","header::map::ValueDrain","header::map::ValueIterMut","<*const T as std::fmt::Debug>","header::map::Iter"]},"header::map::IterMut":{"T":["header::map::Drain","header::map::IterMut","<*mut T as std::marker::Send>","header::map::ValueDrain","header::map::ValueIterMut","header::map::Iter"]},"header::map::Keys":{"T":["header::name::HeaderName","response::Builder","header::map::ValueIterMut","uri::port::Port","request::Parts","header::name::HdrName","header::map::ValueIter","uri::scheme::Scheme","status::InvalidStatusCode","header::name::MaybeLower","<*const T as std::fmt::Debug>","header::map::Values","header::map::GetAll","uri::authority::Authority","header::map::ValuesMut","uri::Parts","request::Builder","uri::scheme::Scheme2","status::StatusCode","error::Error","header::map::Iter","header::name::StandardHeader","header::map::HashValue","byte_str::ByteStr","extensions::Extensions","version::Version","uri::scheme::Protocol","header::map::ValueDrain","response::Parts","uri::builder::Builder","uri::InvalidUriParts","header::map::Link","header::name::Custom","header::name::Repr","header::map::ExtraValue","header::map::Drain","header::map::OccupiedEntry","method::Method","header::value::InvalidHeaderValue","header::map::Bucket","header::map::RawLinks","response::Response","uri::path::PathAndQuery","uri::InvalidUri","header::value::HeaderValue","header::map::HeaderMap","header::map::Links","header::map::IterMut","header::map::Cursor","header::map::VacantEntry","header::map::IntoIter","uri::ErrorKind","request::Request","method::InvalidMethod","header::name::InvalidHeaderName","header::value::ToStrError","header::map::Keys","uri::Uri","header::map::Entry"]},"header::map::OccupiedEntry":{"T":["uri::Parts","uri::scheme::Scheme","header::map::Links","header::map::ValuesMut","header::value::InvalidHeaderValue","header::map::ValueIter","header::map::OccupiedEntry","header::map::HashValue","header::map::VacantEntry","header::map::Bucket","uri::ErrorKind","header::map::Entry","header::name::HdrName","header::map::Values","header::map::GetAll","header::name::InvalidHeaderName","method::Method","response::Builder","header::map::ValueDrain","status::StatusCode","method::InvalidMethod","header::name::MaybeLower","header::map::Iter","request::Request","header::map::IterMut","header::name::Repr","version::Version","header::map::Link","extensions::Extensions","response::Response","response::Parts","request::Builder","header::value::HeaderValue","uri::InvalidUri","header::map::IntoIter","uri::builder::Builder","header::name::Custom","uri::scheme::Protocol","uri::scheme::Scheme2","header::map::ExtraValue","request::Parts","header::map::ValueIterMut","header::map::Drain","header::map::HeaderMap","uri::authority::Authority","header::map::RawLinks","uri::port::Port","header::map::Keys","uri::path::PathAndQuery","status::InvalidStatusCode","header::value::ToStrError","header::map::Cursor","uri::Uri","header::name::StandardHeader","uri::InvalidUriParts","header::name::HeaderName","error::Error","<&T as std::fmt::Debug>","byte_str::ByteStr"]},"header::map::RawLinks":{"T":["header::map::HashValue","header::map::Links","header::map::RawLinks","request::Builder","header::map::IterMut","uri::port::Port","header::name::InvalidHeaderName","uri::Parts","header::map::GetAll","status::StatusCode","uri::scheme::Scheme","header::map::IntoIter","header::map::ExtraValue","uri::builder::Builder","extensions::Extensions","header::name::Repr","header::map::Link","uri::path::PathAndQuery","header::map::HeaderMap","byte_str::ByteStr","header::map::Values","uri::InvalidUri","header::map::ValueDrain","response::Builder","uri::InvalidUriParts","header::name::HdrName","header::map::Iter","header::map::Entry","header::map::VacantEntry","<*const T as std::fmt::Debug>","header::value::HeaderValue","method::InvalidMethod","uri::ErrorKind","header::map::ValueIter","error::Error","uri::authority::Authority","status::InvalidStatusCode","method::Method","request::Request","header::map::ValueIterMut","header::map::Cursor","header::name::HeaderName","header::map::Bucket","header::value::InvalidHeaderValue","header::map::Drain","header::map::Keys","header::map::OccupiedEntry","header::name::MaybeLower","uri::scheme::Protocol","uri::Uri","uri::scheme::Scheme2","header::map::ValuesMut","header::name::Custom","response::Parts","header::value::ToStrError","header::name::StandardHeader","response::Response","version::Version","request::Parts"]},"header::map::VacantEntry":{"T":["error::Error","header::name::Repr","request::Parts","header::map::Cursor","header::name::Custom","status::StatusCode","byte_str::ByteStr","header::value::InvalidHeaderValue","header::map::HashValue","response::Response","header::map::GetAll","header::value::ToStrError","header::name::HeaderName","response::Builder","uri::Parts","status::InvalidStatusCode","method::Method","response::Parts","uri::InvalidUri","uri::authority::Authority","header::name::MaybeLower","request::Request","header::map::ValueDrain","header::map::HeaderMap","<&T as std::fmt::Debug>","header::map::Keys","uri::scheme::Scheme2","header::map::IntoIter","uri::InvalidUriParts","uri::Uri","uri::builder::Builder","header::map::ValueIterMut","header::map::OccupiedEntry","request::Builder","method::InvalidMethod","uri::port::Port","header::map::ExtraValue","header::map::Iter","header::name::InvalidHeaderName","version::Version","header::value::HeaderValue","uri::path::PathAndQuery","header::map::Links","uri::scheme::Protocol","header::name::StandardHeader","header::map::Link","header::map::Drain","header::map::RawLinks","header::map::ValueIter","uri::scheme::Scheme","header::map::IterMut","extensions::Extensions","header::map::Bucket","header::map::VacantEntry","header::name::HdrName","header::map::Values","uri::ErrorKind","header::map::ValuesMut","header::map::Entry"]},"header::map::ValueDrain":{"T":["header::map::ValueDrain","header::map::IterMut","<*const T as std::marker::Send>","header::map::ValueIterMut","header::map::Drain","header::map::Iter"]},"header::map::ValueIter":{"T":["header::map::IntoIter","error::Error","version::Version","uri::InvalidUriParts","header::map::Keys","uri::ErrorKind","header::map::HashValue","header::name::HeaderName","header::value::InvalidHeaderValue","header::map::Bucket","header::name::Custom","uri::scheme::Scheme2","header::name::InvalidHeaderName","response::Builder","header::map::RawLinks","header::name::HdrName","header::map::Drain","uri::authority::Authority","uri::port::Port","request::Request","byte_str::ByteStr","header::map::IterMut","header::map::ValuesMut","header::map::GetAll","uri::builder::Builder","header::map::Values","method::InvalidMethod","status::StatusCode","uri::scheme::Protocol","header::value::HeaderValue","header::name::MaybeLower","header::map::ValueIter","header::map::HeaderMap","uri::scheme::Scheme","header::value::ToStrError","uri::Uri","request::Parts","header::name::StandardHeader","uri::Parts","request::Builder","<*mut T as std::fmt::Debug>","header::map::VacantEntry","uri::InvalidUri","header::map::Iter","header::map::OccupiedEntry","response::Parts","header::name::Repr","header::map::ValueIterMut","header::map::ValueDrain","response::Response","header::map::Link","extensions::Extensions","uri::path::PathAndQuery","status::InvalidStatusCode","method::Method","header::map::Links","header::map::Cursor","header::map::ExtraValue","header::map::Entry"]},"header::map::ValueIterMut":{"T":["header::map::ValueDrain","header::map::Iter","header::map::ValueIterMut","<*mut T as std::marker::Sync>","header::map::Drain","header::map::IterMut"]},"header::map::Values":{"T":["request::Request","header::value::ToStrError","header::name::HeaderName","header::name::InvalidHeaderName","header::name::Repr","header::map::Cursor","header::map::RawLinks","status::InvalidStatusCode","<&T as std::fmt::Debug>","method::InvalidMethod","uri::port::Port","extensions::Extensions","uri::authority::Authority","header::map::HashValue","method::Method","uri::Uri","header::map::Bucket","header::map::IterMut","uri::scheme::Scheme","header::map::Drain","error::Error","header::value::InvalidHeaderValue","header::name::StandardHeader","uri::InvalidUri","header::map::Entry","request::Builder","header::map::ValueIterMut","byte_str::ByteStr","header::map::ValueDrain","header::map::IntoIter","header::name::MaybeLower","header::map::VacantEntry","header::map::ValuesMut","uri::ErrorKind","response::Response","header::map::Link","uri::path::PathAndQuery","header::map::Keys","uri::scheme::Scheme2","header::map::ValueIter","header::map::HeaderMap","response::Builder","request::Parts","header::map::GetAll","uri::builder::Builder","header::name::Custom","version::Version","header::map::Values","header::map::Iter","header::value::HeaderValue","uri::Parts","uri::InvalidUriParts","uri::scheme::Protocol","header::map::Links","header::name::HdrName","response::Parts","status::StatusCode","header::map::OccupiedEntry","header::map::ExtraValue"]},"header::map::ValuesMut":{"T":["response::Response","<&T as std::fmt::Debug>","header::map::GetAll","header::map::Link","header::map::Entry","header::map::Drain","uri::InvalidUriParts","header::name::HeaderName","request::Request","uri::path::PathAndQuery","header::map::ValueIter","header::map::ExtraValue","header::map::Keys","header::name::StandardHeader","uri::authority::Authority","header::map::RawLinks","header::map::Cursor","header::value::InvalidHeaderValue","uri::scheme::Scheme2","header::name::MaybeLower","status::InvalidStatusCode","header::map::IntoIter","method::Method","header::map::ValueIterMut","error::Error","header::map::OccupiedEntry","uri::builder::Builder","header::map::Iter","header::map::HashValue","header::map::Links","header::map::VacantEntry","header::map::Bucket","header::name::Custom","version::Version","status::StatusCode","header::value::ToStrError","extensions::Extensions","header::map::Values","header::name::HdrName","uri::Uri","header::map::ValueDrain","header::name::Repr","request::Parts","header::value::HeaderValue","header::name::InvalidHeaderName","response::Builder","uri::scheme::Protocol","header::map::ValuesMut","response::Parts","request::Builder","uri::scheme::Scheme","uri::ErrorKind","byte_str::ByteStr","method::InvalidMethod","header::map::IterMut","uri::InvalidUri","uri::port::Port","uri::Parts","header::map::HeaderMap"]},"header::name::Repr":{"T":["header::name::StandardHeader","header::name::Custom","header::name::Repr","std::clone::impls::<impl std::clone::Clone for *mut T>","version::Version","byte_str::ByteStr"]},"request::Request":{"T":["version::Version","uri::Parts","response::Response","response::Builder","status::StatusCode","extensions::Extensions","uri::builder::Builder","header::map::HeaderMap","request::Builder","method::Method","uri::Uri","request::Request"]},"response::Response":{"T":["uri::Parts","response::Response","extensions::Extensions","uri::Uri","status::StatusCode","request::Builder","method::Method","header::map::HeaderMap","response::Builder","version::Version","uri::builder::Builder","request::Request"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"uri::port::Port":{"T":["uri::scheme::Scheme","<&mut T as std::fmt::Debug>","uri::authority::Authority","uri::port::Port","method::Method","header::value::HeaderValue"]},"uri::scheme::Scheme2":{"T":["uri::Uri","uri::scheme::Scheme","header::map::Cursor","<*mut T as std::fmt::Debug>","header::name::HeaderName","uri::scheme::Scheme2","uri::authority::Authority","header::name::Custom","header::map::Link","header::map::HeaderMap","header::map::ExtraValue","header::name::Repr","status::StatusCode","byte_str::ByteStr","uri::scheme::Protocol","header::map::Bucket","header::map::HashValue","header::map::Links","uri::path::PathAndQuery","method::Method","header::value::HeaderValue","header::name::StandardHeader","std::boxed::Box<byte_str::ByteStr>","header::name::MaybeLower","version::Version","header::map::RawLinks"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Repr<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::name::Repr<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::name::Repr<T> as std::fmt::Debug>::fmt(p0, p1);
+<header::name::Repr<T>>::fmt(p0, p1);
-----------------
src/header/name.rs <header::name::Repr<T> as std::clone::Clone>::clone
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::name::Repr<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"header::map::Bucket":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::convert::TryFrom","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Send","std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::name::Repr":{"T":["std::marker::Sized","std::hash::Hash","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::fmt::Debug","std::default::Default","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Sync>":{},"<header::name::Repr<T> as std::clone::Clone>::clone":{"T":["header::value::HeaderValue","method::Inner","header::map::Link","header::name::StandardHeader","uri::scheme::Protocol","header::map::RawLinks","header::map::ExtraValue","header::map::Bucket","version::Version","header::map::Pos","header::map::Links","header::name::Repr","header::map::HashValue","uri::path::PathAndQuery","byte_str::ByteStr","uri::scheme::Scheme2","method::extension::InlineExtension","uri::Uri","header::map::Cursor","header::name::Custom","header::map::HeaderMap","method::Method","header::name::MaybeLower","status::StatusCode","std::clone::impls::<impl std::clone::Clone for &mut T>","header::map::Danger","uri::authority::Authority","std::clone::impls::<impl std::clone::Clone for &T>","method::extension::AllocatedExtension","header::name::HeaderName","uri::scheme::Scheme","version::Http"]},"header::map::Bucket":{"T":["header::name::Custom","uri::Uri","header::name::Repr","header::map::ExtraValue","byte_str::ByteStr","header::map::Link","uri::scheme::Scheme","header::map::Cursor","header::map::HashValue","method::Method","uri::path::PathAndQuery","std::clone::impls::<impl std::clone::Clone for &T>","header::map::Bucket","header::name::MaybeLower","header::value::HeaderValue","header::map::HeaderMap","header::map::Links","version::Version","uri::scheme::Scheme2","uri::authority::Authority","header::name::StandardHeader","status::StatusCode","header::name::HeaderName","header::map::RawLinks","uri::scheme::Protocol"]},"header::map::Drain":{"T":["<*mut T as std::fmt::Debug>","header::map::Iter","header::map::ValueDrain","header::map::Drain","header::map::IterMut","header::map::ValueIterMut"]},"header::map::Entry":{"T":["uri::scheme::Scheme2","header::map::IntoIter","header::name::MaybeLower","header::map::Link","status::StatusCode","header::map::Drain","header::value::ToStrError","status::InvalidStatusCode","header::value::InvalidHeaderValue","header::map::Entry","header::value::HeaderValue","header::map::HashValue","request::Request","header::name::Custom","header::map::Bucket","header::map::IterMut","header::map::ValueIter","uri::InvalidUriParts","uri::Parts","header::map::Iter","uri::builder::Builder","uri::Uri","header::name::Repr","header::map::HeaderMap","method::InvalidMethod","header::name::StandardHeader","method::Method","uri::scheme::Scheme","header::map::Cursor","header::map::ValueIterMut","uri::InvalidUri","uri::port::Port","uri::path::PathAndQuery","uri::ErrorKind","header::map::GetAll","error::Error","byte_str::ByteStr","<&T as std::fmt::Debug>","version::Version","header::name::InvalidHeaderName","response::Response","header::name::HeaderName","header::map::Links","header::map::OccupiedEntry","uri::scheme::Protocol","header::map::Values","header::name::HdrName","header::map::ValueDrain","response::Builder","extensions::Extensions","header::map::RawLinks","header::map::Keys","uri::authority::Authority","response::Parts","request::Builder","header::map::ValuesMut","request::Parts","header::map::ExtraValue","header::map::VacantEntry"]},"header::map::ExtraValue":{"T":["header::map::HashValue","header::value::HeaderValue","header::map::HeaderMap","uri::scheme::Protocol","byte_str::ByteStr","header::map::Bucket","header::name::StandardHeader","header::name::Custom","header::map::Links","uri::scheme::Scheme2","header::name::Repr","method::Method","header::name::MaybeLower","header::map::Cursor","status::StatusCode","<&mut T as std::fmt::Debug>","version::Version","header::map::Link","uri::path::PathAndQuery","header::name::HeaderName","uri::authority::Authority","header::map::ExtraValue","header::map::RawLinks","uri::scheme::Scheme","uri::Uri"]},"header::map::GetAll":{"T":["header::map::GetAll","header::map::HeaderMap","version::Version","header::name::Custom","header::map::Link","uri::ErrorKind","byte_str::ByteStr","header::map::HashValue","header::map::Cursor","<*const T as std::fmt::Debug>","header::name::Repr","header::name::StandardHeader"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::ExtraValue","header::map::IntoIter","uri::Uri","version::Version","header::map::Link","header::name::InvalidHeaderName","uri::builder::Builder","header::map::ValueIter","uri::authority::Authority","header::map::Bucket","response::Builder","header::map::OccupiedEntry","header::map::Values","error::Error","header::map::ValueIterMut","response::Response","uri::path::PathAndQuery","header::name::HeaderName","header::map::ValuesMut","uri::InvalidUriParts","byte_str::ByteStr","request::Parts","header::map::Links","header::value::HeaderValue","header::map::RawLinks","header::map::Keys","header::map::IterMut","header::map::HashValue","uri::scheme::Scheme2","header::map::Drain","uri::port::Port","<&T as std::fmt::Debug>","header::name::StandardHeader","uri::scheme::Scheme","response::Parts","header::name::HdrName","header::name::Custom","request::Builder","header::value::InvalidHeaderValue","method::InvalidMethod","extensions::Extensions","status::InvalidStatusCode","request::Request","header::map::ValueDrain","uri::ErrorKind","method::Method","header::map::GetAll","header::map::Cursor","header::map::HeaderMap","uri::InvalidUri","header::name::MaybeLower","header::map::VacantEntry","header::map::Iter","status::StatusCode","header::name::Repr","uri::scheme::Protocol","uri::Parts","header::map::Entry","header::value::ToStrError"]},"header::map::Iter":{"T":["header::map::Iter","header::map::ValueDrain","header::map::Drain","<*mut T as std::fmt::Debug>","header::map::ValueIterMut","header::map::IterMut"]},"header::map::IterMut":{"T":["header::map::Drain","header::map::Iter","<*const T as std::marker::Send>","header::map::ValueIterMut","header::map::ValueDrain","header::map::IterMut"]},"header::map::Keys":{"T":["header::name::HdrName","header::map::Cursor","header::name::Custom","error::Error","header::map::ValueIter","uri::scheme::Scheme","header::map::Iter","header::map::Entry","response::Response","status::InvalidStatusCode","uri::Uri","request::Builder","header::map::RawLinks","uri::scheme::Scheme2","header::name::Repr","request::Parts","extensions::Extensions","uri::Parts","header::name::HeaderName","method::Method","header::map::OccupiedEntry","header::map::Links","header::name::StandardHeader","header::value::InvalidHeaderValue","header::map::ValueDrain","header::map::GetAll","header::map::Drain","header::value::ToStrError","method::InvalidMethod","header::map::ValuesMut","header::value::HeaderValue","status::StatusCode","uri::authority::Authority","response::Parts","uri::path::PathAndQuery","header::name::InvalidHeaderName","<&mut T as std::fmt::Debug>","header::map::Bucket","uri::InvalidUriParts","request::Request","uri::ErrorKind","header::map::HeaderMap","header::map::HashValue","header::map::Keys","header::map::Values","uri::port::Port","header::map::IterMut","version::Version","header::map::ValueIterMut","byte_str::ByteStr","header::name::MaybeLower","uri::builder::Builder","header::map::Link","uri::InvalidUri","uri::scheme::Protocol","header::map::ExtraValue","header::map::VacantEntry","response::Builder","header::map::IntoIter"]},"header::map::OccupiedEntry":{"T":["header::map::IntoIter","header::map::ValuesMut","header::name::StandardHeader","byte_str::ByteStr","header::map::ExtraValue","header::map::GetAll","header::map::Cursor","header::map::RawLinks","header::map::Keys","header::map::Link","uri::authority::Authority","error::Error","header::map::ValueIterMut","uri::builder::Builder","header::map::IterMut","header::name::InvalidHeaderName","header::value::HeaderValue","method::Method","extensions::Extensions","header::map::Values","header::map::Entry","request::Request","header::name::Repr","status::StatusCode","header::map::Links","header::name::HdrName","<*const T as std::fmt::Debug>","header::map::ValueDrain","header::map::Bucket","uri::InvalidUri","header::map::HeaderMap","method::InvalidMethod","header::map::OccupiedEntry","uri::Parts","header::map::ValueIter","header::name::MaybeLower","header::map::VacantEntry","uri::path::PathAndQuery","request::Builder","uri::scheme::Scheme2","header::map::Drain","request::Parts","response::Parts","status::InvalidStatusCode","header::map::Iter","header::value::ToStrError","uri::scheme::Protocol","header::map::HashValue","response::Response","uri::port::Port","uri::InvalidUriParts","version::Version","response::Builder","header::value::InvalidHeaderValue","uri::scheme::Scheme","uri::Uri","uri::ErrorKind","header::name::Custom","header::name::HeaderName"]},"header::map::RawLinks":{"T":["method::InvalidMethod","uri::authority::Authority","uri::ErrorKind","header::map::ValueIter","status::StatusCode","extensions::Extensions","header::name::Custom","header::value::ToStrError","header::map::Link","header::map::Bucket","uri::Parts","header::map::VacantEntry","response::Parts","header::map::ExtraValue","response::Builder","error::Error","header::map::Keys","request::Request","uri::scheme::Protocol","header::map::Cursor","header::map::ValueDrain","header::map::Values","header::value::HeaderValue","request::Builder","header::map::GetAll","header::name::Repr","header::name::MaybeLower","uri::scheme::Scheme2","header::value::InvalidHeaderValue","header::map::HeaderMap","<*mut T as std::fmt::Debug>","version::Version","header::map::Links","header::name::InvalidHeaderName","header::map::IterMut","uri::path::PathAndQuery","uri::InvalidUriParts","uri::port::Port","header::map::Entry","header::map::Drain","header::name::HeaderName","response::Response","status::InvalidStatusCode","header::name::HdrName","byte_str::ByteStr","uri::Uri","uri::InvalidUri","method::Method","uri::builder::Builder","header::map::IntoIter","request::Parts","header::map::OccupiedEntry","header::map::HashValue","header::map::ValuesMut","header::map::RawLinks","uri::scheme::Scheme","header::name::StandardHeader","header::map::Iter","header::map::ValueIterMut"]},"header::map::VacantEntry":{"T":["header::map::ValueIter","header::map::Iter","header::map::Link","uri::ErrorKind","header::map::ValueDrain","request::Builder","header::map::IterMut","extensions::Extensions","byte_str::ByteStr","uri::path::PathAndQuery","header::name::Repr","header::name::InvalidHeaderName","header::map::Bucket","header::value::ToStrError","error::Error","header::map::Cursor","request::Parts","status::StatusCode","uri::scheme::Protocol","version::Version","header::map::Links","<&T as std::fmt::Debug>","header::value::HeaderValue","header::value::InvalidHeaderValue","header::name::HdrName","header::map::Entry","uri::scheme::Scheme","request::Request","header::name::MaybeLower","header::map::Keys","header::map::HeaderMap","header::map::HashValue","header::map::ExtraValue","header::map::GetAll","status::InvalidStatusCode","header::map::ValuesMut","header::name::StandardHeader","response::Parts","uri::Parts","header::name::HeaderName","response::Builder","uri::port::Port","header::map::VacantEntry","response::Response","uri::InvalidUri","header::map::OccupiedEntry","uri::InvalidUriParts","header::map::IntoIter","method::Method","header::map::Drain","uri::scheme::Scheme2","header::name::Custom","method::InvalidMethod","uri::builder::Builder","header::map::ValueIterMut","header::map::RawLinks","header::map::Values","uri::Uri","uri::authority::Authority"]},"header::map::ValueDrain":{"T":["header::map::Iter","header::map::ValueIterMut","header::map::IterMut","header::map::ValueDrain","<*const T as std::marker::Send>","header::map::Drain"]},"header::map::ValueIter":{"T":["header::map::ValueIter","response::Parts","response::Builder","header::map::ValueIterMut","header::map::ExtraValue","header::map::Links","header::name::MaybeLower","request::Request","uri::builder::Builder","status::StatusCode","uri::Uri","uri::scheme::Scheme2","uri::scheme::Scheme","status::InvalidStatusCode","header::map::Values","method::InvalidMethod","header::name::HdrName","header::name::InvalidHeaderName","header::value::HeaderValue","header::map::Entry","uri::path::PathAndQuery","header::map::Bucket","uri::Parts","uri::InvalidUriParts","<*mut T as std::fmt::Debug>","header::name::HeaderName","uri::port::Port","header::map::HeaderMap","header::value::ToStrError","request::Parts","response::Response","header::map::Iter","header::map::Keys","header::map::ValueDrain","header::map::Cursor","uri::ErrorKind","header::map::OccupiedEntry","header::map::HashValue","header::map::GetAll","byte_str::ByteStr","header::map::VacantEntry","request::Builder","extensions::Extensions","uri::scheme::Protocol","method::Method","uri::InvalidUri","header::value::InvalidHeaderValue","header::name::Custom","header::map::RawLinks","header::map::Link","header::map::IterMut","uri::authority::Authority","header::name::StandardHeader","header::map::IntoIter","header::map::ValuesMut","error::Error","header::map::Drain","version::Version","header::name::Repr"]},"header::map::ValueIterMut":{"T":["header::map::ValueIterMut","header::map::ValueDrain","header::map::Iter","<*const T as std::marker::Send>","header::map::Drain","header::map::IterMut"]},"header::map::Values":{"T":["method::Method","uri::InvalidUri","version::Version","header::map::Drain","header::map::ValueIter","uri::InvalidUriParts","header::name::HdrName","uri::path::PathAndQuery","header::map::IterMut","header::map::ValueIterMut","header::map::Iter","uri::scheme::Scheme2","header::map::Cursor","uri::authority::Authority","header::map::Bucket","uri::ErrorKind","response::Parts","header::name::HeaderName","header::map::HashValue","header::map::ValuesMut","header::map::Entry","uri::builder::Builder","uri::port::Port","uri::scheme::Scheme","request::Parts","uri::scheme::Protocol","header::map::ExtraValue","extensions::Extensions","response::Builder","header::map::Links","byte_str::ByteStr","status::InvalidStatusCode","header::map::ValueDrain","method::InvalidMethod","<*mut T as std::fmt::Debug>","header::value::InvalidHeaderValue","header::name::InvalidHeaderName","header::value::ToStrError","header::map::Values","header::map::IntoIter","header::name::MaybeLower","header::value::HeaderValue","header::map::HeaderMap","header::name::Repr","request::Builder","request::Request","header::map::Link","response::Response","header::map::RawLinks","header::map::VacantEntry","uri::Uri","uri::Parts","error::Error","header::name::Custom","status::StatusCode","header::map::Keys","header::map::GetAll","header::name::StandardHeader","header::map::OccupiedEntry"]},"header::map::ValuesMut":{"T":["header::name::HeaderName","header::name::MaybeLower","header::map::Values","header::map::ValuesMut","byte_str::ByteStr","header::map::ValueDrain","version::Version","uri::builder::Builder","uri::ErrorKind","uri::authority::Authority","<&mut T as std::fmt::Debug>","header::name::InvalidHeaderName","header::map::Bucket","status::InvalidStatusCode","status::StatusCode","header::map::VacantEntry","header::map::Link","header::map::Links","uri::path::PathAndQuery","header::name::StandardHeader","header::map::Keys","header::map::Iter","header::map::IterMut","header::name::HdrName","method::Method","header::name::Custom","header::map::ValueIterMut","header::map::HashValue","extensions::Extensions","uri::scheme::Scheme","uri::Uri","method::InvalidMethod","header::value::InvalidHeaderValue","header::map::Entry","request::Builder","uri::scheme::Protocol","request::Request","header::map::HeaderMap","request::Parts","header::map::RawLinks","header::map::Drain","error::Error","uri::scheme::Scheme2","response::Parts","uri::InvalidUri","uri::Parts","header::value::ToStrError","uri::port::Port","uri::InvalidUriParts","header::map::GetAll","header::value::HeaderValue","header::map::ExtraValue","header::name::Repr","response::Builder","header::map::ValueIter","response::Response","header::map::IntoIter","header::map::OccupiedEntry","header::map::Cursor"]},"header::name::Repr":{"T":["header::name::Repr","header::name::Custom","header::name::StandardHeader","std::hash::impls::<impl std::hash::Hash for *const T>","byte_str::ByteStr","version::Version"]},"request::Request":{"T":["uri::Parts","uri::Uri","method::Method","status::StatusCode","response::Response","request::Request","request::Builder","header::map::HeaderMap","version::Version","extensions::Extensions","uri::builder::Builder","response::Builder"]},"response::Response":{"T":["uri::Uri","version::Version","extensions::Extensions","status::StatusCode","method::Method","uri::Parts","response::Response","header::map::HeaderMap","request::Request","request::Builder","uri::builder::Builder","response::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"uri::port::Port":{"T":["method::Method","<&T as std::convert::AsRef<U>>","uri::scheme::Scheme","uri::port::Port","uri::authority::Authority","header::value::HeaderValue"]},"uri::scheme::Scheme2":{"T":["version::Version","header::map::HashValue","method::Method","header::map::ExtraValue","uri::Uri","header::map::HeaderMap","header::name::StandardHeader","header::name::Repr","header::map::Links","status::StatusCode","std::boxed::Box<byte_str::ByteStr>","header::map::Link","uri::authority::Authority","<&mut T as std::fmt::Debug>","uri::scheme::Protocol","header::map::RawLinks","header::name::HeaderName","header::value::HeaderValue","header::name::Custom","header::map::Cursor","byte_str::ByteStr","uri::path::PathAndQuery","header::map::Bucket","uri::scheme::Scheme2","uri::scheme::Scheme","header::name::MaybeLower"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Repr<T>
+p0.clone();
+<header::name::Repr<T> as std::clone::Clone>::clone(p0);
+crate::<header::name::Repr<T> as std::clone::Clone>::clone(p0);
+<header::name::Repr<T>>::clone(p0);
-----------------
src/header/name.rs <header::name::Repr<T> as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{"<header::name::Repr<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["std::marker::Sized","std::cmp::Eq"]},"header::map::HeaderMap":{"T":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::convert::TryFrom","std::marker::Sized"]},"header::name::Repr":{"T":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::hash::Hash"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<header::name::Repr<T> as std::cmp::Eq>::assert_receiver_is_total_eq":{"T":["uri::Uri","version::Http","header::value::HeaderValue","header::map::HashValue","byte_str::ByteStr","std::cmp::impls::<impl std::cmp::Eq for &A>","uri::scheme::Scheme","header::map::Link","uri::authority::Authority","header::name::Repr","header::name::HeaderName","header::map::Cursor","header::map::HeaderMap","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","header::name::StandardHeader","version::Version","status::StatusCode","uri::path::PathAndQuery","method::extension::InlineExtension","method::Inner","method::Method","header::name::Custom","method::extension::AllocatedExtension","uri::ErrorKind"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::name::Repr":{"T":["byte_str::ByteStr","version::Version","header::name::Custom","header::name::StandardHeader","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","header::name::Repr"]},"std::cmp::impls::<impl std::cmp::Eq for &A>":{},"std::cmp::impls::<impl std::cmp::Eq for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Repr<T>
+p0.assert_receiver_is_total_eq();
+<header::name::Repr<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<header::name::Repr<T> as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<header::name::Repr<T>>::assert_receiver_is_total_eq(p0);
-----------------
src/header/name.rs <header::name::Repr<T> as std::cmp::PartialEq>::eq
deps:{"<*const T as std::fmt::Debug>":{},"<header::name::Repr<T> as std::cmp::PartialEq>::eq":{"T":["std::marker::Sized","std::cmp::PartialEq"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::name::Repr":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::hash::Hash"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<header::name::Repr<T> as std::cmp::PartialEq>::eq":{"T":["method::extension::AllocatedExtension","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::name::StandardHeader","header::name::Repr","byte_str::ByteStr","header::map::Cursor","header::name::Custom","uri::ErrorKind","method::Inner","header::map::HeaderMap","version::Version","method::extension::InlineExtension","header::map::GetAll","version::Http","header::map::HashValue","header::map::Link"]},"header::map::GetAll":{"T":["header::map::HeaderMap","uri::ErrorKind","header::name::Repr","version::Version","header::map::HashValue","header::name::Custom","header::map::GetAll","byte_str::ByteStr","header::name::StandardHeader","<*const T as std::fmt::Debug>","header::map::Link","header::map::Cursor"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::name::Repr":{"T":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","version::Version","header::name::StandardHeader","header::name::Repr","header::name::Custom","byte_str::ByteStr"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Repr<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::name::Repr<T>
+p0.eq(p1);
+<header::name::Repr<T> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::name::Repr<T> as std::cmp::PartialEq>::eq(p0, p1);
+<header::name::Repr<T>>::eq(p0, p1);
-----------------
src/header/name.rs <header::name::Repr<T> as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<*const T as std::fmt::Debug>":{},"<header::name::Repr<T> as std::hash::Hash>::hash":{"T":["std::marker::Sized","std::hash::Hash"],"__H":["std::marker::Sized","std::hash::Hasher"]},"header::name::Repr":{"T":["std::hash::Hash","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<*const T as std::fmt::Debug>":{},"<header::name::Repr<T> as std::hash::Hash>::hash":{"T":["method::Inner","header::name::StandardHeader","std::hash::impls::<impl std::hash::Hash for &mut T>","uri::Uri","version::Http","byte_str::ByteStr","uri::scheme::Scheme","method::extension::InlineExtension","header::name::HeaderName","method::Method","header::name::HdrName","header::name::Repr","header::name::Custom","status::StatusCode","header::name::MaybeLower","method::extension::AllocatedExtension","header::value::HeaderValue","version::Version","uri::authority::Authority"],"__H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]},"header::name::Repr":{"T":["header::name::StandardHeader","header::name::Repr","header::name::Custom","byte_str::ByteStr","<*const T as std::fmt::Debug>","version::Version"]},"std::hash::impls::<impl std::hash::Hash for &T>":{},"std::hash::impls::<impl std::hash::Hash for &mut T>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Repr<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<header::name::Repr<T> as std::hash::Hash>::hash(p0, p1);
+crate::<header::name::Repr<T> as std::hash::Hash>::hash(p0, p1);
+<header::name::Repr<T>>::hash(p0, p1);
-----------------
src/header/name.rs <header::name::Custom as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Custom
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::name::Custom as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::name::Custom as std::fmt::Debug>::fmt(p0, p1);
+<header::name::Custom>::fmt(p0, p1);
-----------------
src/header/name.rs <header::name::Custom as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Custom
+p0.clone();
+<header::name::Custom as std::clone::Clone>::clone(p0);
+crate::<header::name::Custom as std::clone::Clone>::clone(p0);
+<header::name::Custom>::clone(p0);
-----------------
src/header/name.rs <header::name::Custom as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Custom
+p0.assert_receiver_is_total_eq();
+<header::name::Custom as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<header::name::Custom as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<header::name::Custom>::assert_receiver_is_total_eq(p0);
-----------------
src/header/name.rs <header::name::Custom as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Custom
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::name::Custom
+p0.eq(p1);
+<header::name::Custom as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::name::Custom as std::cmp::PartialEq>::eq(p0, p1);
+<header::name::Custom>::eq(p0, p1);
-----------------
src/header/name.rs <header::name::MaybeLower<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::MaybeLower<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::name::MaybeLower<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::name::MaybeLower<'a> as std::fmt::Debug>::fmt(p0, p1);
+<header::name::MaybeLower<'a>>::fmt(p0, p1);
-----------------
src/header/name.rs <header::name::MaybeLower<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::MaybeLower<'a>
+p0.clone();
+<header::name::MaybeLower<'a> as std::clone::Clone>::clone(p0);
+crate::<header::name::MaybeLower<'a> as std::clone::Clone>::clone(p0);
+<header::name::MaybeLower<'a>>::clone(p0);
-----------------
src/header/name.rs <header::name::StandardHeader as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::StandardHeader
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::name::StandardHeader as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::name::StandardHeader as std::fmt::Debug>::fmt(p0, p1);
+<header::name::StandardHeader>::fmt(p0, p1);
-----------------
src/header/name.rs <header::name::StandardHeader as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::StandardHeader
+p0.clone();
+<header::name::StandardHeader as std::clone::Clone>::clone(p0);
+crate::<header::name::StandardHeader as std::clone::Clone>::clone(p0);
+<header::name::StandardHeader>::clone(p0);
-----------------
src/header/name.rs <header::name::StandardHeader as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::StandardHeader
+p0.assert_receiver_is_total_eq();
+<header::name::StandardHeader as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<header::name::StandardHeader as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<header::name::StandardHeader>::assert_receiver_is_total_eq(p0);
-----------------
src/header/name.rs <header::name::StandardHeader as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::StandardHeader
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::name::StandardHeader
+p0.eq(p1);
+<header::name::StandardHeader as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::name::StandardHeader as std::cmp::PartialEq>::eq(p0, p1);
+<header::name::StandardHeader>::eq(p0, p1);
-----------------
src/header/name.rs <header::name::StandardHeader as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<header::name::StandardHeader as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<header::name::StandardHeader as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::StandardHeader
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<header::name::StandardHeader as std::hash::Hash>::hash(p0, p1);
+crate::<header::name::StandardHeader as std::hash::Hash>::hash(p0, p1);
+<header::name::StandardHeader>::hash(p0, p1);
-----------------
src/header/name.rs header::name::StandardHeader::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::StandardHeader
+p0.as_str();
+header::name::StandardHeader::as_str(p0);
+crate::header::name::StandardHeader::as_str(p0);
+<header::name::StandardHeader>::as_str(p0);
-----------------
src/header/name.rs <header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::StandardHeader
+<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from(p0);
+crate::<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from(p0);
+<header::name::HdrName<'a>>::from(p0);
-----------------
src/header/name.rs header::name::HeaderName::from_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+header::name::HeaderName::from_bytes(p0);
+crate::header::name::HeaderName::from_bytes(p0);
+<header::name::HeaderName>::from_bytes(p0);
-----------------
src/header/name.rs header::name::HeaderName::from_lowercase
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+header::name::HeaderName::from_lowercase(p0);
+crate::header::name::HeaderName::from_lowercase(p0);
+<header::name::HeaderName>::from_lowercase(p0);
-----------------
src/header/name.rs header::name::HeaderName::from_static
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+header::name::HeaderName::from_static(&p0);
+crate::header::name::HeaderName::from_static(&p0);
+<header::name::HeaderName>::from_static(&p0);
-----------------
src/header/name.rs header::name::HeaderName::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.as_str();
+header::name::HeaderName::as_str(p0);
+crate::header::name::HeaderName::as_str(p0);
+<header::name::HeaderName>::as_str(p0);
-----------------
src/header/name.rs header::name::HeaderName::into_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.into_bytes();
+header::name::HeaderName::into_bytes(p0);
+crate::header::name::HeaderName::into_bytes(p0);
+<header::name::HeaderName>::into_bytes(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<header::name::HeaderName as std::str::FromStr>::from_str(&p0);
+crate::<header::name::HeaderName as std::str::FromStr>::from_str(&p0);
+<header::name::HeaderName>::from_str(&p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::convert::AsRef<str>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.as_ref();
+<header::name::HeaderName as std::convert::AsRef<str>>::as_ref(p0);
+crate::<header::name::HeaderName as std::convert::AsRef<str>>::as_ref(p0);
+<header::name::HeaderName>::as_ref(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.as_ref();
+<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref(p0);
+crate::<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref(p0);
+<header::name::HeaderName>::as_ref(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::borrow::Borrow<str>>::borrow
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.borrow();
+<header::name::HeaderName as std::borrow::Borrow<str>>::borrow(p0);
+crate::<header::name::HeaderName as std::borrow::Borrow<str>>::borrow(p0);
+<header::name::HeaderName>::borrow(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::name::HeaderName as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::name::HeaderName as std::fmt::Debug>::fmt(p0, p1);
+<header::name::HeaderName>::fmt(p0, p1);
-----------------
src/header/name.rs <header::name::HeaderName as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<header::name::HeaderName as std::fmt::Display>::fmt(p0, p1);
+crate::<header::name::HeaderName as std::fmt::Display>::fmt(p0, p1);
+<header::name::HeaderName>::fmt(p0, p1);
-----------------
src/header/name.rs header::name::InvalidHeaderName::new
deps:{}
candidates:{}
+header::name::InvalidHeaderName::new();
+crate::header::name::InvalidHeaderName::new();
+<header::name::InvalidHeaderName>::new();
-----------------
src/header/name.rs <header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from(p0);
+crate::<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from(p0);
+<header::name::HeaderName>::from(p0);
-----------------
src/header/name.rs header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from":{"T":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from":{"T":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::Repr<T>
+header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from(p0);
+crate::header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from(p0);
+<bytes::Bytes>::from(p0);
-----------------
src/header/name.rs header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::Custom
+header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from(p0);
+crate::header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from(p0);
+<bytes::Bytes>::from(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::convert::TryFrom<&'a str>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<header::name::HeaderName as std::convert::TryFrom<&'a str>>::try_from(&p0);
+crate::<header::name::HeaderName as std::convert::TryFrom<&'a str>>::try_from(&p0);
+<header::name::HeaderName>::try_from(&p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::convert::TryFrom<&'a std::string::String>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<header::name::HeaderName as std::convert::TryFrom<&'a std::string::String>>::try_from(p0);
+crate::<header::name::HeaderName as std::convert::TryFrom<&'a std::string::String>>::try_from(p0);
+<header::name::HeaderName>::try_from(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::convert::TryFrom<&'a [u8]>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<header::name::HeaderName as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+crate::<header::name::HeaderName as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+<header::name::HeaderName>::try_from(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::StandardHeader
+<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from(p0);
+crate::<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from(p0);
+<header::name::HeaderName>::from(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::convert::From<header::name::Custom>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::Custom
+<header::name::HeaderName as std::convert::From<header::name::Custom>>::from(p0);
+crate::<header::name::HeaderName as std::convert::From<header::name::Custom>>::from(p0);
+<header::name::HeaderName>::from(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = & & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.eq(p1);
+<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq(p0, p1);
+crate::<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq(p0, p1);
+<header::name::HeaderName>::eq(p0, p1);
-----------------
src/header/name.rs <&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.eq(p1);
+<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq(p0, p1);
+crate::<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq(p0, p1);
+<&'a header::name::HeaderName>::eq(p0, p1);
-----------------
src/header/name.rs <header::name::HeaderName as std::cmp::PartialEq<str>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<header::name::HeaderName as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<header::name::HeaderName as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<header::name::HeaderName>::eq(p0, &p1);
-----------------
src/header/name.rs header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.eq(p1);
+header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq(&p0, p1);
+crate::header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq(&p0, p1);
+<str>::eq(&p0, p1);
-----------------
src/header/name.rs <header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = & "a"; // None+&'a str
+p0.eq(p1);
+<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+crate::<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+<header::name::HeaderName>::eq(p0, p1);
-----------------
src/header/name.rs header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+p0.eq(p1);
+header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq(p0, p1);
+crate::header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq(p0, p1);
+<&'a str>::eq(p0, p1);
-----------------
src/header/name.rs <header::name::InvalidHeaderName as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::InvalidHeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::name::InvalidHeaderName as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::name::InvalidHeaderName as std::fmt::Debug>::fmt(p0, p1);
+<header::name::InvalidHeaderName>::fmt(p0, p1);
-----------------
src/header/name.rs <header::name::InvalidHeaderName as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::InvalidHeaderName
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<header::name::InvalidHeaderName as std::fmt::Display>::fmt(p0, p1);
+crate::<header::name::InvalidHeaderName as std::fmt::Display>::fmt(p0, p1);
+<header::name::InvalidHeaderName>::fmt(p0, p1);
-----------------
src/header/name.rs header::name::HdrName::<'a>::custom
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = true; // None+bool
+header::name::HdrName::<'a>::custom(p0, p1);
+crate::header::name::HdrName::<'a>::custom(p0, p1);
+<header::name::HdrName<'a>>::custom(p0, p1);
-----------------
src/header/name.rs header::name::HdrName::<'a>::from_bytes
'a
deps:{"header::name::HdrName::<'a>::from_bytes":{"F":["std::marker::Sized","std::ops::FnOnce"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"header::name::HdrName::<'a>::from_bytes":{"F":["core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::panic::AssertUnwindSafe<F>"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+header::name::HdrName::<'a>::from_bytes(p0, p1);
+crate::header::name::HdrName::<'a>::from_bytes(p0, p1);
+<header::name::HdrName<'a>>::from_bytes(p0, p1);
-----------------
src/header/name.rs header::name::HdrName::<'a>::from_static
'a
deps:{"header::name::HdrName::<'a>::from_static":{"F":["std::marker::Sized","std::ops::FnOnce"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"header::name::HdrName::<'a>::from_static":{"F":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::panic::AssertUnwindSafe<F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+header::name::HdrName::<'a>::from_static(&p0, p1);
+crate::header::name::HdrName::<'a>::from_static(&p0, p1);
+<header::name::HdrName<'a>>::from_static(&p0, p1);
-----------------
src/header/name.rs <header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::HdrName<'a>
+<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from(p0);
+crate::<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from(p0);
+<header::name::HeaderName>::from(p0);
-----------------
src/header/name.rs <header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::HeaderName
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::name::HdrName<'a>
+p0.eq(p1);
+<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq(p0, p1);
+crate::<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq(p0, p1);
+<header::name::HeaderName>::eq(p0, p1);
-----------------
src/header/name.rs <header::name::Custom as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<header::name::Custom as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<header::name::Custom as std::hash::Hash>::hash":{"H":["extensions::IdHasher","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::Custom
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<header::name::Custom as std::hash::Hash>::hash(p0, p1);
+crate::<header::name::Custom as std::hash::Hash>::hash(p0, p1);
+<header::name::Custom>::hash(p0, p1);
-----------------
src/header/name.rs <header::name::MaybeLower<'a> as std::hash::Hash>::hash
'a
deps:{"<&mut H as std::hash::Hasher>":{},"<header::name::MaybeLower<'a> as std::hash::Hash>::hash":{"H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<header::name::MaybeLower<'a> as std::hash::Hash>::hash":{"H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::name::MaybeLower<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<header::name::MaybeLower<'a> as std::hash::Hash>::hash(p0, p1);
+crate::<header::name::MaybeLower<'a> as std::hash::Hash>::hash(p0, p1);
+<header::name::MaybeLower<'a>>::hash(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.clone();
+<header::value::HeaderValue as std::clone::Clone>::clone(p0);
+crate::<header::value::HeaderValue as std::clone::Clone>::clone(p0);
+<header::value::HeaderValue>::clone(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<header::value::HeaderValue as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<header::value::HeaderValue as std::hash::Hash>::hash":{"__H":["extensions::IdHasher","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<header::value::HeaderValue as std::hash::Hash>::hash(p0, p1);
+crate::<header::value::HeaderValue as std::hash::Hash>::hash(p0, p1);
+<header::value::HeaderValue>::hash(p0, p1);
-----------------
src/header/value.rs <header::value::ToStrError as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::ToStrError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::value::ToStrError as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::value::ToStrError as std::fmt::Debug>::fmt(p0, p1);
+<header::value::ToStrError>::fmt(p0, p1);
-----------------
src/header/value.rs header::value::HeaderValue::from_static
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+header::value::HeaderValue::from_static(&p0);
+crate::header::value::HeaderValue::from_static(&p0);
+<header::value::HeaderValue>::from_static(&p0);
-----------------
src/header/value.rs header::value::HeaderValue::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+header::value::HeaderValue::from_str(&p0);
+crate::header::value::HeaderValue::from_str(&p0);
+<header::value::HeaderValue>::from_str(&p0);
-----------------
src/header/value.rs header::value::HeaderValue::from_name
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+header::value::HeaderValue::from_name(p0);
+crate::header::value::HeaderValue::from_name(p0);
+<header::value::HeaderValue>::from_name(p0);
-----------------
src/header/value.rs header::value::HeaderValue::from_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+header::value::HeaderValue::from_bytes(p0);
+crate::header::value::HeaderValue::from_bytes(p0);
+<header::value::HeaderValue>::from_bytes(p0);
-----------------
src/header/value.rs header::value::HeaderValue::from_maybe_shared
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"header::value::HeaderValue::from_maybe_shared":{"T":["std::marker::Sized","std::convert::AsRef"]},"uri::port::Port":{"T":["std::fmt::Debug","std::marker::Sized","std::convert::AsRef"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"header::value::HeaderValue::from_maybe_shared":{"T":["<&mut T as std::convert::AsRef<U>>","header::value::HeaderValue","<&T as std::convert::AsRef<U>>","uri::port::Port","method::Method","uri::scheme::Scheme","uri::authority::Authority"]},"uri::port::Port":{"T":["uri::authority::Authority","<&mut T as std::fmt::Debug>","method::Method","uri::port::Port","uri::scheme::Scheme","header::value::HeaderValue"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+header::value::HeaderValue::from_maybe_shared(p0);
+crate::header::value::HeaderValue::from_maybe_shared(p0);
+<header::value::HeaderValue>::from_maybe_shared(p0);
-----------------
src/header/value.rs header::value::HeaderValue::from_maybe_shared_unchecked
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"header::value::HeaderValue::from_maybe_shared_unchecked":{"T":["std::marker::Sized","std::convert::AsRef"]},"uri::port::Port":{"T":["std::convert::AsRef","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"header::value::HeaderValue::from_maybe_shared_unchecked":{"T":["<&mut T as std::convert::AsRef<U>>","<&T as std::convert::AsRef<U>>","uri::authority::Authority","uri::port::Port","uri::scheme::Scheme","method::Method","header::value::HeaderValue"]},"uri::port::Port":{"T":["uri::port::Port","header::value::HeaderValue","method::Method","uri::scheme::Scheme","uri::authority::Authority","<&T as std::convert::AsRef<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+header::value::HeaderValue::from_maybe_shared_unchecked(p0);
+crate::header::value::HeaderValue::from_maybe_shared_unchecked(p0);
+<header::value::HeaderValue>::from_maybe_shared_unchecked(p0);
-----------------
src/header/value.rs header::value::HeaderValue::from_shared
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // bytes::Bytes
+header::value::HeaderValue::from_shared(p0);
+crate::header::value::HeaderValue::from_shared(p0);
+<header::value::HeaderValue>::from_shared(p0);
-----------------
src/header/value.rs header::value::HeaderValue::try_from_generic
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"header::value::HeaderValue::try_from_generic":{"F":["std::marker::Sized","std::ops::FnOnce"],"T":["std::convert::AsRef","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"header::value::HeaderValue::try_from_generic":{"F":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::panic::AssertUnwindSafe<F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty"],"T":["<&mut T as std::convert::AsRef<U>>","uri::port::Port","method::Method","uri::scheme::Scheme","uri::authority::Authority","header::value::HeaderValue","<&T as std::convert::AsRef<U>>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"uri::port::Port":{"T":["uri::port::Port","method::Method","<&mut T as std::convert::AsRef<U>>","uri::authority::Authority","uri::scheme::Scheme","header::value::HeaderValue"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+header::value::HeaderValue::try_from_generic(p0, p1);
+crate::header::value::HeaderValue::try_from_generic(p0, p1);
+<header::value::HeaderValue>::try_from_generic(p0, p1);
-----------------
src/header/value.rs header::value::HeaderValue::to_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.to_str();
+header::value::HeaderValue::to_str(p0);
+crate::header::value::HeaderValue::to_str(p0);
+<header::value::HeaderValue>::to_str(p0);
-----------------
src/header/value.rs header::value::HeaderValue::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.len();
+header::value::HeaderValue::len(p0);
+crate::header::value::HeaderValue::len(p0);
+<header::value::HeaderValue>::len(p0);
-----------------
src/header/value.rs header::value::HeaderValue::is_empty
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.is_empty();
+header::value::HeaderValue::is_empty(p0);
+crate::header::value::HeaderValue::is_empty(p0);
+<header::value::HeaderValue>::is_empty(p0);
-----------------
src/header/value.rs header::value::HeaderValue::as_bytes
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.as_bytes();
+header::value::HeaderValue::as_bytes(p0);
+crate::header::value::HeaderValue::as_bytes(p0);
+<header::value::HeaderValue>::as_bytes(p0);
-----------------
src/header/value.rs header::value::HeaderValue::set_sensitive
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = true; // None+bool
+p0.set_sensitive(p1);
+header::value::HeaderValue::set_sensitive(p0, p1);
+crate::header::value::HeaderValue::set_sensitive(p0, p1);
+<header::value::HeaderValue>::set_sensitive(p0, p1);
-----------------
src/header/value.rs header::value::HeaderValue::is_sensitive
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.is_sensitive();
+header::value::HeaderValue::is_sensitive(p0);
+crate::header::value::HeaderValue::is_sensitive(p0);
+<header::value::HeaderValue>::is_sensitive(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.as_ref();
+<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref(p0);
+crate::<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref(p0);
+<header::value::HeaderValue>::as_ref(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::value::HeaderValue as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::value::HeaderValue as std::fmt::Debug>::fmt(p0, p1);
+<header::value::HeaderValue>::fmt(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::HeaderName
+<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<u16>>::from
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<header::value::HeaderValue as std::convert::From<u16>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<u16>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<i16>>::from
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<header::value::HeaderValue as std::convert::From<i16>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<i16>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<u32>>::from
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<header::value::HeaderValue as std::convert::From<u32>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<u32>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<i32>>::from
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<header::value::HeaderValue as std::convert::From<i32>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<i32>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<u64>>::from
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<header::value::HeaderValue as std::convert::From<u64>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<u64>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<i64>>::from
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<header::value::HeaderValue as std::convert::From<i64>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<i64>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<usize>>::from
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<header::value::HeaderValue as std::convert::From<usize>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<usize>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<isize>>::from
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<header::value::HeaderValue as std::convert::From<isize>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<isize>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<header::value::HeaderValue as std::str::FromStr>::from_str(&p0);
+crate::<header::value::HeaderValue as std::str::FromStr>::from_str(&p0);
+<header::value::HeaderValue>::from_str(&p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from(p0);
+crate::<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from(p0);
+<header::value::HeaderValue>::from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::TryFrom<&'a str>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<header::value::HeaderValue as std::convert::TryFrom<&'a str>>::try_from(&p0);
+crate::<header::value::HeaderValue as std::convert::TryFrom<&'a str>>::try_from(&p0);
+<header::value::HeaderValue>::try_from(&p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::TryFrom<&'a std::string::String>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<header::value::HeaderValue as std::convert::TryFrom<&'a std::string::String>>::try_from(p0);
+crate::<header::value::HeaderValue as std::convert::TryFrom<&'a std::string::String>>::try_from(p0);
+<header::value::HeaderValue>::try_from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::TryFrom<&'a [u8]>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<header::value::HeaderValue as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+crate::<header::value::HeaderValue as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+<header::value::HeaderValue>::try_from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::TryFrom<std::string::String>>::try_from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<header::value::HeaderValue as std::convert::TryFrom<std::string::String>>::try_from(p0);
+crate::<header::value::HeaderValue as std::convert::TryFrom<std::string::String>>::try_from(p0);
+<header::value::HeaderValue>::try_from(p0);
-----------------
src/header/value.rs <header::value::HeaderValue as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+<header::value::HeaderValue as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from(p0);
+crate::<header::value::HeaderValue as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from(p0);
+<header::value::HeaderValue>::try_from(p0);
-----------------
src/header/value.rs <header::value::InvalidHeaderValue as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::InvalidHeaderValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt(p0, p1);
+crate::<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt(p0, p1);
+<header::value::InvalidHeaderValue>::fmt(p0, p1);
-----------------
src/header/value.rs <header::value::InvalidHeaderValue as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::InvalidHeaderValue
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<header::value::InvalidHeaderValue as std::fmt::Display>::fmt(p0, p1);
+crate::<header::value::InvalidHeaderValue as std::fmt::Display>::fmt(p0, p1);
+<header::value::InvalidHeaderValue>::fmt(p0, p1);
-----------------
src/header/value.rs <header::value::ToStrError as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::ToStrError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<header::value::ToStrError as std::fmt::Display>::fmt(p0, p1);
+crate::<header::value::ToStrError as std::fmt::Display>::fmt(p0, p1);
+<header::value::ToStrError>::fmt(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.eq(p1);
+<header::value::HeaderValue as std::cmp::PartialEq>::eq(p0, p1);
+crate::<header::value::HeaderValue as std::cmp::PartialEq>::eq(p0, p1);
+<header::value::HeaderValue>::eq(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.partial_cmp(p1);
+<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<header::value::HeaderValue>::partial_cmp(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.cmp(p1);
+<header::value::HeaderValue as std::cmp::Ord>::cmp(p0, p1);
+crate::<header::value::HeaderValue as std::cmp::Ord>::cmp(p0, p1);
+<header::value::HeaderValue>::cmp(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialEq<str>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<header::value::HeaderValue>::eq(p0, &p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.eq(p1);
+<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq(p0, p1);
+crate::<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq(p0, p1);
+<header::value::HeaderValue>::eq(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = "sample"; // None+&str
+p0.partial_cmp(&p1);
+<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp(p0, &p1);
+crate::<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp(p0, &p1);
+<header::value::HeaderValue>::partial_cmp(p0, &p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.partial_cmp(p1);
+<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp(p0, p1);
+crate::<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp(p0, p1);
+<header::value::HeaderValue>::partial_cmp(p0, p1);
-----------------
src/header/value.rs header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.eq(p1);
+header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq(&p0, p1);
+crate::header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq(&p0, p1);
+<str>::eq(&p0, p1);
-----------------
src/header/value.rs header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.eq(p1);
+header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq(p0, p1);
+crate::header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq(p0, p1);
+<[u8]>::eq(p0, p1);
-----------------
src/header/value.rs header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.partial_cmp(p1);
+header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp(&p0, p1);
+crate::header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp(&p0, p1);
+<str>::partial_cmp(&p0, p1);
-----------------
src/header/value.rs header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.partial_cmp(p1);
+header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp(p0, p1);
+crate::header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp(p0, p1);
+<[u8]>::partial_cmp(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.eq(p1);
+<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+crate::<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+<header::value::HeaderValue>::eq(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.partial_cmp(p1);
+<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp(p0, p1);
+crate::<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp(p0, p1);
+<header::value::HeaderValue>::partial_cmp(p0, p1);
-----------------
src/header/value.rs header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.eq(p1);
+header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq(p0, p1);
+crate::header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq(p0, p1);
+<std::string::String>::eq(p0, p1);
-----------------
src/header/value.rs header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.partial_cmp(p1);
+header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp(p0, p1);
+crate::header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp(p0, p1);
+<std::string::String>::partial_cmp(p0, p1);
-----------------
src/header/value.rs <&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.eq(p1);
+<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq(p0, p1);
+crate::<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq(p0, p1);
+<&'a header::value::HeaderValue>::eq(p0, p1);
-----------------
src/header/value.rs <&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.partial_cmp(p1);
+<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp(p0, p1);
+crate::<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp(p0, p1);
+<&'a header::value::HeaderValue>::partial_cmp(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq
'a
deps:{"<*const T as std::fmt::Debug>":{},"<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq":{"header::value::HeaderValue":["std::cmp::PartialEq"]},"header::map::GetAll":{"T":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::convert::TryFrom","std::cmp::Eq"]},"header::name::Repr":{"T":["std::clone::Clone","std::fmt::Debug","std::hash::Hash","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq":{"header::value::HeaderValue":["header::map::Cursor","header::map::GetAll","header::map::Link","header::map::HeaderMap","header::name::Custom","header::map::HashValue","version::Http","byte_str::ByteStr","uri::ErrorKind","method::extension::AllocatedExtension","header::name::Repr","method::Inner","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","method::extension::InlineExtension","version::Version","header::name::StandardHeader"]},"header::map::GetAll":{"T":["header::name::Repr","header::map::GetAll","header::map::Cursor","version::Version","header::name::StandardHeader","byte_str::ByteStr","header::map::HeaderMap","uri::ErrorKind","header::name::Custom","header::map::HashValue","std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>","header::map::Link"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"header::name::Repr":{"T":["header::name::Repr","<*const T as std::fmt::Debug>","version::Version","header::name::Custom","byte_str::ByteStr","header::name::StandardHeader"]},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = & & MaybeUninit::uninit().assume_init(); // T
+p0.eq(p1);
+<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq(p0, p1);
+crate::<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq(p0, p1);
+<header::value::HeaderValue>::eq(p0, p1);
-----------------
src/header/value.rs <header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp
'a
deps:{"<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp":{"header::value::HeaderValue":["std::cmp::PartialOrd"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
candidates:{"<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp":{"header::value::HeaderValue":["version::Http","std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>","status::StatusCode","byte_str::ByteStr","version::Version"]},"std::cmp::impls::<impl std::cmp::PartialOrd<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialOrd<&mut B> for &mut A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialOrd for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialOrd for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
let mut p1 = & & MaybeUninit::uninit().assume_init(); // T
+p0.partial_cmp(p1);
+<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp(p0, p1);
+crate::<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp(p0, p1);
+<header::value::HeaderValue>::partial_cmp(p0, p1);
-----------------
src/header/value.rs header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.eq(p1);
+header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq(p0, p1);
+crate::header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq(p0, p1);
+<&'a str>::eq(p0, p1);
-----------------
src/header/value.rs header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // header::value::HeaderValue
+p0.partial_cmp(p1);
+header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp(p0, p1);
+crate::header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp(p0, p1);
+<&'a str>::partial_cmp(p0, p1);
-----------------
src/method.rs <method::Method as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.clone();
+<method::Method as std::clone::Clone>::clone(p0);
+crate::<method::Method as std::clone::Clone>::clone(p0);
+<method::Method>::clone(p0);
-----------------
src/method.rs <method::Method as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
let mut p1 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.eq(p1);
+<method::Method as std::cmp::PartialEq>::eq(p0, p1);
+crate::<method::Method as std::cmp::PartialEq>::eq(p0, p1);
+<method::Method>::eq(p0, p1);
-----------------
src/method.rs <method::Method as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.assert_receiver_is_total_eq();
+<method::Method as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<method::Method as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<method::Method>::assert_receiver_is_total_eq(p0);
-----------------
src/method.rs <method::Method as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<method::Method as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<method::Method as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<method::Method as std::hash::Hash>::hash(p0, p1);
+crate::<method::Method as std::hash::Hash>::hash(p0, p1);
+<method::Method>::hash(p0, p1);
-----------------
src/method.rs <method::Inner as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Inner
+p0.clone();
+<method::Inner as std::clone::Clone>::clone(p0);
+crate::<method::Inner as std::clone::Clone>::clone(p0);
+<method::Inner>::clone(p0);
-----------------
src/method.rs <method::Inner as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Inner
let mut p1 = & MaybeUninit::uninit().assume_init(); // method::Inner
+p0.eq(p1);
+<method::Inner as std::cmp::PartialEq>::eq(p0, p1);
+crate::<method::Inner as std::cmp::PartialEq>::eq(p0, p1);
+<method::Inner>::eq(p0, p1);
-----------------
src/method.rs <method::Inner as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Inner
+p0.assert_receiver_is_total_eq();
+<method::Inner as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<method::Inner as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<method::Inner>::assert_receiver_is_total_eq(p0);
-----------------
src/method.rs <method::Inner as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<method::Inner as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<method::Inner as std::hash::Hash>::hash":{"__H":["extensions::IdHasher","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Inner
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<method::Inner as std::hash::Hash>::hash(p0, p1);
+crate::<method::Inner as std::hash::Hash>::hash(p0, p1);
+<method::Inner>::hash(p0, p1);
-----------------
src/method.rs method::Method::from_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+method::Method::from_bytes(p0);
+crate::method::Method::from_bytes(p0);
+<method::Method>::from_bytes(p0);
-----------------
src/method.rs method::Method::extension_inline
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+method::Method::extension_inline(p0);
+crate::method::Method::extension_inline(p0);
+<method::Method>::extension_inline(p0);
-----------------
src/method.rs method::Method::is_safe
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.is_safe();
+method::Method::is_safe(p0);
+crate::method::Method::is_safe(p0);
+<method::Method>::is_safe(p0);
-----------------
src/method.rs method::Method::is_idempotent
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.is_idempotent();
+method::Method::is_idempotent(p0);
+crate::method::Method::is_idempotent(p0);
+<method::Method>::is_idempotent(p0);
-----------------
src/method.rs method::Method::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.as_str();
+method::Method::as_str(p0);
+crate::method::Method::as_str(p0);
+<method::Method>::as_str(p0);
-----------------
src/method.rs <method::Method as std::convert::AsRef<str>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.as_ref();
+<method::Method as std::convert::AsRef<str>>::as_ref(p0);
+crate::<method::Method as std::convert::AsRef<str>>::as_ref(p0);
+<method::Method>::as_ref(p0);
-----------------
src/method.rs <method::Method as std::cmp::PartialEq<&'a method::Method>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
let mut p1 = & & MaybeUninit::uninit().assume_init(); // method::Method
+p0.eq(p1);
+<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq(p0, p1);
+crate::<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq(p0, p1);
+<method::Method>::eq(p0, p1);
-----------------
src/method.rs <&'a method::Method as std::cmp::PartialEq<method::Method>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // method::Method
let mut p1 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.eq(p1);
+<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq(p0, p1);
+crate::<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq(p0, p1);
+<&'a method::Method>::eq(p0, p1);
-----------------
src/method.rs <method::Method as std::cmp::PartialEq<str>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<method::Method as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<method::Method as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<method::Method>::eq(p0, &p1);
-----------------
src/method.rs method::<impl std::cmp::PartialEq<method::Method> for str>::eq
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.eq(p1);
+method::<impl std::cmp::PartialEq<method::Method> for str>::eq(&p0, p1);
+crate::method::<impl std::cmp::PartialEq<method::Method> for str>::eq(&p0, p1);
+<str>::eq(&p0, p1);
-----------------
src/method.rs <method::Method as std::cmp::PartialEq<&'a str>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
let mut p1 = & "a"; // None+&'a str
+p0.eq(p1);
+<method::Method as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+crate::<method::Method as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+<method::Method>::eq(p0, p1);
-----------------
src/method.rs method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // method::Method
+p0.eq(p1);
+method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq(p0, p1);
+crate::method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq(p0, p1);
+<&'a str>::eq(p0, p1);
-----------------
src/method.rs <method::Method as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<method::Method as std::fmt::Debug>::fmt(p0, p1);
+crate::<method::Method as std::fmt::Debug>::fmt(p0, p1);
+<method::Method>::fmt(p0, p1);
-----------------
src/method.rs <method::Method as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<method::Method as std::fmt::Display>::fmt(p0, p1);
+crate::<method::Method as std::fmt::Display>::fmt(p0, p1);
+<method::Method>::fmt(p0, p1);
-----------------
src/method.rs <method::Method as std::default::Default>::default
deps:{}
candidates:{}
+<method::Method as std::default::Default>::default();
+crate::<method::Method as std::default::Default>::default();
+<method::Method>::default();
-----------------
src/method.rs <method::Method as std::convert::From<&'a method::Method>>::from
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::Method
+<method::Method as std::convert::From<&'a method::Method>>::from(p0);
+crate::<method::Method as std::convert::From<&'a method::Method>>::from(p0);
+<method::Method>::from(p0);
-----------------
src/method.rs <method::Method as std::convert::TryFrom<&'a [u8]>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<method::Method as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+crate::<method::Method as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+<method::Method>::try_from(p0);
-----------------
src/method.rs <method::Method as std::convert::TryFrom<&'a str>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<method::Method as std::convert::TryFrom<&'a str>>::try_from(&p0);
+crate::<method::Method as std::convert::TryFrom<&'a str>>::try_from(&p0);
+<method::Method>::try_from(&p0);
-----------------
src/method.rs <method::Method as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<method::Method as std::str::FromStr>::from_str(&p0);
+crate::<method::Method as std::str::FromStr>::from_str(&p0);
+<method::Method>::from_str(&p0);
-----------------
src/method.rs method::InvalidMethod::new
deps:{}
candidates:{}
+method::InvalidMethod::new();
+crate::method::InvalidMethod::new();
+<method::InvalidMethod>::new();
-----------------
src/method.rs <method::InvalidMethod as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::InvalidMethod
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<method::InvalidMethod as std::fmt::Debug>::fmt(p0, p1);
+crate::<method::InvalidMethod as std::fmt::Debug>::fmt(p0, p1);
+<method::InvalidMethod>::fmt(p0, p1);
-----------------
src/method.rs <method::InvalidMethod as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::InvalidMethod
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<method::InvalidMethod as std::fmt::Display>::fmt(p0, p1);
+crate::<method::InvalidMethod as std::fmt::Display>::fmt(p0, p1);
+<method::InvalidMethod>::fmt(p0, p1);
-----------------
src/method.rs <method::extension::InlineExtension as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::InlineExtension
+p0.clone();
+<method::extension::InlineExtension as std::clone::Clone>::clone(p0);
+crate::<method::extension::InlineExtension as std::clone::Clone>::clone(p0);
+<method::extension::InlineExtension>::clone(p0);
-----------------
src/method.rs <method::extension::InlineExtension as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::InlineExtension
let mut p1 = & MaybeUninit::uninit().assume_init(); // method::extension::InlineExtension
+p0.eq(p1);
+<method::extension::InlineExtension as std::cmp::PartialEq>::eq(p0, p1);
+crate::<method::extension::InlineExtension as std::cmp::PartialEq>::eq(p0, p1);
+<method::extension::InlineExtension>::eq(p0, p1);
-----------------
src/method.rs <method::extension::InlineExtension as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::InlineExtension
+p0.assert_receiver_is_total_eq();
+<method::extension::InlineExtension as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<method::extension::InlineExtension as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<method::extension::InlineExtension>::assert_receiver_is_total_eq(p0);
-----------------
src/method.rs <method::extension::InlineExtension as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<method::extension::InlineExtension as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<method::extension::InlineExtension as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::InlineExtension
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<method::extension::InlineExtension as std::hash::Hash>::hash(p0, p1);
+crate::<method::extension::InlineExtension as std::hash::Hash>::hash(p0, p1);
+<method::extension::InlineExtension>::hash(p0, p1);
-----------------
src/method.rs <method::extension::AllocatedExtension as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::AllocatedExtension
+p0.clone();
+<method::extension::AllocatedExtension as std::clone::Clone>::clone(p0);
+crate::<method::extension::AllocatedExtension as std::clone::Clone>::clone(p0);
+<method::extension::AllocatedExtension>::clone(p0);
-----------------
src/method.rs <method::extension::AllocatedExtension as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::AllocatedExtension
let mut p1 = & MaybeUninit::uninit().assume_init(); // method::extension::AllocatedExtension
+p0.eq(p1);
+<method::extension::AllocatedExtension as std::cmp::PartialEq>::eq(p0, p1);
+crate::<method::extension::AllocatedExtension as std::cmp::PartialEq>::eq(p0, p1);
+<method::extension::AllocatedExtension>::eq(p0, p1);
-----------------
src/method.rs <method::extension::AllocatedExtension as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::AllocatedExtension
+p0.assert_receiver_is_total_eq();
+<method::extension::AllocatedExtension as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<method::extension::AllocatedExtension as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<method::extension::AllocatedExtension>::assert_receiver_is_total_eq(p0);
-----------------
src/method.rs <method::extension::AllocatedExtension as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<method::extension::AllocatedExtension as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<method::extension::AllocatedExtension as std::hash::Hash>::hash":{"__H":["extensions::IdHasher","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::AllocatedExtension
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<method::extension::AllocatedExtension as std::hash::Hash>::hash(p0, p1);
+crate::<method::extension::AllocatedExtension as std::hash::Hash>::hash(p0, p1);
+<method::extension::AllocatedExtension>::hash(p0, p1);
-----------------
src/method.rs method::extension::InlineExtension::new
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+method::extension::InlineExtension::new(p0);
+crate::method::extension::InlineExtension::new(p0);
+<method::extension::InlineExtension>::new(p0);
-----------------
src/method.rs method::extension::InlineExtension::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::InlineExtension
+p0.as_str();
+method::extension::InlineExtension::as_str(p0);
+crate::method::extension::InlineExtension::as_str(p0);
+<method::extension::InlineExtension>::as_str(p0);
-----------------
src/method.rs method::extension::AllocatedExtension::new
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+method::extension::AllocatedExtension::new(p0);
+crate::method::extension::AllocatedExtension::new(p0);
+<method::extension::AllocatedExtension>::new(p0);
-----------------
src/method.rs method::extension::AllocatedExtension::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // method::extension::AllocatedExtension
+p0.as_str();
+method::extension::AllocatedExtension::as_str(p0);
+crate::method::extension::AllocatedExtension::as_str(p0);
+<method::extension::AllocatedExtension>::as_str(p0);
-----------------
src/request.rs <request::Builder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Builder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<request::Builder as std::fmt::Debug>::fmt(p0, p1);
+crate::<request::Builder as std::fmt::Debug>::fmt(p0, p1);
+<request::Builder>::fmt(p0, p1);
-----------------
src/request.rs request::Request::<()>::builder
deps:{}
candidates:{}
+request::Request::<()>::builder();
+crate::request::Request::<()>::builder();
+<request::Request<()>>::builder();
-----------------
src/request.rs request::Request::<()>::get
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::convert::TryFrom"]},"request::Request::<()>::get":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"request::Request::<()>::get":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"],"T":["RUG_ANY"],"uri::Uri":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<()>::get(p0);
+crate::request::Request::<()>::get(p0);
+<request::Request<()>>::get(p0);
-----------------
src/request.rs request::Request::<()>::put
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::convert::TryFrom","std::cmp::PartialEq","std::fmt::Debug"]},"request::Request::<()>::put":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"request::Request::<()>::put":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"],"T":["RUG_ANY"],"uri::Uri":["header::map::HeaderMap","<T as std::convert::TryFrom<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<()>::put(p0);
+crate::request::Request::<()>::put(p0);
+<request::Request<()>>::put(p0);
-----------------
src/request.rs request::Request::<()>::post
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::convert::TryFrom","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"request::Request::<()>::post":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"request::Request::<()>::post":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError"],"T":["RUG_ANY"],"uri::Uri":["header::map::HeaderMap","<T as std::convert::TryFrom<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<()>::post(p0);
+crate::request::Request::<()>::post(p0);
+<request::Request<()>>::post(p0);
-----------------
src/request.rs request::Request::<()>::delete
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::convert::TryFrom","std::clone::Clone"]},"request::Request::<()>::delete":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"request::Request::<()>::delete":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"],"T":["RUG_ANY"],"uri::Uri":["header::map::HeaderMap","<T as std::convert::TryFrom<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<()>::delete(p0);
+crate::request::Request::<()>::delete(p0);
+<request::Request<()>>::delete(p0);
-----------------
src/request.rs request::Request::<()>::options
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::clone::Clone","std::cmp::PartialEq","std::convert::TryFrom","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"request::Request::<()>::options":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"request::Request::<()>::options":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError"],"T":["RUG_ANY"],"uri::Uri":["header::map::HeaderMap","<T as std::convert::TryFrom<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<()>::options(p0);
+crate::request::Request::<()>::options(p0);
+<request::Request<()>>::options(p0);
-----------------
src/request.rs request::Request::<()>::head
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::cmp::PartialEq","std::clone::Clone","std::convert::TryFrom","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"request::Request::<()>::head":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"request::Request::<()>::head":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"],"T":["RUG_ANY"],"uri::Uri":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<()>::head(p0);
+crate::request::Request::<()>::head(p0);
+<request::Request<()>>::head(p0);
-----------------
src/request.rs request::Request::<()>::connect
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::cmp::PartialEq","std::convert::TryFrom","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"request::Request::<()>::connect":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"request::Request::<()>::connect":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"],"T":["RUG_ANY"],"uri::Uri":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<()>::connect(p0);
+crate::request::Request::<()>::connect(p0);
+<request::Request<()>>::connect(p0);
-----------------
src/request.rs request::Request::<()>::patch
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::convert::TryFrom","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"request::Request::<()>::patch":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"request::Request::<()>::patch":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError"],"T":["RUG_ANY"],"uri::Uri":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<()>::patch(p0);
+crate::request::Request::<()>::patch(p0);
+<request::Request<()>>::patch(p0);
-----------------
src/request.rs request::Request::<()>::trace
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::convert::TryFrom"]},"request::Request::<()>::trace":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"request::Request::<()>::trace":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"],"T":["RUG_ANY"],"uri::Uri":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<()>::trace(p0);
+crate::request::Request::<()>::trace(p0);
+<request::Request<()>>::trace(p0);
-----------------
src/request.rs request::Request::<T>::new
deps:{"request::Request::<T>::new":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::new":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<T>::new(p0);
+crate::request::Request::<T>::new(p0);
+<request::Request<T>>::new(p0);
-----------------
src/request.rs request::Request::<T>::from_parts
deps:{"request::Request::<T>::from_parts":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::from_parts":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Parts
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+request::Request::<T>::from_parts(p0, p1);
+crate::request::Request::<T>::from_parts(p0, p1);
+<request::Request<T>>::from_parts(p0, p1);
-----------------
src/request.rs request::Request::<T>::method
deps:{"request::Request::<T>::method":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::method":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.method();
+request::Request::<T>::method(p0);
+crate::request::Request::<T>::method(p0);
+<request::Request<T>>::method(p0);
-----------------
src/request.rs request::Request::<T>::method_mut
deps:{"request::Request::<T>::method_mut":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::method_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.method_mut();
+request::Request::<T>::method_mut(p0);
+crate::request::Request::<T>::method_mut(p0);
+<request::Request<T>>::method_mut(p0);
-----------------
src/request.rs request::Request::<T>::uri
deps:{"request::Request::<T>::uri":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::uri":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.uri();
+request::Request::<T>::uri(p0);
+crate::request::Request::<T>::uri(p0);
+<request::Request<T>>::uri(p0);
-----------------
src/request.rs request::Request::<T>::uri_mut
deps:{"request::Request::<T>::uri_mut":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::uri_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.uri_mut();
+request::Request::<T>::uri_mut(p0);
+crate::request::Request::<T>::uri_mut(p0);
+<request::Request<T>>::uri_mut(p0);
-----------------
src/request.rs request::Request::<T>::version
deps:{"request::Request::<T>::version":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::version":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.version();
+request::Request::<T>::version(p0);
+crate::request::Request::<T>::version(p0);
+<request::Request<T>>::version(p0);
-----------------
src/request.rs request::Request::<T>::version_mut
deps:{"request::Request::<T>::version_mut":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::version_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.version_mut();
+request::Request::<T>::version_mut(p0);
+crate::request::Request::<T>::version_mut(p0);
+<request::Request<T>>::version_mut(p0);
-----------------
src/request.rs request::Request::<T>::headers
deps:{"request::Request::<T>::headers":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::headers":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.headers();
+request::Request::<T>::headers(p0);
+crate::request::Request::<T>::headers(p0);
+<request::Request<T>>::headers(p0);
-----------------
src/request.rs request::Request::<T>::headers_mut
deps:{"request::Request::<T>::headers_mut":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::headers_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.headers_mut();
+request::Request::<T>::headers_mut(p0);
+crate::request::Request::<T>::headers_mut(p0);
+<request::Request<T>>::headers_mut(p0);
-----------------
src/request.rs request::Request::<T>::extensions
deps:{"request::Request::<T>::extensions":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::extensions":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.extensions();
+request::Request::<T>::extensions(p0);
+crate::request::Request::<T>::extensions(p0);
+<request::Request<T>>::extensions(p0);
-----------------
src/request.rs request::Request::<T>::extensions_mut
deps:{"request::Request::<T>::extensions_mut":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::extensions_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.extensions_mut();
+request::Request::<T>::extensions_mut(p0);
+crate::request::Request::<T>::extensions_mut(p0);
+<request::Request<T>>::extensions_mut(p0);
-----------------
src/request.rs request::Request::<T>::body
deps:{"request::Request::<T>::body":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::body":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.body();
+request::Request::<T>::body(p0);
+crate::request::Request::<T>::body(p0);
+<request::Request<T>>::body(p0);
-----------------
src/request.rs request::Request::<T>::body_mut
deps:{"request::Request::<T>::body_mut":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::body_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.body_mut();
+request::Request::<T>::body_mut(p0);
+crate::request::Request::<T>::body_mut(p0);
+<request::Request<T>>::body_mut(p0);
-----------------
src/request.rs request::Request::<T>::into_body
deps:{"request::Request::<T>::into_body":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::into_body":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.into_body();
+request::Request::<T>::into_body(p0);
+crate::request::Request::<T>::into_body(p0);
+<request::Request<T>>::into_body(p0);
-----------------
src/request.rs request::Request::<T>::into_parts
deps:{"request::Request::<T>::into_parts":{"T":["std::marker::Sized"]}}
candidates:{"request::Request::<T>::into_parts":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Request<T>
+p0.into_parts();
+request::Request::<T>::into_parts(p0);
+crate::request::Request::<T>::into_parts(p0);
+<request::Request<T>>::into_parts(p0);
-----------------
src/request.rs request::Request::<T>::map
deps:{"request::Request::<T>::map":{"F":["std::marker::Sized","std::ops::FnOnce"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"request::Request::<T>::map":{"F":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::panic::AssertUnwindSafe<F>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Request<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+request::Request::<T>::map(p0, p1);
+crate::request::Request::<T>::map(p0, p1);
+<request::Request<T>>::map(p0, p1);
-----------------
src/request.rs <request::Request<T> as std::default::Default>::default
deps:{"<request::Request<T> as std::default::Default>::default":{"T":["std::marker::Sized","std::default::Default"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::convert::TryFrom"]},"request::Request":{"T":["std::default::Default","std::fmt::Debug","std::marker::Sized"]},"response::Response":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]}}
candidates:{"<request::Request<T> as std::default::Default>::default":{"T":["extensions::Extensions","version::Version","status::StatusCode","uri::builder::Builder","extensions::IdHasher","response::Response","response::Builder","request::Builder","uri::Uri","request::Request","uri::Parts","header::map::HeaderMap","method::Method"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"request::Request":{"T":["request::Request","header::map::HeaderMap","status::StatusCode","uri::Uri","extensions::Extensions","request::Builder","method::Method","response::Response","version::Version","uri::builder::Builder","response::Builder","uri::Parts"]},"response::Response":{"T":["header::map::HeaderMap","extensions::Extensions","version::Version","method::Method","uri::Uri","request::Request","response::Response","uri::builder::Builder","status::StatusCode","request::Builder","uri::Parts","response::Builder"]}}
+<request::Request<T> as std::default::Default>::default();
+crate::<request::Request<T> as std::default::Default>::default();
+<request::Request<T>>::default();
-----------------
src/request.rs <request::Request<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<request::Request<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Bucket":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sync","std::marker::Sized"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::GetAll":{"T":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sync","std::marker::Sized"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Send","std::marker::Sync"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Sync","std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::name::Repr":{"T":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::hash::Hash","std::fmt::Debug"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::fmt::Debug","std::marker::Sized","std::convert::AsRef"]},"uri::scheme::Scheme2":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<request::Request<T> as std::fmt::Debug>::fmt":{"T":["header::value::ToStrError","header::map::VacantEntry","uri::Parts","header::map::OccupiedEntry","header::map::ValueDrain","header::map::Bucket","header::map::Keys","header::map::RawLinks","header::name::StandardHeader","header::map::Entry","request::Builder","header::map::ExtraValue","uri::ErrorKind","<*const T as std::fmt::Debug>","request::Parts","header::map::Link","uri::InvalidUri","header::name::InvalidHeaderName","header::map::Cursor","header::map::HeaderMap","response::Parts","header::map::Iter","header::map::ValuesMut","header::map::IterMut","header::map::HashValue","response::Builder","method::Method","header::map::ValueIter","method::InvalidMethod","header::map::Values","uri::Uri","uri::scheme::Protocol","uri::InvalidUriParts","uri::builder::Builder","header::map::GetAll","request::Request","header::map::Drain","uri::authority::Authority","uri::path::PathAndQuery","header::map::ValueIterMut","status::InvalidStatusCode","header::value::HeaderValue","header::name::HdrName","response::Response","byte_str::ByteStr","header::name::Repr","<&T as std::fmt::Debug>","header::name::Custom","extensions::Extensions","header::map::Links","header::map::IntoIter","uri::scheme::Scheme2","uri::port::Port","uri::scheme::Scheme","header::value::InvalidHeaderValue","version::Version","header::name::MaybeLower","error::Error","status::StatusCode","header::name::HeaderName"]},"header::map::Bucket":{"T":["header::map::Links","header::map::Bucket","header::name::MaybeLower","header::name::StandardHeader","<&T as std::fmt::Debug>","header::map::HeaderMap","uri::path::PathAndQuery","version::Version","header::map::RawLinks","header::map::ExtraValue","header::map::Cursor","header::name::Custom","status::StatusCode","header::map::Link","method::Method","header::value::HeaderValue","uri::scheme::Scheme2","uri::scheme::Scheme","uri::scheme::Protocol","uri::authority::Authority","byte_str::ByteStr","header::name::Repr","header::name::HeaderName","header::map::HashValue","uri::Uri"]},"header::map::Drain":{"T":["<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Iter","header::map::IterMut","header::map::Drain","header::map::ValueIterMut"]},"header::map::Entry":{"T":["header::map::Values","uri::port::Port","response::Response","header::map::ExtraValue","header::name::InvalidHeaderName","header::map::Link","extensions::Extensions","byte_str::ByteStr","header::map::IntoIter","request::Parts","header::map::ValueIterMut","request::Request","uri::Parts","header::map::Cursor","uri::scheme::Scheme2","header::map::Entry","uri::builder::Builder","uri::InvalidUri","header::map::Iter","header::map::IterMut","response::Parts","header::map::ValueIter","header::value::InvalidHeaderValue","header::name::MaybeLower","uri::scheme::Scheme","uri::ErrorKind","uri::Uri","header::map::Drain","header::name::StandardHeader","header::map::Keys","uri::authority::Authority","status::InvalidStatusCode","status::StatusCode","uri::scheme::Protocol","version::Version","header::map::Bucket","request::Builder","header::map::VacantEntry","response::Builder","header::value::ToStrError","header::map::Links","header::map::ValuesMut","header::map::ValueDrain","header::map::OccupiedEntry","header::map::HeaderMap","method::InvalidMethod","header::map::RawLinks","header::name::Repr","header::name::Custom","header::map::HashValue","header::name::HeaderName","<&T as std::fmt::Debug>","header::value::HeaderValue","method::Method","header::name::HdrName","uri::path::PathAndQuery","error::Error","header::map::GetAll","uri::InvalidUriParts"]},"header::map::ExtraValue":{"T":["uri::scheme::Protocol","byte_str::ByteStr","uri::Uri","header::map::ExtraValue","std::clone::impls::<impl std::clone::Clone for *mut T>","uri::authority::Authority","header::value::HeaderValue","header::map::Link","header::name::Repr","header::map::HeaderMap","header::name::MaybeLower","header::map::Bucket","header::name::StandardHeader","status::StatusCode","uri::scheme::Scheme2","header::map::HashValue","header::map::Cursor","uri::path::PathAndQuery","version::Version","uri::scheme::Scheme","method::Method","header::map::Links","header::map::RawLinks","header::name::Custom","header::name::HeaderName"]},"header::map::GetAll":{"T":["header::map::HeaderMap","uri::ErrorKind","header::map::HashValue","version::Version","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","header::name::Repr","byte_str::ByteStr","header::map::GetAll","header::name::StandardHeader","header::map::Cursor","header::name::Custom","header::map::Link"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::ExtraValue","header::map::Links","header::map::IterMut","header::value::ToStrError","uri::builder::Builder","header::name::MaybeLower","header::name::Custom","<&mut T as std::fmt::Debug>","header::value::InvalidHeaderValue","header::name::Repr","header::map::HeaderMap","extensions::Extensions","uri::path::PathAndQuery","header::map::ValueIterMut","header::map::Iter","header::map::Cursor","header::name::StandardHeader","method::InvalidMethod","status::InvalidStatusCode","uri::InvalidUriParts","method::Method","response::Parts","request::Builder","header::map::Link","header::name::InvalidHeaderName","header::map::Entry","header::map::IntoIter","header::map::VacantEntry","header::value::HeaderValue","uri::InvalidUri","header::map::Keys","uri::scheme::Protocol","uri::ErrorKind","uri::port::Port","uri::scheme::Scheme","header::map::ValueIter","header::map::ValuesMut","uri::Parts","header::map::ValueDrain","uri::authority::Authority","uri::Uri","header::map::RawLinks","version::Version","header::map::Values","request::Request","header::map::GetAll","header::map::Drain","request::Parts","header::map::Bucket","header::name::HeaderName","byte_str::ByteStr","response::Response","header::map::HashValue","response::Builder","status::StatusCode","uri::scheme::Scheme2","header::name::HdrName","header::map::OccupiedEntry","error::Error"]},"header::map::Iter":{"T":["header::map::IterMut","header::map::ValueDrain","header::map::Iter","header::map::Drain","header::map::ValueIterMut","<*const T as std::marker::Sync>"]},"header::map::IterMut":{"T":["header::map::ValueDrain","header::map::IterMut","header::map::Iter","<*mut T as std::marker::Sync>","header::map::Drain","header::map::ValueIterMut"]},"header::map::Keys":{"T":["header::map::HeaderMap","version::Version","header::map::HashValue","header::map::Cursor","header::map::Links","header::map::Bucket","header::map::IterMut","uri::InvalidUri","uri::scheme::Scheme","status::InvalidStatusCode","header::map::Iter","status::StatusCode","uri::authority::Authority","header::map::Entry","method::InvalidMethod","header::value::ToStrError","header::map::VacantEntry","response::Response","uri::scheme::Scheme2","header::map::Drain","uri::scheme::Protocol","header::value::HeaderValue","<*mut T as std::fmt::Debug>","header::name::Custom","method::Method","header::name::HeaderName","request::Builder","request::Parts","header::map::IntoIter","header::name::MaybeLower","uri::InvalidUriParts","header::map::Keys","response::Builder","header::map::ExtraValue","header::name::HdrName","response::Parts","header::map::ValuesMut","header::map::Link","uri::path::PathAndQuery","error::Error","extensions::Extensions","header::map::ValueDrain","byte_str::ByteStr","uri::Uri","uri::port::Port","header::map::OccupiedEntry","uri::ErrorKind","header::map::ValueIter","header::value::InvalidHeaderValue","header::map::GetAll","request::Request","header::map::Values","header::map::ValueIterMut","uri::builder::Builder","header::name::Repr","uri::Parts","header::map::RawLinks","header::name::StandardHeader","header::name::InvalidHeaderName"]},"header::map::OccupiedEntry":{"T":["header::map::ValuesMut","header::value::HeaderValue","header::map::ValueDrain","<*const T as std::fmt::Debug>","header::map::GetAll","request::Builder","header::name::Repr","header::map::Links","header::name::HdrName","header::name::Custom","request::Request","header::map::Bucket","header::map::Entry","header::map::ValueIter","uri::InvalidUri","header::map::IntoIter","header::name::MaybeLower","uri::path::PathAndQuery","response::Response","status::StatusCode","header::name::InvalidHeaderName","header::map::ValueIterMut","uri::authority::Authority","uri::scheme::Scheme2","header::map::HashValue","header::map::HeaderMap","header::name::StandardHeader","header::map::VacantEntry","response::Parts","request::Parts","header::map::Iter","header::map::Cursor","method::Method","header::map::Values","uri::port::Port","header::map::IterMut","uri::scheme::Protocol","error::Error","extensions::Extensions","uri::Parts","uri::builder::Builder","uri::Uri","header::map::Drain","header::value::ToStrError","response::Builder","uri::ErrorKind","header::map::Link","header::map::RawLinks","byte_str::ByteStr","uri::InvalidUriParts","uri::scheme::Scheme","header::map::Keys","header::map::ExtraValue","header::value::InvalidHeaderValue","method::InvalidMethod","header::map::OccupiedEntry","header::name::HeaderName","version::Version","status::InvalidStatusCode"]},"header::map::RawLinks":{"T":["request::Builder","header::name::InvalidHeaderName","status::InvalidStatusCode","header::map::Entry","version::Version","header::value::ToStrError","method::Method","uri::InvalidUriParts","header::map::HeaderMap","header::map::IterMut","uri::Uri","uri::ErrorKind","header::name::HeaderName","header::name::HdrName","header::name::Repr","header::map::ValuesMut","request::Parts","header::name::Custom","header::map::Link","header::map::Links","header::map::ValueIter","error::Error","header::map::IntoIter","uri::path::PathAndQuery","uri::authority::Authority","response::Builder","response::Parts","header::value::InvalidHeaderValue","status::StatusCode","response::Response","request::Request","header::map::Iter","header::map::Drain","header::map::HashValue","header::map::ValueDrain","uri::scheme::Protocol","extensions::Extensions","header::map::VacantEntry","method::InvalidMethod","uri::scheme::Scheme","header::map::RawLinks","<*const T as std::fmt::Debug>","header::map::Cursor","header::name::StandardHeader","uri::scheme::Scheme2","header::name::MaybeLower","header::map::Keys","uri::InvalidUri","byte_str::ByteStr","header::map::ExtraValue","header::map::Values","header::map::ValueIterMut","header::map::OccupiedEntry","uri::builder::Builder","uri::port::Port","header::value::HeaderValue","header::map::Bucket","uri::Parts","header::map::GetAll"]},"header::map::VacantEntry":{"T":["header::map::IterMut","header::name::HdrName","header::map::ValuesMut","header::map::Links","uri::port::Port","uri::ErrorKind","header::map::HashValue","header::map::Iter","header::map::ExtraValue","header::value::HeaderValue","header::value::InvalidHeaderValue","header::map::HeaderMap","uri::InvalidUri","error::Error","<&T as std::fmt::Debug>","uri::InvalidUriParts","header::map::Cursor","header::name::Custom","status::StatusCode","header::name::StandardHeader","uri::scheme::Protocol","uri::scheme::Scheme2","response::Response","extensions::Extensions","status::InvalidStatusCode","header::value::ToStrError","header::map::RawLinks","method::Method","uri::scheme::Scheme","header::map::Keys","header::map::Link","uri::path::PathAndQuery","header::name::Repr","version::Version","request::Builder","response::Parts","header::name::InvalidHeaderName","response::Builder","header::map::OccupiedEntry","header::map::Bucket","uri::Uri","header::map::Drain","request::Parts","header::name::MaybeLower","byte_str::ByteStr","header::map::ValueDrain","header::map::GetAll","request::Request","uri::authority::Authority","uri::Parts","header::map::Values","header::map::ValueIter","header::map::ValueIterMut","header::name::HeaderName","header::map::VacantEntry","uri::builder::Builder","method::InvalidMethod","header::map::Entry","header::map::IntoIter"]},"header::map::ValueDrain":{"T":["header::map::ValueIterMut","header::map::ValueDrain","header::map::Iter","header::map::IterMut","header::map::Drain","<*const T as std::marker::Send>"]},"header::map::ValueIter":{"T":["header::name::HdrName","header::value::InvalidHeaderValue","header::name::Repr","extensions::Extensions","uri::path::PathAndQuery","uri::InvalidUri","method::InvalidMethod","byte_str::ByteStr","<&mut T as std::fmt::Debug>","header::map::Iter","uri::InvalidUriParts","request::Builder","header::map::HashValue","uri::authority::Authority","header::map::Values","status::StatusCode","header::map::Links","uri::scheme::Protocol","uri::ErrorKind","request::Parts","header::name::MaybeLower","header::map::ValueDrain","header::map::VacantEntry","header::name::InvalidHeaderName","header::map::Entry","header::name::HeaderName","method::Method","header::map::Bucket","header::map::Drain","header::value::ToStrError","header::name::Custom","uri::builder::Builder","header::map::HeaderMap","version::Version","header::value::HeaderValue","error::Error","header::map::OccupiedEntry","header::map::Keys","status::InvalidStatusCode","header::map::Cursor","uri::port::Port","header::map::ExtraValue","request::Request","uri::Uri","uri::scheme::Scheme","header::map::RawLinks","header::map::Link","response::Parts","header::map::GetAll","header::map::IntoIter","uri::Parts","header::name::StandardHeader","response::Response","header::map::IterMut","response::Builder","header::map::ValueIter","header::map::ValuesMut","header::map::ValueIterMut","uri::scheme::Scheme2"]},"header::map::ValueIterMut":{"T":["header::map::ValueIterMut","header::map::ValueDrain","header::map::Drain","header::map::IterMut","<*mut T as std::marker::Send>","header::map::Iter"]},"header::map::Values":{"T":["header::map::IterMut","status::StatusCode","method::Method","header::map::VacantEntry","header::map::GetAll","header::value::HeaderValue","uri::authority::Authority","uri::scheme::Protocol","header::map::Cursor","header::map::ValueIter","header::map::HeaderMap","response::Builder","header::name::HdrName","header::map::ValueIterMut","header::map::Values","uri::port::Port","request::Builder","header::name::StandardHeader","response::Response","header::map::ExtraValue","uri::scheme::Scheme2","uri::path::PathAndQuery","request::Request","version::Version","header::map::Iter","header::map::ValuesMut","extensions::Extensions","header::value::ToStrError","uri::scheme::Scheme","header::map::Bucket","header::name::Custom","uri::InvalidUriParts","header::name::Repr","header::map::RawLinks","header::name::MaybeLower","header::value::InvalidHeaderValue","header::map::ValueDrain","response::Parts","method::InvalidMethod","header::map::Drain","header::name::InvalidHeaderName","header::map::Entry","<&mut T as std::fmt::Debug>","error::Error","header::map::Links","uri::builder::Builder","header::map::IntoIter","byte_str::ByteStr","request::Parts","header::map::HashValue","header::name::HeaderName","status::InvalidStatusCode","header::map::Link","uri::ErrorKind","uri::Uri","uri::InvalidUri","uri::Parts","header::map::OccupiedEntry","header::map::Keys"]},"header::map::ValuesMut":{"T":["error::Error","header::map::OccupiedEntry","status::StatusCode","uri::scheme::Scheme2","header::map::RawLinks","method::Method","header::map::VacantEntry","header::map::IterMut","header::map::ExtraValue","header::map::Links","header::map::Values","request::Builder","method::InvalidMethod","response::Parts","header::map::ValuesMut","uri::Uri","uri::path::PathAndQuery","uri::Parts","header::name::MaybeLower","header::map::Entry","header::map::Bucket","header::name::HdrName","header::map::GetAll","uri::scheme::Protocol","header::name::InvalidHeaderName","uri::builder::Builder","request::Request","header::map::IntoIter","header::map::Keys","version::Version","byte_str::ByteStr","header::name::Custom","uri::InvalidUri","<&T as std::fmt::Debug>","status::InvalidStatusCode","header::value::HeaderValue","uri::scheme::Scheme","response::Builder","extensions::Extensions","response::Response","header::map::ValueIter","header::map::Cursor","uri::authority::Authority","header::map::ValueDrain","header::map::ValueIterMut","request::Parts","header::map::Link","uri::InvalidUriParts","header::name::HeaderName","header::value::InvalidHeaderValue","header::value::ToStrError","uri::ErrorKind","header::map::HeaderMap","header::map::Iter","header::name::Repr","header::name::StandardHeader","header::map::HashValue","header::map::Drain","uri::port::Port"]},"header::name::Repr":{"T":["version::Version","header::name::Repr","std::hash::impls::<impl std::hash::Hash for *const T>","byte_str::ByteStr","header::name::Custom","header::name::StandardHeader"]},"request::Request":{"T":["extensions::Extensions","response::Response","response::Builder","header::map::HeaderMap","method::Method","version::Version","status::StatusCode","request::Request","request::Builder","uri::Uri","uri::builder::Builder","uri::Parts"]},"response::Response":{"T":["method::Method","response::Builder","uri::builder::Builder","status::StatusCode","header::map::HeaderMap","request::Request","response::Response","extensions::Extensions","uri::Uri","uri::Parts","version::Version","request::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["<&T as std::convert::AsRef<U>>","header::value::HeaderValue","uri::port::Port","uri::scheme::Scheme","uri::authority::Authority","method::Method"]},"uri::scheme::Scheme2":{"T":["method::Method","header::map::ExtraValue","byte_str::ByteStr","header::map::Link","uri::authority::Authority","<&T as std::fmt::Debug>","header::map::Bucket","header::name::Repr","header::name::MaybeLower","uri::scheme::Scheme","uri::Uri","header::value::HeaderValue","uri::scheme::Protocol","std::boxed::Box<byte_str::ByteStr>","header::name::Custom","header::name::HeaderName","header::map::HeaderMap","header::map::RawLinks","uri::path::PathAndQuery","header::map::HashValue","header::name::StandardHeader","version::Version","status::StatusCode","header::map::Links","header::map::Cursor","uri::scheme::Scheme2"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Request<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<request::Request<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<request::Request<T> as std::fmt::Debug>::fmt(p0, p1);
+<request::Request<T>>::fmt(p0, p1);
-----------------
src/request.rs request::Parts::new
deps:{}
candidates:{}
+request::Parts::new();
+crate::request::Parts::new();
+<request::Parts>::new();
-----------------
src/request.rs <request::Parts as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Parts
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<request::Parts as std::fmt::Debug>::fmt(p0, p1);
+crate::<request::Parts as std::fmt::Debug>::fmt(p0, p1);
+<request::Parts>::fmt(p0, p1);
-----------------
src/request.rs request::Builder::new
deps:{}
candidates:{}
+request::Builder::new();
+crate::request::Builder::new();
+<request::Builder>::new();
-----------------
src/request.rs request::Builder::method
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"request::Builder::method":{"<method::Method as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"method::Method":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"request::Builder::method":{"<method::Method as std::convert::TryFrom<T>>::Error":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"],"T":["RUG_ANY"],"method::Method":["header::map::HeaderMap","<T as std::convert::TryFrom<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.method(p1);
+request::Builder::method(p0, p1);
+crate::request::Builder::method(p0, p1);
+<request::Builder>::method(p0, p1);
-----------------
src/request.rs request::Builder::method_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Builder
+p0.method_ref();
+request::Builder::method_ref(p0);
+crate::request::Builder::method_ref(p0);
+<request::Builder>::method_ref(p0);
-----------------
src/request.rs request::Builder::uri
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::convert::TryFrom","std::marker::Sized"]},"request::Builder::uri":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::Uri":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"request::Builder::uri":{"<uri::Uri as std::convert::TryFrom<T>>::Error":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>"],"T":["RUG_ANY"],"uri::Uri":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.uri(p1);
+request::Builder::uri(p0, p1);
+crate::request::Builder::uri(p0, p1);
+<request::Builder>::uri(p0, p1);
-----------------
src/request.rs request::Builder::uri_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Builder
+p0.uri_ref();
+request::Builder::uri_ref(p0);
+crate::request::Builder::uri_ref(p0);
+<request::Builder>::uri_ref(p0);
-----------------
src/request.rs request::Builder::version
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // version::Version
+p0.version(p1);
+request::Builder::version(p0, p1);
+crate::request::Builder::version(p0, p1);
+<request::Builder>::version(p0, p1);
-----------------
src/request.rs request::Builder::header
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::convert::TryFrom","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"request::Builder::header":{"<header::name::HeaderName as std::convert::TryFrom<K>>::Error":["std::convert::Into"],"<header::value::HeaderValue as std::convert::TryFrom<V>>::Error":["std::convert::Into"],"K":["std::marker::Sized"],"V":["std::marker::Sized"],"header::name::HeaderName":["std::convert::TryFrom"],"header::value::HeaderValue":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"request::Builder::header":{"<header::name::HeaderName as std::convert::TryFrom<K>>::Error":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::process::ExitStatusError"],"<header::value::HeaderValue as std::convert::TryFrom<V>>::Error":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>"],"K":["RUG_ANY"],"V":["RUG_ANY"],"header::name::HeaderName":["header::map::HeaderMap","<T as std::convert::TryFrom<U>>"],"header::value::HeaderValue":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // K
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.header(p1, p2);
+request::Builder::header(p0, p1, p2);
+crate::request::Builder::header(p0, p1, p2);
+<request::Builder>::header(p0, p1, p2);
-----------------
src/request.rs request::Builder::headers_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Builder
+p0.headers_ref();
+request::Builder::headers_ref(p0);
+crate::request::Builder::headers_ref(p0);
+<request::Builder>::headers_ref(p0);
-----------------
src/request.rs request::Builder::headers_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // request::Builder
+p0.headers_mut();
+request::Builder::headers_mut(p0);
+crate::request::Builder::headers_mut(p0);
+<request::Builder>::headers_mut(p0);
-----------------
src/request.rs request::Builder::extension
deps:{"request::Builder::extension":{"T":["std::marker::Send","std::any::Any","std::marker::Sized","std::marker::Sync"]}}
candidates:{"request::Builder::extension":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extension(p1);
+request::Builder::extension(p0, p1);
+crate::request::Builder::extension(p0, p1);
+<request::Builder>::extension(p0, p1);
-----------------
src/request.rs request::Builder::extensions_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // request::Builder
+p0.extensions_ref();
+request::Builder::extensions_ref(p0);
+crate::request::Builder::extensions_ref(p0);
+<request::Builder>::extensions_ref(p0);
-----------------
src/request.rs request::Builder::extensions_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // request::Builder
+p0.extensions_mut();
+request::Builder::extensions_mut(p0);
+crate::request::Builder::extensions_mut(p0);
+<request::Builder>::extensions_mut(p0);
-----------------
src/request.rs request::Builder::body
deps:{"request::Builder::body":{"T":["std::marker::Sized"]}}
candidates:{"request::Builder::body":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.body(p1);
+request::Builder::body(p0, p1);
+crate::request::Builder::body(p0, p1);
+<request::Builder>::body(p0, p1);
-----------------
src/request.rs request::Builder::and_then
deps:{"request::Builder::and_then":{"F":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"request::Builder::and_then":{"F":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeDefault"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // request::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.and_then(p1);
+request::Builder::and_then(p0, p1);
+crate::request::Builder::and_then(p0, p1);
+<request::Builder>::and_then(p0, p1);
-----------------
src/request.rs <request::Builder as std::default::Default>::default
deps:{}
candidates:{}
+<request::Builder as std::default::Default>::default();
+crate::<request::Builder as std::default::Default>::default();
+<request::Builder>::default();
-----------------
src/response.rs <response::Builder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Builder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<response::Builder as std::fmt::Debug>::fmt(p0, p1);
+crate::<response::Builder as std::fmt::Debug>::fmt(p0, p1);
+<response::Builder>::fmt(p0, p1);
-----------------
src/response.rs response::Response::<()>::builder
deps:{}
candidates:{}
+response::Response::<()>::builder();
+crate::response::Response::<()>::builder();
+<response::Response<()>>::builder();
-----------------
src/response.rs response::Response::<T>::new
deps:{"response::Response::<T>::new":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::new":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+response::Response::<T>::new(p0);
+crate::response::Response::<T>::new(p0);
+<response::Response<T>>::new(p0);
-----------------
src/response.rs response::Response::<T>::from_parts
deps:{"response::Response::<T>::from_parts":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::from_parts":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Parts
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+response::Response::<T>::from_parts(p0, p1);
+crate::response::Response::<T>::from_parts(p0, p1);
+<response::Response<T>>::from_parts(p0, p1);
-----------------
src/response.rs response::Response::<T>::status
deps:{"response::Response::<T>::status":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::status":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.status();
+response::Response::<T>::status(p0);
+crate::response::Response::<T>::status(p0);
+<response::Response<T>>::status(p0);
-----------------
src/response.rs response::Response::<T>::status_mut
deps:{"response::Response::<T>::status_mut":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::status_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.status_mut();
+response::Response::<T>::status_mut(p0);
+crate::response::Response::<T>::status_mut(p0);
+<response::Response<T>>::status_mut(p0);
-----------------
src/response.rs response::Response::<T>::version
deps:{"response::Response::<T>::version":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::version":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.version();
+response::Response::<T>::version(p0);
+crate::response::Response::<T>::version(p0);
+<response::Response<T>>::version(p0);
-----------------
src/response.rs response::Response::<T>::version_mut
deps:{"response::Response::<T>::version_mut":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::version_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.version_mut();
+response::Response::<T>::version_mut(p0);
+crate::response::Response::<T>::version_mut(p0);
+<response::Response<T>>::version_mut(p0);
-----------------
src/response.rs response::Response::<T>::headers
deps:{"response::Response::<T>::headers":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::headers":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.headers();
+response::Response::<T>::headers(p0);
+crate::response::Response::<T>::headers(p0);
+<response::Response<T>>::headers(p0);
-----------------
src/response.rs response::Response::<T>::headers_mut
deps:{"response::Response::<T>::headers_mut":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::headers_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.headers_mut();
+response::Response::<T>::headers_mut(p0);
+crate::response::Response::<T>::headers_mut(p0);
+<response::Response<T>>::headers_mut(p0);
-----------------
src/response.rs response::Response::<T>::extensions
deps:{"response::Response::<T>::extensions":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::extensions":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.extensions();
+response::Response::<T>::extensions(p0);
+crate::response::Response::<T>::extensions(p0);
+<response::Response<T>>::extensions(p0);
-----------------
src/response.rs response::Response::<T>::extensions_mut
deps:{"response::Response::<T>::extensions_mut":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::extensions_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.extensions_mut();
+response::Response::<T>::extensions_mut(p0);
+crate::response::Response::<T>::extensions_mut(p0);
+<response::Response<T>>::extensions_mut(p0);
-----------------
src/response.rs response::Response::<T>::body
deps:{"response::Response::<T>::body":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::body":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.body();
+response::Response::<T>::body(p0);
+crate::response::Response::<T>::body(p0);
+<response::Response<T>>::body(p0);
-----------------
src/response.rs response::Response::<T>::body_mut
deps:{"response::Response::<T>::body_mut":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::body_mut":{"T":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.body_mut();
+response::Response::<T>::body_mut(p0);
+crate::response::Response::<T>::body_mut(p0);
+<response::Response<T>>::body_mut(p0);
-----------------
src/response.rs response::Response::<T>::into_body
deps:{"response::Response::<T>::into_body":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::into_body":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.into_body();
+response::Response::<T>::into_body(p0);
+crate::response::Response::<T>::into_body(p0);
+<response::Response<T>>::into_body(p0);
-----------------
src/response.rs response::Response::<T>::into_parts
deps:{"response::Response::<T>::into_parts":{"T":["std::marker::Sized"]}}
candidates:{"response::Response::<T>::into_parts":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Response<T>
+p0.into_parts();
+response::Response::<T>::into_parts(p0);
+crate::response::Response::<T>::into_parts(p0);
+<response::Response<T>>::into_parts(p0);
-----------------
src/response.rs response::Response::<T>::map
deps:{"response::Response::<T>::map":{"F":["std::marker::Sized","std::ops::FnOnce"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"response::Response::<T>::map":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::panic::AssertUnwindSafe<F>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Response<T>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+response::Response::<T>::map(p0, p1);
+crate::response::Response::<T>::map(p0, p1);
+<response::Response<T>>::map(p0, p1);
-----------------
src/response.rs <response::Response<T> as std::default::Default>::default
deps:{"<response::Response<T> as std::default::Default>::default":{"T":["std::marker::Sized","std::default::Default"]},"header::map::HeaderMap":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::convert::TryFrom","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"request::Request":{"T":["std::marker::Sized","std::fmt::Debug","std::default::Default"]},"response::Response":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]}}
candidates:{"<response::Response<T> as std::default::Default>::default":{"T":["uri::Parts","extensions::Extensions","response::Builder","method::Method","extensions::IdHasher","status::StatusCode","header::map::HeaderMap","version::Version","uri::Uri","uri::builder::Builder","response::Response","request::Builder","request::Request"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"request::Request":{"T":["response::Response","response::Builder","header::map::HeaderMap","extensions::Extensions","version::Version","status::StatusCode","uri::Parts","request::Builder","uri::builder::Builder","uri::Uri","request::Request","method::Method"]},"response::Response":{"T":["method::Method","uri::Parts","status::StatusCode","extensions::Extensions","response::Builder","uri::builder::Builder","request::Builder","version::Version","header::map::HeaderMap","request::Request","response::Response","uri::Uri"]}}
+<response::Response<T> as std::default::Default>::default();
+crate::<response::Response<T> as std::default::Default>::default();
+<response::Response<T>>::default();
-----------------
src/response.rs <response::Response<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<response::Response<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Bucket":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sync","std::marker::Sized"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized"]},"header::map::IterMut":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::Values":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::hash::Hash"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::default::Default","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::fmt::Debug","std::convert::AsRef"]},"uri::scheme::Scheme2":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<response::Response<T> as std::fmt::Debug>::fmt":{"T":["error::Error","uri::ErrorKind","uri::Parts","header::map::OccupiedEntry","header::map::ValueIter","header::map::Values","header::map::ValueDrain","header::name::Custom","header::map::Iter","response::Parts","header::map::IntoIter","header::map::Keys","status::InvalidStatusCode","uri::scheme::Scheme","response::Response","header::map::Link","header::map::HashValue","<*mut T as std::fmt::Debug>","request::Request","uri::scheme::Scheme2","status::StatusCode","header::name::StandardHeader","uri::authority::Authority","header::map::Links","header::name::InvalidHeaderName","header::map::Cursor","header::map::Bucket","header::map::ValueIterMut","byte_str::ByteStr","response::Builder","method::InvalidMethod","header::map::IterMut","uri::InvalidUri","request::Parts","header::name::HdrName","header::map::Entry","header::value::HeaderValue","header::value::InvalidHeaderValue","header::map::Drain","header::map::ExtraValue","version::Version","header::map::GetAll","request::Builder","uri::builder::Builder","header::map::VacantEntry","header::name::HeaderName","header::name::Repr","uri::port::Port","uri::path::PathAndQuery","extensions::Extensions","uri::scheme::Protocol","uri::InvalidUriParts","header::value::ToStrError","header::map::HeaderMap","header::name::MaybeLower","method::Method","header::map::RawLinks","<&mut T as std::fmt::Debug>","header::map::ValuesMut","uri::Uri"]},"header::map::Bucket":{"T":["uri::scheme::Protocol","header::name::StandardHeader","byte_str::ByteStr","header::map::RawLinks","uri::path::PathAndQuery","header::map::ExtraValue","header::map::Links","uri::authority::Authority","uri::scheme::Scheme2","status::StatusCode","uri::Uri","header::map::HashValue","method::Method","header::name::Repr","header::name::HeaderName","header::value::HeaderValue","header::map::Bucket","header::name::Custom","header::name::MaybeLower","header::map::Cursor","uri::scheme::Scheme","header::map::HeaderMap","std::clone::impls::<impl std::clone::Clone for *mut T>","version::Version","header::map::Link"]},"header::map::Drain":{"T":["header::map::ValueDrain","header::map::IterMut","<*const T as std::marker::Send>","header::map::Iter","header::map::ValueIterMut","header::map::Drain"]},"header::map::Entry":{"T":["header::map::HeaderMap","uri::port::Port","uri::scheme::Scheme2","response::Response","response::Parts","header::map::ExtraValue","request::Request","uri::InvalidUriParts","uri::Parts","header::map::Values","version::Version","header::map::Iter","status::StatusCode","uri::builder::Builder","header::name::InvalidHeaderName","header::name::Custom","uri::Uri","header::value::ToStrError","header::map::GetAll","header::map::Cursor","header::map::Link","extensions::Extensions","header::map::VacantEntry","method::Method","status::InvalidStatusCode","header::name::StandardHeader","header::map::ValueDrain","<&T as std::fmt::Debug>","byte_str::ByteStr","error::Error","header::map::IterMut","header::name::HeaderName","response::Builder","request::Parts","uri::InvalidUri","header::map::OccupiedEntry","header::map::ValueIter","method::InvalidMethod","header::name::MaybeLower","header::map::ValueIterMut","header::name::HdrName","uri::path::PathAndQuery","header::map::Bucket","header::map::Links","header::map::Drain","uri::authority::Authority","uri::ErrorKind","uri::scheme::Scheme","header::map::RawLinks","request::Builder","header::map::IntoIter","header::map::ValuesMut","header::value::InvalidHeaderValue","header::value::HeaderValue","uri::scheme::Protocol","header::name::Repr","header::map::HashValue","header::map::Keys","header::map::Entry"]},"header::map::ExtraValue":{"T":["header::map::Cursor","header::map::RawLinks","uri::path::PathAndQuery","header::name::MaybeLower","header::map::HashValue","byte_str::ByteStr","header::name::Custom","header::map::ExtraValue","header::map::Link","version::Version","header::value::HeaderValue","uri::scheme::Scheme2","header::name::StandardHeader","header::map::HeaderMap","header::map::Links","uri::scheme::Scheme","header::map::Bucket","header::name::Repr","uri::scheme::Protocol","status::StatusCode","std::clone::impls::<impl std::clone::Clone for *const T>","uri::authority::Authority","uri::Uri","header::name::HeaderName","method::Method"]},"header::map::GetAll":{"T":["header::map::Cursor","header::map::Link","std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>","header::map::GetAll","header::map::HeaderMap","byte_str::ByteStr","header::map::HashValue","uri::ErrorKind","header::name::Custom","header::name::StandardHeader","version::Version","header::name::Repr"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::HeaderMap","request::Builder","byte_str::ByteStr","header::name::MaybeLower","uri::scheme::Scheme","header::map::Iter","version::Version","header::name::Custom","header::name::InvalidHeaderName","header::map::Entry","response::Builder","uri::ErrorKind","method::InvalidMethod","header::name::HdrName","status::InvalidStatusCode","header::value::InvalidHeaderValue","header::map::Bucket","response::Parts","header::map::Drain","request::Request","uri::scheme::Scheme2","error::Error","header::name::HeaderName","extensions::Extensions","uri::builder::Builder","status::StatusCode","header::value::ToStrError","header::map::IntoIter","header::name::Repr","uri::Parts","uri::authority::Authority","request::Parts","header::map::IterMut","header::map::Values","header::map::Cursor","header::map::ValueDrain","uri::InvalidUriParts","header::map::ValuesMut","header::map::OccupiedEntry","uri::path::PathAndQuery","header::map::ValueIter","uri::InvalidUri","uri::Uri","header::map::RawLinks","method::Method","header::map::Keys","header::map::Links","header::name::StandardHeader","header::map::GetAll","header::map::VacantEntry","response::Response","header::map::Link","header::map::HashValue","header::map::ExtraValue","uri::port::Port","header::value::HeaderValue","header::map::ValueIterMut","uri::scheme::Protocol","<&mut T as std::fmt::Debug>"]},"header::map::Iter":{"T":["header::map::Iter","header::map::IterMut","header::map::Drain","header::map::ValueDrain","<*mut T as std::fmt::Debug>","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["header::map::IterMut","<*mut T as std::marker::Send>","header::map::ValueDrain","header::map::Iter","header::map::ValueIterMut","header::map::Drain"]},"header::map::Keys":{"T":["header::map::ValuesMut","header::value::ToStrError","header::map::Link","version::Version","method::InvalidMethod","request::Parts","status::StatusCode","header::map::VacantEntry","response::Builder","header::map::Entry","uri::Uri","header::map::Keys","header::name::InvalidHeaderName","header::name::Repr","uri::path::PathAndQuery","uri::authority::Authority","header::map::Iter","uri::scheme::Protocol","header::name::StandardHeader","header::map::ValueIter","error::Error","header::map::GetAll","header::map::ValueIterMut","header::map::IterMut","header::map::RawLinks","response::Parts","header::name::HeaderName","uri::ErrorKind","header::map::HeaderMap","byte_str::ByteStr","header::map::HashValue","response::Response","header::map::ExtraValue","request::Builder","uri::builder::Builder","header::map::Cursor","header::name::Custom","uri::scheme::Scheme2","method::Method","header::value::InvalidHeaderValue","header::map::OccupiedEntry","header::value::HeaderValue","header::name::HdrName","uri::Parts","uri::InvalidUriParts","header::map::Links","uri::port::Port","header::map::Bucket","<&T as std::fmt::Debug>","request::Request","uri::InvalidUri","extensions::Extensions","uri::scheme::Scheme","header::map::ValueDrain","status::InvalidStatusCode","header::name::MaybeLower","header::map::IntoIter","header::map::Drain","header::map::Values"]},"header::map::OccupiedEntry":{"T":["header::map::OccupiedEntry","header::map::IntoIter","header::map::Values","byte_str::ByteStr","version::Version","uri::port::Port","uri::InvalidUri","uri::scheme::Protocol","header::map::HashValue","response::Parts","header::map::Links","status::InvalidStatusCode","uri::authority::Authority","extensions::Extensions","request::Builder","header::name::MaybeLower","uri::Parts","header::map::HeaderMap","header::map::Cursor","header::map::ValueDrain","header::map::Bucket","header::map::VacantEntry","header::value::ToStrError","uri::scheme::Scheme2","uri::InvalidUriParts","header::name::StandardHeader","response::Builder","error::Error","uri::builder::Builder","header::value::HeaderValue","header::map::ValueIterMut","<*const T as std::fmt::Debug>","header::map::ValuesMut","header::map::RawLinks","header::name::Repr","uri::Uri","uri::path::PathAndQuery","header::map::Iter","response::Response","header::name::HeaderName","status::StatusCode","header::map::GetAll","header::name::Custom","method::Method","header::map::Entry","header::map::IterMut","request::Parts","method::InvalidMethod","request::Request","uri::ErrorKind","header::name::InvalidHeaderName","header::value::InvalidHeaderValue","header::map::Drain","header::map::Keys","header::map::ValueIter","header::map::ExtraValue","uri::scheme::Scheme","header::map::Link","header::name::HdrName"]},"header::map::RawLinks":{"T":["header::map::Iter","header::map::ValuesMut","uri::Parts","uri::scheme::Scheme2","header::map::Entry","byte_str::ByteStr","header::map::GetAll","uri::InvalidUri","status::InvalidStatusCode","header::name::Repr","response::Parts","uri::scheme::Protocol","header::map::Links","header::map::Values","uri::path::PathAndQuery","method::InvalidMethod","uri::scheme::Scheme","header::map::VacantEntry","header::map::HashValue","header::map::ExtraValue","uri::port::Port","header::map::IntoIter","uri::authority::Authority","error::Error","<&mut T as std::fmt::Debug>","header::map::Cursor","uri::builder::Builder","uri::ErrorKind","uri::Uri","header::map::ValueDrain","header::map::Drain","uri::InvalidUriParts","status::StatusCode","header::name::InvalidHeaderName","header::map::HeaderMap","request::Builder","header::map::RawLinks","response::Builder","header::name::StandardHeader","header::map::ValueIter","header::map::Link","header::name::HeaderName","header::name::Custom","header::map::Bucket","request::Parts","header::value::InvalidHeaderValue","header::value::ToStrError","request::Request","header::map::ValueIterMut","version::Version","header::value::HeaderValue","header::map::OccupiedEntry","header::name::HdrName","header::map::Keys","extensions::Extensions","header::name::MaybeLower","method::Method","header::map::IterMut","response::Response"]},"header::map::VacantEntry":{"T":["header::map::HashValue","header::name::HeaderName","request::Parts","method::InvalidMethod","header::map::ValuesMut","header::map::Entry","response::Builder","header::map::ExtraValue","response::Parts","extensions::Extensions","header::map::HeaderMap","error::Error","uri::InvalidUriParts","header::map::IterMut","uri::scheme::Protocol","header::name::StandardHeader","<&mut T as std::fmt::Debug>","header::name::HdrName","header::map::ValueIterMut","uri::InvalidUri","header::map::RawLinks","request::Builder","method::Method","header::map::ValueIter","uri::authority::Authority","header::name::InvalidHeaderName","header::map::Links","header::map::Link","response::Response","header::map::Cursor","header::map::Drain","uri::Uri","header::map::OccupiedEntry","header::map::GetAll","uri::Parts","byte_str::ByteStr","header::name::Repr","uri::ErrorKind","header::map::ValueDrain","header::name::MaybeLower","header::value::HeaderValue","uri::port::Port","header::map::Iter","uri::scheme::Scheme2","request::Request","header::map::Bucket","header::map::Values","header::name::Custom","header::value::InvalidHeaderValue","header::map::Keys","header::value::ToStrError","status::InvalidStatusCode","header::map::IntoIter","uri::scheme::Scheme","uri::path::PathAndQuery","uri::builder::Builder","header::map::VacantEntry","status::StatusCode","version::Version"]},"header::map::ValueDrain":{"T":["<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::Drain","header::map::Iter","header::map::IterMut","header::map::ValueIterMut"]},"header::map::ValueIter":{"T":["header::name::Custom","header::map::IntoIter","header::name::Repr","uri::builder::Builder","header::map::Cursor","uri::port::Port","header::map::ExtraValue","header::map::Links","header::name::StandardHeader","extensions::Extensions","uri::ErrorKind","header::map::ValueIter","header::map::GetAll","uri::InvalidUri","header::value::ToStrError","response::Builder","response::Parts","request::Builder","header::name::InvalidHeaderName","method::Method","response::Response","uri::Uri","header::map::VacantEntry","header::map::ValueDrain","header::value::InvalidHeaderValue","header::map::HeaderMap","uri::scheme::Scheme2","header::map::HashValue","version::Version","header::map::Drain","request::Parts","status::InvalidStatusCode","uri::scheme::Scheme","header::map::Link","header::map::Keys","request::Request","header::map::RawLinks","error::Error","header::map::IterMut","header::map::Iter","uri::Parts","method::InvalidMethod","uri::scheme::Protocol","header::map::Entry","header::value::HeaderValue","uri::path::PathAndQuery","header::name::HdrName","header::map::OccupiedEntry","header::map::ValuesMut","status::StatusCode","uri::authority::Authority","header::map::ValueIterMut","header::name::HeaderName","header::map::Values","uri::InvalidUriParts","header::map::Bucket","header::name::MaybeLower","byte_str::ByteStr","<*mut T as std::fmt::Debug>"]},"header::map::ValueIterMut":{"T":["header::map::Iter","header::map::ValueDrain","header::map::IterMut","header::map::ValueIterMut","header::map::Drain","<*mut T as std::fmt::Debug>"]},"header::map::Values":{"T":["uri::Parts","header::name::HdrName","error::Error","header::name::InvalidHeaderName","header::map::HeaderMap","uri::Uri","header::map::ExtraValue","request::Request","response::Builder","request::Builder","header::map::ValueIterMut","header::map::Entry","header::name::Repr","header::map::ValueDrain","uri::port::Port","header::map::ValueIter","header::map::Values","method::InvalidMethod","header::name::HeaderName","header::map::IntoIter","header::map::Iter","header::map::RawLinks","uri::path::PathAndQuery","header::map::Drain","uri::scheme::Scheme","byte_str::ByteStr","header::map::Cursor","header::value::InvalidHeaderValue","header::map::VacantEntry","header::name::StandardHeader","uri::ErrorKind","header::map::OccupiedEntry","header::map::Bucket","header::map::Links","header::map::ValuesMut","uri::authority::Authority","extensions::Extensions","header::map::IterMut","header::value::HeaderValue","status::InvalidStatusCode","<*mut T as std::fmt::Debug>","uri::scheme::Scheme2","header::name::Custom","uri::scheme::Protocol","response::Response","header::map::Link","uri::builder::Builder","header::name::MaybeLower","uri::InvalidUri","request::Parts","header::map::HashValue","uri::InvalidUriParts","status::StatusCode","header::map::GetAll","response::Parts","version::Version","method::Method","header::value::ToStrError","header::map::Keys"]},"header::map::ValuesMut":{"T":["header::map::Cursor","header::map::Iter","header::map::ValuesMut","header::map::Drain","header::name::Custom","header::value::HeaderValue","response::Response","request::Request","header::name::HdrName","header::value::InvalidHeaderValue","uri::authority::Authority","header::map::Bucket","status::InvalidStatusCode","header::map::Entry","header::name::MaybeLower","uri::scheme::Protocol","extensions::Extensions","method::Method","header::map::ValueIter","request::Parts","request::Builder","<*mut T as std::fmt::Debug>","header::name::HeaderName","header::map::GetAll","response::Parts","header::map::Values","header::name::StandardHeader","header::name::InvalidHeaderName","header::value::ToStrError","header::map::IterMut","header::map::HashValue","header::map::VacantEntry","version::Version","uri::port::Port","error::Error","uri::InvalidUriParts","header::map::ValueIterMut","header::map::HeaderMap","header::map::ExtraValue","header::map::ValueDrain","header::name::Repr","header::map::Link","response::Builder","uri::scheme::Scheme2","header::map::IntoIter","uri::Uri","header::map::OccupiedEntry","method::InvalidMethod","uri::Parts","uri::path::PathAndQuery","uri::InvalidUri","byte_str::ByteStr","uri::builder::Builder","uri::scheme::Scheme","status::StatusCode","header::map::Keys","header::map::Links","uri::ErrorKind","header::map::RawLinks"]},"header::name::Repr":{"T":["header::name::Repr","byte_str::ByteStr","version::Version","header::name::Custom","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","header::name::StandardHeader"]},"request::Request":{"T":["request::Request","response::Response","version::Version","request::Builder","uri::builder::Builder","method::Method","extensions::Extensions","uri::Uri","response::Builder","uri::Parts","status::StatusCode","header::map::HeaderMap"]},"response::Response":{"T":["uri::builder::Builder","response::Builder","version::Version","status::StatusCode","extensions::Extensions","header::map::HeaderMap","uri::Parts","uri::Uri","response::Response","request::Builder","method::Method","request::Request"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"uri::port::Port":{"T":["<&mut T as std::convert::AsRef<U>>","method::Method","uri::authority::Authority","uri::scheme::Scheme","uri::port::Port","header::value::HeaderValue"]},"uri::scheme::Scheme2":{"T":["header::map::HashValue","method::Method","uri::path::PathAndQuery","header::map::Links","std::clone::impls::<impl std::clone::Clone for *const T>","uri::Uri","uri::authority::Authority","header::map::Link","header::name::MaybeLower","header::map::Cursor","byte_str::ByteStr","header::value::HeaderValue","status::StatusCode","header::name::HeaderName","header::map::RawLinks","header::map::HeaderMap","header::name::StandardHeader","std::boxed::Box<byte_str::ByteStr>","uri::scheme::Scheme2","header::map::ExtraValue","uri::scheme::Scheme","version::Version","header::name::Custom","header::name::Repr","uri::scheme::Protocol","header::map::Bucket"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Response<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<response::Response<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<response::Response<T> as std::fmt::Debug>::fmt(p0, p1);
+<response::Response<T>>::fmt(p0, p1);
-----------------
src/response.rs response::Parts::new
deps:{}
candidates:{}
+response::Parts::new();
+crate::response::Parts::new();
+<response::Parts>::new();
-----------------
src/response.rs <response::Parts as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Parts
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<response::Parts as std::fmt::Debug>::fmt(p0, p1);
+crate::<response::Parts as std::fmt::Debug>::fmt(p0, p1);
+<response::Parts>::fmt(p0, p1);
-----------------
src/response.rs response::Builder::new
deps:{}
candidates:{}
+response::Builder::new();
+crate::response::Builder::new();
+<response::Builder>::new();
-----------------
src/response.rs response::Builder::status
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::convert::TryFrom","std::cmp::Eq"]},"response::Builder::status":{"<status::StatusCode as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"status::StatusCode":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"response::Builder::status":{"<status::StatusCode as std::convert::TryFrom<T>>::Error":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","std::process::ExitStatusError"],"T":["RUG_ANY"],"status::StatusCode":["header::map::HeaderMap","<T as std::convert::TryFrom<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.status(p1);
+response::Builder::status(p0, p1);
+crate::response::Builder::status(p0, p1);
+<response::Builder>::status(p0, p1);
-----------------
src/response.rs response::Builder::version
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // version::Version
+p0.version(p1);
+response::Builder::version(p0, p1);
+crate::response::Builder::version(p0, p1);
+<response::Builder>::version(p0, p1);
-----------------
src/response.rs response::Builder::header
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::convert::TryFrom","std::fmt::Debug","std::cmp::PartialEq"]},"response::Builder::header":{"<header::name::HeaderName as std::convert::TryFrom<K>>::Error":["std::convert::Into"],"<header::value::HeaderValue as std::convert::TryFrom<V>>::Error":["std::convert::Into"],"K":["std::marker::Sized"],"V":["std::marker::Sized"],"header::name::HeaderName":["std::convert::TryFrom"],"header::value::HeaderValue":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"response::Builder::header":{"<header::name::HeaderName as std::convert::TryFrom<K>>::Error":["<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","std::sync::mpmc::select::Selected"],"<header::value::HeaderValue as std::convert::TryFrom<V>>::Error":["std::sync::mpmc::select::Selected","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"],"K":["RUG_ANY"],"V":["RUG_ANY"],"header::name::HeaderName":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"],"header::value::HeaderValue":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // K
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.header(p1, p2);
+response::Builder::header(p0, p1, p2);
+crate::response::Builder::header(p0, p1, p2);
+<response::Builder>::header(p0, p1, p2);
-----------------
src/response.rs response::Builder::headers_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Builder
+p0.headers_ref();
+response::Builder::headers_ref(p0);
+crate::response::Builder::headers_ref(p0);
+<response::Builder>::headers_ref(p0);
-----------------
src/response.rs response::Builder::headers_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // response::Builder
+p0.headers_mut();
+response::Builder::headers_mut(p0);
+crate::response::Builder::headers_mut(p0);
+<response::Builder>::headers_mut(p0);
-----------------
src/response.rs response::Builder::extension
deps:{"response::Builder::extension":{"T":["std::marker::Send","std::marker::Sync","std::any::Any","std::marker::Sized"]}}
candidates:{"response::Builder::extension":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extension(p1);
+response::Builder::extension(p0, p1);
+crate::response::Builder::extension(p0, p1);
+<response::Builder>::extension(p0, p1);
-----------------
src/response.rs response::Builder::extensions_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // response::Builder
+p0.extensions_ref();
+response::Builder::extensions_ref(p0);
+crate::response::Builder::extensions_ref(p0);
+<response::Builder>::extensions_ref(p0);
-----------------
src/response.rs response::Builder::extensions_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // response::Builder
+p0.extensions_mut();
+response::Builder::extensions_mut(p0);
+crate::response::Builder::extensions_mut(p0);
+<response::Builder>::extensions_mut(p0);
-----------------
src/response.rs response::Builder::body
deps:{"response::Builder::body":{"T":["std::marker::Sized"]}}
candidates:{"response::Builder::body":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.body(p1);
+response::Builder::body(p0, p1);
+crate::response::Builder::body(p0, p1);
+<response::Builder>::body(p0, p1);
-----------------
src/response.rs response::Builder::and_then
deps:{"response::Builder::and_then":{"F":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"response::Builder::and_then":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // response::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.and_then(p1);
+response::Builder::and_then(p0, p1);
+crate::response::Builder::and_then(p0, p1);
+<response::Builder>::and_then(p0, p1);
-----------------
src/response.rs <response::Builder as std::default::Default>::default
deps:{}
candidates:{}
+<response::Builder as std::default::Default>::default();
+crate::<response::Builder as std::default::Default>::default();
+<response::Builder>::default();
-----------------
src/status.rs <status::StatusCode as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.clone();
+<status::StatusCode as std::clone::Clone>::clone(p0);
+crate::<status::StatusCode as std::clone::Clone>::clone(p0);
+<status::StatusCode>::clone(p0);
-----------------
src/status.rs <status::StatusCode as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
let mut p1 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.eq(p1);
+<status::StatusCode as std::cmp::PartialEq>::eq(p0, p1);
+crate::<status::StatusCode as std::cmp::PartialEq>::eq(p0, p1);
+<status::StatusCode>::eq(p0, p1);
-----------------
src/status.rs <status::StatusCode as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.assert_receiver_is_total_eq();
+<status::StatusCode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<status::StatusCode as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<status::StatusCode>::assert_receiver_is_total_eq(p0);
-----------------
src/status.rs <status::StatusCode as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
let mut p1 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.partial_cmp(p1);
+<status::StatusCode as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<status::StatusCode as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<status::StatusCode>::partial_cmp(p0, p1);
-----------------
src/status.rs <status::StatusCode as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
let mut p1 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.cmp(p1);
+<status::StatusCode as std::cmp::Ord>::cmp(p0, p1);
+crate::<status::StatusCode as std::cmp::Ord>::cmp(p0, p1);
+<status::StatusCode>::cmp(p0, p1);
-----------------
src/status.rs <status::StatusCode as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<status::StatusCode as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<status::StatusCode as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<status::StatusCode as std::hash::Hash>::hash(p0, p1);
+crate::<status::StatusCode as std::hash::Hash>::hash(p0, p1);
+<status::StatusCode>::hash(p0, p1);
-----------------
src/status.rs status::StatusCode::from_u16
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+status::StatusCode::from_u16(p0);
+crate::status::StatusCode::from_u16(p0);
+<status::StatusCode>::from_u16(p0);
-----------------
src/status.rs status::StatusCode::from_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+status::StatusCode::from_bytes(p0);
+crate::status::StatusCode::from_bytes(p0);
+<status::StatusCode>::from_bytes(p0);
-----------------
src/status.rs status::StatusCode::as_u16
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.as_u16();
+status::StatusCode::as_u16(p0);
+crate::status::StatusCode::as_u16(p0);
+<status::StatusCode>::as_u16(p0);
-----------------
src/status.rs status::StatusCode::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.as_str();
+status::StatusCode::as_str(p0);
+crate::status::StatusCode::as_str(p0);
+<status::StatusCode>::as_str(p0);
-----------------
src/status.rs status::StatusCode::canonical_reason
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.canonical_reason();
+status::StatusCode::canonical_reason(p0);
+crate::status::StatusCode::canonical_reason(p0);
+<status::StatusCode>::canonical_reason(p0);
-----------------
src/status.rs status::StatusCode::is_informational
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.is_informational();
+status::StatusCode::is_informational(p0);
+crate::status::StatusCode::is_informational(p0);
+<status::StatusCode>::is_informational(p0);
-----------------
src/status.rs status::StatusCode::is_success
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.is_success();
+status::StatusCode::is_success(p0);
+crate::status::StatusCode::is_success(p0);
+<status::StatusCode>::is_success(p0);
-----------------
src/status.rs status::StatusCode::is_redirection
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.is_redirection();
+status::StatusCode::is_redirection(p0);
+crate::status::StatusCode::is_redirection(p0);
+<status::StatusCode>::is_redirection(p0);
-----------------
src/status.rs status::StatusCode::is_client_error
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.is_client_error();
+status::StatusCode::is_client_error(p0);
+crate::status::StatusCode::is_client_error(p0);
+<status::StatusCode>::is_client_error(p0);
-----------------
src/status.rs status::StatusCode::is_server_error
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.is_server_error();
+status::StatusCode::is_server_error(p0);
+crate::status::StatusCode::is_server_error(p0);
+<status::StatusCode>::is_server_error(p0);
-----------------
src/status.rs <status::StatusCode as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<status::StatusCode as std::fmt::Debug>::fmt(p0, p1);
+crate::<status::StatusCode as std::fmt::Debug>::fmt(p0, p1);
+<status::StatusCode>::fmt(p0, p1);
-----------------
src/status.rs <status::StatusCode as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<status::StatusCode as std::fmt::Display>::fmt(p0, p1);
+crate::<status::StatusCode as std::fmt::Display>::fmt(p0, p1);
+<status::StatusCode>::fmt(p0, p1);
-----------------
src/status.rs <status::StatusCode as std::default::Default>::default
deps:{}
candidates:{}
+<status::StatusCode as std::default::Default>::default();
+crate::<status::StatusCode as std::default::Default>::default();
+<status::StatusCode>::default();
-----------------
src/status.rs <status::StatusCode as std::cmp::PartialEq<u16>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
let mut p1 = & 0u16; // None+u16
+p0.eq(p1);
+<status::StatusCode as std::cmp::PartialEq<u16>>::eq(p0, p1);
+crate::<status::StatusCode as std::cmp::PartialEq<u16>>::eq(p0, p1);
+<status::StatusCode>::eq(p0, p1);
-----------------
src/status.rs status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+p0.eq(p1);
+status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq(p0, p1);
+crate::status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq(p0, p1);
+<u16>::eq(p0, p1);
-----------------
src/status.rs status::<impl std::convert::From<status::StatusCode> for u16>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // status::StatusCode
+status::<impl std::convert::From<status::StatusCode> for u16>::from(p0);
+crate::status::<impl std::convert::From<status::StatusCode> for u16>::from(p0);
+<u16>::from(p0);
-----------------
src/status.rs <status::StatusCode as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<status::StatusCode as std::str::FromStr>::from_str(&p0);
+crate::<status::StatusCode as std::str::FromStr>::from_str(&p0);
+<status::StatusCode>::from_str(&p0);
-----------------
src/status.rs <status::StatusCode as std::convert::From<&'a status::StatusCode>>::from
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::StatusCode
+<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from(p0);
+crate::<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from(p0);
+<status::StatusCode>::from(p0);
-----------------
src/status.rs <status::StatusCode as std::convert::TryFrom<&'a [u8]>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<status::StatusCode as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+crate::<status::StatusCode as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+<status::StatusCode>::try_from(p0);
-----------------
src/status.rs <status::StatusCode as std::convert::TryFrom<&'a str>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<status::StatusCode as std::convert::TryFrom<&'a str>>::try_from(&p0);
+crate::<status::StatusCode as std::convert::TryFrom<&'a str>>::try_from(&p0);
+<status::StatusCode>::try_from(&p0);
-----------------
src/status.rs <status::StatusCode as std::convert::TryFrom<u16>>::try_from
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<status::StatusCode as std::convert::TryFrom<u16>>::try_from(p0);
+crate::<status::StatusCode as std::convert::TryFrom<u16>>::try_from(p0);
+<status::StatusCode>::try_from(p0);
-----------------
src/status.rs status::InvalidStatusCode::new
deps:{}
candidates:{}
+status::InvalidStatusCode::new();
+crate::status::InvalidStatusCode::new();
+<status::InvalidStatusCode>::new();
-----------------
src/status.rs <status::InvalidStatusCode as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::InvalidStatusCode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<status::InvalidStatusCode as std::fmt::Debug>::fmt(p0, p1);
+crate::<status::InvalidStatusCode as std::fmt::Debug>::fmt(p0, p1);
+<status::InvalidStatusCode>::fmt(p0, p1);
-----------------
src/status.rs <status::InvalidStatusCode as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // status::InvalidStatusCode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<status::InvalidStatusCode as std::fmt::Display>::fmt(p0, p1);
+crate::<status::InvalidStatusCode as std::fmt::Display>::fmt(p0, p1);
+<status::InvalidStatusCode>::fmt(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.clone();
+<uri::authority::Authority as std::clone::Clone>::clone(p0);
+crate::<uri::authority::Authority as std::clone::Clone>::clone(p0);
+<uri::authority::Authority>::clone(p0);
-----------------
src/uri/authority.rs uri::authority::Authority::empty
deps:{}
candidates:{}
+uri::authority::Authority::empty();
+crate::uri::authority::Authority::empty();
+<uri::authority::Authority>::empty();
-----------------
src/uri/authority.rs uri::authority::Authority::from_shared
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // bytes::Bytes
+uri::authority::Authority::from_shared(p0);
+crate::uri::authority::Authority::from_shared(p0);
+<uri::authority::Authority>::from_shared(p0);
-----------------
src/uri/authority.rs uri::authority::Authority::from_static
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+uri::authority::Authority::from_static(&p0);
+crate::uri::authority::Authority::from_static(&p0);
+<uri::authority::Authority>::from_static(&p0);
-----------------
src/uri/authority.rs uri::authority::Authority::from_maybe_shared
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"uri::authority::Authority::from_maybe_shared":{"T":["std::marker::Sized","std::convert::AsRef"]},"uri::port::Port":{"T":["std::fmt::Debug","std::marker::Sized","std::convert::AsRef"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"uri::authority::Authority::from_maybe_shared":{"T":["uri::port::Port","header::value::HeaderValue","<&mut T as std::convert::AsRef<U>>","uri::scheme::Scheme","method::Method","uri::authority::Authority","<&T as std::convert::AsRef<U>>"]},"uri::port::Port":{"T":["uri::authority::Authority","uri::scheme::Scheme","header::value::HeaderValue","method::Method","<&mut T as std::convert::AsRef<U>>","uri::port::Port"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+uri::authority::Authority::from_maybe_shared(p0);
+crate::uri::authority::Authority::from_maybe_shared(p0);
+<uri::authority::Authority>::from_maybe_shared(p0);
-----------------
src/uri/authority.rs uri::authority::Authority::parse
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+uri::authority::Authority::parse(p0);
+crate::uri::authority::Authority::parse(p0);
+<uri::authority::Authority>::parse(p0);
-----------------
src/uri/authority.rs uri::authority::Authority::parse_non_empty
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+uri::authority::Authority::parse_non_empty(p0);
+crate::uri::authority::Authority::parse_non_empty(p0);
+<uri::authority::Authority>::parse_non_empty(p0);
-----------------
src/uri/authority.rs uri::authority::Authority::host
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.host();
+uri::authority::Authority::host(p0);
+crate::uri::authority::Authority::host(p0);
+<uri::authority::Authority>::host(p0);
-----------------
src/uri/authority.rs uri::authority::Authority::port
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.port();
+uri::authority::Authority::port(p0);
+crate::uri::authority::Authority::port(p0);
+<uri::authority::Authority>::port(p0);
-----------------
src/uri/authority.rs uri::authority::Authority::port_u16
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.port_u16();
+uri::authority::Authority::port_u16(p0);
+crate::uri::authority::Authority::port_u16(p0);
+<uri::authority::Authority>::port_u16(p0);
-----------------
src/uri/authority.rs uri::authority::Authority::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.as_str();
+uri::authority::Authority::as_str(p0);
+crate::uri::authority::Authority::as_str(p0);
+<uri::authority::Authority>::as_str(p0);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::convert::AsRef<str>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.as_ref();
+<uri::authority::Authority as std::convert::AsRef<str>>::as_ref(p0);
+crate::<uri::authority::Authority as std::convert::AsRef<str>>::as_ref(p0);
+<uri::authority::Authority>::as_ref(p0);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.eq(p1);
+<uri::authority::Authority as std::cmp::PartialEq>::eq(p0, p1);
+crate::<uri::authority::Authority as std::cmp::PartialEq>::eq(p0, p1);
+<uri::authority::Authority>::eq(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::cmp::PartialEq<str>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<uri::authority::Authority as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<uri::authority::Authority as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<uri::authority::Authority>::eq(p0, &p1);
-----------------
src/uri/authority.rs uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.eq(p1);
+uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq(&p0, p1);
+crate::uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq(&p0, p1);
+<str>::eq(&p0, p1);
-----------------
src/uri/authority.rs uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.eq(p1);
+uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq(p0, p1);
+crate::uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq(p0, p1);
+<&'a str>::eq(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = & "a"; // None+&'a str
+p0.eq(p1);
+<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+crate::<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+<uri::authority::Authority>::eq(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.eq(p1);
+<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+crate::<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+<uri::authority::Authority>::eq(p0, p1);
-----------------
src/uri/authority.rs uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.eq(p1);
+uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq(p0, p1);
+crate::uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq(p0, p1);
+<std::string::String>::eq(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.partial_cmp(p1);
+<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<uri::authority::Authority>::partial_cmp(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = "sample"; // None+&str
+p0.partial_cmp(&p1);
+<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp(p0, &p1);
+crate::<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp(p0, &p1);
+<uri::authority::Authority>::partial_cmp(p0, &p1);
-----------------
src/uri/authority.rs uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.partial_cmp(p1);
+uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp(&p0, p1);
+crate::uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp(&p0, p1);
+<str>::partial_cmp(&p0, p1);
-----------------
src/uri/authority.rs uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.partial_cmp(p1);
+uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp(p0, p1);
+crate::uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp(p0, p1);
+<&'a str>::partial_cmp(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = & "a"; // None+&'a str
+p0.partial_cmp(p1);
+<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp(p0, p1);
+crate::<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp(p0, p1);
+<uri::authority::Authority>::partial_cmp(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.partial_cmp(p1);
+<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp(p0, p1);
+crate::<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp(p0, p1);
+<uri::authority::Authority>::partial_cmp(p0, p1);
-----------------
src/uri/authority.rs uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
+p0.partial_cmp(p1);
+uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp(p0, p1);
+crate::uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp(p0, p1);
+<std::string::String>::partial_cmp(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<uri::authority::Authority as std::hash::Hash>::hash":{"H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<uri::authority::Authority as std::hash::Hash>::hash":{"H":["extensions::IdHasher","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<uri::authority::Authority as std::hash::Hash>::hash(p0, p1);
+crate::<uri::authority::Authority as std::hash::Hash>::hash(p0, p1);
+<uri::authority::Authority>::hash(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+crate::<uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+<uri::authority::Authority>::try_from(p0);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::convert::TryFrom<&'a str>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<uri::authority::Authority as std::convert::TryFrom<&'a str>>::try_from(&p0);
+crate::<uri::authority::Authority as std::convert::TryFrom<&'a str>>::try_from(&p0);
+<uri::authority::Authority>::try_from(&p0);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<uri::authority::Authority as std::str::FromStr>::from_str(&p0);
+crate::<uri::authority::Authority as std::str::FromStr>::from_str(&p0);
+<uri::authority::Authority>::from_str(&p0);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::authority::Authority as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::authority::Authority as std::fmt::Debug>::fmt(p0, p1);
+<uri::authority::Authority>::fmt(p0, p1);
-----------------
src/uri/authority.rs <uri::authority::Authority as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::authority::Authority
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<uri::authority::Authority as std::fmt::Display>::fmt(p0, p1);
+crate::<uri::authority::Authority as std::fmt::Display>::fmt(p0, p1);
+<uri::authority::Authority>::fmt(p0, p1);
-----------------
src/uri/builder.rs <uri::builder::Builder as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::builder::Builder
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::builder::Builder as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::builder::Builder as std::fmt::Debug>::fmt(p0, p1);
+<uri::builder::Builder>::fmt(p0, p1);
-----------------
src/uri/builder.rs uri::builder::Builder::new
deps:{}
candidates:{}
+uri::builder::Builder::new();
+crate::uri::builder::Builder::new();
+<uri::builder::Builder>::new();
-----------------
src/uri/builder.rs uri::builder::Builder::scheme
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"uri::builder::Builder::scheme":{"<uri::scheme::Scheme as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::scheme::Scheme":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"uri::builder::Builder::scheme":{"<uri::scheme::Scheme as std::convert::TryFrom<T>>::Error":["<T as std::convert::Into<U>>","std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"],"T":["RUG_ANY"],"uri::scheme::Scheme":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::builder::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.scheme(p1);
+uri::builder::Builder::scheme(p0, p1);
+crate::uri::builder::Builder::scheme(p0, p1);
+<uri::builder::Builder>::scheme(p0, p1);
-----------------
src/uri/builder.rs uri::builder::Builder::authority
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::convert::TryFrom","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"uri::builder::Builder::authority":{"<uri::authority::Authority as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::authority::Authority":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::value::HeaderValue","header::map::HeaderMap"]},"uri::builder::Builder::authority":{"<uri::authority::Authority as std::convert::TryFrom<T>>::Error":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError"],"T":["RUG_ANY"],"uri::authority::Authority":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::builder::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.authority(p1);
+uri::builder::Builder::authority(p0, p1);
+crate::uri::builder::Builder::authority(p0, p1);
+<uri::builder::Builder>::authority(p0, p1);
-----------------
src/uri/builder.rs uri::builder::Builder::path_and_query
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"<T as std::convert::TryFrom<U>>":{"T":["std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::cmp::PartialEq","std::convert::TryFrom","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"uri::builder::Builder::path_and_query":{"<uri::path::PathAndQuery as std::convert::TryFrom<T>>::Error":["std::convert::Into"],"T":["std::marker::Sized"],"uri::path::PathAndQuery":["std::convert::TryFrom"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"<T as std::convert::TryFrom<U>>":{"T":["RUG_ANY"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"uri::builder::Builder::path_and_query":{"<uri::path::PathAndQuery as std::convert::TryFrom<T>>::Error":["std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::process::ExitStatusError"],"T":["RUG_ANY"],"uri::path::PathAndQuery":["<T as std::convert::TryFrom<U>>","header::map::HeaderMap"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::builder::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.path_and_query(p1);
+uri::builder::Builder::path_and_query(p0, p1);
+crate::uri::builder::Builder::path_and_query(p0, p1);
+<uri::builder::Builder>::path_and_query(p0, p1);
-----------------
src/uri/builder.rs uri::builder::Builder::build
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::builder::Builder
+p0.build();
+uri::builder::Builder::build(p0);
+crate::uri::builder::Builder::build(p0);
+<uri::builder::Builder>::build(p0);
-----------------
src/uri/builder.rs uri::builder::Builder::map
deps:{"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"uri::builder::Builder::map":{"F":["std::marker::Sized","std::ops::FnOnce"]}}
candidates:{"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{},"uri::builder::Builder::map":{"F":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::builder::Builder
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+uri::builder::Builder::map(p0, p1);
+crate::uri::builder::Builder::map(p0, p1);
+<uri::builder::Builder>::map(p0, p1);
-----------------
src/uri/builder.rs <uri::builder::Builder as std::default::Default>::default
deps:{}
candidates:{}
+<uri::builder::Builder as std::default::Default>::default();
+crate::<uri::builder::Builder as std::default::Default>::default();
+<uri::builder::Builder>::default();
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.clone();
+<uri::path::PathAndQuery as std::clone::Clone>::clone(p0);
+crate::<uri::path::PathAndQuery as std::clone::Clone>::clone(p0);
+<uri::path::PathAndQuery>::clone(p0);
-----------------
src/uri/path.rs uri::path::PathAndQuery::from_shared
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // bytes::Bytes
+uri::path::PathAndQuery::from_shared(p0);
+crate::uri::path::PathAndQuery::from_shared(p0);
+<uri::path::PathAndQuery>::from_shared(p0);
-----------------
src/uri/path.rs uri::path::PathAndQuery::from_static
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+uri::path::PathAndQuery::from_static(&p0);
+crate::uri::path::PathAndQuery::from_static(&p0);
+<uri::path::PathAndQuery>::from_static(&p0);
-----------------
src/uri/path.rs uri::path::PathAndQuery::from_maybe_shared
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"uri::path::PathAndQuery::from_maybe_shared":{"T":["std::marker::Sized","std::convert::AsRef"]},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"uri::path::PathAndQuery::from_maybe_shared":{"T":["header::value::HeaderValue","uri::port::Port","<&mut T as std::convert::AsRef<U>>","uri::authority::Authority","uri::scheme::Scheme","method::Method","<&T as std::convert::AsRef<U>>"]},"uri::port::Port":{"T":["uri::scheme::Scheme","<&mut T as std::fmt::Debug>","uri::port::Port","uri::authority::Authority","method::Method","header::value::HeaderValue"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+uri::path::PathAndQuery::from_maybe_shared(p0);
+crate::uri::path::PathAndQuery::from_maybe_shared(p0);
+<uri::path::PathAndQuery>::from_maybe_shared(p0);
-----------------
src/uri/path.rs uri::path::PathAndQuery::empty
deps:{}
candidates:{}
+uri::path::PathAndQuery::empty();
+crate::uri::path::PathAndQuery::empty();
+<uri::path::PathAndQuery>::empty();
-----------------
src/uri/path.rs uri::path::PathAndQuery::slash
deps:{}
candidates:{}
+uri::path::PathAndQuery::slash();
+crate::uri::path::PathAndQuery::slash();
+<uri::path::PathAndQuery>::slash();
-----------------
src/uri/path.rs uri::path::PathAndQuery::star
deps:{}
candidates:{}
+uri::path::PathAndQuery::star();
+crate::uri::path::PathAndQuery::star();
+<uri::path::PathAndQuery>::star();
-----------------
src/uri/path.rs uri::path::PathAndQuery::path
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.path();
+uri::path::PathAndQuery::path(p0);
+crate::uri::path::PathAndQuery::path(p0);
+<uri::path::PathAndQuery>::path(p0);
-----------------
src/uri/path.rs uri::path::PathAndQuery::query
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.query();
+uri::path::PathAndQuery::query(p0);
+crate::uri::path::PathAndQuery::query(p0);
+<uri::path::PathAndQuery>::query(p0);
-----------------
src/uri/path.rs uri::path::PathAndQuery::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.as_str();
+uri::path::PathAndQuery::as_str(p0);
+crate::uri::path::PathAndQuery::as_str(p0);
+<uri::path::PathAndQuery>::as_str(p0);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::convert::TryFrom<&'a [u8]>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<uri::path::PathAndQuery as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+crate::<uri::path::PathAndQuery as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+<uri::path::PathAndQuery>::try_from(p0);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::convert::TryFrom<&'a str>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<uri::path::PathAndQuery as std::convert::TryFrom<&'a str>>::try_from(&p0);
+crate::<uri::path::PathAndQuery as std::convert::TryFrom<&'a str>>::try_from(&p0);
+<uri::path::PathAndQuery>::try_from(&p0);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::convert::TryFrom<std::string::String>>::try_from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<uri::path::PathAndQuery as std::convert::TryFrom<std::string::String>>::try_from(p0);
+crate::<uri::path::PathAndQuery as std::convert::TryFrom<std::string::String>>::try_from(p0);
+<uri::path::PathAndQuery>::try_from(p0);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::convert::TryFrom<&std::string::String>>::try_from
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<uri::path::PathAndQuery as std::convert::TryFrom<&std::string::String>>::try_from(p0);
+crate::<uri::path::PathAndQuery as std::convert::TryFrom<&std::string::String>>::try_from(p0);
+<uri::path::PathAndQuery>::try_from(p0);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<uri::path::PathAndQuery as std::str::FromStr>::from_str(&p0);
+crate::<uri::path::PathAndQuery as std::str::FromStr>::from_str(&p0);
+<uri::path::PathAndQuery>::from_str(&p0);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::path::PathAndQuery as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::path::PathAndQuery as std::fmt::Debug>::fmt(p0, p1);
+<uri::path::PathAndQuery>::fmt(p0, p1);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<uri::path::PathAndQuery as std::fmt::Display>::fmt(p0, p1);
+crate::<uri::path::PathAndQuery as std::fmt::Display>::fmt(p0, p1);
+<uri::path::PathAndQuery>::fmt(p0, p1);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.eq(p1);
+<uri::path::PathAndQuery as std::cmp::PartialEq>::eq(p0, p1);
+crate::<uri::path::PathAndQuery as std::cmp::PartialEq>::eq(p0, p1);
+<uri::path::PathAndQuery>::eq(p0, p1);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<uri::path::PathAndQuery>::eq(p0, &p1);
-----------------
src/uri/path.rs uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.eq(p1);
+uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq(p0, p1);
+crate::uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq(p0, p1);
+<&'a str>::eq(p0, p1);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = & "a"; // None+&'a str
+p0.eq(p1);
+<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+crate::<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+<uri::path::PathAndQuery>::eq(p0, p1);
-----------------
src/uri/path.rs uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.eq(p1);
+uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq(&p0, p1);
+crate::uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq(&p0, p1);
+<str>::eq(&p0, p1);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.eq(p1);
+<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+crate::<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq(p0, p1);
+<uri::path::PathAndQuery>::eq(p0, p1);
-----------------
src/uri/path.rs uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.eq(p1);
+uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq(p0, p1);
+crate::uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq(p0, p1);
+<std::string::String>::eq(p0, p1);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.partial_cmp(p1);
+<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<uri::path::PathAndQuery>::partial_cmp(p0, p1);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = "sample"; // None+&str
+p0.partial_cmp(&p1);
+<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp(p0, &p1);
+crate::<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp(p0, &p1);
+<uri::path::PathAndQuery>::partial_cmp(p0, &p1);
-----------------
src/uri/path.rs uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.partial_cmp(p1);
+uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp(&p0, p1);
+crate::uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp(&p0, p1);
+<str>::partial_cmp(&p0, p1);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = & "a"; // None+&'a str
+p0.partial_cmp(p1);
+<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp(p0, p1);
+crate::<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp(p0, p1);
+<uri::path::PathAndQuery>::partial_cmp(p0, p1);
-----------------
src/uri/path.rs uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.partial_cmp(p1);
+uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp(p0, p1);
+crate::uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp(p0, p1);
+<&'a str>::partial_cmp(p0, p1);
-----------------
src/uri/path.rs <uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.partial_cmp(p1);
+<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp(p0, p1);
+crate::<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp(p0, p1);
+<uri::path::PathAndQuery>::partial_cmp(p0, p1);
-----------------
src/uri/path.rs uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::path::PathAndQuery
+p0.partial_cmp(p1);
+uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp(p0, p1);
+crate::uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp(p0, p1);
+<std::string::String>::partial_cmp(p0, p1);
-----------------
src/uri/port.rs uri::port::Port::<T>::as_u16
deps:{"uri::port::Port::<T>::as_u16":{"T":["std::marker::Sized"]}}
candidates:{"uri::port::Port::<T>::as_u16":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::port::Port<T>
+p0.as_u16();
+uri::port::Port::<T>::as_u16(p0);
+crate::uri::port::Port::<T>::as_u16(p0);
+<uri::port::Port<T>>::as_u16(p0);
-----------------
src/uri/port.rs uri::port::Port::<T>::from_str
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"uri::port::Port":{"T":["std::convert::AsRef","std::marker::Sized","std::fmt::Debug"]},"uri::port::Port::<T>::from_str":{"T":["std::convert::AsRef","std::marker::Sized"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"uri::port::Port":{"T":["<&T as std::convert::AsRef<U>>","method::Method","uri::scheme::Scheme","header::value::HeaderValue","uri::port::Port","uri::authority::Authority"]},"uri::port::Port::<T>::from_str":{"T":["method::Method","<&T as std::convert::AsRef<U>>","uri::port::Port","header::value::HeaderValue","uri::authority::Authority","<&mut T as std::convert::AsRef<U>>","uri::scheme::Scheme"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+uri::port::Port::<T>::from_str(p0);
+crate::uri::port::Port::<T>::from_str(p0);
+<uri::port::Port<T>>::from_str(p0);
-----------------
src/uri/port.rs uri::port::Port::<T>::as_str
deps:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::port::Port::<T>::as_str":{"T":["std::marker::Sized","std::convert::AsRef"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&T as std::fmt::Debug>":{},"<&mut T as std::convert::AsRef<U>>":{},"uri::port::Port":{"T":["<&mut T as std::convert::AsRef<U>>","uri::scheme::Scheme","uri::port::Port","uri::authority::Authority","method::Method","header::value::HeaderValue"]},"uri::port::Port::<T>::as_str":{"T":["<&T as std::convert::AsRef<U>>","uri::scheme::Scheme","method::Method","uri::port::Port","uri::authority::Authority","header::value::HeaderValue"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::port::Port<T>
+p0.as_str();
+uri::port::Port::<T>::as_str(p0);
+crate::uri::port::Port::<T>::as_str(p0);
+<uri::port::Port<T>>::as_str(p0);
-----------------
src/uri/port.rs <uri::port::Port<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<uri::port::Port<T> as std::fmt::Debug>::fmt":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Bucket":{"T":["std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"header::map::Drain":{"T":["std::marker::Sync","std::fmt::Debug","std::marker::Send","std::marker::Sized"]},"header::map::Entry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ExtraValue":{"T":["std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"header::map::GetAll":{"T":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"header::map::HeaderMap":{"T":["std::cmp::PartialEq","std::cmp::Eq","std::convert::TryFrom","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Send","std::marker::Sized","std::marker::Sync"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Sized","std::marker::Send","std::marker::Sync","std::fmt::Debug"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::hash::Hash","std::cmp::PartialEq"]},"request::Request":{"T":["std::marker::Sized","std::fmt::Debug","std::default::Default"]},"response::Response":{"T":["std::fmt::Debug","std::default::Default","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<uri::port::Port<T> as std::fmt::Debug>::fmt":{"T":["header::name::StandardHeader","header::map::RawLinks","header::map::Links","request::Request","header::name::Repr","header::map::ValueIter","header::map::Link","extensions::Extensions","header::map::Values","uri::path::PathAndQuery","response::Parts","uri::scheme::Scheme","header::map::ExtraValue","uri::port::Port","<&T as std::fmt::Debug>","uri::builder::Builder","response::Response","header::value::InvalidHeaderValue","header::map::IntoIter","header::map::GetAll","header::value::HeaderValue","uri::scheme::Scheme2","header::name::InvalidHeaderName","status::StatusCode","header::map::HashValue","header::map::ValuesMut","<*mut T as std::fmt::Debug>","method::InvalidMethod","uri::InvalidUri","header::name::HeaderName","uri::ErrorKind","header::value::ToStrError","header::map::ValueIterMut","request::Parts","header::name::MaybeLower","version::Version","header::map::IterMut","uri::Parts","uri::InvalidUriParts","header::map::HeaderMap","header::map::ValueDrain","error::Error","status::InvalidStatusCode","header::name::Custom","header::map::VacantEntry","uri::scheme::Protocol","header::map::Bucket","uri::Uri","header::map::Keys","byte_str::ByteStr","header::map::Cursor","method::Method","header::map::Entry","request::Builder","uri::authority::Authority","header::name::HdrName","header::map::Drain","header::map::Iter","response::Builder","header::map::OccupiedEntry"]},"header::map::Bucket":{"T":["header::map::Bucket","version::Version","header::map::Cursor","byte_str::ByteStr","uri::scheme::Scheme2","uri::path::PathAndQuery","header::map::Link","header::name::HeaderName","uri::authority::Authority","header::map::HashValue","header::map::ExtraValue","status::StatusCode","header::name::StandardHeader","header::map::RawLinks","<&mut T as std::fmt::Debug>","uri::scheme::Scheme","header::name::Repr","method::Method","uri::Uri","header::map::Links","header::value::HeaderValue","header::map::HeaderMap","header::name::Custom","header::name::MaybeLower","uri::scheme::Protocol"]},"header::map::Drain":{"T":["header::map::ValueDrain","header::map::ValueIterMut","<*mut T as std::marker::Send>","header::map::IterMut","header::map::Drain","header::map::Iter"]},"header::map::Entry":{"T":["status::StatusCode","header::map::GetAll","response::Response","header::map::ValuesMut","header::name::HdrName","header::value::HeaderValue","error::Error","uri::Parts","request::Builder","header::map::Link","response::Parts","header::map::ValueIterMut","header::map::Cursor","<*mut T as std::fmt::Debug>","header::map::RawLinks","header::map::ExtraValue","uri::builder::Builder","uri::InvalidUriParts","method::InvalidMethod","header::map::Keys","header::name::HeaderName","extensions::Extensions","header::name::Custom","header::map::Iter","header::value::ToStrError","uri::scheme::Protocol","uri::ErrorKind","header::map::ValueIter","header::name::Repr","uri::scheme::Scheme","version::Version","uri::path::PathAndQuery","header::name::MaybeLower","header::map::IntoIter","uri::Uri","uri::authority::Authority","header::map::VacantEntry","header::name::StandardHeader","header::map::Bucket","header::map::IterMut","byte_str::ByteStr","uri::InvalidUri","header::name::InvalidHeaderName","header::map::Links","method::Method","status::InvalidStatusCode","header::map::HeaderMap","header::map::OccupiedEntry","uri::port::Port","request::Request","request::Parts","header::map::HashValue","header::map::Values","response::Builder","header::map::Drain","uri::scheme::Scheme2","header::map::ValueDrain","header::value::InvalidHeaderValue","header::map::Entry"]},"header::map::ExtraValue":{"T":["header::map::Cursor","uri::authority::Authority","uri::scheme::Scheme2","header::value::HeaderValue","header::name::Repr","header::name::StandardHeader","header::map::HeaderMap","uri::Uri","header::map::Link","status::StatusCode","header::name::Custom","header::map::ExtraValue","<&mut T as std::fmt::Debug>","header::map::Links","header::map::HashValue","header::map::Bucket","method::Method","header::map::RawLinks","uri::scheme::Protocol","header::name::HeaderName","version::Version","byte_str::ByteStr","header::name::MaybeLower","uri::scheme::Scheme","uri::path::PathAndQuery"]},"header::map::GetAll":{"T":["header::map::HashValue","byte_str::ByteStr","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","header::map::Link","header::map::Cursor","header::map::HeaderMap","header::map::GetAll","header::name::Custom","header::name::Repr","version::Version","header::name::StandardHeader","uri::ErrorKind"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::name::Custom","header::name::Repr","method::Method","header::map::Iter","response::Parts","<&mut T as std::fmt::Debug>","method::InvalidMethod","uri::scheme::Scheme2","header::value::HeaderValue","header::map::Values","uri::builder::Builder","uri::authority::Authority","request::Parts","uri::Parts","header::map::RawLinks","header::map::Cursor","header::map::ExtraValue","status::InvalidStatusCode","header::map::Link","response::Builder","header::map::HeaderMap","uri::scheme::Protocol","header::name::HeaderName","header::map::ValueDrain","extensions::Extensions","header::map::Keys","header::map::OccupiedEntry","uri::port::Port","uri::ErrorKind","header::name::StandardHeader","header::map::HashValue","header::name::MaybeLower","header::map::IterMut","request::Request","version::Version","uri::InvalidUriParts","header::value::InvalidHeaderValue","header::map::ValueIter","request::Builder","uri::path::PathAndQuery","status::StatusCode","header::map::Drain","header::map::ValueIterMut","header::name::InvalidHeaderName","response::Response","header::map::Bucket","uri::Uri","header::map::ValuesMut","uri::InvalidUri","header::map::GetAll","header::map::Entry","header::value::ToStrError","header::name::HdrName","uri::scheme::Scheme","header::map::Links","error::Error","byte_str::ByteStr","header::map::VacantEntry","header::map::IntoIter"]},"header::map::Iter":{"T":["<*const T as std::marker::Sync>","header::map::Drain","header::map::ValueDrain","header::map::IterMut","header::map::Iter","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["header::map::ValueIterMut","header::map::IterMut","<*mut T as std::marker::Send>","header::map::Drain","header::map::Iter","header::map::ValueDrain"]},"header::map::Keys":{"T":["header::value::InvalidHeaderValue","uri::InvalidUriParts","header::name::Custom","extensions::Extensions","uri::Uri","header::map::ValueDrain","<&mut T as std::fmt::Debug>","header::map::Values","header::map::ValueIterMut","uri::builder::Builder","method::Method","header::name::Repr","header::map::HeaderMap","uri::scheme::Scheme","method::InvalidMethod","header::map::Keys","header::value::HeaderValue","header::map::VacantEntry","header::map::IterMut","uri::InvalidUri","header::map::Cursor","uri::path::PathAndQuery","response::Response","header::map::Link","header::map::HashValue","response::Parts","header::name::InvalidHeaderName","header::map::ValuesMut","status::InvalidStatusCode","header::map::ValueIter","header::map::RawLinks","uri::Parts","version::Version","header::map::Entry","uri::scheme::Scheme2","header::name::HeaderName","uri::ErrorKind","header::value::ToStrError","header::map::ExtraValue","uri::port::Port","header::name::MaybeLower","header::map::OccupiedEntry","header::map::Drain","uri::authority::Authority","header::map::Bucket","error::Error","byte_str::ByteStr","response::Builder","request::Request","uri::scheme::Protocol","header::map::IntoIter","header::map::Links","header::map::Iter","request::Parts","status::StatusCode","header::map::GetAll","header::name::HdrName","request::Builder","header::name::StandardHeader"]},"header::map::OccupiedEntry":{"T":["header::name::StandardHeader","uri::scheme::Protocol","header::map::GetAll","response::Response","header::map::HeaderMap","<&mut T as std::fmt::Debug>","header::map::Bucket","header::map::Cursor","header::value::ToStrError","status::InvalidStatusCode","uri::Parts","header::map::IntoIter","uri::port::Port","uri::builder::Builder","header::name::MaybeLower","error::Error","header::map::Drain","header::map::Keys","header::map::Links","header::map::Link","extensions::Extensions","header::name::HeaderName","uri::scheme::Scheme","header::name::HdrName","header::map::IterMut","header::map::Values","header::name::Custom","request::Builder","response::Builder","header::map::VacantEntry","header::map::HashValue","byte_str::ByteStr","header::map::ValueIter","header::map::Iter","header::value::InvalidHeaderValue","uri::authority::Authority","uri::path::PathAndQuery","request::Parts","uri::InvalidUri","uri::ErrorKind","header::map::ExtraValue","response::Parts","header::name::InvalidHeaderName","header::value::HeaderValue","uri::Uri","uri::scheme::Scheme2","header::map::ValueIterMut","header::map::ValuesMut","request::Request","method::InvalidMethod","version::Version","header::map::RawLinks","status::StatusCode","header::map::Entry","header::map::OccupiedEntry","method::Method","header::name::Repr","header::map::ValueDrain","uri::InvalidUriParts"]},"header::map::RawLinks":{"T":["uri::path::PathAndQuery","header::map::ValueIterMut","header::map::GetAll","header::map::Cursor","header::value::ToStrError","header::map::HeaderMap","header::map::ValueIter","header::map::ValueDrain","status::InvalidStatusCode","header::map::HashValue","method::Method","extensions::Extensions","uri::InvalidUri","uri::Parts","error::Error","header::map::Link","header::map::OccupiedEntry","request::Builder","header::map::Iter","version::Version","response::Builder","header::map::Entry","header::map::Values","response::Response","header::name::Custom","header::value::InvalidHeaderValue","response::Parts","header::name::MaybeLower","byte_str::ByteStr","uri::scheme::Protocol","uri::Uri","header::name::StandardHeader","status::StatusCode","header::map::VacantEntry","method::InvalidMethod","header::value::HeaderValue","header::name::InvalidHeaderName","uri::scheme::Scheme2","header::name::HeaderName","request::Parts","header::map::Bucket","uri::ErrorKind","uri::InvalidUriParts","header::map::IntoIter","header::name::Repr","header::map::Drain","header::map::IterMut","header::map::Links","<*mut T as std::fmt::Debug>","header::name::HdrName","header::map::ExtraValue","uri::port::Port","uri::builder::Builder","uri::scheme::Scheme","header::map::ValuesMut","header::map::RawLinks","request::Request","uri::authority::Authority","header::map::Keys"]},"header::map::VacantEntry":{"T":["response::Builder","header::map::Cursor","header::map::Drain","header::map::OccupiedEntry","request::Builder","header::map::ExtraValue","header::map::Values","extensions::Extensions","response::Parts","header::name::StandardHeader","uri::InvalidUriParts","header::map::RawLinks","request::Parts","header::name::MaybeLower","header::name::HeaderName","header::name::HdrName","uri::builder::Builder","header::map::Bucket","header::map::GetAll","method::Method","uri::ErrorKind","header::map::Keys","header::map::VacantEntry","uri::InvalidUri","<*const T as std::fmt::Debug>","header::map::ValuesMut","version::Version","header::value::HeaderValue","header::map::Link","uri::Uri","header::map::ValueIter","uri::authority::Authority","header::map::Links","uri::port::Port","header::map::IterMut","byte_str::ByteStr","header::map::ValueDrain","header::map::HashValue","request::Request","uri::Parts","header::value::ToStrError","uri::path::PathAndQuery","header::map::ValueIterMut","header::map::IntoIter","response::Response","status::StatusCode","header::name::Custom","uri::scheme::Scheme2","header::name::Repr","header::map::Iter","header::map::Entry","header::map::HeaderMap","header::value::InvalidHeaderValue","error::Error","header::name::InvalidHeaderName","uri::scheme::Scheme","status::InvalidStatusCode","uri::scheme::Protocol","method::InvalidMethod"]},"header::map::ValueDrain":{"T":["<*const T as std::fmt::Debug>","header::map::Drain","header::map::ValueIterMut","header::map::Iter","header::map::ValueDrain","header::map::IterMut"]},"header::map::ValueIter":{"T":["header::name::Repr","uri::ErrorKind","header::map::ValueIterMut","error::Error","header::map::VacantEntry","header::map::Bucket","header::map::IntoIter","header::name::HeaderName","uri::Parts","<&T as std::fmt::Debug>","uri::builder::Builder","header::name::StandardHeader","header::value::InvalidHeaderValue","method::Method","header::map::HeaderMap","request::Parts","header::map::Cursor","header::value::HeaderValue","uri::Uri","header::name::HdrName","uri::scheme::Protocol","header::map::ExtraValue","header::map::RawLinks","uri::authority::Authority","uri::path::PathAndQuery","extensions::Extensions","header::map::Entry","uri::scheme::Scheme","header::map::Links","header::name::MaybeLower","header::map::GetAll","header::value::ToStrError","response::Builder","uri::InvalidUriParts","uri::scheme::Scheme2","header::map::Values","uri::port::Port","request::Request","status::StatusCode","header::map::Drain","header::map::OccupiedEntry","header::map::HashValue","request::Builder","header::map::ValuesMut","response::Response","method::InvalidMethod","header::name::Custom","header::map::ValueIter","response::Parts","header::map::Iter","byte_str::ByteStr","header::map::Keys","status::InvalidStatusCode","header::map::IterMut","uri::InvalidUri","header::name::InvalidHeaderName","header::map::Link","version::Version","header::map::ValueDrain"]},"header::map::ValueIterMut":{"T":["header::map::Drain","header::map::IterMut","header::map::Iter","<*const T as std::marker::Send>","header::map::ValueIterMut","header::map::ValueDrain"]},"header::map::Values":{"T":["uri::builder::Builder","request::Parts","header::map::RawLinks","header::name::Custom","version::Version","header::map::IterMut","header::name::MaybeLower","header::map::IntoIter","header::map::ExtraValue","header::value::InvalidHeaderValue","header::map::ValueIterMut","uri::scheme::Scheme2","header::map::VacantEntry","error::Error","header::name::HdrName","uri::port::Port","uri::scheme::Scheme","header::map::OccupiedEntry","header::map::ValuesMut","header::map::Cursor","header::map::ValueIter","header::map::Bucket","header::map::HashValue","status::InvalidStatusCode","uri::InvalidUri","header::name::HeaderName","header::map::Drain","response::Parts","header::map::Keys","method::InvalidMethod","header::map::Values","uri::scheme::Protocol","request::Request","uri::Uri","header::map::ValueDrain","header::map::Entry","uri::InvalidUriParts","<&T as std::fmt::Debug>","response::Builder","request::Builder","uri::Parts","status::StatusCode","header::map::Links","uri::ErrorKind","header::map::HeaderMap","uri::path::PathAndQuery","method::Method","header::map::Iter","byte_str::ByteStr","header::name::InvalidHeaderName","header::map::Link","header::value::HeaderValue","header::value::ToStrError","response::Response","header::name::StandardHeader","extensions::Extensions","header::name::Repr","uri::authority::Authority","header::map::GetAll"]},"header::map::ValuesMut":{"T":["header::map::IntoIter","header::map::GetAll","header::map::ValueIter","uri::path::PathAndQuery","byte_str::ByteStr","response::Response","header::map::Links","method::Method","header::map::ValueIterMut","header::map::RawLinks","response::Builder","status::InvalidStatusCode","header::map::HashValue","error::Error","header::map::Bucket","uri::ErrorKind","method::InvalidMethod","header::name::StandardHeader","header::name::MaybeLower","request::Request","header::name::Repr","header::map::VacantEntry","header::map::Iter","uri::InvalidUriParts","header::name::Custom","uri::builder::Builder","header::name::HdrName","request::Builder","header::map::Cursor","uri::scheme::Protocol","header::value::InvalidHeaderValue","header::value::ToStrError","header::name::InvalidHeaderName","header::name::HeaderName","version::Version","header::map::ValuesMut","header::map::Entry","uri::port::Port","header::map::Link","header::map::ExtraValue","header::map::Keys","header::map::HeaderMap","header::map::IterMut","header::map::OccupiedEntry","header::map::ValueDrain","extensions::Extensions","uri::Uri","uri::scheme::Scheme","uri::Parts","uri::scheme::Scheme2","header::map::Drain","<&T as std::fmt::Debug>","response::Parts","uri::InvalidUri","request::Parts","uri::authority::Authority","header::map::Values","status::StatusCode","header::value::HeaderValue"]},"header::name::Repr":{"T":["std::hash::impls::<impl std::hash::Hash for *const T>","version::Version","header::name::StandardHeader","header::name::Custom","byte_str::ByteStr","header::name::Repr"]},"request::Request":{"T":["extensions::Extensions","method::Method","response::Response","response::Builder","status::StatusCode","uri::Uri","request::Request","header::map::HeaderMap","uri::Parts","uri::builder::Builder","request::Builder","version::Version"]},"response::Response":{"T":["uri::builder::Builder","status::StatusCode","extensions::Extensions","uri::Uri","response::Response","uri::Parts","method::Method","header::map::HeaderMap","request::Request","request::Builder","version::Version","response::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"uri::port::Port":{"T":["header::value::HeaderValue","uri::scheme::Scheme","uri::port::Port","uri::authority::Authority","method::Method","<&mut T as std::fmt::Debug>"]},"uri::scheme::Scheme2":{"T":["status::StatusCode","header::name::Repr","header::name::Custom","uri::authority::Authority","header::map::Links","header::map::Link","<&mut T as std::fmt::Debug>","uri::scheme::Scheme","header::map::RawLinks","header::map::Bucket","header::name::StandardHeader","header::name::HeaderName","header::name::MaybeLower","uri::path::PathAndQuery","header::map::HeaderMap","version::Version","header::map::HashValue","method::Method","byte_str::ByteStr","header::value::HeaderValue","uri::Uri","uri::scheme::Protocol","header::map::Cursor","std::boxed::Box<byte_str::ByteStr>","uri::scheme::Scheme2","header::map::ExtraValue"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::port::Port<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::port::Port<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::port::Port<T> as std::fmt::Debug>::fmt(p0, p1);
+<uri::port::Port<T>>::fmt(p0, p1);
-----------------
src/uri/port.rs <uri::port::Port<T> as std::fmt::Display>::fmt
deps:{"<uri::port::Port<T> as std::fmt::Display>::fmt":{"T":["std::marker::Sized"]}}
candidates:{"<uri::port::Port<T> as std::fmt::Display>::fmt":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::port::Port<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<uri::port::Port<T> as std::fmt::Display>::fmt(p0, p1);
+crate::<uri::port::Port<T> as std::fmt::Display>::fmt(p0, p1);
+<uri::port::Port<T>>::fmt(p0, p1);
-----------------
src/uri/port.rs uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from
deps:{"uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from":{"T":["std::marker::Sized"]}}
candidates:{"uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::port::Port<T>
+uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from(p0);
+crate::uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from(p0);
+<u16>::from(p0);
-----------------
src/uri/port.rs <uri::port::Port<T> as std::convert::AsRef<str>>::as_ref
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref":{"T":["std::marker::Sized","std::convert::AsRef"]},"uri::port::Port":{"T":["std::marker::Sized","std::fmt::Debug","std::convert::AsRef"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"<&mut T as std::fmt::Debug>":{},"<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref":{"T":["header::value::HeaderValue","uri::authority::Authority","uri::scheme::Scheme","<&mut T as std::convert::AsRef<U>>","uri::port::Port","method::Method"]},"uri::port::Port":{"T":["<&T as std::convert::AsRef<U>>","uri::authority::Authority","uri::port::Port","uri::scheme::Scheme","header::value::HeaderValue","method::Method"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::port::Port<T>
+p0.as_ref();
+<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref(p0);
+crate::<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref(p0);
+<uri::port::Port<T>>::as_ref(p0);
-----------------
src/uri/port.rs <uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq
deps:{"<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq":{"T":["std::marker::Sized"],"U":["std::marker::Sized"]}}
candidates:{"<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq":{"T":["RUG_ANY"],"U":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::port::Port<T>
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::port::Port<U>
+p0.eq(p1);
+<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq(p0, p1);
+crate::<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq(p0, p1);
+<uri::port::Port<T>>::eq(p0, p1);
-----------------
src/uri/port.rs <uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq
deps:{"<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq":{"T":["std::marker::Sized"]}}
candidates:{"<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::port::Port<T>
let mut p1 = & 0u16; // None+u16
+p0.eq(p1);
+<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq(p0, p1);
+crate::<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq(p0, p1);
+<uri::port::Port<T>>::eq(p0, p1);
-----------------
src/uri/port.rs uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq
deps:{"uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq":{"T":["std::marker::Sized"]}}
candidates:{"uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq":{"T":["RUG_ANY"]}}
let mut p0 = & 0u16; // None+u16
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::port::Port<T>
+p0.eq(p1);
+uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq(p0, p1);
+crate::uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq(p0, p1);
+<u16>::eq(p0, p1);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
+p0.clone();
+<uri::scheme::Scheme as std::clone::Clone>::clone(p0);
+crate::<uri::scheme::Scheme as std::clone::Clone>::clone(p0);
+<uri::scheme::Scheme>::clone(p0);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme2<T> as std::clone::Clone>::clone
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<uri::scheme::Scheme2<T> as std::clone::Clone>::clone":{"T":["std::clone::Clone","std::marker::Sized"]},"header::map::Bucket":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Send","std::fmt::Debug","std::marker::Sync"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"header::map::HeaderMap":{"T":["std::fmt::Debug","std::convert::TryFrom","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"header::map::IntoIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Iter":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Keys":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::ValueIter":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValueIterMut":{"T":["std::marker::Sync","std::marker::Send","std::fmt::Debug","std::marker::Sized"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::hash::Hash","std::fmt::Debug"]},"request::Request":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"response::Response":{"T":["std::marker::Sized","std::fmt::Debug","std::default::Default"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"uri::port::Port":{"T":["std::fmt::Debug","std::marker::Sized","std::convert::AsRef"]},"uri::scheme::Scheme2":{"T":["std::fmt::Debug","std::marker::Sized","std::clone::Clone"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<uri::scheme::Scheme2<T> as std::clone::Clone>::clone":{"T":["uri::Uri","uri::authority::Authority","header::map::Cursor","header::name::Repr","header::name::MaybeLower","version::Http","header::map::HashValue","byte_str::ByteStr","method::extension::InlineExtension","std::clone::impls::<impl std::clone::Clone for *mut T>","uri::scheme::Scheme","uri::scheme::Protocol","method::extension::AllocatedExtension","header::value::HeaderValue","method::Method","uri::path::PathAndQuery","header::map::Pos","std::clone::impls::<impl std::clone::Clone for &mut T>","uri::scheme::Scheme2","header::map::HeaderMap","header::map::ExtraValue","status::StatusCode","header::name::StandardHeader","version::Version","header::name::HeaderName","header::name::Custom","method::Inner","header::map::Link","header::map::RawLinks","header::map::Danger","header::map::Bucket","header::map::Links"]},"header::map::Bucket":{"T":["header::map::RawLinks","header::name::HeaderName","header::map::Bucket","header::map::HashValue","header::name::Custom","uri::scheme::Scheme","uri::path::PathAndQuery","<*const T as std::fmt::Debug>","header::map::ExtraValue","version::Version","header::name::Repr","status::StatusCode","header::name::StandardHeader","header::map::Cursor","method::Method","uri::scheme::Protocol","header::map::Links","header::name::MaybeLower","byte_str::ByteStr","header::map::HeaderMap","uri::scheme::Scheme2","header::value::HeaderValue","header::map::Link","uri::authority::Authority","uri::Uri"]},"header::map::Drain":{"T":["header::map::ValueIterMut","<*mut T as std::marker::Send>","header::map::Drain","header::map::Iter","header::map::ValueDrain","header::map::IterMut"]},"header::map::Entry":{"T":["header::map::ValueIter","header::name::HeaderName","header::value::HeaderValue","header::map::ExtraValue","request::Builder","header::map::HeaderMap","<*mut T as std::fmt::Debug>","uri::port::Port","uri::Uri","header::map::Drain","header::map::IterMut","uri::path::PathAndQuery","header::value::ToStrError","request::Request","method::Method","header::map::ValueDrain","header::map::Bucket","header::map::RawLinks","header::map::ValueIterMut","header::name::MaybeLower","header::name::Custom","extensions::Extensions","header::map::Values","header::map::OccupiedEntry","response::Builder","header::map::Keys","header::map::IntoIter","header::map::Entry","uri::scheme::Scheme","uri::builder::Builder","header::map::Links","uri::authority::Authority","request::Parts","byte_str::ByteStr","status::InvalidStatusCode","header::map::Link","header::map::GetAll","header::name::InvalidHeaderName","header::map::Cursor","header::map::Iter","uri::InvalidUri","header::name::StandardHeader","status::StatusCode","header::name::HdrName","uri::scheme::Scheme2","header::map::VacantEntry","uri::scheme::Protocol","uri::ErrorKind","uri::Parts","method::InvalidMethod","version::Version","header::map::HashValue","error::Error","response::Parts","header::value::InvalidHeaderValue","header::name::Repr","header::map::ValuesMut","uri::InvalidUriParts","response::Response"]},"header::map::ExtraValue":{"T":["method::Method","status::StatusCode","header::map::HashValue","header::name::StandardHeader","header::map::Link","header::map::HeaderMap","header::map::Bucket","byte_str::ByteStr","uri::Uri","header::name::HeaderName","uri::scheme::Protocol","header::name::Repr","<&T as std::fmt::Debug>","header::name::Custom","uri::authority::Authority","uri::scheme::Scheme2","uri::scheme::Scheme","header::map::Cursor","header::map::Links","header::value::HeaderValue","header::map::RawLinks","header::name::MaybeLower","version::Version","uri::path::PathAndQuery","header::map::ExtraValue"]},"header::map::GetAll":{"T":["header::name::StandardHeader","header::name::Custom","header::map::GetAll","uri::ErrorKind","byte_str::ByteStr","header::name::Repr","header::map::Cursor","header::map::Link","header::map::HashValue","version::Version","header::map::HeaderMap","<*mut T as std::fmt::Debug>"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["uri::InvalidUriParts","header::map::GetAll","header::name::HdrName","header::map::Iter","header::map::ValueIterMut","method::Method","header::map::Link","status::StatusCode","header::value::InvalidHeaderValue","request::Parts","status::InvalidStatusCode","header::name::Repr","header::map::HashValue","header::map::ValueIter","uri::ErrorKind","uri::scheme::Scheme","header::map::VacantEntry","header::map::HeaderMap","uri::port::Port","header::name::Custom","<*const T as std::fmt::Debug>","header::name::MaybeLower","request::Builder","header::value::HeaderValue","header::name::StandardHeader","header::map::IntoIter","header::map::IterMut","header::map::ExtraValue","uri::scheme::Protocol","header::name::InvalidHeaderName","request::Request","response::Response","response::Parts","uri::InvalidUri","header::map::Keys","header::value::ToStrError","header::map::Bucket","header::map::Values","byte_str::ByteStr","extensions::Extensions","header::map::Drain","header::name::HeaderName","header::map::Entry","uri::scheme::Scheme2","uri::Parts","header::map::Cursor","response::Builder","uri::path::PathAndQuery","method::InvalidMethod","uri::authority::Authority","header::map::RawLinks","version::Version","uri::Uri","header::map::ValueDrain","uri::builder::Builder","error::Error","header::map::Links","header::map::OccupiedEntry","header::map::ValuesMut"]},"header::map::Iter":{"T":["header::map::ValueIterMut","header::map::Drain","header::map::IterMut","header::map::ValueDrain","<*mut T as std::fmt::Debug>","header::map::Iter"]},"header::map::IterMut":{"T":["header::map::ValueIterMut","header::map::Drain","<*mut T as std::marker::Send>","header::map::IterMut","header::map::Iter","header::map::ValueDrain"]},"header::map::Keys":{"T":["header::map::IntoIter","header::map::HashValue","uri::scheme::Protocol","header::value::HeaderValue","header::map::IterMut","header::name::StandardHeader","uri::authority::Authority","header::map::ValueIter","header::name::MaybeLower","method::InvalidMethod","header::map::Iter","header::map::GetAll","header::name::HdrName","response::Response","response::Parts","header::map::Drain","uri::scheme::Scheme2","uri::builder::Builder","header::map::HeaderMap","extensions::Extensions","header::name::Repr","header::name::InvalidHeaderName","response::Builder","uri::path::PathAndQuery","header::map::Links","request::Parts","header::map::Values","uri::Parts","header::map::Entry","header::name::Custom","header::map::ExtraValue","method::Method","header::map::Cursor","header::map::Bucket","header::map::ValueDrain","uri::port::Port","header::map::Link","uri::ErrorKind","request::Request","byte_str::ByteStr","header::map::Keys","header::name::HeaderName","header::map::RawLinks","uri::scheme::Scheme","header::value::InvalidHeaderValue","header::value::ToStrError","uri::InvalidUriParts","status::InvalidStatusCode","header::map::ValuesMut","header::map::OccupiedEntry","request::Builder","uri::Uri","status::StatusCode","header::map::VacantEntry","uri::InvalidUri","version::Version","<&T as std::fmt::Debug>","error::Error","header::map::ValueIterMut"]},"header::map::OccupiedEntry":{"T":["uri::InvalidUri","header::value::HeaderValue","header::map::GetAll","uri::scheme::Scheme2","uri::Parts","error::Error","header::map::Link","request::Parts","header::map::ValuesMut","header::map::HashValue","header::map::Keys","uri::builder::Builder","header::map::RawLinks","extensions::Extensions","header::map::ValueIter","uri::ErrorKind","uri::scheme::Protocol","<&T as std::fmt::Debug>","header::map::Entry","header::value::InvalidHeaderValue","header::value::ToStrError","header::map::ValueIterMut","header::name::HdrName","uri::authority::Authority","header::map::Bucket","header::map::IterMut","response::Builder","header::map::HeaderMap","header::map::Cursor","method::InvalidMethod","version::Version","request::Builder","header::name::Custom","header::map::IntoIter","header::map::VacantEntry","header::map::Iter","uri::scheme::Scheme","response::Response","uri::Uri","status::StatusCode","uri::InvalidUriParts","byte_str::ByteStr","response::Parts","header::map::ValueDrain","uri::port::Port","request::Request","header::name::HeaderName","header::map::Drain","header::name::InvalidHeaderName","header::name::MaybeLower","header::map::Values","header::name::Repr","status::InvalidStatusCode","header::map::OccupiedEntry","header::map::Links","header::map::ExtraValue","header::name::StandardHeader","uri::path::PathAndQuery","method::Method"]},"header::map::RawLinks":{"T":["response::Builder","uri::InvalidUriParts","response::Response","error::Error","header::map::Drain","header::map::ValuesMut","header::map::ValueIter","uri::Uri","header::map::Keys","uri::scheme::Scheme","uri::Parts","header::name::HeaderName","header::map::OccupiedEntry","header::map::IntoIter","method::InvalidMethod","header::map::Cursor","header::map::HashValue","request::Parts","extensions::Extensions","header::name::MaybeLower","method::Method","uri::path::PathAndQuery","header::map::ExtraValue","header::map::Bucket","response::Parts","byte_str::ByteStr","header::value::ToStrError","uri::port::Port","header::map::Link","header::name::Repr","request::Builder","header::map::IterMut","header::name::StandardHeader","header::map::VacantEntry","uri::InvalidUri","request::Request","header::map::Entry","header::name::InvalidHeaderName","header::map::Iter","uri::authority::Authority","uri::scheme::Protocol","header::map::ValueDrain","header::name::HdrName","header::map::RawLinks","header::name::Custom","uri::scheme::Scheme2","status::InvalidStatusCode","header::map::ValueIterMut","header::value::InvalidHeaderValue","header::map::Links","uri::ErrorKind","header::value::HeaderValue","<*mut T as std::fmt::Debug>","uri::builder::Builder","status::StatusCode","header::map::GetAll","header::map::HeaderMap","version::Version","header::map::Values"]},"header::map::VacantEntry":{"T":["header::value::ToStrError","request::Parts","header::map::Link","header::name::Repr","response::Response","method::InvalidMethod","header::map::Entry","header::name::StandardHeader","header::map::GetAll","response::Parts","header::map::Bucket","uri::Parts","header::value::InvalidHeaderValue","header::map::ValueIter","uri::scheme::Scheme2","header::map::RawLinks","header::name::MaybeLower","uri::path::PathAndQuery","error::Error","header::map::Cursor","request::Builder","header::map::HashValue","uri::port::Port","header::map::HeaderMap","uri::builder::Builder","header::map::OccupiedEntry","header::map::Values","request::Request","uri::scheme::Protocol","uri::ErrorKind","header::map::ValueIterMut","header::map::Links","uri::Uri","header::name::InvalidHeaderName","header::map::ValuesMut","header::map::IterMut","version::Version","response::Builder","header::name::HeaderName","header::map::Keys","header::map::Iter","header::map::ExtraValue","header::map::ValueDrain","header::name::Custom","<&T as std::fmt::Debug>","header::map::Drain","method::Method","uri::authority::Authority","uri::InvalidUriParts","uri::InvalidUri","header::name::HdrName","byte_str::ByteStr","extensions::Extensions","status::StatusCode","header::map::IntoIter","header::value::HeaderValue","header::map::VacantEntry","uri::scheme::Scheme","status::InvalidStatusCode"]},"header::map::ValueDrain":{"T":["header::map::ValueDrain","header::map::IterMut","header::map::ValueIterMut","<*const T as std::fmt::Debug>","header::map::Drain","header::map::Iter"]},"header::map::ValueIter":{"T":["header::map::ValuesMut","uri::builder::Builder","header::map::Cursor","response::Response","header::name::StandardHeader","header::name::Custom","header::map::GetAll","header::map::Drain","header::map::IterMut","uri::Parts","header::map::VacantEntry","uri::ErrorKind","header::value::InvalidHeaderValue","byte_str::ByteStr","request::Parts","header::map::Values","error::Error","version::Version","status::InvalidStatusCode","header::map::HashValue","header::name::HeaderName","uri::Uri","header::map::Bucket","response::Parts","<&T as std::fmt::Debug>","header::map::ValueDrain","header::map::HeaderMap","request::Builder","uri::port::Port","uri::authority::Authority","extensions::Extensions","uri::scheme::Protocol","header::name::MaybeLower","status::StatusCode","uri::InvalidUriParts","request::Request","header::map::OccupiedEntry","header::map::RawLinks","header::value::HeaderValue","header::map::IntoIter","uri::InvalidUri","header::map::ValueIter","header::name::Repr","response::Builder","header::map::Entry","method::Method","header::map::ValueIterMut","uri::scheme::Scheme","header::map::Keys","header::map::Links","uri::path::PathAndQuery","header::value::ToStrError","header::map::Link","header::name::InvalidHeaderName","header::map::Iter","method::InvalidMethod","header::name::HdrName","uri::scheme::Scheme2","header::map::ExtraValue"]},"header::map::ValueIterMut":{"T":["header::map::ValueDrain","<*mut T as std::marker::Send>","header::map::Iter","header::map::ValueIterMut","header::map::Drain","header::map::IterMut"]},"header::map::Values":{"T":["header::map::VacantEntry","header::name::Repr","header::value::InvalidHeaderValue","uri::scheme::Protocol","header::map::IntoIter","uri::Parts","header::value::HeaderValue","header::name::HeaderName","request::Builder","header::value::ToStrError","request::Parts","error::Error","uri::ErrorKind","header::map::Values","uri::scheme::Scheme","status::InvalidStatusCode","byte_str::ByteStr","method::Method","header::map::Cursor","status::StatusCode","header::map::Links","uri::port::Port","header::map::Entry","uri::builder::Builder","version::Version","uri::InvalidUri","uri::path::PathAndQuery","header::name::Custom","header::name::HdrName","header::map::RawLinks","header::map::ExtraValue","header::map::GetAll","header::map::Iter","header::map::Link","header::map::HeaderMap","response::Response","response::Builder","header::map::OccupiedEntry","header::map::Bucket","header::name::StandardHeader","uri::authority::Authority","request::Request","header::map::Drain","response::Parts","uri::Uri","header::name::InvalidHeaderName","header::name::MaybeLower","header::map::IterMut","method::InvalidMethod","extensions::Extensions","<*const T as std::fmt::Debug>","header::map::ValueDrain","uri::scheme::Scheme2","uri::InvalidUriParts","header::map::Keys","header::map::ValueIter","header::map::ValueIterMut","header::map::HashValue","header::map::ValuesMut"]},"header::map::ValuesMut":{"T":["header::map::Keys","<&T as std::fmt::Debug>","header::map::IntoIter","header::map::Cursor","uri::scheme::Protocol","header::map::Bucket","method::Method","header::map::Link","response::Builder","header::map::GetAll","uri::scheme::Scheme","header::map::ExtraValue","version::Version","header::map::Entry","header::name::Repr","uri::Parts","header::name::InvalidHeaderName","error::Error","uri::port::Port","uri::authority::Authority","header::map::RawLinks","header::map::OccupiedEntry","uri::ErrorKind","uri::InvalidUriParts","uri::scheme::Scheme2","byte_str::ByteStr","header::map::Links","header::map::Values","response::Response","header::map::VacantEntry","header::name::MaybeLower","response::Parts","uri::Uri","header::map::ValueIterMut","header::value::ToStrError","request::Builder","request::Parts","header::map::IterMut","header::value::InvalidHeaderValue","header::name::HdrName","status::InvalidStatusCode","header::map::ValueIter","header::name::Custom","header::value::HeaderValue","uri::path::PathAndQuery","header::map::ValueDrain","request::Request","header::name::StandardHeader","header::map::ValuesMut","header::map::Iter","method::InvalidMethod","uri::InvalidUri","header::map::HashValue","header::name::HeaderName","header::map::Drain","status::StatusCode","uri::builder::Builder","extensions::Extensions","header::map::HeaderMap"]},"header::name::Repr":{"T":["version::Version","header::name::Repr","byte_str::ByteStr","<*const T as std::fmt::Debug>","header::name::StandardHeader","header::name::Custom"]},"request::Request":{"T":["version::Version","response::Builder","extensions::Extensions","request::Request","status::StatusCode","uri::Uri","method::Method","uri::builder::Builder","header::map::HeaderMap","request::Builder","response::Response","uri::Parts"]},"response::Response":{"T":["method::Method","response::Response","uri::Uri","status::StatusCode","request::Request","uri::builder::Builder","extensions::Extensions","request::Builder","response::Builder","uri::Parts","header::map::HeaderMap","version::Version"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"uri::port::Port":{"T":["uri::port::Port","uri::scheme::Scheme","<&T as std::fmt::Debug>","header::value::HeaderValue","method::Method","uri::authority::Authority"]},"uri::scheme::Scheme2":{"T":["header::value::HeaderValue","header::map::Cursor","header::map::Link","status::StatusCode","uri::path::PathAndQuery","method::Method","header::map::HeaderMap","header::name::HeaderName","uri::authority::Authority","header::name::StandardHeader","header::map::Bucket","uri::scheme::Protocol","std::clone::impls::<impl std::clone::Clone for &mut T>","uri::scheme::Scheme2","header::map::Links","byte_str::ByteStr","uri::scheme::Scheme","uri::Uri","header::map::ExtraValue","header::map::HashValue","header::name::Repr","std::boxed::Box<byte_str::ByteStr>","header::map::RawLinks","version::Version","header::name::Custom","header::name::MaybeLower"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme2<T>
+p0.clone();
+<uri::scheme::Scheme2<T> as std::clone::Clone>::clone(p0);
+crate::<uri::scheme::Scheme2<T> as std::clone::Clone>::clone(p0);
+<uri::scheme::Scheme2<T>>::clone(p0);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme2<T> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<uri::scheme::Scheme2<T> as std::fmt::Debug>::fmt":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::Bucket":{"T":["std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Send","std::marker::Sized"]},"header::map::Entry":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ExtraValue":{"T":["std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"header::map::GetAll":{"T":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"header::map::HeaderMap":{"T":["std::cmp::Eq","std::convert::TryFrom","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"header::map::IntoIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::IterMut":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::Keys":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::OccupiedEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::RawLinks":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::VacantEntry":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Sync","std::marker::Send","std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIter":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Send","std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::Values":{"T":["std::fmt::Debug","std::marker::Sized"]},"header::map::ValuesMut":{"T":["std::marker::Sized","std::fmt::Debug"]},"header::name::Repr":{"T":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::hash::Hash"]},"request::Request":{"T":["std::fmt::Debug","std::marker::Sized","std::default::Default"]},"response::Response":{"T":["std::marker::Sized","std::default::Default","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["std::marker::Sized","std::convert::AsRef","std::fmt::Debug"]},"uri::scheme::Scheme2":{"T":["std::marker::Sized","std::clone::Clone","std::fmt::Debug"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"<uri::scheme::Scheme2<T> as std::fmt::Debug>::fmt":{"T":["header::name::Repr","uri::InvalidUri","uri::scheme::Protocol","uri::port::Port","header::map::HeaderMap","header::map::Values","uri::scheme::Scheme","method::InvalidMethod","request::Builder","response::Builder","header::map::Entry","version::Version","header::map::IntoIter","request::Parts","response::Parts","header::map::GetAll","<&mut T as std::fmt::Debug>","header::map::Bucket","header::map::IterMut","uri::ErrorKind","header::map::Iter","response::Response","header::name::InvalidHeaderName","header::map::ValueIterMut","header::map::Keys","header::value::ToStrError","status::StatusCode","header::map::HashValue","header::map::Cursor","<*mut T as std::fmt::Debug>","header::value::HeaderValue","uri::scheme::Scheme2","status::InvalidStatusCode","method::Method","header::name::StandardHeader","byte_str::ByteStr","uri::Parts","header::map::ExtraValue","uri::path::PathAndQuery","header::name::Custom","request::Request","header::map::RawLinks","header::map::ValueIter","header::map::ValueDrain","uri::Uri","header::name::MaybeLower","uri::InvalidUriParts","header::map::OccupiedEntry","header::name::HeaderName","header::value::InvalidHeaderValue","uri::authority::Authority","uri::builder::Builder","header::map::Links","extensions::Extensions","header::name::HdrName","error::Error","header::map::Link","header::map::ValuesMut","header::map::Drain","header::map::VacantEntry"]},"header::map::Bucket":{"T":["uri::authority::Authority","header::map::Links","method::Method","byte_str::ByteStr","uri::Uri","header::name::Custom","header::name::MaybeLower","header::name::Repr","header::name::StandardHeader","header::map::Link","header::map::HeaderMap","header::map::HashValue","uri::scheme::Scheme2","std::clone::impls::<impl std::clone::Clone for *mut T>","uri::scheme::Scheme","version::Version","uri::path::PathAndQuery","header::map::ExtraValue","header::map::Bucket","header::map::Cursor","header::name::HeaderName","uri::scheme::Protocol","status::StatusCode","header::map::RawLinks","header::value::HeaderValue"]},"header::map::Drain":{"T":["header::map::Drain","header::map::Iter","header::map::ValueDrain","header::map::ValueIterMut","header::map::IterMut","<*const T as std::marker::Sync>"]},"header::map::Entry":{"T":["header::map::OccupiedEntry","<&mut T as std::fmt::Debug>","header::value::HeaderValue","response::Response","header::map::ValuesMut","error::Error","header::name::HeaderName","status::StatusCode","header::map::RawLinks","header::value::InvalidHeaderValue","response::Parts","header::map::ValueIter","uri::builder::Builder","header::map::ExtraValue","header::map::ValueIterMut","uri::authority::Authority","request::Builder","header::map::VacantEntry","byte_str::ByteStr","header::name::InvalidHeaderName","header::map::Drain","response::Builder","header::map::HeaderMap","uri::scheme::Protocol","header::name::Repr","request::Request","uri::scheme::Scheme","request::Parts","header::map::IterMut","uri::InvalidUri","uri::Uri","version::Version","header::map::Entry","uri::ErrorKind","header::map::Links","header::map::Iter","header::name::MaybeLower","header::map::Values","uri::scheme::Scheme2","header::map::HashValue","header::map::Cursor","header::map::ValueDrain","header::name::Custom","uri::path::PathAndQuery","header::name::HdrName","uri::port::Port","extensions::Extensions","header::map::GetAll","header::map::Link","header::map::Keys","method::InvalidMethod","header::value::ToStrError","status::InvalidStatusCode","header::map::Bucket","uri::Parts","uri::InvalidUriParts","header::name::StandardHeader","header::map::IntoIter","method::Method"]},"header::map::ExtraValue":{"T":["header::map::HeaderMap","header::map::HashValue","<*const T as std::fmt::Debug>","header::map::Link","uri::path::PathAndQuery","header::map::Bucket","header::name::MaybeLower","header::map::Links","header::value::HeaderValue","uri::authority::Authority","header::map::RawLinks","uri::Uri","header::map::Cursor","status::StatusCode","uri::scheme::Scheme","header::name::Repr","header::map::ExtraValue","header::name::StandardHeader","uri::scheme::Protocol","uri::scheme::Scheme2","byte_str::ByteStr","header::name::Custom","version::Version","method::Method","header::name::HeaderName"]},"header::map::GetAll":{"T":["header::map::HashValue","header::map::Link","header::map::Cursor","header::map::GetAll","header::name::Custom","header::name::Repr","uri::ErrorKind","header::name::StandardHeader","std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>","version::Version","byte_str::ByteStr","header::map::HeaderMap"]},"header::map::HeaderMap":{"T":["header::map::HeaderMap","header::value::HeaderValue"]},"header::map::IntoIter":{"T":["header::map::IntoIter","response::Response","byte_str::ByteStr","uri::scheme::Scheme2","header::name::HdrName","response::Builder","method::InvalidMethod","uri::InvalidUri","uri::Parts","request::Builder","header::map::ExtraValue","uri::scheme::Scheme","header::name::Repr","uri::ErrorKind","header::map::Bucket","error::Error","status::InvalidStatusCode","header::map::ValueIter","extensions::Extensions","header::value::ToStrError","header::name::MaybeLower","uri::path::PathAndQuery","header::map::ValueDrain","header::value::HeaderValue","header::map::ValueIterMut","uri::authority::Authority","uri::scheme::Protocol","uri::Uri","header::map::Link","header::name::StandardHeader","header::map::VacantEntry","header::map::Links","header::map::HashValue","response::Parts","header::map::Keys","request::Parts","request::Request","header::map::RawLinks","header::name::HeaderName","header::map::ValuesMut","header::map::Drain","method::Method","header::map::HeaderMap","header::map::GetAll","header::name::Custom","uri::InvalidUriParts","status::StatusCode","header::map::Entry","header::name::InvalidHeaderName","uri::builder::Builder","header::value::InvalidHeaderValue","uri::port::Port","<&T as std::fmt::Debug>","header::map::Iter","header::map::Values","header::map::Cursor","header::map::IterMut","version::Version","header::map::OccupiedEntry"]},"header::map::Iter":{"T":["header::map::Iter","header::map::ValueIterMut","header::map::IterMut","header::map::ValueDrain","<*mut T as std::marker::Sync>","header::map::Drain"]},"header::map::IterMut":{"T":["header::map::ValueIterMut","header::map::Drain","header::map::Iter","header::map::IterMut","<*const T as std::fmt::Debug>","header::map::ValueDrain"]},"header::map::Keys":{"T":["error::Error","header::map::Keys","header::map::Bucket","status::StatusCode","header::value::InvalidHeaderValue","byte_str::ByteStr","header::map::HashValue","uri::port::Port","header::name::HeaderName","header::map::ValueIterMut","uri::scheme::Scheme","<&mut T as std::fmt::Debug>","extensions::Extensions","response::Builder","uri::authority::Authority","method::Method","header::map::Cursor","uri::scheme::Scheme2","header::name::StandardHeader","uri::builder::Builder","header::name::InvalidHeaderName","method::InvalidMethod","status::InvalidStatusCode","header::name::Custom","header::value::HeaderValue","header::map::OccupiedEntry","uri::Uri","header::map::IntoIter","header::map::VacantEntry","header::map::Link","header::map::ExtraValue","header::value::ToStrError","header::map::HeaderMap","request::Parts","uri::scheme::Protocol","response::Parts","uri::ErrorKind","request::Request","uri::Parts","header::map::RawLinks","header::map::IterMut","header::name::MaybeLower","request::Builder","uri::InvalidUri","uri::path::PathAndQuery","header::map::Entry","header::map::ValuesMut","header::map::Links","header::name::HdrName","version::Version","header::map::ValueDrain","header::map::Drain","uri::InvalidUriParts","header::map::GetAll","header::name::Repr","response::Response","header::map::Iter","header::map::Values","header::map::ValueIter"]},"header::map::OccupiedEntry":{"T":["header::value::ToStrError","extensions::Extensions","uri::path::PathAndQuery","status::InvalidStatusCode","response::Builder","uri::Parts","request::Request","error::Error","header::name::Custom","header::value::InvalidHeaderValue","header::map::IterMut","uri::scheme::Scheme","header::map::HashValue","method::Method","response::Parts","header::map::OccupiedEntry","uri::ErrorKind","header::name::Repr","header::map::Links","header::map::GetAll","header::map::Keys","header::map::ExtraValue","header::map::ValueDrain","version::Version","uri::Uri","header::map::ValueIter","header::map::VacantEntry","uri::InvalidUri","request::Builder","header::map::IntoIter","uri::builder::Builder","header::map::Drain","header::map::Bucket","header::map::RawLinks","header::map::Values","uri::InvalidUriParts","header::map::Cursor","header::name::HeaderName","header::value::HeaderValue","method::InvalidMethod","header::map::Link","request::Parts","header::map::ValueIterMut","uri::authority::Authority","header::map::HeaderMap","uri::scheme::Protocol","uri::port::Port","header::name::InvalidHeaderName","header::name::StandardHeader","header::name::HdrName","uri::scheme::Scheme2","byte_str::ByteStr","status::StatusCode","response::Response","<&mut T as std::fmt::Debug>","header::map::Iter","header::name::MaybeLower","header::map::Entry","header::map::ValuesMut"]},"header::map::RawLinks":{"T":["version::Version","header::map::Cursor","header::name::Repr","header::map::HashValue","header::map::IterMut","header::value::HeaderValue","uri::Parts","request::Builder","header::map::Values","uri::scheme::Scheme2","header::name::InvalidHeaderName","header::map::Link","header::map::ValueIterMut","header::map::ValueIter","response::Response","header::map::ExtraValue","header::name::HeaderName","header::map::Iter","header::map::Links","<*mut T as std::fmt::Debug>","extensions::Extensions","header::name::MaybeLower","header::value::ToStrError","byte_str::ByteStr","header::map::Keys","header::map::Drain","header::map::ValuesMut","uri::ErrorKind","header::value::InvalidHeaderValue","uri::authority::Authority","uri::InvalidUri","header::map::IntoIter","header::map::HeaderMap","header::map::Entry","uri::InvalidUriParts","request::Parts","uri::scheme::Protocol","request::Request","header::name::Custom","header::map::OccupiedEntry","header::name::HdrName","uri::scheme::Scheme","response::Parts","header::map::Bucket","method::Method","status::InvalidStatusCode","uri::builder::Builder","response::Builder","header::name::StandardHeader","method::InvalidMethod","error::Error","header::map::ValueDrain","header::map::VacantEntry","status::StatusCode","uri::Uri","header::map::GetAll","uri::path::PathAndQuery","uri::port::Port","header::map::RawLinks"]},"header::map::VacantEntry":{"T":["header::map::IterMut","uri::builder::Builder","method::Method","uri::authority::Authority","header::map::ValueIter","uri::scheme::Protocol","header::name::StandardHeader","uri::scheme::Scheme2","request::Parts","request::Request","header::map::Links","uri::Parts","header::map::Iter","header::map::ExtraValue","uri::port::Port","header::name::HeaderName","uri::InvalidUri","response::Response","header::map::ValueIterMut","header::map::RawLinks","uri::Uri","header::map::GetAll","header::name::MaybeLower","status::InvalidStatusCode","header::map::Values","response::Parts","header::name::Repr","version::Version","header::value::InvalidHeaderValue","uri::InvalidUriParts","header::value::HeaderValue","uri::ErrorKind","header::value::ToStrError","extensions::Extensions","header::map::VacantEntry","byte_str::ByteStr","header::map::IntoIter","error::Error","header::map::Bucket","method::InvalidMethod","header::map::ValuesMut","response::Builder","header::map::Link","<*mut T as std::fmt::Debug>","uri::path::PathAndQuery","request::Builder","header::map::HeaderMap","header::name::HdrName","header::name::Custom","header::map::HashValue","header::map::Entry","uri::scheme::Scheme","header::map::OccupiedEntry","status::StatusCode","header::map::ValueDrain","header::map::Drain","header::map::Keys","header::name::InvalidHeaderName","header::map::Cursor"]},"header::map::ValueDrain":{"T":["header::map::ValueIterMut","header::map::ValueDrain","header::map::IterMut","header::map::Drain","<*const T as std::marker::Send>","header::map::Iter"]},"header::map::ValueIter":{"T":["request::Parts","header::map::Bucket","response::Builder","uri::Parts","byte_str::ByteStr","header::map::GetAll","header::name::HdrName","header::name::HeaderName","header::value::HeaderValue","header::map::ExtraValue","header::map::ValuesMut","header::map::VacantEntry","header::map::Links","status::StatusCode","request::Builder","header::map::ValueIterMut","header::map::Values","<&mut T as std::fmt::Debug>","header::name::InvalidHeaderName","header::map::ValueDrain","request::Request","header::name::Repr","version::Version","header::map::IntoIter","method::InvalidMethod","header::name::MaybeLower","header::map::Entry","error::Error","header::map::RawLinks","header::name::StandardHeader","header::value::ToStrError","uri::InvalidUri","header::map::IterMut","extensions::Extensions","response::Response","header::map::Drain","uri::InvalidUriParts","uri::port::Port","status::InvalidStatusCode","header::map::Keys","uri::ErrorKind","header::name::Custom","uri::scheme::Scheme2","header::map::HashValue","header::map::HeaderMap","header::map::Cursor","uri::Uri","header::map::ValueIter","header::map::OccupiedEntry","method::Method","uri::scheme::Protocol","uri::authority::Authority","uri::scheme::Scheme","header::map::Link","response::Parts","uri::path::PathAndQuery","uri::builder::Builder","header::value::InvalidHeaderValue","header::map::Iter"]},"header::map::ValueIterMut":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::Drain","header::map::Iter","header::map::ValueDrain","<*const T as std::marker::Send>"]},"header::map::Values":{"T":["uri::builder::Builder","header::map::VacantEntry","header::map::ExtraValue","uri::InvalidUri","header::map::ValueDrain","header::name::HdrName","header::map::Drain","header::map::GetAll","header::map::Bucket","uri::port::Port","response::Builder","header::name::InvalidHeaderName","uri::InvalidUriParts","header::map::RawLinks","header::map::Iter","extensions::Extensions","header::name::StandardHeader","status::StatusCode","header::map::IterMut","header::map::Entry","header::map::Values","header::name::Custom","header::name::MaybeLower","header::map::Cursor","header::map::HeaderMap","header::map::Keys","request::Parts","<*const T as std::fmt::Debug>","uri::Parts","uri::ErrorKind","error::Error","header::map::Links","uri::Uri","header::value::ToStrError","header::map::ValueIterMut","header::name::Repr","header::map::OccupiedEntry","request::Builder","response::Response","header::value::InvalidHeaderValue","header::name::HeaderName","header::map::ValuesMut","uri::scheme::Scheme","header::map::ValueIter","response::Parts","method::InvalidMethod","status::InvalidStatusCode","header::map::HashValue","request::Request","uri::scheme::Protocol","byte_str::ByteStr","version::Version","uri::scheme::Scheme2","uri::path::PathAndQuery","header::value::HeaderValue","uri::authority::Authority","method::Method","header::map::Link","header::map::IntoIter"]},"header::map::ValuesMut":{"T":["header::map::VacantEntry","header::map::RawLinks","header::map::ValueDrain","uri::Parts","header::map::ValuesMut","uri::scheme::Protocol","uri::Uri","method::Method","uri::builder::Builder","header::map::Drain","request::Request","header::map::Values","header::value::InvalidHeaderValue","header::map::Bucket","uri::InvalidUri","method::InvalidMethod","request::Builder","header::map::HeaderMap","header::map::Iter","header::value::HeaderValue","uri::scheme::Scheme","response::Parts","uri::port::Port","header::map::IntoIter","header::map::ValueIter","header::map::Link","header::value::ToStrError","request::Parts","header::name::HdrName","header::map::OccupiedEntry","response::Response","header::name::StandardHeader","status::InvalidStatusCode","header::map::HashValue","header::name::InvalidHeaderName","uri::InvalidUriParts","header::map::ExtraValue","extensions::Extensions","header::map::GetAll","byte_str::ByteStr","version::Version","uri::scheme::Scheme2","header::map::Links","response::Builder","header::name::HeaderName","header::name::Repr","status::StatusCode","uri::path::PathAndQuery","header::map::Entry","header::map::ValueIterMut","<&T as std::fmt::Debug>","header::map::IterMut","error::Error","header::name::Custom","header::map::Keys","header::map::Cursor","uri::ErrorKind","uri::authority::Authority","header::name::MaybeLower"]},"header::name::Repr":{"T":["version::Version","header::name::StandardHeader","byte_str::ByteStr","header::name::Custom","header::name::Repr","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"request::Request":{"T":["response::Response","version::Version","request::Builder","uri::Parts","response::Builder","status::StatusCode","header::map::HeaderMap","extensions::Extensions","method::Method","uri::builder::Builder","uri::Uri","request::Request"]},"response::Response":{"T":["uri::Parts","response::Builder","extensions::Extensions","uri::Uri","method::Method","response::Response","status::StatusCode","uri::builder::Builder","request::Request","header::map::HeaderMap","version::Version","request::Builder"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"uri::port::Port":{"T":["header::value::HeaderValue","method::Method","uri::scheme::Scheme","uri::authority::Authority","<&T as std::fmt::Debug>","uri::port::Port"]},"uri::scheme::Scheme2":{"T":["uri::path::PathAndQuery","header::value::HeaderValue","header::name::HeaderName","header::name::StandardHeader","<&T as std::fmt::Debug>","header::name::Custom","header::map::Cursor","header::map::RawLinks","header::map::Links","header::map::ExtraValue","byte_str::ByteStr","header::map::Bucket","uri::scheme::Protocol","status::StatusCode","uri::scheme::Scheme","header::name::Repr","method::Method","uri::authority::Authority","version::Version","uri::Uri","header::map::HashValue","header::map::Link","header::map::HeaderMap","header::name::MaybeLower","std::boxed::Box<byte_str::ByteStr>","uri::scheme::Scheme2"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme2<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::scheme::Scheme2<T> as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::scheme::Scheme2<T> as std::fmt::Debug>::fmt(p0, p1);
+<uri::scheme::Scheme2<T>>::fmt(p0, p1);
-----------------
src/uri/scheme.rs <uri::scheme::Protocol as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Protocol
+p0.clone();
+<uri::scheme::Protocol as std::clone::Clone>::clone(p0);
+crate::<uri::scheme::Protocol as std::clone::Clone>::clone(p0);
+<uri::scheme::Protocol>::clone(p0);
-----------------
src/uri/scheme.rs <uri::scheme::Protocol as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Protocol
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::scheme::Protocol as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::scheme::Protocol as std::fmt::Debug>::fmt(p0, p1);
+<uri::scheme::Protocol>::fmt(p0, p1);
-----------------
src/uri/scheme.rs uri::scheme::Scheme::empty
deps:{}
candidates:{}
+uri::scheme::Scheme::empty();
+crate::uri::scheme::Scheme::empty();
+<uri::scheme::Scheme>::empty();
-----------------
src/uri/scheme.rs uri::scheme::Scheme::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
+p0.as_str();
+uri::scheme::Scheme::as_str(p0);
+crate::uri::scheme::Scheme::as_str(p0);
+<uri::scheme::Scheme>::as_str(p0);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::convert::TryFrom<&'a [u8]>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<uri::scheme::Scheme as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+crate::<uri::scheme::Scheme as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+<uri::scheme::Scheme>::try_from(p0);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::convert::TryFrom<&'a str>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<uri::scheme::Scheme as std::convert::TryFrom<&'a str>>::try_from(&p0);
+crate::<uri::scheme::Scheme as std::convert::TryFrom<&'a str>>::try_from(&p0);
+<uri::scheme::Scheme>::try_from(&p0);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<uri::scheme::Scheme as std::str::FromStr>::from_str(&p0);
+crate::<uri::scheme::Scheme as std::str::FromStr>::from_str(&p0);
+<uri::scheme::Scheme>::from_str(&p0);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::scheme::Scheme as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::scheme::Scheme as std::fmt::Debug>::fmt(p0, p1);
+<uri::scheme::Scheme>::fmt(p0, p1);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<uri::scheme::Scheme as std::fmt::Display>::fmt(p0, p1);
+crate::<uri::scheme::Scheme as std::fmt::Display>::fmt(p0, p1);
+<uri::scheme::Scheme>::fmt(p0, p1);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
+p0.as_ref();
+<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref(p0);
+crate::<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref(p0);
+<uri::scheme::Scheme>::as_ref(p0);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
+p0.eq(p1);
+<uri::scheme::Scheme as std::cmp::PartialEq>::eq(p0, p1);
+crate::<uri::scheme::Scheme as std::cmp::PartialEq>::eq(p0, p1);
+<uri::scheme::Scheme>::eq(p0, p1);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<uri::scheme::Scheme>::eq(p0, &p1);
-----------------
src/uri/scheme.rs uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
+p0.eq(p1);
+uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq(&p0, p1);
+crate::uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq(&p0, p1);
+<str>::eq(&p0, p1);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<uri::scheme::Scheme as std::hash::Hash>::hash":{"H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<uri::scheme::Scheme as std::hash::Hash>::hash":{"H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<uri::scheme::Scheme as std::hash::Hash>::hash(p0, p1);
+crate::<uri::scheme::Scheme as std::hash::Hash>::hash(p0, p1);
+<uri::scheme::Scheme>::hash(p0, p1);
-----------------
src/uri/scheme.rs uri::scheme::Scheme2::<T>::is_none
deps:{"uri::scheme::Scheme2::<T>::is_none":{"T":["std::marker::Sized"]}}
candidates:{"uri::scheme::Scheme2::<T>::is_none":{"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme2<T>
+p0.is_none();
+uri::scheme::Scheme2::<T>::is_none(p0);
+crate::uri::scheme::Scheme2::<T>::is_none(p0);
+<uri::scheme::Scheme2<T>>::is_none(p0);
-----------------
src/uri/scheme.rs uri::scheme::Scheme2::<usize>::parse_exact
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+uri::scheme::Scheme2::<usize>::parse_exact(p0);
+crate::uri::scheme::Scheme2::<usize>::parse_exact(p0);
+<uri::scheme::Scheme2<usize>>::parse_exact(p0);
-----------------
src/uri/scheme.rs uri::scheme::Scheme2::<usize>::parse
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+uri::scheme::Scheme2::<usize>::parse(p0);
+crate::uri::scheme::Scheme2::<usize>::parse(p0);
+<uri::scheme::Scheme2<usize>>::parse(p0);
-----------------
src/uri/scheme.rs uri::scheme::Protocol::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::scheme::Protocol
+p0.len();
+uri::scheme::Protocol::len(p0);
+crate::uri::scheme::Protocol::len(p0);
+<uri::scheme::Protocol>::len(p0);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from
deps:{"<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from":{"T":["std::marker::Sized"]}}
candidates:{"<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from":{"T":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::scheme::Protocol
+<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from(p0);
+crate::<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from(p0);
+<uri::scheme::Scheme2<T>>::from(p0);
-----------------
src/uri/scheme.rs <uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::scheme::Scheme2
+<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from(p0);
+crate::<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from(p0);
+<uri::scheme::Scheme>::from(p0);
-----------------
src/uri/mod.rs <uri::Uri as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.clone();
+<uri::Uri as std::clone::Clone>::clone(p0);
+crate::<uri::Uri as std::clone::Clone>::clone(p0);
+<uri::Uri>::clone(p0);
-----------------
src/uri/mod.rs <uri::Parts as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Parts
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::Parts as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::Parts as std::fmt::Debug>::fmt(p0, p1);
+<uri::Parts>::fmt(p0, p1);
-----------------
src/uri/mod.rs <uri::Parts as std::default::Default>::default
deps:{}
candidates:{}
+<uri::Parts as std::default::Default>::default();
+crate::<uri::Parts as std::default::Default>::default();
+<uri::Parts>::default();
-----------------
src/uri/mod.rs <uri::InvalidUri as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::InvalidUri
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::InvalidUri as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::InvalidUri as std::fmt::Debug>::fmt(p0, p1);
+<uri::InvalidUri>::fmt(p0, p1);
-----------------
src/uri/mod.rs <uri::InvalidUriParts as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::InvalidUriParts
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::InvalidUriParts as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::InvalidUriParts as std::fmt::Debug>::fmt(p0, p1);
+<uri::InvalidUriParts>::fmt(p0, p1);
-----------------
src/uri/mod.rs <uri::ErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<uri::ErrorKind>::fmt(p0, p1);
-----------------
src/uri/mod.rs <uri::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::ErrorKind
+p0.assert_receiver_is_total_eq();
+<uri::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<uri::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<uri::ErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
src/uri/mod.rs <uri::ErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::ErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::ErrorKind
+p0.eq(p1);
+<uri::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<uri::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<uri::ErrorKind>::eq(p0, p1);
-----------------
src/uri/mod.rs uri::Uri::builder
deps:{}
candidates:{}
+uri::Uri::builder();
+crate::uri::Uri::builder();
+<uri::Uri>::builder();
-----------------
src/uri/mod.rs uri::Uri::from_parts
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::Parts
+uri::Uri::from_parts(p0);
+crate::uri::Uri::from_parts(p0);
+<uri::Uri>::from_parts(p0);
-----------------
src/uri/mod.rs uri::Uri::from_maybe_shared
deps:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"uri::Uri::from_maybe_shared":{"T":["std::marker::Sized","std::convert::AsRef"]},"uri::port::Port":{"T":["std::fmt::Debug","std::marker::Sized","std::convert::AsRef"]}}
candidates:{"<&T as std::convert::AsRef<U>>":{},"<&mut T as std::convert::AsRef<U>>":{},"uri::Uri::from_maybe_shared":{"T":["header::value::HeaderValue","<&mut T as std::convert::AsRef<U>>","uri::authority::Authority","uri::scheme::Scheme","uri::port::Port","<&T as std::convert::AsRef<U>>","method::Method"]},"uri::port::Port":{"T":["uri::port::Port","<&mut T as std::convert::AsRef<U>>","uri::authority::Authority","uri::scheme::Scheme","method::Method","header::value::HeaderValue"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+uri::Uri::from_maybe_shared(p0);
+crate::uri::Uri::from_maybe_shared(p0);
+<uri::Uri>::from_maybe_shared(p0);
-----------------
src/uri/mod.rs uri::Uri::from_shared
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // bytes::Bytes
+uri::Uri::from_shared(p0);
+crate::uri::Uri::from_shared(p0);
+<uri::Uri>::from_shared(p0);
-----------------
src/uri/mod.rs uri::Uri::from_static
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+uri::Uri::from_static(&p0);
+crate::uri::Uri::from_static(&p0);
+<uri::Uri>::from_static(&p0);
-----------------
src/uri/mod.rs uri::Uri::into_parts
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.into_parts();
+uri::Uri::into_parts(p0);
+crate::uri::Uri::into_parts(p0);
+<uri::Uri>::into_parts(p0);
-----------------
src/uri/mod.rs uri::Uri::path_and_query
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.path_and_query();
+uri::Uri::path_and_query(p0);
+crate::uri::Uri::path_and_query(p0);
+<uri::Uri>::path_and_query(p0);
-----------------
src/uri/mod.rs uri::Uri::path
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.path();
+uri::Uri::path(p0);
+crate::uri::Uri::path(p0);
+<uri::Uri>::path(p0);
-----------------
src/uri/mod.rs uri::Uri::scheme
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.scheme();
+uri::Uri::scheme(p0);
+crate::uri::Uri::scheme(p0);
+<uri::Uri>::scheme(p0);
-----------------
src/uri/mod.rs uri::Uri::scheme_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.scheme_str();
+uri::Uri::scheme_str(p0);
+crate::uri::Uri::scheme_str(p0);
+<uri::Uri>::scheme_str(p0);
-----------------
src/uri/mod.rs uri::Uri::authority
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.authority();
+uri::Uri::authority(p0);
+crate::uri::Uri::authority(p0);
+<uri::Uri>::authority(p0);
-----------------
src/uri/mod.rs uri::Uri::host
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.host();
+uri::Uri::host(p0);
+crate::uri::Uri::host(p0);
+<uri::Uri>::host(p0);
-----------------
src/uri/mod.rs uri::Uri::port
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.port();
+uri::Uri::port(p0);
+crate::uri::Uri::port(p0);
+<uri::Uri>::port(p0);
-----------------
src/uri/mod.rs uri::Uri::port_u16
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.port_u16();
+uri::Uri::port_u16(p0);
+crate::uri::Uri::port_u16(p0);
+<uri::Uri>::port_u16(p0);
-----------------
src/uri/mod.rs uri::Uri::query
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.query();
+uri::Uri::query(p0);
+crate::uri::Uri::query(p0);
+<uri::Uri>::query(p0);
-----------------
src/uri/mod.rs uri::Uri::has_path
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.has_path();
+uri::Uri::has_path(p0);
+crate::uri::Uri::has_path(p0);
+<uri::Uri>::has_path(p0);
-----------------
src/uri/mod.rs <uri::Uri as std::convert::TryFrom<&'a [u8]>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+<uri::Uri as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+crate::<uri::Uri as std::convert::TryFrom<&'a [u8]>>::try_from(p0);
+<uri::Uri>::try_from(p0);
-----------------
src/uri/mod.rs <uri::Uri as std::convert::TryFrom<&'a str>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<uri::Uri as std::convert::TryFrom<&'a str>>::try_from(&p0);
+crate::<uri::Uri as std::convert::TryFrom<&'a str>>::try_from(&p0);
+<uri::Uri>::try_from(&p0);
-----------------
src/uri/mod.rs <uri::Uri as std::convert::TryFrom<&'a std::string::String>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
+<uri::Uri as std::convert::TryFrom<&'a std::string::String>>::try_from(p0);
+crate::<uri::Uri as std::convert::TryFrom<&'a std::string::String>>::try_from(p0);
+<uri::Uri>::try_from(p0);
-----------------
src/uri/mod.rs <uri::Uri as std::convert::TryFrom<std::string::String>>::try_from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<uri::Uri as std::convert::TryFrom<std::string::String>>::try_from(p0);
+crate::<uri::Uri as std::convert::TryFrom<std::string::String>>::try_from(p0);
+<uri::Uri>::try_from(p0);
-----------------
src/uri/mod.rs <uri::Uri as std::convert::TryFrom<uri::Parts>>::try_from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::Parts
+<uri::Uri as std::convert::TryFrom<uri::Parts>>::try_from(p0);
+crate::<uri::Uri as std::convert::TryFrom<uri::Parts>>::try_from(p0);
+<uri::Uri>::try_from(p0);
-----------------
src/uri/mod.rs <uri::Uri as std::convert::TryFrom<&'a uri::Uri>>::try_from
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+<uri::Uri as std::convert::TryFrom<&'a uri::Uri>>::try_from(p0);
+crate::<uri::Uri as std::convert::TryFrom<&'a uri::Uri>>::try_from(p0);
+<uri::Uri>::try_from(p0);
-----------------
src/uri/mod.rs <uri::Parts as std::convert::From<uri::Uri>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::Uri
+<uri::Parts as std::convert::From<uri::Uri>>::from(p0);
+crate::<uri::Parts as std::convert::From<uri::Uri>>::from(p0);
+<uri::Parts>::from(p0);
-----------------
src/uri/mod.rs <uri::Uri as std::str::FromStr>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<uri::Uri as std::str::FromStr>::from_str(&p0);
+crate::<uri::Uri as std::str::FromStr>::from_str(&p0);
+<uri::Uri>::from_str(&p0);
-----------------
src/uri/mod.rs <uri::Uri as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.eq(p1);
+<uri::Uri as std::cmp::PartialEq>::eq(p0, p1);
+crate::<uri::Uri as std::cmp::PartialEq>::eq(p0, p1);
+<uri::Uri>::eq(p0, p1);
-----------------
src/uri/mod.rs <uri::Uri as std::cmp::PartialEq<str>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+<uri::Uri as std::cmp::PartialEq<str>>::eq(p0, &p1);
+crate::<uri::Uri as std::cmp::PartialEq<str>>::eq(p0, &p1);
+<uri::Uri>::eq(p0, &p1);
-----------------
src/uri/mod.rs uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.eq(p1);
+uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq(&p0, p1);
+crate::uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq(&p0, p1);
+<str>::eq(&p0, p1);
-----------------
src/uri/mod.rs <uri::Uri as std::cmp::PartialEq<&'a str>>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
let mut p1 = & "a"; // None+&'a str
+p0.eq(p1);
+<uri::Uri as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+crate::<uri::Uri as std::cmp::PartialEq<&'a str>>::eq(p0, p1);
+<uri::Uri>::eq(p0, p1);
-----------------
src/uri/mod.rs uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // uri::Uri
+p0.eq(p1);
+uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq(p0, p1);
+crate::uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq(p0, p1);
+<&'a str>::eq(p0, p1);
-----------------
src/uri/mod.rs <uri::Uri as std::default::Default>::default
deps:{}
candidates:{}
+<uri::Uri as std::default::Default>::default();
+crate::<uri::Uri as std::default::Default>::default();
+<uri::Uri>::default();
-----------------
src/uri/mod.rs <uri::Uri as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<uri::Uri as std::fmt::Display>::fmt(p0, p1);
+crate::<uri::Uri as std::fmt::Display>::fmt(p0, p1);
+<uri::Uri>::fmt(p0, p1);
-----------------
src/uri/mod.rs <uri::Uri as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<uri::Uri as std::fmt::Debug>::fmt(p0, p1);
+crate::<uri::Uri as std::fmt::Debug>::fmt(p0, p1);
+<uri::Uri>::fmt(p0, p1);
-----------------
src/uri/mod.rs <uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::ErrorKind
+<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from(p0);
+crate::<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from(p0);
+<uri::InvalidUri>::from(p0);
-----------------
src/uri/mod.rs <uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::ErrorKind
+<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from(p0);
+crate::<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from(p0);
+<uri::InvalidUriParts>::from(p0);
-----------------
src/uri/mod.rs uri::InvalidUri::s
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::InvalidUri
+p0.s();
+uri::InvalidUri::s(p0);
+crate::uri::InvalidUri::s(p0);
+<uri::InvalidUri>::s(p0);
-----------------
src/uri/mod.rs <uri::InvalidUri as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::InvalidUri
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<uri::InvalidUri as std::fmt::Display>::fmt(p0, p1);
+crate::<uri::InvalidUri as std::fmt::Display>::fmt(p0, p1);
+<uri::InvalidUri>::fmt(p0, p1);
-----------------
src/uri/mod.rs <uri::InvalidUriParts as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::InvalidUriParts
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<uri::InvalidUriParts as std::fmt::Display>::fmt(p0, p1);
+crate::<uri::InvalidUriParts as std::fmt::Display>::fmt(p0, p1);
+<uri::InvalidUriParts>::fmt(p0, p1);
-----------------
src/uri/mod.rs <uri::Uri as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<uri::Uri as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<uri::Uri as std::hash::Hash>::hash":{"H":["extensions::IdHasher","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // uri::Uri
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<uri::Uri as std::hash::Hash>::hash(p0, p1);
+crate::<uri::Uri as std::hash::Hash>::hash(p0, p1);
+<uri::Uri>::hash(p0, p1);
-----------------
src/version.rs <version::Version as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Version
let mut p1 = & MaybeUninit::uninit().assume_init(); // version::Version
+p0.eq(p1);
+<version::Version as std::cmp::PartialEq>::eq(p0, p1);
+crate::<version::Version as std::cmp::PartialEq>::eq(p0, p1);
+<version::Version>::eq(p0, p1);
-----------------
src/version.rs <version::Version as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Version
let mut p1 = & MaybeUninit::uninit().assume_init(); // version::Version
+p0.partial_cmp(p1);
+<version::Version as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<version::Version as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<version::Version>::partial_cmp(p0, p1);
-----------------
src/version.rs <version::Version as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Version
+p0.clone();
+<version::Version as std::clone::Clone>::clone(p0);
+crate::<version::Version as std::clone::Clone>::clone(p0);
+<version::Version>::clone(p0);
-----------------
src/version.rs <version::Version as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Version
+p0.assert_receiver_is_total_eq();
+<version::Version as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<version::Version as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<version::Version>::assert_receiver_is_total_eq(p0);
-----------------
src/version.rs <version::Version as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Version
let mut p1 = & MaybeUninit::uninit().assume_init(); // version::Version
+p0.cmp(p1);
+<version::Version as std::cmp::Ord>::cmp(p0, p1);
+crate::<version::Version as std::cmp::Ord>::cmp(p0, p1);
+<version::Version>::cmp(p0, p1);
-----------------
src/version.rs <version::Version as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<version::Version as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<version::Version as std::hash::Hash>::hash":{"__H":["extensions::IdHasher","<&mut H as std::hash::Hasher>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Version
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<version::Version as std::hash::Hash>::hash(p0, p1);
+crate::<version::Version as std::hash::Hash>::hash(p0, p1);
+<version::Version>::hash(p0, p1);
-----------------
src/version.rs <version::Http as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Http
let mut p1 = & MaybeUninit::uninit().assume_init(); // version::Http
+p0.eq(p1);
+<version::Http as std::cmp::PartialEq>::eq(p0, p1);
+crate::<version::Http as std::cmp::PartialEq>::eq(p0, p1);
+<version::Http>::eq(p0, p1);
-----------------
src/version.rs <version::Http as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Http
let mut p1 = & MaybeUninit::uninit().assume_init(); // version::Http
+p0.partial_cmp(p1);
+<version::Http as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<version::Http as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<version::Http>::partial_cmp(p0, p1);
-----------------
src/version.rs <version::Http as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Http
+p0.clone();
+<version::Http as std::clone::Clone>::clone(p0);
+crate::<version::Http as std::clone::Clone>::clone(p0);
+<version::Http>::clone(p0);
-----------------
src/version.rs <version::Http as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Http
+p0.assert_receiver_is_total_eq();
+<version::Http as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<version::Http as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<version::Http>::assert_receiver_is_total_eq(p0);
-----------------
src/version.rs <version::Http as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Http
let mut p1 = & MaybeUninit::uninit().assume_init(); // version::Http
+p0.cmp(p1);
+<version::Http as std::cmp::Ord>::cmp(p0, p1);
+crate::<version::Http as std::cmp::Ord>::cmp(p0, p1);
+<version::Http>::cmp(p0, p1);
-----------------
src/version.rs <version::Http as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<version::Http as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<version::Http as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Http
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<version::Http as std::hash::Hash>::hash(p0, p1);
+crate::<version::Http as std::hash::Hash>::hash(p0, p1);
+<version::Http>::hash(p0, p1);
-----------------
src/version.rs <version::Version as std::default::Default>::default
deps:{}
candidates:{}
+<version::Version as std::default::Default>::default();
+crate::<version::Version as std::default::Default>::default();
+<version::Version>::default();
-----------------
src/version.rs <version::Version as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // version::Version
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<version::Version as std::fmt::Debug>::fmt(p0, p1);
+crate::<version::Version as std::fmt::Debug>::fmt(p0, p1);
+<version::Version>::fmt(p0, p1);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<byte_str::ByteStr as std::fmt::Debug>::fmt(p0, p1);
+crate::<byte_str::ByteStr as std::fmt::Debug>::fmt(p0, p1);
+<byte_str::ByteStr>::fmt(p0, p1);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
+p0.clone();
+<byte_str::ByteStr as std::clone::Clone>::clone(p0);
+crate::<byte_str::ByteStr as std::clone::Clone>::clone(p0);
+<byte_str::ByteStr>::clone(p0);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
+p0.assert_receiver_is_total_eq();
+<byte_str::ByteStr as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<byte_str::ByteStr as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<byte_str::ByteStr>::assert_receiver_is_total_eq(p0);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
let mut p1 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
+p0.eq(p1);
+<byte_str::ByteStr as std::cmp::PartialEq>::eq(p0, p1);
+crate::<byte_str::ByteStr as std::cmp::PartialEq>::eq(p0, p1);
+<byte_str::ByteStr>::eq(p0, p1);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
let mut p1 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
+p0.cmp(p1);
+<byte_str::ByteStr as std::cmp::Ord>::cmp(p0, p1);
+crate::<byte_str::ByteStr as std::cmp::Ord>::cmp(p0, p1);
+<byte_str::ByteStr>::cmp(p0, p1);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
let mut p1 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
+p0.partial_cmp(p1);
+<byte_str::ByteStr as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<byte_str::ByteStr as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<byte_str::ByteStr>::partial_cmp(p0, p1);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<byte_str::ByteStr as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<byte_str::ByteStr as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","extensions::IdHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<byte_str::ByteStr as std::hash::Hash>::hash(p0, p1);
+crate::<byte_str::ByteStr as std::hash::Hash>::hash(p0, p1);
+<byte_str::ByteStr>::hash(p0, p1);
-----------------
src/byte_str.rs byte_str::ByteStr::new
deps:{}
candidates:{}
+byte_str::ByteStr::new();
+crate::byte_str::ByteStr::new();
+<byte_str::ByteStr>::new();
-----------------
src/byte_str.rs byte_str::ByteStr::from_static
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+byte_str::ByteStr::from_static(&p0);
+crate::byte_str::ByteStr::from_static(&p0);
+<byte_str::ByteStr>::from_static(&p0);
-----------------
src/byte_str.rs byte_str::ByteStr::from_utf8_unchecked
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // bytes::Bytes
+byte_str::ByteStr::from_utf8_unchecked(p0);
+crate::byte_str::ByteStr::from_utf8_unchecked(p0);
+<byte_str::ByteStr>::from_utf8_unchecked(p0);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::ops::Deref>::deref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
+p0.deref();
+<byte_str::ByteStr as std::ops::Deref>::deref(p0);
+crate::<byte_str::ByteStr as std::ops::Deref>::deref(p0);
+<byte_str::ByteStr>::deref(p0);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::convert::From<std::string::String>>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+<byte_str::ByteStr as std::convert::From<std::string::String>>::from(p0);
+crate::<byte_str::ByteStr as std::convert::From<std::string::String>>::from(p0);
+<byte_str::ByteStr>::from(p0);
-----------------
src/byte_str.rs <byte_str::ByteStr as std::convert::From<&'a str>>::from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+<byte_str::ByteStr as std::convert::From<&'a str>>::from(&p0);
+crate::<byte_str::ByteStr as std::convert::From<&'a str>>::from(&p0);
+<byte_str::ByteStr>::from(&p0);
-----------------
src/byte_str.rs byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // byte_str::ByteStr
+byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from(p0);
+crate::byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from(p0);
+<bytes::Bytes>::from(p0);
-----------------
src/error.rs <error::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Debug>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error.rs <error::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Display>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error.rs error::Error::is
deps:{"<&'a T as std::error::Error>":{},"error::Error::is":{"T":["std::error::Error","std::marker::Sized"]}}
candidates:{"<&'a T as std::error::Error>":{},"error::Error::is":{"T":["error::Error","header::name::InvalidHeaderName","header::value::InvalidHeaderValue","status::InvalidStatusCode","header::value::ToStrError","uri::InvalidUriParts","method::InvalidMethod","<&'a T as std::error::Error>","uri::InvalidUri"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.is();
+error::Error::is(p0);
+crate::error::Error::is(p0);
+<error::Error>::is(p0);
-----------------
src/error.rs error::Error::get_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.get_ref();
+error::Error::get_ref(p0);
+crate::error::Error::get_ref(p0);
+<error::Error>::get_ref(p0);
-----------------
src/error.rs <error::Error as std::error::Error>::source
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.source();
+<error::Error as std::error::Error>::source(p0);
+crate::<error::Error as std::error::Error>::source(p0);
+<error::Error>::source(p0);
-----------------
src/error.rs <error::Error as std::convert::From<status::InvalidStatusCode>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // status::InvalidStatusCode
+<error::Error as std::convert::From<status::InvalidStatusCode>>::from(p0);
+crate::<error::Error as std::convert::From<status::InvalidStatusCode>>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error.rs <error::Error as std::convert::From<method::InvalidMethod>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // method::InvalidMethod
+<error::Error as std::convert::From<method::InvalidMethod>>::from(p0);
+crate::<error::Error as std::convert::From<method::InvalidMethod>>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error.rs <error::Error as std::convert::From<uri::InvalidUri>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::InvalidUri
+<error::Error as std::convert::From<uri::InvalidUri>>::from(p0);
+crate::<error::Error as std::convert::From<uri::InvalidUri>>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error.rs <error::Error as std::convert::From<uri::InvalidUriParts>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // uri::InvalidUriParts
+<error::Error as std::convert::From<uri::InvalidUriParts>>::from(p0);
+crate::<error::Error as std::convert::From<uri::InvalidUriParts>>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error.rs <error::Error as std::convert::From<header::name::InvalidHeaderName>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::name::InvalidHeaderName
+<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from(p0);
+crate::<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error.rs <error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // header::value::InvalidHeaderValue
+<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from(p0);
+crate::<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error.rs <error::Error as std::convert::From<std::convert::Infallible>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::convert::Infallible
+<error::Error as std::convert::From<std::convert::Infallible>>::from(p0);
+crate::<error::Error as std::convert::From<std::convert::Infallible>>::from(p0);
+<error::Error>::from(p0);
-----------------
src/extensions.rs <extensions::IdHasher as std::default::Default>::default
deps:{}
candidates:{}
+<extensions::IdHasher as std::default::Default>::default();
+crate::<extensions::IdHasher as std::default::Default>::default();
+<extensions::IdHasher>::default();
-----------------
src/extensions.rs <extensions::IdHasher as std::hash::Hasher>::write
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // extensions::IdHasher
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write(p1);
+<extensions::IdHasher as std::hash::Hasher>::write(p0, p1);
+crate::<extensions::IdHasher as std::hash::Hasher>::write(p0, p1);
+<extensions::IdHasher>::write(p0, p1);
-----------------
src/extensions.rs <extensions::IdHasher as std::hash::Hasher>::write_u64
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // extensions::IdHasher
let mut p1 = 0u64; // None+u64
+p0.write_u64(p1);
+<extensions::IdHasher as std::hash::Hasher>::write_u64(p0, p1);
+crate::<extensions::IdHasher as std::hash::Hasher>::write_u64(p0, p1);
+<extensions::IdHasher>::write_u64(p0, p1);
-----------------
src/extensions.rs <extensions::IdHasher as std::hash::Hasher>::finish
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // extensions::IdHasher
+p0.finish();
+<extensions::IdHasher as std::hash::Hasher>::finish(p0);
+crate::<extensions::IdHasher as std::hash::Hasher>::finish(p0);
+<extensions::IdHasher>::finish(p0);
-----------------
src/extensions.rs <extensions::Extensions as std::default::Default>::default
deps:{}
candidates:{}
+<extensions::Extensions as std::default::Default>::default();
+crate::<extensions::Extensions as std::default::Default>::default();
+<extensions::Extensions>::default();
-----------------
src/extensions.rs extensions::Extensions::new
deps:{}
candidates:{}
+extensions::Extensions::new();
+crate::extensions::Extensions::new();
+<extensions::Extensions>::new();
-----------------
src/extensions.rs extensions::Extensions::insert
deps:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"extensions::Extensions::insert":{"T":["std::marker::Send","std::marker::Sync","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::Iter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Sized","std::marker::Sync","std::fmt::Debug","std::marker::Send"]},"header::map::ValueDrain":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Sync","std::marker::Sized","std::marker::Send"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"extensions::Extensions::insert":{"T":["<*const T as std::marker::Send>","header::map::ValueDrain","header::map::ValueIterMut","header::map::Iter","header::map::IterMut","<*const T as std::marker::Sync>","header::map::Drain","<*mut T as std::marker::Sync>"]},"header::map::Drain":{"T":["header::map::ValueIterMut","<*mut T as std::fmt::Debug>","header::map::Iter","header::map::ValueDrain","header::map::IterMut","header::map::Drain"]},"header::map::Iter":{"T":["<*const T as std::marker::Sync>","header::map::ValueIterMut","header::map::IterMut","header::map::ValueDrain","header::map::Iter","header::map::Drain"]},"header::map::IterMut":{"T":["header::map::Drain","header::map::ValueDrain","header::map::IterMut","<*const T as std::marker::Send>","header::map::ValueIterMut","header::map::Iter"]},"header::map::ValueDrain":{"T":["<*const T as std::marker::Send>","header::map::Drain","header::map::IterMut","header::map::ValueIterMut","header::map::ValueDrain","header::map::Iter"]},"header::map::ValueIterMut":{"T":["header::map::Iter","header::map::IterMut","<*mut T as std::marker::Sync>","header::map::Drain","header::map::ValueIterMut","header::map::ValueDrain"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // extensions::Extensions
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.insert(p1);
+extensions::Extensions::insert(p0, p1);
+crate::extensions::Extensions::insert(p0, p1);
+<extensions::Extensions>::insert(p0, p1);
-----------------
src/extensions.rs extensions::Extensions::get
deps:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"extensions::Extensions::get":{"T":["std::marker::Send","std::marker::Sized","std::marker::Sync"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Send","std::marker::Sync"]},"header::map::Iter":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::IterMut":{"T":["std::marker::Sized","std::marker::Send","std::marker::Sync","std::fmt::Debug"]},"header::map::ValueDrain":{"T":["std::marker::Send","std::marker::Sized","std::marker::Sync","std::fmt::Debug"]},"header::map::ValueIterMut":{"T":["std::marker::Sized","std::marker::Send","std::marker::Sync","std::fmt::Debug"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"extensions::Extensions::get":{"T":["<*mut T as std::marker::Sync>","header::map::Iter","header::map::ValueIterMut","<*mut T as std::marker::Send>","header::map::IterMut","header::map::ValueDrain","header::map::Drain","<*const T as std::marker::Sync>"]},"header::map::Drain":{"T":["<*mut T as std::fmt::Debug>","header::map::ValueIterMut","header::map::IterMut","header::map::Iter","header::map::ValueDrain","header::map::Drain"]},"header::map::Iter":{"T":["header::map::ValueIterMut","header::map::Iter","header::map::IterMut","header::map::Drain","<*const T as std::fmt::Debug>","header::map::ValueDrain"]},"header::map::IterMut":{"T":["header::map::ValueDrain","header::map::Iter","header::map::ValueIterMut","header::map::Drain","<*const T as std::fmt::Debug>","header::map::IterMut"]},"header::map::ValueDrain":{"T":["header::map::ValueDrain","header::map::ValueIterMut","header::map::IterMut","<*const T as std::fmt::Debug>","header::map::Drain","header::map::Iter"]},"header::map::ValueIterMut":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::Iter","header::map::Drain","<*const T as std::fmt::Debug>","header::map::ValueDrain"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // extensions::Extensions
+p0.get();
+extensions::Extensions::get(p0);
+crate::extensions::Extensions::get(p0);
+<extensions::Extensions>::get(p0);
-----------------
src/extensions.rs extensions::Extensions::get_mut
deps:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"extensions::Extensions::get_mut":{"T":["std::marker::Sync","std::marker::Sized","std::marker::Send"]},"header::map::Drain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::Iter":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::marker::Sized","std::fmt::Debug","std::marker::Sync","std::marker::Send"]},"header::map::ValueDrain":{"T":["std::marker::Send","std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::ValueIterMut":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Send","std::marker::Sync"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"extensions::Extensions::get_mut":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::Drain","<*const T as std::marker::Send>","<*mut T as std::marker::Send>","header::map::ValueDrain","header::map::Iter"]},"header::map::Drain":{"T":["header::map::ValueIterMut","header::map::Iter","header::map::ValueDrain","<*const T as std::marker::Send>","header::map::IterMut","header::map::Drain"]},"header::map::Iter":{"T":["header::map::ValueIterMut","header::map::Drain","<*mut T as std::marker::Sync>","header::map::ValueDrain","header::map::IterMut","header::map::Iter"]},"header::map::IterMut":{"T":["header::map::Iter","header::map::ValueIterMut","header::map::Drain","header::map::ValueDrain","header::map::IterMut","<*mut T as std::marker::Send>"]},"header::map::ValueDrain":{"T":["<*mut T as std::marker::Sync>","header::map::ValueIterMut","header::map::Iter","header::map::IterMut","header::map::Drain","header::map::ValueDrain"]},"header::map::ValueIterMut":{"T":["header::map::ValueDrain","<*mut T as std::marker::Sync>","header::map::Iter","header::map::Drain","header::map::IterMut","header::map::ValueIterMut"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // extensions::Extensions
+p0.get_mut();
+extensions::Extensions::get_mut(p0);
+crate::extensions::Extensions::get_mut(p0);
+<extensions::Extensions>::get_mut(p0);
-----------------
src/extensions.rs extensions::Extensions::remove
deps:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"extensions::Extensions::remove":{"T":["std::marker::Sync","std::marker::Send","std::marker::Sized"]},"header::map::Drain":{"T":["std::marker::Sized","std::marker::Sync","std::marker::Send","std::fmt::Debug"]},"header::map::Iter":{"T":["std::marker::Sync","std::marker::Sized","std::fmt::Debug"]},"header::map::IterMut":{"T":["std::marker::Send","std::marker::Sized","std::fmt::Debug","std::marker::Sync"]},"header::map::ValueDrain":{"T":["std::fmt::Debug","std::marker::Sized","std::marker::Sync","std::marker::Send"]},"header::map::ValueIterMut":{"T":["std::marker::Send","std::marker::Sync","std::marker::Sized","std::fmt::Debug"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*const T as std::marker::Send>":{},"<*const T as std::marker::Sync>":{},"<*mut T as std::fmt::Debug>":{},"<*mut T as std::marker::Send>":{},"<*mut T as std::marker::Sync>":{},"extensions::Extensions::remove":{"T":["<*mut T as std::marker::Sync>","header::map::ValueIterMut","header::map::IterMut","header::map::ValueDrain","header::map::Drain","header::map::Iter","<*const T as std::marker::Sync>"]},"header::map::Drain":{"T":["header::map::Drain","<*const T as std::marker::Sync>","header::map::Iter","header::map::ValueDrain","header::map::ValueIterMut","header::map::IterMut"]},"header::map::Iter":{"T":["header::map::Drain","header::map::Iter","header::map::ValueDrain","header::map::IterMut","<*mut T as std::marker::Sync>","header::map::ValueIterMut"]},"header::map::IterMut":{"T":["header::map::IterMut","header::map::ValueIterMut","header::map::Iter","<*mut T as std::marker::Send>","header::map::ValueDrain","header::map::Drain"]},"header::map::ValueDrain":{"T":["header::map::ValueDrain","header::map::ValueIterMut","header::map::IterMut","header::map::Drain","header::map::Iter","<*mut T as std::fmt::Debug>"]},"header::map::ValueIterMut":{"T":["header::map::ValueDrain","header::map::IterMut","header::map::ValueIterMut","header::map::Drain","<*const T as std::marker::Sync>","header::map::Iter"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // extensions::Extensions
+p0.remove();
+extensions::Extensions::remove(p0);
+crate::extensions::Extensions::remove(p0);
+<extensions::Extensions>::remove(p0);
-----------------
src/extensions.rs extensions::Extensions::clear
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // extensions::Extensions
+p0.clear();
+extensions::Extensions::clear(p0);
+crate::extensions::Extensions::clear(p0);
+<extensions::Extensions>::clear(p0);
-----------------
src/extensions.rs <extensions::Extensions as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // extensions::Extensions
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<extensions::Extensions as std::fmt::Debug>::fmt(p0, p1);
+crate::<extensions::Extensions as std::fmt::Debug>::fmt(p0, p1);
+<extensions::Extensions>::fmt(p0, p1);