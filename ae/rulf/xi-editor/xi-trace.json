{"dependencies":{"<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::collections::vec_deque::Iter","std::marker::Sized"],"<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::collections::vec_deque::IterMut","std::marker::Sized"],"<&'static [&'static str] as StringArrayEq<std::vec::Vec<std::string::String>>>::arr_eq":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::expecting":["<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::visit_str":["<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de> as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<CategoriesT as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor":["<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor"],"<CategoriesT as serde::Serialize>::serialize":["CategoriesT","serde::Serializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<CategoriesT as std::clone::Clone>::clone":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::cmp::PartialEq>::eq":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 0]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 10]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 1]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 2]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 3]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 4]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 5]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 6]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 7]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 8]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<&'static [&'static str; 9]>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::convert::From<std::vec::Vec<std::string::String>>>::from":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<CategoriesT as std::fmt::Debug>::fmt":["CategoriesT","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<Config as std::clone::Clone>::clone":["Config"],"<MetadataType as std::clone::Clone>::clone":["MetadataType","std::string::String"],"<MetadataType as std::cmp::Eq>::assert_receiver_is_total_eq":["MetadataType","std::string::String"],"<MetadataType as std::cmp::PartialEq>::eq":["MetadataType","std::string::String"],"<MetadataType as std::fmt::Debug>::fmt":["MetadataType","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<Sample as std::clone::Clone>::clone":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<Sample as std::cmp::Ord>::cmp":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::cmp::Ordering","std::marker::Sized","std::option::Option"],"<Sample as std::cmp::PartialEq>::eq":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<Sample as std::cmp::PartialOrd>::partial_cmp":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<Sample as std::fmt::Debug>::fmt":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<Sample as std::hash::Hash>::hash":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::hash::Hasher","std::marker::Sized","std::option::Option"],"<SampleArgs as std::clone::Clone>::clone":["SampleArgs","std::marker::Sized","std::option::Option"],"<SampleArgs as std::cmp::PartialEq>::eq":["SampleArgs","std::marker::Sized","std::option::Option"],"<SampleArgs as std::fmt::Debug>::fmt":["SampleArgs","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<SampleEventType as std::clone::Clone>::clone":["SampleEventType"],"<SampleEventType as std::cmp::Eq>::assert_receiver_is_total_eq":["SampleEventType"],"<SampleEventType as std::cmp::PartialEq>::eq":["SampleEventType"],"<SampleEventType as std::fmt::Debug>::fmt":["SampleEventType","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<SampleGuard<'a> as std::ops::Drop>::drop":["SampleGuard","std::marker::Sized","std::option::Option"],"<TRACE as lazy_static::LazyStatic>::initialize":["TRACE"],"<TRACE as lazy_static::__Deref>::deref":["TRACE","Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"<TRACE as lazy_static::__Deref>::deref::__stability":["Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"<TRACE as lazy_static::__Deref>::deref::__static_ref_initialize":["Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","SampleEventType","std::marker::PhantomData"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith","SampleEventType","std::marker::PhantomData"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith<'__a> as serde::Serialize>::serialize":["SampleEventType","_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith","serde::Serializer","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<chrome_trace_dump::ChromeTraceArrayEntries as std::clone::Clone>::clone":["chrome_trace_dump::ChromeTraceArrayEntries","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<chrome_trace_dump::ChromeTraceArrayEntries as std::fmt::Debug>::fmt":["chrome_trace_dump::ChromeTraceArrayEntries","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<chrome_trace_dump::Error as std::convert::From<serde_json::Error>>::from":["chrome_trace_dump::Error","serde_json::Error","std::io::Error","std::string::String"],"<chrome_trace_dump::Error as std::convert::From<std::io::Error>>::from":["chrome_trace_dump::Error","serde_json::Error","std::io::Error","std::string::String"],"<chrome_trace_dump::Error as std::convert::From<std::string::String>>::from":["chrome_trace_dump::Error","serde_json::Error","std::io::Error","std::string::String"],"<chrome_trace_dump::Error as std::fmt::Debug>::fmt":["chrome_trace_dump::Error","serde_json::Error","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result","std::string::String"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::Ord>::cmp":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::cmp::Ordering","std::collections::VecDeque","std::marker::Sized"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialEq>::eq":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialOrd>::partial_cmp":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::hash::Hash>::hash":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::hash::Hasher","std::marker::Sized"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::iter::Extend<A>>::extend":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::iter::IntoIterator","std::marker::Sized"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::Index<usize>>::index":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::IndexMut<usize>>::index_mut":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"<fixed_lifo_deque::FixedLifoDeque<T> as std::clone::Clone>::clone":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"<fixed_lifo_deque::FixedLifoDeque<T> as std::fmt::Debug>::fmt":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::Extend<&'a T>>::extend":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::iter::IntoIterator","std::marker::Sized"],"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::collections::vec_deque::IntoIter","std::marker::Sized"],"<std::vec::Vec<std::string::String> as StringArrayEq<[&'static str]>>::arr_eq":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"CategoriesT":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"CategoriesT::join":["CategoriesT","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"Config":["Config"],"Config::default":["Config"],"Config::max_samples":["Config"],"Config::max_size_in_bytes":["Config"],"Config::with_limit_bytes":["Config"],"Config::with_limit_count":["Config"],"MetadataType":["MetadataType","std::string::String"],"MetadataType::consume":["MetadataType","std::marker::Sized","std::option::Option","std::string::String"],"MetadataType::sample_name":["MetadataType","std::string::String"],"Sample":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"Sample::new_duration":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::convert::Into","std::marker::Sized","std::option::Option"],"Sample::new_duration_marker":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::convert::Into","std::marker::Sized","std::option::Option"],"Sample::new_instant":["Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::convert::Into","std::marker::Sized","std::option::Option"],"Sample::new_metadata":["MetadataType","Sample","SampleEventType","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::string::String"],"Sample::thread_name":["std::marker::Sized","std::option::Option"],"SampleArgs":["SampleArgs","std::marker::Sized","std::option::Option"],"SampleEventType":["SampleEventType"],"SampleEventType::from_chrome_id":["SampleEventType"],"SampleEventType::into_chrome_id":["SampleEventType"],"SampleGuard":["SampleGuard","std::marker::Sized","std::option::Option"],"SampleGuard::<'a>::new":["SampleGuard","Trace","std::convert::Into","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicBool"],"SampleGuard::<'a>::new_disabled":["SampleGuard","std::marker::Sized","std::option::Option"],"StringArrayEq::arr_eq":[],"TRACE":["TRACE"],"Trace":["Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::block":["SampleGuard","Trace","std::convert::Into","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::block_payload":["SampleGuard","Trace","std::convert::Into","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::closure":["Trace","std::convert::Into","std::marker::Sized","std::ops::FnOnce","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::closure_payload":["Trace","std::convert::Into","std::marker::Sized","std::ops::FnOnce","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::disable":["Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::disabled":["Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::enable":["Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::enable_config":["Config","Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::enabled":["Config","Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::get_samples_count":["Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::get_samples_limit":["Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::instant":["Trace","std::convert::Into","std::marker::Sized","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::instant_payload":["Trace","std::convert::Into","std::marker::Sized","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::is_enabled":["Trace","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::record":["Sample","SampleEventType","Trace","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicBool"],"Trace::samples_cloned_sorted":["Trace","std::alloc::Allocator","std::marker::Sized","std::sync::Mutex","std::sync::atomic::AtomicBool","std::vec::Vec"],"Trace::samples_cloned_unsorted":["Trace","std::alloc::Allocator","std::marker::Sized","std::sync::Mutex","std::sync::atomic::AtomicBool","std::vec::Vec"],"Trace::save":["Trace","std::convert::AsRef","std::marker::Sized","std::result::Result","std::sync::Mutex","std::sync::atomic::AtomicBool"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor":["_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor","std::marker::PhantomData"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor":["_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor","std::marker::PhantomData"],"_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize":["Sample","SampleEventType","serde::Serializer","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option","std::result::Result"],"_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith":["SampleEventType","_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith","std::marker::PhantomData"],"_IMPL_SERIALIZE_FOR_SampleArgs::<impl serde::Serialize for SampleArgs>::serialize":["SampleArgs","serde::Serializer","std::marker::Sized","std::option::Option","std::result::Result"],"chrome_trace_dump::ChromeTraceArrayEntries":["chrome_trace_dump::ChromeTraceArrayEntries","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"chrome_trace_dump::Error":["chrome_trace_dump::Error","serde_json::Error","std::io::Error","std::string::String"],"chrome_trace_dump::Error::already_exists":["chrome_trace_dump::Error","serde_json::Error","std::io::Error","std::string::String"],"chrome_trace_dump::_IMPL_DESERIALIZE_FOR_ChromeTraceArrayEntries::<impl serde::Deserialize<'de> for chrome_trace_dump::ChromeTraceArrayEntries>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"chrome_trace_dump::decode":["serde_json::Value","std::marker::Sized","std::result::Result"],"chrome_trace_dump::deserialize":["std::io::Read","std::marker::Sized","std::result::Result"],"chrome_trace_dump::serialize":["std::alloc::Allocator","std::io::Write","std::marker::Sized","std::result::Result","std::vec::Vec"],"chrome_trace_dump::to_value":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"deserialize_event_type":["serde::Deserializer","std::marker::Sized","std::result::Result"],"disable_tracing":[],"enable_tracing":[],"enable_tracing_with_config":["Config"],"exe_name":["std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::append":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::as_mut_slices":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::as_slices":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::back":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::back_mut":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::capacity":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::clear":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::contains":["CategoriesT","fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::cmp::PartialEq","std::collections::VecDeque","std::marker::Sized","std::vec::Vec"],"fixed_lifo_deque::FixedLifoDeque::<T>::drain":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::collections::vec_deque::Drain","std::marker::Sized","std::ops::RangeBounds"],"fixed_lifo_deque::FixedLifoDeque::<T>::drop_excess_for_inserting":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::front":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::front_mut":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::get":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::get_mut":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::is_empty":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::iter":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::collections::vec_deque::Iter","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::iter_mut":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::collections::vec_deque::IterMut","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::len":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::limit":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::new":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::pop_back":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::pop_front":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::push_back":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::remove":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::reset_limit":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::resize":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::retain":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::ops::FnMut"],"fixed_lifo_deque::FixedLifoDeque::<T>::split_off":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::swap":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_back":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_front":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized","std::option::Option"],"fixed_lifo_deque::FixedLifoDeque::<T>::with_limit":["fixed_lifo_deque::FixedLifoDeque","std::alloc::Allocator","std::collections::VecDeque","std::marker::Sized"],"is_enabled":[],"ns_to_us":[],"samples_cloned_sorted":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"samples_cloned_unsorted":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"samples_len":[],"save":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"serialize_event_type":["SampleEventType","serde::Serializer","std::marker::Sized","std::result::Result"],"sys_pid::current_pid":[],"sys_pid::current_pid::getpid":[],"sys_tid::current_tid":["std::marker::Sized","std::result::Result"],"to_cow_str":["std::borrow::Cow","std::borrow::ToOwned","std::convert::Into","std::marker::Sized"],"trace":["std::convert::Into","std::marker::Sized"],"trace_block":["SampleGuard","std::convert::Into","std::marker::Sized","std::option::Option"],"trace_block_payload":["SampleGuard","std::convert::Into","std::marker::Sized","std::option::Option"],"trace_closure":["std::convert::Into","std::marker::Sized","std::ops::FnOnce"],"trace_closure_payload":["std::convert::Into","std::marker::Sized","std::ops::FnOnce"],"trace_payload":["std::convert::Into","std::marker::Sized"]},"glob_path_import":{},"self_to_fn":{"<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor":["impl<'de> Visitor<'de> for CategoriesTVisitor {\n            type Value = CategoriesT;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"comma-separated strings\")\n            }\n\n            fn visit_str<E>(self, v: &str) -> Result<CategoriesT, E>\n            where\n                E: serde::de::Error,\n            {\n                let categories = v.split(',').map(ToString::to_string).collect();\n                Ok(CategoriesT::DynamicArray(categories))\n            }\n        }"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["Deserialize"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["Deserialize"],"CategoriesT":["Clone","Debug","impl CategoriesT {\n    pub fn join(&self, sep: &str) -> String {\n        match *self {\n            CategoriesT::StaticArray(ref arr) => arr.join(sep),\n            CategoriesT::DynamicArray(ref vec) => vec.join(sep),\n        }\n    }\n}","impl Eq for CategoriesT {}","impl From<&'static [&'static str; $num_args]> for CategoriesT {\n            fn from(c: &'static [&'static str; $num_args]) -> CategoriesT {\n                CategoriesT::StaticArray(c)\n            }\n        }","impl From<Vec<String>> for CategoriesT {\n    fn from(c: Vec<String>) -> CategoriesT {\n        CategoriesT::DynamicArray(c)\n    }\n}","impl PartialEq for CategoriesT {\n    fn eq(&self, other: &CategoriesT) -> bool {\n        match *self {\n            CategoriesT::StaticArray(ref self_arr) => match *other {\n                CategoriesT::StaticArray(ref other_arr) => self_arr.eq(other_arr),\n                CategoriesT::DynamicArray(ref other_arr) => self_arr.arr_eq(other_arr),\n            },\n            CategoriesT::DynamicArray(ref self_arr) => match *other {\n                CategoriesT::StaticArray(ref other_arr) => self_arr.arr_eq(other_arr),\n                CategoriesT::DynamicArray(ref other_arr) => self_arr.eq(other_arr),\n            },\n        }\n    }\n}","impl serde::Serialize for CategoriesT {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        self.join(\",\").serialize(serializer)\n    }\n}","impl<'de> serde::Deserialize<'de> for CategoriesT {\n    fn deserialize<D>(deserializer: D) -> Result<CategoriesT, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        use serde::de::Visitor;\n        struct CategoriesTVisitor;\n\n        impl<'de> Visitor<'de> for CategoriesTVisitor {\n            type Value = CategoriesT;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"comma-separated strings\")\n            }\n\n            fn visit_str<E>(self, v: &str) -> Result<CategoriesT, E>\n            where\n                E: serde::de::Error,\n            {\n                let categories = v.split(',').map(ToString::to_string).collect();\n                Ok(CategoriesT::DynamicArray(categories))\n            }\n        }\n\n        deserializer.deserialize_str(CategoriesTVisitor)\n    }\n}"],"Config":["Clone","Copy","impl Config {\n    /// The maximum number of bytes the tracing data should take up.  This limit\n    /// won't be exceeded by the underlying storage itself (i.e. rounds down).\n    pub fn with_limit_bytes(size: usize) -> Self {\n        Self::with_limit_count(size / size_of::<Sample>())\n    }\n\n    /// The maximum number of entries the tracing data should allow.  Total\n    /// storage allocated will be limit * size_of<Sample>\n    pub fn with_limit_count(limit: usize) -> Self {\n        Self { sample_limit_count: limit }\n    }\n\n    /// The default amount of storage to allocate for tracing.  Currently 1 MB.\n    pub fn default() -> Self {\n        // 1 MB\n        Self::with_limit_bytes(1 * 1024 * 1024)\n    }\n\n    /// The maximum amount of space the tracing data will take up.  This does\n    /// not account for any overhead of storing the data itself (i.e. pointer to\n    /// the heap, counters, etc); just the data itself.\n    pub fn max_size_in_bytes(self) -> usize {\n        self.sample_limit_count * size_of::<Sample>()\n    }\n\n    /// The maximum number of samples that should be stored.\n    pub fn max_samples(self) -> usize {\n        self.sample_limit_count\n    }\n}"],"MetadataType":["Clone","Debug","Eq","PartialEq","impl MetadataType {\n    fn sample_name(&self) -> &'static str {\n        match *self {\n            MetadataType::ProcessName { .. } => \"process_name\",\n            MetadataType::ProcessLabels { .. } => \"process_labels\",\n            MetadataType::ProcessSortIndex { .. } => \"process_sort_index\",\n            MetadataType::ThreadName { .. } => \"thread_name\",\n            MetadataType::ThreadSortIndex { .. } => \"thread_sort_index\",\n        }\n    }\n\n    fn consume(self) -> (Option<String>, Option<i32>) {\n        match self {\n            MetadataType::ProcessName { name } => (Some(name), None),\n            MetadataType::ThreadName { name } => (Some(name), None),\n            MetadataType::ProcessSortIndex { sort_index } => (None, Some(sort_index)),\n            MetadataType::ThreadSortIndex { sort_index } => (None, Some(sort_index)),\n            MetadataType::ProcessLabels { .. } => (None, None),\n        }\n    }\n}"],"Sample":["Clone","Debug","Deserialize","Serialize","impl Eq for Sample {}","impl Hash for Sample {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        (self.pid, self.timestamp_us).hash(state);\n    }\n}","impl Ord for Sample {\n    fn cmp(&self, other: &Sample) -> cmp::Ordering {\n        self.timestamp_us.cmp(&other.timestamp_us)\n    }\n}","impl PartialEq for Sample {\n    fn eq(&self, other: &Sample) -> bool {\n        self.timestamp_us == other.timestamp_us\n            && self.name == other.name\n            && self.categories == other.categories\n            && self.pid == other.pid\n            && self.tid == other.tid\n            && self.event_type == other.event_type\n            && self.args == other.args\n    }\n}","impl PartialOrd for Sample {\n    fn partial_cmp(&self, other: &Sample) -> Option<cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}","impl Sample {\n    fn thread_name() -> Option<StrCow> {\n        let thread = std::thread::current();\n        thread.name().map(|ref s| to_cow_str((*s).to_string()))\n    }\n\n    /// Constructs a Begin or End sample.  Should not be used directly.  Instead\n    /// should be constructed via SampleGuard.\n    pub fn new_duration_marker<S, C>(\n        name: S,\n        categories: C,\n        payload: Option<TracePayloadT>,\n        event_type: SampleEventType,\n    ) -> Self\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n    {\n        Self {\n            name: name.into(),\n            categories: Some(categories.into()),\n            timestamp_us: ns_to_us(time::precise_time_ns()),\n            event_type,\n            duration_us: None,\n            tid: sys_tid::current_tid().unwrap(),\n            thread_name: Sample::thread_name(),\n            pid: sys_pid::current_pid(),\n            args: Some(SampleArgs { payload, metadata_name: None, metadata_sort_index: None }),\n        }\n    }\n\n    /// Constructs a Duration sample.  For use via xi_trace::closure.\n    pub fn new_duration<S, C>(\n        name: S,\n        categories: C,\n        payload: Option<TracePayloadT>,\n        start_ns: u64,\n        duration_ns: u64,\n    ) -> Self\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n    {\n        Self {\n            name: name.into(),\n            categories: Some(categories.into()),\n            timestamp_us: ns_to_us(start_ns),\n            event_type: SampleEventType::CompleteDuration,\n            duration_us: Some(ns_to_us(duration_ns)),\n            tid: sys_tid::current_tid().unwrap(),\n            thread_name: Sample::thread_name(),\n            pid: sys_pid::current_pid(),\n            args: Some(SampleArgs { payload, metadata_name: None, metadata_sort_index: None }),\n        }\n    }\n\n    /// Constructs an instantaneous sample.\n    pub fn new_instant<S, C>(name: S, categories: C, payload: Option<TracePayloadT>) -> Self\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n    {\n        Self {\n            name: name.into(),\n            categories: Some(categories.into()),\n            timestamp_us: ns_to_us(time::precise_time_ns()),\n            event_type: SampleEventType::Instant,\n            duration_us: None,\n            tid: sys_tid::current_tid().unwrap(),\n            thread_name: Sample::thread_name(),\n            pid: sys_pid::current_pid(),\n            args: Some(SampleArgs { payload, metadata_name: None, metadata_sort_index: None }),\n        }\n    }\n\n    fn new_metadata(timestamp_ns: u64, meta: MetadataType, tid: u64) -> Self {\n        let sample_name = to_cow_str(meta.sample_name());\n        let (metadata_name, sort_index) = meta.consume();\n\n        Self {\n            name: sample_name,\n            categories: None,\n            timestamp_us: ns_to_us(timestamp_ns),\n            event_type: SampleEventType::Metadata,\n            duration_us: None,\n            tid,\n            thread_name: None,\n            pid: sys_pid::current_pid(),\n            args: Some(SampleArgs {\n                payload: None,\n                metadata_name: metadata_name.map(Cow::Owned),\n                metadata_sort_index: sort_index,\n            }),\n        }\n    }\n}"],"SampleArgs":["Clone","Debug","Deserialize","PartialEq","Serialize"],"SampleEventType":["Clone","Copy","Debug","Eq","PartialEq","impl SampleEventType {\n    // TODO(vlovich): Replace all of this with serde flatten + rename once\n    // https://github.com/serde-rs/serde/issues/1189 is fixed.\n    #[inline]\n    fn into_chrome_id(self) -> char {\n        match self {\n            SampleEventType::DurationBegin => 'B',\n            SampleEventType::DurationEnd => 'E',\n            SampleEventType::CompleteDuration => 'X',\n            SampleEventType::Instant => 'i',\n            SampleEventType::AsyncStart => 'b',\n            SampleEventType::AsyncInstant => 'n',\n            SampleEventType::AsyncEnd => 'e',\n            SampleEventType::FlowStart => 's',\n            SampleEventType::FlowInstant => 't',\n            SampleEventType::FlowEnd => 'f',\n            SampleEventType::ObjectCreated => 'N',\n            SampleEventType::ObjectSnapshot => 'O',\n            SampleEventType::ObjectDestroyed => 'D',\n            SampleEventType::Metadata => 'M',\n        }\n    }\n\n    #[inline]\n    fn from_chrome_id(symbol: char) -> Self {\n        match symbol {\n            'B' => SampleEventType::DurationBegin,\n            'E' => SampleEventType::DurationEnd,\n            'X' => SampleEventType::CompleteDuration,\n            'i' => SampleEventType::Instant,\n            'b' => SampleEventType::AsyncStart,\n            'n' => SampleEventType::AsyncInstant,\n            'e' => SampleEventType::AsyncEnd,\n            's' => SampleEventType::FlowStart,\n            't' => SampleEventType::FlowInstant,\n            'f' => SampleEventType::FlowEnd,\n            'N' => SampleEventType::ObjectCreated,\n            'O' => SampleEventType::ObjectSnapshot,\n            'D' => SampleEventType::ObjectDestroyed,\n            'M' => SampleEventType::Metadata,\n            _ => panic!(\"Unexpected chrome sample type '{}'\", symbol),\n        }\n    }\n}"],"SampleGuard":["impl<'a> Drop for SampleGuard<'a> {\n    fn drop(&mut self) {\n        if let Some(ref mut trace) = self.trace {\n            let mut sample = self.sample.take().unwrap();\n            sample.timestamp_us = ns_to_us(time::precise_time_ns());\n            sample.event_type = SampleEventType::DurationEnd;\n            trace.record(sample);\n        }\n    }\n}","impl<'a> SampleGuard<'a> {\n    #[inline]\n    pub fn new_disabled() -> Self {\n        Self { sample: None, trace: None }\n    }\n\n    #[inline]\n    fn new<S, C>(trace: &'a Trace, name: S, categories: C, payload: Option<TracePayloadT>) -> Self\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n    {\n        // TODO(vlovich): optimize this path to use the Complete event type\n        // rather than emitting an explicit start/stop to reduce the size of\n        // the generated JSON.\n        let guard = Self {\n            sample: Some(Sample::new_duration_marker(\n                name,\n                categories,\n                payload,\n                SampleEventType::DurationBegin,\n            )),\n            trace: Some(&trace),\n        };\n        trace.record(guard.sample.as_ref().unwrap().clone());\n        guard\n    }\n}"],"TRACE":["impl $crate::LazyStatic for $N {\n            fn initialize(lazy: &Self) {\n                let _ = &**lazy;\n            }\n        }","impl $crate::__Deref for $N {\n            type Target = $T;\n            fn deref(&self) -> &$T {\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }\n        }"],"Trace":["impl Trace {\n    pub fn disabled() -> Self {\n        Self { enabled: AtomicBool::new(false), samples: Mutex::new(FixedLifoDeque::new()) }\n    }\n\n    pub fn enabled(config: Config) -> Self {\n        Self {\n            enabled: AtomicBool::new(true),\n            samples: Mutex::new(FixedLifoDeque::with_limit(config.max_samples())),\n        }\n    }\n\n    pub fn disable(&self) {\n        let mut all_samples = self.samples.lock().unwrap();\n        all_samples.reset_limit(0);\n        self.enabled.store(false, AtomicOrdering::Relaxed);\n    }\n\n    #[inline]\n    pub fn enable(&self) {\n        self.enable_config(Config::default());\n    }\n\n    pub fn enable_config(&self, config: Config) {\n        let mut all_samples = self.samples.lock().unwrap();\n        all_samples.reset_limit(config.max_samples());\n        self.enabled.store(true, AtomicOrdering::Relaxed);\n    }\n\n    /// Generally racy since the underlying storage might be mutated in a separate thread.\n    /// Exposed for unit tests.\n    pub fn get_samples_count(&self) -> usize {\n        self.samples.lock().unwrap().len()\n    }\n\n    /// Exposed for unit tests only.\n    pub fn get_samples_limit(&self) -> usize {\n        self.samples.lock().unwrap().limit()\n    }\n\n    #[inline]\n    pub(crate) fn record(&self, sample: Sample) {\n        let mut all_samples = self.samples.lock().unwrap();\n        all_samples.push_back(sample);\n    }\n\n    pub fn is_enabled(&self) -> bool {\n        self.enabled.load(AtomicOrdering::Relaxed)\n    }\n\n    pub fn instant<S, C>(&self, name: S, categories: C)\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n    {\n        if self.is_enabled() {\n            self.record(Sample::new_instant(name, categories, None));\n        }\n    }\n\n    pub fn instant_payload<S, C, P>(&self, name: S, categories: C, payload: P)\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n        P: Into<TracePayloadT>,\n    {\n        if self.is_enabled() {\n            self.record(Sample::new_instant(name, categories, Some(payload.into())));\n        }\n    }\n\n    pub fn block<S, C>(&self, name: S, categories: C) -> SampleGuard\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n    {\n        if !self.is_enabled() {\n            SampleGuard::new_disabled()\n        } else {\n            SampleGuard::new(&self, name, categories, None)\n        }\n    }\n\n    pub fn block_payload<S, C, P>(&self, name: S, categories: C, payload: P) -> SampleGuard\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n        P: Into<TracePayloadT>,\n    {\n        if !self.is_enabled() {\n            SampleGuard::new_disabled()\n        } else {\n            SampleGuard::new(&self, name, categories, Some(payload.into()))\n        }\n    }\n\n    pub fn closure<S, C, F, R>(&self, name: S, categories: C, closure: F) -> R\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n        F: FnOnce() -> R,\n    {\n        // TODO: simplify this through the use of scopeguard crate\n        let start = time::precise_time_ns();\n        let result = closure();\n        let end = time::precise_time_ns();\n        if self.is_enabled() {\n            self.record(Sample::new_duration(name, categories, None, start, end - start));\n        }\n        result\n    }\n\n    pub fn closure_payload<S, C, P, F, R>(\n        &self,\n        name: S,\n        categories: C,\n        closure: F,\n        payload: P,\n    ) -> R\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n        P: Into<TracePayloadT>,\n        F: FnOnce() -> R,\n    {\n        // TODO: simplify this through the use of scopeguard crate\n        let start = time::precise_time_ns();\n        let result = closure();\n        let end = time::precise_time_ns();\n        if self.is_enabled() {\n            self.record(Sample::new_duration(\n                name,\n                categories,\n                Some(payload.into()),\n                start,\n                end - start,\n            ));\n        }\n        result\n    }\n\n    pub fn samples_cloned_unsorted(&self) -> Vec<Sample> {\n        let all_samples = self.samples.lock().unwrap();\n        if all_samples.is_empty() {\n            return Vec::with_capacity(0);\n        }\n\n        let mut as_vec = Vec::with_capacity(all_samples.len() + 10);\n        let first_sample_timestamp = all_samples.front().map_or(0, |ref s| s.timestamp_us);\n        let tid =\n            all_samples.front().map_or_else(|| sys_tid::current_tid().unwrap(), |ref s| s.tid);\n\n        if let Some(exe_name) = exe_name() {\n            as_vec.push(Sample::new_metadata(\n                first_sample_timestamp,\n                MetadataType::ProcessName { name: exe_name },\n                tid,\n            ));\n        }\n\n        let mut thread_names: HashMap<u64, StrCow> = HashMap::new();\n\n        for sample in all_samples.iter() {\n            if let Some(ref thread_name) = sample.thread_name {\n                let previous_name = thread_names.insert(sample.tid, thread_name.clone());\n                if previous_name.is_none() || previous_name.unwrap() != *thread_name {\n                    as_vec.push(Sample::new_metadata(\n                        first_sample_timestamp,\n                        MetadataType::ThreadName { name: thread_name.to_string() },\n                        sample.tid,\n                    ));\n                }\n            }\n        }\n\n        as_vec.extend(all_samples.iter().cloned());\n        as_vec\n    }\n\n    #[inline]\n    pub fn samples_cloned_sorted(&self) -> Vec<Sample> {\n        let mut samples = self.samples_cloned_unsorted();\n        samples.sort_unstable();\n        samples\n    }\n\n    pub fn save<P: AsRef<Path>>(\n        &self,\n        path: P,\n        sort: bool,\n    ) -> Result<(), chrome_trace_dump::Error> {\n        let traces = if sort { samples_cloned_sorted() } else { samples_cloned_unsorted() };\n        let path: &Path = path.as_ref();\n\n        if path.exists() {\n            return Err(chrome_trace_dump::Error::already_exists());\n        }\n\n        let mut trace_file = fs::File::create(&path)?;\n\n        chrome_trace_dump::serialize(&traces, &mut trace_file)\n    }\n}"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field":["Deserialize"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor":["Deserialize"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor":["Deserialize"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field":["Deserialize"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor":["Deserialize"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor":["Deserialize"],"_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith":["Serialize"],"chrome_trace_dump::ChromeTraceArrayEntries":["Clone","Debug","Deserialize"],"chrome_trace_dump::Error":["Debug","impl Error {\n    pub fn already_exists() -> Error {\n        Error::Io(IOError::from(IOErrorKind::AlreadyExists))\n    }\n}","impl From<IOError> for Error {\n    fn from(e: IOError) -> Error {\n        Error::Io(e)\n    }\n}","impl From<String> for Error {\n    fn from(e: String) -> Error {\n        Error::DecodingFormat(e)\n    }\n}","impl From<serde_json::Error> for Error {\n    fn from(e: serde_json::Error) -> Error {\n        Error::Json(e)\n    }\n}"],"fixed_lifo_deque::FixedLifoDeque":["Clone","Debug","impl<'a, T: 'a + Copy> Extend<&'a T> for FixedLifoDeque<T> {\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n        self.extend(iter.into_iter().cloned());\n    }\n}","impl<A: Eq> Eq for FixedLifoDeque<A> {}","impl<A: Hash> Hash for FixedLifoDeque<A> {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.storage.hash(state);\n    }\n}","impl<A: Ord> Ord for FixedLifoDeque<A> {\n    #[inline]\n    fn cmp(&self, other: &FixedLifoDeque<A>) -> Ordering {\n        self.storage.cmp(&other.storage)\n    }\n}","impl<A: PartialEq> PartialEq for FixedLifoDeque<A> {\n    #[inline]\n    fn eq(&self, other: &FixedLifoDeque<A>) -> bool {\n        self.storage == other.storage\n    }\n}","impl<A: PartialOrd> PartialOrd for FixedLifoDeque<A> {\n    #[inline]\n    fn partial_cmp(&self, other: &FixedLifoDeque<A>) -> Option<Ordering> {\n        self.storage.partial_cmp(&other.storage)\n    }\n}","impl<A> Extend<A> for FixedLifoDeque<A> {\n    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n        for elt in iter {\n            self.push_back(elt);\n        }\n    }\n}","impl<A> Index<usize> for FixedLifoDeque<A> {\n    type Output = A;\n\n    #[inline]\n    fn index(&self, index: usize) -> &A {\n        &self.storage[index]\n    }\n}","impl<A> IndexMut<usize> for FixedLifoDeque<A> {\n    #[inline]\n    fn index_mut(&mut self, index: usize) -> &mut A {\n        &mut self.storage[index]\n    }\n}","impl<T: Clone> FixedLifoDeque<T> {\n    /// Resizes a fixed queue.  This doesn't change the limit so the resize is\n    /// capped to the limit.  Additionally, resizing drops the elements from the\n    /// front unlike with a regular VecDeque.\n    pub fn resize(&mut self, new_len: usize, value: T) {\n        if new_len < self.len() {\n            let to_drop = self.len() - new_len;\n            self.storage.drain(..to_drop);\n        } else {\n            self.storage.resize(cmp::min(self.limit, new_len), value);\n        }\n    }\n}","impl<T> FixedLifoDeque<T> {\n    /// Constructs a ring buffer that will reject all insertions as no-ops.\n    /// This also construct the underlying VecDeque with_capacity(0) which\n    /// in the current stdlib implementation allocates 2 Ts.\n    #[inline]\n    pub fn new() -> Self {\n        FixedLifoDeque::with_limit(0)\n    }\n\n    /// Constructs a fixed size ring buffer with the given number of elements.\n    /// Attempts to insert more than this number of elements will cause excess\n    /// elements to first be evicted in FIFO order (i.e. from the front).\n    pub fn with_limit(n: usize) -> Self {\n        FixedLifoDeque { storage: VecDeque::with_capacity(n), limit: n }\n    }\n\n    /// This sets a new limit on the container.  Excess elements are dropped in\n    /// FIFO order.  The new capacity is reset to the requested limit which will\n    /// likely result in re-allocation + copies/clones even if the limit\n    /// shrinks.\n    pub fn reset_limit(&mut self, n: usize) {\n        if n < self.limit {\n            let overflow = self.limit - n;\n            self.drop_excess_for_inserting(overflow);\n        }\n        self.limit = n;\n        self.storage.reserve_exact(n);\n        self.storage.shrink_to_fit();\n        debug_assert!(self.storage.len() <= self.limit);\n    }\n\n    /// Returns the current limit this ring buffer is configured with.\n    #[inline]\n    pub fn limit(&self) -> usize {\n        self.limit\n    }\n\n    #[inline]\n    pub fn get(&self, index: usize) -> Option<&T> {\n        self.storage.get(index)\n    }\n\n    #[inline]\n    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n        self.storage.get_mut(index)\n    }\n\n    #[inline]\n    pub fn swap(&mut self, i: usize, j: usize) {\n        self.storage.swap(i, j);\n    }\n\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        self.limit\n    }\n\n    #[inline]\n    pub fn iter(&self) -> Iter<T> {\n        self.storage.iter()\n    }\n\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        self.storage.iter_mut()\n    }\n\n    /// Returns a tuple of 2 slices that represents the ring buffer. [0] is the\n    /// beginning of the buffer to the physical end of the array or the last\n    /// element (whichever comes first).  [1] is the continuation of [0] if the\n    /// ring buffer has wrapped the contiguous storage.\n    #[inline]\n    pub fn as_slices(&self) -> (&[T], &[T]) {\n        self.storage.as_slices()\n    }\n\n    #[inline]\n    pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n        self.storage.as_mut_slices()\n    }\n\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.storage.len()\n    }\n\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.storage.is_empty()\n    }\n\n    #[inline]\n    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n    where\n        R: RangeBounds<usize>,\n    {\n        self.storage.drain(range)\n    }\n\n    #[inline]\n    pub fn clear(&mut self) {\n        self.storage.clear();\n    }\n\n    #[inline]\n    pub fn contains(&self, x: &T) -> bool\n    where\n        T: PartialEq<T>,\n    {\n        self.storage.contains(x)\n    }\n\n    #[inline]\n    pub fn front(&self) -> Option<&T> {\n        self.storage.front()\n    }\n\n    #[inline]\n    pub fn front_mut(&mut self) -> Option<&mut T> {\n        self.storage.front_mut()\n    }\n\n    #[inline]\n    pub fn back(&self) -> Option<&T> {\n        self.storage.back()\n    }\n\n    #[inline]\n    pub fn back_mut(&mut self) -> Option<&mut T> {\n        self.storage.back_mut()\n    }\n\n    #[inline]\n    fn drop_excess_for_inserting(&mut self, n_to_be_inserted: usize) {\n        if self.storage.len() + n_to_be_inserted > self.limit {\n            let overflow =\n                self.storage.len().min(self.storage.len() + n_to_be_inserted - self.limit);\n            self.storage.drain(..overflow);\n        }\n    }\n\n    /// Always an O(1) operation.  Memory is never reclaimed.\n    #[inline]\n    pub fn pop_front(&mut self) -> Option<T> {\n        self.storage.pop_front()\n    }\n\n    /// Always an O(1) operation.  If the number of elements is at the limit,\n    /// the element at the front is overwritten.\n    ///\n    /// Post condition: The number of elements is <= limit\n    pub fn push_back(&mut self, value: T) {\n        self.drop_excess_for_inserting(1);\n        self.storage.push_back(value);\n        // For when limit == 0\n        self.drop_excess_for_inserting(0);\n    }\n\n    /// Always an O(1) operation.  Memory is never reclaimed.\n    #[inline]\n    pub fn pop_back(&mut self) -> Option<T> {\n        self.storage.pop_back()\n    }\n\n    #[inline]\n    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n        self.storage.swap_remove_back(index)\n    }\n\n    #[inline]\n    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n        self.storage.swap_remove_front(index)\n    }\n\n    /// Always an O(1) operation.\n    #[inline]\n    pub fn remove(&mut self, index: usize) -> Option<T> {\n        self.storage.remove(index)\n    }\n\n    pub fn split_off(&mut self, at: usize) -> FixedLifoDeque<T> {\n        FixedLifoDeque { storage: self.storage.split_off(at), limit: self.limit }\n    }\n\n    /// Always an O(m) operation where m is the length of `other'.\n    pub fn append(&mut self, other: &mut VecDeque<T>) {\n        self.drop_excess_for_inserting(other.len());\n        self.storage.append(other);\n        // For when limit == 0\n        self.drop_excess_for_inserting(0);\n    }\n\n    #[inline]\n    pub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n        self.storage.retain(f);\n    }\n}","impl<T> IntoIterator for FixedLifoDeque<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Consumes the list into a front-to-back iterator yielding elements by\n    /// value.\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n        self.storage.into_iter()\n    }\n}"],"std::vec::Vec":["impl StringArrayEq<[&'static str]> for Vec<String> {\n    fn arr_eq(&self, other: &[&'static str]) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        for i in 0..self.len() {\n            if self[i] != other[i] {\n                return false;\n            }\n        }\n        true\n    }\n}"]},"single_path_import":{},"srcs":{"<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Iter<'a, T>{\n        self.storage.iter()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> IterMut<'a, T>{\n        self.storage.iter_mut()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<&'static [&'static str] as StringArrayEq<std::vec::Vec<std::string::String>>>::arr_eq":["fn arr_eq(&self, other: &Vec<String>) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n        for i in 0..self.len() {\n            if self[i] != other[i] {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::expecting":["fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n                formatter.write_str(\"comma-separated strings\")\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::visit_str":["fn visit_str<E>(self, v: &str) -> Result<CategoriesT, E>\n            where\n                E: serde::de::Error,{\n                let categories = v.split(',').map(ToString::to_string).collect();\n                Ok(CategoriesT::DynamicArray(categories))\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as serde::Deserialize<'de>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<CategoriesT, D::Error>\n    where\n        D: serde::Deserializer<'de>,{\n        use serde::de::Visitor;\n        struct CategoriesTVisitor;\n\n        impl<'de> Visitor<'de> for CategoriesTVisitor {\n            type Value = CategoriesT;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"comma-separated strings\")\n            }\n\n            fn visit_str<E>(self, v: &str) -> Result<CategoriesT, E>\n            where\n                E: serde::de::Error,\n            {\n                let categories = v.split(',').map(ToString::to_string).collect();\n                Ok(CategoriesT::DynamicArray(categories))\n            }\n        }\n\n        deserializer.deserialize_str(CategoriesTVisitor)\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor":["struct CategoriesTVisitor;","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as serde::Serialize>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,{\n        self.join(\",\").serialize(serializer)\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::cmp::PartialEq>::eq":["fn eq(&self, other: &CategoriesT) -> bool{\n        match *self {\n            CategoriesT::StaticArray(ref self_arr) => match *other {\n                CategoriesT::StaticArray(ref other_arr) => self_arr.eq(other_arr),\n                CategoriesT::DynamicArray(ref other_arr) => self_arr.arr_eq(other_arr),\n            },\n            CategoriesT::DynamicArray(ref self_arr) => match *other {\n                CategoriesT::StaticArray(ref other_arr) => self_arr.arr_eq(other_arr),\n                CategoriesT::DynamicArray(ref other_arr) => self_arr.eq(other_arr),\n            },\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 0]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 10]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 1]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 2]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 3]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 4]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 5]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 6]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 7]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 8]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<&'static [&'static str; 9]>>::from":["fn from(c: &'static [&'static str; $num_args]) -> CategoriesT{\n                CategoriesT::StaticArray(c)\n            }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<CategoriesT as std::convert::From<std::vec::Vec<std::string::String>>>::from":["fn from(c: Vec<String>) -> CategoriesT{\n        CategoriesT::DynamicArray(c)\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<Sample as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Sample) -> cmp::Ordering{\n        self.timestamp_us.cmp(&other.timestamp_us)\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<Sample as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Sample) -> bool{\n        self.timestamp_us == other.timestamp_us\n            && self.name == other.name\n            && self.categories == other.categories\n            && self.pid == other.pid\n            && self.tid == other.tid\n            && self.event_type == other.event_type\n            && self.args == other.args\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<Sample as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Sample) -> Option<cmp::Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<Sample as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, state: &mut H){\n        (self.pid, self.timestamp_us).hash(state);\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<SampleGuard<'a> as std::ops::Drop>::drop":["fn drop(&mut self){\n        if let Some(ref mut trace) = self.trace {\n            let mut sample = self.sample.take().unwrap();\n            sample.timestamp_us = ns_to_us(time::precise_time_ns());\n            sample.event_type = SampleEventType::DurationEnd;\n            trace.record(sample);\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"<TRACE as lazy_static::LazyStatic>::initialize":["fn initialize(lazy: &Self){\n                let _ = &**lazy;\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<TRACE as lazy_static::__Deref>::deref":["fn deref(&self) -> &$T{\n                #[inline(always)]\n                fn __static_ref_initialize() -> $T { $e }\n\n                #[inline(always)]\n                fn __stability() -> &'static $T {\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }\n                __stability()\n            }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<TRACE as lazy_static::__Deref>::deref::__stability":["#[inline(always)]\nfn __stability() -> &'static $T{\n                    __lazy_static_create!(LAZY, $T);\n                    LAZY.get(__static_ref_initialize)\n                }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<TRACE as lazy_static::__Deref>::deref::__static_ref_initialize":["#[inline(always)]\nfn __static_ref_initialize() -> $T{ $e }","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["Deserialize","Real(LocalPath(\"trace/src/lib.rs\"))"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["Deserialize","Real(LocalPath(\"trace/src/lib.rs\"))"],"<chrome_trace_dump::Error as std::convert::From<serde_json::Error>>::from":["fn from(e: serde_json::Error) -> Error{\n        Error::Json(e)\n    }","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"<chrome_trace_dump::Error as std::convert::From<std::io::Error>>::from":["fn from(e: IOError) -> Error{\n        Error::Io(e)\n    }","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"<chrome_trace_dump::Error as std::convert::From<std::string::String>>::from":["fn from(e: String) -> Error{\n        Error::DecodingFormat(e)\n    }","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::Ord>::cmp":["#[inline]\nfn cmp(&self, other: &FixedLifoDeque<A>) -> Ordering{\n        self.storage.cmp(&other.storage)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &FixedLifoDeque<A>) -> bool{\n        self.storage == other.storage\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialOrd>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &FixedLifoDeque<A>) -> Option<Ordering>{\n        self.storage.partial_cmp(&other.storage)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::hash::Hash>::hash":["#[inline]\nfn hash<H: Hasher>(&self, state: &mut H){\n        self.storage.hash(state);\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::iter::Extend<A>>::extend":["fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T){\n        for elt in iter {\n            self.push_back(elt);\n        }\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::Index<usize>>::index":["#[inline]\nfn index(&self, index: usize) -> &A{\n        &self.storage[index]\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::IndexMut<usize>>::index_mut":["#[inline]\nfn index_mut(&mut self, index: usize) -> &mut A{\n        &mut self.storage[index]\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::Extend<&'a T>>::extend":["fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I){\n        self.extend(iter.into_iter().cloned());\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":["/// Consumes the list into a front-to-back iterator yielding elements by\n/// value.\n#[inline]\nfn into_iter(self) -> IntoIter<T>{\n        self.storage.into_iter()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"<std::vec::Vec<std::string::String> as StringArrayEq<[&'static str]>>::arr_eq":["fn arr_eq(&self, other: &[&'static str]) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n\n        for i in 0..self.len() {\n            if self[i] != other[i] {\n                return false;\n            }\n        }\n        true\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"CategoriesT":["pub enum CategoriesT {\n    StaticArray(&'static [&'static str]),\n    DynamicArray(Vec<String>),\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"CategoriesT::join":["pub fn join(&self, sep: &str) -> String{\n        match *self {\n            CategoriesT::StaticArray(ref arr) => arr.join(sep),\n            CategoriesT::DynamicArray(ref vec) => vec.join(sep),\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Config":["/// How tracing should be configured.\npub struct Config {\n    sample_limit_count: usize,\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"Config::default":["/// The default amount of storage to allocate for tracing.  Currently 1 MB.\npub fn default() -> Self{\n        // 1 MB\n        Self::with_limit_bytes(1 * 1024 * 1024)\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Config::max_samples":["/// The maximum number of samples that should be stored.\npub fn max_samples(self) -> usize{\n        self.sample_limit_count\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Config::max_size_in_bytes":["/// The maximum amount of space the tracing data will take up.  This does\n/// not account for any overhead of storing the data itself (i.e. pointer to\n/// the heap, counters, etc); just the data itself.\npub fn max_size_in_bytes(self) -> usize{\n        self.sample_limit_count * size_of::<Sample>()\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Config::with_limit_bytes":["/// The maximum number of bytes the tracing data should take up.  This limit\n/// won't be exceeded by the underlying storage itself (i.e. rounds down).\npub fn with_limit_bytes(size: usize) -> Self{\n        Self::with_limit_count(size / size_of::<Sample>())\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Config::with_limit_count":["/// The maximum number of entries the tracing data should allow.  Total\n/// storage allocated will be limit * size_of<Sample>\npub fn with_limit_count(limit: usize) -> Self{\n        Self { sample_limit_count: limit }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"MetadataType":["enum MetadataType {\n    ProcessName {\n        name: String,\n    },\n    #[allow(dead_code)]\n    ProcessLabels {\n        labels: String,\n    },\n    #[allow(dead_code)]\n    ProcessSortIndex {\n        sort_index: i32,\n    },\n    ThreadName {\n        name: String,\n    },\n    #[allow(dead_code)]\n    ThreadSortIndex {\n        sort_index: i32,\n    },\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"MetadataType::consume":["fn consume(self) -> (Option<String>, Option<i32>){\n        match self {\n            MetadataType::ProcessName { name } => (Some(name), None),\n            MetadataType::ThreadName { name } => (Some(name), None),\n            MetadataType::ProcessSortIndex { sort_index } => (None, Some(sort_index)),\n            MetadataType::ThreadSortIndex { sort_index } => (None, Some(sort_index)),\n            MetadataType::ProcessLabels { .. } => (None, None),\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"MetadataType::sample_name":["fn sample_name(&self) -> &'static str{\n        match *self {\n            MetadataType::ProcessName { .. } => \"process_name\",\n            MetadataType::ProcessLabels { .. } => \"process_labels\",\n            MetadataType::ProcessSortIndex { .. } => \"process_sort_index\",\n            MetadataType::ThreadName { .. } => \"thread_name\",\n            MetadataType::ThreadSortIndex { .. } => \"thread_sort_index\",\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Sample":["/// Stores the relevant data about a sample for later serialization.\n/// The payload associated with any sample is by default a string but may be\n/// configured via the `json_payload` feature (there is an\n/// associated performance hit across the board for turning it on).\npub struct Sample {\n    /// The name of the event to be shown.\n    pub name: StrCow,\n    /// List of categories the event applies to.\n    #[serde(rename = \"cat\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub categories: Option<CategoriesT>,\n    /// When was the sample started.\n    #[serde(rename = \"ts\")]\n    pub timestamp_us: u64,\n    /// What kind of sample this is.\n    #[serde(rename = \"ph\")]\n    #[serde(serialize_with = \"serialize_event_type\")]\n    #[serde(deserialize_with = \"deserialize_event_type\")]\n    pub event_type: SampleEventType,\n    #[serde(rename = \"dur\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub duration_us: Option<u64>,\n    /// The process the sample was captured in.\n    pub pid: u64,\n    /// The thread the sample was captured on.  Omitted for Metadata events that\n    /// want to set the process name (if provided then sets the thread name).\n    pub tid: u64,\n    #[serde(skip_serializing)]\n    pub thread_name: Option<StrCow>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub args: Option<SampleArgs>,\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"Sample::new_duration":["/// Constructs a Duration sample.  For use via xi_trace::closure.\npub fn new_duration<S, C>(\n        name: S,\n        categories: C,\n        payload: Option<TracePayloadT>,\n        start_ns: u64,\n        duration_ns: u64,\n    ) -> Self\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,{\n        Self {\n            name: name.into(),\n            categories: Some(categories.into()),\n            timestamp_us: ns_to_us(start_ns),\n            event_type: SampleEventType::CompleteDuration,\n            duration_us: Some(ns_to_us(duration_ns)),\n            tid: sys_tid::current_tid().unwrap(),\n            thread_name: Sample::thread_name(),\n            pid: sys_pid::current_pid(),\n            args: Some(SampleArgs { payload, metadata_name: None, metadata_sort_index: None }),\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Sample::new_duration_marker":["/// Constructs a Begin or End sample.  Should not be used directly.  Instead\n/// should be constructed via SampleGuard.\npub fn new_duration_marker<S, C>(\n        name: S,\n        categories: C,\n        payload: Option<TracePayloadT>,\n        event_type: SampleEventType,\n    ) -> Self\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,{\n        Self {\n            name: name.into(),\n            categories: Some(categories.into()),\n            timestamp_us: ns_to_us(time::precise_time_ns()),\n            event_type,\n            duration_us: None,\n            tid: sys_tid::current_tid().unwrap(),\n            thread_name: Sample::thread_name(),\n            pid: sys_pid::current_pid(),\n            args: Some(SampleArgs { payload, metadata_name: None, metadata_sort_index: None }),\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Sample::new_instant":["/// Constructs an instantaneous sample.\npub fn new_instant<S, C>(name: S, categories: C, payload: Option<TracePayloadT>) -> Self\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,{\n        Self {\n            name: name.into(),\n            categories: Some(categories.into()),\n            timestamp_us: ns_to_us(time::precise_time_ns()),\n            event_type: SampleEventType::Instant,\n            duration_us: None,\n            tid: sys_tid::current_tid().unwrap(),\n            thread_name: Sample::thread_name(),\n            pid: sys_pid::current_pid(),\n            args: Some(SampleArgs { payload, metadata_name: None, metadata_sort_index: None }),\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Sample::new_metadata":["fn new_metadata(timestamp_ns: u64, meta: MetadataType, tid: u64) -> Self{\n        let sample_name = to_cow_str(meta.sample_name());\n        let (metadata_name, sort_index) = meta.consume();\n\n        Self {\n            name: sample_name,\n            categories: None,\n            timestamp_us: ns_to_us(timestamp_ns),\n            event_type: SampleEventType::Metadata,\n            duration_us: None,\n            tid,\n            thread_name: None,\n            pid: sys_pid::current_pid(),\n            args: Some(SampleArgs {\n                payload: None,\n                metadata_name: metadata_name.map(Cow::Owned),\n                metadata_sort_index: sort_index,\n            }),\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Sample::thread_name":["fn thread_name() -> Option<StrCow>{\n        let thread = std::thread::current();\n        thread.name().map(|ref s| to_cow_str((*s).to_string()))\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"SampleArgs":["pub struct SampleArgs {\n    /// An arbitrary payload to associate with the sample.  The type is\n    /// controlled by features (default string).\n    #[serde(rename = \"xi_payload\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payload: Option<TracePayloadT>,\n\n    /// The name to associate with the pid/tid.  Whether it's associated with\n    /// the pid or the tid depends on the name of the event\n    /// via process_name/thread_name respectively.\n    #[serde(rename = \"name\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub metadata_name: Option<StrCow>,\n\n    /// Sorting priority between processes/threads in the view.\n    #[serde(rename = \"sort_index\")]\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub metadata_sort_index: Option<i32>,\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"SampleEventType":["pub enum SampleEventType {\n    DurationBegin,\n    DurationEnd,\n    CompleteDuration,\n    Instant,\n    AsyncStart,\n    AsyncInstant,\n    AsyncEnd,\n    FlowStart,\n    FlowInstant,\n    FlowEnd,\n    ObjectCreated,\n    ObjectSnapshot,\n    ObjectDestroyed,\n    Metadata,\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"SampleEventType::from_chrome_id":["#[inline]\nfn from_chrome_id(symbol: char) -> Self{\n        match symbol {\n            'B' => SampleEventType::DurationBegin,\n            'E' => SampleEventType::DurationEnd,\n            'X' => SampleEventType::CompleteDuration,\n            'i' => SampleEventType::Instant,\n            'b' => SampleEventType::AsyncStart,\n            'n' => SampleEventType::AsyncInstant,\n            'e' => SampleEventType::AsyncEnd,\n            's' => SampleEventType::FlowStart,\n            't' => SampleEventType::FlowInstant,\n            'f' => SampleEventType::FlowEnd,\n            'N' => SampleEventType::ObjectCreated,\n            'O' => SampleEventType::ObjectSnapshot,\n            'D' => SampleEventType::ObjectDestroyed,\n            'M' => SampleEventType::Metadata,\n            _ => panic!(\"Unexpected chrome sample type '{}'\", symbol),\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"SampleEventType::into_chrome_id":["#[inline]\nfn into_chrome_id(self) -> char{\n        match self {\n            SampleEventType::DurationBegin => 'B',\n            SampleEventType::DurationEnd => 'E',\n            SampleEventType::CompleteDuration => 'X',\n            SampleEventType::Instant => 'i',\n            SampleEventType::AsyncStart => 'b',\n            SampleEventType::AsyncInstant => 'n',\n            SampleEventType::AsyncEnd => 'e',\n            SampleEventType::FlowStart => 's',\n            SampleEventType::FlowInstant => 't',\n            SampleEventType::FlowEnd => 'f',\n            SampleEventType::ObjectCreated => 'N',\n            SampleEventType::ObjectSnapshot => 'O',\n            SampleEventType::ObjectDestroyed => 'D',\n            SampleEventType::Metadata => 'M',\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"SampleGuard":["#[must_use]\npub struct SampleGuard<'a> {\n    sample: Option<Sample>,\n    trace: Option<&'a Trace>,\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"SampleGuard::<'a>::new":["#[inline]\nfn new<S, C>(trace: &'a Trace, name: S, categories: C, payload: Option<TracePayloadT>) -> Self\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,{\n        // TODO(vlovich): optimize this path to use the Complete event type\n        // rather than emitting an explicit start/stop to reduce the size of\n        // the generated JSON.\n        let guard = Self {\n            sample: Some(Sample::new_duration_marker(\n                name,\n                categories,\n                payload,\n                SampleEventType::DurationBegin,\n            )),\n            trace: Some(&trace),\n        };\n        trace.record(guard.sample.as_ref().unwrap().clone());\n        guard\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"SampleGuard::<'a>::new_disabled":["#[inline]\npub fn new_disabled() -> Self{\n        Self { sample: None, trace: None }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"StringArrayEq":["trait StringArrayEq<Rhs: ?Sized = Self> {\n    fn arr_eq(&self, other: &Rhs) -> bool;\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"TRACE":["#[allow(missing_copy_implementations)]\n#[allow(non_camel_case_types)]\n#[allow(dead_code)]\nstruct $N {__private_field: ()}","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))"],"Trace":["/// Stores the tracing data.\npub struct Trace {\n    enabled: AtomicBool,\n    samples: Mutex<FixedLifoDeque<Sample>>,\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::block":["pub fn block<S, C>(&self, name: S, categories: C) -> SampleGuard\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,{\n        if !self.is_enabled() {\n            SampleGuard::new_disabled()\n        } else {\n            SampleGuard::new(&self, name, categories, None)\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::block_payload":["pub fn block_payload<S, C, P>(&self, name: S, categories: C, payload: P) -> SampleGuard\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n        P: Into<TracePayloadT>,{\n        if !self.is_enabled() {\n            SampleGuard::new_disabled()\n        } else {\n            SampleGuard::new(&self, name, categories, Some(payload.into()))\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::closure":["pub fn closure<S, C, F, R>(&self, name: S, categories: C, closure: F) -> R\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n        F: FnOnce() -> R,{\n        // TODO: simplify this through the use of scopeguard crate\n        let start = time::precise_time_ns();\n        let result = closure();\n        let end = time::precise_time_ns();\n        if self.is_enabled() {\n            self.record(Sample::new_duration(name, categories, None, start, end - start));\n        }\n        result\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::closure_payload":["pub fn closure_payload<S, C, P, F, R>(\n        &self,\n        name: S,\n        categories: C,\n        closure: F,\n        payload: P,\n    ) -> R\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n        P: Into<TracePayloadT>,\n        F: FnOnce() -> R,{\n        // TODO: simplify this through the use of scopeguard crate\n        let start = time::precise_time_ns();\n        let result = closure();\n        let end = time::precise_time_ns();\n        if self.is_enabled() {\n            self.record(Sample::new_duration(\n                name,\n                categories,\n                Some(payload.into()),\n                start,\n                end - start,\n            ));\n        }\n        result\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::disable":["pub fn disable(&self){\n        let mut all_samples = self.samples.lock().unwrap();\n        all_samples.reset_limit(0);\n        self.enabled.store(false, AtomicOrdering::Relaxed);\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::disabled":["pub fn disabled() -> Self{\n        Self { enabled: AtomicBool::new(false), samples: Mutex::new(FixedLifoDeque::new()) }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::enable":["#[inline]\npub fn enable(&self){\n        self.enable_config(Config::default());\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::enable_config":["pub fn enable_config(&self, config: Config){\n        let mut all_samples = self.samples.lock().unwrap();\n        all_samples.reset_limit(config.max_samples());\n        self.enabled.store(true, AtomicOrdering::Relaxed);\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::enabled":["pub fn enabled(config: Config) -> Self{\n        Self {\n            enabled: AtomicBool::new(true),\n            samples: Mutex::new(FixedLifoDeque::with_limit(config.max_samples())),\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::get_samples_count":["/// Generally racy since the underlying storage might be mutated in a separate thread.\n/// Exposed for unit tests.\npub fn get_samples_count(&self) -> usize{\n        self.samples.lock().unwrap().len()\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::get_samples_limit":["/// Exposed for unit tests only.\npub fn get_samples_limit(&self) -> usize{\n        self.samples.lock().unwrap().limit()\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::instant":["pub fn instant<S, C>(&self, name: S, categories: C)\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,{\n        if self.is_enabled() {\n            self.record(Sample::new_instant(name, categories, None));\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::instant_payload":["pub fn instant_payload<S, C, P>(&self, name: S, categories: C, payload: P)\n    where\n        S: Into<StrCow>,\n        C: Into<CategoriesT>,\n        P: Into<TracePayloadT>,{\n        if self.is_enabled() {\n            self.record(Sample::new_instant(name, categories, Some(payload.into())));\n        }\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::is_enabled":["pub fn is_enabled(&self) -> bool{\n        self.enabled.load(AtomicOrdering::Relaxed)\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::record":["#[inline]\npub(crate) fn record(&self, sample: Sample){\n        let mut all_samples = self.samples.lock().unwrap();\n        all_samples.push_back(sample);\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::samples_cloned_sorted":["#[inline]\npub fn samples_cloned_sorted(&self) -> Vec<Sample>{\n        let mut samples = self.samples_cloned_unsorted();\n        samples.sort_unstable();\n        samples\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::samples_cloned_unsorted":["pub fn samples_cloned_unsorted(&self) -> Vec<Sample>{\n        let all_samples = self.samples.lock().unwrap();\n        if all_samples.is_empty() {\n            return Vec::with_capacity(0);\n        }\n\n        let mut as_vec = Vec::with_capacity(all_samples.len() + 10);\n        let first_sample_timestamp = all_samples.front().map_or(0, |ref s| s.timestamp_us);\n        let tid =\n            all_samples.front().map_or_else(|| sys_tid::current_tid().unwrap(), |ref s| s.tid);\n\n        if let Some(exe_name) = exe_name() {\n            as_vec.push(Sample::new_metadata(\n                first_sample_timestamp,\n                MetadataType::ProcessName { name: exe_name },\n                tid,\n            ));\n        }\n\n        let mut thread_names: HashMap<u64, StrCow> = HashMap::new();\n\n        for sample in all_samples.iter() {\n            if let Some(ref thread_name) = sample.thread_name {\n                let previous_name = thread_names.insert(sample.tid, thread_name.clone());\n                if previous_name.is_none() || previous_name.unwrap() != *thread_name {\n                    as_vec.push(Sample::new_metadata(\n                        first_sample_timestamp,\n                        MetadataType::ThreadName { name: thread_name.to_string() },\n                        sample.tid,\n                    ));\n                }\n            }\n        }\n\n        as_vec.extend(all_samples.iter().cloned());\n        as_vec\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"Trace::save":["pub fn save<P: AsRef<Path>>(\n        &self,\n        path: P,\n        sort: bool,\n    ) -> Result<(), chrome_trace_dump::Error>{\n        let traces = if sort { samples_cloned_sorted() } else { samples_cloned_unsorted() };\n        let path: &Path = path.as_ref();\n\n        if path.exists() {\n            return Err(chrome_trace_dump::Error::already_exists());\n        }\n\n        let mut trace_file = fs::File::create(&path)?;\n\n        chrome_trace_dump::serialize(&traces, &mut trace_file)\n    }","Real(LocalPath(\"trace/src/lib.rs\"))"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"trace/src/lib.rs\"))"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"trace/src/lib.rs\"))"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"trace/src/lib.rs\"))"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"trace/src/lib.rs\"))"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"trace/src/lib.rs\"))"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"trace/src/lib.rs\"))"],"_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith":["Serialize","Real(LocalPath(\"trace/src/lib.rs\"))"],"chrome_trace_dump::ChromeTraceArrayEntries":["#[serde(untagged)]\nenum ChromeTraceArrayEntries {\n    Array(Vec<Sample>),\n}","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"chrome_trace_dump::Error":["pub enum Error {\n    Io(IOError),\n    Json(serde_json::Error),\n    DecodingFormat(String),\n}","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"chrome_trace_dump::Error::already_exists":["pub fn already_exists() -> Error{\n        Error::Io(IOError::from(IOErrorKind::AlreadyExists))\n    }","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"chrome_trace_dump::decode":["pub fn decode(samples: serde_json::Value) -> Result<Vec<Sample>, Error>{\n    serde_json::from_value(samples).map_err(Error::Json)\n}","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"chrome_trace_dump::deserialize":["pub fn deserialize<R>(input: R) -> Result<Vec<Sample>, Error>\nwhere\n    R: Read,{\n    serde_json::from_reader(input).map_err(Error::Json)\n}","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"chrome_trace_dump::serialize":["/// This serializes the samples into the [Chrome trace event format](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwiJlZmDguXYAhUD4GMKHVmEDqIQFggpMAA&url=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU%2Fpreview&usg=AOvVaw0tBFlVbDVBikdzLqgrWK3g).\n///\n/// # Arguments\n/// `samples` - Something that can be converted into an iterator of sample\n/// references.\n/// `format` - Which trace format to save the data in.  There are four total\n/// formats described in the document.\n/// `output` - Where to write the serialized result.\n///\n/// # Returns\n/// A `Result<(), Error>` that indicates if serialization was successful or the\n/// details of any error that occured.\n///\n/// # Examples\n/// ```norun\n/// let samples = xi_trace::samples_cloned_sorted();\n/// let mut serialized = Vec::<u8>::new();\n/// serialize(samples.iter(), serialized);\n/// ```\npub fn serialize<W>(samples: &Vec<Sample>, output: W) -> Result<(), Error>\nwhere\n    W: Write,{\n    serde_json::to_writer(output, samples).map_err(Error::Json)\n}","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"chrome_trace_dump::to_value":["pub fn to_value(samples: &Vec<Sample>) -> Result<serde_json::Value, Error>{\n    serde_json::to_value(samples).map_err(Error::Json)\n}","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))"],"deserialize_event_type":["fn deserialize_event_type<'de, D>(d: D) -> Result<SampleEventType, D::Error>\nwhere\n    D: serde::Deserializer<'de>,{\n    serde::Deserialize::deserialize(d).map(SampleEventType::from_chrome_id)\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"disable_tracing":["/// Disable tracing.  This clears all trace data (& frees the memory).\n#[inline]\npub fn disable_tracing(){\n    TRACE.disable();\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"enable_tracing":["/// Enable tracing with the default configuration.  See Config::default.\n/// Tracing is disabled initially on program launch.\n#[inline]\npub fn enable_tracing(){\n    TRACE.enable();\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"enable_tracing_with_config":["/// Enable tracing with a specific configuration. Tracing is disabled initially\n/// on program launch.\n#[inline]\npub fn enable_tracing_with_config(config: Config){\n    TRACE.enable_config(config);\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"exe_name":["/// Returns the file name of the EXE if possible, otherwise the full path, or\n/// None if an irrecoverable error occured.\nfn exe_name() -> Option<String>{\n    match std::env::current_exe() {\n        Ok(exe_name) => match exe_name.file_name() {\n            Some(filename) => filename.to_str().map(ToString::to_string),\n            None => {\n                let full_path = exe_name.into_os_string();\n                let full_path_str = full_path.into_string();\n                match full_path_str {\n                    Ok(s) => Some(s),\n                    Err(e) => {\n                        warn!(\"Failed to get string representation: {:?}\", e);\n                        None\n                    }\n                }\n            }\n        },\n        Err(ref e) => {\n            warn!(\"Failed to get path to current exe: {:?}\", e);\n            None\n        }\n    }\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"fixed_lifo_deque::FixedLifoDeque":["/// Provides fixed size ring buffer that overwrites elements in FIFO order on\n/// insertion when full.  API provided is similar to VecDeque & uses a VecDeque\n/// internally. One distinction is that only append-like insertion is allowed.\n/// This means that insert & push_front are not allowed.  The reasoning is that\n/// there is ambiguity on how such functions should operate since it would be\n/// pretty impossible to maintain a FIFO ordering.\n///\n/// All operations that would cause growth beyond the limit drop the appropriate\n/// number of elements from the front.  For example, on a full buffer push_front\n/// replaces the first element.\n///\n/// The removal of elements on operation that would cause excess beyond the\n/// limit happens first to make sure the space is available in the underlying\n/// VecDeque, thus guaranteeing O(1) operations always.\npub struct FixedLifoDeque<T> {\n    storage: VecDeque<T>,\n    limit: usize,\n}","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::append":["/// Always an O(m) operation where m is the length of `other'.\npub fn append(&mut self, other: &mut VecDeque<T>){\n        self.drop_excess_for_inserting(other.len());\n        self.storage.append(other);\n        // For when limit == 0\n        self.drop_excess_for_inserting(0);\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::as_mut_slices":["#[inline]\npub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]){\n        self.storage.as_mut_slices()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::as_slices":["/// Returns a tuple of 2 slices that represents the ring buffer. [0] is the\n/// beginning of the buffer to the physical end of the array or the last\n/// element (whichever comes first).  [1] is the continuation of [0] if the\n/// ring buffer has wrapped the contiguous storage.\n#[inline]\npub fn as_slices(&self) -> (&[T], &[T]){\n        self.storage.as_slices()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::back":["#[inline]\npub fn back(&self) -> Option<&T>{\n        self.storage.back()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::back_mut":["#[inline]\npub fn back_mut(&mut self) -> Option<&mut T>{\n        self.storage.back_mut()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::capacity":["#[inline]\npub fn capacity(&self) -> usize{\n        self.limit\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::clear":["#[inline]\npub fn clear(&mut self){\n        self.storage.clear();\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::contains":["#[inline]\npub fn contains(&self, x: &T) -> bool\n    where\n        T: PartialEq<T>,{\n        self.storage.contains(x)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::drain":["#[inline]\npub fn drain<R>(&mut self, range: R) -> Drain<T>\n    where\n        R: RangeBounds<usize>,{\n        self.storage.drain(range)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::drop_excess_for_inserting":["#[inline]\nfn drop_excess_for_inserting(&mut self, n_to_be_inserted: usize){\n        if self.storage.len() + n_to_be_inserted > self.limit {\n            let overflow =\n                self.storage.len().min(self.storage.len() + n_to_be_inserted - self.limit);\n            self.storage.drain(..overflow);\n        }\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::front":["#[inline]\npub fn front(&self) -> Option<&T>{\n        self.storage.front()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::front_mut":["#[inline]\npub fn front_mut(&mut self) -> Option<&mut T>{\n        self.storage.front_mut()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::get":["#[inline]\npub fn get(&self, index: usize) -> Option<&T>{\n        self.storage.get(index)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::get_mut":["#[inline]\npub fn get_mut(&mut self, index: usize) -> Option<&mut T>{\n        self.storage.get_mut(index)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::is_empty":["#[inline]\npub fn is_empty(&self) -> bool{\n        self.storage.is_empty()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::iter":["#[inline]\npub fn iter(&self) -> Iter<T>{\n        self.storage.iter()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::iter_mut":["#[inline]\npub fn iter_mut(&mut self) -> IterMut<T>{\n        self.storage.iter_mut()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::len":["#[inline]\npub fn len(&self) -> usize{\n        self.storage.len()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::limit":["/// Returns the current limit this ring buffer is configured with.\n#[inline]\npub fn limit(&self) -> usize{\n        self.limit\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::new":["/// Constructs a ring buffer that will reject all insertions as no-ops.\n/// This also construct the underlying VecDeque with_capacity(0) which\n/// in the current stdlib implementation allocates 2 Ts.\n#[inline]\npub fn new() -> Self{\n        FixedLifoDeque::with_limit(0)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::pop_back":["/// Always an O(1) operation.  Memory is never reclaimed.\n#[inline]\npub fn pop_back(&mut self) -> Option<T>{\n        self.storage.pop_back()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::pop_front":["/// Always an O(1) operation.  Memory is never reclaimed.\n#[inline]\npub fn pop_front(&mut self) -> Option<T>{\n        self.storage.pop_front()\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::push_back":["/// Always an O(1) operation.  If the number of elements is at the limit,\n/// the element at the front is overwritten.\n///\n/// Post condition: The number of elements is <= limit\npub fn push_back(&mut self, value: T){\n        self.drop_excess_for_inserting(1);\n        self.storage.push_back(value);\n        // For when limit == 0\n        self.drop_excess_for_inserting(0);\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::remove":["/// Always an O(1) operation.\n#[inline]\npub fn remove(&mut self, index: usize) -> Option<T>{\n        self.storage.remove(index)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::reset_limit":["/// This sets a new limit on the container.  Excess elements are dropped in\n/// FIFO order.  The new capacity is reset to the requested limit which will\n/// likely result in re-allocation + copies/clones even if the limit\n/// shrinks.\npub fn reset_limit(&mut self, n: usize){\n        if n < self.limit {\n            let overflow = self.limit - n;\n            self.drop_excess_for_inserting(overflow);\n        }\n        self.limit = n;\n        self.storage.reserve_exact(n);\n        self.storage.shrink_to_fit();\n        debug_assert!(self.storage.len() <= self.limit);\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::resize":["/// Resizes a fixed queue.  This doesn't change the limit so the resize is\n/// capped to the limit.  Additionally, resizing drops the elements from the\n/// front unlike with a regular VecDeque.\npub fn resize(&mut self, new_len: usize, value: T){\n        if new_len < self.len() {\n            let to_drop = self.len() - new_len;\n            self.storage.drain(..to_drop);\n        } else {\n            self.storage.resize(cmp::min(self.limit, new_len), value);\n        }\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::retain":["#[inline]\npub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&T) -> bool,{\n        self.storage.retain(f);\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::split_off":["pub fn split_off(&mut self, at: usize) -> FixedLifoDeque<T>{\n        FixedLifoDeque { storage: self.storage.split_off(at), limit: self.limit }\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::swap":["#[inline]\npub fn swap(&mut self, i: usize, j: usize){\n        self.storage.swap(i, j);\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_back":["#[inline]\npub fn swap_remove_back(&mut self, index: usize) -> Option<T>{\n        self.storage.swap_remove_back(index)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_front":["#[inline]\npub fn swap_remove_front(&mut self, index: usize) -> Option<T>{\n        self.storage.swap_remove_front(index)\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"fixed_lifo_deque::FixedLifoDeque::<T>::with_limit":["/// Constructs a fixed size ring buffer with the given number of elements.\n/// Attempts to insert more than this number of elements will cause excess\n/// elements to first be evicted in FIFO order (i.e. from the front).\npub fn with_limit(n: usize) -> Self{\n        FixedLifoDeque { storage: VecDeque::with_capacity(n), limit: n }\n    }","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))"],"is_enabled":["/// Is tracing enabled.  Technically doesn't guarantee any samples will be\n/// stored as tracing could still be enabled but set with a limit of 0.\n#[inline]\npub fn is_enabled() -> bool{\n    TRACE.is_enabled()\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"ns_to_us":["#[inline]\nfn ns_to_us(ns: u64) -> u64{\n    ns / 1000\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"samples_cloned_sorted":["/// Returns all the samples collected so far ordered chronologically by\n/// creation.  Roughly corresponds to start_ns but instead there's a\n/// monotonically increasing single global integer (when tracing) per creation\n/// of Sample that determines order.\n#[inline]\npub fn samples_cloned_sorted() -> Vec<Sample>{\n    TRACE.samples_cloned_sorted()\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"samples_cloned_unsorted":["/// Returns all the samples collected so far.  There is no guarantee that the\n/// samples are ordered chronologically for several reasons:\n///\n/// 1. Samples that span sections of code may be inserted on end instead of\n/// beginning.\n/// 2. Performance optimizations might have per-thread buffers.  Keeping all\n/// that sorted would be prohibitively expensive.\n/// 3. You may not care about them always being sorted if you're merging samples\n/// from multiple distributed sources (i.e. you want to sort the merged result\n/// rather than just this processe's samples).\n#[inline]\npub fn samples_cloned_unsorted() -> Vec<Sample>{\n    TRACE.samples_cloned_unsorted()\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"samples_len":["#[inline]\npub fn samples_len() -> usize{\n    TRACE.get_samples_count()\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"save":["/// Save tracing data to to supplied path, using the Trace Viewer format. Trace file can be opened\n/// using the Chrome browser by visiting the URL `about:tracing`. If `sorted_chronologically` is\n/// true then sort output traces chronologically by each trace's time of creation.\n#[inline]\npub fn save<P: AsRef<Path>>(path: P, sort: bool) -> Result<(), chrome_trace_dump::Error>{\n    TRACE.save(path, sort)\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"serialize_event_type":["fn serialize_event_type<S>(ph: &SampleEventType, s: S) -> Result<S::Ok, S::Error>\nwhere\n    S: serde::Serializer,{\n    s.serialize_char(ph.into_chrome_id())\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"sys_pid::current_pid":["#[cfg(all(target_family = \"unix\", not(target_os = \"fuchsia\")))]\n#[inline]\npub fn current_pid() -> u64{\n    extern \"C\" {\n        fn getpid() -> libc::pid_t;\n    }\n\n    unsafe { getpid() as u64 }\n}","Real(LocalPath(\"trace/src/sys_pid.rs\"))"],"sys_tid::current_tid":["#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n#[inline]\npub fn current_tid() -> Result<u64, libc::c_int>{\n    unsafe { Ok(libc::syscall(libc::SYS_gettid) as u64) }\n}","Real(LocalPath(\"trace/src/sys_tid.rs\"))"],"to_cow_str":["fn to_cow_str<S>(s: S) -> StrCow\nwhere\n    S: Into<StrCow>,{\n    s.into()\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"trace":["/// Create an instantaneous sample without any payload.  This is the lowest\n/// overhead tracing routine available.\n///\n/// # Performance\n/// The `json_payload` feature makes this ~1.3-~1.5x slower.\n/// See `trace_payload` for a more complete discussion.\n///\n/// # Arguments\n///\n/// * `name` - A string that provides some meaningful name to this sample.\n/// Usage of static strings is encouraged for best performance to avoid copies.\n/// However, anything that can be converted into a Cow string can be passed as\n/// an argument.\n///\n/// * `categories` - A static array of static strings that tags the samples in\n/// some way.\n///\n/// # Examples\n///\n/// ```\n/// xi_trace::trace(\"something happened\", &[\"rpc\", \"response\"]);\n/// ```\n#[inline]\npub fn trace<S, C>(name: S, categories: C)\nwhere\n    S: Into<StrCow>,\n    C: Into<CategoriesT>,{\n    TRACE.instant(name, categories);\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"trace_block":["/// Creates a duration sample.  The sample is finalized (end_ns set) when the\n/// returned value is dropped.  `trace_closure` may be prettier to read.\n///\n/// # Performance\n/// See `trace_payload` for a more complete discussion.\n///\n/// # Arguments\n///\n/// * `name` - A string that provides some meaningful name to this sample.\n/// Usage of static strings is encouraged for best performance to avoid copies.\n/// However, anything that can be converted into a Cow string can be passed as\n/// an argument.\n///\n/// * `categories` - A static array of static strings that tags the samples in\n/// some way.\n///\n/// # Returns\n/// A guard that when dropped will update the Sample with the timestamp & then\n/// record it.\n///\n/// # Examples\n///\n/// ```\n/// fn something_expensive() {\n/// }\n///\n/// fn something_else_expensive() {\n/// }\n///\n/// let trace_guard = xi_trace::trace_block(\"something_expensive\", &[\"rpc\", \"request\"]);\n/// something_expensive();\n/// std::mem::drop(trace_guard); // finalize explicitly if\n///\n/// {\n///     let _guard = xi_trace::trace_block(\"something_else_expensive\", &[\"rpc\", \"response\"]);\n///     something_else_expensive();\n/// }\n/// ```\n#[inline]\npub fn trace_block<'a, S, C>(name: S, categories: C) -> SampleGuard<'a>\nwhere\n    S: Into<StrCow>,\n    C: Into<CategoriesT>,{\n    TRACE.block(name, categories)\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"trace_block_payload":["/// See `trace_block` for how the block works and `trace_payload` for a\n/// discussion on payload.\n#[inline]\npub fn trace_block_payload<'a, S, C, P>(name: S, categories: C, payload: P) -> SampleGuard<'a>\nwhere\n    S: Into<StrCow>,\n    C: Into<CategoriesT>,\n    P: Into<TracePayloadT>,{\n    TRACE.block_payload(name, categories, payload)\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"trace_closure":["/// Creates a duration sample that measures how long the closure took to execute.\n///\n/// # Performance\n/// See `trace_payload` for a more complete discussion.\n///\n/// # Arguments\n///\n/// * `name` - A string that provides some meaningful name to this sample.\n/// Usage of static strings is encouraged for best performance to avoid copies.\n/// However, anything that can be converted into a Cow string can be passed as\n/// an argument.\n///\n/// * `categories` - A static array of static strings that tags the samples in\n/// some way.\n///\n/// # Returns\n/// The result of the closure.\n///\n/// # Examples\n///\n/// ```\n/// fn something_expensive() -> u32 {\n///     0\n/// }\n///\n/// fn something_else_expensive(value: u32) {\n/// }\n///\n/// let result = xi_trace::trace_closure(\"something_expensive\", &[\"rpc\", \"request\"], || {\n///     something_expensive()\n/// });\n/// xi_trace::trace_closure(\"something_else_expensive\", &[\"rpc\", \"response\"], || {\n///     something_else_expensive(result);\n/// });\n/// ```\n#[inline]\npub fn trace_closure<S, C, F, R>(name: S, categories: C, closure: F) -> R\nwhere\n    S: Into<StrCow>,\n    C: Into<CategoriesT>,\n    F: FnOnce() -> R,{\n    TRACE.closure(name, categories, closure)\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"trace_closure_payload":["/// See `trace_closure` for how the closure works and `trace_payload` for a\n/// discussion on payload.\n#[inline]\npub fn trace_closure_payload<S, C, P, F, R>(name: S, categories: C, closure: F, payload: P) -> R\nwhere\n    S: Into<StrCow>,\n    C: Into<CategoriesT>,\n    P: Into<TracePayloadT>,\n    F: FnOnce() -> R,{\n    TRACE.closure_payload(name, categories, closure, payload)\n}","Real(LocalPath(\"trace/src/lib.rs\"))"],"trace_payload":["/// Create an instantaneous sample with a payload.  The type the payload\n/// conforms to is currently determined by the feature this library is compiled\n/// with.  By default, the type is string-like just like name.  If compiled with\n/// the `json_payload` then a `serde_json::Value` is expected and  the library\n/// acquires a dependency on the `serde_json` crate.\n///\n/// # Performance\n/// A static string has the lowest overhead as no copies are necessary, roughly\n/// equivalent performance to a regular trace.  A string that needs to be copied\n/// first can make it ~1.7x slower than a regular trace.\n///\n/// When compiling with `json_payload`, this is ~2.1x slower than a string that\n/// needs to be copied (or ~4.5x slower than a static string)\n///\n/// # Arguments\n///\n/// * `name` - A string that provides some meaningful name to this sample.\n/// Usage of static strings is encouraged for best performance to avoid copies.\n/// However, anything that can be converted into a Cow string can be passed as\n/// an argument.\n///\n/// * `categories` - A static array of static strings that tags the samples in\n/// some way.\n///\n/// # Examples\n///\n/// ```\n/// xi_trace::trace_payload(\"something happened\", &[\"rpc\", \"response\"], \"a note about this\");\n/// ```\n///\n/// With `json_payload` feature:\n///\n/// ```rust,ignore\n/// xi_trace::trace_payload(\"my event\", &[\"rpc\", \"response\"], json!({\"key\": \"value\"}));\n/// ```\n#[inline]\npub fn trace_payload<S, C, P>(name: S, categories: C, payload: P)\nwhere\n    S: Into<StrCow>,\n    C: Into<CategoriesT>,\n    P: Into<TracePayloadT>,{\n    TRACE.instant_payload(name, categories, payload);\n}","Real(LocalPath(\"trace/src/lib.rs\"))"]},"struct_constructor":{"&'static Trace":["__stability"],"&'static str":["sample_name"],"&Trace":["deref"],"(&[T], &[T])":["as_slices"],"(&mut [T], &mut [T])":["as_mut_slices"],"(std::option::Option<std::string::String>, std::option::Option<i32>)":["consume"],"<S as serde::Serializer>::Ok":["serialize","serialize_event_type"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["deserialize"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["deserialize"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<__S as serde::Serializer>::Ok":["serialize"],"CategoriesT":["clone","deserialize","from","visit_str"],"Config":["clone","default","with_limit_bytes","with_limit_count"],"MetadataType":["clone"],"Sample":["clone","deserialize","new_duration","new_duration_marker","new_instant","new_metadata"],"SampleArgs":["clone","deserialize"],"SampleEventType":["clone","deserialize_event_type","from_chrome_id"],"SampleGuard":["block","block_payload","new","new_disabled","trace_block","trace_block_payload"],"Trace":["__static_ref_initialize","disabled","enabled"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field":["deserialize"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field":["deserialize"],"bool":["arr_eq","contains","eq","is_empty","is_enabled"],"char":["into_chrome_id"],"chrome_trace_dump::ChromeTraceArrayEntries":["clone","deserialize"],"chrome_trace_dump::Error":["already_exists","from"],"fixed_lifo_deque::FixedLifoDeque":["clone","new","split_off","with_limit"],"i32":["getpid"],"serde_json::Value":["to_value"],"std::borrow::Cow":["thread_name","to_cow_str"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::collections::vec_deque::Drain":["drain"],"std::collections::vec_deque::IntoIter":["into_iter"],"std::collections::vec_deque::Iter":["into_iter","iter"],"std::collections::vec_deque::IterMut":["into_iter","iter_mut"],"std::string::String":["exe_name","join"],"std::vec::Vec":["decode","deserialize","samples_cloned_sorted","samples_cloned_unsorted"],"u64":["current_pid","current_tid"],"usize":["capacity","get_samples_count","get_samples_limit","len","limit","max_samples","max_size_in_bytes","samples_len"]},"struct_to_trait":{"<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor":["serde::de::Visitor"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith":["serde::Deserialize"],"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith":["serde::Deserialize"],"CategoriesT":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug"],"Config":["std::clone::Clone","std::marker::Copy"],"MetadataType":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"Sample":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash"],"SampleArgs":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"SampleEventType":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"SampleGuard":["std::ops::Drop"],"TRACE":["lazy_static::LazyStatic","lazy_static::__Deref"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field":["serde::Deserialize"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor":["serde::de::Visitor"],"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor":["serde::de::Visitor"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field":["serde::Deserialize"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor":["serde::de::Visitor"],"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor":["serde::de::Visitor"],"_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith":["serde::Serialize"],"chrome_trace_dump::ChromeTraceArrayEntries":["serde::Deserialize","std::clone::Clone","std::fmt::Debug"],"chrome_trace_dump::Error":["std::convert::From","std::fmt::Debug"],"fixed_lifo_deque::FixedLifoDeque":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::iter::Extend","std::iter::IntoIterator","std::ops::Index","std::ops::IndexMut"],"std::vec::Vec":["StringArrayEq"]},"targets":{"<&'a fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::iter::IntoIterator"],"<&'a mut fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::iter::IntoIterator"],"<&'static [&'static str] as StringArrayEq<std::vec::Vec<std::string::String>>>::arr_eq":["arr_eq","Real(LocalPath(\"trace/src/lib.rs\"))","StringArrayEq"],"<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::expecting":["expecting","Real(LocalPath(\"trace/src/lib.rs\"))","serde::de::Visitor"],"<<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor as serde::de::Visitor<'de>>::visit_str":["visit_str","Real(LocalPath(\"trace/src/lib.rs\"))","serde::de::Visitor"],"<CategoriesT as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"trace/src/lib.rs\"))","serde::Deserialize"],"<CategoriesT as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"trace/src/lib.rs\"))","serde::Serialize"],"<CategoriesT as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"trace/src/lib.rs\"))","std::cmp::PartialEq"],"<CategoriesT as std::convert::From<&'static [&'static str; 0]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 10]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 1]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 2]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 3]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 4]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 5]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 6]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 7]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 8]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<&'static [&'static str; 9]>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<CategoriesT as std::convert::From<std::vec::Vec<std::string::String>>>::from":["from","Real(LocalPath(\"trace/src/lib.rs\"))","std::convert::From"],"<Sample as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"trace/src/lib.rs\"))","std::cmp::Ord"],"<Sample as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"trace/src/lib.rs\"))","std::cmp::PartialEq"],"<Sample as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"trace/src/lib.rs\"))","std::cmp::PartialOrd"],"<Sample as std::hash::Hash>::hash":["hash","Real(LocalPath(\"trace/src/lib.rs\"))","std::hash::Hash"],"<SampleGuard<'a> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"trace/src/lib.rs\"))","std::ops::Drop"],"<TRACE as lazy_static::LazyStatic>::initialize":["initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::LazyStatic"],"<TRACE as lazy_static::__Deref>::deref":["deref","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))","lazy_static::__Deref"],"<TRACE as lazy_static::__Deref>::deref::__stability":["__stability","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<TRACE as lazy_static::__Deref>::deref::__static_ref_initialize":["__static_ref_initialize","Real(LocalPath(\"/home/xiang/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs\"))",""],"<chrome_trace_dump::Error as std::convert::From<serde_json::Error>>::from":["from","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))","std::convert::From"],"<chrome_trace_dump::Error as std::convert::From<std::io::Error>>::from":["from","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))","std::convert::From"],"<chrome_trace_dump::Error as std::convert::From<std::string::String>>::from":["from","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))","std::convert::From"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::cmp::Ord"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::cmp::PartialEq"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::cmp::PartialOrd"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::hash::Hash"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::iter::Extend<A>>::extend":["extend","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::iter::Extend"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::ops::Index"],"<fixed_lifo_deque::FixedLifoDeque<A> as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::ops::IndexMut"],"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::Extend<&'a T>>::extend":["extend","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::iter::Extend"],"<fixed_lifo_deque::FixedLifoDeque<T> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))","std::iter::IntoIterator"],"<std::vec::Vec<std::string::String> as StringArrayEq<[&'static str]>>::arr_eq":["arr_eq","Real(LocalPath(\"trace/src/lib.rs\"))","StringArrayEq"],"CategoriesT::join":["join","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Config::default":["default","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Config::max_samples":["max_samples","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Config::max_size_in_bytes":["max_size_in_bytes","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Config::with_limit_bytes":["with_limit_bytes","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Config::with_limit_count":["with_limit_count","Real(LocalPath(\"trace/src/lib.rs\"))",""],"MetadataType::consume":["consume","Real(LocalPath(\"trace/src/lib.rs\"))",""],"MetadataType::sample_name":["sample_name","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Sample::new_duration":["new_duration","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Sample::new_duration_marker":["new_duration_marker","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Sample::new_instant":["new_instant","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Sample::new_metadata":["new_metadata","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Sample::thread_name":["thread_name","Real(LocalPath(\"trace/src/lib.rs\"))",""],"SampleEventType::from_chrome_id":["from_chrome_id","Real(LocalPath(\"trace/src/lib.rs\"))",""],"SampleEventType::into_chrome_id":["into_chrome_id","Real(LocalPath(\"trace/src/lib.rs\"))",""],"SampleGuard::<'a>::new":["new","Real(LocalPath(\"trace/src/lib.rs\"))",""],"SampleGuard::<'a>::new_disabled":["new_disabled","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::block":["block","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::block_payload":["block_payload","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::closure":["closure","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::closure_payload":["closure_payload","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::disable":["disable","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::disabled":["disabled","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::enable":["enable","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::enable_config":["enable_config","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::enabled":["enabled","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::get_samples_count":["get_samples_count","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::get_samples_limit":["get_samples_limit","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::instant":["instant","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::instant_payload":["instant_payload","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::is_enabled":["is_enabled","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::record":["record","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::samples_cloned_sorted":["samples_cloned_sorted","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::samples_cloned_unsorted":["samples_cloned_unsorted","Real(LocalPath(\"trace/src/lib.rs\"))",""],"Trace::save":["save","Real(LocalPath(\"trace/src/lib.rs\"))",""],"chrome_trace_dump::Error::already_exists":["already_exists","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))",""],"chrome_trace_dump::decode":["decode","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))",""],"chrome_trace_dump::deserialize":["deserialize","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))",""],"chrome_trace_dump::serialize":["serialize","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))",""],"chrome_trace_dump::to_value":["to_value","Real(LocalPath(\"trace/src/chrome_trace_dump.rs\"))",""],"deserialize_event_type":["deserialize_event_type","Real(LocalPath(\"trace/src/lib.rs\"))",""],"disable_tracing":["disable_tracing","Real(LocalPath(\"trace/src/lib.rs\"))",""],"enable_tracing":["enable_tracing","Real(LocalPath(\"trace/src/lib.rs\"))",""],"enable_tracing_with_config":["enable_tracing_with_config","Real(LocalPath(\"trace/src/lib.rs\"))",""],"exe_name":["exe_name","Real(LocalPath(\"trace/src/lib.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::append":["append","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::as_mut_slices":["as_mut_slices","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::as_slices":["as_slices","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::back":["back","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::back_mut":["back_mut","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::capacity":["capacity","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::clear":["clear","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::contains":["contains","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::drain":["drain","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::drop_excess_for_inserting":["drop_excess_for_inserting","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::front":["front","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::front_mut":["front_mut","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::get":["get","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::get_mut":["get_mut","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::is_empty":["is_empty","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::iter":["iter","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::iter_mut":["iter_mut","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::len":["len","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::limit":["limit","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::new":["new","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::pop_back":["pop_back","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::pop_front":["pop_front","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::push_back":["push_back","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::remove":["remove","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::reset_limit":["reset_limit","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::resize":["resize","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::retain":["retain","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::split_off":["split_off","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::swap":["swap","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_back":["swap_remove_back","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::swap_remove_front":["swap_remove_front","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"fixed_lifo_deque::FixedLifoDeque::<T>::with_limit":["with_limit","Real(LocalPath(\"trace/src/fixed_lifo_deque.rs\"))",""],"is_enabled":["is_enabled","Real(LocalPath(\"trace/src/lib.rs\"))",""],"ns_to_us":["ns_to_us","Real(LocalPath(\"trace/src/lib.rs\"))",""],"samples_cloned_sorted":["samples_cloned_sorted","Real(LocalPath(\"trace/src/lib.rs\"))",""],"samples_cloned_unsorted":["samples_cloned_unsorted","Real(LocalPath(\"trace/src/lib.rs\"))",""],"samples_len":["samples_len","Real(LocalPath(\"trace/src/lib.rs\"))",""],"save":["save","Real(LocalPath(\"trace/src/lib.rs\"))",""],"serialize_event_type":["serialize_event_type","Real(LocalPath(\"trace/src/lib.rs\"))",""],"sys_pid::current_pid":["current_pid","Real(LocalPath(\"trace/src/sys_pid.rs\"))",""],"sys_tid::current_tid":["current_tid","Real(LocalPath(\"trace/src/sys_tid.rs\"))",""],"to_cow_str":["to_cow_str","Real(LocalPath(\"trace/src/lib.rs\"))",""],"trace":["trace","Real(LocalPath(\"trace/src/lib.rs\"))",""],"trace_block":["trace_block","Real(LocalPath(\"trace/src/lib.rs\"))",""],"trace_block_payload":["trace_block_payload","Real(LocalPath(\"trace/src/lib.rs\"))",""],"trace_closure":["trace_closure","Real(LocalPath(\"trace/src/lib.rs\"))",""],"trace_closure_payload":["trace_closure_payload","Real(LocalPath(\"trace/src/lib.rs\"))",""],"trace_payload":["trace_payload","Real(LocalPath(\"trace/src/lib.rs\"))",""]},"trait_to_struct":{"StringArrayEq":["std::vec::Vec"],"lazy_static::LazyStatic":["TRACE"],"lazy_static::__Deref":["TRACE"],"serde::Deserialize":["<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith","CategoriesT","Sample","SampleArgs","_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field","_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field","chrome_trace_dump::ChromeTraceArrayEntries"],"serde::Serialize":["CategoriesT","Sample","SampleArgs","_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith"],"serde::de::Visitor":["<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor","_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor","_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor","_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor","_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor"],"std::clone::Clone":["CategoriesT","Config","MetadataType","Sample","SampleArgs","SampleEventType","chrome_trace_dump::ChromeTraceArrayEntries","fixed_lifo_deque::FixedLifoDeque"],"std::cmp::Eq":["CategoriesT","MetadataType","Sample","SampleEventType","fixed_lifo_deque::FixedLifoDeque"],"std::cmp::Ord":["Sample","fixed_lifo_deque::FixedLifoDeque"],"std::cmp::PartialEq":["CategoriesT","MetadataType","Sample","SampleArgs","SampleEventType","fixed_lifo_deque::FixedLifoDeque"],"std::cmp::PartialOrd":["Sample","fixed_lifo_deque::FixedLifoDeque"],"std::convert::From":["CategoriesT","chrome_trace_dump::Error"],"std::fmt::Debug":["CategoriesT","MetadataType","Sample","SampleArgs","SampleEventType","chrome_trace_dump::ChromeTraceArrayEntries","chrome_trace_dump::Error","fixed_lifo_deque::FixedLifoDeque"],"std::hash::Hash":["Sample","fixed_lifo_deque::FixedLifoDeque"],"std::iter::Extend":["fixed_lifo_deque::FixedLifoDeque"],"std::iter::IntoIterator":["fixed_lifo_deque::FixedLifoDeque"],"std::marker::Copy":["Config","SampleEventType"],"std::marker::StructuralEq":["MetadataType","SampleEventType"],"std::marker::StructuralPartialEq":["MetadataType","SampleArgs","SampleEventType"],"std::ops::Drop":["SampleGuard"],"std::ops::Index":["fixed_lifo_deque::FixedLifoDeque"],"std::ops::IndexMut":["fixed_lifo_deque::FixedLifoDeque"]},"type_to_def_path":{"<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor":"<CategoriesT as serde::Deserialize<'de>>::deserialize::CategoriesTVisitor","<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith<'de>":"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map::__DeserializeWith","<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith<'de>":"<_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq::__DeserializeWith","CategoriesT":"CategoriesT","Config":"Config","MetadataType":"MetadataType","Sample":"Sample","SampleArgs":"SampleArgs","SampleEventType":"SampleEventType","SampleGuard<'a>":"SampleGuard","TRACE":"TRACE","Trace":"Trace","_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field":"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Field","_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor":"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__FieldVisitor","_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor<'de>":"_IMPL_DESERIALIZE_FOR_Sample::<impl serde::Deserialize<'de> for Sample>::deserialize::__Visitor","_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field":"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Field","_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor":"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__FieldVisitor","_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor<'de>":"_IMPL_DESERIALIZE_FOR_SampleArgs::<impl serde::Deserialize<'de> for SampleArgs>::deserialize::__Visitor","_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith<'__a>":"_IMPL_SERIALIZE_FOR_Sample::<impl serde::Serialize for Sample>::serialize::__SerializeWith","chrome_trace_dump::ChromeTraceArrayEntries":"chrome_trace_dump::ChromeTraceArrayEntries","chrome_trace_dump::Error":"chrome_trace_dump::Error","fixed_lifo_deque::FixedLifoDeque<T>":"fixed_lifo_deque::FixedLifoDeque"}}