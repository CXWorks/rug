{"dependencies":{"<F as Callback>::call":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<F as IdleProc>::call":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<PanicGuard<'a, W> as std::ops::Drop>::drop":["PanicGuard","RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"<RawPeer<W> as Peer>::box_clone":["RawPeer","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"<RawPeer<W> as Peer>::request_is_pending":["RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"<RawPeer<W> as Peer>::schedule_idle":["RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"<RawPeer<W> as Peer>::schedule_timer":["RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","std::time::Instant","test_utils::DummyWriter"],"<RawPeer<W> as Peer>::send_rpc_notification":["RawPeer","serde_json::Value","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"<RawPeer<W> as Peer>::send_rpc_request":["RawPeer","serde_json::Value","std::io::Write","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"<RawPeer<W> as Peer>::send_rpc_request_async":["RawPeer","serde_json::Value","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"<RawPeer<W> as std::clone::Clone>::clone":["RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"<RpcCall as std::clone::Clone>::clone":["RpcCall","serde_json::Value","std::string::String"],"<RpcCall as std::fmt::Debug>::fmt":["RpcCall","serde_json::Value","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<Timer as std::cmp::Eq>::assert_receiver_is_total_eq":["Timer","std::time::Instant"],"<Timer as std::cmp::Ord>::cmp":["Timer","std::cmp::Ordering","std::time::Instant"],"<Timer as std::cmp::PartialEq>::eq":["Timer","std::time::Instant"],"<Timer as std::cmp::PartialOrd>::partial_cmp":["Timer","std::marker::Sized","std::option::Option","std::time::Instant"],"<Timer as std::fmt::Debug>::fmt":["Timer","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::Instant"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<error::Error as std::convert::From<error::RemoteError>>::from":["error::Error","error::RemoteError","serde_json::Value","std::io::Error","std::marker::Sized","std::option::Option","std::string::String"],"<error::Error as std::fmt::Debug>::fmt":["error::Error","error::RemoteError","serde_json::Value","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<error::ReadError as std::convert::From<serde_json::Error>>::from":["error::ReadError","serde_json::Error","std::io::Error"],"<error::ReadError as std::convert::From<std::io::Error>>::from":["error::ReadError","serde_json::Error","std::io::Error"],"<error::ReadError as std::fmt::Debug>::fmt":["error::ReadError","serde_json::Error","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result"],"<error::ReadError as std::fmt::Display>::fmt":["error::ReadError","serde_json::Error","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result"],"<error::RemoteError as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<error::RemoteError as serde::Serialize>::serialize":["error::RemoteError","serde::Serializer","serde_json::Value","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<error::RemoteError as std::clone::Clone>::clone":["error::RemoteError","serde_json::Value","std::marker::Sized","std::option::Option","std::string::String"],"<error::RemoteError as std::cmp::PartialEq>::eq":["error::RemoteError","serde_json::Value","std::marker::Sized","std::option::Option","std::string::String"],"<error::RemoteError as std::convert::From<serde_json::Error>>::from":["error::RemoteError","serde_json::Error","serde_json::Value","std::marker::Sized","std::option::Option","std::string::String"],"<error::RemoteError as std::fmt::Debug>::fmt":["error::RemoteError","serde_json::Value","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field as serde::Deserialize<'de>>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::expecting":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_bytes":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_str":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::visit_u64":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor","serde::de::Error","std::marker::Sized","std::result::Result"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::expecting":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor","std::fmt::Formatter","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_map":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor","serde::de::MapAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::visit_seq":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor","serde::de::SeqAccess","std::marker::PhantomData","std::marker::Sized","std::result::Result"],"<impl std::clone::Clone for std::boxed::Box<(dyn Peer + 'static)>>::clone":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<parse::Call<N, R> as std::clone::Clone>::clone":["error::RemoteError","parse::Call","serde_json::Value","std::marker::Sized","std::option::Option","std::string::String"],"<parse::Call<N, R> as std::cmp::PartialEq>::eq":["error::RemoteError","parse::Call","serde_json::Value","std::marker::Sized","std::option::Option","std::string::String"],"<parse::Call<N, R> as std::fmt::Debug>::fmt":["error::RemoteError","parse::Call","serde_json::Value","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"<parse::MessageReader as std::default::Default>::default":["parse::MessageReader","std::string::String"],"<parse::MessageReader as std::fmt::Debug>::fmt":["parse::MessageReader","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<parse::RpcObject as std::clone::Clone>::clone":["parse::RpcObject","serde_json::Value"],"<parse::RpcObject as std::convert::From<serde_json::Value>>::from":["parse::RpcObject","serde_json::Value"],"<parse::RpcObject as std::fmt::Debug>::fmt":["parse::RpcObject","serde_json::Value","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<test_utils::DummyPeer as Peer>::box_clone":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","test_utils::DummyPeer"],"<test_utils::DummyPeer as Peer>::request_is_pending":["test_utils::DummyPeer"],"<test_utils::DummyPeer as Peer>::schedule_idle":["test_utils::DummyPeer"],"<test_utils::DummyPeer as Peer>::schedule_timer":["std::time::Instant","test_utils::DummyPeer"],"<test_utils::DummyPeer as Peer>::send_rpc_notification":["serde_json::Value","test_utils::DummyPeer"],"<test_utils::DummyPeer as Peer>::send_rpc_request":["serde_json::Value","std::marker::Sized","std::result::Result","test_utils::DummyPeer"],"<test_utils::DummyPeer as Peer>::send_rpc_request_async":["serde_json::Value","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","test_utils::DummyPeer"],"<test_utils::DummyPeer as std::clone::Clone>::clone":["test_utils::DummyPeer"],"<test_utils::DummyPeer as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","test_utils::DummyPeer"],"<test_utils::DummyWriter as std::io::Write>::flush":["std::marker::Sized","std::result::Result","std::sync::mpsc::Sender","test_utils::DummyWriter"],"<test_utils::DummyWriter as std::io::Write>::write":["std::marker::Sized","std::result::Result","std::sync::mpsc::Sender","test_utils::DummyWriter"],"Callback::call":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"Handler::handle_notification":["RpcCtx","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"Handler::handle_request":["RpcCtx","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"Handler::idle":["RpcCtx","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"IdleProc::call":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"PanicGuard":["PanicGuard","RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"Peer::box_clone":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"Peer::request_is_pending":[],"Peer::schedule_idle":[],"Peer::schedule_timer":["std::time::Instant"],"Peer::send_rpc_notification":["serde_json::Value"],"Peer::send_rpc_request":["serde_json::Value","std::marker::Sized","std::result::Result"],"Peer::send_rpc_request_async":["serde_json::Value","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"RawPeer":["RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::check_timers":["RawPeer","std::io::Write","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::disconnect":["RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::get_rx_timeout":["RawPeer","std::io::Write","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::mpsc::Sender","std::time::Duration","test_utils::DummyWriter"],"RawPeer::<W>::handle_response":["RawPeer","std::io::Write","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::needs_exit":["RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::put_rx":["RawPeer","std::io::Write","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::reset_needs_exit":["RawPeer","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::respond":["RawPeer","std::io::Write","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::send":["RawPeer","serde_json::Value","std::io::Write","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::send_rpc_request_common":["RawPeer","ResponseHandler","serde_json::Value","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Sized","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::try_get_idle":["RawPeer","std::io::Write","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RawPeer::<W>::try_get_rx":["RawPeer","std::io::Write","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"ResponseHandler":["ResponseHandler","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::mpsc::Sender"],"ResponseHandler::invoke":["ResponseHandler","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::sync::mpsc::Sender"],"RpcCall":["RpcCall","serde_json::Value","std::string::String"],"RpcCtx":["RpcCtx","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"RpcCtx::get_peer":["RpcCtx","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"RpcCtx::schedule_idle":["RpcCtx","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"RpcLoop":["RawPeer","RpcLoop","parse::MessageReader","std::io::Write","std::marker::Sized","std::string::String","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RpcLoop::<W>::get_raw_peer":["RawPeer","RpcLoop","parse::MessageReader","std::io::Write","std::marker::Sized","std::string::String","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RpcLoop::<W>::mainloop":["Handler","RawPeer","RpcLoop","parse::MessageReader","std::io::BufRead","std::io::Write","std::marker::Send","std::marker::Sized","std::ops::FnOnce","std::result::Result","std::string::String","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RpcLoop::<W>::new":["RawPeer","RpcLoop","parse::MessageReader","std::io::Write","std::marker::Sized","std::string::String","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"RpcState":["RpcState","std::io::Write","std::marker::Sized","std::sync::Condvar","std::sync::Mutex","std::sync::atomic::AtomicBool","std::sync::atomic::AtomicUsize","std::sync::mpsc::Sender","test_utils::DummyWriter"],"Timer":["Timer","std::time::Instant"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor","std::marker::PhantomData"],"_IMPL_SERIALIZE_FOR_RpcCall::<impl serde::Serialize for RpcCall>::serialize":["RpcCall","serde::Serializer","serde_json::Value","std::marker::Sized","std::result::Result","std::string::String"],"do_idle":["Handler","RpcCtx","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error":["error::Error","error::RemoteError","serde_json::Value","std::io::Error","std::marker::Sized","std::option::Option","std::string::String"],"error::ErrorHelper":["error::ErrorHelper","std::marker::Sized","std::option::Option","std::string::String"],"error::ReadError":["error::ReadError","serde_json::Error","std::io::Error"],"error::ReadError::is_disconnect":["error::ReadError","serde_json::Error","std::io::Error"],"error::RemoteError":["error::RemoteError","serde_json::Value","std::marker::Sized","std::option::Option","std::string::String"],"error::RemoteError::custom":["error::RemoteError","serde_json::Value","std::convert::AsRef","std::convert::Into","std::marker::Sized","std::option::Option","std::string::String"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize":["serde::Deserializer","std::marker::Sized","std::result::Result"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor":["error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor","std::marker::PhantomData"],"error::_IMPL_SERIALIZE_FOR_ErrorHelper::<impl serde::Serialize for error::ErrorHelper>::serialize":["error::ErrorHelper","serde::Serializer","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"next_read":["Handler","RawPeer","RpcCtx","std::alloc::Allocator","std::boxed::Box","std::io::Write","std::marker::Send","std::marker::Sized","std::result::Result","std::sync::Arc","std::sync::mpsc::Sender","test_utils::DummyWriter"],"parse::Call":["error::RemoteError","parse::Call","serde_json::Value","std::marker::Sized","std::option::Option","std::string::String"],"parse::MessageReader":["parse::MessageReader","std::string::String"],"parse::MessageReader::next":["parse::MessageReader","std::io::BufRead","std::marker::Sized","std::result::Result","std::string::String"],"parse::MessageReader::parse":["parse::MessageReader","std::marker::Sized","std::result::Result","std::string::String"],"parse::RpcObject":["parse::RpcObject","serde_json::Value"],"parse::RpcObject::get_id":["parse::RpcObject","serde_json::Value","std::marker::Sized","std::option::Option"],"parse::RpcObject::get_method":["parse::RpcObject","serde_json::Value","std::marker::Sized","std::option::Option"],"parse::RpcObject::into_response":["parse::RpcObject","serde_json::Value","std::marker::Sized","std::result::Result"],"parse::RpcObject::into_rpc":["parse::RpcObject","serde::de::DeserializeOwned","serde_json::Value","std::marker::Sized","std::result::Result"],"parse::RpcObject::is_response":["parse::RpcObject","serde_json::Value"],"test_utils::DummyPeer":["test_utils::DummyPeer"],"test_utils::DummyReader":["parse::MessageReader","std::marker::Sized","std::string::String","std::sync::mpsc::Receiver","test_utils::DummyReader"],"test_utils::DummyReader::expect_nothing":["parse::MessageReader","std::marker::Sized","std::string::String","std::sync::mpsc::Receiver","test_utils::DummyReader"],"test_utils::DummyReader::expect_object":["parse::MessageReader","parse::RpcObject","serde_json::Value","std::marker::Sized","std::string::String","std::sync::mpsc::Receiver","test_utils::DummyReader"],"test_utils::DummyReader::expect_response":["parse::MessageReader","std::marker::Sized","std::result::Result","std::string::String","std::sync::mpsc::Receiver","test_utils::DummyReader"],"test_utils::DummyReader::expect_rpc":["parse::MessageReader","parse::RpcObject","serde_json::Value","std::marker::Sized","std::string::String","std::sync::mpsc::Receiver","test_utils::DummyReader"],"test_utils::DummyReader::next_timeout":["parse::MessageReader","std::marker::Sized","std::option::Option","std::string::String","std::sync::mpsc::Receiver","std::time::Duration","test_utils::DummyReader"],"test_utils::DummyWriter":["std::marker::Sized","std::sync::mpsc::Sender","test_utils::DummyWriter"],"test_utils::make_reader":["std::convert::AsRef","std::io::Cursor","std::marker::Sized"],"test_utils::test_channel":["parse::MessageReader","std::marker::Sized","std::string::String","std::sync::mpsc::Receiver","std::sync::mpsc::Sender","test_utils::DummyReader","test_utils::DummyWriter"]},"glob_path_import":{},"self_to_fn":{"<F as Callback>::F":["impl<F: Send + FnOnce(Result<Value, Error>)> Callback for F {\n    fn call(self: Box<F>, result: Result<Value, Error>) {\n        (*self)(result)\n    }\n}"],"<F as IdleProc>::F":["impl<F: Send + FnOnce(usize)> IdleProc for F {\n    fn call(self: Box<F>, token: usize) {\n        (*self)(token)\n    }\n}"],"PanicGuard":["impl<'a, W: Write + 'static> Drop for PanicGuard<'a, W> {\n    fn drop(&mut self) {\n        if thread::panicking() {\n            error!(\"panic guard hit, closing runloop\");\n            self.0.disconnect();\n        }\n    }\n}"],"RawPeer":["impl<W: Write + Send + 'static> Peer for RawPeer<W> {\n    fn box_clone(&self) -> Box<dyn Peer> {\n        Box::new((*self).clone())\n    }\n\n    fn send_rpc_notification(&self, method: &str, params: &Value) {\n        let _trace = trace_block_payload(\"send notif\", &[\"rpc\"], method.to_owned());\n        if let Err(e) = self.send(&json!({\n            \"method\": method,\n            \"params\": params,\n        })) {\n            error!(\"send error on send_rpc_notification method {}: {}\", method, e);\n        }\n    }\n\n    fn send_rpc_request_async(&self, method: &str, params: &Value, f: Box<dyn Callback>) {\n        let _trace = trace_block_payload(\"send req async\", &[\"rpc\"], method.to_owned());\n        self.send_rpc_request_common(method, params, ResponseHandler::Callback(f));\n    }\n\n    fn send_rpc_request(&self, method: &str, params: &Value) -> Result<Value, Error> {\n        let _trace = trace_block_payload(\"send req sync\", &[\"rpc\"], method.to_owned());\n        self.0.is_blocked.store(true, Ordering::Release);\n        let (tx, rx) = mpsc::channel();\n        self.send_rpc_request_common(method, params, ResponseHandler::Chan(tx));\n        rx.recv().unwrap_or(Err(Error::PeerDisconnect))\n    }\n\n    fn request_is_pending(&self) -> bool {\n        let queue = self.0.rx_queue.lock().unwrap();\n        !queue.is_empty()\n    }\n\n    fn schedule_idle(&self, token: usize) {\n        self.0.idle_queue.lock().unwrap().push_back(token);\n    }\n\n    fn schedule_timer(&self, after: Instant, token: usize) {\n        self.0.timers.lock().unwrap().push(Timer { fire_after: after, token });\n    }\n}","impl<W: Write> Clone for RawPeer<W> {\n    fn clone(&self) -> Self {\n        RawPeer(self.0.clone())\n    }\n}","impl<W: Write> RawPeer<W> {\n    fn send(&self, v: &Value) -> Result<(), io::Error> {\n        let _trace = trace_block(\"send\", &[\"rpc\"]);\n        let mut s = serde_json::to_string(v).unwrap();\n        s.push('\\n');\n        self.0.writer.lock().unwrap().write_all(s.as_bytes())\n        // Technically, maybe we should flush here, but doesn't seem to be required.\n    }\n\n    fn respond(&self, result: Response, id: u64) {\n        let mut response = json!({ \"id\": id });\n        match result {\n            Ok(result) => response[\"result\"] = result,\n            Err(error) => response[\"error\"] = json!(error),\n        };\n        if let Err(e) = self.send(&response) {\n            error!(\"error {} sending response to RPC {:?}\", e, id);\n        }\n    }\n\n    fn send_rpc_request_common(&self, method: &str, params: &Value, rh: ResponseHandler) {\n        let id = self.0.id.fetch_add(1, Ordering::Relaxed);\n        {\n            let mut pending = self.0.pending.lock().unwrap();\n            pending.insert(id, rh);\n        }\n        if let Err(e) = self.send(&json!({\n            \"id\": id,\n            \"method\": method,\n            \"params\": params,\n        })) {\n            let mut pending = self.0.pending.lock().unwrap();\n            if let Some(rh) = pending.remove(&id) {\n                rh.invoke(Err(Error::Io(e)));\n            }\n        }\n    }\n\n    fn handle_response(&self, id: u64, resp: Result<Value, Error>) {\n        let id = id as usize;\n        let handler = {\n            let mut pending = self.0.pending.lock().unwrap();\n            pending.remove(&id)\n        };\n        match handler {\n            Some(responsehandler) => responsehandler.invoke(resp),\n            None => warn!(\"id {} not found in pending\", id),\n        }\n    }\n\n    /// Get a message from the receive queue if available.\n    fn try_get_rx(&self) -> Option<Result<RpcObject, ReadError>> {\n        let mut queue = self.0.rx_queue.lock().unwrap();\n        queue.pop_front()\n    }\n\n    /// Get a message from the receive queue, waiting for at most `Duration`\n    /// and returning `None` if no message is available.\n    fn get_rx_timeout(&self, dur: Duration) -> Option<Result<RpcObject, ReadError>> {\n        let mut queue = self.0.rx_queue.lock().unwrap();\n        let result = self.0.rx_cvar.wait_timeout(queue, dur).unwrap();\n        queue = result.0;\n        queue.pop_front()\n    }\n\n    /// Adds a message to the receive queue. The message should only\n    /// be `None` if the read thread is exiting.\n    fn put_rx(&self, json: Result<RpcObject, ReadError>) {\n        let mut queue = self.0.rx_queue.lock().unwrap();\n        queue.push_back(json);\n        self.0.rx_cvar.notify_one();\n    }\n\n    fn try_get_idle(&self) -> Option<usize> {\n        self.0.idle_queue.lock().unwrap().pop_front()\n    }\n\n    /// Checks status of the most imminent timer. If that timer has expired,\n    /// returns `Some(Ok(_))`, with the corresponding token.\n    /// If a timer exists but has not expired, returns `Some(Err(_))`,\n    /// with the error value being the `Duration` until the timer is ready.\n    /// Returns `None` if no timers are registered.\n    fn check_timers(&self) -> Option<Result<usize, Duration>> {\n        let mut timers = self.0.timers.lock().unwrap();\n        match timers.peek() {\n            None => return None,\n            Some(t) => {\n                let now = Instant::now();\n                if t.fire_after > now {\n                    return Some(Err(t.fire_after - now));\n                }\n            }\n        }\n        Some(Ok(timers.pop().unwrap().token))\n    }\n\n    /// send disconnect error to pending requests.\n    fn disconnect(&self) {\n        let mut pending = self.0.pending.lock().unwrap();\n        let ids = pending.keys().cloned().collect::<Vec<_>>();\n        for id in &ids {\n            let callback = pending.remove(id).unwrap();\n            callback.invoke(Err(Error::PeerDisconnect));\n        }\n        self.0.needs_exit.store(true, Ordering::Relaxed);\n    }\n\n    /// Returns `true` if an error has occured in the main thread.\n    fn needs_exit(&self) -> bool {\n        self.0.needs_exit.load(Ordering::Relaxed)\n    }\n\n    fn reset_needs_exit(&self) {\n        self.0.needs_exit.store(false, Ordering::SeqCst);\n    }\n}"],"ResponseHandler":["impl ResponseHandler {\n    fn invoke(self, result: Result<Value, Error>) {\n        match self {\n            ResponseHandler::Chan(tx) => {\n                let _ = tx.send(result);\n            }\n            ResponseHandler::Callback(f) => f.call(result),\n        }\n    }\n}"],"RpcCall":["Clone","Debug","Deserialize","Serialize"],"RpcCtx":["impl RpcCtx {\n    pub fn get_peer(&self) -> &RpcPeer {\n        &self.peer\n    }\n\n    /// Schedule the idle handler to be run when there are no requests pending.\n    pub fn schedule_idle(&self, token: usize) {\n        self.peer.schedule_idle(token)\n    }\n}"],"RpcLoop":["impl<W: Write + Send> RpcLoop<W> {\n    /// Creates a new `RpcLoop` with the given output stream (which is used for\n    /// sending requests and notifications, as well as responses).\n    pub fn new(writer: W) -> Self {\n        let rpc_peer = RawPeer(Arc::new(RpcState {\n            rx_queue: Mutex::new(VecDeque::new()),\n            rx_cvar: Condvar::new(),\n            writer: Mutex::new(writer),\n            id: AtomicUsize::new(0),\n            pending: Mutex::new(BTreeMap::new()),\n            idle_queue: Mutex::new(VecDeque::new()),\n            timers: Mutex::new(BinaryHeap::new()),\n            needs_exit: AtomicBool::new(false),\n            is_blocked: AtomicBool::new(false),\n        }));\n        RpcLoop { reader: MessageReader::default(), peer: rpc_peer }\n    }\n\n    /// Gets a reference to the peer.\n    pub fn get_raw_peer(&self) -> RawPeer<W> {\n        self.peer.clone()\n    }\n\n    /// Starts the event loop, reading lines from the reader until EOF,\n    /// or an error occurs.\n    ///\n    /// Returns `Ok()` in the EOF case, otherwise returns the\n    /// underlying `ReadError`.\n    ///\n    /// # Note:\n    /// The reader is supplied via a closure, as basically a workaround\n    /// so that the reader doesn't have to be `Send`. Internally, the\n    /// main loop starts a separate thread for I/O, and at startup that\n    /// thread calls the given closure.\n    ///\n    /// Calls to the handler happen on the caller's thread.\n    ///\n    /// Calls to the handler are guaranteed to preserve the order as\n    /// they appear on on the channel. At the moment, there is no way\n    /// for there to be more than one incoming request to be outstanding.\n    pub fn mainloop<R, RF, H>(&mut self, rf: RF, handler: &mut H) -> Result<(), ReadError>\n    where\n        R: BufRead,\n        RF: Send + FnOnce() -> R,\n        H: Handler,\n    {\n        let exit = crossbeam_utils::thread::scope(|scope| {\n            let peer = self.get_raw_peer();\n            peer.reset_needs_exit();\n\n            let ctx = RpcCtx { peer: Box::new(peer.clone()) };\n            scope.spawn(move |_| {\n                let mut stream = rf();\n                loop {\n                    // The main thread cannot return while this thread is active;\n                    // when the main thread wants to exit it sets this flag.\n                    if self.peer.needs_exit() {\n                        trace(\"read loop exit\", &[\"rpc\"]);\n                        break;\n                    }\n\n                    let json = match self.reader.next(&mut stream) {\n                        Ok(json) => json,\n                        Err(err) => {\n                            if self.peer.0.is_blocked.load(Ordering::Acquire) {\n                                error!(\"failed to parse response json: {}\", err);\n                                self.peer.disconnect();\n                            }\n                            self.peer.put_rx(Err(err));\n                            break;\n                        }\n                    };\n                    if json.is_response() {\n                        let id = json.get_id().unwrap();\n                        let _resp =\n                            trace_block_payload(\"read loop response\", &[\"rpc\"], format!(\"{}\", id));\n                        match json.into_response() {\n                            Ok(resp) => {\n                                let resp = resp.map_err(Error::from);\n                                self.peer.handle_response(id, resp);\n                            }\n                            Err(msg) => {\n                                error!(\"failed to parse response: {}\", msg);\n                                self.peer.handle_response(id, Err(Error::InvalidResponse));\n                            }\n                        }\n                    } else {\n                        self.peer.put_rx(Ok(json));\n                    }\n                }\n            });\n\n            loop {\n                let _guard = PanicGuard(&peer);\n                let read_result = next_read(&peer, handler, &ctx);\n                let _trace = trace_block(\"main got msg\", &[\"rpc\"]);\n\n                let json = match read_result {\n                    Ok(json) => json,\n                    Err(err) => {\n                        trace_payload(\"main loop err\", &[\"rpc\"], err.to_string());\n                        // finish idle work before disconnecting;\n                        // this is mostly useful for integration tests.\n                        if let Some(idle_token) = peer.try_get_idle() {\n                            handler.idle(&ctx, idle_token);\n                        }\n                        peer.disconnect();\n                        return err;\n                    }\n                };\n\n                let method = json.get_method().map(String::from);\n                match json.into_rpc::<H::Notification, H::Request>() {\n                    Ok(Call::Request(id, cmd)) => {\n                        let _t = trace_block_payload(\"handle request\", &[\"rpc\"], method.unwrap());\n                        let result = handler.handle_request(&ctx, cmd);\n                        peer.respond(result, id);\n                    }\n                    Ok(Call::Notification(cmd)) => {\n                        let _t = trace_block_payload(\"handle notif\", &[\"rpc\"], method.unwrap());\n                        handler.handle_notification(&ctx, cmd);\n                    }\n                    Ok(Call::InvalidRequest(id, err)) => peer.respond(Err(err), id),\n                    Err(err) => {\n                        trace_payload(\"read loop exit\", &[\"rpc\"], err.to_string());\n                        peer.disconnect();\n                        return ReadError::UnknownRequest(err);\n                    }\n                }\n            }\n        })\n        .unwrap();\n\n        if exit.is_disconnect() {\n            Ok(())\n        } else {\n            Err(exit)\n        }\n    }\n}"],"Timer":["Debug","Eq","PartialEq","impl Ord for Timer {\n    fn cmp(&self, other: &Timer) -> cmp::Ordering {\n        other.fire_after.cmp(&self.fire_after)\n    }\n}","impl PartialOrd for Timer {\n    fn partial_cmp(&self, other: &Timer) -> Option<cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field":["Deserialize"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor":["Deserialize"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor":["Deserialize"],"error::Error":["Debug","impl From<RemoteError> for Error {\n    fn from(err: RemoteError) -> Error {\n        Error::RemoteError(err)\n    }\n}"],"error::ErrorHelper":["Deserialize","Serialize"],"error::ReadError":["Debug","impl From<JsonError> for ReadError {\n    fn from(err: JsonError) -> ReadError {\n        ReadError::Json(err)\n    }\n}","impl From<io::Error> for ReadError {\n    fn from(err: io::Error) -> ReadError {\n        ReadError::Io(err)\n    }\n}","impl ReadError {\n    /// Returns `true` iff this is the `ReadError::Disconnect` variant.\n    pub fn is_disconnect(&self) -> bool {\n        matches!(*self, ReadError::Disconnect)\n    }\n}","impl fmt::Display for ReadError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            ReadError::Io(ref err) => write!(f, \"I/O Error: {:?}\", err),\n            ReadError::Json(ref err) => write!(f, \"JSON Error: {:?}\", err),\n            ReadError::NotObject => write!(f, \"JSON message was not an object.\"),\n            ReadError::UnknownRequest(ref err) => write!(f, \"Unknown request: {:?}\", err),\n            ReadError::Disconnect => write!(f, \"Peer closed the connection.\"),\n        }\n    }\n}"],"error::RemoteError":["Clone","Debug","PartialEq","impl From<JsonError> for RemoteError {\n    fn from(err: JsonError) -> RemoteError {\n        RemoteError::InvalidRequest(Some(json!(err.to_string())))\n    }\n}","impl RemoteError {\n    /// Creates a new custom error.\n    pub fn custom<S, V>(code: i64, message: S, data: V) -> Self\n    where\n        S: AsRef<str>,\n        V: Into<Option<Value>>,\n    {\n        let message = message.as_ref().into();\n        let data = data.into();\n        RemoteError::Custom { code, message, data }\n    }\n}","impl Serialize for RemoteError {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        let (code, message, data) = match *self {\n            RemoteError::InvalidRequest(ref d) => (-32600, \"Invalid request\", d),\n            RemoteError::Custom { code, ref message, ref data } => (code, message.as_ref(), data),\n            RemoteError::Unknown(_) => panic!(\n                \"The 'Unknown' error variant is \\\n                 not intended for client use.\"\n            ),\n        };\n        let message = message.to_owned();\n        let data = data.to_owned();\n        let err = ErrorHelper { code, message, data };\n        err.serialize(serializer)\n    }\n}","impl<'de> Deserialize<'de> for RemoteError {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let v = Value::deserialize(deserializer)?;\n        let resp = match ErrorHelper::deserialize(&v) {\n            Ok(resp) => resp,\n            Err(_) => return Ok(RemoteError::Unknown(v)),\n        };\n\n        Ok(match resp.code {\n            -32600 => RemoteError::InvalidRequest(resp.data),\n            _ => RemoteError::Custom { code: resp.code, message: resp.message, data: resp.data },\n        })\n    }\n}"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field":["Deserialize"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor":["Deserialize"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor":["Deserialize"],"parse::Call":["Clone","Debug","PartialEq"],"parse::MessageReader":["Debug","Default","impl MessageReader {\n    /// Attempts to read the next line from the stream and parse it as\n    /// an RPC object.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if there is an underlying\n    /// I/O error, if the stream is closed, or if the message is not\n    /// a valid JSON object.\n    pub fn next<R: BufRead>(&mut self, reader: &mut R) -> Result<RpcObject, ReadError> {\n        self.0.clear();\n        let _ = reader.read_line(&mut self.0)?;\n        if self.0.is_empty() {\n            Err(ReadError::Disconnect)\n        } else {\n            self.parse(&self.0)\n        }\n    }\n\n    /// Attempts to parse a &str as an RPC Object.\n    ///\n    /// This should not be called directly unless you are writing tests.\n    #[doc(hidden)]\n    pub fn parse(&self, s: &str) -> Result<RpcObject, ReadError> {\n        let _trace = xi_trace::trace_block(\"parse\", &[\"rpc\"]);\n        let val = serde_json::from_str::<Value>(&s)?;\n        if !val.is_object() {\n            Err(ReadError::NotObject)\n        } else {\n            Ok(val.into())\n        }\n    }\n}"],"parse::RpcObject":["Clone","Debug","impl From<Value> for RpcObject {\n    fn from(v: Value) -> RpcObject {\n        RpcObject(v)\n    }\n}","impl RpcObject {\n    /// Returns the 'id' of the underlying object, if present.\n    pub fn get_id(&self) -> Option<RequestId> {\n        self.0.get(\"id\").and_then(Value::as_u64)\n    }\n\n    /// Returns the 'method' field of the underlying object, if present.\n    pub fn get_method(&self) -> Option<&str> {\n        self.0.get(\"method\").and_then(Value::as_str)\n    }\n\n    /// Returns `true` if this object looks like an RPC response;\n    /// that is, if it has an 'id' field and does _not_ have a 'method'\n    /// field.\n    pub fn is_response(&self) -> bool {\n        self.0.get(\"id\").is_some() && self.0.get(\"method\").is_none()\n    }\n\n    /// Attempts to convert the underlying `Value` into an RPC response\n    /// object, and returns the result.\n    ///\n    /// The caller is expected to verify that the object is a response\n    /// before calling this method.\n    ///\n    /// # Errors\n    ///\n    /// If the `Value` is not a well formed response object, this will\n    /// return a `String` containing an error message. The caller should\n    /// print this message and exit.\n    pub fn into_response(mut self) -> Result<Response, String> {\n        let _ = self.get_id().ok_or(\"Response requires 'id' field.\".to_string())?;\n\n        if self.0.get(\"result\").is_some() == self.0.get(\"error\").is_some() {\n            return Err(\"RPC response must contain exactly one of\\\n                        'error' or 'result' fields.\"\n                .into());\n        }\n        let result = self.0.as_object_mut().and_then(|obj| obj.remove(\"result\"));\n\n        match result {\n            Some(r) => Ok(Ok(r)),\n            None => {\n                let error = self.0.as_object_mut().and_then(|obj| obj.remove(\"error\")).unwrap();\n                match serde_json::from_value::<RemoteError>(error) {\n                    Ok(e) => Ok(Err(e)),\n                    Err(e) => Err(format!(\"Error handling response: {:?}\", e)),\n                }\n            }\n        }\n    }\n\n    /// Attempts to convert the underlying `Value` into either an RPC\n    /// notification or request.\n    ///\n    /// # Errors\n    ///\n    /// Returns a `serde_json::Error` if the `Value` cannot be converted\n    /// to one of the expected types.\n    pub fn into_rpc<N, R>(self) -> Result<Call<N, R>, JsonError>\n    where\n        N: DeserializeOwned,\n        R: DeserializeOwned,\n    {\n        let id = self.get_id();\n        match id {\n            Some(id) => match serde_json::from_value::<R>(self.0) {\n                Ok(resp) => Ok(Call::Request(id, resp)),\n                Err(err) => Ok(Call::InvalidRequest(id, err.into())),\n            },\n            None => {\n                let result = serde_json::from_value::<N>(self.0)?;\n                Ok(Call::Notification(result))\n            }\n        }\n    }\n}"],"std::boxed::Box":["impl Clone for Box<dyn Peer> {\n    fn clone(&self) -> Box<dyn Peer> {\n        self.box_clone()\n    }\n}"],"test_utils::DummyPeer":["Clone","Debug","impl Peer for DummyPeer {\n    fn box_clone(&self) -> Box<dyn Peer> {\n        Box::new(self.clone())\n    }\n    fn send_rpc_notification(&self, _method: &str, _params: &Value) {}\n    fn send_rpc_request_async(&self, _method: &str, _params: &Value, f: Box<dyn Callback>) {\n        f.call(Ok(\"dummy peer\".into()))\n    }\n    fn send_rpc_request(&self, _method: &str, _params: &Value) -> Result<Value, Error> {\n        Ok(\"dummy peer\".into())\n    }\n    fn request_is_pending(&self) -> bool {\n        false\n    }\n    fn schedule_idle(&self, _token: usize) {}\n    fn schedule_timer(&self, _time: Instant, _token: usize) {}\n}"],"test_utils::DummyReader":["impl DummyReader {\n    /// Attempts to read a message, returning `None` if the wait exceeds\n    /// `timeout`.\n    ///\n    /// This method makes no assumptions about the contents of the\n    /// message, and does no error handling.\n    pub fn next_timeout(&mut self, timeout: Duration) -> Option<Result<RpcObject, ReadError>> {\n        self.1.recv_timeout(timeout).ok().map(|s| self.0.parse(&s))\n    }\n\n    /// Reads and parses a response object.\n    ///\n    /// # Panics\n    ///\n    /// Panics if a non-response message is received, or if no message\n    /// is received after a reasonable time.\n    pub fn expect_response(&mut self) -> Response {\n        let raw = self.next_timeout(Duration::from_secs(1)).expect(\"response should be received\");\n        let val = raw.as_ref().ok().map(|v| serde_json::to_string(&v.0));\n        let resp = raw.map_err(|e| e.to_string()).and_then(|r| r.into_response());\n\n        match resp {\n            Err(msg) => panic!(\"Bad response: {:?}. {}\", val, msg),\n            Ok(resp) => resp,\n        }\n    }\n\n    pub fn expect_object(&mut self) -> RpcObject {\n        self.next_timeout(Duration::from_secs(1)).expect(\"expected object\").unwrap()\n    }\n\n    pub fn expect_rpc(&mut self, method: &str) -> RpcObject {\n        let obj = self\n            .next_timeout(Duration::from_secs(1))\n            .unwrap_or_else(|| panic!(\"expected rpc \\\"{}\\\"\", method))\n            .unwrap();\n        assert_eq!(obj.get_method(), Some(method));\n        obj\n    }\n\n    pub fn expect_nothing(&mut self) {\n        if let Some(thing) = self.next_timeout(Duration::from_millis(500)) {\n            panic!(\"unexpected something {:?}\", thing);\n        }\n    }\n}"],"test_utils::DummyWriter":["impl Write for DummyWriter {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let s = String::from_utf8(buf.to_vec()).unwrap();\n        self.0\n            .send(s)\n            .map_err(|err| io::Error::new(io::ErrorKind::Other, format!(\"{:?}\", err)))\n            .map(|_| buf.len())\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}"]},"single_path_import":{"error::Error":"Error","error::ReadError":"ReadError","error::RemoteError":"RemoteError"},"srcs":{"<F as Callback>::call":["fn call(self: Box<F>, result: Result<Value, Error>){\n        (*self)(result)\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<F as IdleProc>::call":["fn call(self: Box<F>, token: usize){\n        (*self)(token)\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<PanicGuard<'a, W> as std::ops::Drop>::drop":["fn drop(&mut self){\n        if thread::panicking() {\n            error!(\"panic guard hit, closing runloop\");\n            self.0.disconnect();\n        }\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<RawPeer<W> as Peer>::box_clone":["fn box_clone(&self) -> Box<dyn Peer>{\n        Box::new((*self).clone())\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<RawPeer<W> as Peer>::request_is_pending":["fn request_is_pending(&self) -> bool{\n        let queue = self.0.rx_queue.lock().unwrap();\n        !queue.is_empty()\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<RawPeer<W> as Peer>::schedule_idle":["fn schedule_idle(&self, token: usize){\n        self.0.idle_queue.lock().unwrap().push_back(token);\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<RawPeer<W> as Peer>::schedule_timer":["fn schedule_timer(&self, after: Instant, token: usize){\n        self.0.timers.lock().unwrap().push(Timer { fire_after: after, token });\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<RawPeer<W> as Peer>::send_rpc_notification":["fn send_rpc_notification(&self, method: &str, params: &Value){\n        let _trace = trace_block_payload(\"send notif\", &[\"rpc\"], method.to_owned());\n        if let Err(e) = self.send(&json!({\n            \"method\": method,\n            \"params\": params,\n        })) {\n            error!(\"send error on send_rpc_notification method {}: {}\", method, e);\n        }\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<RawPeer<W> as Peer>::send_rpc_request":["fn send_rpc_request(&self, method: &str, params: &Value) -> Result<Value, Error>{\n        let _trace = trace_block_payload(\"send req sync\", &[\"rpc\"], method.to_owned());\n        self.0.is_blocked.store(true, Ordering::Release);\n        let (tx, rx) = mpsc::channel();\n        self.send_rpc_request_common(method, params, ResponseHandler::Chan(tx));\n        rx.recv().unwrap_or(Err(Error::PeerDisconnect))\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<RawPeer<W> as Peer>::send_rpc_request_async":["fn send_rpc_request_async(&self, method: &str, params: &Value, f: Box<dyn Callback>){\n        let _trace = trace_block_payload(\"send req async\", &[\"rpc\"], method.to_owned());\n        self.send_rpc_request_common(method, params, ResponseHandler::Callback(f));\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<RawPeer<W> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        RawPeer(self.0.clone())\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<Timer as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Timer) -> cmp::Ordering{\n        other.fire_after.cmp(&self.fire_after)\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<Timer as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Timer) -> Option<cmp::Ordering>{\n        Some(self.cmp(other))\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<error::Error as std::convert::From<error::RemoteError>>::from":["fn from(err: RemoteError) -> Error{\n        Error::RemoteError(err)\n    }","Real(LocalPath(\"rpc/src/error.rs\"))"],"<error::ReadError as std::convert::From<serde_json::Error>>::from":["fn from(err: JsonError) -> ReadError{\n        ReadError::Json(err)\n    }","Real(LocalPath(\"rpc/src/error.rs\"))"],"<error::ReadError as std::convert::From<std::io::Error>>::from":["fn from(err: io::Error) -> ReadError{\n        ReadError::Io(err)\n    }","Real(LocalPath(\"rpc/src/error.rs\"))"],"<error::ReadError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {\n            ReadError::Io(ref err) => write!(f, \"I/O Error: {:?}\", err),\n            ReadError::Json(ref err) => write!(f, \"JSON Error: {:?}\", err),\n            ReadError::NotObject => write!(f, \"JSON message was not an object.\"),\n            ReadError::UnknownRequest(ref err) => write!(f, \"Unknown request: {:?}\", err),\n            ReadError::Disconnect => write!(f, \"Peer closed the connection.\"),\n        }\n    }","Real(LocalPath(\"rpc/src/error.rs\"))"],"<error::RemoteError as serde::Deserialize<'de>>::deserialize":["fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,{\n        let v = Value::deserialize(deserializer)?;\n        let resp = match ErrorHelper::deserialize(&v) {\n            Ok(resp) => resp,\n            Err(_) => return Ok(RemoteError::Unknown(v)),\n        };\n\n        Ok(match resp.code {\n            -32600 => RemoteError::InvalidRequest(resp.data),\n            _ => RemoteError::Custom { code: resp.code, message: resp.message, data: resp.data },\n        })\n    }","Real(LocalPath(\"rpc/src/error.rs\"))"],"<error::RemoteError as serde::Serialize>::serialize":["fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,{\n        let (code, message, data) = match *self {\n            RemoteError::InvalidRequest(ref d) => (-32600, \"Invalid request\", d),\n            RemoteError::Custom { code, ref message, ref data } => (code, message.as_ref(), data),\n            RemoteError::Unknown(_) => panic!(\n                \"The 'Unknown' error variant is \\\n                 not intended for client use.\"\n            ),\n        };\n        let message = message.to_owned();\n        let data = data.to_owned();\n        let err = ErrorHelper { code, message, data };\n        err.serialize(serializer)\n    }","Real(LocalPath(\"rpc/src/error.rs\"))"],"<error::RemoteError as std::convert::From<serde_json::Error>>::from":["fn from(err: JsonError) -> RemoteError{\n        RemoteError::InvalidRequest(Some(json!(err.to_string())))\n    }","Real(LocalPath(\"rpc/src/error.rs\"))"],"<impl std::clone::Clone for std::boxed::Box<(dyn Peer + 'static)>>::clone":["fn clone(&self) -> Box<dyn Peer>{\n        self.box_clone()\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"<parse::RpcObject as std::convert::From<serde_json::Value>>::from":["fn from(v: Value) -> RpcObject{\n        RpcObject(v)\n    }","Real(LocalPath(\"rpc/src/parse.rs\"))"],"<test_utils::DummyPeer as Peer>::box_clone":["fn box_clone(&self) -> Box<dyn Peer>{\n        Box::new(self.clone())\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"<test_utils::DummyPeer as Peer>::request_is_pending":["fn request_is_pending(&self) -> bool{\n        false\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"<test_utils::DummyPeer as Peer>::schedule_idle":["fn schedule_idle(&self, _token: usize){}","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"<test_utils::DummyPeer as Peer>::schedule_timer":["fn schedule_timer(&self, _time: Instant, _token: usize){}","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"<test_utils::DummyPeer as Peer>::send_rpc_notification":["fn send_rpc_notification(&self, _method: &str, _params: &Value){}","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"<test_utils::DummyPeer as Peer>::send_rpc_request":["fn send_rpc_request(&self, _method: &str, _params: &Value) -> Result<Value, Error>{\n        Ok(\"dummy peer\".into())\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"<test_utils::DummyPeer as Peer>::send_rpc_request_async":["fn send_rpc_request_async(&self, _method: &str, _params: &Value, f: Box<dyn Callback>){\n        f.call(Ok(\"dummy peer\".into()))\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"<test_utils::DummyWriter as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n        Ok(())\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"<test_utils::DummyWriter as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n        let s = String::from_utf8(buf.to_vec()).unwrap();\n        self.0\n            .send(s)\n            .map_err(|err| io::Error::new(io::ErrorKind::Other, format!(\"{:?}\", err)))\n            .map(|_| buf.len())\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"Callback":["pub trait Callback: Send {\n    fn call(self: Box<Self>, result: Result<Value, Error>);\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"Handler":["/// A trait for types which can handle RPCs.\n///\n/// Types which implement `MethodHandler` are also responsible for implementing\n/// `Parser`; `Parser` is provided when Self::Notification and Self::Request\n/// can be used with serde::DeserializeOwned.\npub trait Handler {\n    type Notification: DeserializeOwned;\n    type Request: DeserializeOwned;\n    fn handle_notification(&mut self, ctx: &RpcCtx, rpc: Self::Notification);\n    fn handle_request(&mut self, ctx: &RpcCtx, rpc: Self::Request) -> Result<Value, RemoteError>;\n    #[allow(unused_variables)]\n    fn idle(&mut self, ctx: &RpcCtx, token: usize) {}\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"Handler::idle":["#[allow(unused_variables)]\nfn idle(&mut self, ctx: &RpcCtx, token: usize){}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"IdleProc":["trait IdleProc: Send {\n    fn call(self: Box<Self>, token: usize);\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"PanicGuard":["/// A helper type which shuts down the runloop if a panic occurs while\n/// handling an RPC.\nstruct PanicGuard<'a, W: Write + 'static>(&'a RawPeer<W>);","Real(LocalPath(\"rpc/src/lib.rs\"))"],"Peer":["/// The `Peer` trait represents the interface for the other side of the RPC\n/// channel. It is intended to be used behind a pointer, a trait object.\npub trait Peer: Send + 'static {\n    /// Used to implement `clone` in an object-safe way.\n    /// For an explanation on this approach, see\n    /// [this thread](https://users.rust-lang.org/t/solved-is-it-possible-to-clone-a-boxed-trait-object/1714/6).\n    fn box_clone(&self) -> Box<dyn Peer>;\n    /// Sends a notification (asynchronous RPC) to the peer.\n    fn send_rpc_notification(&self, method: &str, params: &Value);\n    /// Sends a request asynchronously, and the supplied callback will\n    /// be called when the response arrives.\n    ///\n    /// `Callback` is an alias for `FnOnce(Result<Value, Error>)`; it must\n    /// be boxed because trait objects cannot use generic paramaters.\n    fn send_rpc_request_async(&self, method: &str, params: &Value, f: Box<dyn Callback>);\n    /// Sends a request (synchronous RPC) to the peer, and waits for the result.\n    fn send_rpc_request(&self, method: &str, params: &Value) -> Result<Value, Error>;\n    /// Determines whether an incoming request (or notification) is\n    /// pending. This is intended to reduce latency for bulk operations\n    /// done in the background.\n    fn request_is_pending(&self) -> bool;\n    /// Adds a token to the idle queue. When the runloop is idle and the\n    /// queue is not empty, the handler's `idle` fn will be called\n    /// with the earliest added token.\n    fn schedule_idle(&self, token: usize);\n    /// Like `schedule_idle`, with the guarantee that the handler's `idle`\n    /// fn will not be called _before_ the provided `Instant`.\n    ///\n    /// # Note\n    ///\n    /// This is not intended as a high-fidelity timer. Regular RPC messages\n    /// will always take priority over an idle task.\n    fn schedule_timer(&self, after: Instant, token: usize);\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer":["/// An interface to access the other side of the RPC channel. The main purpose\n/// is to send RPC requests and notifications to the peer.\n///\n/// A single shared `RawPeer` exists for each `RpcLoop`; a reference can\n/// be taken with `RpcLoop::get_peer()`.\n///\n/// In general, `RawPeer` shouldn't be used directly, but behind a pointer as\n/// the `Peer` trait object.\npub struct RawPeer<W: Write + 'static>(Arc<RpcState<W>>);","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::check_timers":["/// Checks status of the most imminent timer. If that timer has expired,\n/// returns `Some(Ok(_))`, with the corresponding token.\n/// If a timer exists but has not expired, returns `Some(Err(_))`,\n/// with the error value being the `Duration` until the timer is ready.\n/// Returns `None` if no timers are registered.\nfn check_timers(&self) -> Option<Result<usize, Duration>>{\n        let mut timers = self.0.timers.lock().unwrap();\n        match timers.peek() {\n            None => return None,\n            Some(t) => {\n                let now = Instant::now();\n                if t.fire_after > now {\n                    return Some(Err(t.fire_after - now));\n                }\n            }\n        }\n        Some(Ok(timers.pop().unwrap().token))\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::disconnect":["/// send disconnect error to pending requests.\nfn disconnect(&self){\n        let mut pending = self.0.pending.lock().unwrap();\n        let ids = pending.keys().cloned().collect::<Vec<_>>();\n        for id in &ids {\n            let callback = pending.remove(id).unwrap();\n            callback.invoke(Err(Error::PeerDisconnect));\n        }\n        self.0.needs_exit.store(true, Ordering::Relaxed);\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::get_rx_timeout":["/// Get a message from the receive queue, waiting for at most `Duration`\n/// and returning `None` if no message is available.\nfn get_rx_timeout(&self, dur: Duration) -> Option<Result<RpcObject, ReadError>>{\n        let mut queue = self.0.rx_queue.lock().unwrap();\n        let result = self.0.rx_cvar.wait_timeout(queue, dur).unwrap();\n        queue = result.0;\n        queue.pop_front()\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::handle_response":["fn handle_response(&self, id: u64, resp: Result<Value, Error>){\n        let id = id as usize;\n        let handler = {\n            let mut pending = self.0.pending.lock().unwrap();\n            pending.remove(&id)\n        };\n        match handler {\n            Some(responsehandler) => responsehandler.invoke(resp),\n            None => warn!(\"id {} not found in pending\", id),\n        }\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::needs_exit":["/// Returns `true` if an error has occured in the main thread.\nfn needs_exit(&self) -> bool{\n        self.0.needs_exit.load(Ordering::Relaxed)\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::put_rx":["/// Adds a message to the receive queue. The message should only\n/// be `None` if the read thread is exiting.\nfn put_rx(&self, json: Result<RpcObject, ReadError>){\n        let mut queue = self.0.rx_queue.lock().unwrap();\n        queue.push_back(json);\n        self.0.rx_cvar.notify_one();\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::reset_needs_exit":["fn reset_needs_exit(&self){\n        self.0.needs_exit.store(false, Ordering::SeqCst);\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::respond":["fn respond(&self, result: Response, id: u64){\n        let mut response = json!({ \"id\": id });\n        match result {\n            Ok(result) => response[\"result\"] = result,\n            Err(error) => response[\"error\"] = json!(error),\n        };\n        if let Err(e) = self.send(&response) {\n            error!(\"error {} sending response to RPC {:?}\", e, id);\n        }\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::send":["fn send(&self, v: &Value) -> Result<(), io::Error>{\n        let _trace = trace_block(\"send\", &[\"rpc\"]);\n        let mut s = serde_json::to_string(v).unwrap();\n        s.push('\\n');\n        self.0.writer.lock().unwrap().write_all(s.as_bytes())\n        // Technically, maybe we should flush here, but doesn't seem to be required.\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::send_rpc_request_common":["fn send_rpc_request_common(&self, method: &str, params: &Value, rh: ResponseHandler){\n        let id = self.0.id.fetch_add(1, Ordering::Relaxed);\n        {\n            let mut pending = self.0.pending.lock().unwrap();\n            pending.insert(id, rh);\n        }\n        if let Err(e) = self.send(&json!({\n            \"id\": id,\n            \"method\": method,\n            \"params\": params,\n        })) {\n            let mut pending = self.0.pending.lock().unwrap();\n            if let Some(rh) = pending.remove(&id) {\n                rh.invoke(Err(Error::Io(e)));\n            }\n        }\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::try_get_idle":["fn try_get_idle(&self) -> Option<usize>{\n        self.0.idle_queue.lock().unwrap().pop_front()\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RawPeer::<W>::try_get_rx":["/// Get a message from the receive queue if available.\nfn try_get_rx(&self) -> Option<Result<RpcObject, ReadError>>{\n        let mut queue = self.0.rx_queue.lock().unwrap();\n        queue.pop_front()\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"ResponseHandler":["enum ResponseHandler {\n    Chan(mpsc::Sender<Result<Value, Error>>),\n    Callback(Box<dyn Callback>),\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"ResponseHandler::invoke":["fn invoke(self, result: Result<Value, Error>){\n        match self {\n            ResponseHandler::Chan(tx) => {\n                let _ = tx.send(result);\n            }\n            ResponseHandler::Callback(f) => f.call(result),\n        }\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RpcCall":["/// An RPC command.\n///\n/// This type is used as a placeholder in various places, and can be\n/// used by clients as a catchall type for implementing `MethodHandler`.\npub struct RpcCall {\n    pub method: String,\n    pub params: Value,\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RpcCtx":["pub struct RpcCtx {\n    peer: RpcPeer,\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RpcCtx::get_peer":["pub fn get_peer(&self) -> &RpcPeer{\n        &self.peer\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RpcCtx::schedule_idle":["/// Schedule the idle handler to be run when there are no requests pending.\npub fn schedule_idle(&self, token: usize){\n        self.peer.schedule_idle(token)\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RpcLoop":["/// A structure holding the state of a main loop for handling RPC's.\npub struct RpcLoop<W: Write + 'static> {\n    reader: MessageReader,\n    peer: RawPeer<W>,\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RpcLoop::<W>::get_raw_peer":["/// Gets a reference to the peer.\npub fn get_raw_peer(&self) -> RawPeer<W>{\n        self.peer.clone()\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RpcLoop::<W>::mainloop":["/// Starts the event loop, reading lines from the reader until EOF,\n/// or an error occurs.\n///\n/// Returns `Ok()` in the EOF case, otherwise returns the\n/// underlying `ReadError`.\n///\n/// # Note:\n/// The reader is supplied via a closure, as basically a workaround\n/// so that the reader doesn't have to be `Send`. Internally, the\n/// main loop starts a separate thread for I/O, and at startup that\n/// thread calls the given closure.\n///\n/// Calls to the handler happen on the caller's thread.\n///\n/// Calls to the handler are guaranteed to preserve the order as\n/// they appear on on the channel. At the moment, there is no way\n/// for there to be more than one incoming request to be outstanding.\npub fn mainloop<R, RF, H>(&mut self, rf: RF, handler: &mut H) -> Result<(), ReadError>\n    where\n        R: BufRead,\n        RF: Send + FnOnce() -> R,\n        H: Handler,{\n        let exit = crossbeam_utils::thread::scope(|scope| {\n            let peer = self.get_raw_peer();\n            peer.reset_needs_exit();\n\n            let ctx = RpcCtx { peer: Box::new(peer.clone()) };\n            scope.spawn(move |_| {\n                let mut stream = rf();\n                loop {\n                    // The main thread cannot return while this thread is active;\n                    // when the main thread wants to exit it sets this flag.\n                    if self.peer.needs_exit() {\n                        trace(\"read loop exit\", &[\"rpc\"]);\n                        break;\n                    }\n\n                    let json = match self.reader.next(&mut stream) {\n                        Ok(json) => json,\n                        Err(err) => {\n                            if self.peer.0.is_blocked.load(Ordering::Acquire) {\n                                error!(\"failed to parse response json: {}\", err);\n                                self.peer.disconnect();\n                            }\n                            self.peer.put_rx(Err(err));\n                            break;\n                        }\n                    };\n                    if json.is_response() {\n                        let id = json.get_id().unwrap();\n                        let _resp =\n                            trace_block_payload(\"read loop response\", &[\"rpc\"], format!(\"{}\", id));\n                        match json.into_response() {\n                            Ok(resp) => {\n                                let resp = resp.map_err(Error::from);\n                                self.peer.handle_response(id, resp);\n                            }\n                            Err(msg) => {\n                                error!(\"failed to parse response: {}\", msg);\n                                self.peer.handle_response(id, Err(Error::InvalidResponse));\n                            }\n                        }\n                    } else {\n                        self.peer.put_rx(Ok(json));\n                    }\n                }\n            });\n\n            loop {\n                let _guard = PanicGuard(&peer);\n                let read_result = next_read(&peer, handler, &ctx);\n                let _trace = trace_block(\"main got msg\", &[\"rpc\"]);\n\n                let json = match read_result {\n                    Ok(json) => json,\n                    Err(err) => {\n                        trace_payload(\"main loop err\", &[\"rpc\"], err.to_string());\n                        // finish idle work before disconnecting;\n                        // this is mostly useful for integration tests.\n                        if let Some(idle_token) = peer.try_get_idle() {\n                            handler.idle(&ctx, idle_token);\n                        }\n                        peer.disconnect();\n                        return err;\n                    }\n                };\n\n                let method = json.get_method().map(String::from);\n                match json.into_rpc::<H::Notification, H::Request>() {\n                    Ok(Call::Request(id, cmd)) => {\n                        let _t = trace_block_payload(\"handle request\", &[\"rpc\"], method.unwrap());\n                        let result = handler.handle_request(&ctx, cmd);\n                        peer.respond(result, id);\n                    }\n                    Ok(Call::Notification(cmd)) => {\n                        let _t = trace_block_payload(\"handle notif\", &[\"rpc\"], method.unwrap());\n                        handler.handle_notification(&ctx, cmd);\n                    }\n                    Ok(Call::InvalidRequest(id, err)) => peer.respond(Err(err), id),\n                    Err(err) => {\n                        trace_payload(\"read loop exit\", &[\"rpc\"], err.to_string());\n                        peer.disconnect();\n                        return ReadError::UnknownRequest(err);\n                    }\n                }\n            }\n        })\n        .unwrap();\n\n        if exit.is_disconnect() {\n            Ok(())\n        } else {\n            Err(exit)\n        }\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RpcLoop::<W>::new":["/// Creates a new `RpcLoop` with the given output stream (which is used for\n/// sending requests and notifications, as well as responses).\npub fn new(writer: W) -> Self{\n        let rpc_peer = RawPeer(Arc::new(RpcState {\n            rx_queue: Mutex::new(VecDeque::new()),\n            rx_cvar: Condvar::new(),\n            writer: Mutex::new(writer),\n            id: AtomicUsize::new(0),\n            pending: Mutex::new(BTreeMap::new()),\n            idle_queue: Mutex::new(VecDeque::new()),\n            timers: Mutex::new(BinaryHeap::new()),\n            needs_exit: AtomicBool::new(false),\n            is_blocked: AtomicBool::new(false),\n        }));\n        RpcLoop { reader: MessageReader::default(), peer: rpc_peer }\n    }","Real(LocalPath(\"rpc/src/lib.rs\"))"],"RpcState":["struct RpcState<W: Write> {\n    rx_queue: Mutex<VecDeque<Result<RpcObject, ReadError>>>,\n    rx_cvar: Condvar,\n    writer: Mutex<W>,\n    id: AtomicUsize,\n    pending: Mutex<BTreeMap<usize, ResponseHandler>>,\n    idle_queue: Mutex<VecDeque<usize>>,\n    timers: Mutex<BinaryHeap<Timer>>,\n    needs_exit: AtomicBool,\n    is_blocked: AtomicBool,\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"Timer":["struct Timer {\n    fire_after: Instant,\n    token: usize,\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"rpc/src/lib.rs\"))"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"rpc/src/lib.rs\"))"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"rpc/src/lib.rs\"))"],"do_idle":["fn do_idle<H: Handler>(handler: &mut H, ctx: &RpcCtx, token: usize){\n    let _trace = trace_block_payload(\"do_idle\", &[\"rpc\"], format!(\"token: {}\", token));\n    handler.idle(ctx, token);\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"error::Error":["/// The possible error outcomes when attempting to send a message.\npub enum Error {\n    /// An IO error occurred on the underlying communication channel.\n    Io(io::Error),\n    /// The peer returned an error.\n    RemoteError(RemoteError),\n    /// The peer closed the connection.\n    PeerDisconnect,\n    /// The peer sent a response containing the id, but was malformed.\n    InvalidResponse,\n}","Real(LocalPath(\"rpc/src/error.rs\"))"],"error::ErrorHelper":["struct ErrorHelper {\n    code: i64,\n    message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    data: Option<Value>,\n}","Real(LocalPath(\"rpc/src/error.rs\"))"],"error::ReadError":["/// The possible error outcomes when attempting to read a message.\npub enum ReadError {\n    /// An error occurred in the underlying stream\n    Io(io::Error),\n    /// The message was not valid JSON.\n    Json(JsonError),\n    /// The message was not a JSON object.\n    NotObject,\n    /// The the method and params were not recognized by the handler.\n    UnknownRequest(JsonError),\n    /// The peer closed the connection.\n    Disconnect,\n}","Real(LocalPath(\"rpc/src/error.rs\"))"],"error::ReadError::is_disconnect":["/// Returns `true` iff this is the `ReadError::Disconnect` variant.\npub fn is_disconnect(&self) -> bool{\n        matches!(*self, ReadError::Disconnect)\n    }","Real(LocalPath(\"rpc/src/error.rs\"))"],"error::RemoteError":["/// Errors that can be received from the other side of the RPC channel.\n///\n/// This type is intended to go over the wire. And by convention\n/// should `Serialize` as a JSON object with \"code\", \"message\",\n/// and optionally \"data\" fields.\n///\n/// The xi RPC protocol defines one error: `RemoteError::InvalidRequest`,\n/// represented by error code `-32600`; however codes in the range\n/// `-32700 ... -32000` (inclusive) are reserved for compatability with\n/// the JSON-RPC spec.\n///\n/// # Examples\n///\n/// An invalid request:\n///\n/// ```\n/// # extern crate xi_rpc;\n/// # extern crate serde_json;\n/// use xi_rpc::RemoteError;\n/// use serde_json::Value;\n///\n/// let json = r#\"{\n///     \"code\": -32600,\n///     \"message\": \"Invalid request\",\n///     \"data\": \"Additional details\"\n///     }\"#;\n///\n/// let err = serde_json::from_str::<RemoteError>(&json).unwrap();\n/// assert_eq!(err,\n///            RemoteError::InvalidRequest(\n///                Some(Value::String(\"Additional details\".into()))));\n/// ```\n///\n/// A custom error:\n///\n/// ```\n/// # extern crate xi_rpc;\n/// # extern crate serde_json;\n/// use xi_rpc::RemoteError;\n/// use serde_json::Value;\n///\n/// let json = r#\"{\n///     \"code\": 404,\n///     \"message\": \"Not Found\"\n///     }\"#;\n///\n/// let err = serde_json::from_str::<RemoteError>(&json).unwrap();\n/// assert_eq!(err, RemoteError::custom(404, \"Not Found\", None));\n/// ```\npub enum RemoteError {\n    /// The JSON was valid, but was not a correctly formed request.\n    ///\n    /// This Error is used internally, and should not be returned by\n    /// clients.\n    InvalidRequest(Option<Value>),\n    /// A custom error, defined by the client.\n    Custom { code: i64, message: String, data: Option<Value> },\n    /// An error that cannot be represented by an error object.\n    ///\n    /// This error is intended to accommodate clients that return arbitrary\n    /// error values. It should not be used for new errors.\n    Unknown(Value),\n}","Real(LocalPath(\"rpc/src/error.rs\"))"],"error::RemoteError::custom":["/// Creates a new custom error.\npub fn custom<S, V>(code: i64, message: S, data: V) -> Self\n    where\n        S: AsRef<str>,\n        V: Into<Option<Value>>,{\n        let message = message.as_ref().into();\n        let data = data.into();\n        RemoteError::Custom { code, message, data }\n    }","Real(LocalPath(\"rpc/src/error.rs\"))"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field":["Deserialize\nDeserialize","Real(LocalPath(\"rpc/src/error.rs\"))"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor":["Deserialize","Real(LocalPath(\"rpc/src/error.rs\"))"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor":["Deserialize","Real(LocalPath(\"rpc/src/error.rs\"))"],"next_read":["/// Returns the next read result, checking for idle work when no\n/// result is available.\nfn next_read<W, H>(peer: &RawPeer<W>, handler: &mut H, ctx: &RpcCtx) -> Result<RpcObject, ReadError>\nwhere\n    W: Write + Send,\n    H: Handler,{\n    loop {\n        if let Some(result) = peer.try_get_rx() {\n            return result;\n        }\n        // handle timers before general idle work\n        let time_to_next_timer = match peer.check_timers() {\n            Some(Ok(token)) => {\n                do_idle(handler, ctx, token);\n                continue;\n            }\n            Some(Err(duration)) => Some(duration),\n            None => None,\n        };\n\n        if let Some(idle_token) = peer.try_get_idle() {\n            do_idle(handler, ctx, idle_token);\n            continue;\n        }\n\n        // we don't want to block indefinitely if there's no current idle work,\n        // because idle work could be scheduled from another thread.\n        let idle_timeout = time_to_next_timer.unwrap_or(MAX_IDLE_WAIT).min(MAX_IDLE_WAIT);\n\n        if let Some(result) = peer.get_rx_timeout(idle_timeout) {\n            return result;\n        }\n    }\n}","Real(LocalPath(\"rpc/src/lib.rs\"))"],"parse::Call":["/// An RPC call, which may be either a notification or a request.\npub enum Call<N, R> {\n    /// An id and an RPC Request\n    Request(RequestId, R),\n    /// An RPC Notification\n    Notification(N),\n    /// A malformed request: the request contained an id, but could\n    /// not be parsed. The client will receive an error.\n    InvalidRequest(RequestId, RemoteError),\n}","Real(LocalPath(\"rpc/src/parse.rs\"))"],"parse::MessageReader":["/// Reads and parses RPC messages from a stream, maintaining an\n/// internal buffer.\npub struct MessageReader(String);","Real(LocalPath(\"rpc/src/parse.rs\"))"],"parse::MessageReader::next":["/// Attempts to read the next line from the stream and parse it as\n/// an RPC object.\n///\n/// # Errors\n///\n/// This function will return an error if there is an underlying\n/// I/O error, if the stream is closed, or if the message is not\n/// a valid JSON object.\npub fn next<R: BufRead>(&mut self, reader: &mut R) -> Result<RpcObject, ReadError>{\n        self.0.clear();\n        let _ = reader.read_line(&mut self.0)?;\n        if self.0.is_empty() {\n            Err(ReadError::Disconnect)\n        } else {\n            self.parse(&self.0)\n        }\n    }","Real(LocalPath(\"rpc/src/parse.rs\"))"],"parse::MessageReader::parse":["/// Attempts to parse a &str as an RPC Object.\n///\n/// This should not be called directly unless you are writing tests.\n#[doc(hidden)]\npub fn parse(&self, s: &str) -> Result<RpcObject, ReadError>{\n        let _trace = xi_trace::trace_block(\"parse\", &[\"rpc\"]);\n        let val = serde_json::from_str::<Value>(&s)?;\n        if !val.is_object() {\n            Err(ReadError::NotObject)\n        } else {\n            Ok(val.into())\n        }\n    }","Real(LocalPath(\"rpc/src/parse.rs\"))"],"parse::RpcObject":["/// An internal type used during initial JSON parsing.\n///\n/// Wraps an arbitrary JSON object, which may be any valid or invalid\n/// RPC message. This allows initial parsing and response handling to\n/// occur on the read thread. If the message looks like a request, it\n/// is passed to the main thread for handling.\npub struct RpcObject(pub Value);","Real(LocalPath(\"rpc/src/parse.rs\"))"],"parse::RpcObject::get_id":["/// Returns the 'id' of the underlying object, if present.\npub fn get_id(&self) -> Option<RequestId>{\n        self.0.get(\"id\").and_then(Value::as_u64)\n    }","Real(LocalPath(\"rpc/src/parse.rs\"))"],"parse::RpcObject::get_method":["/// Returns the 'method' field of the underlying object, if present.\npub fn get_method(&self) -> Option<&str>{\n        self.0.get(\"method\").and_then(Value::as_str)\n    }","Real(LocalPath(\"rpc/src/parse.rs\"))"],"parse::RpcObject::into_response":["/// Attempts to convert the underlying `Value` into an RPC response\n/// object, and returns the result.\n///\n/// The caller is expected to verify that the object is a response\n/// before calling this method.\n///\n/// # Errors\n///\n/// If the `Value` is not a well formed response object, this will\n/// return a `String` containing an error message. The caller should\n/// print this message and exit.\npub fn into_response(mut self) -> Result<Response, String>{\n        let _ = self.get_id().ok_or(\"Response requires 'id' field.\".to_string())?;\n\n        if self.0.get(\"result\").is_some() == self.0.get(\"error\").is_some() {\n            return Err(\"RPC response must contain exactly one of\\\n                        'error' or 'result' fields.\"\n                .into());\n        }\n        let result = self.0.as_object_mut().and_then(|obj| obj.remove(\"result\"));\n\n        match result {\n            Some(r) => Ok(Ok(r)),\n            None => {\n                let error = self.0.as_object_mut().and_then(|obj| obj.remove(\"error\")).unwrap();\n                match serde_json::from_value::<RemoteError>(error) {\n                    Ok(e) => Ok(Err(e)),\n                    Err(e) => Err(format!(\"Error handling response: {:?}\", e)),\n                }\n            }\n        }\n    }","Real(LocalPath(\"rpc/src/parse.rs\"))"],"parse::RpcObject::into_rpc":["/// Attempts to convert the underlying `Value` into either an RPC\n/// notification or request.\n///\n/// # Errors\n///\n/// Returns a `serde_json::Error` if the `Value` cannot be converted\n/// to one of the expected types.\npub fn into_rpc<N, R>(self) -> Result<Call<N, R>, JsonError>\n    where\n        N: DeserializeOwned,\n        R: DeserializeOwned,{\n        let id = self.get_id();\n        match id {\n            Some(id) => match serde_json::from_value::<R>(self.0) {\n                Ok(resp) => Ok(Call::Request(id, resp)),\n                Err(err) => Ok(Call::InvalidRequest(id, err.into())),\n            },\n            None => {\n                let result = serde_json::from_value::<N>(self.0)?;\n                Ok(Call::Notification(result))\n            }\n        }\n    }","Real(LocalPath(\"rpc/src/parse.rs\"))"],"parse::RpcObject::is_response":["/// Returns `true` if this object looks like an RPC response;\n/// that is, if it has an 'id' field and does _not_ have a 'method'\n/// field.\npub fn is_response(&self) -> bool{\n        self.0.get(\"id\").is_some() && self.0.get(\"method\").is_none()\n    }","Real(LocalPath(\"rpc/src/parse.rs\"))"],"test_utils::DummyPeer":["/// An Peer that doesn't do anything.\npub struct DummyPeer;","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"test_utils::DummyReader":["/// Wraps an instance of `mpsc::Receiver`, providing convenience methods\n/// for parsing received messages.\npub struct DummyReader(MessageReader, Receiver<String>);","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"test_utils::DummyReader::expect_nothing":["pub fn expect_nothing(&mut self){\n        if let Some(thing) = self.next_timeout(Duration::from_millis(500)) {\n            panic!(\"unexpected something {:?}\", thing);\n        }\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"test_utils::DummyReader::expect_object":["pub fn expect_object(&mut self) -> RpcObject{\n        self.next_timeout(Duration::from_secs(1)).expect(\"expected object\").unwrap()\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"test_utils::DummyReader::expect_response":["/// Reads and parses a response object.\n///\n/// # Panics\n///\n/// Panics if a non-response message is received, or if no message\n/// is received after a reasonable time.\npub fn expect_response(&mut self) -> Response{\n        let raw = self.next_timeout(Duration::from_secs(1)).expect(\"response should be received\");\n        let val = raw.as_ref().ok().map(|v| serde_json::to_string(&v.0));\n        let resp = raw.map_err(|e| e.to_string()).and_then(|r| r.into_response());\n\n        match resp {\n            Err(msg) => panic!(\"Bad response: {:?}. {}\", val, msg),\n            Ok(resp) => resp,\n        }\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"test_utils::DummyReader::expect_rpc":["pub fn expect_rpc(&mut self, method: &str) -> RpcObject{\n        let obj = self\n            .next_timeout(Duration::from_secs(1))\n            .unwrap_or_else(|| panic!(\"expected rpc \\\"{}\\\"\", method))\n            .unwrap();\n        assert_eq!(obj.get_method(), Some(method));\n        obj\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"test_utils::DummyReader::next_timeout":["/// Attempts to read a message, returning `None` if the wait exceeds\n/// `timeout`.\n///\n/// This method makes no assumptions about the contents of the\n/// message, and does no error handling.\npub fn next_timeout(&mut self, timeout: Duration) -> Option<Result<RpcObject, ReadError>>{\n        self.1.recv_timeout(timeout).ok().map(|s| self.0.parse(&s))\n    }","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"test_utils::DummyWriter":["/// Wraps an instance of `mpsc::Sender`, implementing `Write`.\n///\n/// This lets the tx side of an mpsc::channel serve as the destination\n/// stream for an RPC loop.\npub struct DummyWriter(Sender<String>);","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"test_utils::make_reader":["/// Given a string type, returns a `Cursor<Vec<u8>>`, which implements\n/// `BufRead`.\npub fn make_reader<S: AsRef<str>>(s: S) -> Cursor<Vec<u8>>{\n    Cursor::new(s.as_ref().as_bytes().to_vec())\n}","Real(LocalPath(\"rpc/src/test_utils.rs\"))"],"test_utils::test_channel":["/// Returns a `(DummyWriter, DummyReader)` pair.\npub fn test_channel() -> (DummyWriter, DummyReader){\n    let (tx, rx) = channel();\n    (DummyWriter(tx), DummyReader(MessageReader::default(), rx))\n}","Real(LocalPath(\"rpc/src/test_utils.rs\"))"]},"struct_constructor":{"&str":["get_method"],"(test_utils::DummyWriter, test_utils::DummyReader)":["test_channel"],"<S as serde::Serializer>::Ok":["serialize"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"<__S as serde::Serializer>::Ok":["serialize"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor as serde::de::Visitor<'de>>::Value":["visit_bytes","visit_str","visit_u64"],"<error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor<'de> as serde::de::Visitor<'de>>::Value":["visit_map","visit_seq"],"RawPeer":["clone","get_raw_peer"],"RpcCall":["clone","deserialize"],"RpcLoop":["new"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field":["deserialize"],"bool":["eq","is_disconnect","is_response","needs_exit","request_is_pending"],"error::Error":["from"],"error::ErrorHelper":["deserialize"],"error::ReadError":["from"],"error::RemoteError":["clone","custom","deserialize","from"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field":["deserialize"],"parse::Call":["clone","into_rpc"],"parse::MessageReader":["default"],"parse::RpcObject":["clone","expect_object","expect_rpc","from","get_rx_timeout","next","next_read","next_timeout","parse","try_get_rx"],"serde_json::Value":["expect_response","handle_request","into_response","send_rpc_request"],"std::boxed::Box":["box_clone","clone"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::io::Cursor":["make_reader"],"test_utils::DummyPeer":["clone"],"u64":["get_id"],"usize":["check_timers","try_get_idle","write"]},"struct_to_trait":{"<F as Callback>::F":["Callback"],"<F as IdleProc>::F":["IdleProc"],"PanicGuard":["std::ops::Drop"],"RawPeer":["Peer","std::clone::Clone"],"RpcCall":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::fmt::Debug"],"Timer":["std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field":["serde::Deserialize"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor":["serde::de::Visitor"],"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor":["serde::de::Visitor"],"error::Error":["std::convert::From","std::fmt::Debug"],"error::ErrorHelper":["serde::Deserialize","serde::Serialize"],"error::ReadError":["std::convert::From","std::fmt::Debug","std::fmt::Display"],"error::RemoteError":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::StructuralPartialEq"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field":["serde::Deserialize"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor":["serde::de::Visitor"],"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor":["serde::de::Visitor"],"parse::Call":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"parse::MessageReader":["std::default::Default","std::fmt::Debug"],"parse::RpcObject":["std::clone::Clone","std::convert::From","std::fmt::Debug"],"std::boxed::Box":["std::clone::Clone"],"test_utils::DummyPeer":["Peer","std::clone::Clone","std::fmt::Debug"],"test_utils::DummyWriter":["std::io::Write"]},"targets":{"<F as Callback>::call":["call","Real(LocalPath(\"rpc/src/lib.rs\"))","Callback"],"<F as IdleProc>::call":["call","Real(LocalPath(\"rpc/src/lib.rs\"))","IdleProc"],"<PanicGuard<'a, W> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"rpc/src/lib.rs\"))","std::ops::Drop"],"<RawPeer<W> as Peer>::box_clone":["box_clone","Real(LocalPath(\"rpc/src/lib.rs\"))","Peer"],"<RawPeer<W> as Peer>::request_is_pending":["request_is_pending","Real(LocalPath(\"rpc/src/lib.rs\"))","Peer"],"<RawPeer<W> as Peer>::schedule_idle":["schedule_idle","Real(LocalPath(\"rpc/src/lib.rs\"))","Peer"],"<RawPeer<W> as Peer>::schedule_timer":["schedule_timer","Real(LocalPath(\"rpc/src/lib.rs\"))","Peer"],"<RawPeer<W> as Peer>::send_rpc_notification":["send_rpc_notification","Real(LocalPath(\"rpc/src/lib.rs\"))","Peer"],"<RawPeer<W> as Peer>::send_rpc_request":["send_rpc_request","Real(LocalPath(\"rpc/src/lib.rs\"))","Peer"],"<RawPeer<W> as Peer>::send_rpc_request_async":["send_rpc_request_async","Real(LocalPath(\"rpc/src/lib.rs\"))","Peer"],"<RawPeer<W> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"rpc/src/lib.rs\"))","std::clone::Clone"],"<Timer as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"rpc/src/lib.rs\"))","std::cmp::Ord"],"<Timer as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"rpc/src/lib.rs\"))","std::cmp::PartialOrd"],"<error::Error as std::convert::From<error::RemoteError>>::from":["from","Real(LocalPath(\"rpc/src/error.rs\"))","std::convert::From"],"<error::ReadError as std::convert::From<serde_json::Error>>::from":["from","Real(LocalPath(\"rpc/src/error.rs\"))","std::convert::From"],"<error::ReadError as std::convert::From<std::io::Error>>::from":["from","Real(LocalPath(\"rpc/src/error.rs\"))","std::convert::From"],"<error::ReadError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"rpc/src/error.rs\"))","std::fmt::Display"],"<error::RemoteError as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"rpc/src/error.rs\"))","serde::Deserialize"],"<error::RemoteError as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"rpc/src/error.rs\"))","serde::Serialize"],"<error::RemoteError as std::convert::From<serde_json::Error>>::from":["from","Real(LocalPath(\"rpc/src/error.rs\"))","std::convert::From"],"<impl std::clone::Clone for std::boxed::Box<(dyn Peer + 'static)>>::clone":["clone","Real(LocalPath(\"rpc/src/lib.rs\"))","std::clone::Clone"],"<parse::RpcObject as std::convert::From<serde_json::Value>>::from":["from","Real(LocalPath(\"rpc/src/parse.rs\"))","std::convert::From"],"<test_utils::DummyPeer as Peer>::box_clone":["box_clone","Real(LocalPath(\"rpc/src/test_utils.rs\"))","Peer"],"<test_utils::DummyPeer as Peer>::request_is_pending":["request_is_pending","Real(LocalPath(\"rpc/src/test_utils.rs\"))","Peer"],"<test_utils::DummyPeer as Peer>::schedule_idle":["schedule_idle","Real(LocalPath(\"rpc/src/test_utils.rs\"))","Peer"],"<test_utils::DummyPeer as Peer>::schedule_timer":["schedule_timer","Real(LocalPath(\"rpc/src/test_utils.rs\"))","Peer"],"<test_utils::DummyPeer as Peer>::send_rpc_notification":["send_rpc_notification","Real(LocalPath(\"rpc/src/test_utils.rs\"))","Peer"],"<test_utils::DummyPeer as Peer>::send_rpc_request":["send_rpc_request","Real(LocalPath(\"rpc/src/test_utils.rs\"))","Peer"],"<test_utils::DummyPeer as Peer>::send_rpc_request_async":["send_rpc_request_async","Real(LocalPath(\"rpc/src/test_utils.rs\"))","Peer"],"<test_utils::DummyWriter as std::io::Write>::flush":["flush","Real(LocalPath(\"rpc/src/test_utils.rs\"))","std::io::Write"],"<test_utils::DummyWriter as std::io::Write>::write":["write","Real(LocalPath(\"rpc/src/test_utils.rs\"))","std::io::Write"],"Handler::idle":["idle","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::check_timers":["check_timers","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::disconnect":["disconnect","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::get_rx_timeout":["get_rx_timeout","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::handle_response":["handle_response","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::needs_exit":["needs_exit","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::put_rx":["put_rx","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::reset_needs_exit":["reset_needs_exit","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::respond":["respond","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::send":["send","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::send_rpc_request_common":["send_rpc_request_common","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::try_get_idle":["try_get_idle","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RawPeer::<W>::try_get_rx":["try_get_rx","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"ResponseHandler::invoke":["invoke","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RpcCtx::get_peer":["get_peer","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RpcCtx::schedule_idle":["schedule_idle","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RpcLoop::<W>::get_raw_peer":["get_raw_peer","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RpcLoop::<W>::mainloop":["mainloop","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"RpcLoop::<W>::new":["new","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"do_idle":["do_idle","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"error::ReadError::is_disconnect":["is_disconnect","Real(LocalPath(\"rpc/src/error.rs\"))",""],"error::RemoteError::custom":["custom","Real(LocalPath(\"rpc/src/error.rs\"))",""],"next_read":["next_read","Real(LocalPath(\"rpc/src/lib.rs\"))",""],"parse::MessageReader::next":["next","Real(LocalPath(\"rpc/src/parse.rs\"))",""],"parse::MessageReader::parse":["parse","Real(LocalPath(\"rpc/src/parse.rs\"))",""],"parse::RpcObject::get_id":["get_id","Real(LocalPath(\"rpc/src/parse.rs\"))",""],"parse::RpcObject::get_method":["get_method","Real(LocalPath(\"rpc/src/parse.rs\"))",""],"parse::RpcObject::into_response":["into_response","Real(LocalPath(\"rpc/src/parse.rs\"))",""],"parse::RpcObject::into_rpc":["into_rpc","Real(LocalPath(\"rpc/src/parse.rs\"))",""],"parse::RpcObject::is_response":["is_response","Real(LocalPath(\"rpc/src/parse.rs\"))",""],"test_utils::DummyReader::expect_nothing":["expect_nothing","Real(LocalPath(\"rpc/src/test_utils.rs\"))",""],"test_utils::DummyReader::expect_object":["expect_object","Real(LocalPath(\"rpc/src/test_utils.rs\"))",""],"test_utils::DummyReader::expect_response":["expect_response","Real(LocalPath(\"rpc/src/test_utils.rs\"))",""],"test_utils::DummyReader::expect_rpc":["expect_rpc","Real(LocalPath(\"rpc/src/test_utils.rs\"))",""],"test_utils::DummyReader::next_timeout":["next_timeout","Real(LocalPath(\"rpc/src/test_utils.rs\"))",""],"test_utils::make_reader":["make_reader","Real(LocalPath(\"rpc/src/test_utils.rs\"))",""],"test_utils::test_channel":["test_channel","Real(LocalPath(\"rpc/src/test_utils.rs\"))",""]},"trait_to_struct":{"Callback":["<F as Callback>::F"],"IdleProc":["<F as IdleProc>::F"],"Peer":["RawPeer","test_utils::DummyPeer"],"serde::Deserialize":["RpcCall","_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field","error::ErrorHelper","error::RemoteError","error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field"],"serde::Serialize":["RpcCall","error::ErrorHelper","error::RemoteError"],"serde::de::Visitor":["_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor","_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor","error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor","error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor"],"std::clone::Clone":["RawPeer","RpcCall","error::RemoteError","parse::Call","parse::RpcObject","std::boxed::Box","test_utils::DummyPeer"],"std::cmp::Eq":["Timer"],"std::cmp::Ord":["Timer"],"std::cmp::PartialEq":["Timer","error::RemoteError","parse::Call"],"std::cmp::PartialOrd":["Timer"],"std::convert::From":["error::Error","error::ReadError","error::RemoteError","parse::RpcObject"],"std::default::Default":["parse::MessageReader"],"std::fmt::Debug":["RpcCall","Timer","error::Error","error::ReadError","error::RemoteError","parse::Call","parse::MessageReader","parse::RpcObject","test_utils::DummyPeer"],"std::fmt::Display":["error::ReadError"],"std::io::Write":["test_utils::DummyWriter"],"std::marker::StructuralEq":["Timer"],"std::marker::StructuralPartialEq":["Timer","error::RemoteError","parse::Call"],"std::ops::Drop":["PanicGuard"]},"type_to_def_path":{"PanicGuard<'a, W>":"PanicGuard","RawPeer<W>":"RawPeer","ResponseHandler":"ResponseHandler","RpcCall":"RpcCall","RpcCtx":"RpcCtx","RpcLoop<W>":"RpcLoop","RpcState<W>":"RpcState","Timer":"Timer","_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field":"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Field","_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor":"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__FieldVisitor","_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor<'de>":"_IMPL_DESERIALIZE_FOR_RpcCall::<impl serde::Deserialize<'de> for RpcCall>::deserialize::__Visitor","error::Error":"error::Error","error::ErrorHelper":"error::ErrorHelper","error::ReadError":"error::ReadError","error::RemoteError":"error::RemoteError","error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field":"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Field","error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor":"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__FieldVisitor","error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor<'de>":"error::_IMPL_DESERIALIZE_FOR_ErrorHelper::<impl serde::Deserialize<'de> for error::ErrorHelper>::deserialize::__Visitor","parse::Call<N, R>":"parse::Call","parse::MessageReader":"parse::MessageReader","parse::RpcObject":"parse::RpcObject","test_utils::DummyPeer":"test_utils::DummyPeer","test_utils::DummyReader":"test_utils::DummyReader","test_utils::DummyWriter":"test_utils::DummyWriter"}}