{"dependencies":{"<T as interval::IntervalBounds>::into_interval":["interval::Interval"],"<breaks::BreakBuilder as std::default::Default>::default":["breaks::BreakBuilder","breaks::BreaksBaseMetric","breaks::BreaksInfo","breaks::BreaksLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"<breaks::BreaksBaseMetric as std::clone::Clone>::clone":["breaks::BreaksBaseMetric"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment":[],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::measure":["breaks::BreaksInfo"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::next":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::prev":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksInfo as std::clone::Clone>::clone":["breaks::BreaksInfo"],"<breaks::BreaksInfo as std::fmt::Debug>::fmt":["breaks::BreaksInfo","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<breaks::BreaksInfo as tree::NodeInfo>::accumulate":["breaks::BreaksInfo"],"<breaks::BreaksInfo as tree::NodeInfo>::compute_info":["breaks::BreaksInfo","breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksLeaf as std::clone::Clone>::clone":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksLeaf as std::cmp::Eq>::assert_receiver_is_total_eq":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksLeaf as std::cmp::PartialEq>::eq":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksLeaf as std::default::Default>::default":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksLeaf as std::fmt::Debug>::fmt":["breaks::BreaksLeaf","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<breaks::BreaksLeaf as tree::Leaf>::is_ok_child":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksLeaf as tree::Leaf>::len":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksLeaf as tree::Leaf>::push_maybe_split":["breaks::BreaksLeaf","interval::Interval","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<breaks::BreaksMetric as std::clone::Clone>::clone":["breaks::BreaksMetric"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment":[],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::measure":["breaks::BreaksInfo"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::next":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::prev":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::DeletionsIter","std::clone::Clone","std::marker::Sized","std::option::Option","std::slice::Iter","tree::NodeInfo"],"<delta::Delta<N> as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"<delta::Delta<N> as std::fmt::Debug>::fmt":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","tree::NodeInfo"],"<delta::DeltaElement<N> as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::DeltaElement","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"<delta::DeltaRegion as std::cmp::PartialEq>::eq":["delta::DeltaRegion"],"<delta::DeltaRegion as std::fmt::Debug>::fmt":["delta::DeltaRegion","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<delta::InsertDelta<N> as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"<delta::InsertDelta<N> as std::fmt::Debug>::fmt":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","std::alloc::Allocator","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","tree::NodeInfo"],"<delta::InsertDelta<N> as std::ops::Deref>::deref":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"<delta::InsertsIter<'a, N> as std::iter::Iterator>::next":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::InsertsIter","std::clone::Clone","std::marker::Sized","std::option::Option","std::slice::Iter","tree::NodeInfo"],"<diff::DiffBuilder as std::clone::Clone>::clone":["diff::DiffBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<diff::DiffBuilder as std::default::Default>::default":["diff::DiffBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<diff::DiffBuilder as std::fmt::Debug>::fmt":["diff::DiffBuilder","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<diff::DiffOp as std::clone::Clone>::clone":["diff::DiffOp"],"<diff::DiffOp as std::fmt::Debug>::fmt":["diff::DiffOp","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<diff::LineHashDiff as diff::Diff<rope::RopeInfo>>::compute_delta":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"<engine::Contents as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","engine::Contents","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::vec::Vec"],"<engine::Contents as std::fmt::Debug>::fmt":["breaks::BreaksBaseMetric","engine::Contents","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<engine::DeltaOp as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","engine::DeltaOp","engine::RevId","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"<engine::DeltaOp as std::fmt::Debug>::fmt":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","engine::DeltaOp","engine::RevId","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec","tree::NodeInfo"],"<engine::Engine as std::fmt::Debug>::fmt":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"<engine::Error as std::clone::Clone>::clone":["engine::Error"],"<engine::Error as std::fmt::Debug>::fmt":["engine::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<engine::Error as std::fmt::Display>::fmt":["engine::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<engine::FullPriority as std::clone::Clone>::clone":["engine::FullPriority"],"<engine::FullPriority as std::cmp::Eq>::assert_receiver_is_total_eq":["engine::FullPriority"],"<engine::FullPriority as std::cmp::Ord>::cmp":["engine::FullPriority","std::cmp::Ordering"],"<engine::FullPriority as std::cmp::PartialEq>::eq":["engine::FullPriority"],"<engine::FullPriority as std::cmp::PartialOrd>::partial_cmp":["engine::FullPriority","std::marker::Sized","std::option::Option"],"<engine::RevId as std::clone::Clone>::clone":["engine::RevId"],"<engine::RevId as std::cmp::Eq>::assert_receiver_is_total_eq":["engine::RevId"],"<engine::RevId as std::cmp::Ord>::cmp":["engine::RevId","std::cmp::Ordering"],"<engine::RevId as std::cmp::PartialEq>::eq":["engine::RevId"],"<engine::RevId as std::cmp::PartialOrd>::partial_cmp":["engine::RevId","std::marker::Sized","std::option::Option"],"<engine::RevId as std::fmt::Debug>::fmt":["engine::RevId","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<engine::RevId as std::hash::Hash>::hash":["engine::RevId","std::hash::Hasher","std::marker::Sized"],"<engine::Revision as std::fmt::Debug>::fmt":["breaks::BreaksBaseMetric","engine::Contents","engine::RevId","engine::Revision","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<find::CaseMatching as std::clone::Clone>::clone":["find::CaseMatching"],"<find::CaseMatching as std::cmp::PartialEq>::eq":["find::CaseMatching"],"<interval::Interval as std::clone::Clone>::clone":["interval::Interval"],"<interval::Interval as std::cmp::Eq>::assert_receiver_is_total_eq":["interval::Interval"],"<interval::Interval as std::cmp::PartialEq>::eq":["interval::Interval"],"<interval::Interval as std::convert::From<std::ops::Range<usize>>>::from":["interval::Interval","std::marker::Sized","std::ops::Range"],"<interval::Interval as std::convert::From<std::ops::RangeInclusive<usize>>>::from":["interval::Interval","std::marker::Sized","std::ops::RangeInclusive"],"<interval::Interval as std::convert::From<std::ops::RangeTo<usize>>>::from":["interval::Interval","std::marker::Sized","std::ops::RangeTo"],"<interval::Interval as std::convert::From<std::ops::RangeToInclusive<usize>>>::from":["interval::Interval","std::marker::Sized","std::ops::RangeToInclusive"],"<interval::Interval as std::fmt::Debug>::fmt":["interval::Interval","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<interval::Interval as std::fmt::Display>::fmt":["interval::Interval","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<multiset::CountMatcher as std::clone::Clone>::clone":["multiset::CountMatcher"],"<multiset::CountMatcher as std::fmt::Debug>::fmt":["multiset::CountMatcher","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<multiset::RangeIter<'a> as std::iter::Iterator>::next":["multiset::CountMatcher","multiset::RangeIter","std::marker::Sized","std::option::Option","std::slice::Iter"],"<multiset::Segment as std::clone::Clone>::clone":["multiset::Segment"],"<multiset::Segment as std::cmp::Eq>::assert_receiver_is_total_eq":["multiset::Segment"],"<multiset::Segment as std::cmp::PartialEq>::eq":["multiset::Segment"],"<multiset::Segment as std::fmt::Debug>::fmt":["multiset::Segment","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<multiset::Subset as std::clone::Clone>::clone":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<multiset::Subset as std::cmp::Eq>::assert_receiver_is_total_eq":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<multiset::Subset as std::cmp::PartialEq>::eq":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<multiset::Subset as std::fmt::Debug>::fmt":["multiset::Subset","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<multiset::SubsetBuilder as std::default::Default>::default":["multiset::SubsetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<multiset::ZipIter<'a> as std::iter::Iterator>::next":["multiset::Segment","multiset::ZipIter","std::marker::Sized","std::option::Option"],"<multiset::ZipSegment as std::clone::Clone>::clone":["multiset::ZipSegment"],"<multiset::ZipSegment as std::fmt::Debug>::fmt":["multiset::ZipSegment","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<rope::BaseMetric as std::clone::Clone>::clone":["rope::BaseMetric"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::can_fragment":[],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::from_base_units":["std::string::String"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::is_boundary":["std::string::String"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::measure":["rope::RopeInfo"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::next":["std::marker::Sized","std::option::Option","std::string::String"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::prev":["std::marker::Sized","std::option::Option","std::string::String"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::to_base_units":["std::string::String"],"<rope::ChunkIter<'a> as std::iter::Iterator>::next":["breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::ChunkIter","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"<rope::Lines<'a> as std::iter::Iterator>::next":["breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::ChunkIter","rope::Lines","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"<rope::LinesMetric as std::clone::Clone>::clone":["rope::LinesMetric"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::can_fragment":[],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::from_base_units":["std::string::String"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::is_boundary":["std::string::String"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::measure":["rope::RopeInfo"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::next":["std::marker::Sized","std::option::Option","std::string::String"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::prev":["std::marker::Sized","std::option::Option","std::string::String"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::to_base_units":["std::string::String"],"<rope::LinesRaw<'a> as std::iter::Iterator>::next":["breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"<rope::RopeInfo as std::clone::Clone>::clone":["rope::RopeInfo"],"<rope::RopeInfo as tree::NodeInfo>::accumulate":["rope::RopeInfo"],"<rope::RopeInfo as tree::NodeInfo>::compute_info":["rope::RopeInfo","std::string::String"],"<rope::RopeInfo as tree::NodeInfo>::identity":["rope::RopeInfo"],"<rope::Utf16CodeUnitsMetric as std::clone::Clone>::clone":["rope::Utf16CodeUnitsMetric"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::can_fragment":[],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::from_base_units":["std::string::String"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::is_boundary":["std::string::String"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::measure":["rope::RopeInfo"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::next":["std::marker::Sized","std::option::Option","std::string::String"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::prev":["std::marker::Sized","std::option::Option","std::string::String"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::to_base_units":["std::string::String"],"<spans::Span<T> as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","interval::Interval","spans::Span","std::clone::Clone","std::marker::Sized"],"<spans::SpanIter<'a, T> as std::iter::Iterator>::next":["breaks::BreaksBaseMetric","breaks::BreaksInfo","spans::SpanIter","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"<spans::SpansInfo<T> as std::clone::Clone>::clone":["interval::Interval","spans::SpansInfo","std::marker::PhantomData","std::marker::Sized"],"<spans::SpansInfo<T> as tree::NodeInfo>::accumulate":["interval::Interval","spans::SpansInfo","std::marker::PhantomData","std::marker::Sized"],"<spans::SpansInfo<T> as tree::NodeInfo>::compute_info":["breaks::BreaksBaseMetric","interval::Interval","spans::SpansInfo","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"<spans::SpansLeaf<T> as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec"],"<spans::SpansLeaf<T> as std::default::Default>::default":["breaks::BreaksBaseMetric","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec"],"<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child":["breaks::BreaksBaseMetric","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec"],"<spans::SpansLeaf<T> as tree::Leaf>::len":["breaks::BreaksBaseMetric","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec"],"<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split":["breaks::BreaksBaseMetric","interval::Interval","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::option::Option","std::vec::Vec"],"<std::ops::RangeFrom<usize> as interval::IntervalBounds>::into_interval":["interval::Interval","std::marker::Sized","std::ops::RangeFrom"],"<std::ops::RangeFull as interval::IntervalBounds>::into_interval":["interval::Interval","std::ops::RangeFull"],"<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::CursorIter","tree::Metric","tree::Node","tree::NodeInfo"],"<tree::Node<N> as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"<tree::Node<N> as std::default::Default>::default":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"<tree::NodeBody<N> as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeBody","tree::NodeInfo","tree::NodeVal"],"<tree::NodeVal<N> as std::clone::Clone>::clone":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::NodeVal"],"breaks::<impl tree::Node<breaks::BreaksInfo>>::new_no_break":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"breaks::BreakBuilder":["breaks::BreakBuilder","breaks::BreaksBaseMetric","breaks::BreaksInfo","breaks::BreaksLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"breaks::BreakBuilder::add_break":["breaks::BreakBuilder","breaks::BreaksBaseMetric","breaks::BreaksInfo","breaks::BreaksLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"breaks::BreakBuilder::add_no_break":["breaks::BreakBuilder","breaks::BreaksBaseMetric","breaks::BreaksInfo","breaks::BreaksLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"breaks::BreakBuilder::build":["breaks::BreakBuilder","breaks::BreaksBaseMetric","breaks::BreaksInfo","breaks::BreaksLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo","tree::TreeBuilder"],"breaks::BreakBuilder::new":["breaks::BreakBuilder","breaks::BreaksBaseMetric","breaks::BreaksInfo","breaks::BreaksLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"breaks::BreaksBaseMetric":["breaks::BreaksBaseMetric"],"breaks::BreaksInfo":["breaks::BreaksInfo"],"breaks::BreaksLeaf":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"breaks::BreaksLeaf::get_data_cloned":["breaks::BreaksLeaf","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"breaks::BreaksMetric":["breaks::BreaksMetric"],"compare::RopeScanner":["breaks::BreaksBaseMetric","breaks::BreaksInfo","compare::RopeScanner","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"compare::RopeScanner::<'a>::find_min_diff_range":["breaks::BreaksBaseMetric","breaks::BreaksInfo","compare::RopeScanner","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"compare::RopeScanner::<'a>::find_ne_char":["breaks::BreaksBaseMetric","breaks::BreaksInfo","compare::RopeScanner","std::clone::Clone","std::convert::Into","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"compare::RopeScanner::<'a>::find_ne_char_back":["breaks::BreaksBaseMetric","breaks::BreaksInfo","compare::RopeScanner","std::clone::Clone","std::convert::Into","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"compare::RopeScanner::<'a>::load_next_chunk":["breaks::BreaksBaseMetric","breaks::BreaksInfo","compare::RopeScanner","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"compare::RopeScanner::<'a>::load_prev_chunk":["breaks::BreaksBaseMetric","breaks::BreaksInfo","compare::RopeScanner","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"compare::RopeScanner::<'a>::new":["breaks::BreaksBaseMetric","breaks::BreaksInfo","compare::RopeScanner","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"compare::avx_compare_mask":[],"compare::ne_idx":["std::marker::Sized","std::option::Option"],"compare::ne_idx_avx":["std::marker::Sized","std::option::Option"],"compare::ne_idx_fallback":["std::marker::Sized","std::option::Option"],"compare::ne_idx_rev":["std::marker::Sized","std::option::Option"],"compare::ne_idx_rev_fallback":["std::marker::Sized","std::option::Option"],"compare::ne_idx_rev_sse":["std::marker::Sized","std::option::Option"],"compare::ne_idx_sse":["std::marker::Sized","std::option::Option"],"compare::sse_compare_mask":[],"delta::Builder":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Builder","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Builder::<N>::build":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Builder","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Builder::<N>::delete":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Builder","delta::Delta","interval::IntervalBounds","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Builder::<N>::is_empty":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Builder","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Builder::<N>::new":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Builder","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Builder::<N>::replace":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Builder","delta::Delta","interval::IntervalBounds","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"delta::DeletionsIter":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::DeletionsIter","std::clone::Clone","std::marker::Sized","std::slice::Iter","tree::NodeInfo"],"delta::Delta":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::apply":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"delta::Delta::<N>::as_simple_insert":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::option::Option","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::factor":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::inserts_len":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::is_identity":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::is_simple_delete":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::iter_deletions":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::DeletionsIter","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::slice::Iter","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::iter_inserts":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertsIter","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::slice::Iter","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::new_document_len":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::simple_edit":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","interval::IntervalBounds","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"delta::Delta::<N>::summary":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","interval::Interval","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Delta::<N>::synthesize":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"delta::Delta::<N>::total_element_len":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::DeltaElement","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"delta::DeltaElement":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::DeltaElement","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"delta::DeltaRegion":["delta::DeltaRegion"],"delta::DeltaRegion::new":["delta::DeltaRegion"],"delta::InsertDelta":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::InsertDelta::<N>::inserted_subset":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::InsertDelta::<N>::transform_expand":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::InsertDelta::<N>::transform_shrink":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::InsertsIter":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::InsertsIter","std::clone::Clone","std::marker::Sized","std::slice::Iter","tree::NodeInfo"],"delta::Transformer":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::Transformer","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Transformer::<'a, N>::interval_untouched":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::Transformer","interval::IntervalBounds","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Transformer::<'a, N>::new":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::Transformer","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"delta::Transformer::<'a, N>::transform":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::Transformer","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"diff::Diff::compute_delta":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"diff::DiffBuilder":["diff::DiffBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"diff::DiffBuilder::copy":["diff::DiffBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"diff::DiffBuilder::to_delta":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","diff::DiffBuilder","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"diff::DiffOp":["diff::DiffOp"],"diff::LineHashDiff":["diff::LineHashDiff"],"diff::expand_match":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"diff::longest_increasing_region_set":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"diff::make_line_hashes":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::collections::HashMap","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"diff::non_ws_offset":[],"engine::Contents":["breaks::BreaksBaseMetric","engine::Contents","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::vec::Vec"],"engine::DeltaOp":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::InsertDelta","engine::DeltaOp","engine::RevId","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo"],"engine::Engine":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::compute_undo":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Contents","engine::Engine","engine::RevId","engine::Revision","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::deletes_from_cur_union_for_index":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::deletes_from_union_before_index":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::deletes_from_union_for_index":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::edit_rev":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::empty":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::empty_subset_before_first_rev":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::find_first_undo_candidate_index":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::find_rev":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","engine::RevId","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::find_rev_token":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::gc":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::get_head":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::get_head_rev_id":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","engine::RevId","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::get_rev":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::is_equivalent_revision":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","engine::RevId","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::max_undo_group_id":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::merge":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::mk_new_rev":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::new":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::next_rev_id":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","engine::RevId","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::rev_content_for_index":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::set_session_id":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::try_delta_rev_head":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::try_edit_rev":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Engine::undo":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Engine","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::Error":["engine::Error"],"engine::FullPriority":["engine::FullPriority"],"engine::RevId":["engine::RevId"],"engine::RevId::session_id":["engine::RevId"],"engine::RevId::token":["engine::RevId"],"engine::Revision":["breaks::BreaksBaseMetric","engine::Contents","engine::RevId","engine::Revision","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::vec::Vec"],"engine::compute_deltas":["breaks::BreaksBaseMetric","breaks::BreaksInfo","engine::Contents","engine::RevId","engine::Revision","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::compute_transforms":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"engine::default_session":[],"engine::find_base_index":["breaks::BreaksBaseMetric","engine::Contents","engine::RevId","engine::Revision","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::vec::Vec"],"engine::find_common":["breaks::BreaksBaseMetric","engine::Contents","engine::RevId","engine::Revision","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::vec::Vec"],"engine::rearrange":["breaks::BreaksBaseMetric","engine::Contents","engine::RevId","engine::Revision","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeSet","std::marker::Sized","std::vec::Vec"],"engine::rebase":["breaks::BreaksBaseMetric","breaks::BreaksInfo","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::shuffle":["breaks::BreaksBaseMetric","breaks::BreaksInfo","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"engine::shuffle_tombstones":["breaks::BreaksBaseMetric","breaks::BreaksInfo","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"find::CaseMatching":["find::CaseMatching"],"find::FindResult":["find::FindResult"],"find::compare_cursor_regex":["breaks::BreaksBaseMetric","breaks::BreaksInfo","regex::Regex","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"find::compare_cursor_str":["breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"find::compare_cursor_str_casei":["breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"find::find":["breaks::BreaksBaseMetric","breaks::BreaksInfo","find::CaseMatching","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"find::find_core":["breaks::BreaksBaseMetric","breaks::BreaksInfo","find::FindResult","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::ops::Fn","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"find::find_progress":["breaks::BreaksBaseMetric","breaks::BreaksInfo","find::CaseMatching","find::FindResult","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"find::find_progress_iter":["breaks::BreaksBaseMetric","breaks::BreaksInfo","find::FindResult","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::ops::Fn","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"find::is_multiline_regex":[],"find::scan_lowercase":["std::marker::Sized","std::option::Option"],"interval::Interval":["interval::Interval"],"interval::Interval::contains":["interval::Interval"],"interval::Interval::end":["interval::Interval"],"interval::Interval::intersect":["interval::Interval"],"interval::Interval::is_after":["interval::Interval"],"interval::Interval::is_before":["interval::Interval"],"interval::Interval::is_empty":["interval::Interval"],"interval::Interval::new":["interval::Interval"],"interval::Interval::new_closed_closed":["interval::Interval"],"interval::Interval::new_closed_open":["interval::Interval"],"interval::Interval::new_open_closed":["interval::Interval"],"interval::Interval::new_open_open":["interval::Interval"],"interval::Interval::prefix":["interval::Interval"],"interval::Interval::size":["interval::Interval"],"interval::Interval::start":["interval::Interval"],"interval::Interval::start_end":["interval::Interval"],"interval::Interval::suffix":["interval::Interval"],"interval::Interval::translate":["interval::Interval"],"interval::Interval::translate_neg":["interval::Interval"],"interval::Interval::union":["interval::Interval"],"interval::IntervalBounds::into_interval":["interval::Interval"],"multiset::CountMatcher":["multiset::CountMatcher"],"multiset::CountMatcher::matches":["multiset::CountMatcher","multiset::Segment"],"multiset::Mapper":["multiset::CountMatcher","multiset::Mapper","multiset::RangeIter","std::marker::Sized","std::slice::Iter"],"multiset::Mapper::<'a>::doc_index_to_subset":["multiset::CountMatcher","multiset::Mapper","multiset::RangeIter","std::marker::Sized","std::slice::Iter"],"multiset::RangeIter":["multiset::CountMatcher","multiset::RangeIter","std::marker::Sized","std::slice::Iter"],"multiset::Segment":["multiset::Segment"],"multiset::Subset":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::bitxor":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::complement":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::complement_iter":["multiset::CountMatcher","multiset::RangeIter","multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::slice::Iter","std::vec::Vec"],"multiset::Subset::count":["multiset::CountMatcher","multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::delete_from":["breaks::BreaksBaseMetric","breaks::BreaksInfo","multiset::Subset","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"multiset::Subset::delete_from_string":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec"],"multiset::Subset::is_empty":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::len":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::len_after_delete":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::mapper":["multiset::CountMatcher","multiset::Mapper","multiset::RangeIter","multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::slice::Iter","std::vec::Vec"],"multiset::Subset::new":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::range_iter":["multiset::CountMatcher","multiset::RangeIter","multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::slice::Iter","std::vec::Vec"],"multiset::Subset::subtract":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::transform":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::transform_expand":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::transform_shrink":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::transform_union":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::union":["multiset::Subset","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::Subset::zip":["multiset::Segment","multiset::Subset","multiset::ZipIter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::SubsetBuilder":["multiset::SubsetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::SubsetBuilder::add_range":["multiset::SubsetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::SubsetBuilder::build":["multiset::Subset","multiset::SubsetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::SubsetBuilder::new":["multiset::SubsetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::SubsetBuilder::pad_to_len":["multiset::SubsetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::SubsetBuilder::push_segment":["multiset::SubsetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"multiset::ZipIter":["multiset::Segment","multiset::ZipIter"],"multiset::ZipSegment":["multiset::ZipSegment"],"rope::<impl std::convert::From<&'a tree::Node<rope::RopeInfo>> for std::string::String>::from":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::string::String","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl std::convert::From<tree::Node<rope::RopeInfo>> for std::string::String>::from":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::string::String","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl std::fmt::Debug for tree::Node<rope::RopeInfo>>::fmt":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl std::fmt::Display for tree::Node<rope::RopeInfo>>::fmt":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl std::ops::Add for tree::Node<rope::RopeInfo>>::add":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl std::str::FromStr for tree::Node<rope::RopeInfo>>::from_str":["std::marker::Sized","std::result::Result"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_codepoint":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_grapheme":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::<impl tree::Leaf for std::string::String>::is_ok_child":["std::string::String"],"rope::<impl tree::Leaf for std::string::String>::len":["std::string::String"],"rope::<impl tree::Leaf for std::string::String>::push_maybe_split":["interval::Interval","std::marker::Sized","std::option::Option","std::string::String"],"rope::<impl tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::byte_at":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::edit_str":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::IntervalBounds","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::is_codepoint_boundary":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::IntervalBounds","rope::ChunkIter","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::line_of_offset":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::lines":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::IntervalBounds","rope::ChunkIter","rope::Lines","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::lines_raw":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::IntervalBounds","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::next_codepoint_offset":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::next_grapheme_offset":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::offset_of_line":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::prev_codepoint_offset":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::prev_grapheme_offset":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::slice":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::IntervalBounds","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::IntervalBounds","std::borrow::Cow","std::borrow::ToOwned","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"rope::<impl tree::TreeBuilder<rope::RopeInfo>>::push_str":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"rope::BaseMetric":["rope::BaseMetric"],"rope::ChunkIter":["breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::ChunkIter","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::Lines":["breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::ChunkIter","rope::Lines","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::LinesMetric":["rope::LinesMetric"],"rope::LinesRaw":["breaks::BreaksBaseMetric","breaks::BreaksInfo","rope::ChunkIter","rope::LinesRaw","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"rope::RopeInfo":["rope::RopeInfo"],"rope::Utf16CodeUnitsMetric":["rope::Utf16CodeUnitsMetric"],"rope::count_newlines":[],"rope::count_utf16_code_units":[],"rope::cow_append":["std::borrow::Cow","std::borrow::ToOwned"],"rope::find_leaf_split":[],"rope::find_leaf_split_for_bulk":[],"rope::find_leaf_split_for_merge":[],"rope::len_utf8_from_first_byte":[],"spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","tree::Node","tree::NodeInfo"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after":["breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::Interval","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::iter":["breaks::BreaksBaseMetric","breaks::BreaksInfo","spans::SpanIter","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::merge":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::ops::FnMut","std::sync::Arc","tree::Node","tree::NodeInfo"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::transform":["breaks::BreaksBaseMetric","breaks::BreaksInfo","delta::Delta","delta::Transformer","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"spans::Span":["breaks::BreaksBaseMetric","interval::Interval","spans::Span","std::clone::Clone","std::marker::Sized"],"spans::SpanIter":["breaks::BreaksBaseMetric","breaks::BreaksInfo","spans::SpanIter","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"spans::SpansBuilder":["breaks::BreaksBaseMetric","breaks::BreaksInfo","spans::SpansBuilder","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"spans::SpansBuilder::<T>::add_span":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::IntervalBounds","spans::SpansBuilder","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"spans::SpansBuilder::<T>::build":["breaks::BreaksBaseMetric","breaks::BreaksInfo","spans::SpansBuilder","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo","tree::TreeBuilder"],"spans::SpansBuilder::<T>::new":["breaks::BreaksBaseMetric","breaks::BreaksInfo","spans::SpansBuilder","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"spans::SpansInfo":["interval::Interval","spans::SpansInfo","std::marker::PhantomData","std::marker::Sized"],"spans::SpansLeaf":["breaks::BreaksBaseMetric","spans::SpansLeaf","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec"],"tree::Cursor":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::at_or_next":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::at_or_prev":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::descend":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::descend_metric":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::get_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::is_boundary":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::iter":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::CursorIter","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::last_inside_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::measure_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::new":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::next":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::next_inside_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::next_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::pos":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::prev":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::prev_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::root":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::set":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::Cursor::<'a, N>::total_len":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::Node","tree::NodeInfo"],"tree::CursorIter":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::CursorIter","tree::Metric","tree::Node","tree::NodeInfo"],"tree::CursorIter::<'c, 'a, N, M>::pos":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::sync::Arc","tree::Cursor","tree::CursorIter","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Leaf::is_ok_child":[],"tree::Leaf::len":[],"tree::Leaf::push_maybe_split":["interval::Interval","std::marker::Sized","std::option::Option"],"tree::Leaf::subseq":["interval::Interval"],"tree::Metric::can_fragment":[],"tree::Metric::from_base_units":[],"tree::Metric::is_boundary":[],"tree::Metric::measure":[],"tree::Metric::next":["std::marker::Sized","std::option::Option"],"tree::Metric::prev":["std::marker::Sized","std::option::Option"],"tree::Metric::to_base_units":[],"tree::Node":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::concat":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::convert_metrics":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Node::<N>::count":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Node::<N>::count_base_units":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Node::<N>::edit":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::IntervalBounds","std::clone::Clone","std::convert::Into","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::from_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::from_nodes":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo"],"tree::Node::<N>::get_children":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::get_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::height":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::interval":["breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::Interval","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::is_empty":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::is_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::is_ok_child":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::len":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::measure":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Metric","tree::Node","tree::NodeInfo"],"tree::Node::<N>::merge_leaves":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::merge_nodes":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::ptr_eq":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::push_subseq":["breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::Interval","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo","tree::TreeBuilder"],"tree::Node::<N>::subseq":["<T as interval::IntervalBounds>::T","breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::IntervalBounds","std::clone::Clone","std::marker::Sized","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::Node::<N>::with_leaf_mut":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::clone::Clone","std::marker::Sized","std::ops::FnOnce","std::sync::Arc","tree::Node","tree::NodeInfo"],"tree::NodeBody":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeBody","tree::NodeInfo","tree::NodeVal"],"tree::NodeInfo::accumulate":[],"tree::NodeInfo::compute_info":[],"tree::NodeInfo::identity":[],"tree::NodeInfo::interval":["interval::Interval"],"tree::NodeVal":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::NodeVal"],"tree::TreeBuilder":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"tree::TreeBuilder::<N>::build":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo","tree::TreeBuilder"],"tree::TreeBuilder::<N>::new":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"tree::TreeBuilder::<N>::pop":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo","tree::TreeBuilder"],"tree::TreeBuilder::<N>::push":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::sync::Arc","std::vec::Vec","tree::Node","tree::NodeInfo","tree::TreeBuilder"],"tree::TreeBuilder::<N>::push_leaf":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"tree::TreeBuilder::<N>::push_leaf_slice":["breaks::BreaksBaseMetric","breaks::BreaksInfo","interval::Interval","std::alloc::Allocator","std::clone::Clone","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"],"tree::TreeBuilder::<N>::push_leaves":["breaks::BreaksBaseMetric","breaks::BreaksInfo","std::alloc::Allocator","std::clone::Clone","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec","tree::NodeInfo","tree::TreeBuilder"]},"glob_path_import":{},"self_to_fn":{"<T as interval::IntervalBounds>::T":["impl<T: Into<Interval>> IntervalBounds for T {\n    fn into_interval(self, _upper_bound: usize) -> Interval {\n        self.into()\n    }\n}"],"breaks::BreakBuilder":["impl BreakBuilder {\n    pub fn new() -> BreakBuilder {\n        BreakBuilder::default()\n    }\n\n    pub fn add_break(&mut self, len: usize) {\n        if self.leaf.data.len() == MAX_LEAF {\n            let leaf = mem::take(&mut self.leaf);\n            self.b.push(Node::from_leaf(leaf));\n        }\n        self.leaf.len += len;\n        self.leaf.data.push(self.leaf.len);\n    }\n\n    pub fn add_no_break(&mut self, len: usize) {\n        self.leaf.len += len;\n    }\n\n    pub fn build(mut self) -> Breaks {\n        self.b.push(Node::from_leaf(self.leaf));\n        self.b.build()\n    }\n}","impl Default for BreakBuilder {\n    fn default() -> BreakBuilder {\n        BreakBuilder { b: TreeBuilder::new(), leaf: BreaksLeaf::default() }\n    }\n}"],"breaks::Breaks":["impl Breaks {\n    // a length with no break, useful in edit operations; for\n    // other use cases, use the builder.\n    pub fn new_no_break(len: usize) -> Breaks {\n        let leaf = BreaksLeaf { len, data: vec![] };\n        Node::from_leaf(leaf)\n    }\n}"],"breaks::BreaksBaseMetric":["Clone","Copy","impl Metric<BreaksInfo> for BreaksBaseMetric {\n    fn measure(_: &BreaksInfo, len: usize) -> usize {\n        len\n    }\n\n    fn to_base_units(_: &BreaksLeaf, in_measured_units: usize) -> usize {\n        in_measured_units\n    }\n\n    fn from_base_units(_: &BreaksLeaf, in_base_units: usize) -> usize {\n        in_base_units\n    }\n\n    fn is_boundary(l: &BreaksLeaf, offset: usize) -> bool {\n        BreaksMetric::is_boundary(l, offset)\n    }\n\n    fn prev(l: &BreaksLeaf, offset: usize) -> Option<usize> {\n        BreaksMetric::prev(l, offset)\n    }\n\n    fn next(l: &BreaksLeaf, offset: usize) -> Option<usize> {\n        BreaksMetric::next(l, offset)\n    }\n\n    fn can_fragment() -> bool {\n        true\n    }\n}"],"breaks::BreaksInfo":["Clone","Debug","impl DefaultMetric for BreaksInfo {\n    type DefaultMetric = BreaksBaseMetric;\n}","impl NodeInfo for BreaksInfo {\n    type L = BreaksLeaf;\n\n    fn accumulate(&mut self, other: &Self) {\n        self.0 += other.0;\n    }\n\n    fn compute_info(l: &BreaksLeaf) -> BreaksInfo {\n        BreaksInfo(l.data.len())\n    }\n}"],"breaks::BreaksLeaf":["Clone","Debug","Default","Eq","PartialEq","impl BreaksLeaf {\n    /// Exposed for testing.\n    #[doc(hidden)]\n    pub fn get_data_cloned(&self) -> Vec<usize> {\n        self.data.clone()\n    }\n}","impl Leaf for BreaksLeaf {\n    fn len(&self) -> usize {\n        self.len\n    }\n\n    fn is_ok_child(&self) -> bool {\n        self.data.len() >= MIN_LEAF\n    }\n\n    fn push_maybe_split(&mut self, other: &BreaksLeaf, iv: Interval) -> Option<BreaksLeaf> {\n        //eprintln!(\"push_maybe_split {:?} {:?} {}\", self, other, iv);\n        let (start, end) = iv.start_end();\n        for &v in &other.data {\n            if start < v && v <= end {\n                self.data.push(v - start + self.len);\n            }\n        }\n        // the min with other.len() shouldn't be needed\n        self.len += min(end, other.len()) - start;\n\n        if self.data.len() <= MAX_LEAF {\n            None\n        } else {\n            let splitpoint = self.data.len() / 2; // number of breaks\n            let splitpoint_units = self.data[splitpoint - 1];\n\n            let mut new = self.data.split_off(splitpoint);\n            for x in &mut new {\n                *x -= splitpoint_units;\n            }\n\n            let new_len = self.len - splitpoint_units;\n            self.len = splitpoint_units;\n            Some(BreaksLeaf { len: new_len, data: new })\n        }\n    }\n}"],"breaks::BreaksMetric":["Clone","Copy","impl Metric<BreaksInfo> for BreaksMetric {\n    fn measure(info: &BreaksInfo, _: usize) -> usize {\n        info.0\n    }\n\n    fn to_base_units(l: &BreaksLeaf, in_measured_units: usize) -> usize {\n        if in_measured_units > l.data.len() {\n            l.len + 1\n        } else if in_measured_units == 0 {\n            0\n        } else {\n            l.data[in_measured_units - 1]\n        }\n    }\n\n    fn from_base_units(l: &BreaksLeaf, in_base_units: usize) -> usize {\n        match l.data.binary_search(&in_base_units) {\n            Ok(n) => n + 1,\n            Err(n) => n,\n        }\n    }\n\n    fn is_boundary(l: &BreaksLeaf, offset: usize) -> bool {\n        l.data.binary_search(&offset).is_ok()\n    }\n\n    fn prev(l: &BreaksLeaf, offset: usize) -> Option<usize> {\n        for i in 0..l.data.len() {\n            if offset <= l.data[i] {\n                if i == 0 {\n                    return None;\n                } else {\n                    return Some(l.data[i - 1]);\n                }\n            }\n        }\n        l.data.last().cloned()\n    }\n\n    fn next(l: &BreaksLeaf, offset: usize) -> Option<usize> {\n        let n = match l.data.binary_search(&offset) {\n            Ok(n) => n + 1,\n            Err(n) => n,\n        };\n\n        if n == l.data.len() {\n            None\n        } else {\n            Some(l.data[n])\n        }\n    }\n\n    fn can_fragment() -> bool {\n        true\n    }\n}"],"compare::RopeScanner":["impl<'a> RopeScanner<'a> {\n    pub fn new(base: &'a Rope, target: &'a Rope) -> Self {\n        RopeScanner {\n            base: Cursor::new(base, 0),\n            target: Cursor::new(target, 0),\n            base_chunk: \"\",\n            target_chunk: \"\",\n            scanned: 0,\n        }\n    }\n\n    /// Starting from the two provided offsets in the corresponding ropes,\n    /// Returns the distance, moving backwards, to the first non-equal codepoint.\n    /// If no such position exists, returns the distance to the closest 0 offset.\n    ///\n    /// if `stop` is not None, the scan will stop at if it reaches this value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use xi_rope::compare::RopeScanner;\n    /// # use xi_rope::Rope;\n    ///\n    /// let one = Rope::from(\"hiii\");\n    /// let two = Rope::from(\"siii\");\n    /// let mut scanner = RopeScanner::new(&one, &two);\n    /// assert_eq!(scanner.find_ne_char_back(one.len(), two.len(), None), 3);\n    /// assert_eq!(scanner.find_ne_char_back(one.len(), two.len(), 2), 2);\n    /// ```\n    pub fn find_ne_char_back<T>(&mut self, base_off: usize, targ_off: usize, stop: T) -> usize\n    where\n        T: Into<Option<usize>>,\n    {\n        let stop = stop.into().unwrap_or(usize::max_value());\n        self.base.set(base_off);\n        self.target.set(targ_off);\n        self.scanned = 0;\n\n        let (base_leaf, base_leaf_off) = self.base.get_leaf().unwrap();\n        let (target_leaf, target_leaf_off) = self.target.get_leaf().unwrap();\n\n        debug_assert!(self.target.is_boundary::<BaseMetric>());\n        debug_assert!(self.base.is_boundary::<BaseMetric>());\n        debug_assert!(base_leaf.is_char_boundary(base_leaf_off));\n        debug_assert!(target_leaf.is_char_boundary(target_leaf_off));\n\n        self.base_chunk = &base_leaf[..base_leaf_off];\n        self.target_chunk = &target_leaf[..target_leaf_off];\n\n        loop {\n            if let Some(mut idx) =\n                ne_idx_rev(self.base_chunk.as_bytes(), self.target_chunk.as_bytes())\n            {\n                // find nearest codepoint boundary\n                while idx > 1 && !self.base_chunk.is_char_boundary(self.base_chunk.len() - idx) {\n                    idx -= 1;\n                }\n                return stop.min(self.scanned + idx);\n            }\n            let scan_len = self.target_chunk.len().min(self.base_chunk.len());\n            self.base_chunk = &self.base_chunk[..self.base_chunk.len() - scan_len];\n            self.target_chunk = &self.target_chunk[..self.target_chunk.len() - scan_len];\n            self.scanned += scan_len;\n\n            if stop <= self.scanned {\n                break;\n            }\n            self.load_prev_chunk();\n            if self.base_chunk.is_empty() || self.target_chunk.is_empty() {\n                break;\n            }\n        }\n        stop.min(self.scanned)\n    }\n\n    /// Starting from the two provided offsets into the two ropes, returns\n    /// the distance (in bytes) to the first non-equal codepoint. If no such\n    /// position exists, returns the shortest distance to the end of a rope.\n    ///\n    /// This can be thought of as the length of the longest common substring\n    /// between `base[base_off..]` and `target[targ_off..]`.\n    ///\n    /// if `stop` is not None, the scan will stop at if it reaches this value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use xi_rope::compare::RopeScanner;\n    /// # use xi_rope::Rope;\n    ///\n    /// let one = Rope::from(\"uh-oh🙈\");\n    /// let two = Rope::from(\"uh-oh🙉\");\n    /// let mut scanner = RopeScanner::new(&one, &two);\n    /// assert_eq!(scanner.find_ne_char(0, 0, None), 5);\n    /// assert_eq!(scanner.find_ne_char(0, 0, 3), 3);\n    /// ```\n    pub fn find_ne_char<T>(&mut self, base_off: usize, targ_off: usize, stop: T) -> usize\n    where\n        T: Into<Option<usize>>,\n    {\n        let stop = stop.into().unwrap_or(usize::max_value());\n        self.base.set(base_off);\n        self.target.set(targ_off);\n        self.scanned = 0;\n\n        let (base_leaf, base_leaf_off) = self.base.get_leaf().unwrap();\n        let (target_leaf, target_leaf_off) = self.target.get_leaf().unwrap();\n\n        debug_assert!(base_leaf.is_char_boundary(base_leaf_off));\n        debug_assert!(target_leaf.is_char_boundary(target_leaf_off));\n\n        self.base_chunk = &base_leaf[base_leaf_off..];\n        self.target_chunk = &target_leaf[target_leaf_off..];\n\n        loop {\n            if let Some(mut idx) = ne_idx(self.base_chunk.as_bytes(), self.target_chunk.as_bytes())\n            {\n                while idx > 0 && !self.base_chunk.is_char_boundary(idx) {\n                    idx -= 1;\n                }\n                return stop.min(self.scanned + idx);\n            }\n            let scan_len = self.target_chunk.len().min(self.base_chunk.len());\n            self.base_chunk = &self.base_chunk[scan_len..];\n            self.target_chunk = &self.target_chunk[scan_len..];\n            debug_assert!(self.base_chunk.is_empty() || self.target_chunk.is_empty());\n            self.scanned += scan_len;\n            if stop <= self.scanned {\n                break;\n            }\n            self.load_next_chunk();\n            if self.base_chunk.is_empty() || self.target_chunk.is_empty() {\n                break;\n            }\n        }\n        stop.min(self.scanned)\n    }\n\n    /// Returns the positive offset from the start of the rope to the first\n    /// non-equal byte, and the negative offset from the end of the rope to\n    /// the first non-equal byte.\n    ///\n    /// The two offsets are guaranteed not to overlap;\n    /// thus `sum(start_offset, end_offset) <= min(one.len(), two.len())`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use xi_rope::compare::RopeScanner;\n    /// # use xi_rope::Rope;\n    ///\n    /// let one = Rope::from(\"123xxx12345\");\n    /// let two = Rope::from(\"123ZZZ12345\");\n    /// let mut scanner = RopeScanner::new(&one, &two);\n    /// assert_eq!(scanner.find_min_diff_range(), (3, 5));\n    ///\n    ///\n    /// let one = Rope::from(\"friends\");\n    /// let two = Rope::from(\"fiends\");\n    /// let mut scanner = RopeScanner::new(&one, &two);\n    /// assert_eq!(scanner.find_min_diff_range(), (1, 5))\n    /// ```\n    pub fn find_min_diff_range(&mut self) -> (usize, usize) {\n        let b_end = self.base.total_len();\n        let t_end = self.target.total_len();\n        let start = self.find_ne_char(0, 0, None);\n\n        // scanning from the end of the document, we should stop at whatever\n        // offset we reached scanning from the start.\n        let unscanned = b_end.min(t_end) - start;\n\n        let end = match unscanned {\n            0 => 0,\n            n => self.find_ne_char_back(b_end, t_end, n),\n        };\n\n        (start, end)\n    }\n\n    fn load_prev_chunk(&mut self) {\n        if self.base_chunk.is_empty() {\n            if let Some(prev) = self.base.prev_leaf() {\n                self.base_chunk = prev.0;\n            }\n        }\n\n        if self.target_chunk.is_empty() {\n            if let Some(prev) = self.target.prev_leaf() {\n                self.target_chunk = prev.0;\n            }\n        }\n    }\n\n    fn load_next_chunk(&mut self) {\n        if self.base_chunk.is_empty() {\n            if let Some(next) = self.base.next_leaf() {\n                self.base_chunk = next.0;\n            }\n        }\n\n        if self.target_chunk.is_empty() {\n            if let Some(next) = self.target.next_leaf() {\n                self.target_chunk = next.0;\n            }\n        }\n    }\n}"],"delta::Builder":["impl<N: NodeInfo> Builder<N> {\n    /// Creates a new builder, applicable to a base rope of length `base_len`.\n    pub fn new(base_len: usize) -> Builder<N> {\n        Builder { delta: Delta { els: Vec::new(), base_len }, last_offset: 0 }\n    }\n\n    /// Deletes the given interval. Panics if interval is not properly sorted.\n    pub fn delete<T: IntervalBounds>(&mut self, interval: T) {\n        let interval = interval.into_interval(self.delta.base_len);\n        let (start, end) = interval.start_end();\n        assert!(start >= self.last_offset, \"Delta builder: intervals not properly sorted\");\n        if start > self.last_offset {\n            self.delta.els.push(DeltaElement::Copy(self.last_offset, start));\n        }\n        self.last_offset = end;\n    }\n\n    /// Replaces the given interval with the new rope. Panics if interval\n    /// is not properly sorted.\n    pub fn replace<T: IntervalBounds>(&mut self, interval: T, rope: Node<N>) {\n        self.delete(interval);\n        if !rope.is_empty() {\n            self.delta.els.push(DeltaElement::Insert(rope));\n        }\n    }\n\n    /// Determines if delta would be a no-op transformation if built.\n    pub fn is_empty(&self) -> bool {\n        self.last_offset == 0 && self.delta.els.is_empty()\n    }\n\n    /// Builds the `Delta`.\n    pub fn build(mut self) -> Delta<N> {\n        if self.last_offset < self.delta.base_len {\n            self.delta.els.push(DeltaElement::Copy(self.last_offset, self.delta.base_len));\n        }\n        self.delta\n    }\n}"],"delta::DeletionsIter":["impl<'a, N: NodeInfo> Iterator for DeletionsIter<'a, N> {\n    type Item = DeltaRegion;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let mut result = None;\n        while let Some(elem) = self.els_iter.next() {\n            match *elem {\n                DeltaElement::Copy(b, e) => {\n                    if b > self.last_end {\n                        result = Some(DeltaRegion::new(self.last_end, self.pos, b - self.last_end));\n                    }\n                    self.pos += e - b;\n                    self.last_end = e;\n                    if result.is_some() {\n                        break;\n                    }\n                }\n                DeltaElement::Insert(ref n) => {\n                    self.pos += n.len();\n                    self.last_end += n.len();\n                }\n            }\n        }\n        if result.is_none() && self.last_end < self.base_len {\n            result = Some(DeltaRegion::new(self.last_end, self.pos, self.base_len - self.last_end));\n            self.last_end = self.base_len;\n        }\n        result\n    }\n}"],"delta::Delta":["Clone","impl<N: NodeInfo> Delta<N> {\n    pub fn simple_edit<T: IntervalBounds>(interval: T, rope: Node<N>, base_len: usize) -> Delta<N> {\n        let mut builder = Builder::new(base_len);\n        if rope.is_empty() {\n            builder.delete(interval);\n        } else {\n            builder.replace(interval, rope);\n        }\n        builder.build()\n    }\n\n    /// If this delta represents a simple insertion, returns the inserted node.\n    pub fn as_simple_insert(&self) -> Option<&Node<N>> {\n        let mut iter = self.els.iter();\n        let mut el = iter.next();\n        let mut i = 0;\n        if let Some(&DeltaElement::Copy(beg, end)) = el {\n            if beg != 0 {\n                return None;\n            }\n            i = end;\n            el = iter.next();\n        }\n        if let Some(&DeltaElement::Insert(ref n)) = el {\n            el = iter.next();\n            if el.is_none() {\n                if i == self.base_len {\n                    return Some(n);\n                }\n            } else if let Some(&DeltaElement::Copy(beg, end)) = el {\n                if i == beg && end == self.base_len && iter.next().is_none() {\n                    return Some(n);\n                }\n            }\n        }\n        None\n    }\n\n    /// Returns `true` if this delta represents a single deletion without\n    /// any insertions.\n    ///\n    /// Note that this is `false` for the trivial delta, as well as for a deletion\n    /// from an empty `Rope`.\n    pub fn is_simple_delete(&self) -> bool {\n        if self.els.is_empty() {\n            return self.base_len > 0;\n        }\n        if let DeltaElement::Copy(beg, end) = self.els[0] {\n            if beg == 0 {\n                if self.els.len() == 1 {\n                    // Deletion at end\n                    end < self.base_len\n                } else if let DeltaElement::Copy(b1, e1) = self.els[1] {\n                    // Deletion in middle\n                    self.els.len() == 2 && end < b1 && e1 == self.base_len\n                } else {\n                    false\n                }\n            } else {\n                // Deletion at beginning\n                end == self.base_len && self.els.len() == 1\n            }\n        } else {\n            false\n        }\n    }\n\n    /// Returns `true` if applying the delta will cause no change.\n    pub fn is_identity(&self) -> bool {\n        let len = self.els.len();\n        // Case 1: Everything from beginning to end is getting copied.\n        if len == 1 {\n            if let DeltaElement::Copy(beg, end) = self.els[0] {\n                return beg == 0 && end == self.base_len;\n            }\n        }\n\n        // Case 2: The rope is empty and the entire rope is getting deleted.\n        len == 0 && self.base_len == 0\n    }\n\n    /// Apply the delta to the given rope. May not work well if the length of the rope\n    /// is not compatible with the construction of the delta.\n    pub fn apply(&self, base: &Node<N>) -> Node<N> {\n        debug_assert_eq!(base.len(), self.base_len, \"must apply Delta to Node of correct length\");\n        let mut b = TreeBuilder::new();\n        for elem in &self.els {\n            match *elem {\n                DeltaElement::Copy(beg, end) => base.push_subseq(&mut b, Interval::new(beg, end)),\n                DeltaElement::Insert(ref n) => b.push(n.clone()),\n            }\n        }\n        b.build()\n    }\n\n    /// Factor the delta into an insert-only delta and a subset representing deletions.\n    /// Applying the insert then the delete yields the same result as the original delta:\n    ///\n    /// ```no_run\n    /// # use xi_rope::rope::{Rope, RopeInfo};\n    /// # use xi_rope::delta::Delta;\n    /// # use std::str::FromStr;\n    /// fn test_factor(d : &Delta<RopeInfo>, r : &Rope) {\n    ///     let (ins, del) = d.clone().factor();\n    ///     let del2 = del.transform_expand(&ins.inserted_subset());\n    ///     assert_eq!(String::from(del2.delete_from(&ins.apply(r))), String::from(d.apply(r)));\n    /// }\n    /// ```\n    pub fn factor(self) -> (InsertDelta<N>, Subset) {\n        let mut ins = Vec::new();\n        let mut sb = SubsetBuilder::new();\n        let mut b1 = 0;\n        let mut e1 = 0;\n        for elem in self.els {\n            match elem {\n                DeltaElement::Copy(b, e) => {\n                    sb.add_range(e1, b, 1);\n                    e1 = e;\n                }\n                DeltaElement::Insert(n) => {\n                    if e1 > b1 {\n                        ins.push(DeltaElement::Copy(b1, e1));\n                    }\n                    b1 = e1;\n                    ins.push(DeltaElement::Insert(n));\n                }\n            }\n        }\n        if b1 < self.base_len {\n            ins.push(DeltaElement::Copy(b1, self.base_len));\n        }\n        sb.add_range(e1, self.base_len, 1);\n        sb.pad_to_len(self.base_len);\n        (InsertDelta(Delta { els: ins, base_len: self.base_len }), sb.build())\n    }\n\n    /// Synthesize a delta from a \"union string\" and two subsets: an old set\n    /// of deletions and a new set of deletions from the union. The Delta is\n    /// from text to text, not union to union; anything in both subsets will\n    /// be assumed to be missing from the Delta base and the new text. You can\n    /// also think of these as a set of insertions and one of deletions, with\n    /// overlap doing nothing. This is basically the inverse of `factor`.\n    ///\n    /// Since only the deleted portions of the union string are necessary,\n    /// instead of requiring a union string the function takes a `tombstones`\n    /// rope which contains the deleted portions of the union string. The\n    /// `from_dels` subset must be the interleaving of `tombstones` into the\n    /// union string.\n    ///\n    /// ```no_run\n    /// # use xi_rope::rope::{Rope, RopeInfo};\n    /// # use xi_rope::delta::Delta;\n    /// # use std::str::FromStr;\n    /// fn test_synthesize(d : &Delta<RopeInfo>, r : &Rope) {\n    ///     let (ins_d, del) = d.clone().factor();\n    ///     let ins = ins_d.inserted_subset();\n    ///     let del2 = del.transform_expand(&ins);\n    ///     let r2 = ins_d.apply(&r);\n    ///     let tombstones = ins.complement().delete_from(&r2);\n    ///     let d2 = Delta::synthesize(&tombstones, &ins, &del);\n    ///     assert_eq!(String::from(d2.apply(r)), String::from(d.apply(r)));\n    /// }\n    /// ```\n    // For if last_old.is_some() && last_old.unwrap().0 <= beg {. Clippy complaints\n    // about not using if-let, but that'd change the meaning of the conditional.\n    #[allow(clippy::unnecessary_unwrap)]\n    pub fn synthesize(tombstones: &Node<N>, from_dels: &Subset, to_dels: &Subset) -> Delta<N> {\n        let base_len = from_dels.len_after_delete();\n        let mut els = Vec::new();\n        let mut x = 0;\n        let mut old_ranges = from_dels.complement_iter();\n        let mut last_old = old_ranges.next();\n        let mut m = from_dels.mapper(CountMatcher::NonZero);\n        // For each segment of the new text\n        for (b, e) in to_dels.complement_iter() {\n            // Fill the whole segment\n            let mut beg = b;\n            while beg < e {\n                // Skip over ranges in old text until one overlaps where we want to fill\n                while let Some((ib, ie)) = last_old {\n                    if ie > beg {\n                        break;\n                    }\n                    x += ie - ib;\n                    last_old = old_ranges.next();\n                }\n                // If we have a range in the old text with the character at beg, then we Copy\n                if last_old.is_some() && last_old.unwrap().0 <= beg {\n                    let (ib, ie) = last_old.unwrap();\n                    let end = min(e, ie);\n                    // Try to merge contiguous Copys in the output\n                    let xbeg = beg + x - ib; // \"beg - ib + x\" better for overflow?\n                    let xend = end + x - ib; // ditto\n                    let merged =\n                        if let Some(&mut DeltaElement::Copy(_, ref mut le)) = els.last_mut() {\n                            if *le == xbeg {\n                                *le = xend;\n                                true\n                            } else {\n                                false\n                            }\n                        } else {\n                            false\n                        };\n                    if !merged {\n                        els.push(DeltaElement::Copy(xbeg, xend));\n                    }\n                    beg = end;\n                } else {\n                    // if the character at beg isn't in the old text, then we Insert\n                    // Insert up until the next old range we could Copy from, or the end of this segment\n                    let mut end = e;\n                    if let Some((ib, _)) = last_old {\n                        end = min(end, ib)\n                    }\n                    // Note: could try to aggregate insertions, but not sure of the win.\n                    // Use the mapper to insert the corresponding section of the tombstones rope\n                    let interval =\n                        Interval::new(m.doc_index_to_subset(beg), m.doc_index_to_subset(end));\n                    els.push(DeltaElement::Insert(tombstones.subseq(interval)));\n                    beg = end;\n                }\n            }\n        }\n        Delta { els, base_len }\n    }\n\n    /// Produce a summary of the delta. Everything outside the returned interval\n    /// is unchanged, and the old contents of the interval are replaced by new\n    /// contents of the returned length. Equations:\n    ///\n    /// `(iv, new_len) = self.summary()`\n    ///\n    /// `new_s = self.apply(s)`\n    ///\n    /// `new_s = simple_edit(iv, new_s.subseq(iv.start(), iv.start() + new_len), s.len()).apply(s)`\n    pub fn summary(&self) -> (Interval, usize) {\n        let mut els = self.els.as_slice();\n        let mut iv_start = 0;\n        if let Some((&DeltaElement::Copy(0, end), rest)) = els.split_first() {\n            iv_start = end;\n            els = rest;\n        }\n        let mut iv_end = self.base_len;\n        if let Some((&DeltaElement::Copy(beg, end), init)) = els.split_last() {\n            if end == iv_end {\n                iv_end = beg;\n                els = init;\n            }\n        }\n        (Interval::new(iv_start, iv_end), Delta::total_element_len(els))\n    }\n\n    /// Returns the length of the new document. In other words, the length of\n    /// the transformed string after this Delta is applied.\n    ///\n    /// `d.apply(r).len() == d.new_document_len()`\n    pub fn new_document_len(&self) -> usize {\n        Delta::total_element_len(self.els.as_slice())\n    }\n\n    fn total_element_len(els: &[DeltaElement<N>]) -> usize {\n        els.iter().fold(0, |sum, el| {\n            sum + match *el {\n                DeltaElement::Copy(beg, end) => end - beg,\n                DeltaElement::Insert(ref n) => n.len(),\n            }\n        })\n    }\n\n    /// Returns the sum length of the inserts of the delta.\n    pub fn inserts_len(&self) -> usize {\n        self.els.iter().fold(0, |sum, el| {\n            sum + match *el {\n                DeltaElement::Copy(_, _) => 0,\n                DeltaElement::Insert(ref s) => s.len(),\n            }\n        })\n    }\n\n    /// Iterates over all the inserts of the delta.\n    pub fn iter_inserts(&self) -> InsertsIter<N> {\n        InsertsIter { pos: 0, last_end: 0, els_iter: self.els.iter() }\n    }\n\n    /// Iterates over all the deletions of the delta.\n    pub fn iter_deletions(&self) -> DeletionsIter<N> {\n        DeletionsIter { pos: 0, last_end: 0, base_len: self.base_len, els_iter: self.els.iter() }\n    }\n}","impl<N: NodeInfo> fmt::Debug for Delta<N>\nwhere\n    Node<N>: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if f.alternate() {\n            for el in &self.els {\n                match *el {\n                    DeltaElement::Copy(beg, end) => {\n                        write!(f, \"{}\", \"-\".repeat(end - beg))?;\n                    }\n                    DeltaElement::Insert(ref node) => {\n                        node.fmt(f)?;\n                    }\n                }\n            }\n        } else {\n            write!(f, \"Delta(\")?;\n            for el in &self.els {\n                match *el {\n                    DeltaElement::Copy(beg, end) => {\n                        write!(f, \"[{},{}) \", beg, end)?;\n                    }\n                    DeltaElement::Insert(ref node) => {\n                        write!(f, \"<ins:{}> \", node.len())?;\n                    }\n                }\n            }\n            write!(f, \"base_len: {})\", self.base_len)?;\n        }\n        Ok(())\n    }\n}"],"delta::DeltaElement":["Clone"],"delta::DeltaRegion":["Debug","PartialEq","impl DeltaRegion {\n    fn new(old_offset: usize, new_offset: usize, len: usize) -> Self {\n        DeltaRegion { old_offset, new_offset, len }\n    }\n}"],"delta::InsertDelta":["Clone","impl<N: NodeInfo> Deref for InsertDelta<N> {\n    type Target = Delta<N>;\n\n    fn deref(&self) -> &Delta<N> {\n        &self.0\n    }\n}","impl<N: NodeInfo> InsertDelta<N> {\n    #![allow(clippy::many_single_char_names)]\n    /// Do a coordinate transformation on an insert-only delta. The `after` parameter\n    /// controls whether the insertions in `self` come after those specific in the\n    /// coordinate transform.\n    //\n    // TODO: write accurate equations\n    pub fn transform_expand(&self, xform: &Subset, after: bool) -> InsertDelta<N> {\n        let cur_els = &self.0.els;\n        let mut els = Vec::new();\n        let mut x = 0; // coordinate within self\n        let mut y = 0; // coordinate within xform\n        let mut i = 0; // index into self.els\n        let mut b1 = 0;\n        let mut xform_ranges = xform.complement_iter();\n        let mut last_xform = xform_ranges.next();\n        let l = xform.count(CountMatcher::All);\n        while y < l || i < cur_els.len() {\n            let next_iv_beg = if let Some((xb, _)) = last_xform { xb } else { l };\n            if after && y < next_iv_beg {\n                y = next_iv_beg;\n            }\n            while i < cur_els.len() {\n                match cur_els[i] {\n                    DeltaElement::Insert(ref n) => {\n                        if y > b1 {\n                            els.push(DeltaElement::Copy(b1, y));\n                        }\n                        b1 = y;\n                        els.push(DeltaElement::Insert(n.clone()));\n                        i += 1;\n                    }\n                    DeltaElement::Copy(_b, e) => {\n                        if y >= next_iv_beg {\n                            let mut next_y = e + y - x;\n                            if let Some((_, xe)) = last_xform {\n                                next_y = min(next_y, xe);\n                            }\n                            x += next_y - y;\n                            y = next_y;\n                            if x == e {\n                                i += 1;\n                            }\n                            if let Some((_, xe)) = last_xform {\n                                if y == xe {\n                                    last_xform = xform_ranges.next();\n                                }\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n            if !after && y < next_iv_beg {\n                y = next_iv_beg;\n            }\n        }\n        if y > b1 {\n            els.push(DeltaElement::Copy(b1, y));\n        }\n        InsertDelta(Delta { els, base_len: l })\n    }\n\n    // TODO: it is plausible this method also works on Deltas with deletes\n    /// Shrink a delta through a deletion of some of its copied regions with\n    /// the same base. For example, if `self` applies to a union string, and\n    /// `xform` is the deletions from that union, the resulting Delta will\n    /// apply to the text.\n    pub fn transform_shrink(&self, xform: &Subset) -> InsertDelta<N> {\n        let mut m = xform.mapper(CountMatcher::Zero);\n        let els = self\n            .0\n            .els\n            .iter()\n            .map(|elem| match *elem {\n                DeltaElement::Copy(b, e) => {\n                    DeltaElement::Copy(m.doc_index_to_subset(b), m.doc_index_to_subset(e))\n                }\n                DeltaElement::Insert(ref n) => DeltaElement::Insert(n.clone()),\n            })\n            .collect();\n        InsertDelta(Delta { els, base_len: xform.len_after_delete() })\n    }\n\n    /// Return a Subset containing the inserted ranges.\n    ///\n    /// `d.inserted_subset().delete_from_string(d.apply_to_string(s)) == s`\n    pub fn inserted_subset(&self) -> Subset {\n        let mut sb = SubsetBuilder::new();\n        for elem in &self.0.els {\n            match *elem {\n                DeltaElement::Copy(b, e) => {\n                    sb.push_segment(e - b, 0);\n                }\n                DeltaElement::Insert(ref n) => {\n                    sb.push_segment(n.len(), 1);\n                }\n            }\n        }\n        sb.build()\n    }\n}","impl<N: NodeInfo> fmt::Debug for InsertDelta<N>\nwhere\n    Node<N>: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"],"delta::InsertsIter":["impl<'a, N: NodeInfo> Iterator for InsertsIter<'a, N> {\n    type Item = DeltaRegion;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let mut result = None;\n        while let Some(elem) = self.els_iter.next() {\n            match *elem {\n                DeltaElement::Copy(b, e) => {\n                    self.pos += e - b;\n                    self.last_end = e;\n                }\n                DeltaElement::Insert(ref n) => {\n                    result = Some(DeltaRegion::new(self.last_end, self.pos, n.len()));\n                    self.pos += n.len();\n                    self.last_end += n.len();\n                    break;\n                }\n            }\n        }\n        result\n    }\n}"],"delta::Transformer":["impl<'a, N: NodeInfo + 'a> Transformer<'a, N> {\n    /// Create a new transformer from a delta.\n    pub fn new(delta: &'a Delta<N>) -> Self {\n        Transformer { delta }\n    }\n\n    /// Transform a single coordinate. The `after` parameter indicates whether it\n    /// it should land before or after an inserted region.\n\n    // TODO: implement a cursor so we're not scanning from the beginning every time.\n    pub fn transform(&mut self, ix: usize, after: bool) -> usize {\n        if ix == 0 && !after {\n            return 0;\n        }\n        let mut result = 0;\n        for el in &self.delta.els {\n            match *el {\n                DeltaElement::Copy(beg, end) => {\n                    if ix <= beg {\n                        return result;\n                    }\n                    if ix < end || (ix == end && !after) {\n                        return result + ix - beg;\n                    }\n                    result += end - beg;\n                }\n                DeltaElement::Insert(ref n) => {\n                    result += n.len();\n                }\n            }\n        }\n        result\n    }\n\n    /// Determine whether a given interval is untouched by the transformation.\n    pub fn interval_untouched<T: IntervalBounds>(&mut self, iv: T) -> bool {\n        let iv = iv.into_interval(self.delta.base_len);\n        let mut last_was_ins = true;\n        for el in &self.delta.els {\n            match *el {\n                DeltaElement::Copy(beg, end) => {\n                    if iv.is_before(end) {\n                        if last_was_ins {\n                            if iv.is_after(beg) {\n                                return true;\n                            }\n                        } else {\n                            if !iv.is_before(beg) {\n                                return true;\n                            }\n                        }\n                    } else {\n                        return false;\n                    }\n                    last_was_ins = false;\n                }\n                _ => {\n                    last_was_ins = true;\n                }\n            }\n        }\n        false\n    }\n}"],"diff::DiffBuilder":["Clone","Debug","Default","impl DiffBuilder {\n    fn copy(&mut self, base: usize, target: usize, len: usize) {\n        if let Some(prev) = self.ops.last_mut() {\n            let prev_end = prev.target_idx + prev.len;\n            let base_end = prev.base_idx + prev.len;\n            assert!(prev_end <= target, \"{} <= {} prev {:?}\", prev_end, target, prev);\n            if prev_end == target && base_end == base {\n                prev.len += len;\n                return;\n            }\n        }\n        self.ops.push(DiffOp { target_idx: target, base_idx: base, len })\n    }\n\n    fn to_delta(self, base: &Rope, target: &Rope) -> RopeDelta {\n        let mut els = Vec::with_capacity(self.ops.len() * 2);\n        let mut targ_pos = 0;\n        for DiffOp { base_idx, target_idx, len } in self.ops {\n            if target_idx > targ_pos {\n                let iv = Interval::new(targ_pos, target_idx);\n                els.push(DeltaElement::Insert(target.subseq(iv)));\n            }\n            els.push(DeltaElement::Copy(base_idx, base_idx + len));\n            targ_pos = target_idx + len;\n        }\n\n        if targ_pos < target.len() {\n            let iv = Interval::new(targ_pos, target.len());\n            els.push(DeltaElement::Insert(target.subseq(iv)));\n        }\n\n        Delta { els, base_len: base.len() }\n    }\n}"],"diff::DiffOp":["Clone","Copy","Debug"],"diff::LineHashDiff":["impl Diff<RopeInfo> for LineHashDiff {\n    fn compute_delta(base: &Rope, target: &Rope) -> RopeDelta {\n        let mut builder = DiffBuilder::default();\n\n        // before doing anything, scan top down and bottom up for like-ness.\n        let mut scanner = RopeScanner::new(base, target);\n        let (start_offset, diff_end) = scanner.find_min_diff_range();\n        let target_end = target.len() - diff_end;\n\n        if start_offset > 0 {\n            builder.copy(0, 0, start_offset);\n        }\n\n        // if our preliminary scan finds no differences we're done\n        if start_offset == base.len() && target.len() == base.len() {\n            return builder.to_delta(base, target);\n        }\n\n        // if a continuous range of text got deleted, we're done\n        if target.len() < base.len() && start_offset + diff_end == target.len() {\n            builder.copy(base.len() - diff_end, target_end, diff_end);\n            return builder.to_delta(base, target);\n        }\n\n        // if a continuous range of text got inserted, we're done\n        if target.len() > base.len() && start_offset + diff_end == base.len() {\n            builder.copy(base.len() - diff_end, target_end, diff_end);\n            return builder.to_delta(base, target);\n        }\n\n        let line_hashes = make_line_hashes(&base, MIN_SIZE);\n\n        let line_count = target.measure::<LinesMetric>() + 1;\n        let mut matches = Vec::with_capacity(line_count);\n\n        let mut targ_line_offset = 0;\n        let mut prev_base = 0;\n\n        let mut needs_subseq = false;\n        for line in target.lines_raw(start_offset..target_end) {\n            let non_ws = non_ws_offset(&line);\n            if line.len() - non_ws >= MIN_SIZE {\n                if let Some(base_off) = line_hashes.get(&line[non_ws..]) {\n                    let targ_off = targ_line_offset + non_ws;\n                    matches.push((start_offset + targ_off, *base_off));\n                    if *base_off < prev_base {\n                        needs_subseq = true;\n                    }\n                    prev_base = *base_off;\n                }\n            }\n            targ_line_offset += line.len();\n        }\n\n        // we now have an ordered list of matches and their positions.\n        // to ensure that our delta only copies non-decreasing base regions,\n        // we take the longest increasing subsequence.\n        // TODO: a possible optimization here would be to expand matches\n        // to adjacent lines first? this would be at best a small win though..\n\n        let longest_subseq =\n            if needs_subseq { longest_increasing_region_set(&matches) } else { matches };\n\n        // for each matching region, we extend it forwards and backwards.\n        // we keep track of how far forward we extend it each time, to avoid\n        // having a subsequent scan extend backwards over the same region.\n        let mut prev_end = start_offset;\n\n        for (targ_off, base_off) in longest_subseq {\n            if targ_off <= prev_end {\n                continue;\n            }\n            let (left_dist, mut right_dist) =\n                expand_match(base, target, base_off, targ_off, prev_end);\n\n            // don't let last match expand past target_end\n            right_dist = right_dist.min(target_end - targ_off);\n\n            let targ_start = targ_off - left_dist;\n            let base_start = base_off - left_dist;\n            let len = left_dist + right_dist;\n            prev_end = targ_start + len;\n\n            builder.copy(base_start, targ_start, len);\n        }\n\n        if diff_end > 0 {\n            builder.copy(base.len() - diff_end, target.len() - diff_end, diff_end);\n        }\n\n        builder.to_delta(base, target)\n    }\n}"],"engine::Contents":["Clone","Debug"],"engine::DeltaOp":["Clone","Debug"],"engine::Engine":["Debug","impl Engine {\n    /// Create a new Engine with a single edit that inserts `initial_contents`\n    /// if it is non-empty. It needs to be a separate commit rather than just\n    /// part of the initial contents since any two `Engine`s need a common\n    /// ancestor in order to be mergeable.\n    pub fn new(initial_contents: Rope) -> Engine {\n        let mut engine = Engine::empty();\n        if !initial_contents.is_empty() {\n            let first_rev = engine.get_head_rev_id().token();\n            let delta = Delta::simple_edit(Interval::new(0, 0), initial_contents, 0);\n            engine.edit_rev(0, 0, first_rev, delta);\n        }\n        engine\n    }\n\n    pub fn empty() -> Engine {\n        let deletes_from_union = Subset::new(0);\n        let rev = Revision {\n            rev_id: RevId { session1: 0, session2: 0, num: 0 },\n            edit: Undo {\n                toggled_groups: BTreeSet::new(),\n                deletes_bitxor: deletes_from_union.clone(),\n            },\n            max_undo_so_far: 0,\n        };\n        Engine {\n            session: default_session(),\n            rev_id_counter: 1,\n            text: Rope::default(),\n            tombstones: Rope::default(),\n            deletes_from_union,\n            undone_groups: BTreeSet::new(),\n            revs: vec![rev],\n        }\n    }\n\n    fn next_rev_id(&self) -> RevId {\n        RevId { session1: self.session.0, session2: self.session.1, num: self.rev_id_counter }\n    }\n\n    fn find_rev(&self, rev_id: RevId) -> Option<usize> {\n        self.revs\n            .iter()\n            .enumerate()\n            .rev()\n            .find(|&(_, ref rev)| rev.rev_id == rev_id)\n            .map(|(i, _)| i)\n    }\n\n    fn find_rev_token(&self, rev_token: RevToken) -> Option<usize> {\n        self.revs\n            .iter()\n            .enumerate()\n            .rev()\n            .find(|&(_, ref rev)| rev.rev_id.token() == rev_token)\n            .map(|(i, _)| i)\n    }\n\n    // TODO: does Cow really help much here? It certainly won't after making Subsets a rope.\n    /// Find what the `deletes_from_union` field in Engine would have been at the time\n    /// of a certain `rev_index`. In other words, the deletes from the union string at that time.\n    fn deletes_from_union_for_index(&self, rev_index: usize) -> Cow<Subset> {\n        self.deletes_from_union_before_index(rev_index + 1, true)\n    }\n\n    /// Garbage collection means undo can sometimes need to replay the very first\n    /// revision, and so needs a way to get the deletion set before then.\n    fn deletes_from_union_before_index(&self, rev_index: usize, invert_undos: bool) -> Cow<Subset> {\n        let mut deletes_from_union = Cow::Borrowed(&self.deletes_from_union);\n        let mut undone_groups = Cow::Borrowed(&self.undone_groups);\n\n        // invert the changes to deletes_from_union starting in the present and working backwards\n        for rev in self.revs[rev_index..].iter().rev() {\n            deletes_from_union = match rev.edit {\n                Edit { ref inserts, ref deletes, ref undo_group, .. } => {\n                    if undone_groups.contains(undo_group) {\n                        // no need to un-delete undone inserts since we'll just shrink them out\n                        Cow::Owned(deletes_from_union.transform_shrink(inserts))\n                    } else {\n                        let un_deleted = deletes_from_union.subtract(deletes);\n                        Cow::Owned(un_deleted.transform_shrink(inserts))\n                    }\n                }\n                Undo { ref toggled_groups, ref deletes_bitxor } => {\n                    if invert_undos {\n                        let new_undone =\n                            undone_groups.symmetric_difference(toggled_groups).cloned().collect();\n                        undone_groups = Cow::Owned(new_undone);\n                        Cow::Owned(deletes_from_union.bitxor(deletes_bitxor))\n                    } else {\n                        deletes_from_union\n                    }\n                }\n            }\n        }\n        deletes_from_union\n    }\n\n    /// Get the contents of the document at a given revision number\n    fn rev_content_for_index(&self, rev_index: usize) -> Rope {\n        let old_deletes_from_union = self.deletes_from_cur_union_for_index(rev_index);\n        let delta =\n            Delta::synthesize(&self.tombstones, &self.deletes_from_union, &old_deletes_from_union);\n        delta.apply(&self.text)\n    }\n\n    /// Get the Subset to delete from the current union string in order to obtain a revision's content\n    fn deletes_from_cur_union_for_index(&self, rev_index: usize) -> Cow<Subset> {\n        let mut deletes_from_union = self.deletes_from_union_for_index(rev_index);\n        for rev in &self.revs[rev_index + 1..] {\n            if let Edit { ref inserts, .. } = rev.edit {\n                if !inserts.is_empty() {\n                    deletes_from_union = Cow::Owned(deletes_from_union.transform_union(inserts));\n                }\n            }\n        }\n        deletes_from_union\n    }\n\n    /// Returns the largest undo group ID used so far\n    pub fn max_undo_group_id(&self) -> usize {\n        self.revs.last().unwrap().max_undo_so_far\n    }\n\n    /// Get revision id of head revision.\n    pub fn get_head_rev_id(&self) -> RevId {\n        self.revs.last().unwrap().rev_id\n    }\n\n    /// Get text of head revision.\n    pub fn get_head(&self) -> &Rope {\n        &self.text\n    }\n\n    /// Get text of a given revision, if it can be found.\n    pub fn get_rev(&self, rev: RevToken) -> Option<Rope> {\n        self.find_rev_token(rev).map(|rev_index| self.rev_content_for_index(rev_index))\n    }\n\n    /// A delta that, when applied to `base_rev`, results in the current head. Returns\n    /// an error if there is not at least one edit.\n    pub fn try_delta_rev_head(&self, base_rev: RevToken) -> Result<Delta<RopeInfo>, Error> {\n        let ix = self.find_rev_token(base_rev).ok_or(Error::MissingRevision(base_rev))?;\n        let prev_from_union = self.deletes_from_cur_union_for_index(ix);\n        // TODO: this does 2 calls to Delta::synthesize and 1 to apply, this probably could be better.\n        let old_tombstones = shuffle_tombstones(\n            &self.text,\n            &self.tombstones,\n            &self.deletes_from_union,\n            &prev_from_union,\n        );\n        Ok(Delta::synthesize(&old_tombstones, &prev_from_union, &self.deletes_from_union))\n    }\n\n    // TODO: don't construct transform if subsets are empty\n    // TODO: maybe switch to using a revision index for `base_rev` once we disable GC\n    /// Returns a tuple of a new `Revision` representing the edit based on the\n    /// current head, a new text `Rope`, a new tombstones `Rope` and a new `deletes_from_union`.\n    /// Returns an [`Error`] if `base_rev` cannot be found, or `delta.base_len`\n    /// does not equal the length of the text at `base_rev`.\n    fn mk_new_rev(\n        &self,\n        new_priority: usize,\n        undo_group: usize,\n        base_rev: RevToken,\n        delta: Delta<RopeInfo>,\n    ) -> Result<(Revision, Rope, Rope, Subset), Error> {\n        let ix = self.find_rev_token(base_rev).ok_or(Error::MissingRevision(base_rev))?;\n\n        let (ins_delta, deletes) = delta.factor();\n\n        // rebase delta to be on the base_rev union instead of the text\n        let deletes_at_rev = self.deletes_from_union_for_index(ix);\n\n        // validate delta\n        if ins_delta.base_len != deletes_at_rev.len_after_delete() {\n            return Err(Error::MalformedDelta {\n                delta_len: ins_delta.base_len,\n                rev_len: deletes_at_rev.len_after_delete(),\n            });\n        }\n\n        let mut union_ins_delta = ins_delta.transform_expand(&deletes_at_rev, true);\n        let mut new_deletes = deletes.transform_expand(&deletes_at_rev);\n\n        // rebase the delta to be on the head union instead of the base_rev union\n        let new_full_priority = FullPriority { priority: new_priority, session_id: self.session };\n        for r in &self.revs[ix + 1..] {\n            if let Edit { priority, ref inserts, .. } = r.edit {\n                if !inserts.is_empty() {\n                    let full_priority =\n                        FullPriority { priority, session_id: r.rev_id.session_id() };\n                    let after = new_full_priority >= full_priority; // should never be ==\n                    union_ins_delta = union_ins_delta.transform_expand(inserts, after);\n                    new_deletes = new_deletes.transform_expand(inserts);\n                }\n            }\n        }\n\n        // rebase the deletion to be after the inserts instead of directly on the head union\n        let new_inserts = union_ins_delta.inserted_subset();\n        if !new_inserts.is_empty() {\n            new_deletes = new_deletes.transform_expand(&new_inserts);\n        }\n\n        // rebase insertions on text and apply\n        let cur_deletes_from_union = &self.deletes_from_union;\n        let text_ins_delta = union_ins_delta.transform_shrink(cur_deletes_from_union);\n        let text_with_inserts = text_ins_delta.apply(&self.text);\n        let rebased_deletes_from_union = cur_deletes_from_union.transform_expand(&new_inserts);\n\n        // is the new edit in an undo group that was already undone due to concurrency?\n        let undone = self.undone_groups.contains(&undo_group);\n        let new_deletes_from_union = {\n            let to_delete = if undone { &new_inserts } else { &new_deletes };\n            rebased_deletes_from_union.union(to_delete)\n        };\n\n        // move deleted or undone-inserted things from text to tombstones\n        let (new_text, new_tombstones) = shuffle(\n            &text_with_inserts,\n            &self.tombstones,\n            &rebased_deletes_from_union,\n            &new_deletes_from_union,\n        );\n\n        let head_rev = &self.revs.last().unwrap();\n        Ok((\n            Revision {\n                rev_id: self.next_rev_id(),\n                max_undo_so_far: std::cmp::max(undo_group, head_rev.max_undo_so_far),\n                edit: Edit {\n                    priority: new_priority,\n                    undo_group,\n                    inserts: new_inserts,\n                    deletes: new_deletes,\n                },\n            },\n            new_text,\n            new_tombstones,\n            new_deletes_from_union,\n        ))\n    }\n    // NOTE: maybe just deprecate this? we can panic on the other side of\n    // the call if/when that makes sense.\n    /// Create a new edit based on `base_rev`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `base_rev` does not exist, or if `delta` is poorly formed.\n    pub fn edit_rev(\n        &mut self,\n        priority: usize,\n        undo_group: usize,\n        base_rev: RevToken,\n        delta: Delta<RopeInfo>,\n    ) {\n        self.try_edit_rev(priority, undo_group, base_rev, delta).unwrap();\n    }\n\n    // TODO: have `base_rev` be an index so that it can be used maximally\n    // efficiently with the head revision, a token or a revision ID.\n    // Efficiency loss of token is negligible but unfortunate.\n    /// Attempts to apply a new edit based on the [`Revision`] specified by `base_rev`,\n    /// Returning an [`Error`] if the `Revision` cannot be found.\n    pub fn try_edit_rev(\n        &mut self,\n        priority: usize,\n        undo_group: usize,\n        base_rev: RevToken,\n        delta: Delta<RopeInfo>,\n    ) -> Result<(), Error> {\n        let (new_rev, new_text, new_tombstones, new_deletes_from_union) =\n            self.mk_new_rev(priority, undo_group, base_rev, delta)?;\n        self.rev_id_counter += 1;\n        self.revs.push(new_rev);\n        self.text = new_text;\n        self.tombstones = new_tombstones;\n        self.deletes_from_union = new_deletes_from_union;\n        Ok(())\n    }\n\n    // since undo and gc replay history with transforms, we need an empty set\n    // of the union string length *before* the first revision.\n    fn empty_subset_before_first_rev(&self) -> Subset {\n        let first_rev = &self.revs.first().unwrap();\n        // it will be immediately transform_expanded by inserts if it is an Edit, so length must be before\n        let len = match first_rev.edit {\n            Edit { ref inserts, .. } => inserts.count(CountMatcher::Zero),\n            Undo { ref deletes_bitxor, .. } => deletes_bitxor.count(CountMatcher::All),\n        };\n        Subset::new(len)\n    }\n\n    /// Find the first revision that could be affected by toggling a set of undo groups\n    fn find_first_undo_candidate_index(&self, toggled_groups: &BTreeSet<usize>) -> usize {\n        // find the lowest toggled undo group number\n        if let Some(lowest_group) = toggled_groups.iter().cloned().next() {\n            for (i, rev) in self.revs.iter().enumerate().rev() {\n                if rev.max_undo_so_far < lowest_group {\n                    return i + 1; // +1 since we know the one we just found doesn't have it\n                }\n            }\n            0\n        } else {\n            // no toggled groups, return past end\n            self.revs.len()\n        }\n    }\n\n    // This computes undo all the way from the beginning. An optimization would be to not\n    // recompute the prefix up to where the history diverges, but it's not clear that's\n    // even worth the code complexity.\n    fn compute_undo(&self, groups: &BTreeSet<usize>) -> (Revision, Subset) {\n        let toggled_groups = self.undone_groups.symmetric_difference(&groups).cloned().collect();\n        let first_candidate = self.find_first_undo_candidate_index(&toggled_groups);\n        // the `false` below: don't invert undos since our first_candidate is based on the current undo set, not past\n        let mut deletes_from_union =\n            self.deletes_from_union_before_index(first_candidate, false).into_owned();\n\n        for rev in &self.revs[first_candidate..] {\n            if let Edit { ref undo_group, ref inserts, ref deletes, .. } = rev.edit {\n                if groups.contains(undo_group) {\n                    if !inserts.is_empty() {\n                        deletes_from_union = deletes_from_union.transform_union(inserts);\n                    }\n                } else {\n                    if !inserts.is_empty() {\n                        deletes_from_union = deletes_from_union.transform_expand(inserts);\n                    }\n                    if !deletes.is_empty() {\n                        deletes_from_union = deletes_from_union.union(deletes);\n                    }\n                }\n            }\n        }\n\n        let deletes_bitxor = self.deletes_from_union.bitxor(&deletes_from_union);\n        let max_undo_so_far = self.revs.last().unwrap().max_undo_so_far;\n        (\n            Revision {\n                rev_id: self.next_rev_id(),\n                max_undo_so_far,\n                edit: Undo { toggled_groups, deletes_bitxor },\n            },\n            deletes_from_union,\n        )\n    }\n\n    // TODO: maybe refactor this API to take a toggle set\n    pub fn undo(&mut self, groups: BTreeSet<usize>) {\n        let (new_rev, new_deletes_from_union) = self.compute_undo(&groups);\n\n        let (new_text, new_tombstones) = shuffle(\n            &self.text,\n            &self.tombstones,\n            &self.deletes_from_union,\n            &new_deletes_from_union,\n        );\n\n        self.text = new_text;\n        self.tombstones = new_tombstones;\n        self.deletes_from_union = new_deletes_from_union;\n        self.undone_groups = groups;\n        self.revs.push(new_rev);\n        self.rev_id_counter += 1;\n    }\n\n    pub fn is_equivalent_revision(&self, base_rev: RevId, other_rev: RevId) -> bool {\n        let base_subset = self\n            .find_rev(base_rev)\n            .map(|rev_index| self.deletes_from_cur_union_for_index(rev_index));\n        let other_subset = self\n            .find_rev(other_rev)\n            .map(|rev_index| self.deletes_from_cur_union_for_index(rev_index));\n\n        base_subset.is_some() && base_subset == other_subset\n    }\n\n    // Note: this function would need some work to handle retaining arbitrary revisions,\n    // partly because the reachability calculation would become more complicated (a\n    // revision might hold content from an undo group that would otherwise be gc'ed),\n    // and partly because you need to retain more undo history, to supply input to the\n    // reachability calculation.\n    //\n    // Thus, it's easiest to defer gc to when all plugins quiesce, but it's certainly\n    // possible to fix it so that's not necessary.\n    pub fn gc(&mut self, gc_groups: &BTreeSet<usize>) {\n        let mut gc_dels = self.empty_subset_before_first_rev();\n        // TODO: want to let caller retain more rev_id's.\n        let mut retain_revs = BTreeSet::new();\n        if let Some(last) = self.revs.last() {\n            retain_revs.insert(last.rev_id);\n        }\n        {\n            for rev in &self.revs {\n                if let Edit { ref undo_group, ref inserts, ref deletes, .. } = rev.edit {\n                    if !retain_revs.contains(&rev.rev_id) && gc_groups.contains(undo_group) {\n                        if self.undone_groups.contains(undo_group) {\n                            if !inserts.is_empty() {\n                                gc_dels = gc_dels.transform_union(inserts);\n                            }\n                        } else {\n                            if !inserts.is_empty() {\n                                gc_dels = gc_dels.transform_expand(inserts);\n                            }\n                            if !deletes.is_empty() {\n                                gc_dels = gc_dels.union(deletes);\n                            }\n                        }\n                    } else if !inserts.is_empty() {\n                        gc_dels = gc_dels.transform_expand(inserts);\n                    }\n                }\n            }\n        }\n        if !gc_dels.is_empty() {\n            let not_in_tombstones = self.deletes_from_union.complement();\n            let dels_from_tombstones = gc_dels.transform_shrink(&not_in_tombstones);\n            self.tombstones = dels_from_tombstones.delete_from(&self.tombstones);\n            self.deletes_from_union = self.deletes_from_union.transform_shrink(&gc_dels);\n        }\n        let old_revs = std::mem::replace(&mut self.revs, Vec::new());\n        for rev in old_revs.into_iter().rev() {\n            match rev.edit {\n                Edit { priority, undo_group, inserts, deletes } => {\n                    let new_gc_dels = if inserts.is_empty() {\n                        None\n                    } else {\n                        Some(gc_dels.transform_shrink(&inserts))\n                    };\n                    if retain_revs.contains(&rev.rev_id) || !gc_groups.contains(&undo_group) {\n                        let (inserts, deletes) = if gc_dels.is_empty() {\n                            (inserts, deletes)\n                        } else {\n                            (inserts.transform_shrink(&gc_dels), deletes.transform_shrink(&gc_dels))\n                        };\n                        self.revs.push(Revision {\n                            rev_id: rev.rev_id,\n                            max_undo_so_far: rev.max_undo_so_far,\n                            edit: Edit { priority, undo_group, inserts, deletes },\n                        });\n                    }\n                    if let Some(new_gc_dels) = new_gc_dels {\n                        gc_dels = new_gc_dels;\n                    }\n                }\n                Undo { toggled_groups, deletes_bitxor } => {\n                    // We're super-aggressive about dropping these; after gc, the history\n                    // of which undos were used to compute deletes_from_union in edits may be lost.\n                    if retain_revs.contains(&rev.rev_id) {\n                        let new_deletes_bitxor = if gc_dels.is_empty() {\n                            deletes_bitxor\n                        } else {\n                            deletes_bitxor.transform_shrink(&gc_dels)\n                        };\n                        self.revs.push(Revision {\n                            rev_id: rev.rev_id,\n                            max_undo_so_far: rev.max_undo_so_far,\n                            edit: Undo {\n                                toggled_groups: &toggled_groups - gc_groups,\n                                deletes_bitxor: new_deletes_bitxor,\n                            },\n                        })\n                    }\n                }\n            }\n        }\n        self.revs.reverse();\n    }\n\n    /// Merge the new content from another Engine into this one with a CRDT merge\n    pub fn merge(&mut self, other: &Engine) {\n        let (mut new_revs, text, tombstones, deletes_from_union) = {\n            let base_index = find_base_index(&self.revs, &other.revs);\n            let a_to_merge = &self.revs[base_index..];\n            let b_to_merge = &other.revs[base_index..];\n\n            let common = find_common(a_to_merge, b_to_merge);\n\n            let a_new = rearrange(a_to_merge, &common, self.deletes_from_union.len());\n            let b_new = rearrange(b_to_merge, &common, other.deletes_from_union.len());\n\n            let b_deltas =\n                compute_deltas(&b_new, &other.text, &other.tombstones, &other.deletes_from_union);\n            let expand_by = compute_transforms(a_new);\n\n            let max_undo = self.max_undo_group_id();\n            rebase(\n                expand_by,\n                b_deltas,\n                self.text.clone(),\n                self.tombstones.clone(),\n                self.deletes_from_union.clone(),\n                max_undo,\n            )\n        };\n\n        self.text = text;\n        self.tombstones = tombstones;\n        self.deletes_from_union = deletes_from_union;\n        self.revs.append(&mut new_revs);\n    }\n\n    /// When merging between multiple concurrently-editing sessions, each session should have a unique ID\n    /// set with this function, which will make the revisions they create not have colliding IDs.\n    /// For safety, this will panic if any revisions have already been added to the Engine.\n    ///\n    /// Merge may panic or return incorrect results if session IDs collide, which is why they can be\n    /// 96 bits which is more than sufficient for this to never happen.\n    pub fn set_session_id(&mut self, session: SessionId) {\n        assert_eq!(\n            1,\n            self.revs.len(),\n            \"Revisions were added to an Engine before set_session_id, these may collide.\"\n        );\n        self.session = session;\n    }\n}"],"engine::Error":["Clone","impl std::error::Error for Error {}","impl std::fmt::Debug for Error {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        std::fmt::Display::fmt(self, f)\n    }\n}","impl std::fmt::Display for Error {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        match self {\n            Error::MissingRevision(_) => write!(f, \"Revision not found\"),\n            Error::MalformedDelta { delta_len, rev_len } => {\n                write!(f, \"Delta base_len {} does not match revision length {}\", delta_len, rev_len)\n            }\n        }\n    }\n}"],"engine::FullPriority":["Clone","Copy","Eq","Ord","PartialEq","PartialOrd"],"engine::RevId":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl RevId {\n    /// Returns a u64 that will be equal for equivalent revision IDs and\n    /// should be as unlikely to collide as two random u64s.\n    pub fn token(&self) -> RevToken {\n        use std::hash::{Hash, Hasher};\n        // Rust is unlikely to break the property that this hash is strongly collision-resistant\n        // and it only needs to be consistent over one execution.\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()\n    }\n\n    pub fn session_id(&self) -> SessionId {\n        (self.session1, self.session2)\n    }\n}"],"engine::Revision":["Debug"],"find::CaseMatching":["Clone","Copy","PartialEq"],"interval::Interval":["Clone","Copy","Eq","PartialEq","impl From<Range<usize>> for Interval {\n    fn from(src: Range<usize>) -> Interval {\n        let Range { start, end } = src;\n        Interval { start, end }\n    }\n}","impl From<RangeInclusive<usize>> for Interval {\n    fn from(src: RangeInclusive<usize>) -> Interval {\n        Interval::new(*src.start(), src.end().saturating_add(1))\n    }\n}","impl From<RangeTo<usize>> for Interval {\n    fn from(src: RangeTo<usize>) -> Interval {\n        Interval::new(0, src.end)\n    }\n}","impl From<RangeToInclusive<usize>> for Interval {\n    fn from(src: RangeToInclusive<usize>) -> Interval {\n        Interval::new(0, src.end.saturating_add(1))\n    }\n}","impl Interval {\n    /// Construct a new `Interval` representing the range [start..end).\n    /// It is an invariant that `start <= end`.\n    pub fn new(start: usize, end: usize) -> Interval {\n        debug_assert!(start <= end);\n        Interval { start, end }\n    }\n\n    #[deprecated(since = \"0.3.0\", note = \"all intervals are now closed_open, use Interval::new\")]\n    pub fn new_closed_open(start: usize, end: usize) -> Interval {\n        Self::new(start, end)\n    }\n\n    #[deprecated(since = \"0.3.0\", note = \"all intervals are now closed_open\")]\n    pub fn new_open_closed(start: usize, end: usize) -> Interval {\n        Self::new(start, end)\n    }\n\n    #[deprecated(since = \"0.3.0\", note = \"all intervals are now closed_open\")]\n    pub fn new_closed_closed(start: usize, end: usize) -> Interval {\n        Self::new(start, end)\n    }\n\n    #[deprecated(since = \"0.3.0\", note = \"all intervals are now closed_open\")]\n    pub fn new_open_open(start: usize, end: usize) -> Interval {\n        Self::new(start, end)\n    }\n\n    pub fn start(&self) -> usize {\n        self.start\n    }\n\n    pub fn end(&self) -> usize {\n        self.end\n    }\n\n    pub fn start_end(&self) -> (usize, usize) {\n        (self.start, self.end)\n    }\n\n    // The following 3 methods define a trisection, exactly one is true.\n    // (similar to std::cmp::Ordering, but \"Equal\" is not the same as \"contains\")\n\n    /// the interval is before the point (the point is after the interval)\n    pub fn is_before(&self, val: usize) -> bool {\n        self.end <= val\n    }\n\n    /// the point is inside the interval\n    pub fn contains(&self, val: usize) -> bool {\n        self.start <= val && val < self.end\n    }\n\n    /// the interval is after the point (the point is before the interval)\n    pub fn is_after(&self, val: usize) -> bool {\n        self.start > val\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.end <= self.start\n    }\n\n    // impl BitAnd would be completely valid for this\n    pub fn intersect(&self, other: Interval) -> Interval {\n        let start = max(self.start, other.start);\n        let end = min(self.end, other.end);\n        Interval { start, end: max(start, end) }\n    }\n\n    // smallest interval that encloses both inputs; if the inputs are\n    // disjoint, then it fills in the hole.\n    pub fn union(&self, other: Interval) -> Interval {\n        if self.is_empty() {\n            return other;\n        }\n        if other.is_empty() {\n            return *self;\n        }\n        let start = min(self.start, other.start);\n        let end = max(self.end, other.end);\n        Interval { start, end }\n    }\n\n    // the first half of self - other\n    pub fn prefix(&self, other: Interval) -> Interval {\n        Interval { start: min(self.start, other.start), end: min(self.end, other.start) }\n    }\n\n    // the second half of self - other\n    pub fn suffix(&self, other: Interval) -> Interval {\n        Interval { start: max(self.start, other.end), end: max(self.end, other.end) }\n    }\n\n    // could impl Add trait, but that's probably too cute\n    pub fn translate(&self, amount: usize) -> Interval {\n        Interval { start: self.start + amount, end: self.end + amount }\n    }\n\n    // as above for Sub trait\n    pub fn translate_neg(&self, amount: usize) -> Interval {\n        debug_assert!(self.start >= amount);\n        Interval { start: self.start - amount, end: self.end - amount }\n    }\n\n    // insensitive to open or closed ends, just the size of the interior\n    pub fn size(&self) -> usize {\n        self.end - self.start\n    }\n}","impl fmt::Debug for Interval {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}","impl fmt::Display for Interval {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"[{}, {})\", self.start(), self.end())\n    }\n}"],"multiset::CountMatcher":["Clone","Copy","Debug","impl CountMatcher {\n    fn matches(self, seg: &Segment) -> bool {\n        match self {\n            CountMatcher::Zero => (seg.count == 0),\n            CountMatcher::NonZero => (seg.count != 0),\n            CountMatcher::All => true,\n        }\n    }\n}"],"multiset::Mapper":["impl<'a> Mapper<'a> {\n    /// Map a coordinate in the document this subset corresponds to, to a\n    /// coordinate in the subset matched by the `CountMatcher`. For example,\n    /// if the Subset is a set of deletions and the matcher is\n    /// `CountMatcher::NonZero`, this would map indices in the union string to\n    /// indices in the tombstones string.\n    ///\n    /// Will return the closest coordinate in the subset if the index is not\n    /// in the subset. If the coordinate is past the end of the subset it will\n    /// return one more than the largest index in the subset (i.e the length).\n    /// This behaviour is suitable for mapping closed-open intervals in a\n    /// string to intervals in a subset of the string.\n    ///\n    /// In order to guarantee good performance, this method must be called\n    /// with `i` values in non-decreasing order or it will panic. This allows\n    /// the total cost to be O(n) where `n = max(calls,ranges)` over all times\n    /// called on a single `Mapper`.\n    pub fn doc_index_to_subset(&mut self, i: usize) -> usize {\n        assert!(\n            i >= self.last_i,\n            \"method must be called with i in non-decreasing order. i={}<{}=last_i\",\n            i,\n            self.last_i\n        );\n        self.last_i = i;\n\n        while i >= self.cur_range.1 {\n            self.subset_amount_consumed += self.cur_range.1 - self.cur_range.0;\n            self.cur_range = match self.range_iter.next() {\n                Some(range) => range,\n                // past the end of the subset\n                None => {\n                    // ensure we don't try to consume any more\n                    self.cur_range = (usize::max_value(), usize::max_value());\n                    return self.subset_amount_consumed;\n                }\n            }\n        }\n\n        if i >= self.cur_range.0 {\n            let dist_in_range = i - self.cur_range.0;\n            dist_in_range + self.subset_amount_consumed\n        } else {\n            // not in the subset\n            self.subset_amount_consumed\n        }\n    }\n}"],"multiset::RangeIter":["impl<'a> Iterator for RangeIter<'a> {\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        while let Some(seg) = self.seg_iter.next() {\n            self.consumed += seg.len;\n            if self.matcher.matches(seg) {\n                return Some((self.consumed - seg.len, self.consumed));\n            }\n        }\n        None\n    }\n}"],"multiset::Segment":["Clone","Debug","Eq","PartialEq"],"multiset::Subset":["Clone","Eq","PartialEq","impl Subset {\n    /// Creates an empty `Subset` of a string of length `len`\n    pub fn new(len: usize) -> Subset {\n        let mut sb = SubsetBuilder::new();\n        sb.pad_to_len(len);\n        sb.build()\n    }\n\n    /// Mostly for testing.\n    pub fn delete_from_string(&self, s: &str) -> String {\n        let mut result = String::new();\n        for (b, e) in self.range_iter(CountMatcher::Zero) {\n            result.push_str(&s[b..e]);\n        }\n        result\n    }\n\n    // Maybe Subset should be a pure data structure and this method should\n    // be a method of Node.\n    /// Builds a version of `s` with all the elements in this `Subset` deleted from it.\n    pub fn delete_from<N: NodeInfo>(&self, s: &Node<N>) -> Node<N> {\n        let mut b = TreeBuilder::new();\n        for (beg, end) in self.range_iter(CountMatcher::Zero) {\n            s.push_subseq(&mut b, Interval::new(beg, end));\n        }\n        b.build()\n    }\n\n    /// The length of the resulting sequence after deleting this subset. A\n    /// convenience alias for `self.count(CountMatcher::Zero)` to reduce\n    /// thinking about what that means in the cases where the length after\n    /// delete is what you want to know.\n    ///\n    /// `self.delete_from_string(s).len() = self.len(s.len())`\n    pub fn len_after_delete(&self) -> usize {\n        self.count(CountMatcher::Zero)\n    }\n\n    /// Count the total length of all the segments matching `matcher`.\n    pub fn count(&self, matcher: CountMatcher) -> usize {\n        self.segments.iter().filter(|seg| matcher.matches(seg)).map(|seg| seg.len).sum()\n    }\n\n    /// Convenience alias for `self.count(CountMatcher::All)`\n    pub fn len(&self) -> usize {\n        self.count(CountMatcher::All)\n    }\n\n    /// Determine whether the subset is empty.\n    /// In this case deleting it would do nothing.\n    pub fn is_empty(&self) -> bool {\n        (self.segments.is_empty()) || ((self.segments.len() == 1) && (self.segments[0].count == 0))\n    }\n\n    /// Compute the union of two subsets. The count of an element in the\n    /// result is the sum of the counts in the inputs.\n    pub fn union(&self, other: &Subset) -> Subset {\n        let mut sb = SubsetBuilder::new();\n        for zseg in self.zip(other) {\n            sb.push_segment(zseg.len, zseg.a_count + zseg.b_count);\n        }\n        sb.build()\n    }\n\n    /// Compute the difference of two subsets. The count of an element in the\n    /// result is the subtraction of the counts of other from self.\n    pub fn subtract(&self, other: &Subset) -> Subset {\n        let mut sb = SubsetBuilder::new();\n        for zseg in self.zip(other) {\n            assert!(\n                zseg.a_count >= zseg.b_count,\n                \"can't subtract {} from {}\",\n                zseg.a_count,\n                zseg.b_count\n            );\n            sb.push_segment(zseg.len, zseg.a_count - zseg.b_count);\n        }\n        sb.build()\n    }\n\n    /// Compute the bitwise xor of two subsets, useful as a reversible\n    /// difference. The count of an element in the result is the bitwise xor\n    /// of the counts of the inputs. Unchanged segments will be 0.\n    ///\n    /// This works like set symmetric difference when all counts are 0 or 1\n    /// but it extends nicely to the case of larger counts.\n    pub fn bitxor(&self, other: &Subset) -> Subset {\n        let mut sb = SubsetBuilder::new();\n        for zseg in self.zip(other) {\n            sb.push_segment(zseg.len, zseg.a_count ^ zseg.b_count);\n        }\n        sb.build()\n    }\n\n    /// Map the contents of `self` into the 0-regions of `other`.\n    /// Precondition: `self.count(CountMatcher::All) == other.count(CountMatcher::Zero)`\n    fn transform(&self, other: &Subset, union: bool) -> Subset {\n        let mut sb = SubsetBuilder::new();\n        let mut seg_iter = self.segments.iter();\n        let mut cur_seg = Segment { len: 0, count: 0 };\n        for oseg in &other.segments {\n            if oseg.count > 0 {\n                sb.push_segment(oseg.len, if union { oseg.count } else { 0 });\n            } else {\n                // fill 0-region with segments from self.\n                let mut to_be_consumed = oseg.len;\n                while to_be_consumed > 0 {\n                    if cur_seg.len == 0 {\n                        cur_seg = seg_iter\n                            .next()\n                            .expect(\"self must cover all 0-regions of other\")\n                            .clone();\n                    }\n                    // consume as much of the segment as possible and necessary\n                    let to_consume = cmp::min(cur_seg.len, to_be_consumed);\n                    sb.push_segment(to_consume, cur_seg.count);\n                    to_be_consumed -= to_consume;\n                    cur_seg.len -= to_consume;\n                }\n            }\n        }\n        assert_eq!(cur_seg.len, 0, \"the 0-regions of other must be the size of self\");\n        assert_eq!(seg_iter.next(), None, \"the 0-regions of other must be the size of self\");\n        sb.build()\n    }\n\n    /// Transform through coordinate transform represented by other.\n    /// The equation satisfied is as follows:\n    ///\n    /// s1 = other.delete_from_string(s0)\n    ///\n    /// s2 = self.delete_from_string(s1)\n    ///\n    /// element in self.transform_expand(other).delete_from_string(s0) if (not in s1) or in s2\n    pub fn transform_expand(&self, other: &Subset) -> Subset {\n        self.transform(other, false)\n    }\n\n    /// The same as taking transform_expand and then unioning with `other`.\n    pub fn transform_union(&self, other: &Subset) -> Subset {\n        self.transform(other, true)\n    }\n\n    /// Transform subset through other coordinate transform, shrinking.\n    /// The following equation is satisfied:\n    ///\n    /// C = A.transform_expand(B)\n    ///\n    /// B.transform_shrink(C).delete_from_string(C.delete_from_string(s)) =\n    ///   A.delete_from_string(B.delete_from_string(s))\n    pub fn transform_shrink(&self, other: &Subset) -> Subset {\n        let mut sb = SubsetBuilder::new();\n        // discard ZipSegments where the shrinking set has positive count\n        for zseg in self.zip(other) {\n            // TODO: should this actually do something like subtract counts?\n            if zseg.b_count == 0 {\n                sb.push_segment(zseg.len, zseg.a_count);\n            }\n        }\n        sb.build()\n    }\n\n    /// Return an iterator over the ranges with a count matching the `matcher`.\n    /// These will often be easier to work with than raw segments.\n    pub fn range_iter(&self, matcher: CountMatcher) -> RangeIter {\n        RangeIter { seg_iter: self.segments.iter(), consumed: 0, matcher }\n    }\n\n    /// Convenience alias for `self.range_iter(CountMatcher::Zero)`.\n    /// Semantically iterates the ranges of the complement of this `Subset`.\n    pub fn complement_iter(&self) -> RangeIter {\n        self.range_iter(CountMatcher::Zero)\n    }\n\n    /// Return an iterator over `ZipSegment`s where each `ZipSegment` contains\n    /// the count for both self and other in that range. The two `Subset`s\n    /// must have the same total length.\n    ///\n    /// Each returned `ZipSegment` will differ in at least one count.\n    pub fn zip<'a>(&'a self, other: &'a Subset) -> ZipIter<'a> {\n        ZipIter {\n            a_segs: self.segments.as_slice(),\n            b_segs: other.segments.as_slice(),\n            a_i: 0,\n            b_i: 0,\n            a_consumed: 0,\n            b_consumed: 0,\n            consumed: 0,\n        }\n    }\n\n    /// Find the complement of this Subset. Every 0-count element will have a\n    /// count of 1 and every non-zero element will have a count of 0.\n    pub fn complement(&self) -> Subset {\n        let mut sb = SubsetBuilder::new();\n        for seg in &self.segments {\n            if seg.count == 0 {\n                sb.push_segment(seg.len, 1);\n            } else {\n                sb.push_segment(seg.len, 0);\n            }\n        }\n        sb.build()\n    }\n\n    /// Return a `Mapper` that can be use to map coordinates in the document to coordinates\n    /// in this `Subset`, but only in non-decreasing order for performance reasons.\n    pub fn mapper(&self, matcher: CountMatcher) -> Mapper {\n        Mapper {\n            range_iter: self.range_iter(matcher),\n            last_i: 0, // indices only need to be in non-decreasing order, not increasing\n            cur_range: (0, 0), // will immediately try to consume next range\n            subset_amount_consumed: 0,\n        }\n    }\n}","impl fmt::Debug for Subset {\n    /// Use the alternate flag (`#`) to print a more compact representation\n    /// where each character represents the count of one element:\n    /// '-' is 0, '#' is 1, 2-9 are digits, `+` is >9\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if f.alternate() {\n            for s in &self.segments {\n                let chr = if s.count == 0 {\n                    '-'\n                } else if s.count == 1 {\n                    '#'\n                } else if s.count <= 9 {\n                    ((s.count as u8) + b'0') as char\n                } else {\n                    '+'\n                };\n                for _ in 0..s.len {\n                    write!(f, \"{}\", chr)?;\n                }\n            }\n            Ok(())\n        } else {\n            f.debug_tuple(\"Subset\").field(&self.segments).finish()\n        }\n    }\n}"],"multiset::SubsetBuilder":["Default","impl SubsetBuilder {\n    pub fn new() -> SubsetBuilder {\n        SubsetBuilder::default()\n    }\n\n    /// Intended for use with `add_range` to ensure the total length of the\n    /// `Subset` corresponds to the document length.\n    pub fn pad_to_len(&mut self, total_len: usize) {\n        if total_len > self.total_len {\n            let cur_len = self.total_len;\n            self.push_segment(total_len - cur_len, 0);\n        }\n    }\n\n    /// Sets the count for a given range. This method must be called with a\n    /// non-empty range with `begin` not before the largest range or segment added\n    /// so far. Gaps will be filled with a 0-count segment.\n    pub fn add_range(&mut self, begin: usize, end: usize, count: usize) {\n        assert!(begin >= self.total_len, \"ranges must be added in non-decreasing order\");\n        // assert!(begin < end, \"ranges added must be non-empty: [{},{})\", begin, end);\n        if begin >= end {\n            return;\n        }\n        let len = end - begin;\n        let cur_total_len = self.total_len;\n\n        // add 0-count segment to fill any gap\n        if begin > self.total_len {\n            self.push_segment(begin - cur_total_len, 0);\n        }\n\n        self.push_segment(len, count);\n    }\n\n    /// Assign `count` to the next `len` elements in the string.\n    /// Will panic if called with `len==0`.\n    pub fn push_segment(&mut self, len: usize, count: usize) {\n        assert!(len > 0, \"can't push empty segment\");\n        self.total_len += len;\n\n        // merge into previous segment if possible\n        if let Some(last) = self.segments.last_mut() {\n            if last.count == count {\n                last.len += len;\n                return;\n            }\n        }\n\n        self.segments.push(Segment { len, count });\n    }\n\n    pub fn build(self) -> Subset {\n        Subset { segments: self.segments }\n    }\n}"],"multiset::ZipIter":["impl<'a> Iterator for ZipIter<'a> {\n    type Item = ZipSegment;\n\n    /// Consume as far as possible from `self.consumed` until reaching a\n    /// segment boundary in either `Subset`, and return the resulting\n    /// `ZipSegment`. Will panic if it reaches the end of one `Subset` before\n    /// the other, that is when they have different total length.\n    fn next(&mut self) -> Option<ZipSegment> {\n        match (self.a_segs.get(self.a_i), self.b_segs.get(self.b_i)) {\n            (None, None) => None,\n            (None, Some(_)) | (Some(_), None) => {\n                panic!(\"can't zip Subsets of different base lengths.\")\n            }\n            (\n                Some(&Segment { len: a_len, count: a_count }),\n                Some(&Segment { len: b_len, count: b_count }),\n            ) => {\n                let len = match (a_len + self.a_consumed).cmp(&(b_len + self.b_consumed)) {\n                    cmp::Ordering::Equal => {\n                        self.a_consumed += a_len;\n                        self.a_i += 1;\n                        self.b_consumed += b_len;\n                        self.b_i += 1;\n                        self.a_consumed - self.consumed\n                    }\n                    cmp::Ordering::Less => {\n                        self.a_consumed += a_len;\n                        self.a_i += 1;\n                        self.a_consumed - self.consumed\n                    }\n                    cmp::Ordering::Greater => {\n                        self.b_consumed += b_len;\n                        self.b_i += 1;\n                        self.b_consumed - self.consumed\n                    }\n                };\n                self.consumed += len;\n                Some(ZipSegment { len, a_count, b_count })\n            }\n        }\n    }\n}"],"multiset::ZipSegment":["Clone","Debug"],"rope::BaseMetric":["Clone","Copy","impl Metric<RopeInfo> for BaseMetric {\n    fn measure(_: &RopeInfo, len: usize) -> usize {\n        len\n    }\n\n    fn to_base_units(s: &String, in_measured_units: usize) -> usize {\n        debug_assert!(s.is_char_boundary(in_measured_units));\n        in_measured_units\n    }\n\n    fn from_base_units(s: &String, in_base_units: usize) -> usize {\n        debug_assert!(s.is_char_boundary(in_base_units));\n        in_base_units\n    }\n\n    fn is_boundary(s: &String, offset: usize) -> bool {\n        s.is_char_boundary(offset)\n    }\n\n    fn prev(s: &String, offset: usize) -> Option<usize> {\n        if offset == 0 {\n            // I think it's a precondition that this will never be called\n            // with offset == 0, but be defensive.\n            None\n        } else {\n            let mut len = 1;\n            while !s.is_char_boundary(offset - len) {\n                len += 1;\n            }\n            Some(offset - len)\n        }\n    }\n\n    fn next(s: &String, offset: usize) -> Option<usize> {\n        if offset == s.len() {\n            // I think it's a precondition that this will never be called\n            // with offset == s.len(), but be defensive.\n            None\n        } else {\n            let b = s.as_bytes()[offset];\n            Some(offset + len_utf8_from_first_byte(b))\n        }\n    }\n\n    fn can_fragment() -> bool {\n        false\n    }\n}"],"rope::ChunkIter":["impl<'a> Iterator for ChunkIter<'a> {\n    type Item = &'a str;\n\n    fn next(&mut self) -> Option<&'a str> {\n        if self.cursor.pos() >= self.end {\n            return None;\n        }\n        let (leaf, start_pos) = self.cursor.get_leaf().unwrap();\n        let len = min(self.end - self.cursor.pos(), leaf.len() - start_pos);\n        self.cursor.next_leaf();\n        Some(&leaf[start_pos..start_pos + len])\n    }\n}"],"rope::Lines":["impl<'a> Iterator for Lines<'a> {\n    type Item = Cow<'a, str>;\n\n    fn next(&mut self) -> Option<Cow<'a, str>> {\n        match self.inner.next() {\n            Some(Cow::Borrowed(mut s)) => {\n                if s.ends_with('\\n') {\n                    s = &s[..s.len() - 1];\n                    if s.ends_with('\\r') {\n                        s = &s[..s.len() - 1];\n                    }\n                }\n                Some(Cow::from(s))\n            }\n            Some(Cow::Owned(mut s)) => {\n                if s.ends_with('\\n') {\n                    let _ = s.pop();\n                    if s.ends_with('\\r') {\n                        let _ = s.pop();\n                    }\n                }\n                Some(Cow::from(s))\n            }\n            None => None,\n        }\n    }\n}"],"rope::LinesMetric":["Clone","Copy","impl Metric<RopeInfo> for LinesMetric {\n    fn measure(info: &RopeInfo, _: usize) -> usize {\n        info.lines\n    }\n\n    fn is_boundary(s: &String, offset: usize) -> bool {\n        if offset == 0 {\n            // shouldn't be called with this, but be defensive\n            false\n        } else {\n            s.as_bytes()[offset - 1] == b'\\n'\n        }\n    }\n\n    fn to_base_units(s: &String, in_measured_units: usize) -> usize {\n        let mut offset = 0;\n        for _ in 0..in_measured_units {\n            match memchr(b'\\n', &s.as_bytes()[offset..]) {\n                Some(pos) => offset += pos + 1,\n                _ => panic!(\"to_base_units called with arg too large\"),\n            }\n        }\n        offset\n    }\n\n    fn from_base_units(s: &String, in_base_units: usize) -> usize {\n        count_newlines(&s[..in_base_units])\n    }\n\n    fn prev(s: &String, offset: usize) -> Option<usize> {\n        debug_assert!(offset > 0, \"caller is responsible for validating input\");\n        memrchr(b'\\n', &s.as_bytes()[..offset - 1]).map(|pos| pos + 1)\n    }\n\n    fn next(s: &String, offset: usize) -> Option<usize> {\n        memchr(b'\\n', &s.as_bytes()[offset..]).map(|pos| offset + pos + 1)\n    }\n\n    fn can_fragment() -> bool {\n        true\n    }\n}"],"rope::LinesRaw":["impl<'a> Iterator for LinesRaw<'a> {\n    type Item = Cow<'a, str>;\n\n    fn next(&mut self) -> Option<Cow<'a, str>> {\n        let mut result = Cow::from(\"\");\n        loop {\n            if self.fragment.is_empty() {\n                match self.inner.next() {\n                    Some(chunk) => self.fragment = chunk,\n                    None => return if result.is_empty() { None } else { Some(result) },\n                }\n                if self.fragment.is_empty() {\n                    // can only happen on empty input\n                    return None;\n                }\n            }\n            match memchr(b'\\n', self.fragment.as_bytes()) {\n                Some(i) => {\n                    result = cow_append(result, &self.fragment[..=i]);\n                    self.fragment = &self.fragment[i + 1..];\n                    return Some(result);\n                }\n                None => {\n                    result = cow_append(result, self.fragment);\n                    self.fragment = \"\";\n                }\n            }\n        }\n    }\n}"],"rope::Rope":["impl Add for Rope {\n    type Output = Rope;\n    fn add(self, rhs: Rope) -> Rope {\n        let mut b = TreeBuilder::new();\n        b.push(self);\n        b.push(rhs);\n        b.build()\n    }\n}","impl FromStr for Rope {\n    type Err = ParseError;\n    fn from_str(s: &str) -> Result<Rope, Self::Err> {\n        let mut b = TreeBuilder::new();\n        b.push_str(s);\n        Ok(b.build())\n    }\n}","impl Rope {\n    /// Edit the string, replacing the byte range [`start`..`end`] with `new`.\n    ///\n    /// Time complexity: O(log n)\n    #[deprecated(since = \"0.3.0\", note = \"Use Rope::edit instead\")]\n    pub fn edit_str<T: IntervalBounds>(&mut self, iv: T, new: &str) {\n        self.edit(iv, new)\n    }\n\n    /// Returns a new Rope with the contents of the provided range.\n    pub fn slice<T: IntervalBounds>(&self, iv: T) -> Rope {\n        self.subseq(iv)\n    }\n\n    // encourage callers to use Cursor instead?\n\n    /// Determine whether `offset` lies on a codepoint boundary.\n    pub fn is_codepoint_boundary(&self, offset: usize) -> bool {\n        let mut cursor = Cursor::new(self, offset);\n        cursor.is_boundary::<BaseMetric>()\n    }\n\n    /// Return the offset of the codepoint before `offset`.\n    pub fn prev_codepoint_offset(&self, offset: usize) -> Option<usize> {\n        let mut cursor = Cursor::new(self, offset);\n        cursor.prev::<BaseMetric>()\n    }\n\n    /// Return the offset of the codepoint after `offset`.\n    pub fn next_codepoint_offset(&self, offset: usize) -> Option<usize> {\n        let mut cursor = Cursor::new(self, offset);\n        cursor.next::<BaseMetric>()\n    }\n\n    /// Returns `offset` if it lies on a codepoint boundary. Otherwise returns\n    /// the codepoint after `offset`.\n    pub fn at_or_next_codepoint_boundary(&self, offset: usize) -> Option<usize> {\n        if self.is_codepoint_boundary(offset) {\n            Some(offset)\n        } else {\n            self.next_codepoint_offset(offset)\n        }\n    }\n\n    /// Returns `offset` if it lies on a codepoint boundary. Otherwise returns\n    /// the codepoint before `offset`.\n    pub fn at_or_prev_codepoint_boundary(&self, offset: usize) -> Option<usize> {\n        if self.is_codepoint_boundary(offset) {\n            Some(offset)\n        } else {\n            self.prev_codepoint_offset(offset)\n        }\n    }\n\n    pub fn prev_grapheme_offset(&self, offset: usize) -> Option<usize> {\n        let mut cursor = Cursor::new(self, offset);\n        cursor.prev_grapheme()\n    }\n\n    pub fn next_grapheme_offset(&self, offset: usize) -> Option<usize> {\n        let mut cursor = Cursor::new(self, offset);\n        cursor.next_grapheme()\n    }\n\n    /// Return the line number corresponding to the byte index `offset`.\n    ///\n    /// The line number is 0-based, thus this is equivalent to the count of newlines\n    /// in the slice up to `offset`.\n    ///\n    /// Time complexity: O(log n)\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `offset > self.len()`. Callers are expected to\n    /// validate their input.\n    pub fn line_of_offset(&self, offset: usize) -> usize {\n        self.count::<LinesMetric>(offset)\n    }\n\n    /// Return the byte offset corresponding to the line number `line`.\n    /// If `line` is equal to one plus the current number of lines,\n    /// this returns the offset of the end of the rope. Arguments higher\n    /// than this will panic.\n    ///\n    /// The line number is 0-based.\n    ///\n    /// Time complexity: O(log n)\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `line > self.measure::<LinesMetric>() + 1`.\n    /// Callers are expected to validate their input.\n    pub fn offset_of_line(&self, line: usize) -> usize {\n        let max_line = self.measure::<LinesMetric>() + 1;\n        match line.cmp(&max_line) {\n            Ordering::Greater => {\n                panic!(\"line number {} beyond last line {}\", line, max_line);\n            }\n            Ordering::Equal => {\n                return self.len();\n            }\n            Ordering::Less => self.count_base_units::<LinesMetric>(line),\n        }\n    }\n\n    /// Returns an iterator over chunks of the rope.\n    ///\n    /// Each chunk is a `&str` slice borrowed from the rope's storage. The size\n    /// of the chunks is indeterminate but for large strings will generally be\n    /// in the range of 511-1024 bytes.\n    ///\n    /// The empty string will yield a single empty slice. In all other cases, the\n    /// slices will be nonempty.\n    ///\n    /// Time complexity: technically O(n log n), but the constant factor is so\n    /// tiny it is effectively O(n). This iterator does not allocate.\n    pub fn iter_chunks<T: IntervalBounds>(&self, range: T) -> ChunkIter {\n        let Interval { start, end } = range.into_interval(self.len());\n\n        ChunkIter { cursor: Cursor::new(self, start), end }\n    }\n\n    /// An iterator over the raw lines. The lines, except the last, include the\n    /// terminating newline.\n    ///\n    /// The return type is a `Cow<str>`, and in most cases the lines are slices\n    /// borrowed from the rope.\n    pub fn lines_raw<T: IntervalBounds>(&self, range: T) -> LinesRaw {\n        LinesRaw { inner: self.iter_chunks(range), fragment: \"\" }\n    }\n\n    /// An iterator over the lines of a rope.\n    ///\n    /// Lines are ended with either Unix (`\\n`) or MS-DOS (`\\r\\n`) style line endings.\n    /// The line ending is stripped from the resulting string. The final line ending\n    /// is optional.\n    ///\n    /// The return type is a `Cow<str>`, and in most cases the lines are slices borrowed\n    /// from the rope.\n    ///\n    /// The semantics are intended to match `str::lines()`.\n    pub fn lines<T: IntervalBounds>(&self, range: T) -> Lines {\n        Lines { inner: self.lines_raw(range) }\n    }\n\n    // callers should be encouraged to use cursor instead\n    pub fn byte_at(&self, offset: usize) -> u8 {\n        let cursor = Cursor::new(self, offset);\n        let (leaf, pos) = cursor.get_leaf().unwrap();\n        leaf.as_bytes()[pos]\n    }\n\n    pub fn slice_to_cow<T: IntervalBounds>(&self, range: T) -> Cow<str> {\n        let mut iter = self.iter_chunks(range);\n        let first = iter.next();\n        let second = iter.next();\n\n        match (first, second) {\n            (None, None) => Cow::from(\"\"),\n            (Some(s), None) => Cow::from(s),\n            (Some(one), Some(two)) => {\n                let mut result = [one, two].concat();\n                for chunk in iter {\n                    result.push_str(chunk);\n                }\n                Cow::from(result)\n            }\n            (None, Some(_)) => unreachable!(),\n        }\n    }\n}","impl fmt::Debug for Rope {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if f.alternate() {\n            write!(f, \"{}\", String::from(self))\n        } else {\n            write!(f, \"Rope({:?})\", String::from(self))\n        }\n    }\n}","impl fmt::Display for Rope {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for s in self.iter_chunks(..) {\n            write!(f, \"{}\", s)?;\n        }\n        Ok(())\n    }\n}","impl<T: AsRef<str>> From<T> for Rope {\n    fn from(s: T) -> Rope {\n        Rope::from_str(s.as_ref()).unwrap()\n    }\n}"],"rope::RopeInfo":["Clone","Copy","impl DefaultMetric for RopeInfo {\n    type DefaultMetric = BaseMetric;\n}","impl NodeInfo for RopeInfo {\n    type L = String;\n\n    fn accumulate(&mut self, other: &Self) {\n        self.lines += other.lines;\n        self.utf16_size += other.utf16_size;\n    }\n\n    fn compute_info(s: &String) -> Self {\n        RopeInfo { lines: count_newlines(s), utf16_size: count_utf16_code_units(s) }\n    }\n\n    fn identity() -> Self {\n        RopeInfo { lines: 0, utf16_size: 0 }\n    }\n}"],"rope::Utf16CodeUnitsMetric":["Clone","Copy","impl Metric<RopeInfo> for Utf16CodeUnitsMetric {\n    fn measure(info: &RopeInfo, _: usize) -> usize {\n        info.utf16_size\n    }\n\n    fn is_boundary(s: &String, offset: usize) -> bool {\n        s.is_char_boundary(offset)\n    }\n\n    fn to_base_units(s: &String, in_measured_units: usize) -> usize {\n        let mut cur_len_utf16 = 0;\n        let mut cur_len_utf8 = 0;\n        for u in s.chars() {\n            if cur_len_utf16 >= in_measured_units {\n                break;\n            }\n            cur_len_utf16 += u.len_utf16();\n            cur_len_utf8 += u.len_utf8();\n        }\n        cur_len_utf8\n    }\n\n    fn from_base_units(s: &String, in_base_units: usize) -> usize {\n        count_utf16_code_units(&s[..in_base_units])\n    }\n\n    fn prev(s: &String, offset: usize) -> Option<usize> {\n        if offset == 0 {\n            // I think it's a precondition that this will never be called\n            // with offset == 0, but be defensive.\n            None\n        } else {\n            let mut len = 1;\n            while !s.is_char_boundary(offset - len) {\n                len += 1;\n            }\n            Some(offset - len)\n        }\n    }\n\n    fn next(s: &String, offset: usize) -> Option<usize> {\n        if offset == s.len() {\n            // I think it's a precondition that this will never be called\n            // with offset == s.len(), but be defensive.\n            None\n        } else {\n            let b = s.as_bytes()[offset];\n            Some(offset + len_utf8_from_first_byte(b))\n        }\n    }\n\n    fn can_fragment() -> bool {\n        false\n    }\n}"],"spans::Span":["Clone"],"spans::SpanIter":["impl<'a, T: Clone> Iterator for SpanIter<'a, T> {\n    type Item = (Interval, &'a T);\n\n    fn next(&mut self) -> Option<(Interval, &'a T)> {\n        if let Some((leaf, start_pos)) = self.cursor.get_leaf() {\n            if leaf.spans.is_empty() {\n                return None;\n            }\n            let leaf_start = self.cursor.pos() - start_pos;\n            let span = &leaf.spans[self.ix];\n            self.ix += 1;\n            if self.ix == leaf.spans.len() {\n                let _ = self.cursor.next_leaf();\n                self.ix = 0;\n            }\n            return Some((span.iv.translate(leaf_start), &span.data));\n        }\n        None\n    }\n}"],"spans::Spans":["impl<T: Clone + fmt::Debug> fmt::Debug for Spans<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let strs =\n            self.iter().map(|(iv, val)| format!(\"{}: {:?}\", iv, val)).collect::<Vec<String>>();\n        write!(f, \"len: {}\\nspans:\\n\\t{}\", self.len(), &strs.join(\"\\n\\t\"))\n    }\n}","impl<T: Clone> Spans<T> {\n    /// Perform operational transformation on a spans object intended to be edited into\n    /// a sequence at the given offset.\n\n    // Note: this implementation is not efficient for very large Spans objects, as it\n    // traverses all spans linearly. A more sophisticated approach would be to traverse\n    // the tree, and only delve into subtrees that are transformed.\n    pub fn transform<N: NodeInfo>(\n        &self,\n        base_start: usize,\n        base_end: usize,\n        xform: &mut Transformer<N>,\n    ) -> Self {\n        // TODO: maybe should take base as an Interval and figure out \"after\" from that\n        let new_start = xform.transform(base_start, false);\n        let new_end = xform.transform(base_end, true);\n        let mut builder = SpansBuilder::new(new_end - new_start);\n        for (iv, data) in self.iter() {\n            let start = xform.transform(iv.start() + base_start, false) - new_start;\n            let end = xform.transform(iv.end() + base_start, false) - new_start;\n            if start < end {\n                let iv = Interval::new(start, end);\n                // TODO: could imagine using a move iterator and avoiding clone, but it's not easy.\n                builder.add_span(iv, data.clone());\n            }\n        }\n        builder.build()\n    }\n\n    /// Creates a new Spans instance by merging spans from `other` with `self`,\n    /// using a closure to transform values.\n    ///\n    /// New spans are created from non-overlapping regions of existing spans,\n    /// and by combining overlapping regions into new spans. In all cases,\n    /// new values are generated by calling a closure that transforms the\n    /// value of the existing span or spans.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `self` and `other` have different lengths.\n    ///\n    pub fn merge<F, O>(&self, other: &Self, mut f: F) -> Spans<O>\n    where\n        F: FnMut(&T, Option<&T>) -> O,\n        O: Clone,\n    {\n        //TODO: confirm that this is sensible behaviour\n        assert_eq!(self.len(), other.len());\n        let mut sb = SpansBuilder::new(self.len());\n\n        // red/blue is just a better name than one/two or me/other\n        let mut iter_red = self.iter();\n        let mut iter_blue = other.iter();\n\n        let mut next_red = iter_red.next();\n        let mut next_blue = iter_blue.next();\n\n        loop {\n            // exit conditions:\n            if next_red.is_none() && next_blue.is_none() {\n                // all merged.\n                break;\n            } else if next_red.is_none() != next_blue.is_none() {\n                // one side is exhausted; append remaining items from other side.\n                let iter = if next_red.is_some() { iter_red } else { iter_blue };\n                // add this item\n                let (iv, val) = next_red.or(next_blue).unwrap();\n                sb.add_span(iv, f(val, None));\n\n                for (iv, val) in iter {\n                    sb.add_span(iv, f(val, None))\n                }\n                break;\n            }\n\n            // body:\n            let (mut red_iv, red_val) = next_red.unwrap();\n            let (mut blue_iv, blue_val) = next_blue.unwrap();\n\n            if red_iv.intersect(blue_iv).is_empty() {\n                // spans do not overlap. Add the leading span & advance that iter.\n                if red_iv.is_before(blue_iv.start()) {\n                    sb.add_span(red_iv, f(red_val, None));\n                    next_red = iter_red.next();\n                } else {\n                    sb.add_span(blue_iv, f(blue_val, None));\n                    next_blue = iter_blue.next();\n                }\n                continue;\n            }\n            assert!(!red_iv.intersect(blue_iv).is_empty());\n\n            // if these two spans do not share a start point, create a new span from\n            // the prefix of the leading span.\n            use std::cmp::Ordering;\n\n            match red_iv.start().cmp(&blue_iv.start()) {\n                Ordering::Less => {\n                    let iv = red_iv.prefix(blue_iv);\n                    sb.add_span(iv, f(red_val, None));\n                    red_iv = red_iv.suffix(iv);\n                }\n                Ordering::Greater => {\n                    let iv = blue_iv.prefix(red_iv);\n                    sb.add_span(iv, f(blue_val, None));\n                    blue_iv = blue_iv.suffix(iv);\n                }\n                Ordering::Equal => {}\n            }\n\n            assert!(red_iv.start() == blue_iv.start());\n            // create a new span by merging the overlapping regions.\n            let iv = red_iv.intersect(blue_iv);\n            assert!(!iv.is_empty());\n            sb.add_span(iv, f(red_val, Some(blue_val)));\n\n            // if an old span was consumed by this new span, advance\n            // else reuse remaining span (set next_red/blue) for the next loop iteration\n            red_iv = red_iv.suffix(iv);\n            blue_iv = blue_iv.suffix(iv);\n            assert!(red_iv.is_empty() || blue_iv.is_empty());\n\n            if red_iv.is_empty() {\n                next_red = iter_red.next();\n            } else {\n                next_red = Some((red_iv, red_val));\n            }\n\n            if blue_iv.is_empty() {\n                next_blue = iter_blue.next();\n            } else {\n                next_blue = Some((blue_iv, blue_val));\n            }\n        }\n        sb.build()\n    }\n\n    // possible future: an iterator that takes an interval, so results are the same as\n    // taking a subseq on the spans object. Would require specialized Cursor.\n    pub fn iter(&self) -> SpanIter<T> {\n        SpanIter { cursor: Cursor::new(self, 0), ix: 0 }\n    }\n\n    /// Applies a generic delta to `self`, inserting empty spans for any\n    /// added regions.\n    ///\n    /// This is intended to be used to keep spans up to date with a `Rope`\n    /// as edits occur.\n    pub fn apply_shape<M: NodeInfo>(&mut self, delta: &Delta<M>) {\n        let mut b = TreeBuilder::new();\n        for elem in &delta.els {\n            match *elem {\n                DeltaElement::Copy(beg, end) => b.push(self.subseq(Interval::new(beg, end))),\n                DeltaElement::Insert(ref n) => b.push(SpansBuilder::new(n.len()).build()),\n            }\n        }\n        *self = b.build();\n    }\n\n    /// Deletes all spans that intersect with `interval` and that come after.\n    pub fn delete_after(&mut self, interval: Interval) {\n        let mut builder = SpansBuilder::new(self.len());\n\n        for (iv, data) in self.iter() {\n            // check if spans overlaps with interval\n            if iv.intersect(interval).is_empty() {\n                // keep the ones that are not overlapping\n                builder.add_span(iv, data.clone());\n            } else {\n                // all remaining spans are invalid\n                break;\n            }\n        }\n        *self = builder.build();\n    }\n}"],"spans::SpansBuilder":["impl<T: Clone> SpansBuilder<T> {\n    pub fn new(total_len: usize) -> Self {\n        SpansBuilder { b: TreeBuilder::new(), leaf: SpansLeaf::default(), len: 0, total_len }\n    }\n\n    // Precondition: spans must be added in nondecreasing start order.\n    // Maybe take Span struct instead of separate iv, data args?\n    pub fn add_span<IV: IntervalBounds>(&mut self, iv: IV, data: T) {\n        let iv = iv.into_interval(self.total_len);\n        if self.leaf.spans.len() == MAX_LEAF {\n            let mut leaf = mem::take(&mut self.leaf);\n            leaf.len = iv.start() - self.len;\n            self.len = iv.start();\n            self.b.push(Node::from_leaf(leaf));\n        }\n        self.leaf.spans.push(Span { iv: iv.translate_neg(self.len), data })\n    }\n\n    // Would make slightly more implementation sense to take total_len as an argument\n    // here, but that's not quite the usual builder pattern.\n    pub fn build(mut self) -> Spans<T> {\n        self.leaf.len = self.total_len - self.len;\n        self.b.push(Node::from_leaf(self.leaf));\n        self.b.build()\n    }\n}"],"spans::SpansInfo":["Clone","impl<T: Clone> NodeInfo for SpansInfo<T> {\n    type L = SpansLeaf<T>;\n\n    fn accumulate(&mut self, other: &Self) {\n        self.n_spans += other.n_spans;\n        self.iv = self.iv.union(other.iv);\n    }\n\n    fn compute_info(l: &SpansLeaf<T>) -> Self {\n        let mut iv = Interval::new(0, 0); // should be Interval::default?\n        for span in &l.spans {\n            iv = iv.union(span.iv);\n        }\n        SpansInfo { n_spans: l.spans.len(), iv, phantom: PhantomData }\n    }\n}"],"spans::SpansLeaf":["Clone","impl<T: Clone> Default for SpansLeaf<T> {\n    fn default() -> Self {\n        SpansLeaf { len: 0, spans: vec![] }\n    }\n}","impl<T: Clone> Leaf for SpansLeaf<T> {\n    fn len(&self) -> usize {\n        self.len\n    }\n\n    fn is_ok_child(&self) -> bool {\n        self.spans.len() >= MIN_LEAF\n    }\n\n    fn push_maybe_split(&mut self, other: &Self, iv: Interval) -> Option<Self> {\n        let iv_start = iv.start();\n        for span in &other.spans {\n            let span_iv = span.iv.intersect(iv).translate_neg(iv_start).translate(self.len);\n\n            if !span_iv.is_empty() {\n                self.spans.push(Span { iv: span_iv, data: span.data.clone() });\n            }\n        }\n        self.len += iv.size();\n\n        if self.spans.len() <= MAX_LEAF {\n            None\n        } else {\n            let splitpoint = self.spans.len() / 2; // number of spans\n            let splitpoint_units = self.spans[splitpoint].iv.start();\n            let mut new = self.spans.split_off(splitpoint);\n            for span in &mut new {\n                span.iv = span.iv.translate_neg(splitpoint_units);\n            }\n            let new_len = self.len - splitpoint_units;\n            self.len = splitpoint_units;\n            Some(SpansLeaf { len: new_len, spans: new })\n        }\n    }\n}"],"std::ops::RangeFrom":["impl IntervalBounds for RangeFrom<usize> {\n    fn into_interval(self, upper_bound: usize) -> Interval {\n        Interval::new(self.start, upper_bound)\n    }\n}"],"std::ops::RangeFull":["impl IntervalBounds for RangeFull {\n    fn into_interval(self, upper_bound: usize) -> Interval {\n        Interval::new(0, upper_bound)\n    }\n}"],"std::string::String":["impl From<Rope> for String {\n    // maybe explore grabbing leaf? would require api in tree\n    fn from(r: Rope) -> String {\n        String::from(&r)\n    }\n}","impl Leaf for String {\n    fn len(&self) -> usize {\n        self.len()\n    }\n\n    fn is_ok_child(&self) -> bool {\n        self.len() >= MIN_LEAF\n    }\n\n    fn push_maybe_split(&mut self, other: &String, iv: Interval) -> Option<String> {\n        //println!(\"push_maybe_split [{}] [{}] {:?}\", self, other, iv);\n        let (start, end) = iv.start_end();\n        self.push_str(&other[start..end]);\n        if self.len() <= MAX_LEAF {\n            None\n        } else {\n            let splitpoint = find_leaf_split_for_merge(self);\n            let right_str = self[splitpoint..].to_owned();\n            self.truncate(splitpoint);\n            self.shrink_to_fit();\n            Some(right_str)\n        }\n    }\n}","impl<'a> From<&'a Rope> for String {\n    fn from(r: &Rope) -> String {\n        r.slice_to_cow(..).into_owned()\n    }\n}"],"tree::Cursor":["impl<'a, N: NodeInfo> Cursor<'a, N> {\n    /// Create a new cursor at the given position.\n    pub fn new(n: &'a Node<N>, position: usize) -> Cursor<'a, N> {\n        let mut result = Cursor {\n            root: n,\n            position,\n            cache: [None; CURSOR_CACHE_SIZE],\n            leaf: None,\n            offset_of_leaf: 0,\n        };\n        result.descend();\n        result\n    }\n\n    /// The length of the tree.\n    pub fn total_len(&self) -> usize {\n        self.root.len()\n    }\n\n    /// Return a reference to the root node of the tree.\n    pub fn root(&self) -> &'a Node<N> {\n        self.root\n    }\n\n    /// Get the current leaf of the cursor.\n    ///\n    /// If the cursor is valid, returns the leaf containing the current position,\n    /// and the offset of the current position within the leaf. That offset is equal\n    /// to the leaf length only at the end, otherwise it is less than the leaf length.\n    pub fn get_leaf(&self) -> Option<(&'a N::L, usize)> {\n        self.leaf.map(|l| (l, self.position - self.offset_of_leaf))\n    }\n\n    /// Set the position of the cursor.\n    ///\n    /// The cursor is valid after this call.\n    ///\n    /// Precondition: `position` is less than or equal to the length of the tree.\n    pub fn set(&mut self, position: usize) {\n        self.position = position;\n        if let Some(l) = self.leaf {\n            if self.position >= self.offset_of_leaf && self.position < self.offset_of_leaf + l.len()\n            {\n                return;\n            }\n        }\n        // TODO: walk up tree to find leaf if nearby\n        self.descend();\n    }\n\n    /// Get the position of the cursor.\n    pub fn pos(&self) -> usize {\n        self.position\n    }\n\n    /// Determine whether the current position is a boundary.\n    ///\n    /// Note: the beginning and end of the tree may or may not be boundaries, depending on the\n    /// metric. If the metric is not `can_fragment`, then they always are.\n    pub fn is_boundary<M: Metric<N>>(&mut self) -> bool {\n        if self.leaf.is_none() {\n            // not at a valid position\n            return false;\n        }\n        if self.position == self.offset_of_leaf && !M::can_fragment() {\n            return true;\n        }\n        if self.position == 0 || self.position > self.offset_of_leaf {\n            return M::is_boundary(self.leaf.unwrap(), self.position - self.offset_of_leaf);\n        }\n        // tricky case, at beginning of leaf, need to query end of previous\n        // leaf; TODO: would be nice if we could do it another way that didn't\n        // make the method &mut self.\n        let l = self.prev_leaf().unwrap().0;\n        let result = M::is_boundary(l, l.len());\n        let _ = self.next_leaf();\n        result\n    }\n\n    /// Moves the cursor to the previous boundary.\n    ///\n    /// When there is no previous boundary, returns `None` and the cursor becomes invalid.\n    ///\n    /// Return value: the position of the boundary, if it exists.\n    pub fn prev<M: Metric<N>>(&mut self) -> Option<usize> {\n        if self.position == 0 || self.leaf.is_none() {\n            self.leaf = None;\n            return None;\n        }\n        let orig_pos = self.position;\n        let offset_in_leaf = orig_pos - self.offset_of_leaf;\n        if offset_in_leaf > 0 {\n            let l = self.leaf.unwrap();\n            if let Some(offset_in_leaf) = M::prev(l, offset_in_leaf) {\n                self.position = self.offset_of_leaf + offset_in_leaf;\n                return Some(self.position);\n            }\n        }\n\n        // not in same leaf, need to scan backwards\n        self.prev_leaf()?;\n        if let Some(offset) = self.last_inside_leaf::<M>(orig_pos) {\n            return Some(offset);\n        }\n\n        // Not found in previous leaf, find using measurement.\n        let measure = self.measure_leaf::<M>(self.position);\n        if measure == 0 {\n            self.leaf = None;\n            self.position = 0;\n            return None;\n        }\n        self.descend_metric::<M>(measure);\n        self.last_inside_leaf::<M>(orig_pos)\n    }\n\n    /// Moves the cursor to the next boundary.\n    ///\n    /// When there is no next boundary, returns `None` and the cursor becomes invalid.\n    ///\n    /// Return value: the position of the boundary, if it exists.\n    pub fn next<M: Metric<N>>(&mut self) -> Option<usize> {\n        if self.position >= self.root.len() || self.leaf.is_none() {\n            self.leaf = None;\n            return None;\n        }\n\n        if let Some(offset) = self.next_inside_leaf::<M>() {\n            return Some(offset);\n        }\n\n        self.next_leaf()?;\n        if let Some(offset) = self.next_inside_leaf::<M>() {\n            return Some(offset);\n        }\n\n        // Leaf is 0-measure (otherwise would have already succeeded).\n        let measure = self.measure_leaf::<M>(self.position);\n        self.descend_metric::<M>(measure + 1);\n        if let Some(offset) = self.next_inside_leaf::<M>() {\n            return Some(offset);\n        }\n\n        // Not found, properly invalidate cursor.\n        self.position = self.root.len();\n        self.leaf = None;\n        None\n    }\n\n    /// Returns the current position if it is a boundary in this [`Metric`],\n    /// else behaves like [`next`](#method.next).\n    ///\n    /// [`Metric`]: struct.Metric.html\n    pub fn at_or_next<M: Metric<N>>(&mut self) -> Option<usize> {\n        if self.is_boundary::<M>() {\n            Some(self.pos())\n        } else {\n            self.next::<M>()\n        }\n    }\n\n    /// Returns the current position if it is a boundary in this [`Metric`],\n    /// else behaves like [`prev`](#method.prev).\n    ///\n    /// [`Metric`]: struct.Metric.html\n    pub fn at_or_prev<M: Metric<N>>(&mut self) -> Option<usize> {\n        if self.is_boundary::<M>() {\n            Some(self.pos())\n        } else {\n            self.prev::<M>()\n        }\n    }\n\n    /// Returns an iterator with this cursor over the given [`Metric`].\n    ///\n    /// # Examples:\n    ///\n    /// ```\n    /// # use xi_rope::{Cursor, LinesMetric, Rope};\n    /// #\n    /// let text: Rope = \"one line\\ntwo line\\nred line\\nblue\".into();\n    /// let mut cursor = Cursor::new(&text, 0);\n    /// let line_offsets = cursor.iter::<LinesMetric>().collect::<Vec<_>>();\n    /// assert_eq!(line_offsets, vec![9, 18, 27]);\n    ///\n    /// ```\n    /// [`Metric`]: struct.Metric.html\n    pub fn iter<'c, M: Metric<N>>(&'c mut self) -> CursorIter<'c, 'a, N, M> {\n        CursorIter { cursor: self, _metric: PhantomData }\n    }\n\n    /// Tries to find the last boundary in the leaf the cursor is currently in.\n    ///\n    /// If the last boundary is at the end of the leaf, it is only counted if\n    /// it is less than `orig_pos`.\n    #[inline]\n    fn last_inside_leaf<M: Metric<N>>(&mut self, orig_pos: usize) -> Option<usize> {\n        let l = self.leaf.expect(\"inconsistent, shouldn't get here\");\n        let len = l.len();\n        if self.offset_of_leaf + len < orig_pos && M::is_boundary(l, len) {\n            let _ = self.next_leaf();\n            return Some(self.position);\n        }\n        let offset_in_leaf = M::prev(l, len)?;\n        self.position = self.offset_of_leaf + offset_in_leaf;\n        Some(self.position)\n    }\n\n    /// Tries to find the next boundary in the leaf the cursor is currently in.\n    #[inline]\n    fn next_inside_leaf<M: Metric<N>>(&mut self) -> Option<usize> {\n        let l = self.leaf.expect(\"inconsistent, shouldn't get here\");\n        let offset_in_leaf = self.position - self.offset_of_leaf;\n        let offset_in_leaf = M::next(l, offset_in_leaf)?;\n        if offset_in_leaf == l.len() && self.offset_of_leaf + offset_in_leaf != self.root.len() {\n            let _ = self.next_leaf();\n        } else {\n            self.position = self.offset_of_leaf + offset_in_leaf;\n        }\n        Some(self.position)\n    }\n\n    /// Move to beginning of next leaf.\n    ///\n    /// Return value: same as [`get_leaf`](#method.get_leaf).\n    pub fn next_leaf(&mut self) -> Option<(&'a N::L, usize)> {\n        let leaf = self.leaf?;\n        self.position = self.offset_of_leaf + leaf.len();\n        for i in 0..CURSOR_CACHE_SIZE {\n            if self.cache[i].is_none() {\n                // this probably can't happen\n                self.leaf = None;\n                return None;\n            }\n            let (node, j) = self.cache[i].unwrap();\n            if j + 1 < node.get_children().len() {\n                self.cache[i] = Some((node, j + 1));\n                let mut node_down = &node.get_children()[j + 1];\n                for k in (0..i).rev() {\n                    self.cache[k] = Some((node_down, 0));\n                    node_down = &node_down.get_children()[0];\n                }\n                self.leaf = Some(node_down.get_leaf());\n                self.offset_of_leaf = self.position;\n                return self.get_leaf();\n            }\n        }\n        if self.offset_of_leaf + self.leaf.unwrap().len() == self.root.len() {\n            self.leaf = None;\n            return None;\n        }\n        self.descend();\n        self.get_leaf()\n    }\n\n    /// Move to beginning of previous leaf.\n    ///\n    /// Return value: same as [`get_leaf`](#method.get_leaf).\n    pub fn prev_leaf(&mut self) -> Option<(&'a N::L, usize)> {\n        if self.offset_of_leaf == 0 {\n            self.leaf = None;\n            self.position = 0;\n            return None;\n        }\n        for i in 0..CURSOR_CACHE_SIZE {\n            if self.cache[i].is_none() {\n                // this probably can't happen\n                self.leaf = None;\n                return None;\n            }\n            let (node, j) = self.cache[i].unwrap();\n            if j > 0 {\n                self.cache[i] = Some((node, j - 1));\n                let mut node_down = &node.get_children()[j - 1];\n                for k in (0..i).rev() {\n                    let last_ix = node_down.get_children().len() - 1;\n                    self.cache[k] = Some((node_down, last_ix));\n                    node_down = &node_down.get_children()[last_ix];\n                }\n                let leaf = node_down.get_leaf();\n                self.leaf = Some(leaf);\n                self.offset_of_leaf -= leaf.len();\n                self.position = self.offset_of_leaf;\n                return self.get_leaf();\n            }\n        }\n        self.position = self.offset_of_leaf - 1;\n        self.descend();\n        self.position = self.offset_of_leaf;\n        self.get_leaf()\n    }\n\n    /// Go to the leaf containing the current position.\n    ///\n    /// Sets `leaf` to the leaf containing `position`, and updates `cache` and\n    /// `offset_of_leaf` to be consistent.\n    fn descend(&mut self) {\n        let mut node = self.root;\n        let mut offset = 0;\n        while node.height() > 0 {\n            let children = node.get_children();\n            let mut i = 0;\n            loop {\n                if i + 1 == children.len() {\n                    break;\n                }\n                let nextoff = offset + children[i].len();\n                if nextoff > self.position {\n                    break;\n                }\n                offset = nextoff;\n                i += 1;\n            }\n            let cache_ix = node.height() - 1;\n            if cache_ix < CURSOR_CACHE_SIZE {\n                self.cache[cache_ix] = Some((node, i));\n            }\n            node = &children[i];\n        }\n        self.leaf = Some(node.get_leaf());\n        self.offset_of_leaf = offset;\n    }\n\n    /// Returns the measure at the beginning of the leaf containing `pos`.\n    ///\n    /// This method is O(log n) no matter the current cursor state.\n    fn measure_leaf<M: Metric<N>>(&self, mut pos: usize) -> usize {\n        let mut node = self.root;\n        let mut metric = 0;\n        while node.height() > 0 {\n            for child in node.get_children() {\n                let len = child.len();\n                if pos < len {\n                    node = child;\n                    break;\n                }\n                pos -= len;\n                metric += child.measure::<M>();\n            }\n        }\n        metric\n    }\n\n    /// Find the leaf having the given measure.\n    ///\n    /// This function sets `self.position` to the beginning of the leaf\n    /// containing the smallest offset with the given metric, and also updates\n    /// state as if [`descend`](#method.descend) was called.\n    ///\n    /// If `measure` is greater than the measure of the whole tree, then moves\n    /// to the last node.\n    fn descend_metric<M: Metric<N>>(&mut self, mut measure: usize) {\n        let mut node = self.root;\n        let mut offset = 0;\n        while node.height() > 0 {\n            let children = node.get_children();\n            let mut i = 0;\n            loop {\n                if i + 1 == children.len() {\n                    break;\n                }\n                let child = &children[i];\n                let child_m = child.measure::<M>();\n                if child_m >= measure {\n                    break;\n                }\n                offset += child.len();\n                measure -= child_m;\n                i += 1;\n            }\n            let cache_ix = node.height() - 1;\n            if cache_ix < CURSOR_CACHE_SIZE {\n                self.cache[cache_ix] = Some((node, i));\n            }\n            node = &children[i];\n        }\n        self.leaf = Some(node.get_leaf());\n        self.position = offset;\n        self.offset_of_leaf = offset;\n    }\n}","impl<'a> Cursor<'a, RopeInfo> {\n    /// Get previous codepoint before cursor position, and advance cursor backwards.\n    pub fn prev_codepoint(&mut self) -> Option<char> {\n        self.prev::<BaseMetric>();\n        if let Some((l, offset)) = self.get_leaf() {\n            l[offset..].chars().next()\n        } else {\n            None\n        }\n    }\n\n    /// Get next codepoint after cursor position, and advance cursor.\n    pub fn next_codepoint(&mut self) -> Option<char> {\n        if let Some((l, offset)) = self.get_leaf() {\n            self.next::<BaseMetric>();\n            l[offset..].chars().next()\n        } else {\n            None\n        }\n    }\n\n    /// Get the next codepoint after the cursor position, without advancing\n    /// the cursor.\n    pub fn peek_next_codepoint(&self) -> Option<char> {\n        self.get_leaf().and_then(|(l, off)| l[off..].chars().next())\n    }\n\n    pub fn next_grapheme(&mut self) -> Option<usize> {\n        let (mut l, mut offset) = self.get_leaf()?;\n        let mut pos = self.pos();\n        while offset < l.len() && !l.is_char_boundary(offset) {\n            pos -= 1;\n            offset -= 1;\n        }\n        let mut leaf_offset = pos - offset;\n        let mut c = GraphemeCursor::new(pos, self.total_len(), true);\n        let mut next_boundary = c.next_boundary(&l, leaf_offset);\n        while let Err(incomp) = next_boundary {\n            if let GraphemeIncomplete::PreContext(_) = incomp {\n                let (pl, poffset) = self.prev_leaf()?;\n                c.provide_context(&pl, self.pos() - poffset);\n            } else if incomp == GraphemeIncomplete::NextChunk {\n                self.set(pos);\n                let (nl, noffset) = self.next_leaf()?;\n                l = nl;\n                leaf_offset = self.pos() - noffset;\n                pos = leaf_offset + nl.len();\n            } else {\n                return None;\n            }\n            next_boundary = c.next_boundary(&l, leaf_offset);\n        }\n        next_boundary.unwrap_or(None)\n    }\n\n    pub fn prev_grapheme(&mut self) -> Option<usize> {\n        let (mut l, mut offset) = self.get_leaf()?;\n        let mut pos = self.pos();\n        while offset < l.len() && !l.is_char_boundary(offset) {\n            pos += 1;\n            offset += 1;\n        }\n        let mut leaf_offset = pos - offset;\n        let mut c = GraphemeCursor::new(pos, l.len() + leaf_offset, true);\n        let mut prev_boundary = c.prev_boundary(&l, leaf_offset);\n        while let Err(incomp) = prev_boundary {\n            if let GraphemeIncomplete::PreContext(_) = incomp {\n                let (pl, poffset) = self.prev_leaf()?;\n                c.provide_context(&pl, self.pos() - poffset);\n            } else if incomp == GraphemeIncomplete::PrevChunk {\n                self.set(pos);\n                let (pl, poffset) = self.prev_leaf()?;\n                l = pl;\n                leaf_offset = self.pos() - poffset;\n                pos = leaf_offset + pl.len();\n            } else {\n                return None;\n            }\n            prev_boundary = c.prev_boundary(&l, leaf_offset);\n        }\n        prev_boundary.unwrap_or(None)\n    }\n}"],"tree::CursorIter":["impl<'c, 'a, N: NodeInfo, M: Metric<N>> CursorIter<'c, 'a, N, M> {\n    /// Returns the current position of the underlying [`Cursor`].\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    pub fn pos(&self) -> usize {\n        self.cursor.pos()\n    }\n}","impl<'c, 'a, N: NodeInfo, M: Metric<N>> Iterator for CursorIter<'c, 'a, N, M> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        self.cursor.next::<M>()\n    }\n}"],"tree::Node":["Clone","impl<N: DefaultMetric> Node<N> {\n    /// Measures the length of the text bounded by ``DefaultMetric::measure(offset)`` with another metric.\n    ///\n    /// # Examples\n    /// ```\n    /// use crate::xi_rope::{Rope, LinesMetric};\n    ///\n    /// // the default metric of Rope is BaseMetric (aka number of bytes)\n    /// let my_rope = Rope::from(\"first line \\n second line \\n\");\n    ///\n    /// // count the number of lines in my_rope\n    /// let num_lines = my_rope.count::<LinesMetric>(my_rope.len());\n    /// assert_eq!(2, num_lines);\n    /// ```\n    pub fn count<M: Metric<N>>(&self, offset: usize) -> usize {\n        self.convert_metrics::<N::DefaultMetric, M>(offset)\n    }\n\n    /// Measures the length of the text bounded by ``M::measure(offset)`` with the default metric.\n    ///\n    /// # Examples\n    /// ```\n    /// use crate::xi_rope::{Rope, LinesMetric};\n    ///\n    /// // the default metric of Rope is BaseMetric (aka number of bytes)\n    /// let my_rope = Rope::from(\"first line \\n second line \\n\");\n    ///\n    /// // get the byte offset of the line at index 1\n    /// let byte_offset = my_rope.count_base_units::<LinesMetric>(1);\n    /// assert_eq!(12, byte_offset);\n    /// ```\n    pub fn count_base_units<M: Metric<N>>(&self, offset: usize) -> usize {\n        self.convert_metrics::<M, N::DefaultMetric>(offset)\n    }\n}","impl<N: NodeInfo> Default for Node<N> {\n    fn default() -> Node<N> {\n        Node::from_leaf(N::L::default())\n    }\n}","impl<N: NodeInfo> Node<N> {\n    pub fn from_leaf(l: N::L) -> Node<N> {\n        let len = l.len();\n        let info = N::compute_info(&l);\n        Node(Arc::new(NodeBody { height: 0, len, info, val: NodeVal::Leaf(l) }))\n    }\n\n    /// Create a node from a vec of nodes.\n    ///\n    /// The input must satisfy the following balancing requirements:\n    /// * The length of `nodes` must be <= MAX_CHILDREN and > 1.\n    /// * All the nodes are the same height.\n    /// * All the nodes must satisfy is_ok_child.\n    fn from_nodes(nodes: Vec<Node<N>>) -> Node<N> {\n        debug_assert!(nodes.len() > 1);\n        debug_assert!(nodes.len() <= MAX_CHILDREN);\n        let height = nodes[0].0.height + 1;\n        let mut len = nodes[0].0.len;\n        let mut info = nodes[0].0.info.clone();\n        debug_assert!(nodes[0].is_ok_child());\n        for child in &nodes[1..] {\n            debug_assert_eq!(child.height() + 1, height);\n            debug_assert!(child.is_ok_child());\n            len += child.0.len;\n            info.accumulate(&child.0.info);\n        }\n        Node(Arc::new(NodeBody { height, len, info, val: NodeVal::Internal(nodes) }))\n    }\n\n    pub fn len(&self) -> usize {\n        self.0.len\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns `true` if these two `Node`s share the same underlying data.\n    ///\n    /// This is principally intended to be used by the druid crate, without needing\n    /// to actually add a feature and implement druid's `Data` trait.\n    pub fn ptr_eq(&self, other: &Self) -> bool {\n        Arc::ptr_eq(&self.0, &other.0)\n    }\n\n    fn height(&self) -> usize {\n        self.0.height\n    }\n\n    fn is_leaf(&self) -> bool {\n        self.0.height == 0\n    }\n\n    fn interval(&self) -> Interval {\n        self.0.info.interval(self.0.len)\n    }\n\n    fn get_children(&self) -> &[Node<N>] {\n        if let NodeVal::Internal(ref v) = self.0.val {\n            v\n        } else {\n            panic!(\"get_children called on leaf node\");\n        }\n    }\n\n    fn get_leaf(&self) -> &N::L {\n        if let NodeVal::Leaf(ref l) = self.0.val {\n            l\n        } else {\n            panic!(\"get_leaf called on internal node\");\n        }\n    }\n\n    /// Call a callback with a mutable reference to a leaf.\n    ///\n    /// This clones the leaf if the reference is shared. It also recomputes\n    /// length and info after the leaf is mutated.\n    fn with_leaf_mut<T>(&mut self, f: impl FnOnce(&mut N::L) -> T) -> T {\n        let inner = Arc::make_mut(&mut self.0);\n        if let NodeVal::Leaf(ref mut l) = inner.val {\n            let result = f(l);\n            inner.len = l.len();\n            inner.info = N::compute_info(l);\n            result\n        } else {\n            panic!(\"with_leaf_mut called on internal node\");\n        }\n    }\n\n    fn is_ok_child(&self) -> bool {\n        match self.0.val {\n            NodeVal::Leaf(ref l) => l.is_ok_child(),\n            NodeVal::Internal(ref nodes) => (nodes.len() >= MIN_CHILDREN),\n        }\n    }\n\n    fn merge_nodes(children1: &[Node<N>], children2: &[Node<N>]) -> Node<N> {\n        let n_children = children1.len() + children2.len();\n        if n_children <= MAX_CHILDREN {\n            Node::from_nodes([children1, children2].concat())\n        } else {\n            // Note: this leans left. Splitting at midpoint is also an option\n            let splitpoint = min(MAX_CHILDREN, n_children - MIN_CHILDREN);\n            let mut iter = children1.iter().chain(children2.iter()).cloned();\n            let left = iter.by_ref().take(splitpoint).collect();\n            let right = iter.collect();\n            let parent_nodes = vec![Node::from_nodes(left), Node::from_nodes(right)];\n            Node::from_nodes(parent_nodes)\n        }\n    }\n\n    fn merge_leaves(mut rope1: Node<N>, rope2: Node<N>) -> Node<N> {\n        debug_assert!(rope1.is_leaf() && rope2.is_leaf());\n\n        let both_ok = rope1.get_leaf().is_ok_child() && rope2.get_leaf().is_ok_child();\n        if both_ok {\n            return Node::from_nodes(vec![rope1, rope2]);\n        }\n        match {\n            let node1 = Arc::make_mut(&mut rope1.0);\n            let leaf2 = rope2.get_leaf();\n            if let NodeVal::Leaf(ref mut leaf1) = node1.val {\n                let leaf2_iv = Interval::new(0, leaf2.len());\n                let new = leaf1.push_maybe_split(leaf2, leaf2_iv);\n                node1.len = leaf1.len();\n                node1.info = N::compute_info(leaf1);\n                new\n            } else {\n                panic!(\"merge_leaves called on non-leaf\");\n            }\n        } {\n            Some(new) => Node::from_nodes(vec![rope1, Node::from_leaf(new)]),\n            None => rope1,\n        }\n    }\n\n    pub fn concat(rope1: Node<N>, rope2: Node<N>) -> Node<N> {\n        let h1 = rope1.height();\n        let h2 = rope2.height();\n\n        match h1.cmp(&h2) {\n            Ordering::Less => {\n                let children2 = rope2.get_children();\n                if h1 == h2 - 1 && rope1.is_ok_child() {\n                    return Node::merge_nodes(&[rope1], children2);\n                }\n                let newrope = Node::concat(rope1, children2[0].clone());\n                if newrope.height() == h2 - 1 {\n                    Node::merge_nodes(&[newrope], &children2[1..])\n                } else {\n                    Node::merge_nodes(newrope.get_children(), &children2[1..])\n                }\n            }\n            Ordering::Equal => {\n                if rope1.is_ok_child() && rope2.is_ok_child() {\n                    return Node::from_nodes(vec![rope1, rope2]);\n                }\n                if h1 == 0 {\n                    return Node::merge_leaves(rope1, rope2);\n                }\n                Node::merge_nodes(rope1.get_children(), rope2.get_children())\n            }\n            Ordering::Greater => {\n                let children1 = rope1.get_children();\n                if h2 == h1 - 1 && rope2.is_ok_child() {\n                    return Node::merge_nodes(children1, &[rope2]);\n                }\n                let lastix = children1.len() - 1;\n                let newrope = Node::concat(children1[lastix].clone(), rope2);\n                if newrope.height() == h1 - 1 {\n                    Node::merge_nodes(&children1[..lastix], &[newrope])\n                } else {\n                    Node::merge_nodes(&children1[..lastix], newrope.get_children())\n                }\n            }\n        }\n    }\n\n    pub fn measure<M: Metric<N>>(&self) -> usize {\n        M::measure(&self.0.info, self.0.len)\n    }\n\n    pub(crate) fn push_subseq(&self, b: &mut TreeBuilder<N>, iv: Interval) {\n        if iv.is_empty() {\n            return;\n        }\n        if iv == self.interval() {\n            b.push(self.clone());\n            return;\n        }\n        match self.0.val {\n            NodeVal::Leaf(ref l) => {\n                b.push_leaf_slice(l, iv);\n            }\n            NodeVal::Internal(ref v) => {\n                let mut offset = 0;\n                for child in v {\n                    if iv.is_before(offset) {\n                        break;\n                    }\n                    let child_iv = child.interval();\n                    // easier just to use signed ints?\n                    let rec_iv = iv.intersect(child_iv.translate(offset)).translate_neg(offset);\n                    child.push_subseq(b, rec_iv);\n                    offset += child.len();\n                }\n            }\n        }\n    }\n\n    pub fn subseq<T: IntervalBounds>(&self, iv: T) -> Node<N> {\n        let iv = iv.into_interval(self.len());\n        let mut b = TreeBuilder::new();\n        self.push_subseq(&mut b, iv);\n        b.build()\n    }\n\n    pub fn edit<T, IV>(&mut self, iv: IV, new: T)\n    where\n        T: Into<Node<N>>,\n        IV: IntervalBounds,\n    {\n        let mut b = TreeBuilder::new();\n        let iv = iv.into_interval(self.len());\n        let self_iv = self.interval();\n        self.push_subseq(&mut b, self_iv.prefix(iv));\n        b.push(new.into());\n        self.push_subseq(&mut b, self_iv.suffix(iv));\n        *self = b.build();\n    }\n\n    // doesn't deal with endpoint, handle that specially if you need it\n    pub fn convert_metrics<M1: Metric<N>, M2: Metric<N>>(&self, mut m1: usize) -> usize {\n        if m1 == 0 {\n            return 0;\n        }\n        // If M1 can fragment, then we must land on the leaf containing\n        // the m1 boundary. Otherwise, we can land on the beginning of\n        // the leaf immediately following the M1 boundary, which may be\n        // more efficient.\n        let m1_fudge = if M1::can_fragment() { 1 } else { 0 };\n        let mut m2 = 0;\n        let mut node = self;\n        while node.height() > 0 {\n            for child in node.get_children() {\n                let child_m1 = child.measure::<M1>();\n                if m1 < child_m1 + m1_fudge {\n                    node = child;\n                    break;\n                }\n                m2 += child.measure::<M2>();\n                m1 -= child_m1;\n            }\n        }\n        let l = node.get_leaf();\n        let base = M1::to_base_units(l, m1);\n        m2 + M2::from_base_units(l, base)\n    }\n}"],"tree::NodeBody":["Clone"],"tree::NodeVal":["Clone"],"tree::TreeBuilder":["impl TreeBuilder<RopeInfo> {\n    /// Push a string on the accumulating tree in the naive way.\n    ///\n    /// Splits the provided string in chunks that fit in a leaf\n    /// and pushes the leaves one by one onto the tree by calling\n    /// `push_leaf` on the builder.\n    pub fn push_str(&mut self, mut s: &str) {\n        if s.len() <= MAX_LEAF {\n            if !s.is_empty() {\n                self.push_leaf(s.to_owned());\n            }\n            return;\n        }\n        while !s.is_empty() {\n            let splitpoint = if s.len() > MAX_LEAF { find_leaf_split_for_bulk(s) } else { s.len() };\n            self.push_leaf(s[..splitpoint].to_owned());\n            s = &s[splitpoint..];\n        }\n    }\n}","impl<N: NodeInfo> TreeBuilder<N> {\n    /// A new, empty builder.\n    pub fn new() -> TreeBuilder<N> {\n        TreeBuilder { stack: Vec::new() }\n    }\n\n    /// Append a node to the tree being built.\n    pub fn push(&mut self, mut n: Node<N>) {\n        loop {\n            let ord = if let Some(last) = self.stack.last() {\n                last[0].height().cmp(&n.height())\n            } else {\n                Ordering::Greater\n            };\n            match ord {\n                Ordering::Less => {\n                    n = Node::concat(self.pop(), n);\n                }\n                Ordering::Equal => {\n                    let tos = self.stack.last_mut().unwrap();\n                    if tos.last().unwrap().is_ok_child() && n.is_ok_child() {\n                        tos.push(n);\n                    } else if n.height() == 0 {\n                        let iv = Interval::new(0, n.len());\n                        let new_leaf = tos\n                            .last_mut()\n                            .unwrap()\n                            .with_leaf_mut(|l| l.push_maybe_split(n.get_leaf(), iv));\n                        if let Some(new_leaf) = new_leaf {\n                            tos.push(Node::from_leaf(new_leaf));\n                        }\n                    } else {\n                        let last = tos.pop().unwrap();\n                        let children1 = last.get_children();\n                        let children2 = n.get_children();\n                        let n_children = children1.len() + children2.len();\n                        if n_children <= MAX_CHILDREN {\n                            tos.push(Node::from_nodes([children1, children2].concat()));\n                        } else {\n                            // Note: this leans left. Splitting at midpoint is also an option\n                            let splitpoint = min(MAX_CHILDREN, n_children - MIN_CHILDREN);\n                            let mut iter = children1.iter().chain(children2.iter()).cloned();\n                            let left = iter.by_ref().take(splitpoint).collect();\n                            let right = iter.collect();\n                            tos.push(Node::from_nodes(left));\n                            tos.push(Node::from_nodes(right));\n                        }\n                    }\n                    if tos.len() < MAX_CHILDREN {\n                        break;\n                    }\n                    n = self.pop()\n                }\n                Ordering::Greater => {\n                    self.stack.push(vec![n]);\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Append a sequence of leaves.\n    pub fn push_leaves(&mut self, leaves: impl IntoIterator<Item = N::L>) {\n        for leaf in leaves.into_iter() {\n            self.push(Node::from_leaf(leaf));\n        }\n    }\n\n    /// Append a single leaf.\n    pub fn push_leaf(&mut self, l: N::L) {\n        self.push(Node::from_leaf(l))\n    }\n\n    /// Append a slice of a single leaf.\n    pub fn push_leaf_slice(&mut self, l: &N::L, iv: Interval) {\n        self.push(Node::from_leaf(l.subseq(iv)))\n    }\n\n    /// Build the final tree.\n    ///\n    /// The tree is the concatenation of all the nodes and leaves that have been pushed\n    /// on the builder, in order.\n    pub fn build(mut self) -> Node<N> {\n        if self.stack.is_empty() {\n            Node::from_leaf(N::L::default())\n        } else {\n            let mut n = self.pop();\n            while !self.stack.is_empty() {\n                n = Node::concat(self.pop(), n);\n            }\n            n\n        }\n    }\n\n    /// Pop the last vec-of-nodes off the stack, resulting in a node.\n    fn pop(&mut self) -> Node<N> {\n        let nodes = self.stack.pop().unwrap();\n        if nodes.len() == 1 {\n            nodes.into_iter().next().unwrap()\n        } else {\n            Node::from_nodes(nodes)\n        }\n    }\n}"]},"single_path_import":{"delta::Builder":"Builder","delta::Delta":"Delta","delta::DeltaElement":"DeltaElement","delta::Transformer":"Transformer","interval::Interval":"Interval","rope::LinesMetric":"LinesMetric","rope::Rope":"Rope","rope::RopeDelta":"RopeDelta","rope::RopeInfo":"RopeInfo","tree::Cursor":"Cursor","tree::Metric":"Metric"},"srcs":{"<T as interval::IntervalBounds>::into_interval":["fn into_interval(self, _upper_bound: usize) -> Interval{\n        self.into()\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"<breaks::BreakBuilder as std::default::Default>::default":["fn default() -> BreakBuilder{\n        BreakBuilder { b: TreeBuilder::new(), leaf: BreaksLeaf::default() }\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment":["fn can_fragment() -> bool{\n        true\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units":["fn from_base_units(_: &BreaksLeaf, in_base_units: usize) -> usize{\n        in_base_units\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary":["fn is_boundary(l: &BreaksLeaf, offset: usize) -> bool{\n        BreaksMetric::is_boundary(l, offset)\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::measure":["fn measure(_: &BreaksInfo, len: usize) -> usize{\n        len\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::next":["fn next(l: &BreaksLeaf, offset: usize) -> Option<usize>{\n        BreaksMetric::next(l, offset)\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::prev":["fn prev(l: &BreaksLeaf, offset: usize) -> Option<usize>{\n        BreaksMetric::prev(l, offset)\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units":["fn to_base_units(_: &BreaksLeaf, in_measured_units: usize) -> usize{\n        in_measured_units\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksInfo as tree::NodeInfo>::accumulate":["fn accumulate(&mut self, other: &Self){\n        self.0 += other.0;\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksInfo as tree::NodeInfo>::compute_info":["fn compute_info(l: &BreaksLeaf) -> BreaksInfo{\n        BreaksInfo(l.data.len())\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksLeaf as tree::Leaf>::is_ok_child":["fn is_ok_child(&self) -> bool{\n        self.data.len() >= MIN_LEAF\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksLeaf as tree::Leaf>::len":["fn len(&self) -> usize{\n        self.len\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksLeaf as tree::Leaf>::push_maybe_split":["fn push_maybe_split(&mut self, other: &BreaksLeaf, iv: Interval) -> Option<BreaksLeaf>{\n        //eprintln!(\"push_maybe_split {:?} {:?} {}\", self, other, iv);\n        let (start, end) = iv.start_end();\n        for &v in &other.data {\n            if start < v && v <= end {\n                self.data.push(v - start + self.len);\n            }\n        }\n        // the min with other.len() shouldn't be needed\n        self.len += min(end, other.len()) - start;\n\n        if self.data.len() <= MAX_LEAF {\n            None\n        } else {\n            let splitpoint = self.data.len() / 2; // number of breaks\n            let splitpoint_units = self.data[splitpoint - 1];\n\n            let mut new = self.data.split_off(splitpoint);\n            for x in &mut new {\n                *x -= splitpoint_units;\n            }\n\n            let new_len = self.len - splitpoint_units;\n            self.len = splitpoint_units;\n            Some(BreaksLeaf { len: new_len, data: new })\n        }\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment":["fn can_fragment() -> bool{\n        true\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units":["fn from_base_units(l: &BreaksLeaf, in_base_units: usize) -> usize{\n        match l.data.binary_search(&in_base_units) {\n            Ok(n) => n + 1,\n            Err(n) => n,\n        }\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary":["fn is_boundary(l: &BreaksLeaf, offset: usize) -> bool{\n        l.data.binary_search(&offset).is_ok()\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::measure":["fn measure(info: &BreaksInfo, _: usize) -> usize{\n        info.0\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::next":["fn next(l: &BreaksLeaf, offset: usize) -> Option<usize>{\n        let n = match l.data.binary_search(&offset) {\n            Ok(n) => n + 1,\n            Err(n) => n,\n        };\n\n        if n == l.data.len() {\n            None\n        } else {\n            Some(l.data[n])\n        }\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::prev":["fn prev(l: &BreaksLeaf, offset: usize) -> Option<usize>{\n        for i in 0..l.data.len() {\n            if offset <= l.data[i] {\n                if i == 0 {\n                    return None;\n                } else {\n                    return Some(l.data[i - 1]);\n                }\n            }\n        }\n        l.data.last().cloned()\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units":["fn to_base_units(l: &BreaksLeaf, in_measured_units: usize) -> usize{\n        if in_measured_units > l.data.len() {\n            l.len + 1\n        } else if in_measured_units == 0 {\n            0\n        } else {\n            l.data[in_measured_units - 1]\n        }\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let mut result = None;\n        while let Some(elem) = self.els_iter.next() {\n            match *elem {\n                DeltaElement::Copy(b, e) => {\n                    if b > self.last_end {\n                        result = Some(DeltaRegion::new(self.last_end, self.pos, b - self.last_end));\n                    }\n                    self.pos += e - b;\n                    self.last_end = e;\n                    if result.is_some() {\n                        break;\n                    }\n                }\n                DeltaElement::Insert(ref n) => {\n                    self.pos += n.len();\n                    self.last_end += n.len();\n                }\n            }\n        }\n        if result.is_none() && self.last_end < self.base_len {\n            result = Some(DeltaRegion::new(self.last_end, self.pos, self.base_len - self.last_end));\n            self.last_end = self.base_len;\n        }\n        result\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"<delta::Delta<N> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if f.alternate() {\n            for el in &self.els {\n                match *el {\n                    DeltaElement::Copy(beg, end) => {\n                        write!(f, \"{}\", \"-\".repeat(end - beg))?;\n                    }\n                    DeltaElement::Insert(ref node) => {\n                        node.fmt(f)?;\n                    }\n                }\n            }\n        } else {\n            write!(f, \"Delta(\")?;\n            for el in &self.els {\n                match *el {\n                    DeltaElement::Copy(beg, end) => {\n                        write!(f, \"[{},{}) \", beg, end)?;\n                    }\n                    DeltaElement::Insert(ref node) => {\n                        write!(f, \"<ins:{}> \", node.len())?;\n                    }\n                }\n            }\n            write!(f, \"base_len: {})\", self.base_len)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"<delta::InsertDelta<N> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.0.fmt(f)\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"<delta::InsertDelta<N> as std::ops::Deref>::deref":["fn deref(&self) -> &Delta<N>{\n        &self.0\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"<delta::InsertsIter<'a, N> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let mut result = None;\n        while let Some(elem) = self.els_iter.next() {\n            match *elem {\n                DeltaElement::Copy(b, e) => {\n                    self.pos += e - b;\n                    self.last_end = e;\n                }\n                DeltaElement::Insert(ref n) => {\n                    result = Some(DeltaRegion::new(self.last_end, self.pos, n.len()));\n                    self.pos += n.len();\n                    self.last_end += n.len();\n                    break;\n                }\n            }\n        }\n        result\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"<diff::LineHashDiff as diff::Diff<rope::RopeInfo>>::compute_delta":["fn compute_delta(base: &Rope, target: &Rope) -> RopeDelta{\n        let mut builder = DiffBuilder::default();\n\n        // before doing anything, scan top down and bottom up for like-ness.\n        let mut scanner = RopeScanner::new(base, target);\n        let (start_offset, diff_end) = scanner.find_min_diff_range();\n        let target_end = target.len() - diff_end;\n\n        if start_offset > 0 {\n            builder.copy(0, 0, start_offset);\n        }\n\n        // if our preliminary scan finds no differences we're done\n        if start_offset == base.len() && target.len() == base.len() {\n            return builder.to_delta(base, target);\n        }\n\n        // if a continuous range of text got deleted, we're done\n        if target.len() < base.len() && start_offset + diff_end == target.len() {\n            builder.copy(base.len() - diff_end, target_end, diff_end);\n            return builder.to_delta(base, target);\n        }\n\n        // if a continuous range of text got inserted, we're done\n        if target.len() > base.len() && start_offset + diff_end == base.len() {\n            builder.copy(base.len() - diff_end, target_end, diff_end);\n            return builder.to_delta(base, target);\n        }\n\n        let line_hashes = make_line_hashes(&base, MIN_SIZE);\n\n        let line_count = target.measure::<LinesMetric>() + 1;\n        let mut matches = Vec::with_capacity(line_count);\n\n        let mut targ_line_offset = 0;\n        let mut prev_base = 0;\n\n        let mut needs_subseq = false;\n        for line in target.lines_raw(start_offset..target_end) {\n            let non_ws = non_ws_offset(&line);\n            if line.len() - non_ws >= MIN_SIZE {\n                if let Some(base_off) = line_hashes.get(&line[non_ws..]) {\n                    let targ_off = targ_line_offset + non_ws;\n                    matches.push((start_offset + targ_off, *base_off));\n                    if *base_off < prev_base {\n                        needs_subseq = true;\n                    }\n                    prev_base = *base_off;\n                }\n            }\n            targ_line_offset += line.len();\n        }\n\n        // we now have an ordered list of matches and their positions.\n        // to ensure that our delta only copies non-decreasing base regions,\n        // we take the longest increasing subsequence.\n        // TODO: a possible optimization here would be to expand matches\n        // to adjacent lines first? this would be at best a small win though..\n\n        let longest_subseq =\n            if needs_subseq { longest_increasing_region_set(&matches) } else { matches };\n\n        // for each matching region, we extend it forwards and backwards.\n        // we keep track of how far forward we extend it each time, to avoid\n        // having a subsequent scan extend backwards over the same region.\n        let mut prev_end = start_offset;\n\n        for (targ_off, base_off) in longest_subseq {\n            if targ_off <= prev_end {\n                continue;\n            }\n            let (left_dist, mut right_dist) =\n                expand_match(base, target, base_off, targ_off, prev_end);\n\n            // don't let last match expand past target_end\n            right_dist = right_dist.min(target_end - targ_off);\n\n            let targ_start = targ_off - left_dist;\n            let base_start = base_off - left_dist;\n            let len = left_dist + right_dist;\n            prev_end = targ_start + len;\n\n            builder.copy(base_start, targ_start, len);\n        }\n\n        if diff_end > 0 {\n            builder.copy(base.len() - diff_end, target.len() - diff_end, diff_end);\n        }\n\n        builder.to_delta(base, target)\n    }","Real(LocalPath(\"rope/src/diff.rs\"))"],"<engine::Error as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        std::fmt::Display::fmt(self, f)\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"<engine::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        match self {\n            Error::MissingRevision(_) => write!(f, \"Revision not found\"),\n            Error::MalformedDelta { delta_len, rev_len } => {\n                write!(f, \"Delta base_len {} does not match revision length {}\", delta_len, rev_len)\n            }\n        }\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"<interval::Interval as std::convert::From<std::ops::Range<usize>>>::from":["fn from(src: Range<usize>) -> Interval{\n        let Range { start, end } = src;\n        Interval { start, end }\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"<interval::Interval as std::convert::From<std::ops::RangeInclusive<usize>>>::from":["fn from(src: RangeInclusive<usize>) -> Interval{\n        Interval::new(*src.start(), src.end().saturating_add(1))\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"<interval::Interval as std::convert::From<std::ops::RangeTo<usize>>>::from":["fn from(src: RangeTo<usize>) -> Interval{\n        Interval::new(0, src.end)\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"<interval::Interval as std::convert::From<std::ops::RangeToInclusive<usize>>>::from":["fn from(src: RangeToInclusive<usize>) -> Interval{\n        Interval::new(0, src.end.saturating_add(1))\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"<interval::Interval as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"<interval::Interval as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"[{}, {})\", self.start(), self.end())\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"<multiset::RangeIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(usize, usize)>{\n        while let Some(seg) = self.seg_iter.next() {\n            self.consumed += seg.len;\n            if self.matcher.matches(seg) {\n                return Some((self.consumed - seg.len, self.consumed));\n            }\n        }\n        None\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"<multiset::Subset as std::fmt::Debug>::fmt":["/// Use the alternate flag (`#`) to print a more compact representation\n/// where each character represents the count of one element:\n/// '-' is 0, '#' is 1, 2-9 are digits, `+` is >9\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if f.alternate() {\n            for s in &self.segments {\n                let chr = if s.count == 0 {\n                    '-'\n                } else if s.count == 1 {\n                    '#'\n                } else if s.count <= 9 {\n                    ((s.count as u8) + b'0') as char\n                } else {\n                    '+'\n                };\n                for _ in 0..s.len {\n                    write!(f, \"{}\", chr)?;\n                }\n            }\n            Ok(())\n        } else {\n            f.debug_tuple(\"Subset\").field(&self.segments).finish()\n        }\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"<multiset::ZipIter<'a> as std::iter::Iterator>::next":["/// Consume as far as possible from `self.consumed` until reaching a\n/// segment boundary in either `Subset`, and return the resulting\n/// `ZipSegment`. Will panic if it reaches the end of one `Subset` before\n/// the other, that is when they have different total length.\nfn next(&mut self) -> Option<ZipSegment>{\n        match (self.a_segs.get(self.a_i), self.b_segs.get(self.b_i)) {\n            (None, None) => None,\n            (None, Some(_)) | (Some(_), None) => {\n                panic!(\"can't zip Subsets of different base lengths.\")\n            }\n            (\n                Some(&Segment { len: a_len, count: a_count }),\n                Some(&Segment { len: b_len, count: b_count }),\n            ) => {\n                let len = match (a_len + self.a_consumed).cmp(&(b_len + self.b_consumed)) {\n                    cmp::Ordering::Equal => {\n                        self.a_consumed += a_len;\n                        self.a_i += 1;\n                        self.b_consumed += b_len;\n                        self.b_i += 1;\n                        self.a_consumed - self.consumed\n                    }\n                    cmp::Ordering::Less => {\n                        self.a_consumed += a_len;\n                        self.a_i += 1;\n                        self.a_consumed - self.consumed\n                    }\n                    cmp::Ordering::Greater => {\n                        self.b_consumed += b_len;\n                        self.b_i += 1;\n                        self.b_consumed - self.consumed\n                    }\n                };\n                self.consumed += len;\n                Some(ZipSegment { len, a_count, b_count })\n            }\n        }\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::can_fragment":["fn can_fragment() -> bool{\n        false\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::from_base_units":["fn from_base_units(s: &String, in_base_units: usize) -> usize{\n        debug_assert!(s.is_char_boundary(in_base_units));\n        in_base_units\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::is_boundary":["fn is_boundary(s: &String, offset: usize) -> bool{\n        s.is_char_boundary(offset)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::measure":["fn measure(_: &RopeInfo, len: usize) -> usize{\n        len\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::next":["fn next(s: &String, offset: usize) -> Option<usize>{\n        if offset == s.len() {\n            // I think it's a precondition that this will never be called\n            // with offset == s.len(), but be defensive.\n            None\n        } else {\n            let b = s.as_bytes()[offset];\n            Some(offset + len_utf8_from_first_byte(b))\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::prev":["fn prev(s: &String, offset: usize) -> Option<usize>{\n        if offset == 0 {\n            // I think it's a precondition that this will never be called\n            // with offset == 0, but be defensive.\n            None\n        } else {\n            let mut len = 1;\n            while !s.is_char_boundary(offset - len) {\n                len += 1;\n            }\n            Some(offset - len)\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::to_base_units":["fn to_base_units(s: &String, in_measured_units: usize) -> usize{\n        debug_assert!(s.is_char_boundary(in_measured_units));\n        in_measured_units\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::ChunkIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'a str>{\n        if self.cursor.pos() >= self.end {\n            return None;\n        }\n        let (leaf, start_pos) = self.cursor.get_leaf().unwrap();\n        let len = min(self.end - self.cursor.pos(), leaf.len() - start_pos);\n        self.cursor.next_leaf();\n        Some(&leaf[start_pos..start_pos + len])\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::Lines<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Cow<'a, str>>{\n        match self.inner.next() {\n            Some(Cow::Borrowed(mut s)) => {\n                if s.ends_with('\\n') {\n                    s = &s[..s.len() - 1];\n                    if s.ends_with('\\r') {\n                        s = &s[..s.len() - 1];\n                    }\n                }\n                Some(Cow::from(s))\n            }\n            Some(Cow::Owned(mut s)) => {\n                if s.ends_with('\\n') {\n                    let _ = s.pop();\n                    if s.ends_with('\\r') {\n                        let _ = s.pop();\n                    }\n                }\n                Some(Cow::from(s))\n            }\n            None => None,\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::can_fragment":["fn can_fragment() -> bool{\n        true\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::from_base_units":["fn from_base_units(s: &String, in_base_units: usize) -> usize{\n        count_newlines(&s[..in_base_units])\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::is_boundary":["fn is_boundary(s: &String, offset: usize) -> bool{\n        if offset == 0 {\n            // shouldn't be called with this, but be defensive\n            false\n        } else {\n            s.as_bytes()[offset - 1] == b'\\n'\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::measure":["fn measure(info: &RopeInfo, _: usize) -> usize{\n        info.lines\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::next":["fn next(s: &String, offset: usize) -> Option<usize>{\n        memchr(b'\\n', &s.as_bytes()[offset..]).map(|pos| offset + pos + 1)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::prev":["fn prev(s: &String, offset: usize) -> Option<usize>{\n        debug_assert!(offset > 0, \"caller is responsible for validating input\");\n        memrchr(b'\\n', &s.as_bytes()[..offset - 1]).map(|pos| pos + 1)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::to_base_units":["fn to_base_units(s: &String, in_measured_units: usize) -> usize{\n        let mut offset = 0;\n        for _ in 0..in_measured_units {\n            match memchr(b'\\n', &s.as_bytes()[offset..]) {\n                Some(pos) => offset += pos + 1,\n                _ => panic!(\"to_base_units called with arg too large\"),\n            }\n        }\n        offset\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::LinesRaw<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Cow<'a, str>>{\n        let mut result = Cow::from(\"\");\n        loop {\n            if self.fragment.is_empty() {\n                match self.inner.next() {\n                    Some(chunk) => self.fragment = chunk,\n                    None => return if result.is_empty() { None } else { Some(result) },\n                }\n                if self.fragment.is_empty() {\n                    // can only happen on empty input\n                    return None;\n                }\n            }\n            match memchr(b'\\n', self.fragment.as_bytes()) {\n                Some(i) => {\n                    result = cow_append(result, &self.fragment[..=i]);\n                    self.fragment = &self.fragment[i + 1..];\n                    return Some(result);\n                }\n                None => {\n                    result = cow_append(result, self.fragment);\n                    self.fragment = \"\";\n                }\n            }\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::RopeInfo as tree::NodeInfo>::accumulate":["fn accumulate(&mut self, other: &Self){\n        self.lines += other.lines;\n        self.utf16_size += other.utf16_size;\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::RopeInfo as tree::NodeInfo>::compute_info":["fn compute_info(s: &String) -> Self{\n        RopeInfo { lines: count_newlines(s), utf16_size: count_utf16_code_units(s) }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::RopeInfo as tree::NodeInfo>::identity":["fn identity() -> Self{\n        RopeInfo { lines: 0, utf16_size: 0 }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::can_fragment":["fn can_fragment() -> bool{\n        false\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::from_base_units":["fn from_base_units(s: &String, in_base_units: usize) -> usize{\n        count_utf16_code_units(&s[..in_base_units])\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::is_boundary":["fn is_boundary(s: &String, offset: usize) -> bool{\n        s.is_char_boundary(offset)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::measure":["fn measure(info: &RopeInfo, _: usize) -> usize{\n        info.utf16_size\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::next":["fn next(s: &String, offset: usize) -> Option<usize>{\n        if offset == s.len() {\n            // I think it's a precondition that this will never be called\n            // with offset == s.len(), but be defensive.\n            None\n        } else {\n            let b = s.as_bytes()[offset];\n            Some(offset + len_utf8_from_first_byte(b))\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::prev":["fn prev(s: &String, offset: usize) -> Option<usize>{\n        if offset == 0 {\n            // I think it's a precondition that this will never be called\n            // with offset == 0, but be defensive.\n            None\n        } else {\n            let mut len = 1;\n            while !s.is_char_boundary(offset - len) {\n                len += 1;\n            }\n            Some(offset - len)\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::to_base_units":["fn to_base_units(s: &String, in_measured_units: usize) -> usize{\n        let mut cur_len_utf16 = 0;\n        let mut cur_len_utf8 = 0;\n        for u in s.chars() {\n            if cur_len_utf16 >= in_measured_units {\n                break;\n            }\n            cur_len_utf16 += u.len_utf16();\n            cur_len_utf8 += u.len_utf8();\n        }\n        cur_len_utf8\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"<spans::SpanIter<'a, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(Interval, &'a T)>{\n        if let Some((leaf, start_pos)) = self.cursor.get_leaf() {\n            if leaf.spans.is_empty() {\n                return None;\n            }\n            let leaf_start = self.cursor.pos() - start_pos;\n            let span = &leaf.spans[self.ix];\n            self.ix += 1;\n            if self.ix == leaf.spans.len() {\n                let _ = self.cursor.next_leaf();\n                self.ix = 0;\n            }\n            return Some((span.iv.translate(leaf_start), &span.data));\n        }\n        None\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"<spans::SpansInfo<T> as tree::NodeInfo>::accumulate":["fn accumulate(&mut self, other: &Self){\n        self.n_spans += other.n_spans;\n        self.iv = self.iv.union(other.iv);\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"<spans::SpansInfo<T> as tree::NodeInfo>::compute_info":["fn compute_info(l: &SpansLeaf<T>) -> Self{\n        let mut iv = Interval::new(0, 0); // should be Interval::default?\n        for span in &l.spans {\n            iv = iv.union(span.iv);\n        }\n        SpansInfo { n_spans: l.spans.len(), iv, phantom: PhantomData }\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"<spans::SpansLeaf<T> as std::default::Default>::default":["fn default() -> Self{\n        SpansLeaf { len: 0, spans: vec![] }\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child":["fn is_ok_child(&self) -> bool{\n        self.spans.len() >= MIN_LEAF\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"<spans::SpansLeaf<T> as tree::Leaf>::len":["fn len(&self) -> usize{\n        self.len\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split":["fn push_maybe_split(&mut self, other: &Self, iv: Interval) -> Option<Self>{\n        let iv_start = iv.start();\n        for span in &other.spans {\n            let span_iv = span.iv.intersect(iv).translate_neg(iv_start).translate(self.len);\n\n            if !span_iv.is_empty() {\n                self.spans.push(Span { iv: span_iv, data: span.data.clone() });\n            }\n        }\n        self.len += iv.size();\n\n        if self.spans.len() <= MAX_LEAF {\n            None\n        } else {\n            let splitpoint = self.spans.len() / 2; // number of spans\n            let splitpoint_units = self.spans[splitpoint].iv.start();\n            let mut new = self.spans.split_off(splitpoint);\n            for span in &mut new {\n                span.iv = span.iv.translate_neg(splitpoint_units);\n            }\n            let new_len = self.len - splitpoint_units;\n            self.len = splitpoint_units;\n            Some(SpansLeaf { len: new_len, spans: new })\n        }\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"<std::ops::RangeFrom<usize> as interval::IntervalBounds>::into_interval":["fn into_interval(self, upper_bound: usize) -> Interval{\n        Interval::new(self.start, upper_bound)\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"<std::ops::RangeFull as interval::IntervalBounds>::into_interval":["fn into_interval(self, upper_bound: usize) -> Interval{\n        Interval::new(0, upper_bound)\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<usize>{\n        self.cursor.next::<M>()\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"<tree::Node<N> as std::default::Default>::default":["fn default() -> Node<N>{\n        Node::from_leaf(N::L::default())\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"breaks::<impl tree::Node<breaks::BreaksInfo>>::new_no_break":["pub fn new_no_break(len: usize) -> Breaks{\n        let leaf = BreaksLeaf { len, data: vec![] };\n        Node::from_leaf(leaf)\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreakBuilder":["pub struct BreakBuilder {\n    b: TreeBuilder<BreaksInfo>,\n    leaf: BreaksLeaf,\n}","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreakBuilder::add_break":["pub fn add_break(&mut self, len: usize){\n        if self.leaf.data.len() == MAX_LEAF {\n            let leaf = mem::take(&mut self.leaf);\n            self.b.push(Node::from_leaf(leaf));\n        }\n        self.leaf.len += len;\n        self.leaf.data.push(self.leaf.len);\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreakBuilder::add_no_break":["pub fn add_no_break(&mut self, len: usize){\n        self.leaf.len += len;\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreakBuilder::build":["pub fn build(mut self) -> Breaks{\n        self.b.push(Node::from_leaf(self.leaf));\n        self.b.build()\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreakBuilder::new":["pub fn new() -> BreakBuilder{\n        BreakBuilder::default()\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreaksBaseMetric":["pub struct BreaksBaseMetric(());","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreaksInfo":["/// The number of breaks.\npub struct BreaksInfo(usize);","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreaksLeaf":["pub struct BreaksLeaf {\n    /// Length, in base units.\n    len: usize,\n    /// Indexes, represent as offsets from the start of the leaf.\n    data: Vec<usize>,\n}","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreaksLeaf::get_data_cloned":["/// Exposed for testing.\n#[doc(hidden)]\npub fn get_data_cloned(&self) -> Vec<usize>{\n        self.data.clone()\n    }","Real(LocalPath(\"rope/src/breaks.rs\"))"],"breaks::BreaksMetric":["pub struct BreaksMetric(());","Real(LocalPath(\"rope/src/breaks.rs\"))"],"compare::RopeScanner":["/// Utility for efficiently comparing two ropes.\npub struct RopeScanner<'a> {\n    base: Cursor<'a, RopeInfo>,\n    target: Cursor<'a, RopeInfo>,\n    base_chunk: &'a str,\n    target_chunk: &'a str,\n    scanned: usize,\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::RopeScanner::<'a>::find_min_diff_range":["/// Returns the positive offset from the start of the rope to the first\n/// non-equal byte, and the negative offset from the end of the rope to\n/// the first non-equal byte.\n///\n/// The two offsets are guaranteed not to overlap;\n/// thus `sum(start_offset, end_offset) <= min(one.len(), two.len())`.\n///\n/// # Examples\n///\n/// ```\n/// # use xi_rope::compare::RopeScanner;\n/// # use xi_rope::Rope;\n///\n/// let one = Rope::from(\"123xxx12345\");\n/// let two = Rope::from(\"123ZZZ12345\");\n/// let mut scanner = RopeScanner::new(&one, &two);\n/// assert_eq!(scanner.find_min_diff_range(), (3, 5));\n///\n///\n/// let one = Rope::from(\"friends\");\n/// let two = Rope::from(\"fiends\");\n/// let mut scanner = RopeScanner::new(&one, &two);\n/// assert_eq!(scanner.find_min_diff_range(), (1, 5))\n/// ```\npub fn find_min_diff_range(&mut self) -> (usize, usize){\n        let b_end = self.base.total_len();\n        let t_end = self.target.total_len();\n        let start = self.find_ne_char(0, 0, None);\n\n        // scanning from the end of the document, we should stop at whatever\n        // offset we reached scanning from the start.\n        let unscanned = b_end.min(t_end) - start;\n\n        let end = match unscanned {\n            0 => 0,\n            n => self.find_ne_char_back(b_end, t_end, n),\n        };\n\n        (start, end)\n    }","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::RopeScanner::<'a>::find_ne_char":["/// Starting from the two provided offsets into the two ropes, returns\n/// the distance (in bytes) to the first non-equal codepoint. If no such\n/// position exists, returns the shortest distance to the end of a rope.\n///\n/// This can be thought of as the length of the longest common substring\n/// between `base[base_off..]` and `target[targ_off..]`.\n///\n/// if `stop` is not None, the scan will stop at if it reaches this value.\n///\n/// # Examples\n///\n/// ```\n/// # use xi_rope::compare::RopeScanner;\n/// # use xi_rope::Rope;\n///\n/// let one = Rope::from(\"uh-oh🙈\");\n/// let two = Rope::from(\"uh-oh🙉\");\n/// let mut scanner = RopeScanner::new(&one, &two);\n/// assert_eq!(scanner.find_ne_char(0, 0, None), 5);\n/// assert_eq!(scanner.find_ne_char(0, 0, 3), 3);\n/// ```\npub fn find_ne_char<T>(&mut self, base_off: usize, targ_off: usize, stop: T) -> usize\n    where\n        T: Into<Option<usize>>,{\n        let stop = stop.into().unwrap_or(usize::max_value());\n        self.base.set(base_off);\n        self.target.set(targ_off);\n        self.scanned = 0;\n\n        let (base_leaf, base_leaf_off) = self.base.get_leaf().unwrap();\n        let (target_leaf, target_leaf_off) = self.target.get_leaf().unwrap();\n\n        debug_assert!(base_leaf.is_char_boundary(base_leaf_off));\n        debug_assert!(target_leaf.is_char_boundary(target_leaf_off));\n\n        self.base_chunk = &base_leaf[base_leaf_off..];\n        self.target_chunk = &target_leaf[target_leaf_off..];\n\n        loop {\n            if let Some(mut idx) = ne_idx(self.base_chunk.as_bytes(), self.target_chunk.as_bytes())\n            {\n                while idx > 0 && !self.base_chunk.is_char_boundary(idx) {\n                    idx -= 1;\n                }\n                return stop.min(self.scanned + idx);\n            }\n            let scan_len = self.target_chunk.len().min(self.base_chunk.len());\n            self.base_chunk = &self.base_chunk[scan_len..];\n            self.target_chunk = &self.target_chunk[scan_len..];\n            debug_assert!(self.base_chunk.is_empty() || self.target_chunk.is_empty());\n            self.scanned += scan_len;\n            if stop <= self.scanned {\n                break;\n            }\n            self.load_next_chunk();\n            if self.base_chunk.is_empty() || self.target_chunk.is_empty() {\n                break;\n            }\n        }\n        stop.min(self.scanned)\n    }","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::RopeScanner::<'a>::find_ne_char_back":["/// Starting from the two provided offsets in the corresponding ropes,\n/// Returns the distance, moving backwards, to the first non-equal codepoint.\n/// If no such position exists, returns the distance to the closest 0 offset.\n///\n/// if `stop` is not None, the scan will stop at if it reaches this value.\n///\n/// # Examples\n///\n/// ```\n/// # use xi_rope::compare::RopeScanner;\n/// # use xi_rope::Rope;\n///\n/// let one = Rope::from(\"hiii\");\n/// let two = Rope::from(\"siii\");\n/// let mut scanner = RopeScanner::new(&one, &two);\n/// assert_eq!(scanner.find_ne_char_back(one.len(), two.len(), None), 3);\n/// assert_eq!(scanner.find_ne_char_back(one.len(), two.len(), 2), 2);\n/// ```\npub fn find_ne_char_back<T>(&mut self, base_off: usize, targ_off: usize, stop: T) -> usize\n    where\n        T: Into<Option<usize>>,{\n        let stop = stop.into().unwrap_or(usize::max_value());\n        self.base.set(base_off);\n        self.target.set(targ_off);\n        self.scanned = 0;\n\n        let (base_leaf, base_leaf_off) = self.base.get_leaf().unwrap();\n        let (target_leaf, target_leaf_off) = self.target.get_leaf().unwrap();\n\n        debug_assert!(self.target.is_boundary::<BaseMetric>());\n        debug_assert!(self.base.is_boundary::<BaseMetric>());\n        debug_assert!(base_leaf.is_char_boundary(base_leaf_off));\n        debug_assert!(target_leaf.is_char_boundary(target_leaf_off));\n\n        self.base_chunk = &base_leaf[..base_leaf_off];\n        self.target_chunk = &target_leaf[..target_leaf_off];\n\n        loop {\n            if let Some(mut idx) =\n                ne_idx_rev(self.base_chunk.as_bytes(), self.target_chunk.as_bytes())\n            {\n                // find nearest codepoint boundary\n                while idx > 1 && !self.base_chunk.is_char_boundary(self.base_chunk.len() - idx) {\n                    idx -= 1;\n                }\n                return stop.min(self.scanned + idx);\n            }\n            let scan_len = self.target_chunk.len().min(self.base_chunk.len());\n            self.base_chunk = &self.base_chunk[..self.base_chunk.len() - scan_len];\n            self.target_chunk = &self.target_chunk[..self.target_chunk.len() - scan_len];\n            self.scanned += scan_len;\n\n            if stop <= self.scanned {\n                break;\n            }\n            self.load_prev_chunk();\n            if self.base_chunk.is_empty() || self.target_chunk.is_empty() {\n                break;\n            }\n        }\n        stop.min(self.scanned)\n    }","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::RopeScanner::<'a>::load_next_chunk":["fn load_next_chunk(&mut self){\n        if self.base_chunk.is_empty() {\n            if let Some(next) = self.base.next_leaf() {\n                self.base_chunk = next.0;\n            }\n        }\n\n        if self.target_chunk.is_empty() {\n            if let Some(next) = self.target.next_leaf() {\n                self.target_chunk = next.0;\n            }\n        }\n    }","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::RopeScanner::<'a>::load_prev_chunk":["fn load_prev_chunk(&mut self){\n        if self.base_chunk.is_empty() {\n            if let Some(prev) = self.base.prev_leaf() {\n                self.base_chunk = prev.0;\n            }\n        }\n\n        if self.target_chunk.is_empty() {\n            if let Some(prev) = self.target.prev_leaf() {\n                self.target_chunk = prev.0;\n            }\n        }\n    }","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::RopeScanner::<'a>::new":["pub fn new(base: &'a Rope, target: &'a Rope) -> Self{\n        RopeScanner {\n            base: Cursor::new(base, 0),\n            target: Cursor::new(target, 0),\n            base_chunk: \"\",\n            target_chunk: \"\",\n            scanned: 0,\n        }\n    }","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::avx_compare_mask":["/// Like above but with 32 byte slices\n#[allow(clippy::cast_ptr_alignment, clippy::unreadable_literal)]\n#[doc(hidden)]\n#[cfg(target_arch = \"x86_64\")]\n#[target_feature(enable = \"avx2\")]\npub unsafe fn avx_compare_mask(one: &[u8], two: &[u8]) -> i32{\n    use std::arch::x86_64::*;\n    let onev = _mm256_loadu_si256(one.as_ptr() as *const _);\n    let twov = _mm256_loadu_si256(two.as_ptr() as *const _);\n    let mask = _mm256_cmpeq_epi8(onev, twov);\n    !_mm256_movemask_epi8(mask)\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::ne_idx":["/// Returns the lowest `i` for which `one[i] != two[i]`, if one exists.\npub fn ne_idx(one: &[u8], two: &[u8]) -> Option<usize>{\n    #[cfg(target_arch = \"x86_64\")]\n    {\n        if is_x86_feature_detected!(\"avx2\") {\n            return unsafe { ne_idx_avx(one, two) };\n        } else if is_x86_feature_detected!(\"sse4.2\") {\n            return unsafe { ne_idx_sse(one, two) };\n        }\n    }\n    ne_idx_fallback(one, two)\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::ne_idx_avx":["#[doc(hidden)]\n#[cfg(target_arch = \"x86_64\")]\n#[target_feature(enable = \"avx2\")]\npub unsafe fn ne_idx_avx(one: &[u8], two: &[u8]) -> Option<usize>{\n    let min_len = one.len().min(two.len());\n    let mut idx = 0;\n    while idx < min_len {\n        let stride_len = AVX_STRIDE.min(min_len - idx);\n        let mask = avx_compare_mask(\n            &one.get_unchecked(idx..idx + stride_len),\n            &two.get_unchecked(idx..idx + stride_len),\n        );\n        // at the end of the slice the mask might include garbage bytes, so\n        // we ignore matches that are OOB\n        if mask != 0 && idx + (mask.trailing_zeros() as usize) < min_len {\n            return Some(idx + mask.trailing_zeros() as usize);\n        }\n        idx += AVX_STRIDE;\n    }\n    None\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::ne_idx_fallback":["#[inline]\n#[allow(dead_code)]\n#[doc(hidden)]\npub fn ne_idx_fallback(one: &[u8], two: &[u8]) -> Option<usize>{\n    one.iter().zip(two.iter()).position(|(a, b)| a != b)\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::ne_idx_rev":["/// Returns the lowest `i` such that `one[one.len()-i] != two[two.len()-i]`,\n/// if one exists.\npub fn ne_idx_rev(one: &[u8], two: &[u8]) -> Option<usize>{\n    #[cfg(target_arch = \"x86_64\")]\n    {\n        if is_x86_feature_detected!(\"sse4.2\") {\n            return unsafe { ne_idx_rev_sse(one, two) };\n        }\n    }\n    ne_idx_rev_fallback(one, two)\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::ne_idx_rev_fallback":["#[inline]\n#[allow(dead_code)]\n#[doc(hidden)]\npub fn ne_idx_rev_fallback(one: &[u8], two: &[u8]) -> Option<usize>{\n    one.iter().rev().zip(two.iter().rev()).position(|(a, b)| a != b)\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::ne_idx_rev_sse":["#[doc(hidden)]\n#[cfg(target_arch = \"x86_64\")]\n#[target_feature(enable = \"sse4.2\")]\npub unsafe fn ne_idx_rev_sse(one: &[u8], two: &[u8]) -> Option<usize>{\n    let min_len = one.len().min(two.len());\n    let one = &one[one.len() - min_len..];\n    let two = &two[two.len() - min_len..];\n    debug_assert_eq!(one.len(), two.len());\n    let mut idx = min_len;\n    loop {\n        let mask = if idx < SSE_STRIDE {\n            let mut one_buf: [u8; SSE_STRIDE] = [0; SSE_STRIDE];\n            let mut two_buf: [u8; SSE_STRIDE] = [0; SSE_STRIDE];\n            one_buf[SSE_STRIDE - idx..].copy_from_slice(&one[..idx]);\n            two_buf[SSE_STRIDE - idx..].copy_from_slice(&two[..idx]);\n            sse_compare_mask(&one_buf, &two_buf)\n        } else {\n            sse_compare_mask(&one[idx - SSE_STRIDE..idx], &two[idx - SSE_STRIDE..idx])\n        };\n        let i = mask.leading_zeros() as usize - SSE_STRIDE;\n        if i != SSE_STRIDE {\n            return Some(min_len - (idx - i));\n        }\n        if idx < SSE_STRIDE {\n            break;\n        }\n        idx -= SSE_STRIDE;\n    }\n    None\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::ne_idx_sse":["#[doc(hidden)]\n#[cfg(target_arch = \"x86_64\")]\n#[target_feature(enable = \"sse4.2\")]\npub unsafe fn ne_idx_sse(one: &[u8], two: &[u8]) -> Option<usize>{\n    let min_len = one.len().min(two.len());\n    let mut idx = 0;\n    while idx < min_len {\n        let stride_len = SSE_STRIDE.min(min_len - idx);\n        let mask = sse_compare_mask(\n            &one.get_unchecked(idx..idx + stride_len),\n            &two.get_unchecked(idx..idx + stride_len),\n        );\n        if mask != 0 && idx + (mask.trailing_zeros() as usize) < min_len {\n            return Some(idx + mask.trailing_zeros() as usize);\n        }\n        idx += SSE_STRIDE;\n    }\n    None\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"compare::sse_compare_mask":["/// Given two 16-byte slices, returns a bitmask where the 1 bits indicate\n/// the positions of non-equal bytes.\n///\n/// The least significant bit in the mask refers to the byte in position 0;\n/// that is, you read the mask right to left.\n///\n/// # Examples\n///\n/// ```\n/// # use xi_rope::compare::sse_compare_mask;\n/// # if is_x86_feature_detected!(\"sse4.2\") {\n/// let one = \"aaaaaaaaaaaaaaaa\";\n/// let two = \"aa3aaaaa9aaaEaaa\";\n/// let exp = \"0001000100000100\";\n/// let mask = unsafe { sse_compare_mask(one.as_bytes(), two.as_bytes()) };\n/// let result = format!(\"{:016b}\", mask);\n/// assert_eq!(result.as_str(), exp);\n/// # }\n/// ```\n///\n#[allow(clippy::cast_ptr_alignment, clippy::unreadable_literal)]\n#[doc(hidden)]\n#[cfg(target_arch = \"x86_64\")]\n#[target_feature(enable = \"sse4.2\")]\npub unsafe fn sse_compare_mask(one: &[u8], two: &[u8]) -> i32{\n    use std::arch::x86_64::*;\n\n    // too lazy to figure out the bit-fiddly way to get this mask\n    const HIGH_HALF_MASK: u32 = 0b11111111111111110000000000000000;\n\n    debug_assert!(is_x86_feature_detected!(\"sse4.2\"));\n\n    let onev = _mm_loadu_si128(one.as_ptr() as *const _);\n    let twov = _mm_loadu_si128(two.as_ptr() as *const _);\n    let mask = _mm_cmpeq_epi8(onev, twov);\n    (!_mm_movemask_epi8(mask)) ^ HIGH_HALF_MASK as i32\n}","Real(LocalPath(\"rope/src/compare.rs\"))"],"delta::Builder":["/// A builder for creating new `Delta` objects.\n///\n/// Note that all edit operations must be sorted; the start point of each\n/// interval must be no less than the end point of the previous one.\npub struct Builder<N: NodeInfo> {\n    delta: Delta<N>,\n    last_offset: usize,\n}","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Builder::<N>::build":["/// Builds the `Delta`.\npub fn build(mut self) -> Delta<N>{\n        if self.last_offset < self.delta.base_len {\n            self.delta.els.push(DeltaElement::Copy(self.last_offset, self.delta.base_len));\n        }\n        self.delta\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Builder::<N>::delete":["/// Deletes the given interval. Panics if interval is not properly sorted.\npub fn delete<T: IntervalBounds>(&mut self, interval: T){\n        let interval = interval.into_interval(self.delta.base_len);\n        let (start, end) = interval.start_end();\n        assert!(start >= self.last_offset, \"Delta builder: intervals not properly sorted\");\n        if start > self.last_offset {\n            self.delta.els.push(DeltaElement::Copy(self.last_offset, start));\n        }\n        self.last_offset = end;\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Builder::<N>::is_empty":["/// Determines if delta would be a no-op transformation if built.\npub fn is_empty(&self) -> bool{\n        self.last_offset == 0 && self.delta.els.is_empty()\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Builder::<N>::new":["/// Creates a new builder, applicable to a base rope of length `base_len`.\npub fn new(base_len: usize) -> Builder<N>{\n        Builder { delta: Delta { els: Vec::new(), base_len }, last_offset: 0 }\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Builder::<N>::replace":["/// Replaces the given interval with the new rope. Panics if interval\n/// is not properly sorted.\npub fn replace<T: IntervalBounds>(&mut self, interval: T, rope: Node<N>){\n        self.delete(interval);\n        if !rope.is_empty() {\n            self.delta.els.push(DeltaElement::Insert(rope));\n        }\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::DeletionsIter":["pub struct DeletionsIter<'a, N: NodeInfo + 'a> {\n    pos: usize,\n    last_end: usize,\n    base_len: usize,\n    els_iter: slice::Iter<'a, DeltaElement<N>>,\n}","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta":["/// Represents changes to a document by describing the new document as a\n/// sequence of sections copied from the old document and of new inserted\n/// text. Deletions are represented by gaps in the ranges copied from the old\n/// document.\n///\n/// For example, Editing \"abcd\" into \"acde\" could be represented as:\n/// `[Copy(0,1),Copy(2,4),Insert(\"e\")]`\npub struct Delta<N: NodeInfo> {\n    pub els: Vec<DeltaElement<N>>,\n    pub base_len: usize,\n}","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::apply":["/// Apply the delta to the given rope. May not work well if the length of the rope\n/// is not compatible with the construction of the delta.\npub fn apply(&self, base: &Node<N>) -> Node<N>{\n        debug_assert_eq!(base.len(), self.base_len, \"must apply Delta to Node of correct length\");\n        let mut b = TreeBuilder::new();\n        for elem in &self.els {\n            match *elem {\n                DeltaElement::Copy(beg, end) => base.push_subseq(&mut b, Interval::new(beg, end)),\n                DeltaElement::Insert(ref n) => b.push(n.clone()),\n            }\n        }\n        b.build()\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::as_simple_insert":["/// If this delta represents a simple insertion, returns the inserted node.\npub fn as_simple_insert(&self) -> Option<&Node<N>>{\n        let mut iter = self.els.iter();\n        let mut el = iter.next();\n        let mut i = 0;\n        if let Some(&DeltaElement::Copy(beg, end)) = el {\n            if beg != 0 {\n                return None;\n            }\n            i = end;\n            el = iter.next();\n        }\n        if let Some(&DeltaElement::Insert(ref n)) = el {\n            el = iter.next();\n            if el.is_none() {\n                if i == self.base_len {\n                    return Some(n);\n                }\n            } else if let Some(&DeltaElement::Copy(beg, end)) = el {\n                if i == beg && end == self.base_len && iter.next().is_none() {\n                    return Some(n);\n                }\n            }\n        }\n        None\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::factor":["/// Factor the delta into an insert-only delta and a subset representing deletions.\n/// Applying the insert then the delete yields the same result as the original delta:\n///\n/// ```no_run\n/// # use xi_rope::rope::{Rope, RopeInfo};\n/// # use xi_rope::delta::Delta;\n/// # use std::str::FromStr;\n/// fn test_factor(d : &Delta<RopeInfo>, r : &Rope) {\n///     let (ins, del) = d.clone().factor();\n///     let del2 = del.transform_expand(&ins.inserted_subset());\n///     assert_eq!(String::from(del2.delete_from(&ins.apply(r))), String::from(d.apply(r)));\n/// }\n/// ```\npub fn factor(self) -> (InsertDelta<N>, Subset){\n        let mut ins = Vec::new();\n        let mut sb = SubsetBuilder::new();\n        let mut b1 = 0;\n        let mut e1 = 0;\n        for elem in self.els {\n            match elem {\n                DeltaElement::Copy(b, e) => {\n                    sb.add_range(e1, b, 1);\n                    e1 = e;\n                }\n                DeltaElement::Insert(n) => {\n                    if e1 > b1 {\n                        ins.push(DeltaElement::Copy(b1, e1));\n                    }\n                    b1 = e1;\n                    ins.push(DeltaElement::Insert(n));\n                }\n            }\n        }\n        if b1 < self.base_len {\n            ins.push(DeltaElement::Copy(b1, self.base_len));\n        }\n        sb.add_range(e1, self.base_len, 1);\n        sb.pad_to_len(self.base_len);\n        (InsertDelta(Delta { els: ins, base_len: self.base_len }), sb.build())\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::inserts_len":["/// Returns the sum length of the inserts of the delta.\npub fn inserts_len(&self) -> usize{\n        self.els.iter().fold(0, |sum, el| {\n            sum + match *el {\n                DeltaElement::Copy(_, _) => 0,\n                DeltaElement::Insert(ref s) => s.len(),\n            }\n        })\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::is_identity":["/// Returns `true` if applying the delta will cause no change.\npub fn is_identity(&self) -> bool{\n        let len = self.els.len();\n        // Case 1: Everything from beginning to end is getting copied.\n        if len == 1 {\n            if let DeltaElement::Copy(beg, end) = self.els[0] {\n                return beg == 0 && end == self.base_len;\n            }\n        }\n\n        // Case 2: The rope is empty and the entire rope is getting deleted.\n        len == 0 && self.base_len == 0\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::is_simple_delete":["/// Returns `true` if this delta represents a single deletion without\n/// any insertions.\n///\n/// Note that this is `false` for the trivial delta, as well as for a deletion\n/// from an empty `Rope`.\npub fn is_simple_delete(&self) -> bool{\n        if self.els.is_empty() {\n            return self.base_len > 0;\n        }\n        if let DeltaElement::Copy(beg, end) = self.els[0] {\n            if beg == 0 {\n                if self.els.len() == 1 {\n                    // Deletion at end\n                    end < self.base_len\n                } else if let DeltaElement::Copy(b1, e1) = self.els[1] {\n                    // Deletion in middle\n                    self.els.len() == 2 && end < b1 && e1 == self.base_len\n                } else {\n                    false\n                }\n            } else {\n                // Deletion at beginning\n                end == self.base_len && self.els.len() == 1\n            }\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::iter_deletions":["/// Iterates over all the deletions of the delta.\npub fn iter_deletions(&self) -> DeletionsIter<N>{\n        DeletionsIter { pos: 0, last_end: 0, base_len: self.base_len, els_iter: self.els.iter() }\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::iter_inserts":["/// Iterates over all the inserts of the delta.\npub fn iter_inserts(&self) -> InsertsIter<N>{\n        InsertsIter { pos: 0, last_end: 0, els_iter: self.els.iter() }\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::new_document_len":["/// Returns the length of the new document. In other words, the length of\n/// the transformed string after this Delta is applied.\n///\n/// `d.apply(r).len() == d.new_document_len()`\npub fn new_document_len(&self) -> usize{\n        Delta::total_element_len(self.els.as_slice())\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::simple_edit":["pub fn simple_edit<T: IntervalBounds>(interval: T, rope: Node<N>, base_len: usize) -> Delta<N>{\n        let mut builder = Builder::new(base_len);\n        if rope.is_empty() {\n            builder.delete(interval);\n        } else {\n            builder.replace(interval, rope);\n        }\n        builder.build()\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::summary":["/// Produce a summary of the delta. Everything outside the returned interval\n/// is unchanged, and the old contents of the interval are replaced by new\n/// contents of the returned length. Equations:\n///\n/// `(iv, new_len) = self.summary()`\n///\n/// `new_s = self.apply(s)`\n///\n/// `new_s = simple_edit(iv, new_s.subseq(iv.start(), iv.start() + new_len), s.len()).apply(s)`\npub fn summary(&self) -> (Interval, usize){\n        let mut els = self.els.as_slice();\n        let mut iv_start = 0;\n        if let Some((&DeltaElement::Copy(0, end), rest)) = els.split_first() {\n            iv_start = end;\n            els = rest;\n        }\n        let mut iv_end = self.base_len;\n        if let Some((&DeltaElement::Copy(beg, end), init)) = els.split_last() {\n            if end == iv_end {\n                iv_end = beg;\n                els = init;\n            }\n        }\n        (Interval::new(iv_start, iv_end), Delta::total_element_len(els))\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::synthesize":["/// Synthesize a delta from a \"union string\" and two subsets: an old set\n/// of deletions and a new set of deletions from the union. The Delta is\n/// from text to text, not union to union; anything in both subsets will\n/// be assumed to be missing from the Delta base and the new text. You can\n/// also think of these as a set of insertions and one of deletions, with\n/// overlap doing nothing. This is basically the inverse of `factor`.\n///\n/// Since only the deleted portions of the union string are necessary,\n/// instead of requiring a union string the function takes a `tombstones`\n/// rope which contains the deleted portions of the union string. The\n/// `from_dels` subset must be the interleaving of `tombstones` into the\n/// union string.\n///\n/// ```no_run\n/// # use xi_rope::rope::{Rope, RopeInfo};\n/// # use xi_rope::delta::Delta;\n/// # use std::str::FromStr;\n/// fn test_synthesize(d : &Delta<RopeInfo>, r : &Rope) {\n///     let (ins_d, del) = d.clone().factor();\n///     let ins = ins_d.inserted_subset();\n///     let del2 = del.transform_expand(&ins);\n///     let r2 = ins_d.apply(&r);\n///     let tombstones = ins.complement().delete_from(&r2);\n///     let d2 = Delta::synthesize(&tombstones, &ins, &del);\n///     assert_eq!(String::from(d2.apply(r)), String::from(d.apply(r)));\n/// }\n/// ```\n#[allow(clippy::unnecessary_unwrap)]\npub fn synthesize(tombstones: &Node<N>, from_dels: &Subset, to_dels: &Subset) -> Delta<N>{\n        let base_len = from_dels.len_after_delete();\n        let mut els = Vec::new();\n        let mut x = 0;\n        let mut old_ranges = from_dels.complement_iter();\n        let mut last_old = old_ranges.next();\n        let mut m = from_dels.mapper(CountMatcher::NonZero);\n        // For each segment of the new text\n        for (b, e) in to_dels.complement_iter() {\n            // Fill the whole segment\n            let mut beg = b;\n            while beg < e {\n                // Skip over ranges in old text until one overlaps where we want to fill\n                while let Some((ib, ie)) = last_old {\n                    if ie > beg {\n                        break;\n                    }\n                    x += ie - ib;\n                    last_old = old_ranges.next();\n                }\n                // If we have a range in the old text with the character at beg, then we Copy\n                if last_old.is_some() && last_old.unwrap().0 <= beg {\n                    let (ib, ie) = last_old.unwrap();\n                    let end = min(e, ie);\n                    // Try to merge contiguous Copys in the output\n                    let xbeg = beg + x - ib; // \"beg - ib + x\" better for overflow?\n                    let xend = end + x - ib; // ditto\n                    let merged =\n                        if let Some(&mut DeltaElement::Copy(_, ref mut le)) = els.last_mut() {\n                            if *le == xbeg {\n                                *le = xend;\n                                true\n                            } else {\n                                false\n                            }\n                        } else {\n                            false\n                        };\n                    if !merged {\n                        els.push(DeltaElement::Copy(xbeg, xend));\n                    }\n                    beg = end;\n                } else {\n                    // if the character at beg isn't in the old text, then we Insert\n                    // Insert up until the next old range we could Copy from, or the end of this segment\n                    let mut end = e;\n                    if let Some((ib, _)) = last_old {\n                        end = min(end, ib)\n                    }\n                    // Note: could try to aggregate insertions, but not sure of the win.\n                    // Use the mapper to insert the corresponding section of the tombstones rope\n                    let interval =\n                        Interval::new(m.doc_index_to_subset(beg), m.doc_index_to_subset(end));\n                    els.push(DeltaElement::Insert(tombstones.subseq(interval)));\n                    beg = end;\n                }\n            }\n        }\n        Delta { els, base_len }\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Delta::<N>::total_element_len":["fn total_element_len(els: &[DeltaElement<N>]) -> usize{\n        els.iter().fold(0, |sum, el| {\n            sum + match *el {\n                DeltaElement::Copy(beg, end) => end - beg,\n                DeltaElement::Insert(ref n) => n.len(),\n            }\n        })\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::DeltaElement":["pub enum DeltaElement<N: NodeInfo> {\n    /// Represents a range of text in the base document. Includes beginning, excludes end.\n    Copy(usize, usize), // note: for now, we lose open/closed info at interval endpoints\n    Insert(Node<N>),\n}","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::DeltaRegion":["pub struct DeltaRegion {\n    pub old_offset: usize,\n    pub new_offset: usize,\n    pub len: usize,\n}","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::DeltaRegion::new":["fn new(old_offset: usize, new_offset: usize, len: usize) -> Self{\n        DeltaRegion { old_offset, new_offset, len }\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::InsertDelta":["/// A struct marking that a Delta contains only insertions. That is, it copies\n/// all of the old document in the same order. It has a `Deref` impl so all\n/// normal `Delta` methods can also be used on it.\npub struct InsertDelta<N: NodeInfo>(Delta<N>);","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::InsertDelta::<N>::inserted_subset":["/// Return a Subset containing the inserted ranges.\n///\n/// `d.inserted_subset().delete_from_string(d.apply_to_string(s)) == s`\npub fn inserted_subset(&self) -> Subset{\n        let mut sb = SubsetBuilder::new();\n        for elem in &self.0.els {\n            match *elem {\n                DeltaElement::Copy(b, e) => {\n                    sb.push_segment(e - b, 0);\n                }\n                DeltaElement::Insert(ref n) => {\n                    sb.push_segment(n.len(), 1);\n                }\n            }\n        }\n        sb.build()\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::InsertDelta::<N>::transform_expand":["/// Do a coordinate transformation on an insert-only delta. The `after` parameter\n/// controls whether the insertions in `self` come after those specific in the\n/// coordinate transform.\npub fn transform_expand(&self, xform: &Subset, after: bool) -> InsertDelta<N>{\n        let cur_els = &self.0.els;\n        let mut els = Vec::new();\n        let mut x = 0; // coordinate within self\n        let mut y = 0; // coordinate within xform\n        let mut i = 0; // index into self.els\n        let mut b1 = 0;\n        let mut xform_ranges = xform.complement_iter();\n        let mut last_xform = xform_ranges.next();\n        let l = xform.count(CountMatcher::All);\n        while y < l || i < cur_els.len() {\n            let next_iv_beg = if let Some((xb, _)) = last_xform { xb } else { l };\n            if after && y < next_iv_beg {\n                y = next_iv_beg;\n            }\n            while i < cur_els.len() {\n                match cur_els[i] {\n                    DeltaElement::Insert(ref n) => {\n                        if y > b1 {\n                            els.push(DeltaElement::Copy(b1, y));\n                        }\n                        b1 = y;\n                        els.push(DeltaElement::Insert(n.clone()));\n                        i += 1;\n                    }\n                    DeltaElement::Copy(_b, e) => {\n                        if y >= next_iv_beg {\n                            let mut next_y = e + y - x;\n                            if let Some((_, xe)) = last_xform {\n                                next_y = min(next_y, xe);\n                            }\n                            x += next_y - y;\n                            y = next_y;\n                            if x == e {\n                                i += 1;\n                            }\n                            if let Some((_, xe)) = last_xform {\n                                if y == xe {\n                                    last_xform = xform_ranges.next();\n                                }\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n            if !after && y < next_iv_beg {\n                y = next_iv_beg;\n            }\n        }\n        if y > b1 {\n            els.push(DeltaElement::Copy(b1, y));\n        }\n        InsertDelta(Delta { els, base_len: l })\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::InsertDelta::<N>::transform_shrink":["/// Shrink a delta through a deletion of some of its copied regions with\n/// the same base. For example, if `self` applies to a union string, and\n/// `xform` is the deletions from that union, the resulting Delta will\n/// apply to the text.\npub fn transform_shrink(&self, xform: &Subset) -> InsertDelta<N>{\n        let mut m = xform.mapper(CountMatcher::Zero);\n        let els = self\n            .0\n            .els\n            .iter()\n            .map(|elem| match *elem {\n                DeltaElement::Copy(b, e) => {\n                    DeltaElement::Copy(m.doc_index_to_subset(b), m.doc_index_to_subset(e))\n                }\n                DeltaElement::Insert(ref n) => DeltaElement::Insert(n.clone()),\n            })\n            .collect();\n        InsertDelta(Delta { els, base_len: xform.len_after_delete() })\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::InsertsIter":["pub struct InsertsIter<'a, N: NodeInfo + 'a> {\n    pos: usize,\n    last_end: usize,\n    els_iter: slice::Iter<'a, DeltaElement<N>>,\n}","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Transformer":["/// A mapping from coordinates in the source sequence to coordinates in the sequence after\n/// the delta is applied.\npub struct Transformer<'a, N: NodeInfo + 'a> {\n    delta: &'a Delta<N>,\n}","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Transformer::<'a, N>::interval_untouched":["/// Determine whether a given interval is untouched by the transformation.\npub fn interval_untouched<T: IntervalBounds>(&mut self, iv: T) -> bool{\n        let iv = iv.into_interval(self.delta.base_len);\n        let mut last_was_ins = true;\n        for el in &self.delta.els {\n            match *el {\n                DeltaElement::Copy(beg, end) => {\n                    if iv.is_before(end) {\n                        if last_was_ins {\n                            if iv.is_after(beg) {\n                                return true;\n                            }\n                        } else {\n                            if !iv.is_before(beg) {\n                                return true;\n                            }\n                        }\n                    } else {\n                        return false;\n                    }\n                    last_was_ins = false;\n                }\n                _ => {\n                    last_was_ins = true;\n                }\n            }\n        }\n        false\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Transformer::<'a, N>::new":["/// Create a new transformer from a delta.\npub fn new(delta: &'a Delta<N>) -> Self{\n        Transformer { delta }\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"delta::Transformer::<'a, N>::transform":["/// Transform a single coordinate. The `after` parameter indicates whether it\n/// it should land before or after an inserted region.\npub fn transform(&mut self, ix: usize, after: bool) -> usize{\n        if ix == 0 && !after {\n            return 0;\n        }\n        let mut result = 0;\n        for el in &self.delta.els {\n            match *el {\n                DeltaElement::Copy(beg, end) => {\n                    if ix <= beg {\n                        return result;\n                    }\n                    if ix < end || (ix == end && !after) {\n                        return result + ix - beg;\n                    }\n                    result += end - beg;\n                }\n                DeltaElement::Insert(ref n) => {\n                    result += n.len();\n                }\n            }\n        }\n        result\n    }","Real(LocalPath(\"rope/src/delta.rs\"))"],"diff::Diff":["/// A trait implemented by various diffing strategies.\npub trait Diff<N: NodeInfo> {\n    fn compute_delta(base: &Node<N>, target: &Node<N>) -> Delta<N>;\n}","Real(LocalPath(\"rope/src/diff.rs\"))"],"diff::DiffBuilder":["/// Keeps track of copy ops during diff construction.\npub struct DiffBuilder {\n    ops: Vec<DiffOp>,\n}","Real(LocalPath(\"rope/src/diff.rs\"))"],"diff::DiffBuilder::copy":["fn copy(&mut self, base: usize, target: usize, len: usize){\n        if let Some(prev) = self.ops.last_mut() {\n            let prev_end = prev.target_idx + prev.len;\n            let base_end = prev.base_idx + prev.len;\n            assert!(prev_end <= target, \"{} <= {} prev {:?}\", prev_end, target, prev);\n            if prev_end == target && base_end == base {\n                prev.len += len;\n                return;\n            }\n        }\n        self.ops.push(DiffOp { target_idx: target, base_idx: base, len })\n    }","Real(LocalPath(\"rope/src/diff.rs\"))"],"diff::DiffBuilder::to_delta":["fn to_delta(self, base: &Rope, target: &Rope) -> RopeDelta{\n        let mut els = Vec::with_capacity(self.ops.len() * 2);\n        let mut targ_pos = 0;\n        for DiffOp { base_idx, target_idx, len } in self.ops {\n            if target_idx > targ_pos {\n                let iv = Interval::new(targ_pos, target_idx);\n                els.push(DeltaElement::Insert(target.subseq(iv)));\n            }\n            els.push(DeltaElement::Copy(base_idx, base_idx + len));\n            targ_pos = target_idx + len;\n        }\n\n        if targ_pos < target.len() {\n            let iv = Interval::new(targ_pos, target.len());\n            els.push(DeltaElement::Insert(target.subseq(iv)));\n        }\n\n        Delta { els, base_len: base.len() }\n    }","Real(LocalPath(\"rope/src/diff.rs\"))"],"diff::DiffOp":["/// Represents copying `len` bytes from base to target.\nstruct DiffOp {\n    target_idx: usize,\n    base_idx: usize,\n    len: usize,\n}","Real(LocalPath(\"rope/src/diff.rs\"))"],"diff::LineHashDiff":["/// A line-oriented, hash based diff algorithm.\n///\n/// This works by taking a hash of each line in either document that\n/// has a length, ignoring leading whitespace, above some threshold.\n///\n/// Lines in the target document are matched against lines in the\n/// base document. When a match is found, it is extended forwards\n/// and backwards as far as possible.\n///\n/// This runs in O(n+m) in the lengths of the two ropes, and produces\n/// results on a variety of workloads that are comparable in quality\n/// (measured in terms of serialized diff size) with the results from\n/// using a suffix array, while being an order of magnitude faster.\npub struct LineHashDiff;","Real(LocalPath(\"rope/src/diff.rs\"))"],"diff::expand_match":["/// Given two ropes and the offsets of two equal bytes, finds the largest\n/// identical substring shared between the two ropes which contains the offset.\n///\n/// The return value is a pair of offsets, each of which represents an absolute\n/// distance. That is to say, the position of the start and end boundaries\n/// relative to the input offset.\nfn expand_match(\n    base: &Rope,\n    target: &Rope,\n    base_off: usize,\n    targ_off: usize,\n    prev_match_targ_end: usize,\n) -> (usize, usize){\n    let mut scanner = RopeScanner::new(base, target);\n    let max_left = targ_off - prev_match_targ_end;\n    let start = scanner.find_ne_char_back(base_off, targ_off, max_left);\n    debug_assert!(start <= max_left, \"{} <= {}\", start, max_left);\n    let end = scanner.find_ne_char(base_off, targ_off, None);\n    (start.min(max_left), end)\n}","Real(LocalPath(\"rope/src/diff.rs\"))"],"diff::longest_increasing_region_set":["/// Finds the longest increasing subset of copyable regions. This is essentially\n/// the longest increasing subsequence problem. This implementation is adapted\n/// from https://codereview.stackexchange.com/questions/187337/longest-increasing-subsequence-algorithm\nfn longest_increasing_region_set(items: &[(usize, usize)]) -> Vec<(usize, usize)>{\n    let mut result = vec![0];\n    let mut prev_chain = vec![0; items.len()];\n\n    for i in 1..items.len() {\n        // If the next item is greater than the last item of the current longest\n        // subsequence, push its index at the end of the result and continue.\n        let last_idx = *result.last().unwrap();\n        if items[last_idx].1 < items[i].1 {\n            prev_chain[i] = last_idx;\n            result.push(i);\n            continue;\n        }\n\n        let next_idx = match result.binary_search_by(|&j| items[j].1.cmp(&items[i].1)) {\n            Ok(_) => continue, // we ignore duplicates\n            Err(idx) => idx,\n        };\n\n        if items[i].1 < items[result[next_idx]].1 {\n            if next_idx > 0 {\n                prev_chain[i] = result[next_idx - 1];\n            }\n            result[next_idx] = i;\n        }\n    }\n\n    // walk backwards from the last item in result to build the final sequence\n    let mut u = result.len();\n    let mut v = *result.last().unwrap();\n    while u != 0 {\n        u -= 1;\n        result[u] = v;\n        v = prev_chain[v];\n    }\n    result.iter().map(|i| items[*i]).collect()\n}","Real(LocalPath(\"rope/src/diff.rs\"))"],"diff::make_line_hashes":["/// Creates a map of lines to offsets, ignoring trailing whitespace, and only for those lines\n/// where line.len() >= min_size. Offsets refer to the first non-whitespace byte in the line.\nfn make_line_hashes<'a>(base: &'a Rope, min_size: usize) -> HashMap<Cow<'a, str>, usize>{\n    let mut offset = 0;\n    let mut line_hashes = HashMap::with_capacity(base.len() / 60);\n    for line in base.lines_raw(..) {\n        let non_ws = non_ws_offset(&line);\n        if line.len() - non_ws >= min_size {\n            let cow = match line {\n                Cow::Owned(ref s) => Cow::Owned(s[non_ws..].to_string()),\n                Cow::Borrowed(s) => Cow::Borrowed(&s[non_ws..]),\n            };\n            line_hashes.insert(cow, offset + non_ws);\n        }\n        offset += line.len();\n    }\n    line_hashes\n}","Real(LocalPath(\"rope/src/diff.rs\"))"],"diff::non_ws_offset":["#[inline]\nfn non_ws_offset(s: &str) -> usize{\n    s.as_bytes().iter().take_while(|b| **b == b' ' || **b == b'\\t').count()\n}","Real(LocalPath(\"rope/src/diff.rs\"))"],"engine::Contents":["enum Contents {\n    Edit {\n        /// Used to order concurrent inserts, for example auto-indentation\n        /// should go before typed text.\n        priority: usize,\n        /// Groups related edits together so that they are undone and re-done\n        /// together. For example, an auto-indent insertion would be un-done\n        /// along with the newline that triggered it.\n        undo_group: usize,\n        /// The subset of the characters of the union string from after this\n        /// revision that were added by this revision.\n        inserts: Subset,\n        /// The subset of the characters of the union string from after this\n        /// revision that were deleted by this revision.\n        deletes: Subset,\n    },\n    Undo {\n        /// The set of groups toggled between undone and done.\n        /// Just the `symmetric_difference` (XOR) of the two sets.\n        toggled_groups: BTreeSet<usize>, // set of undo_group id's\n        /// Used to store a reversible difference between the old\n        /// and new deletes_from_union\n        deletes_bitxor: Subset,\n    },\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::DeltaOp":["struct DeltaOp {\n    rev_id: RevId,\n    priority: usize,\n    undo_group: usize,\n    inserts: InsertDelta<RopeInfo>,\n    deletes: Subset,\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine":["/// Represents the current state of a document and all of its history\npub struct Engine {\n    /// The session ID used to create new `RevId`s for edits made on this device\n    #[cfg_attr(feature = \"serde\", serde(default = \"default_session\", skip_serializing))]\n    session: SessionId,\n    /// The incrementing revision number counter for this session used for `RevId`s\n    #[cfg_attr(feature = \"serde\", serde(default = \"initial_revision_counter\", skip_serializing))]\n    rev_id_counter: u32,\n    /// The current contents of the document as would be displayed on screen\n    text: Rope,\n    /// Storage for all the characters that have been deleted  but could\n    /// return if a delete is un-done or an insert is re- done.\n    tombstones: Rope,\n    /// Imagine a \"union string\" that contained all the characters ever\n    /// inserted, including the ones that were later deleted, in the locations\n    /// they would be if they hadn't been deleted.\n    ///\n    /// This is a `Subset` of the \"union string\" representing the characters\n    /// that are currently deleted, and thus in `tombstones` rather than\n    /// `text`. The count of a character in `deletes_from_union` represents\n    /// how many times it has been deleted, so if a character is deleted twice\n    /// concurrently it will have count `2` so that undoing one delete but not\n    /// the other doesn't make it re-appear.\n    ///\n    /// You could construct the \"union string\" from `text`, `tombstones` and\n    /// `deletes_from_union` by splicing a segment of `tombstones` into `text`\n    /// wherever there's a non-zero-count segment in `deletes_from_union`.\n    deletes_from_union: Subset,\n    // TODO: switch to a persistent Set representation to avoid O(n) copying\n    undone_groups: BTreeSet<usize>, // set of undo_group id's\n    /// The revision history of the document\n    revs: Vec<Revision>,\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::compute_undo":["fn compute_undo(&self, groups: &BTreeSet<usize>) -> (Revision, Subset){\n        let toggled_groups = self.undone_groups.symmetric_difference(&groups).cloned().collect();\n        let first_candidate = self.find_first_undo_candidate_index(&toggled_groups);\n        // the `false` below: don't invert undos since our first_candidate is based on the current undo set, not past\n        let mut deletes_from_union =\n            self.deletes_from_union_before_index(first_candidate, false).into_owned();\n\n        for rev in &self.revs[first_candidate..] {\n            if let Edit { ref undo_group, ref inserts, ref deletes, .. } = rev.edit {\n                if groups.contains(undo_group) {\n                    if !inserts.is_empty() {\n                        deletes_from_union = deletes_from_union.transform_union(inserts);\n                    }\n                } else {\n                    if !inserts.is_empty() {\n                        deletes_from_union = deletes_from_union.transform_expand(inserts);\n                    }\n                    if !deletes.is_empty() {\n                        deletes_from_union = deletes_from_union.union(deletes);\n                    }\n                }\n            }\n        }\n\n        let deletes_bitxor = self.deletes_from_union.bitxor(&deletes_from_union);\n        let max_undo_so_far = self.revs.last().unwrap().max_undo_so_far;\n        (\n            Revision {\n                rev_id: self.next_rev_id(),\n                max_undo_so_far,\n                edit: Undo { toggled_groups, deletes_bitxor },\n            },\n            deletes_from_union,\n        )\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::deletes_from_cur_union_for_index":["/// Get the Subset to delete from the current union string in order to obtain a revision's content\nfn deletes_from_cur_union_for_index(&self, rev_index: usize) -> Cow<Subset>{\n        let mut deletes_from_union = self.deletes_from_union_for_index(rev_index);\n        for rev in &self.revs[rev_index + 1..] {\n            if let Edit { ref inserts, .. } = rev.edit {\n                if !inserts.is_empty() {\n                    deletes_from_union = Cow::Owned(deletes_from_union.transform_union(inserts));\n                }\n            }\n        }\n        deletes_from_union\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::deletes_from_union_before_index":["/// Garbage collection means undo can sometimes need to replay the very first\n/// revision, and so needs a way to get the deletion set before then.\nfn deletes_from_union_before_index(&self, rev_index: usize, invert_undos: bool) -> Cow<Subset>{\n        let mut deletes_from_union = Cow::Borrowed(&self.deletes_from_union);\n        let mut undone_groups = Cow::Borrowed(&self.undone_groups);\n\n        // invert the changes to deletes_from_union starting in the present and working backwards\n        for rev in self.revs[rev_index..].iter().rev() {\n            deletes_from_union = match rev.edit {\n                Edit { ref inserts, ref deletes, ref undo_group, .. } => {\n                    if undone_groups.contains(undo_group) {\n                        // no need to un-delete undone inserts since we'll just shrink them out\n                        Cow::Owned(deletes_from_union.transform_shrink(inserts))\n                    } else {\n                        let un_deleted = deletes_from_union.subtract(deletes);\n                        Cow::Owned(un_deleted.transform_shrink(inserts))\n                    }\n                }\n                Undo { ref toggled_groups, ref deletes_bitxor } => {\n                    if invert_undos {\n                        let new_undone =\n                            undone_groups.symmetric_difference(toggled_groups).cloned().collect();\n                        undone_groups = Cow::Owned(new_undone);\n                        Cow::Owned(deletes_from_union.bitxor(deletes_bitxor))\n                    } else {\n                        deletes_from_union\n                    }\n                }\n            }\n        }\n        deletes_from_union\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::deletes_from_union_for_index":["/// Find what the `deletes_from_union` field in Engine would have been at the time\n/// of a certain `rev_index`. In other words, the deletes from the union string at that time.\nfn deletes_from_union_for_index(&self, rev_index: usize) -> Cow<Subset>{\n        self.deletes_from_union_before_index(rev_index + 1, true)\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::edit_rev":["/// Create a new edit based on `base_rev`.\n///\n/// # Panics\n///\n/// Panics if `base_rev` does not exist, or if `delta` is poorly formed.\npub fn edit_rev(\n        &mut self,\n        priority: usize,\n        undo_group: usize,\n        base_rev: RevToken,\n        delta: Delta<RopeInfo>,\n    ){\n        self.try_edit_rev(priority, undo_group, base_rev, delta).unwrap();\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::empty":["pub fn empty() -> Engine{\n        let deletes_from_union = Subset::new(0);\n        let rev = Revision {\n            rev_id: RevId { session1: 0, session2: 0, num: 0 },\n            edit: Undo {\n                toggled_groups: BTreeSet::new(),\n                deletes_bitxor: deletes_from_union.clone(),\n            },\n            max_undo_so_far: 0,\n        };\n        Engine {\n            session: default_session(),\n            rev_id_counter: 1,\n            text: Rope::default(),\n            tombstones: Rope::default(),\n            deletes_from_union,\n            undone_groups: BTreeSet::new(),\n            revs: vec![rev],\n        }\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::empty_subset_before_first_rev":["fn empty_subset_before_first_rev(&self) -> Subset{\n        let first_rev = &self.revs.first().unwrap();\n        // it will be immediately transform_expanded by inserts if it is an Edit, so length must be before\n        let len = match first_rev.edit {\n            Edit { ref inserts, .. } => inserts.count(CountMatcher::Zero),\n            Undo { ref deletes_bitxor, .. } => deletes_bitxor.count(CountMatcher::All),\n        };\n        Subset::new(len)\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::find_first_undo_candidate_index":["/// Find the first revision that could be affected by toggling a set of undo groups\nfn find_first_undo_candidate_index(&self, toggled_groups: &BTreeSet<usize>) -> usize{\n        // find the lowest toggled undo group number\n        if let Some(lowest_group) = toggled_groups.iter().cloned().next() {\n            for (i, rev) in self.revs.iter().enumerate().rev() {\n                if rev.max_undo_so_far < lowest_group {\n                    return i + 1; // +1 since we know the one we just found doesn't have it\n                }\n            }\n            0\n        } else {\n            // no toggled groups, return past end\n            self.revs.len()\n        }\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::find_rev":["fn find_rev(&self, rev_id: RevId) -> Option<usize>{\n        self.revs\n            .iter()\n            .enumerate()\n            .rev()\n            .find(|&(_, ref rev)| rev.rev_id == rev_id)\n            .map(|(i, _)| i)\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::find_rev_token":["fn find_rev_token(&self, rev_token: RevToken) -> Option<usize>{\n        self.revs\n            .iter()\n            .enumerate()\n            .rev()\n            .find(|&(_, ref rev)| rev.rev_id.token() == rev_token)\n            .map(|(i, _)| i)\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::gc":["pub fn gc(&mut self, gc_groups: &BTreeSet<usize>){\n        let mut gc_dels = self.empty_subset_before_first_rev();\n        // TODO: want to let caller retain more rev_id's.\n        let mut retain_revs = BTreeSet::new();\n        if let Some(last) = self.revs.last() {\n            retain_revs.insert(last.rev_id);\n        }\n        {\n            for rev in &self.revs {\n                if let Edit { ref undo_group, ref inserts, ref deletes, .. } = rev.edit {\n                    if !retain_revs.contains(&rev.rev_id) && gc_groups.contains(undo_group) {\n                        if self.undone_groups.contains(undo_group) {\n                            if !inserts.is_empty() {\n                                gc_dels = gc_dels.transform_union(inserts);\n                            }\n                        } else {\n                            if !inserts.is_empty() {\n                                gc_dels = gc_dels.transform_expand(inserts);\n                            }\n                            if !deletes.is_empty() {\n                                gc_dels = gc_dels.union(deletes);\n                            }\n                        }\n                    } else if !inserts.is_empty() {\n                        gc_dels = gc_dels.transform_expand(inserts);\n                    }\n                }\n            }\n        }\n        if !gc_dels.is_empty() {\n            let not_in_tombstones = self.deletes_from_union.complement();\n            let dels_from_tombstones = gc_dels.transform_shrink(&not_in_tombstones);\n            self.tombstones = dels_from_tombstones.delete_from(&self.tombstones);\n            self.deletes_from_union = self.deletes_from_union.transform_shrink(&gc_dels);\n        }\n        let old_revs = std::mem::replace(&mut self.revs, Vec::new());\n        for rev in old_revs.into_iter().rev() {\n            match rev.edit {\n                Edit { priority, undo_group, inserts, deletes } => {\n                    let new_gc_dels = if inserts.is_empty() {\n                        None\n                    } else {\n                        Some(gc_dels.transform_shrink(&inserts))\n                    };\n                    if retain_revs.contains(&rev.rev_id) || !gc_groups.contains(&undo_group) {\n                        let (inserts, deletes) = if gc_dels.is_empty() {\n                            (inserts, deletes)\n                        } else {\n                            (inserts.transform_shrink(&gc_dels), deletes.transform_shrink(&gc_dels))\n                        };\n                        self.revs.push(Revision {\n                            rev_id: rev.rev_id,\n                            max_undo_so_far: rev.max_undo_so_far,\n                            edit: Edit { priority, undo_group, inserts, deletes },\n                        });\n                    }\n                    if let Some(new_gc_dels) = new_gc_dels {\n                        gc_dels = new_gc_dels;\n                    }\n                }\n                Undo { toggled_groups, deletes_bitxor } => {\n                    // We're super-aggressive about dropping these; after gc, the history\n                    // of which undos were used to compute deletes_from_union in edits may be lost.\n                    if retain_revs.contains(&rev.rev_id) {\n                        let new_deletes_bitxor = if gc_dels.is_empty() {\n                            deletes_bitxor\n                        } else {\n                            deletes_bitxor.transform_shrink(&gc_dels)\n                        };\n                        self.revs.push(Revision {\n                            rev_id: rev.rev_id,\n                            max_undo_so_far: rev.max_undo_so_far,\n                            edit: Undo {\n                                toggled_groups: &toggled_groups - gc_groups,\n                                deletes_bitxor: new_deletes_bitxor,\n                            },\n                        })\n                    }\n                }\n            }\n        }\n        self.revs.reverse();\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::get_head":["/// Get text of head revision.\npub fn get_head(&self) -> &Rope{\n        &self.text\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::get_head_rev_id":["/// Get revision id of head revision.\npub fn get_head_rev_id(&self) -> RevId{\n        self.revs.last().unwrap().rev_id\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::get_rev":["/// Get text of a given revision, if it can be found.\npub fn get_rev(&self, rev: RevToken) -> Option<Rope>{\n        self.find_rev_token(rev).map(|rev_index| self.rev_content_for_index(rev_index))\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::is_equivalent_revision":["pub fn is_equivalent_revision(&self, base_rev: RevId, other_rev: RevId) -> bool{\n        let base_subset = self\n            .find_rev(base_rev)\n            .map(|rev_index| self.deletes_from_cur_union_for_index(rev_index));\n        let other_subset = self\n            .find_rev(other_rev)\n            .map(|rev_index| self.deletes_from_cur_union_for_index(rev_index));\n\n        base_subset.is_some() && base_subset == other_subset\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::max_undo_group_id":["/// Returns the largest undo group ID used so far\npub fn max_undo_group_id(&self) -> usize{\n        self.revs.last().unwrap().max_undo_so_far\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::merge":["/// Merge the new content from another Engine into this one with a CRDT merge\npub fn merge(&mut self, other: &Engine){\n        let (mut new_revs, text, tombstones, deletes_from_union) = {\n            let base_index = find_base_index(&self.revs, &other.revs);\n            let a_to_merge = &self.revs[base_index..];\n            let b_to_merge = &other.revs[base_index..];\n\n            let common = find_common(a_to_merge, b_to_merge);\n\n            let a_new = rearrange(a_to_merge, &common, self.deletes_from_union.len());\n            let b_new = rearrange(b_to_merge, &common, other.deletes_from_union.len());\n\n            let b_deltas =\n                compute_deltas(&b_new, &other.text, &other.tombstones, &other.deletes_from_union);\n            let expand_by = compute_transforms(a_new);\n\n            let max_undo = self.max_undo_group_id();\n            rebase(\n                expand_by,\n                b_deltas,\n                self.text.clone(),\n                self.tombstones.clone(),\n                self.deletes_from_union.clone(),\n                max_undo,\n            )\n        };\n\n        self.text = text;\n        self.tombstones = tombstones;\n        self.deletes_from_union = deletes_from_union;\n        self.revs.append(&mut new_revs);\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::mk_new_rev":["/// Returns a tuple of a new `Revision` representing the edit based on the\n/// current head, a new text `Rope`, a new tombstones `Rope` and a new `deletes_from_union`.\n/// Returns an [`Error`] if `base_rev` cannot be found, or `delta.base_len`\n/// does not equal the length of the text at `base_rev`.\nfn mk_new_rev(\n        &self,\n        new_priority: usize,\n        undo_group: usize,\n        base_rev: RevToken,\n        delta: Delta<RopeInfo>,\n    ) -> Result<(Revision, Rope, Rope, Subset), Error>{\n        let ix = self.find_rev_token(base_rev).ok_or(Error::MissingRevision(base_rev))?;\n\n        let (ins_delta, deletes) = delta.factor();\n\n        // rebase delta to be on the base_rev union instead of the text\n        let deletes_at_rev = self.deletes_from_union_for_index(ix);\n\n        // validate delta\n        if ins_delta.base_len != deletes_at_rev.len_after_delete() {\n            return Err(Error::MalformedDelta {\n                delta_len: ins_delta.base_len,\n                rev_len: deletes_at_rev.len_after_delete(),\n            });\n        }\n\n        let mut union_ins_delta = ins_delta.transform_expand(&deletes_at_rev, true);\n        let mut new_deletes = deletes.transform_expand(&deletes_at_rev);\n\n        // rebase the delta to be on the head union instead of the base_rev union\n        let new_full_priority = FullPriority { priority: new_priority, session_id: self.session };\n        for r in &self.revs[ix + 1..] {\n            if let Edit { priority, ref inserts, .. } = r.edit {\n                if !inserts.is_empty() {\n                    let full_priority =\n                        FullPriority { priority, session_id: r.rev_id.session_id() };\n                    let after = new_full_priority >= full_priority; // should never be ==\n                    union_ins_delta = union_ins_delta.transform_expand(inserts, after);\n                    new_deletes = new_deletes.transform_expand(inserts);\n                }\n            }\n        }\n\n        // rebase the deletion to be after the inserts instead of directly on the head union\n        let new_inserts = union_ins_delta.inserted_subset();\n        if !new_inserts.is_empty() {\n            new_deletes = new_deletes.transform_expand(&new_inserts);\n        }\n\n        // rebase insertions on text and apply\n        let cur_deletes_from_union = &self.deletes_from_union;\n        let text_ins_delta = union_ins_delta.transform_shrink(cur_deletes_from_union);\n        let text_with_inserts = text_ins_delta.apply(&self.text);\n        let rebased_deletes_from_union = cur_deletes_from_union.transform_expand(&new_inserts);\n\n        // is the new edit in an undo group that was already undone due to concurrency?\n        let undone = self.undone_groups.contains(&undo_group);\n        let new_deletes_from_union = {\n            let to_delete = if undone { &new_inserts } else { &new_deletes };\n            rebased_deletes_from_union.union(to_delete)\n        };\n\n        // move deleted or undone-inserted things from text to tombstones\n        let (new_text, new_tombstones) = shuffle(\n            &text_with_inserts,\n            &self.tombstones,\n            &rebased_deletes_from_union,\n            &new_deletes_from_union,\n        );\n\n        let head_rev = &self.revs.last().unwrap();\n        Ok((\n            Revision {\n                rev_id: self.next_rev_id(),\n                max_undo_so_far: std::cmp::max(undo_group, head_rev.max_undo_so_far),\n                edit: Edit {\n                    priority: new_priority,\n                    undo_group,\n                    inserts: new_inserts,\n                    deletes: new_deletes,\n                },\n            },\n            new_text,\n            new_tombstones,\n            new_deletes_from_union,\n        ))\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::new":["/// Create a new Engine with a single edit that inserts `initial_contents`\n/// if it is non-empty. It needs to be a separate commit rather than just\n/// part of the initial contents since any two `Engine`s need a common\n/// ancestor in order to be mergeable.\npub fn new(initial_contents: Rope) -> Engine{\n        let mut engine = Engine::empty();\n        if !initial_contents.is_empty() {\n            let first_rev = engine.get_head_rev_id().token();\n            let delta = Delta::simple_edit(Interval::new(0, 0), initial_contents, 0);\n            engine.edit_rev(0, 0, first_rev, delta);\n        }\n        engine\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::next_rev_id":["fn next_rev_id(&self) -> RevId{\n        RevId { session1: self.session.0, session2: self.session.1, num: self.rev_id_counter }\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::rev_content_for_index":["/// Get the contents of the document at a given revision number\nfn rev_content_for_index(&self, rev_index: usize) -> Rope{\n        let old_deletes_from_union = self.deletes_from_cur_union_for_index(rev_index);\n        let delta =\n            Delta::synthesize(&self.tombstones, &self.deletes_from_union, &old_deletes_from_union);\n        delta.apply(&self.text)\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::set_session_id":["/// When merging between multiple concurrently-editing sessions, each session should have a unique ID\n/// set with this function, which will make the revisions they create not have colliding IDs.\n/// For safety, this will panic if any revisions have already been added to the Engine.\n///\n/// Merge may panic or return incorrect results if session IDs collide, which is why they can be\n/// 96 bits which is more than sufficient for this to never happen.\npub fn set_session_id(&mut self, session: SessionId){\n        assert_eq!(\n            1,\n            self.revs.len(),\n            \"Revisions were added to an Engine before set_session_id, these may collide.\"\n        );\n        self.session = session;\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::try_delta_rev_head":["/// A delta that, when applied to `base_rev`, results in the current head. Returns\n/// an error if there is not at least one edit.\npub fn try_delta_rev_head(&self, base_rev: RevToken) -> Result<Delta<RopeInfo>, Error>{\n        let ix = self.find_rev_token(base_rev).ok_or(Error::MissingRevision(base_rev))?;\n        let prev_from_union = self.deletes_from_cur_union_for_index(ix);\n        // TODO: this does 2 calls to Delta::synthesize and 1 to apply, this probably could be better.\n        let old_tombstones = shuffle_tombstones(\n            &self.text,\n            &self.tombstones,\n            &self.deletes_from_union,\n            &prev_from_union,\n        );\n        Ok(Delta::synthesize(&old_tombstones, &prev_from_union, &self.deletes_from_union))\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::try_edit_rev":["/// Attempts to apply a new edit based on the [`Revision`] specified by `base_rev`,\n/// Returning an [`Error`] if the `Revision` cannot be found.\npub fn try_edit_rev(\n        &mut self,\n        priority: usize,\n        undo_group: usize,\n        base_rev: RevToken,\n        delta: Delta<RopeInfo>,\n    ) -> Result<(), Error>{\n        let (new_rev, new_text, new_tombstones, new_deletes_from_union) =\n            self.mk_new_rev(priority, undo_group, base_rev, delta)?;\n        self.rev_id_counter += 1;\n        self.revs.push(new_rev);\n        self.text = new_text;\n        self.tombstones = new_tombstones;\n        self.deletes_from_union = new_deletes_from_union;\n        Ok(())\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Engine::undo":["pub fn undo(&mut self, groups: BTreeSet<usize>){\n        let (new_rev, new_deletes_from_union) = self.compute_undo(&groups);\n\n        let (new_text, new_tombstones) = shuffle(\n            &self.text,\n            &self.tombstones,\n            &self.deletes_from_union,\n            &new_deletes_from_union,\n        );\n\n        self.text = new_text;\n        self.tombstones = new_tombstones;\n        self.deletes_from_union = new_deletes_from_union;\n        self.undone_groups = groups;\n        self.revs.push(new_rev);\n        self.rev_id_counter += 1;\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Error":["/// Type for errors that occur during CRDT operations.\npub enum Error {\n    /// An edit specified a revision that did not exist. The revision may\n    /// have been GC'd, or it may have specified incorrectly.\n    MissingRevision(RevToken),\n    /// A delta was applied which had a `base_len` that did not match the length\n    /// of the revision it was applied to.\n    MalformedDelta { rev_len: usize, delta_len: usize },\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::FullPriority":["struct FullPriority {\n    priority: usize,\n    session_id: SessionId,\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::RevId":["pub struct RevId {\n    // 96 bits has a 10^(-12) chance of collision with 400 million sessions and 10^(-6) with 100 billion.\n    // `session1==session2==0` is reserved for initialization which is the same on all sessions.\n    // A colliding session will break merge invariants and the document will start crashing Xi.\n    session1: u64,\n    // if this was a tuple field instead of two fields, alignment padding would add 8 more bytes.\n    session2: u32,\n    // There will probably never be a document with more than 4 billion edits\n    // in a single session.\n    num: u32,\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::RevId::session_id":["pub fn session_id(&self) -> SessionId{\n        (self.session1, self.session2)\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::RevId::token":["/// Returns a u64 that will be equal for equivalent revision IDs and\n/// should be as unlikely to collide as two random u64s.\npub fn token(&self) -> RevToken{\n        use std::hash::{Hash, Hasher};\n        // Rust is unlikely to break the property that this hash is strongly collision-resistant\n        // and it only needs to be consistent over one execution.\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()\n    }","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::Revision":["struct Revision {\n    /// This uniquely represents the identity of this revision and it stays\n    /// the same even if it is rebased or merged between devices.\n    rev_id: RevId,\n    /// The largest undo group number of any edit in the history up to this\n    /// point. Used to optimize undo to not look further back.\n    max_undo_so_far: usize,\n    edit: Contents,\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::compute_deltas":["/// Transform `revs`, which doesn't include information on the actual content of the operations,\n/// into an `InsertDelta`-based representation that does by working backward from the text and tombstones.\nfn compute_deltas(\n    revs: &[Revision],\n    text: &Rope,\n    tombstones: &Rope,\n    deletes_from_union: &Subset,\n) -> Vec<DeltaOp>{\n    let mut out = Vec::with_capacity(revs.len());\n\n    let mut cur_all_inserts = Subset::new(deletes_from_union.len());\n    for rev in revs.iter().rev() {\n        match rev.edit {\n            Contents::Edit { priority, undo_group, ref inserts, ref deletes } => {\n                let older_all_inserts = inserts.transform_union(&cur_all_inserts);\n\n                // TODO could probably be more efficient by avoiding shuffling from head every time\n                let tombstones_here =\n                    shuffle_tombstones(text, tombstones, deletes_from_union, &older_all_inserts);\n                let delta =\n                    Delta::synthesize(&tombstones_here, &older_all_inserts, &cur_all_inserts);\n                // TODO create InsertDelta directly and more efficiently instead of factoring\n                let (ins, _) = delta.factor();\n                out.push(DeltaOp {\n                    rev_id: rev.rev_id,\n                    priority,\n                    undo_group,\n                    inserts: ins,\n                    deletes: deletes.clone(),\n                });\n\n                cur_all_inserts = older_all_inserts;\n            }\n            Contents::Undo { .. } => panic!(\"can't merge undo yet\"),\n        }\n    }\n\n    out.as_mut_slice().reverse();\n    out\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::compute_transforms":["/// Computes a series of priorities and transforms for the deltas on the right\n/// from the new revisions on the left.\n///\n/// Applies an optimization where it combines sequential revisions with the\n/// same priority into one transform to decrease the number of transforms that\n/// have to be considered in `rebase` substantially for normal editing\n/// patterns. Any large runs of typing in the same place by the same user (e.g\n/// typing a paragraph) will be combined into a single segment in a transform\n/// as opposed to thousands of revisions.\nfn compute_transforms(revs: Vec<Revision>) -> Vec<(FullPriority, Subset)>{\n    let mut out = Vec::new();\n    let mut last_priority: Option<usize> = None;\n    for r in revs {\n        if let Contents::Edit { priority, inserts, .. } = r.edit {\n            if inserts.is_empty() {\n                continue;\n            }\n            if Some(priority) == last_priority {\n                let last: &mut (FullPriority, Subset) = out.last_mut().unwrap();\n                last.1 = last.1.transform_union(&inserts);\n            } else {\n                last_priority = Some(priority);\n                let prio = FullPriority { priority, session_id: r.rev_id.session_id() };\n                out.push((prio, inserts));\n            }\n        }\n    }\n    out\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::default_session":["/// for single user cases, used by serde and ::empty\nfn default_session() -> (u64, u32){\n    (1, 0)\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::find_base_index":["/// Find an index before which everything is the same\nfn find_base_index(a: &[Revision], b: &[Revision]) -> usize{\n    assert!(!a.is_empty() && !b.is_empty());\n    assert!(a[0].rev_id == b[0].rev_id);\n    // TODO find the maximum base revision.\n    // this should have the same behavior, but worse performance\n    1\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::find_common":["/// Find a set of revisions common to both lists\nfn find_common(a: &[Revision], b: &[Revision]) -> BTreeSet<RevId>{\n    // TODO make this faster somehow?\n    let a_ids: BTreeSet<RevId> = a.iter().map(|r| r.rev_id).collect();\n    let b_ids: BTreeSet<RevId> = b.iter().map(|r| r.rev_id).collect();\n    a_ids.intersection(&b_ids).cloned().collect()\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::rearrange":["/// Returns the operations in `revs` that don't have their `rev_id` in\n/// `base_revs`, but modified so that they are in the same order but based on\n/// the `base_revs`. This allows the rest of the merge to operate on only\n/// revisions not shared by both sides.\n///\n/// Conceptually, see the diagram below, with `.` being base revs and `n` being\n/// non-base revs, `N` being transformed non-base revs, and rearranges it:\n/// .n..n...nn..  -> ........NNNN -> returns vec![N,N,N,N]\nfn rearrange(revs: &[Revision], base_revs: &BTreeSet<RevId>, head_len: usize) -> Vec<Revision>{\n    // transform representing the characters added by common revisions after a point.\n    let mut s = Subset::new(head_len);\n\n    let mut out = Vec::with_capacity(revs.len() - base_revs.len());\n    for rev in revs.iter().rev() {\n        let is_base = base_revs.contains(&rev.rev_id);\n        let contents = match rev.edit {\n            Contents::Edit { priority, undo_group, ref inserts, ref deletes } => {\n                if is_base {\n                    s = inserts.transform_union(&s);\n                    None\n                } else {\n                    // fast-forward this revision over all common ones after it\n                    let transformed_inserts = inserts.transform_expand(&s);\n                    let transformed_deletes = deletes.transform_expand(&s);\n                    // we don't want new revisions before this to be transformed after us\n                    s = s.transform_shrink(&transformed_inserts);\n                    Some(Contents::Edit {\n                        inserts: transformed_inserts,\n                        deletes: transformed_deletes,\n                        priority,\n                        undo_group,\n                    })\n                }\n            }\n            Contents::Undo { .. } => panic!(\"can't merge undo yet\"),\n        };\n        if let Some(edit) = contents {\n            out.push(Revision { edit, rev_id: rev.rev_id, max_undo_so_far: rev.max_undo_so_far });\n        }\n    }\n\n    out.as_mut_slice().reverse();\n    out\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::rebase":["/// Rebase `b_new` on top of `expand_by` and return revision contents that can be appended as new\n/// revisions on top of the revisions represented by `expand_by`.\nfn rebase(\n    mut expand_by: Vec<(FullPriority, Subset)>,\n    b_new: Vec<DeltaOp>,\n    mut text: Rope,\n    mut tombstones: Rope,\n    mut deletes_from_union: Subset,\n    mut max_undo_so_far: usize,\n) -> (Vec<Revision>, Rope, Rope, Subset){\n    let mut out = Vec::with_capacity(b_new.len());\n\n    let mut next_expand_by = Vec::with_capacity(expand_by.len());\n    for op in b_new {\n        let DeltaOp { rev_id, priority, undo_group, mut inserts, mut deletes } = op;\n        let full_priority = FullPriority { priority, session_id: rev_id.session_id() };\n        // expand by each in expand_by\n        for &(trans_priority, ref trans_inserts) in &expand_by {\n            let after = full_priority >= trans_priority; // should never be ==\n                                                         // d-expand by other\n            inserts = inserts.transform_expand(trans_inserts, after);\n            // trans-expand other by expanded so they have the same context\n            let inserted = inserts.inserted_subset();\n            let new_trans_inserts = trans_inserts.transform_expand(&inserted);\n            // The deletes are already after our inserts, but we need to include the other inserts\n            deletes = deletes.transform_expand(&new_trans_inserts);\n            // On the next step we want things in expand_by to have op in the context\n            next_expand_by.push((trans_priority, new_trans_inserts));\n        }\n\n        let text_inserts = inserts.transform_shrink(&deletes_from_union);\n        let text_with_inserts = text_inserts.apply(&text);\n        let inserted = inserts.inserted_subset();\n\n        let expanded_deletes_from_union = deletes_from_union.transform_expand(&inserted);\n        let new_deletes_from_union = expanded_deletes_from_union.union(&deletes);\n        let (new_text, new_tombstones) = shuffle(\n            &text_with_inserts,\n            &tombstones,\n            &expanded_deletes_from_union,\n            &new_deletes_from_union,\n        );\n\n        text = new_text;\n        tombstones = new_tombstones;\n        deletes_from_union = new_deletes_from_union;\n\n        max_undo_so_far = std::cmp::max(max_undo_so_far, undo_group);\n        out.push(Revision {\n            rev_id,\n            max_undo_so_far,\n            edit: Contents::Edit { priority, undo_group, deletes, inserts: inserted },\n        });\n\n        expand_by = next_expand_by;\n        next_expand_by = Vec::with_capacity(expand_by.len());\n    }\n\n    (out, text, tombstones, deletes_from_union)\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::shuffle":["/// Move sections from text to tombstones and vice versa based on a new and old set of deletions.\n/// Returns a tuple of a new text `Rope` and a new `Tombstones` rope described by `new_deletes_from_union`.\nfn shuffle(\n    text: &Rope,\n    tombstones: &Rope,\n    old_deletes_from_union: &Subset,\n    new_deletes_from_union: &Subset,\n) -> (Rope, Rope){\n    // Delta that deletes the right bits from the text\n    let del_delta = Delta::synthesize(tombstones, old_deletes_from_union, new_deletes_from_union);\n    let new_text = del_delta.apply(text);\n    // println!(\"shuffle: old={:?} new={:?} old_text={:?} new_text={:?} old_tombstones={:?}\",\n    //     old_deletes_from_union, new_deletes_from_union, text, new_text, tombstones);\n    (new_text, shuffle_tombstones(text, tombstones, old_deletes_from_union, new_deletes_from_union))\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"engine::shuffle_tombstones":["/// Move sections from text to tombstones and out of tombstones based on a new and old set of deletions\nfn shuffle_tombstones(\n    text: &Rope,\n    tombstones: &Rope,\n    old_deletes_from_union: &Subset,\n    new_deletes_from_union: &Subset,\n) -> Rope{\n    // Taking the complement of deletes_from_union leads to an interleaving valid for swapped text and tombstones,\n    // allowing us to use the same method to insert the text into the tombstones.\n    let inverse_tombstones_map = old_deletes_from_union.complement();\n    let move_delta =\n        Delta::synthesize(text, &inverse_tombstones_map, &new_deletes_from_union.complement());\n    move_delta.apply(tombstones)\n}","Real(LocalPath(\"rope/src/engine.rs\"))"],"find::CaseMatching":["/// A policy for case matching. There may be more choices in the future (for\n/// example, an even more forgiving mode that ignores accents, or possibly\n/// handling Unicode normalization).\npub enum CaseMatching {\n    /// Require an exact codepoint-for-codepoint match (implies case sensitivity).\n    Exact,\n    /// Case insensitive match. Guaranteed to work for the ASCII case, and\n    /// reasonably well otherwise (it is currently defined in terms of the\n    /// `to_lowercase` methods in the Rust standard library).\n    CaseInsensitive,\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::FindResult":["/// The result of a [`find`][find] operation.\n///\n/// [find]: fn.find.html\npub enum FindResult {\n    /// The pattern was found at this position.\n    Found(usize),\n    /// The pattern was not found.\n    NotFound,\n    /// The cursor has been advanced by some amount. The pattern is not\n    /// found before the new cursor, but may be at or beyond it.\n    TryAgain,\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::compare_cursor_regex":["/// Compare whether the substring beginning at the cursor location matches\n/// the provided regular expression. The substring begins at the beginning\n/// of the start of the line.\n/// If the regular expression can match multiple lines then the entire text\n/// is consumed and matched against the regular expression. Otherwise only\n/// the current line is matched. Returns the start position of the match.\npub fn compare_cursor_regex(\n    cursor: &mut Cursor<RopeInfo>,\n    lines: &mut LinesRaw,\n    pat: &str,\n    regex: &Regex,\n) -> Option<usize>{\n    let orig_position = cursor.pos();\n\n    if pat.is_empty() {\n        return Some(orig_position);\n    }\n\n    let text: Cow<str>;\n\n    if is_multiline_regex(pat) {\n        // consume all of the text if regex is multi line matching\n        text = Cow::from(String::from_iter(lines));\n    } else {\n        match lines.next() {\n            Some(line) => text = line,\n            _ => return None,\n        }\n    }\n\n    // match regex against text\n    match regex.find(&text) {\n        Some(mat) => {\n            // calculate start position based on where the match starts\n            let start_position = orig_position + mat.start();\n\n            // update cursor and set to end of match\n            let end_position = orig_position + mat.end();\n            cursor.set(end_position);\n            Some(start_position)\n        }\n        None => {\n            cursor.set(orig_position + text.len());\n            None\n        }\n    }\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::compare_cursor_str":["/// Compare whether the substring beginning at the current cursor location\n/// is equal to the provided string. Leaves the cursor at an indeterminate\n/// position on failure, but the end of the string on success. Returns the\n/// start position of the match.\npub fn compare_cursor_str(\n    cursor: &mut Cursor<RopeInfo>,\n    _lines: &mut LinesRaw,\n    mut pat: &str,\n) -> Option<usize>{\n    let start_position = cursor.pos();\n    if pat.is_empty() {\n        return Some(start_position);\n    }\n    let success_pos = cursor.pos() + pat.len();\n    while let Some((leaf, pos_in_leaf)) = cursor.get_leaf() {\n        let n = min(pat.len(), leaf.len() - pos_in_leaf);\n        if leaf.as_bytes()[pos_in_leaf..pos_in_leaf + n] != pat.as_bytes()[..n] {\n            cursor.set(start_position);\n            cursor.next::<BaseMetric>();\n            return None;\n        }\n        pat = &pat[n..];\n        if pat.is_empty() {\n            cursor.set(success_pos);\n            return Some(start_position);\n        }\n        let _ = cursor.next_leaf();\n    }\n    cursor.set(start_position);\n    cursor.next::<BaseMetric>();\n    None\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::compare_cursor_str_casei":["/// Like `compare_cursor_str` but case invariant (using to_lowercase() to\n/// normalize both strings before comparison). Returns the start position\n/// of the match.\npub fn compare_cursor_str_casei(\n    cursor: &mut Cursor<RopeInfo>,\n    _lines: &mut LinesRaw,\n    pat: &str,\n) -> Option<usize>{\n    let start_position = cursor.pos();\n    let mut pat_iter = pat.chars();\n    let mut c = pat_iter.next().unwrap();\n    loop {\n        if let Some(rope_c) = cursor.next_codepoint() {\n            for lc_c in rope_c.to_lowercase() {\n                if c != lc_c {\n                    cursor.set(start_position);\n                    cursor.next::<BaseMetric>();\n                    return None;\n                }\n                if let Some(next_c) = pat_iter.next() {\n                    c = next_c;\n                } else {\n                    return Some(start_position);\n                }\n            }\n        } else {\n            // end of string before pattern is complete\n            cursor.set(start_position);\n            cursor.next::<BaseMetric>();\n            return None;\n        }\n    }\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::find":["/// Finds a pattern string in the rope referenced by the cursor, starting at\n/// the current location of the cursor (and finding the first match). Both\n/// case sensitive and case insensitive matching is provided, controlled by\n/// the `cm` parameter. The `regex` parameter controls whether the query\n/// should be considered as a regular expression.\n///\n/// On success, the cursor is updated to immediately follow the found string.\n/// On failure, the cursor's position is indeterminate.\n///\n/// Can panic if `pat` is empty.\npub fn find(\n    cursor: &mut Cursor<RopeInfo>,\n    lines: &mut LinesRaw,\n    cm: CaseMatching,\n    pat: &str,\n    regex: Option<&Regex>,\n) -> Option<usize>{\n    match find_progress(cursor, lines, cm, pat, usize::max_value(), regex) {\n        FindResult::Found(start) => Some(start),\n        FindResult::NotFound => None,\n        FindResult::TryAgain => unreachable!(\"find_progress got stuck\"),\n    }\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::find_core":["fn find_core(\n    cursor: &mut Cursor<RopeInfo>,\n    lines: &mut LinesRaw,\n    pat: &str,\n    scanner: impl Fn(&str) -> Option<usize>,\n    matcher: impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>,\n) -> FindResult{\n    let orig_pos = cursor.pos();\n\n    // if cursor reached the end of the text then no match has been found\n    if orig_pos == cursor.total_len() {\n        return FindResult::NotFound;\n    }\n\n    if let Some((leaf, pos_in_leaf)) = cursor.get_leaf() {\n        if let Some(off) = scanner(&leaf[pos_in_leaf..]) {\n            let candidate_pos = orig_pos + off;\n            cursor.set(candidate_pos);\n            if let Some(actual_pos) = matcher(cursor, lines, pat) {\n                return FindResult::Found(actual_pos);\n            }\n        } else {\n            let _ = cursor.next_leaf();\n        }\n\n        FindResult::TryAgain\n    } else {\n        FindResult::NotFound\n    }\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::find_progress":["/// A variant of [`find`][find] that makes a bounded amount of progress, then either\n/// returns or suspends (returning `TryAgain`).\n///\n/// The `num_steps` parameter controls the number of \"steps\" processed per\n/// call. The unit of \"step\" is not formally defined but is typically\n/// scanning one leaf (using a memchr-like scan) or testing one candidate\n/// when scanning produces a result. It should be empirically tuned for a\n/// balance between overhead and impact on interactive performance, but the\n/// exact value is probably not critical.\n///\n/// [find]: fn.find.html\npub fn find_progress(\n    cursor: &mut Cursor<RopeInfo>,\n    lines: &mut LinesRaw,\n    cm: CaseMatching,\n    pat: &str,\n    num_steps: usize,\n    regex: Option<&Regex>,\n) -> FindResult{\n    // empty search string\n    if pat.is_empty() {\n        return FindResult::NotFound;\n    }\n\n    match regex {\n        Some(r) => find_progress_iter(\n            cursor,\n            lines,\n            pat,\n            |_| Some(0),\n            |cursor, lines, pat| compare_cursor_regex(cursor, lines, pat, &r),\n            num_steps,\n        ),\n        None => {\n            match cm {\n                CaseMatching::Exact => {\n                    let b = pat.as_bytes()[0];\n                    let scanner = |s: &str| memchr(b, s.as_bytes());\n                    let matcher = compare_cursor_str;\n                    find_progress_iter(cursor, lines, pat, scanner, matcher, num_steps)\n                }\n                CaseMatching::CaseInsensitive => {\n                    let pat_lower = pat.to_lowercase();\n                    let b = pat_lower.as_bytes()[0];\n                    let matcher = compare_cursor_str_casei;\n                    if b == b'i' {\n                        // 0xC4 is first utf-8 byte of 'İ'\n                        let scanner = |s: &str| memchr3(b'i', b'I', 0xC4, s.as_bytes());\n                        find_progress_iter(cursor, lines, &pat_lower, scanner, matcher, num_steps)\n                    } else if b == b'k' {\n                        // 0xE2 is first utf-8 byte of u+212A (kelvin sign)\n                        let scanner = |s: &str| memchr3(b'k', b'K', 0xE2, s.as_bytes());\n                        find_progress_iter(cursor, lines, &pat_lower, scanner, matcher, num_steps)\n                    } else if b >= b'a' && b <= b'z' {\n                        let scanner = |s: &str| memchr2(b, b - 0x20, s.as_bytes());\n                        find_progress_iter(cursor, lines, &pat_lower, scanner, matcher, num_steps)\n                    } else if b < 0x80 {\n                        let scanner = |s: &str| memchr(b, s.as_bytes());\n                        find_progress_iter(cursor, lines, &pat_lower, scanner, matcher, num_steps)\n                    } else {\n                        let c = pat.chars().next().unwrap();\n                        let scanner = |s: &str| scan_lowercase(c, s);\n                        find_progress_iter(cursor, lines, &pat_lower, scanner, matcher, num_steps)\n                    }\n                }\n            }\n        }\n    }\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::find_progress_iter":["fn find_progress_iter(\n    cursor: &mut Cursor<RopeInfo>,\n    lines: &mut LinesRaw,\n    pat: &str,\n    scanner: impl Fn(&str) -> Option<usize>,\n    matcher: impl Fn(&mut Cursor<RopeInfo>, &mut LinesRaw, &str) -> Option<usize>,\n    num_steps: usize,\n) -> FindResult{\n    for _ in 0..num_steps {\n        match find_core(cursor, lines, pat, &scanner, &matcher) {\n            FindResult::TryAgain => (),\n            result => return result,\n        }\n    }\n    FindResult::TryAgain\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::is_multiline_regex":["/// Checks if a regular expression can match multiple lines.\npub fn is_multiline_regex(regex: &str) -> bool{\n    // regex characters that match line breaks\n    // todo: currently multiline mode is ignored\n    let multiline_indicators = vec![r\"\\n\", r\"\\r\", r\"[[:space:]]\"];\n\n    multiline_indicators.iter().any(|&i| regex.contains(i))\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"find::scan_lowercase":["/// Scan for a codepoint that, after conversion to lowercase, matches the probe.\nfn scan_lowercase(probe: char, s: &str) -> Option<usize>{\n    for (i, c) in s.char_indices() {\n        if c.to_lowercase().next().unwrap() == probe {\n            return Some(i);\n        }\n    }\n    None\n}","Real(LocalPath(\"rope/src/find.rs\"))"],"interval::Interval":["/// A fancy version of Range<usize>, representing a closed-open range;\n/// the interval [5, 7) is the set {5, 6}.\n///\n/// It is an invariant that `start <= end`. An interval where `end < start` is\n/// considered empty.\npub struct Interval {\n    pub start: usize,\n    pub end: usize,\n}","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::contains":["/// the point is inside the interval\npub fn contains(&self, val: usize) -> bool{\n        self.start <= val && val < self.end\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::end":["pub fn end(&self) -> usize{\n        self.end\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::intersect":["pub fn intersect(&self, other: Interval) -> Interval{\n        let start = max(self.start, other.start);\n        let end = min(self.end, other.end);\n        Interval { start, end: max(start, end) }\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::is_after":["/// the interval is after the point (the point is before the interval)\npub fn is_after(&self, val: usize) -> bool{\n        self.start > val\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::is_before":["/// the interval is before the point (the point is after the interval)\npub fn is_before(&self, val: usize) -> bool{\n        self.end <= val\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::is_empty":["pub fn is_empty(&self) -> bool{\n        self.end <= self.start\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::new":["/// Construct a new `Interval` representing the range [start..end).\n/// It is an invariant that `start <= end`.\npub fn new(start: usize, end: usize) -> Interval{\n        debug_assert!(start <= end);\n        Interval { start, end }\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::new_closed_closed":["#[deprecated(since = \"0.3.0\", note = \"all intervals are now closed_open\")]\npub fn new_closed_closed(start: usize, end: usize) -> Interval{\n        Self::new(start, end)\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::new_closed_open":["#[deprecated(since = \"0.3.0\", note = \"all intervals are now closed_open, use Interval::new\")]\npub fn new_closed_open(start: usize, end: usize) -> Interval{\n        Self::new(start, end)\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::new_open_closed":["#[deprecated(since = \"0.3.0\", note = \"all intervals are now closed_open\")]\npub fn new_open_closed(start: usize, end: usize) -> Interval{\n        Self::new(start, end)\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::new_open_open":["#[deprecated(since = \"0.3.0\", note = \"all intervals are now closed_open\")]\npub fn new_open_open(start: usize, end: usize) -> Interval{\n        Self::new(start, end)\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::prefix":["pub fn prefix(&self, other: Interval) -> Interval{\n        Interval { start: min(self.start, other.start), end: min(self.end, other.start) }\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::size":["pub fn size(&self) -> usize{\n        self.end - self.start\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::start":["pub fn start(&self) -> usize{\n        self.start\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::start_end":["pub fn start_end(&self) -> (usize, usize){\n        (self.start, self.end)\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::suffix":["pub fn suffix(&self, other: Interval) -> Interval{\n        Interval { start: max(self.start, other.end), end: max(self.end, other.end) }\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::translate":["pub fn translate(&self, amount: usize) -> Interval{\n        Interval { start: self.start + amount, end: self.end + amount }\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::translate_neg":["pub fn translate_neg(&self, amount: usize) -> Interval{\n        debug_assert!(self.start >= amount);\n        Interval { start: self.start - amount, end: self.end - amount }\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::Interval::union":["pub fn union(&self, other: Interval) -> Interval{\n        if self.is_empty() {\n            return other;\n        }\n        if other.is_empty() {\n            return *self;\n        }\n        let start = min(self.start, other.start);\n        let end = max(self.end, other.end);\n        Interval { start, end }\n    }","Real(LocalPath(\"rope/src/interval.rs\"))"],"interval::IntervalBounds":["/// A trait for types that represent unbounded ranges; they need an explicit\n/// upper bound in order to be converted to `Interval`s.\n///\n/// This exists so that some methods that use `Interval` under the hood can\n/// accept arguments like `..` or `10..`.\n///\n/// This trait should only be used when the idea of taking all of something\n/// makes sense.\npub trait IntervalBounds {\n    fn into_interval(self, upper_bound: usize) -> Interval;\n}","Real(LocalPath(\"rope/src/interval.rs\"))"],"multiset::CountMatcher":["/// Determines which elements of a `Subset` a method applies to\n/// based on the count of the element.\npub enum CountMatcher {\n    Zero,\n    NonZero,\n    All,\n}","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::CountMatcher::matches":["fn matches(self, seg: &Segment) -> bool{\n        match self {\n            CountMatcher::Zero => (seg.count == 0),\n            CountMatcher::NonZero => (seg.count != 0),\n            CountMatcher::All => true,\n        }\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Mapper":["pub struct Mapper<'a> {\n    range_iter: RangeIter<'a>,\n    // Not actually necessary for computation, just for dynamic checking of invariant\n    last_i: usize,\n    cur_range: (usize, usize),\n    pub subset_amount_consumed: usize,\n}","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Mapper::<'a>::doc_index_to_subset":["/// Map a coordinate in the document this subset corresponds to, to a\n/// coordinate in the subset matched by the `CountMatcher`. For example,\n/// if the Subset is a set of deletions and the matcher is\n/// `CountMatcher::NonZero`, this would map indices in the union string to\n/// indices in the tombstones string.\n///\n/// Will return the closest coordinate in the subset if the index is not\n/// in the subset. If the coordinate is past the end of the subset it will\n/// return one more than the largest index in the subset (i.e the length).\n/// This behaviour is suitable for mapping closed-open intervals in a\n/// string to intervals in a subset of the string.\n///\n/// In order to guarantee good performance, this method must be called\n/// with `i` values in non-decreasing order or it will panic. This allows\n/// the total cost to be O(n) where `n = max(calls,ranges)` over all times\n/// called on a single `Mapper`.\npub fn doc_index_to_subset(&mut self, i: usize) -> usize{\n        assert!(\n            i >= self.last_i,\n            \"method must be called with i in non-decreasing order. i={}<{}=last_i\",\n            i,\n            self.last_i\n        );\n        self.last_i = i;\n\n        while i >= self.cur_range.1 {\n            self.subset_amount_consumed += self.cur_range.1 - self.cur_range.0;\n            self.cur_range = match self.range_iter.next() {\n                Some(range) => range,\n                // past the end of the subset\n                None => {\n                    // ensure we don't try to consume any more\n                    self.cur_range = (usize::max_value(), usize::max_value());\n                    return self.subset_amount_consumed;\n                }\n            }\n        }\n\n        if i >= self.cur_range.0 {\n            let dist_in_range = i - self.cur_range.0;\n            dist_in_range + self.subset_amount_consumed\n        } else {\n            // not in the subset\n            self.subset_amount_consumed\n        }\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::RangeIter":["pub struct RangeIter<'a> {\n    seg_iter: slice::Iter<'a, Segment>,\n    pub consumed: usize,\n    matcher: CountMatcher,\n}","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Segment":["struct Segment {\n    len: usize,\n    count: usize,\n}","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset":["/// Represents a multi-subset of a string, that is a subset where elements can\n/// be included multiple times. This is represented as each element of the\n/// string having a \"count\" which is the number of times that element is\n/// included in the set.\n///\n/// Internally, this is stored as a list of \"segments\" with a length and a count.\npub struct Subset {\n    /// Invariant, maintained by `SubsetBuilder`: all `Segment`s have non-zero\n    /// length, and no `Segment` has the same count as the one before it.\n    segments: Vec<Segment>,\n}","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::bitxor":["/// Compute the bitwise xor of two subsets, useful as a reversible\n/// difference. The count of an element in the result is the bitwise xor\n/// of the counts of the inputs. Unchanged segments will be 0.\n///\n/// This works like set symmetric difference when all counts are 0 or 1\n/// but it extends nicely to the case of larger counts.\npub fn bitxor(&self, other: &Subset) -> Subset{\n        let mut sb = SubsetBuilder::new();\n        for zseg in self.zip(other) {\n            sb.push_segment(zseg.len, zseg.a_count ^ zseg.b_count);\n        }\n        sb.build()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::complement":["/// Find the complement of this Subset. Every 0-count element will have a\n/// count of 1 and every non-zero element will have a count of 0.\npub fn complement(&self) -> Subset{\n        let mut sb = SubsetBuilder::new();\n        for seg in &self.segments {\n            if seg.count == 0 {\n                sb.push_segment(seg.len, 1);\n            } else {\n                sb.push_segment(seg.len, 0);\n            }\n        }\n        sb.build()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::complement_iter":["/// Convenience alias for `self.range_iter(CountMatcher::Zero)`.\n/// Semantically iterates the ranges of the complement of this `Subset`.\npub fn complement_iter(&self) -> RangeIter{\n        self.range_iter(CountMatcher::Zero)\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::count":["/// Count the total length of all the segments matching `matcher`.\npub fn count(&self, matcher: CountMatcher) -> usize{\n        self.segments.iter().filter(|seg| matcher.matches(seg)).map(|seg| seg.len).sum()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::delete_from":["/// Builds a version of `s` with all the elements in this `Subset` deleted from it.\npub fn delete_from<N: NodeInfo>(&self, s: &Node<N>) -> Node<N>{\n        let mut b = TreeBuilder::new();\n        for (beg, end) in self.range_iter(CountMatcher::Zero) {\n            s.push_subseq(&mut b, Interval::new(beg, end));\n        }\n        b.build()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::delete_from_string":["/// Mostly for testing.\npub fn delete_from_string(&self, s: &str) -> String{\n        let mut result = String::new();\n        for (b, e) in self.range_iter(CountMatcher::Zero) {\n            result.push_str(&s[b..e]);\n        }\n        result\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::is_empty":["/// Determine whether the subset is empty.\n/// In this case deleting it would do nothing.\npub fn is_empty(&self) -> bool{\n        (self.segments.is_empty()) || ((self.segments.len() == 1) && (self.segments[0].count == 0))\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::len":["/// Convenience alias for `self.count(CountMatcher::All)`\npub fn len(&self) -> usize{\n        self.count(CountMatcher::All)\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::len_after_delete":["/// The length of the resulting sequence after deleting this subset. A\n/// convenience alias for `self.count(CountMatcher::Zero)` to reduce\n/// thinking about what that means in the cases where the length after\n/// delete is what you want to know.\n///\n/// `self.delete_from_string(s).len() = self.len(s.len())`\npub fn len_after_delete(&self) -> usize{\n        self.count(CountMatcher::Zero)\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::mapper":["/// Return a `Mapper` that can be use to map coordinates in the document to coordinates\n/// in this `Subset`, but only in non-decreasing order for performance reasons.\npub fn mapper(&self, matcher: CountMatcher) -> Mapper{\n        Mapper {\n            range_iter: self.range_iter(matcher),\n            last_i: 0, // indices only need to be in non-decreasing order, not increasing\n            cur_range: (0, 0), // will immediately try to consume next range\n            subset_amount_consumed: 0,\n        }\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::new":["/// Creates an empty `Subset` of a string of length `len`\npub fn new(len: usize) -> Subset{\n        let mut sb = SubsetBuilder::new();\n        sb.pad_to_len(len);\n        sb.build()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::range_iter":["/// Return an iterator over the ranges with a count matching the `matcher`.\n/// These will often be easier to work with than raw segments.\npub fn range_iter(&self, matcher: CountMatcher) -> RangeIter{\n        RangeIter { seg_iter: self.segments.iter(), consumed: 0, matcher }\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::subtract":["/// Compute the difference of two subsets. The count of an element in the\n/// result is the subtraction of the counts of other from self.\npub fn subtract(&self, other: &Subset) -> Subset{\n        let mut sb = SubsetBuilder::new();\n        for zseg in self.zip(other) {\n            assert!(\n                zseg.a_count >= zseg.b_count,\n                \"can't subtract {} from {}\",\n                zseg.a_count,\n                zseg.b_count\n            );\n            sb.push_segment(zseg.len, zseg.a_count - zseg.b_count);\n        }\n        sb.build()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::transform":["/// Map the contents of `self` into the 0-regions of `other`.\n/// Precondition: `self.count(CountMatcher::All) == other.count(CountMatcher::Zero)`\nfn transform(&self, other: &Subset, union: bool) -> Subset{\n        let mut sb = SubsetBuilder::new();\n        let mut seg_iter = self.segments.iter();\n        let mut cur_seg = Segment { len: 0, count: 0 };\n        for oseg in &other.segments {\n            if oseg.count > 0 {\n                sb.push_segment(oseg.len, if union { oseg.count } else { 0 });\n            } else {\n                // fill 0-region with segments from self.\n                let mut to_be_consumed = oseg.len;\n                while to_be_consumed > 0 {\n                    if cur_seg.len == 0 {\n                        cur_seg = seg_iter\n                            .next()\n                            .expect(\"self must cover all 0-regions of other\")\n                            .clone();\n                    }\n                    // consume as much of the segment as possible and necessary\n                    let to_consume = cmp::min(cur_seg.len, to_be_consumed);\n                    sb.push_segment(to_consume, cur_seg.count);\n                    to_be_consumed -= to_consume;\n                    cur_seg.len -= to_consume;\n                }\n            }\n        }\n        assert_eq!(cur_seg.len, 0, \"the 0-regions of other must be the size of self\");\n        assert_eq!(seg_iter.next(), None, \"the 0-regions of other must be the size of self\");\n        sb.build()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::transform_expand":["/// Transform through coordinate transform represented by other.\n/// The equation satisfied is as follows:\n///\n/// s1 = other.delete_from_string(s0)\n///\n/// s2 = self.delete_from_string(s1)\n///\n/// element in self.transform_expand(other).delete_from_string(s0) if (not in s1) or in s2\npub fn transform_expand(&self, other: &Subset) -> Subset{\n        self.transform(other, false)\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::transform_shrink":["/// Transform subset through other coordinate transform, shrinking.\n/// The following equation is satisfied:\n///\n/// C = A.transform_expand(B)\n///\n/// B.transform_shrink(C).delete_from_string(C.delete_from_string(s)) =\n///   A.delete_from_string(B.delete_from_string(s))\npub fn transform_shrink(&self, other: &Subset) -> Subset{\n        let mut sb = SubsetBuilder::new();\n        // discard ZipSegments where the shrinking set has positive count\n        for zseg in self.zip(other) {\n            // TODO: should this actually do something like subtract counts?\n            if zseg.b_count == 0 {\n                sb.push_segment(zseg.len, zseg.a_count);\n            }\n        }\n        sb.build()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::transform_union":["/// The same as taking transform_expand and then unioning with `other`.\npub fn transform_union(&self, other: &Subset) -> Subset{\n        self.transform(other, true)\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::union":["/// Compute the union of two subsets. The count of an element in the\n/// result is the sum of the counts in the inputs.\npub fn union(&self, other: &Subset) -> Subset{\n        let mut sb = SubsetBuilder::new();\n        for zseg in self.zip(other) {\n            sb.push_segment(zseg.len, zseg.a_count + zseg.b_count);\n        }\n        sb.build()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::Subset::zip":["/// Return an iterator over `ZipSegment`s where each `ZipSegment` contains\n/// the count for both self and other in that range. The two `Subset`s\n/// must have the same total length.\n///\n/// Each returned `ZipSegment` will differ in at least one count.\npub fn zip<'a>(&'a self, other: &'a Subset) -> ZipIter<'a>{\n        ZipIter {\n            a_segs: self.segments.as_slice(),\n            b_segs: other.segments.as_slice(),\n            a_i: 0,\n            b_i: 0,\n            a_consumed: 0,\n            b_consumed: 0,\n            consumed: 0,\n        }\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::SubsetBuilder":["pub struct SubsetBuilder {\n    segments: Vec<Segment>,\n    total_len: usize,\n}","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::SubsetBuilder::add_range":["/// Sets the count for a given range. This method must be called with a\n/// non-empty range with `begin` not before the largest range or segment added\n/// so far. Gaps will be filled with a 0-count segment.\npub fn add_range(&mut self, begin: usize, end: usize, count: usize){\n        assert!(begin >= self.total_len, \"ranges must be added in non-decreasing order\");\n        // assert!(begin < end, \"ranges added must be non-empty: [{},{})\", begin, end);\n        if begin >= end {\n            return;\n        }\n        let len = end - begin;\n        let cur_total_len = self.total_len;\n\n        // add 0-count segment to fill any gap\n        if begin > self.total_len {\n            self.push_segment(begin - cur_total_len, 0);\n        }\n\n        self.push_segment(len, count);\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::SubsetBuilder::build":["pub fn build(self) -> Subset{\n        Subset { segments: self.segments }\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::SubsetBuilder::new":["pub fn new() -> SubsetBuilder{\n        SubsetBuilder::default()\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::SubsetBuilder::pad_to_len":["/// Intended for use with `add_range` to ensure the total length of the\n/// `Subset` corresponds to the document length.\npub fn pad_to_len(&mut self, total_len: usize){\n        if total_len > self.total_len {\n            let cur_len = self.total_len;\n            self.push_segment(total_len - cur_len, 0);\n        }\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::SubsetBuilder::push_segment":["/// Assign `count` to the next `len` elements in the string.\n/// Will panic if called with `len==0`.\npub fn push_segment(&mut self, len: usize, count: usize){\n        assert!(len > 0, \"can't push empty segment\");\n        self.total_len += len;\n\n        // merge into previous segment if possible\n        if let Some(last) = self.segments.last_mut() {\n            if last.count == count {\n                last.len += len;\n                return;\n            }\n        }\n\n        self.segments.push(Segment { len, count });\n    }","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::ZipIter":["/// See `Subset::zip`\npub struct ZipIter<'a> {\n    a_segs: &'a [Segment],\n    b_segs: &'a [Segment],\n    a_i: usize,\n    b_i: usize,\n    a_consumed: usize,\n    b_consumed: usize,\n    pub consumed: usize,\n}","Real(LocalPath(\"rope/src/multiset.rs\"))"],"multiset::ZipSegment":["/// See `Subset::zip`\npub struct ZipSegment {\n    len: usize,\n    a_count: usize,\n    b_count: usize,\n}","Real(LocalPath(\"rope/src/multiset.rs\"))"],"rope::<impl std::convert::From<&'a tree::Node<rope::RopeInfo>> for std::string::String>::from":["fn from(r: &Rope) -> String{\n        r.slice_to_cow(..).into_owned()\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from":["fn from(s: T) -> Rope{\n        Rope::from_str(s.as_ref()).unwrap()\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl std::convert::From<tree::Node<rope::RopeInfo>> for std::string::String>::from":["fn from(r: Rope) -> String{\n        String::from(&r)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl std::fmt::Debug for tree::Node<rope::RopeInfo>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if f.alternate() {\n            write!(f, \"{}\", String::from(self))\n        } else {\n            write!(f, \"Rope({:?})\", String::from(self))\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl std::fmt::Display for tree::Node<rope::RopeInfo>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        for s in self.iter_chunks(..) {\n            write!(f, \"{}\", s)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl std::ops::Add for tree::Node<rope::RopeInfo>>::add":["fn add(self, rhs: Rope) -> Rope{\n        let mut b = TreeBuilder::new();\n        b.push(self);\n        b.push(rhs);\n        b.build()\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl std::str::FromStr for tree::Node<rope::RopeInfo>>::from_str":["fn from_str(s: &str) -> Result<Rope, Self::Err>{\n        let mut b = TreeBuilder::new();\n        b.push_str(s);\n        Ok(b.build())\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_codepoint":["/// Get next codepoint after cursor position, and advance cursor.\npub fn next_codepoint(&mut self) -> Option<char>{\n        if let Some((l, offset)) = self.get_leaf() {\n            self.next::<BaseMetric>();\n            l[offset..].chars().next()\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_grapheme":["pub fn next_grapheme(&mut self) -> Option<usize>{\n        let (mut l, mut offset) = self.get_leaf()?;\n        let mut pos = self.pos();\n        while offset < l.len() && !l.is_char_boundary(offset) {\n            pos -= 1;\n            offset -= 1;\n        }\n        let mut leaf_offset = pos - offset;\n        let mut c = GraphemeCursor::new(pos, self.total_len(), true);\n        let mut next_boundary = c.next_boundary(&l, leaf_offset);\n        while let Err(incomp) = next_boundary {\n            if let GraphemeIncomplete::PreContext(_) = incomp {\n                let (pl, poffset) = self.prev_leaf()?;\n                c.provide_context(&pl, self.pos() - poffset);\n            } else if incomp == GraphemeIncomplete::NextChunk {\n                self.set(pos);\n                let (nl, noffset) = self.next_leaf()?;\n                l = nl;\n                leaf_offset = self.pos() - noffset;\n                pos = leaf_offset + nl.len();\n            } else {\n                return None;\n            }\n            next_boundary = c.next_boundary(&l, leaf_offset);\n        }\n        next_boundary.unwrap_or(None)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint":["/// Get the next codepoint after the cursor position, without advancing\n/// the cursor.\npub fn peek_next_codepoint(&self) -> Option<char>{\n        self.get_leaf().and_then(|(l, off)| l[off..].chars().next())\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint":["/// Get previous codepoint before cursor position, and advance cursor backwards.\npub fn prev_codepoint(&mut self) -> Option<char>{\n        self.prev::<BaseMetric>();\n        if let Some((l, offset)) = self.get_leaf() {\n            l[offset..].chars().next()\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme":["pub fn prev_grapheme(&mut self) -> Option<usize>{\n        let (mut l, mut offset) = self.get_leaf()?;\n        let mut pos = self.pos();\n        while offset < l.len() && !l.is_char_boundary(offset) {\n            pos += 1;\n            offset += 1;\n        }\n        let mut leaf_offset = pos - offset;\n        let mut c = GraphemeCursor::new(pos, l.len() + leaf_offset, true);\n        let mut prev_boundary = c.prev_boundary(&l, leaf_offset);\n        while let Err(incomp) = prev_boundary {\n            if let GraphemeIncomplete::PreContext(_) = incomp {\n                let (pl, poffset) = self.prev_leaf()?;\n                c.provide_context(&pl, self.pos() - poffset);\n            } else if incomp == GraphemeIncomplete::PrevChunk {\n                self.set(pos);\n                let (pl, poffset) = self.prev_leaf()?;\n                l = pl;\n                leaf_offset = self.pos() - poffset;\n                pos = leaf_offset + pl.len();\n            } else {\n                return None;\n            }\n            prev_boundary = c.prev_boundary(&l, leaf_offset);\n        }\n        prev_boundary.unwrap_or(None)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Leaf for std::string::String>::is_ok_child":["fn is_ok_child(&self) -> bool{\n        self.len() >= MIN_LEAF\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Leaf for std::string::String>::len":["fn len(&self) -> usize{\n        self.len()\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Leaf for std::string::String>::push_maybe_split":["fn push_maybe_split(&mut self, other: &String, iv: Interval) -> Option<String>{\n        //println!(\"push_maybe_split [{}] [{}] {:?}\", self, other, iv);\n        let (start, end) = iv.start_end();\n        self.push_str(&other[start..end]);\n        if self.len() <= MAX_LEAF {\n            None\n        } else {\n            let splitpoint = find_leaf_split_for_merge(self);\n            let right_str = self[splitpoint..].to_owned();\n            self.truncate(splitpoint);\n            self.shrink_to_fit();\n            Some(right_str)\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary":["/// Returns `offset` if it lies on a codepoint boundary. Otherwise returns\n/// the codepoint after `offset`.\npub fn at_or_next_codepoint_boundary(&self, offset: usize) -> Option<usize>{\n        if self.is_codepoint_boundary(offset) {\n            Some(offset)\n        } else {\n            self.next_codepoint_offset(offset)\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary":["/// Returns `offset` if it lies on a codepoint boundary. Otherwise returns\n/// the codepoint before `offset`.\npub fn at_or_prev_codepoint_boundary(&self, offset: usize) -> Option<usize>{\n        if self.is_codepoint_boundary(offset) {\n            Some(offset)\n        } else {\n            self.prev_codepoint_offset(offset)\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::byte_at":["pub fn byte_at(&self, offset: usize) -> u8{\n        let cursor = Cursor::new(self, offset);\n        let (leaf, pos) = cursor.get_leaf().unwrap();\n        leaf.as_bytes()[pos]\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::edit_str":["/// Edit the string, replacing the byte range [`start`..`end`] with `new`.\n///\n/// Time complexity: O(log n)\n#[deprecated(since = \"0.3.0\", note = \"Use Rope::edit instead\")]\npub fn edit_str<T: IntervalBounds>(&mut self, iv: T, new: &str){\n        self.edit(iv, new)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::is_codepoint_boundary":["/// Determine whether `offset` lies on a codepoint boundary.\npub fn is_codepoint_boundary(&self, offset: usize) -> bool{\n        let mut cursor = Cursor::new(self, offset);\n        cursor.is_boundary::<BaseMetric>()\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks":["/// Returns an iterator over chunks of the rope.\n///\n/// Each chunk is a `&str` slice borrowed from the rope's storage. The size\n/// of the chunks is indeterminate but for large strings will generally be\n/// in the range of 511-1024 bytes.\n///\n/// The empty string will yield a single empty slice. In all other cases, the\n/// slices will be nonempty.\n///\n/// Time complexity: technically O(n log n), but the constant factor is so\n/// tiny it is effectively O(n). This iterator does not allocate.\npub fn iter_chunks<T: IntervalBounds>(&self, range: T) -> ChunkIter{\n        let Interval { start, end } = range.into_interval(self.len());\n\n        ChunkIter { cursor: Cursor::new(self, start), end }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::line_of_offset":["/// Return the line number corresponding to the byte index `offset`.\n///\n/// The line number is 0-based, thus this is equivalent to the count of newlines\n/// in the slice up to `offset`.\n///\n/// Time complexity: O(log n)\n///\n/// # Panics\n///\n/// This function will panic if `offset > self.len()`. Callers are expected to\n/// validate their input.\npub fn line_of_offset(&self, offset: usize) -> usize{\n        self.count::<LinesMetric>(offset)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::lines":["/// An iterator over the lines of a rope.\n///\n/// Lines are ended with either Unix (`\\n`) or MS-DOS (`\\r\\n`) style line endings.\n/// The line ending is stripped from the resulting string. The final line ending\n/// is optional.\n///\n/// The return type is a `Cow<str>`, and in most cases the lines are slices borrowed\n/// from the rope.\n///\n/// The semantics are intended to match `str::lines()`.\npub fn lines<T: IntervalBounds>(&self, range: T) -> Lines{\n        Lines { inner: self.lines_raw(range) }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::lines_raw":["/// An iterator over the raw lines. The lines, except the last, include the\n/// terminating newline.\n///\n/// The return type is a `Cow<str>`, and in most cases the lines are slices\n/// borrowed from the rope.\npub fn lines_raw<T: IntervalBounds>(&self, range: T) -> LinesRaw{\n        LinesRaw { inner: self.iter_chunks(range), fragment: \"\" }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::next_codepoint_offset":["/// Return the offset of the codepoint after `offset`.\npub fn next_codepoint_offset(&self, offset: usize) -> Option<usize>{\n        let mut cursor = Cursor::new(self, offset);\n        cursor.next::<BaseMetric>()\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::next_grapheme_offset":["pub fn next_grapheme_offset(&self, offset: usize) -> Option<usize>{\n        let mut cursor = Cursor::new(self, offset);\n        cursor.next_grapheme()\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::offset_of_line":["/// Return the byte offset corresponding to the line number `line`.\n/// If `line` is equal to one plus the current number of lines,\n/// this returns the offset of the end of the rope. Arguments higher\n/// than this will panic.\n///\n/// The line number is 0-based.\n///\n/// Time complexity: O(log n)\n///\n/// # Panics\n///\n/// This function will panic if `line > self.measure::<LinesMetric>() + 1`.\n/// Callers are expected to validate their input.\npub fn offset_of_line(&self, line: usize) -> usize{\n        let max_line = self.measure::<LinesMetric>() + 1;\n        match line.cmp(&max_line) {\n            Ordering::Greater => {\n                panic!(\"line number {} beyond last line {}\", line, max_line);\n            }\n            Ordering::Equal => {\n                return self.len();\n            }\n            Ordering::Less => self.count_base_units::<LinesMetric>(line),\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::prev_codepoint_offset":["/// Return the offset of the codepoint before `offset`.\npub fn prev_codepoint_offset(&self, offset: usize) -> Option<usize>{\n        let mut cursor = Cursor::new(self, offset);\n        cursor.prev::<BaseMetric>()\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::prev_grapheme_offset":["pub fn prev_grapheme_offset(&self, offset: usize) -> Option<usize>{\n        let mut cursor = Cursor::new(self, offset);\n        cursor.prev_grapheme()\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::slice":["/// Returns a new Rope with the contents of the provided range.\npub fn slice<T: IntervalBounds>(&self, iv: T) -> Rope{\n        self.subseq(iv)\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow":["pub fn slice_to_cow<T: IntervalBounds>(&self, range: T) -> Cow<str>{\n        let mut iter = self.iter_chunks(range);\n        let first = iter.next();\n        let second = iter.next();\n\n        match (first, second) {\n            (None, None) => Cow::from(\"\"),\n            (Some(s), None) => Cow::from(s),\n            (Some(one), Some(two)) => {\n                let mut result = [one, two].concat();\n                for chunk in iter {\n                    result.push_str(chunk);\n                }\n                Cow::from(result)\n            }\n            (None, Some(_)) => unreachable!(),\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::<impl tree::TreeBuilder<rope::RopeInfo>>::push_str":["/// Push a string on the accumulating tree in the naive way.\n///\n/// Splits the provided string in chunks that fit in a leaf\n/// and pushes the leaves one by one onto the tree by calling\n/// `push_leaf` on the builder.\npub fn push_str(&mut self, mut s: &str){\n        if s.len() <= MAX_LEAF {\n            if !s.is_empty() {\n                self.push_leaf(s.to_owned());\n            }\n            return;\n        }\n        while !s.is_empty() {\n            let splitpoint = if s.len() > MAX_LEAF { find_leaf_split_for_bulk(s) } else { s.len() };\n            self.push_leaf(s[..splitpoint].to_owned());\n            s = &s[splitpoint..];\n        }\n    }","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::BaseMetric":["/// This metric let us walk utf8 text by code point.\n///\n/// `BaseMetric` implements the trait [Metric].  Both its _measured unit_ and\n/// its _base unit_ are utf8 code unit.\n///\n/// Offsets that do not correspond to codepoint boundaries are _invalid_, and\n/// calling functions that assume valid offsets with invalid offets will panic\n/// in debug mode.\n///\n/// Boundary is atomic and determined by codepoint boundary.  Atomicity is\n/// implicit, because offsets between two utf8 code units that form a code\n/// point is considered invalid. For example, if a string starts with a\n/// 0xC2 byte, then `offset=1` is invalid.\npub struct BaseMetric(());","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::ChunkIter":["pub struct ChunkIter<'a> {\n    cursor: Cursor<'a, RopeInfo>,\n    end: usize,\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::Lines":["pub struct Lines<'a> {\n    inner: LinesRaw<'a>,\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::LinesMetric":["pub struct LinesMetric(usize);","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::LinesRaw":["pub struct LinesRaw<'a> {\n    inner: ChunkIter<'a>,\n    fragment: &'a str,\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::RopeInfo":["pub struct RopeInfo {\n    lines: usize,\n    utf16_size: usize,\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::Utf16CodeUnitsMetric":["pub struct Utf16CodeUnitsMetric(usize);","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::count_newlines":["pub fn count_newlines(s: &str) -> usize{\n    bytecount::count(s.as_bytes(), b'\\n')\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::count_utf16_code_units":["fn count_utf16_code_units(s: &str) -> usize{\n    let mut utf16_count = 0;\n    for &b in s.as_bytes() {\n        if (b as i8) >= -0x40 {\n            utf16_count += 1;\n        }\n        if b >= 0xf0 {\n            utf16_count += 1;\n        }\n    }\n    utf16_count\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::cow_append":["fn cow_append<'a>(a: Cow<'a, str>, b: &'a str) -> Cow<'a, str>{\n    if a.is_empty() {\n        Cow::from(b)\n    } else {\n        Cow::from(a.into_owned() + b)\n    }\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::find_leaf_split":["fn find_leaf_split(s: &str, minsplit: usize) -> usize{\n    let mut splitpoint = min(MAX_LEAF, s.len() - MIN_LEAF);\n    match memrchr(b'\\n', &s.as_bytes()[minsplit - 1..splitpoint]) {\n        Some(pos) => minsplit + pos,\n        None => {\n            while !s.is_char_boundary(splitpoint) {\n                splitpoint -= 1;\n            }\n            splitpoint\n        }\n    }\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::find_leaf_split_for_bulk":["fn find_leaf_split_for_bulk(s: &str) -> usize{\n    find_leaf_split(s, MIN_LEAF)\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::find_leaf_split_for_merge":["fn find_leaf_split_for_merge(s: &str) -> usize{\n    find_leaf_split(s, max(MIN_LEAF, s.len() - MAX_LEAF))\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"rope::len_utf8_from_first_byte":["/// Given the inital byte of a UTF-8 codepoint, returns the number of\n/// bytes required to represent the codepoint.\n/// RFC reference : https://tools.ietf.org/html/rfc3629#section-4\npub fn len_utf8_from_first_byte(b: u8) -> usize{\n    match b {\n        b if b < 0x80 => 1,\n        b if b < 0xe0 => 2,\n        b if b < 0xf0 => 3,\n        _ => 4,\n    }\n}","Real(LocalPath(\"rope/src/rope.rs\"))"],"spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let strs =\n            self.iter().map(|(iv, val)| format!(\"{}: {:?}\", iv, val)).collect::<Vec<String>>();\n        write!(f, \"len: {}\\nspans:\\n\\t{}\", self.len(), &strs.join(\"\\n\\t\"))\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape":["/// Applies a generic delta to `self`, inserting empty spans for any\n/// added regions.\n///\n/// This is intended to be used to keep spans up to date with a `Rope`\n/// as edits occur.\npub fn apply_shape<M: NodeInfo>(&mut self, delta: &Delta<M>){\n        let mut b = TreeBuilder::new();\n        for elem in &delta.els {\n            match *elem {\n                DeltaElement::Copy(beg, end) => b.push(self.subseq(Interval::new(beg, end))),\n                DeltaElement::Insert(ref n) => b.push(SpansBuilder::new(n.len()).build()),\n            }\n        }\n        *self = b.build();\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after":["/// Deletes all spans that intersect with `interval` and that come after.\npub fn delete_after(&mut self, interval: Interval){\n        let mut builder = SpansBuilder::new(self.len());\n\n        for (iv, data) in self.iter() {\n            // check if spans overlaps with interval\n            if iv.intersect(interval).is_empty() {\n                // keep the ones that are not overlapping\n                builder.add_span(iv, data.clone());\n            } else {\n                // all remaining spans are invalid\n                break;\n            }\n        }\n        *self = builder.build();\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::iter":["pub fn iter(&self) -> SpanIter<T>{\n        SpanIter { cursor: Cursor::new(self, 0), ix: 0 }\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::merge":["/// Creates a new Spans instance by merging spans from `other` with `self`,\n/// using a closure to transform values.\n///\n/// New spans are created from non-overlapping regions of existing spans,\n/// and by combining overlapping regions into new spans. In all cases,\n/// new values are generated by calling a closure that transforms the\n/// value of the existing span or spans.\n///\n/// # Panics\n///\n/// Panics if `self` and `other` have different lengths.\n///\npub fn merge<F, O>(&self, other: &Self, mut f: F) -> Spans<O>\n    where\n        F: FnMut(&T, Option<&T>) -> O,\n        O: Clone,{\n        //TODO: confirm that this is sensible behaviour\n        assert_eq!(self.len(), other.len());\n        let mut sb = SpansBuilder::new(self.len());\n\n        // red/blue is just a better name than one/two or me/other\n        let mut iter_red = self.iter();\n        let mut iter_blue = other.iter();\n\n        let mut next_red = iter_red.next();\n        let mut next_blue = iter_blue.next();\n\n        loop {\n            // exit conditions:\n            if next_red.is_none() && next_blue.is_none() {\n                // all merged.\n                break;\n            } else if next_red.is_none() != next_blue.is_none() {\n                // one side is exhausted; append remaining items from other side.\n                let iter = if next_red.is_some() { iter_red } else { iter_blue };\n                // add this item\n                let (iv, val) = next_red.or(next_blue).unwrap();\n                sb.add_span(iv, f(val, None));\n\n                for (iv, val) in iter {\n                    sb.add_span(iv, f(val, None))\n                }\n                break;\n            }\n\n            // body:\n            let (mut red_iv, red_val) = next_red.unwrap();\n            let (mut blue_iv, blue_val) = next_blue.unwrap();\n\n            if red_iv.intersect(blue_iv).is_empty() {\n                // spans do not overlap. Add the leading span & advance that iter.\n                if red_iv.is_before(blue_iv.start()) {\n                    sb.add_span(red_iv, f(red_val, None));\n                    next_red = iter_red.next();\n                } else {\n                    sb.add_span(blue_iv, f(blue_val, None));\n                    next_blue = iter_blue.next();\n                }\n                continue;\n            }\n            assert!(!red_iv.intersect(blue_iv).is_empty());\n\n            // if these two spans do not share a start point, create a new span from\n            // the prefix of the leading span.\n            use std::cmp::Ordering;\n\n            match red_iv.start().cmp(&blue_iv.start()) {\n                Ordering::Less => {\n                    let iv = red_iv.prefix(blue_iv);\n                    sb.add_span(iv, f(red_val, None));\n                    red_iv = red_iv.suffix(iv);\n                }\n                Ordering::Greater => {\n                    let iv = blue_iv.prefix(red_iv);\n                    sb.add_span(iv, f(blue_val, None));\n                    blue_iv = blue_iv.suffix(iv);\n                }\n                Ordering::Equal => {}\n            }\n\n            assert!(red_iv.start() == blue_iv.start());\n            // create a new span by merging the overlapping regions.\n            let iv = red_iv.intersect(blue_iv);\n            assert!(!iv.is_empty());\n            sb.add_span(iv, f(red_val, Some(blue_val)));\n\n            // if an old span was consumed by this new span, advance\n            // else reuse remaining span (set next_red/blue) for the next loop iteration\n            red_iv = red_iv.suffix(iv);\n            blue_iv = blue_iv.suffix(iv);\n            assert!(red_iv.is_empty() || blue_iv.is_empty());\n\n            if red_iv.is_empty() {\n                next_red = iter_red.next();\n            } else {\n                next_red = Some((red_iv, red_val));\n            }\n\n            if blue_iv.is_empty() {\n                next_blue = iter_blue.next();\n            } else {\n                next_blue = Some((blue_iv, blue_val));\n            }\n        }\n        sb.build()\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::transform":["/// Perform operational transformation on a spans object intended to be edited into\n/// a sequence at the given offset.\npub fn transform<N: NodeInfo>(\n        &self,\n        base_start: usize,\n        base_end: usize,\n        xform: &mut Transformer<N>,\n    ) -> Self{\n        // TODO: maybe should take base as an Interval and figure out \"after\" from that\n        let new_start = xform.transform(base_start, false);\n        let new_end = xform.transform(base_end, true);\n        let mut builder = SpansBuilder::new(new_end - new_start);\n        for (iv, data) in self.iter() {\n            let start = xform.transform(iv.start() + base_start, false) - new_start;\n            let end = xform.transform(iv.end() + base_start, false) - new_start;\n            if start < end {\n                let iv = Interval::new(start, end);\n                // TODO: could imagine using a move iterator and avoiding clone, but it's not easy.\n                builder.add_span(iv, data.clone());\n            }\n        }\n        builder.build()\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::Span":["pub struct Span<T: Clone> {\n    iv: Interval,\n    data: T,\n}","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::SpanIter":["pub struct SpanIter<'a, T: 'a + Clone> {\n    cursor: Cursor<'a, SpansInfo<T>>,\n    ix: usize,\n}","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::SpansBuilder":["pub struct SpansBuilder<T: Clone> {\n    b: TreeBuilder<SpansInfo<T>>,\n    leaf: SpansLeaf<T>,\n    len: usize,\n    total_len: usize,\n}","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::SpansBuilder::<T>::add_span":["pub fn add_span<IV: IntervalBounds>(&mut self, iv: IV, data: T){\n        let iv = iv.into_interval(self.total_len);\n        if self.leaf.spans.len() == MAX_LEAF {\n            let mut leaf = mem::take(&mut self.leaf);\n            leaf.len = iv.start() - self.len;\n            self.len = iv.start();\n            self.b.push(Node::from_leaf(leaf));\n        }\n        self.leaf.spans.push(Span { iv: iv.translate_neg(self.len), data })\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::SpansBuilder::<T>::build":["pub fn build(mut self) -> Spans<T>{\n        self.leaf.len = self.total_len - self.len;\n        self.b.push(Node::from_leaf(self.leaf));\n        self.b.build()\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::SpansBuilder::<T>::new":["pub fn new(total_len: usize) -> Self{\n        SpansBuilder { b: TreeBuilder::new(), leaf: SpansLeaf::default(), len: 0, total_len }\n    }","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::SpansInfo":["pub struct SpansInfo<T> {\n    n_spans: usize,\n    iv: Interval,\n    phantom: PhantomData<T>,\n}","Real(LocalPath(\"rope/src/spans.rs\"))"],"spans::SpansLeaf":["pub struct SpansLeaf<T: Clone> {\n    len: usize, // measured in base units\n    spans: Vec<Span<T>>,\n}","Real(LocalPath(\"rope/src/spans.rs\"))"],"tree::Cursor":["/// A data structure for traversing boundaries in a tree.\n///\n/// It is designed to be efficient both for random access and for iteration. The\n/// cursor itself is agnostic to which [`Metric`] is used to determine boundaries, but\n/// the methods to find boundaries are parametrized on the [`Metric`].\n///\n/// A cursor can be valid or invalid. It is always valid when created or after\n/// [`set`](#method.set) is called, and becomes invalid after [`prev`](#method.prev)\n/// or [`next`](#method.next) fails to find a boundary.\n///\n/// [`Metric`]: struct.Metric.html\npub struct Cursor<'a, N: 'a + NodeInfo> {\n    /// The tree being traversed by this cursor.\n    root: &'a Node<N>,\n    /// The current position of the cursor.\n    ///\n    /// It is always less than or equal to the tree length.\n    position: usize,\n    /// The cache holds the tail of the path from the root to the current leaf.\n    ///\n    /// Each entry is a reference to the parent node and the index of the child. It\n    /// is stored bottom-up; `cache[0]` is the parent of the leaf and the index of\n    /// the leaf within that parent.\n    ///\n    /// The main motivation for this being a fixed-size array is to keep the cursor\n    /// an allocation-free data structure.\n    cache: [Option<(&'a Node<N>, usize)>; CURSOR_CACHE_SIZE],\n    /// The leaf containing the current position, when the cursor is valid.\n    ///\n    /// The position is only at the end of the leaf when it is at the end of the tree.\n    leaf: Option<&'a N::L>,\n    /// The offset of `leaf` within the tree.\n    offset_of_leaf: usize,\n}","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::at_or_next":["/// Returns the current position if it is a boundary in this [`Metric`],\n/// else behaves like [`next`](#method.next).\n///\n/// [`Metric`]: struct.Metric.html\npub fn at_or_next<M: Metric<N>>(&mut self) -> Option<usize>{\n        if self.is_boundary::<M>() {\n            Some(self.pos())\n        } else {\n            self.next::<M>()\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::at_or_prev":["/// Returns the current position if it is a boundary in this [`Metric`],\n/// else behaves like [`prev`](#method.prev).\n///\n/// [`Metric`]: struct.Metric.html\npub fn at_or_prev<M: Metric<N>>(&mut self) -> Option<usize>{\n        if self.is_boundary::<M>() {\n            Some(self.pos())\n        } else {\n            self.prev::<M>()\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::descend":["/// Go to the leaf containing the current position.\n///\n/// Sets `leaf` to the leaf containing `position`, and updates `cache` and\n/// `offset_of_leaf` to be consistent.\nfn descend(&mut self){\n        let mut node = self.root;\n        let mut offset = 0;\n        while node.height() > 0 {\n            let children = node.get_children();\n            let mut i = 0;\n            loop {\n                if i + 1 == children.len() {\n                    break;\n                }\n                let nextoff = offset + children[i].len();\n                if nextoff > self.position {\n                    break;\n                }\n                offset = nextoff;\n                i += 1;\n            }\n            let cache_ix = node.height() - 1;\n            if cache_ix < CURSOR_CACHE_SIZE {\n                self.cache[cache_ix] = Some((node, i));\n            }\n            node = &children[i];\n        }\n        self.leaf = Some(node.get_leaf());\n        self.offset_of_leaf = offset;\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::descend_metric":["/// Find the leaf having the given measure.\n///\n/// This function sets `self.position` to the beginning of the leaf\n/// containing the smallest offset with the given metric, and also updates\n/// state as if [`descend`](#method.descend) was called.\n///\n/// If `measure` is greater than the measure of the whole tree, then moves\n/// to the last node.\nfn descend_metric<M: Metric<N>>(&mut self, mut measure: usize){\n        let mut node = self.root;\n        let mut offset = 0;\n        while node.height() > 0 {\n            let children = node.get_children();\n            let mut i = 0;\n            loop {\n                if i + 1 == children.len() {\n                    break;\n                }\n                let child = &children[i];\n                let child_m = child.measure::<M>();\n                if child_m >= measure {\n                    break;\n                }\n                offset += child.len();\n                measure -= child_m;\n                i += 1;\n            }\n            let cache_ix = node.height() - 1;\n            if cache_ix < CURSOR_CACHE_SIZE {\n                self.cache[cache_ix] = Some((node, i));\n            }\n            node = &children[i];\n        }\n        self.leaf = Some(node.get_leaf());\n        self.position = offset;\n        self.offset_of_leaf = offset;\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::get_leaf":["/// Get the current leaf of the cursor.\n///\n/// If the cursor is valid, returns the leaf containing the current position,\n/// and the offset of the current position within the leaf. That offset is equal\n/// to the leaf length only at the end, otherwise it is less than the leaf length.\npub fn get_leaf(&self) -> Option<(&'a N::L, usize)>{\n        self.leaf.map(|l| (l, self.position - self.offset_of_leaf))\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::is_boundary":["/// Determine whether the current position is a boundary.\n///\n/// Note: the beginning and end of the tree may or may not be boundaries, depending on the\n/// metric. If the metric is not `can_fragment`, then they always are.\npub fn is_boundary<M: Metric<N>>(&mut self) -> bool{\n        if self.leaf.is_none() {\n            // not at a valid position\n            return false;\n        }\n        if self.position == self.offset_of_leaf && !M::can_fragment() {\n            return true;\n        }\n        if self.position == 0 || self.position > self.offset_of_leaf {\n            return M::is_boundary(self.leaf.unwrap(), self.position - self.offset_of_leaf);\n        }\n        // tricky case, at beginning of leaf, need to query end of previous\n        // leaf; TODO: would be nice if we could do it another way that didn't\n        // make the method &mut self.\n        let l = self.prev_leaf().unwrap().0;\n        let result = M::is_boundary(l, l.len());\n        let _ = self.next_leaf();\n        result\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::iter":["/// Returns an iterator with this cursor over the given [`Metric`].\n///\n/// # Examples:\n///\n/// ```\n/// # use xi_rope::{Cursor, LinesMetric, Rope};\n/// #\n/// let text: Rope = \"one line\\ntwo line\\nred line\\nblue\".into();\n/// let mut cursor = Cursor::new(&text, 0);\n/// let line_offsets = cursor.iter::<LinesMetric>().collect::<Vec<_>>();\n/// assert_eq!(line_offsets, vec![9, 18, 27]);\n///\n/// ```\n/// [`Metric`]: struct.Metric.html\npub fn iter<'c, M: Metric<N>>(&'c mut self) -> CursorIter<'c, 'a, N, M>{\n        CursorIter { cursor: self, _metric: PhantomData }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::last_inside_leaf":["/// Tries to find the last boundary in the leaf the cursor is currently in.\n///\n/// If the last boundary is at the end of the leaf, it is only counted if\n/// it is less than `orig_pos`.\n#[inline]\nfn last_inside_leaf<M: Metric<N>>(&mut self, orig_pos: usize) -> Option<usize>{\n        let l = self.leaf.expect(\"inconsistent, shouldn't get here\");\n        let len = l.len();\n        if self.offset_of_leaf + len < orig_pos && M::is_boundary(l, len) {\n            let _ = self.next_leaf();\n            return Some(self.position);\n        }\n        let offset_in_leaf = M::prev(l, len)?;\n        self.position = self.offset_of_leaf + offset_in_leaf;\n        Some(self.position)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::measure_leaf":["/// Returns the measure at the beginning of the leaf containing `pos`.\n///\n/// This method is O(log n) no matter the current cursor state.\nfn measure_leaf<M: Metric<N>>(&self, mut pos: usize) -> usize{\n        let mut node = self.root;\n        let mut metric = 0;\n        while node.height() > 0 {\n            for child in node.get_children() {\n                let len = child.len();\n                if pos < len {\n                    node = child;\n                    break;\n                }\n                pos -= len;\n                metric += child.measure::<M>();\n            }\n        }\n        metric\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::new":["/// Create a new cursor at the given position.\npub fn new(n: &'a Node<N>, position: usize) -> Cursor<'a, N>{\n        let mut result = Cursor {\n            root: n,\n            position,\n            cache: [None; CURSOR_CACHE_SIZE],\n            leaf: None,\n            offset_of_leaf: 0,\n        };\n        result.descend();\n        result\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::next":["/// Moves the cursor to the next boundary.\n///\n/// When there is no next boundary, returns `None` and the cursor becomes invalid.\n///\n/// Return value: the position of the boundary, if it exists.\npub fn next<M: Metric<N>>(&mut self) -> Option<usize>{\n        if self.position >= self.root.len() || self.leaf.is_none() {\n            self.leaf = None;\n            return None;\n        }\n\n        if let Some(offset) = self.next_inside_leaf::<M>() {\n            return Some(offset);\n        }\n\n        self.next_leaf()?;\n        if let Some(offset) = self.next_inside_leaf::<M>() {\n            return Some(offset);\n        }\n\n        // Leaf is 0-measure (otherwise would have already succeeded).\n        let measure = self.measure_leaf::<M>(self.position);\n        self.descend_metric::<M>(measure + 1);\n        if let Some(offset) = self.next_inside_leaf::<M>() {\n            return Some(offset);\n        }\n\n        // Not found, properly invalidate cursor.\n        self.position = self.root.len();\n        self.leaf = None;\n        None\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::next_inside_leaf":["/// Tries to find the next boundary in the leaf the cursor is currently in.\n#[inline]\nfn next_inside_leaf<M: Metric<N>>(&mut self) -> Option<usize>{\n        let l = self.leaf.expect(\"inconsistent, shouldn't get here\");\n        let offset_in_leaf = self.position - self.offset_of_leaf;\n        let offset_in_leaf = M::next(l, offset_in_leaf)?;\n        if offset_in_leaf == l.len() && self.offset_of_leaf + offset_in_leaf != self.root.len() {\n            let _ = self.next_leaf();\n        } else {\n            self.position = self.offset_of_leaf + offset_in_leaf;\n        }\n        Some(self.position)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::next_leaf":["/// Move to beginning of next leaf.\n///\n/// Return value: same as [`get_leaf`](#method.get_leaf).\npub fn next_leaf(&mut self) -> Option<(&'a N::L, usize)>{\n        let leaf = self.leaf?;\n        self.position = self.offset_of_leaf + leaf.len();\n        for i in 0..CURSOR_CACHE_SIZE {\n            if self.cache[i].is_none() {\n                // this probably can't happen\n                self.leaf = None;\n                return None;\n            }\n            let (node, j) = self.cache[i].unwrap();\n            if j + 1 < node.get_children().len() {\n                self.cache[i] = Some((node, j + 1));\n                let mut node_down = &node.get_children()[j + 1];\n                for k in (0..i).rev() {\n                    self.cache[k] = Some((node_down, 0));\n                    node_down = &node_down.get_children()[0];\n                }\n                self.leaf = Some(node_down.get_leaf());\n                self.offset_of_leaf = self.position;\n                return self.get_leaf();\n            }\n        }\n        if self.offset_of_leaf + self.leaf.unwrap().len() == self.root.len() {\n            self.leaf = None;\n            return None;\n        }\n        self.descend();\n        self.get_leaf()\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::pos":["/// Get the position of the cursor.\npub fn pos(&self) -> usize{\n        self.position\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::prev":["/// Moves the cursor to the previous boundary.\n///\n/// When there is no previous boundary, returns `None` and the cursor becomes invalid.\n///\n/// Return value: the position of the boundary, if it exists.\npub fn prev<M: Metric<N>>(&mut self) -> Option<usize>{\n        if self.position == 0 || self.leaf.is_none() {\n            self.leaf = None;\n            return None;\n        }\n        let orig_pos = self.position;\n        let offset_in_leaf = orig_pos - self.offset_of_leaf;\n        if offset_in_leaf > 0 {\n            let l = self.leaf.unwrap();\n            if let Some(offset_in_leaf) = M::prev(l, offset_in_leaf) {\n                self.position = self.offset_of_leaf + offset_in_leaf;\n                return Some(self.position);\n            }\n        }\n\n        // not in same leaf, need to scan backwards\n        self.prev_leaf()?;\n        if let Some(offset) = self.last_inside_leaf::<M>(orig_pos) {\n            return Some(offset);\n        }\n\n        // Not found in previous leaf, find using measurement.\n        let measure = self.measure_leaf::<M>(self.position);\n        if measure == 0 {\n            self.leaf = None;\n            self.position = 0;\n            return None;\n        }\n        self.descend_metric::<M>(measure);\n        self.last_inside_leaf::<M>(orig_pos)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::prev_leaf":["/// Move to beginning of previous leaf.\n///\n/// Return value: same as [`get_leaf`](#method.get_leaf).\npub fn prev_leaf(&mut self) -> Option<(&'a N::L, usize)>{\n        if self.offset_of_leaf == 0 {\n            self.leaf = None;\n            self.position = 0;\n            return None;\n        }\n        for i in 0..CURSOR_CACHE_SIZE {\n            if self.cache[i].is_none() {\n                // this probably can't happen\n                self.leaf = None;\n                return None;\n            }\n            let (node, j) = self.cache[i].unwrap();\n            if j > 0 {\n                self.cache[i] = Some((node, j - 1));\n                let mut node_down = &node.get_children()[j - 1];\n                for k in (0..i).rev() {\n                    let last_ix = node_down.get_children().len() - 1;\n                    self.cache[k] = Some((node_down, last_ix));\n                    node_down = &node_down.get_children()[last_ix];\n                }\n                let leaf = node_down.get_leaf();\n                self.leaf = Some(leaf);\n                self.offset_of_leaf -= leaf.len();\n                self.position = self.offset_of_leaf;\n                return self.get_leaf();\n            }\n        }\n        self.position = self.offset_of_leaf - 1;\n        self.descend();\n        self.position = self.offset_of_leaf;\n        self.get_leaf()\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::root":["/// Return a reference to the root node of the tree.\npub fn root(&self) -> &'a Node<N>{\n        self.root\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::set":["/// Set the position of the cursor.\n///\n/// The cursor is valid after this call.\n///\n/// Precondition: `position` is less than or equal to the length of the tree.\npub fn set(&mut self, position: usize){\n        self.position = position;\n        if let Some(l) = self.leaf {\n            if self.position >= self.offset_of_leaf && self.position < self.offset_of_leaf + l.len()\n            {\n                return;\n            }\n        }\n        // TODO: walk up tree to find leaf if nearby\n        self.descend();\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Cursor::<'a, N>::total_len":["/// The length of the tree.\npub fn total_len(&self) -> usize{\n        self.root.len()\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::CursorIter":["/// An iterator generated by a [`Cursor`], for some [`Metric`].\n///\n/// [`Cursor`]: struct.Cursor.html\n/// [`Metric`]: struct.Metric.html\npub struct CursorIter<'c, 'a: 'c, N: 'a + NodeInfo, M: 'a + Metric<N>> {\n    cursor: &'c mut Cursor<'a, N>,\n    _metric: PhantomData<&'a M>,\n}","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::CursorIter::<'c, 'a, N, M>::pos":["/// Returns the current position of the underlying [`Cursor`].\n///\n/// [`Cursor`]: struct.Cursor.html\npub fn pos(&self) -> usize{\n        self.cursor.pos()\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::DefaultMetric":["/// A trait indicating the default metric of a NodeInfo.\n///\n/// Adds quality of life functions to\n/// Node\\<N\\>, where N is a DefaultMetric.\n/// For example, [Node\\<DefaultMetric\\>.count](struct.Node.html#method.count).\npub trait DefaultMetric: NodeInfo {\n    type DefaultMetric: Metric<Self>;\n}","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Leaf":["/// A trait for the leaves of trees of type [Node](struct.Node.html).\n///\n/// Two leafs can be concatenated using `push_maybe_split`.\npub trait Leaf: Sized + Clone + Default {\n    /// Measurement of leaf in base units.\n    /// A 'base unit' refers to the smallest discrete unit\n    /// by which a given concrete type can be indexed.\n    /// Concretely, for Rust's String type the base unit is the byte.\n    fn len(&self) -> usize;\n\n    /// Generally a minimum size requirement for leaves.\n    fn is_ok_child(&self) -> bool;\n\n    /// Combine the part `other` denoted by the `Interval` `iv` into `self`,\n    /// optionly splitting off a new `Leaf` if `self` would have become too big.\n    /// Returns either `None` if no splitting was needed, or `Some(rest)` if\n    /// `rest` was split off.\n    ///\n    /// Interval is in \"base units\".  Generally implements a maximum size.\n    ///\n    /// # Invariants:\n    /// - If one or the other input is empty, then no split.\n    /// - If either input satisfies `is_ok_child`, then, on return, `self`\n    ///   satisfies this, as does the optional split.\n    fn push_maybe_split(&mut self, other: &Self, iv: Interval) -> Option<Self>;\n\n    /// Same meaning as push_maybe_split starting from an empty\n    /// leaf, but maybe can be implemented more efficiently?\n    ///\n    // TODO: remove if it doesn't pull its weight\n    fn subseq(&self, iv: Interval) -> Self {\n        let mut result = Self::default();\n        if result.push_maybe_split(self, iv).is_some() {\n            panic!(\"unexpected split\");\n        }\n        result\n    }\n}","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Leaf::subseq":["/// Same meaning as push_maybe_split starting from an empty\n/// leaf, but maybe can be implemented more efficiently?\n///\nfn subseq(&self, iv: Interval) -> Self{\n        let mut result = Self::default();\n        if result.push_maybe_split(self, iv).is_some() {\n            panic!(\"unexpected split\");\n        }\n        result\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Metric":["/// A trait for quickly processing attributes of a\n/// [NodeInfo](struct.NodeInfo.html).\n///\n/// For the conceptual background see the\n/// [blog post, Rope science, part 2: metrics](https://github.com/google/xi-editor/blob/master/docs/docs/rope_science_02.md).\npub trait Metric<N: NodeInfo> {\n    /// Return the size of the\n    /// [NodeInfo::L](trait.NodeInfo.html#associatedtype.L), as measured by this\n    /// metric.\n    ///\n    /// The usize argument is the total size/length of the node, in base units.\n    ///\n    /// # Examples\n    /// For the [LinesMetric](../rope/struct.LinesMetric.html), this gives the number of\n    /// lines in string contained in the leaf. For the\n    /// [BaseMetric](../rope/struct.BaseMetric.html), this gives the size of the string\n    /// in uft8 code units, that is, bytes.\n    ///\n    fn measure(info: &N, len: usize) -> usize;\n\n    /// Returns the smallest offset, in base units, for an offset in measured units.\n    ///\n    /// # Invariants:\n    ///\n    /// - `from_base_units(to_base_units(x)) == x` is True for valid `x`\n    fn to_base_units(l: &N::L, in_measured_units: usize) -> usize;\n\n    /// Returns the smallest offset in measured units corresponding to an offset in base units.\n    ///\n    /// # Invariants:\n    ///\n    /// - `from_base_units(to_base_units(x)) == x` is True for valid `x`\n    fn from_base_units(l: &N::L, in_base_units: usize) -> usize;\n\n    /// Return whether the offset in base units is a boundary of this metric.\n    /// If a boundary is at end of a leaf then this method must return true.\n    /// However, a boundary at the beginning of a leaf is optional\n    /// (the previous leaf will be queried).\n    fn is_boundary(l: &N::L, offset: usize) -> bool;\n\n    /// Returns the index of the boundary directly preceding offset,\n    /// or None if no such boundary exists. Input and result are in base units.\n    fn prev(l: &N::L, offset: usize) -> Option<usize>;\n\n    /// Returns the index of the first boundary for which index > offset,\n    /// or None if no such boundary exists. Input and result are in base units.\n    fn next(l: &N::L, offset: usize) -> Option<usize>;\n\n    /// Returns true if the measured units in this metric can span multiple\n    /// leaves.  As an example, in a metric that measures lines in a rope, a\n    /// line may start in one leaf and end in another; however in a metric\n    /// measuring bytes, storage of a single byte cannot extend across leaves.\n    fn can_fragment() -> bool;\n}","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node":["/// A b-tree node storing leaves at the bottom, and with info\n/// retained at each node. It is implemented with atomic reference counting\n/// and copy-on-write semantics, so an immutable clone is a very cheap\n/// operation, and nodes can be shared across threads. Even so, it is\n/// designed to be updated in place, with efficiency similar to a mutable\n/// data structure, using uniqueness of reference count to detect when\n/// this operation is safe.\n///\n/// When the leaf is a string, this is a rope data structure (a persistent\n/// rope in functional programming jargon). However, it is not restricted\n/// to strings, and it is expected to be the basis for a number of data\n/// structures useful for text processing.\npub struct Node<N: NodeInfo>(Arc<NodeBody<N>>);","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::concat":["pub fn concat(rope1: Node<N>, rope2: Node<N>) -> Node<N>{\n        let h1 = rope1.height();\n        let h2 = rope2.height();\n\n        match h1.cmp(&h2) {\n            Ordering::Less => {\n                let children2 = rope2.get_children();\n                if h1 == h2 - 1 && rope1.is_ok_child() {\n                    return Node::merge_nodes(&[rope1], children2);\n                }\n                let newrope = Node::concat(rope1, children2[0].clone());\n                if newrope.height() == h2 - 1 {\n                    Node::merge_nodes(&[newrope], &children2[1..])\n                } else {\n                    Node::merge_nodes(newrope.get_children(), &children2[1..])\n                }\n            }\n            Ordering::Equal => {\n                if rope1.is_ok_child() && rope2.is_ok_child() {\n                    return Node::from_nodes(vec![rope1, rope2]);\n                }\n                if h1 == 0 {\n                    return Node::merge_leaves(rope1, rope2);\n                }\n                Node::merge_nodes(rope1.get_children(), rope2.get_children())\n            }\n            Ordering::Greater => {\n                let children1 = rope1.get_children();\n                if h2 == h1 - 1 && rope2.is_ok_child() {\n                    return Node::merge_nodes(children1, &[rope2]);\n                }\n                let lastix = children1.len() - 1;\n                let newrope = Node::concat(children1[lastix].clone(), rope2);\n                if newrope.height() == h1 - 1 {\n                    Node::merge_nodes(&children1[..lastix], &[newrope])\n                } else {\n                    Node::merge_nodes(&children1[..lastix], newrope.get_children())\n                }\n            }\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::convert_metrics":["pub fn convert_metrics<M1: Metric<N>, M2: Metric<N>>(&self, mut m1: usize) -> usize{\n        if m1 == 0 {\n            return 0;\n        }\n        // If M1 can fragment, then we must land on the leaf containing\n        // the m1 boundary. Otherwise, we can land on the beginning of\n        // the leaf immediately following the M1 boundary, which may be\n        // more efficient.\n        let m1_fudge = if M1::can_fragment() { 1 } else { 0 };\n        let mut m2 = 0;\n        let mut node = self;\n        while node.height() > 0 {\n            for child in node.get_children() {\n                let child_m1 = child.measure::<M1>();\n                if m1 < child_m1 + m1_fudge {\n                    node = child;\n                    break;\n                }\n                m2 += child.measure::<M2>();\n                m1 -= child_m1;\n            }\n        }\n        let l = node.get_leaf();\n        let base = M1::to_base_units(l, m1);\n        m2 + M2::from_base_units(l, base)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::count":["/// Measures the length of the text bounded by ``DefaultMetric::measure(offset)`` with another metric.\n///\n/// # Examples\n/// ```\n/// use crate::xi_rope::{Rope, LinesMetric};\n///\n/// // the default metric of Rope is BaseMetric (aka number of bytes)\n/// let my_rope = Rope::from(\"first line \\n second line \\n\");\n///\n/// // count the number of lines in my_rope\n/// let num_lines = my_rope.count::<LinesMetric>(my_rope.len());\n/// assert_eq!(2, num_lines);\n/// ```\npub fn count<M: Metric<N>>(&self, offset: usize) -> usize{\n        self.convert_metrics::<N::DefaultMetric, M>(offset)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::count_base_units":["/// Measures the length of the text bounded by ``M::measure(offset)`` with the default metric.\n///\n/// # Examples\n/// ```\n/// use crate::xi_rope::{Rope, LinesMetric};\n///\n/// // the default metric of Rope is BaseMetric (aka number of bytes)\n/// let my_rope = Rope::from(\"first line \\n second line \\n\");\n///\n/// // get the byte offset of the line at index 1\n/// let byte_offset = my_rope.count_base_units::<LinesMetric>(1);\n/// assert_eq!(12, byte_offset);\n/// ```\npub fn count_base_units<M: Metric<N>>(&self, offset: usize) -> usize{\n        self.convert_metrics::<M, N::DefaultMetric>(offset)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::edit":["pub fn edit<T, IV>(&mut self, iv: IV, new: T)\n    where\n        T: Into<Node<N>>,\n        IV: IntervalBounds,{\n        let mut b = TreeBuilder::new();\n        let iv = iv.into_interval(self.len());\n        let self_iv = self.interval();\n        self.push_subseq(&mut b, self_iv.prefix(iv));\n        b.push(new.into());\n        self.push_subseq(&mut b, self_iv.suffix(iv));\n        *self = b.build();\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::from_leaf":["pub fn from_leaf(l: N::L) -> Node<N>{\n        let len = l.len();\n        let info = N::compute_info(&l);\n        Node(Arc::new(NodeBody { height: 0, len, info, val: NodeVal::Leaf(l) }))\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::from_nodes":["/// Create a node from a vec of nodes.\n///\n/// The input must satisfy the following balancing requirements:\n/// * The length of `nodes` must be <= MAX_CHILDREN and > 1.\n/// * All the nodes are the same height.\n/// * All the nodes must satisfy is_ok_child.\nfn from_nodes(nodes: Vec<Node<N>>) -> Node<N>{\n        debug_assert!(nodes.len() > 1);\n        debug_assert!(nodes.len() <= MAX_CHILDREN);\n        let height = nodes[0].0.height + 1;\n        let mut len = nodes[0].0.len;\n        let mut info = nodes[0].0.info.clone();\n        debug_assert!(nodes[0].is_ok_child());\n        for child in &nodes[1..] {\n            debug_assert_eq!(child.height() + 1, height);\n            debug_assert!(child.is_ok_child());\n            len += child.0.len;\n            info.accumulate(&child.0.info);\n        }\n        Node(Arc::new(NodeBody { height, len, info, val: NodeVal::Internal(nodes) }))\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::get_children":["fn get_children(&self) -> &[Node<N>]{\n        if let NodeVal::Internal(ref v) = self.0.val {\n            v\n        } else {\n            panic!(\"get_children called on leaf node\");\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::get_leaf":["fn get_leaf(&self) -> &N::L{\n        if let NodeVal::Leaf(ref l) = self.0.val {\n            l\n        } else {\n            panic!(\"get_leaf called on internal node\");\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::height":["fn height(&self) -> usize{\n        self.0.height\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::interval":["fn interval(&self) -> Interval{\n        self.0.info.interval(self.0.len)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::is_empty":["pub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::is_leaf":["fn is_leaf(&self) -> bool{\n        self.0.height == 0\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::is_ok_child":["fn is_ok_child(&self) -> bool{\n        match self.0.val {\n            NodeVal::Leaf(ref l) => l.is_ok_child(),\n            NodeVal::Internal(ref nodes) => (nodes.len() >= MIN_CHILDREN),\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::len":["pub fn len(&self) -> usize{\n        self.0.len\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::measure":["pub fn measure<M: Metric<N>>(&self) -> usize{\n        M::measure(&self.0.info, self.0.len)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::merge_leaves":["fn merge_leaves(mut rope1: Node<N>, rope2: Node<N>) -> Node<N>{\n        debug_assert!(rope1.is_leaf() && rope2.is_leaf());\n\n        let both_ok = rope1.get_leaf().is_ok_child() && rope2.get_leaf().is_ok_child();\n        if both_ok {\n            return Node::from_nodes(vec![rope1, rope2]);\n        }\n        match {\n            let node1 = Arc::make_mut(&mut rope1.0);\n            let leaf2 = rope2.get_leaf();\n            if let NodeVal::Leaf(ref mut leaf1) = node1.val {\n                let leaf2_iv = Interval::new(0, leaf2.len());\n                let new = leaf1.push_maybe_split(leaf2, leaf2_iv);\n                node1.len = leaf1.len();\n                node1.info = N::compute_info(leaf1);\n                new\n            } else {\n                panic!(\"merge_leaves called on non-leaf\");\n            }\n        } {\n            Some(new) => Node::from_nodes(vec![rope1, Node::from_leaf(new)]),\n            None => rope1,\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::merge_nodes":["fn merge_nodes(children1: &[Node<N>], children2: &[Node<N>]) -> Node<N>{\n        let n_children = children1.len() + children2.len();\n        if n_children <= MAX_CHILDREN {\n            Node::from_nodes([children1, children2].concat())\n        } else {\n            // Note: this leans left. Splitting at midpoint is also an option\n            let splitpoint = min(MAX_CHILDREN, n_children - MIN_CHILDREN);\n            let mut iter = children1.iter().chain(children2.iter()).cloned();\n            let left = iter.by_ref().take(splitpoint).collect();\n            let right = iter.collect();\n            let parent_nodes = vec![Node::from_nodes(left), Node::from_nodes(right)];\n            Node::from_nodes(parent_nodes)\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::ptr_eq":["/// Returns `true` if these two `Node`s share the same underlying data.\n///\n/// This is principally intended to be used by the druid crate, without needing\n/// to actually add a feature and implement druid's `Data` trait.\npub fn ptr_eq(&self, other: &Self) -> bool{\n        Arc::ptr_eq(&self.0, &other.0)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::push_subseq":["pub(crate) fn push_subseq(&self, b: &mut TreeBuilder<N>, iv: Interval){\n        if iv.is_empty() {\n            return;\n        }\n        if iv == self.interval() {\n            b.push(self.clone());\n            return;\n        }\n        match self.0.val {\n            NodeVal::Leaf(ref l) => {\n                b.push_leaf_slice(l, iv);\n            }\n            NodeVal::Internal(ref v) => {\n                let mut offset = 0;\n                for child in v {\n                    if iv.is_before(offset) {\n                        break;\n                    }\n                    let child_iv = child.interval();\n                    // easier just to use signed ints?\n                    let rec_iv = iv.intersect(child_iv.translate(offset)).translate_neg(offset);\n                    child.push_subseq(b, rec_iv);\n                    offset += child.len();\n                }\n            }\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::subseq":["pub fn subseq<T: IntervalBounds>(&self, iv: T) -> Node<N>{\n        let iv = iv.into_interval(self.len());\n        let mut b = TreeBuilder::new();\n        self.push_subseq(&mut b, iv);\n        b.build()\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::Node::<N>::with_leaf_mut":["/// Call a callback with a mutable reference to a leaf.\n///\n/// This clones the leaf if the reference is shared. It also recomputes\n/// length and info after the leaf is mutated.\nfn with_leaf_mut<T>(&mut self, f: impl FnOnce(&mut N::L) -> T) -> T{\n        let inner = Arc::make_mut(&mut self.0);\n        if let NodeVal::Leaf(ref mut l) = inner.val {\n            let result = f(l);\n            inner.len = l.len();\n            inner.info = N::compute_info(l);\n            result\n        } else {\n            panic!(\"with_leaf_mut called on internal node\");\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::NodeBody":["struct NodeBody<N: NodeInfo> {\n    height: usize,\n    len: usize,\n    info: N,\n    val: NodeVal<N>,\n}","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::NodeInfo":["pub trait NodeInfo: Clone {\n    /// The type of the leaf.\n    ///\n    /// A given `NodeInfo` is for exactly one type of leaf. That is why\n    /// the leaf type is an associated type rather than a type parameter.\n    type L: Leaf;\n\n    /// An operator that combines info from two subtrees. It is intended\n    /// (but not strictly enforced) that this operator be associative and\n    /// obey an identity property. In mathematical terms, the accumulate\n    /// method is the operation of a monoid.\n    fn accumulate(&mut self, other: &Self);\n\n    /// A mapping from a leaf into the info type. It is intended (but\n    /// not strictly enforced) that applying the accumulate method to\n    /// the info derived from two leaves gives the same result as\n    /// deriving the info from the concatenation of the two leaves. In\n    /// mathematical terms, the compute_info method is a monoid\n    /// homomorphism.\n    fn compute_info(_: &Self::L) -> Self;\n\n    /// The identity of the monoid. Need not be implemented because it\n    /// can be computed from the leaf default.\n    ///\n    /// This is here to demonstrate that this is a monoid.\n    fn identity() -> Self {\n        Self::compute_info(&Self::L::default())\n    }\n\n    /// The interval covered by the first `len` base units of this node. The\n    /// default impl is sufficient for most types, but interval trees may need\n    /// to override it.\n    fn interval(&self, len: usize) -> Interval {\n        Interval::new(0, len)\n    }\n}","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::NodeInfo::identity":["/// The identity of the monoid. Need not be implemented because it\n/// can be computed from the leaf default.\n///\n/// This is here to demonstrate that this is a monoid.\nfn identity() -> Self{\n        Self::compute_info(&Self::L::default())\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::NodeInfo::interval":["/// The interval covered by the first `len` base units of this node. The\n/// default impl is sufficient for most types, but interval trees may need\n/// to override it.\nfn interval(&self, len: usize) -> Interval{\n        Interval::new(0, len)\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::NodeVal":["enum NodeVal<N: NodeInfo> {\n    Leaf(N::L),\n    Internal(Vec<Node<N>>),\n}","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::TreeBuilder":["/// A builder for creating new trees.\npub struct TreeBuilder<N: NodeInfo> {\n    // A stack of partially built trees. These are kept in order of\n    // strictly descending height, and all vectors have a length less\n    // than MAX_CHILDREN and greater than zero.\n    //\n    // In addition, there is a balancing invariant: for each vector\n    // of length greater than one, all elements satisfy `is_ok_child`.\n    stack: Vec<Vec<Node<N>>>,\n}","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::TreeBuilder::<N>::build":["/// Build the final tree.\n///\n/// The tree is the concatenation of all the nodes and leaves that have been pushed\n/// on the builder, in order.\npub fn build(mut self) -> Node<N>{\n        if self.stack.is_empty() {\n            Node::from_leaf(N::L::default())\n        } else {\n            let mut n = self.pop();\n            while !self.stack.is_empty() {\n                n = Node::concat(self.pop(), n);\n            }\n            n\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::TreeBuilder::<N>::new":["/// A new, empty builder.\npub fn new() -> TreeBuilder<N>{\n        TreeBuilder { stack: Vec::new() }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::TreeBuilder::<N>::pop":["/// Pop the last vec-of-nodes off the stack, resulting in a node.\nfn pop(&mut self) -> Node<N>{\n        let nodes = self.stack.pop().unwrap();\n        if nodes.len() == 1 {\n            nodes.into_iter().next().unwrap()\n        } else {\n            Node::from_nodes(nodes)\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::TreeBuilder::<N>::push":["/// Append a node to the tree being built.\npub fn push(&mut self, mut n: Node<N>){\n        loop {\n            let ord = if let Some(last) = self.stack.last() {\n                last[0].height().cmp(&n.height())\n            } else {\n                Ordering::Greater\n            };\n            match ord {\n                Ordering::Less => {\n                    n = Node::concat(self.pop(), n);\n                }\n                Ordering::Equal => {\n                    let tos = self.stack.last_mut().unwrap();\n                    if tos.last().unwrap().is_ok_child() && n.is_ok_child() {\n                        tos.push(n);\n                    } else if n.height() == 0 {\n                        let iv = Interval::new(0, n.len());\n                        let new_leaf = tos\n                            .last_mut()\n                            .unwrap()\n                            .with_leaf_mut(|l| l.push_maybe_split(n.get_leaf(), iv));\n                        if let Some(new_leaf) = new_leaf {\n                            tos.push(Node::from_leaf(new_leaf));\n                        }\n                    } else {\n                        let last = tos.pop().unwrap();\n                        let children1 = last.get_children();\n                        let children2 = n.get_children();\n                        let n_children = children1.len() + children2.len();\n                        if n_children <= MAX_CHILDREN {\n                            tos.push(Node::from_nodes([children1, children2].concat()));\n                        } else {\n                            // Note: this leans left. Splitting at midpoint is also an option\n                            let splitpoint = min(MAX_CHILDREN, n_children - MIN_CHILDREN);\n                            let mut iter = children1.iter().chain(children2.iter()).cloned();\n                            let left = iter.by_ref().take(splitpoint).collect();\n                            let right = iter.collect();\n                            tos.push(Node::from_nodes(left));\n                            tos.push(Node::from_nodes(right));\n                        }\n                    }\n                    if tos.len() < MAX_CHILDREN {\n                        break;\n                    }\n                    n = self.pop()\n                }\n                Ordering::Greater => {\n                    self.stack.push(vec![n]);\n                    break;\n                }\n            }\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::TreeBuilder::<N>::push_leaf":["/// Append a single leaf.\npub fn push_leaf(&mut self, l: N::L){\n        self.push(Node::from_leaf(l))\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::TreeBuilder::<N>::push_leaf_slice":["/// Append a slice of a single leaf.\npub fn push_leaf_slice(&mut self, l: &N::L, iv: Interval){\n        self.push(Node::from_leaf(l.subseq(iv)))\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"],"tree::TreeBuilder::<N>::push_leaves":["/// Append a sequence of leaves.\npub fn push_leaves(&mut self, leaves: impl IntoIterator<Item = N::L>){\n        for leaf in leaves.into_iter() {\n            self.push(Node::from_leaf(leaf));\n        }\n    }","Real(LocalPath(\"rope/src/tree.rs\"))"]},"struct_constructor":{"&'a str":["next"],"&<N as tree::NodeInfo>::L":["get_leaf"],"&[tree::Node<N>]":["get_children"],"(&'a <N as tree::NodeInfo>::L, usize)":["get_leaf","next_leaf","prev_leaf"],"(delta::InsertDelta<N>, multiset::Subset)":["factor"],"(engine::Revision, multiset::Subset)":["compute_undo"],"(engine::Revision, tree::Node<rope::RopeInfo>, tree::Node<rope::RopeInfo>, multiset::Subset)":["mk_new_rev"],"(interval::Interval, &'a T)":["next"],"(interval::Interval, usize)":["summary"],"(std::vec::Vec<engine::Revision>, tree::Node<rope::RopeInfo>, tree::Node<rope::RopeInfo>, multiset::Subset)":["rebase"],"(tree::Node<rope::RopeInfo>, tree::Node<rope::RopeInfo>)":["shuffle"],"(u64, u32)":["default_session","session_id"],"(usize, usize)":["expand_match","find_min_diff_range","next","start_end"],"<delta::DeletionsIter<'a, N> as std::iter::Iterator>::Item":["next"],"<delta::InsertsIter<'a, N> as std::iter::Iterator>::Item":["next"],"bool":["can_fragment","contains","eq","interval_untouched","is_after","is_before","is_boundary","is_codepoint_boundary","is_empty","is_equivalent_revision","is_identity","is_leaf","is_multiline_regex","is_ok_child","is_simple_delete","matches","ptr_eq"],"breaks::BreakBuilder":["default","new"],"breaks::BreaksBaseMetric":["clone"],"breaks::BreaksInfo":["clone","compute_info"],"breaks::BreaksLeaf":["clone","default","push_maybe_split"],"breaks::BreaksMetric":["clone"],"char":["next_codepoint","peek_next_codepoint","prev_codepoint"],"compare::RopeScanner":["new"],"delta::Builder":["new"],"delta::DeletionsIter":["iter_deletions"],"delta::Delta":["build","clone","compute_delta","simple_edit","synthesize","to_delta","try_delta_rev_head"],"delta::DeltaElement":["clone"],"delta::DeltaRegion":["new"],"delta::InsertDelta":["clone","transform_expand","transform_shrink"],"delta::InsertsIter":["iter_inserts"],"delta::Transformer":["new"],"diff::DiffBuilder":["clone","default"],"diff::DiffOp":["clone"],"engine::Contents":["clone"],"engine::DeltaOp":["clone"],"engine::Engine":["empty","new"],"engine::Error":["clone"],"engine::FullPriority":["clone"],"engine::RevId":["clone","get_head_rev_id","next_rev_id"],"find::CaseMatching":["clone"],"find::FindResult":["find_core","find_progress","find_progress_iter"],"i32":["avx_compare_mask","sse_compare_mask"],"interval::Interval":["clone","from","interval","into_interval","new","new_closed_closed","new_closed_open","new_open_closed","new_open_open","translate","translate_neg"],"multiset::CountMatcher":["clone"],"multiset::Mapper":["mapper"],"multiset::RangeIter":["complement_iter","range_iter"],"multiset::Segment":["clone"],"multiset::Subset":["bitxor","build","clone","complement","empty_subset_before_first_rev","inserted_subset","new","subtract","transform","transform_expand","transform_shrink","transform_union","union"],"multiset::SubsetBuilder":["default","new"],"multiset::ZipIter":["zip"],"multiset::ZipSegment":["clone","next"],"rope::BaseMetric":["clone"],"rope::ChunkIter":["iter_chunks"],"rope::Lines":["lines"],"rope::LinesMetric":["clone"],"rope::LinesRaw":["lines_raw"],"rope::RopeInfo":["clone","compute_info","identity"],"rope::Utf16CodeUnitsMetric":["clone"],"spans::Span":["clone"],"spans::SpanIter":["iter"],"spans::SpansBuilder":["new"],"spans::SpansInfo":["clone","compute_info"],"spans::SpansLeaf":["clone","default","push_maybe_split"],"std::borrow::Cow":["deletes_from_cur_union_for_index","deletes_from_union_before_index","deletes_from_union_for_index","next","slice_to_cow"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::collections::BTreeSet":["find_common"],"std::collections::HashMap":["make_line_hashes"],"std::string::String":["delete_from_string","from","push_maybe_split"],"std::vec::Vec":["compute_deltas","get_data_cloned","longest_increasing_region_set","rearrange"],"tree::Cursor":["new"],"tree::CursorIter":["iter"],"tree::Node":["apply","build","clone","default","delete_from","from","from_leaf","from_nodes","from_str","get_rev","merge","merge_nodes","new_no_break","pop","rev_content_for_index","shuffle_tombstones","slice","subseq","transform"],"tree::NodeBody":["clone"],"tree::NodeVal":["clone"],"tree::TreeBuilder":["new"],"u64":["token"],"u8":["byte_at"],"usize":["at_or_next","at_or_prev","compare_cursor_regex","compare_cursor_str","compare_cursor_str_casei","count","count_newlines","count_utf16_code_units","end","find","find_base_index","find_first_undo_candidate_index","find_leaf_split_for_bulk","find_leaf_split_for_merge","find_rev","find_rev_token","height","inserts_len","len","len_after_delete","len_utf8_from_first_byte","max_undo_group_id","measure","ne_idx","ne_idx_avx","ne_idx_fallback","ne_idx_rev","ne_idx_rev_fallback","ne_idx_rev_sse","ne_idx_sse","new_document_len","next","next_grapheme","next_inside_leaf","non_ws_offset","pos","prev","prev_grapheme","scan_lowercase","size","start","total_element_len","total_len"]},"struct_to_trait":{"<T as interval::IntervalBounds>::T":["interval::IntervalBounds"],"breaks::BreakBuilder":["std::default::Default"],"breaks::BreaksBaseMetric":["std::clone::Clone","std::marker::Copy","tree::Metric"],"breaks::BreaksInfo":["std::clone::Clone","std::fmt::Debug","tree::DefaultMetric","tree::NodeInfo"],"breaks::BreaksLeaf":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq","tree::Leaf"],"breaks::BreaksMetric":["std::clone::Clone","std::marker::Copy","tree::Metric"],"delta::DeletionsIter":["std::iter::Iterator"],"delta::Delta":["std::clone::Clone","std::fmt::Debug"],"delta::DeltaElement":["std::clone::Clone"],"delta::DeltaRegion":["std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"delta::InsertDelta":["std::clone::Clone","std::fmt::Debug","std::ops::Deref"],"delta::InsertsIter":["std::iter::Iterator"],"diff::DiffBuilder":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"diff::DiffOp":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"diff::LineHashDiff":["diff::Diff"],"engine::Contents":["std::clone::Clone","std::fmt::Debug"],"engine::DeltaOp":["std::clone::Clone","std::fmt::Debug"],"engine::Engine":["std::fmt::Debug"],"engine::Error":["std::clone::Clone","std::error::Error","std::fmt::Debug","std::fmt::Display"],"engine::FullPriority":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"engine::RevId":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"engine::Revision":["std::fmt::Debug"],"find::CaseMatching":["std::clone::Clone","std::cmp::PartialEq","std::marker::Copy","std::marker::StructuralPartialEq"],"interval::Interval":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"multiset::CountMatcher":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"multiset::RangeIter":["std::iter::Iterator"],"multiset::Segment":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"multiset::Subset":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"multiset::SubsetBuilder":["std::default::Default"],"multiset::ZipIter":["std::iter::Iterator"],"multiset::ZipSegment":["std::clone::Clone","std::fmt::Debug"],"rope::BaseMetric":["std::clone::Clone","std::marker::Copy","tree::Metric"],"rope::ChunkIter":["std::iter::Iterator"],"rope::Lines":["std::iter::Iterator"],"rope::LinesMetric":["std::clone::Clone","std::marker::Copy","tree::Metric"],"rope::LinesRaw":["std::iter::Iterator"],"rope::Rope":["std::convert::From","std::fmt::Debug","std::fmt::Display","std::ops::Add","std::str::FromStr"],"rope::RopeInfo":["std::clone::Clone","std::marker::Copy","tree::DefaultMetric","tree::NodeInfo"],"rope::Utf16CodeUnitsMetric":["std::clone::Clone","std::marker::Copy","tree::Metric"],"spans::Span":["std::clone::Clone"],"spans::SpanIter":["std::iter::Iterator"],"spans::Spans":["std::fmt::Debug"],"spans::SpansInfo":["std::clone::Clone","tree::NodeInfo"],"spans::SpansLeaf":["std::clone::Clone","std::default::Default","tree::Leaf"],"std::ops::RangeFrom":["interval::IntervalBounds"],"std::ops::RangeFull":["interval::IntervalBounds"],"std::string::String":["std::convert::From","tree::Leaf"],"tree::CursorIter":["std::iter::Iterator"],"tree::Node":["std::clone::Clone","std::default::Default"],"tree::NodeBody":["std::clone::Clone"],"tree::NodeVal":["std::clone::Clone"]},"targets":{"<T as interval::IntervalBounds>::into_interval":["into_interval","Real(LocalPath(\"rope/src/interval.rs\"))","interval::IntervalBounds"],"<breaks::BreakBuilder as std::default::Default>::default":["default","Real(LocalPath(\"rope/src/breaks.rs\"))","std::default::Default"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment":["can_fragment","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units":["from_base_units","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary":["is_boundary","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::measure":["measure","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::next":["next","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::prev":["prev","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksBaseMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units":["to_base_units","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksInfo as tree::NodeInfo>::accumulate":["accumulate","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::NodeInfo"],"<breaks::BreaksInfo as tree::NodeInfo>::compute_info":["compute_info","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::NodeInfo"],"<breaks::BreaksLeaf as tree::Leaf>::is_ok_child":["is_ok_child","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Leaf"],"<breaks::BreaksLeaf as tree::Leaf>::len":["len","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Leaf"],"<breaks::BreaksLeaf as tree::Leaf>::push_maybe_split":["push_maybe_split","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Leaf"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::can_fragment":["can_fragment","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::from_base_units":["from_base_units","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::is_boundary":["is_boundary","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::measure":["measure","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::next":["next","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::prev":["prev","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<breaks::BreaksMetric as tree::Metric<breaks::BreaksInfo>>::to_base_units":["to_base_units","Real(LocalPath(\"rope/src/breaks.rs\"))","tree::Metric"],"<delta::DeletionsIter<'a, N> as std::iter::Iterator>::next":["next","Real(LocalPath(\"rope/src/delta.rs\"))","std::iter::Iterator"],"<delta::Delta<N> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rope/src/delta.rs\"))","std::fmt::Debug"],"<delta::InsertDelta<N> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rope/src/delta.rs\"))","std::fmt::Debug"],"<delta::InsertDelta<N> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"rope/src/delta.rs\"))","std::ops::Deref"],"<delta::InsertsIter<'a, N> as std::iter::Iterator>::next":["next","Real(LocalPath(\"rope/src/delta.rs\"))","std::iter::Iterator"],"<diff::LineHashDiff as diff::Diff<rope::RopeInfo>>::compute_delta":["compute_delta","Real(LocalPath(\"rope/src/diff.rs\"))","diff::Diff"],"<engine::Error as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rope/src/engine.rs\"))","std::fmt::Debug"],"<engine::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"rope/src/engine.rs\"))","std::fmt::Display"],"<interval::Interval as std::convert::From<std::ops::Range<usize>>>::from":["from","Real(LocalPath(\"rope/src/interval.rs\"))","std::convert::From"],"<interval::Interval as std::convert::From<std::ops::RangeInclusive<usize>>>::from":["from","Real(LocalPath(\"rope/src/interval.rs\"))","std::convert::From"],"<interval::Interval as std::convert::From<std::ops::RangeTo<usize>>>::from":["from","Real(LocalPath(\"rope/src/interval.rs\"))","std::convert::From"],"<interval::Interval as std::convert::From<std::ops::RangeToInclusive<usize>>>::from":["from","Real(LocalPath(\"rope/src/interval.rs\"))","std::convert::From"],"<interval::Interval as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rope/src/interval.rs\"))","std::fmt::Debug"],"<interval::Interval as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"rope/src/interval.rs\"))","std::fmt::Display"],"<multiset::RangeIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"rope/src/multiset.rs\"))","std::iter::Iterator"],"<multiset::Subset as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rope/src/multiset.rs\"))","std::fmt::Debug"],"<multiset::ZipIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"rope/src/multiset.rs\"))","std::iter::Iterator"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::can_fragment":["can_fragment","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::from_base_units":["from_base_units","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::is_boundary":["is_boundary","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::measure":["measure","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::next":["next","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::prev":["prev","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::BaseMetric as tree::Metric<rope::RopeInfo>>::to_base_units":["to_base_units","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::ChunkIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"rope/src/rope.rs\"))","std::iter::Iterator"],"<rope::Lines<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"rope/src/rope.rs\"))","std::iter::Iterator"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::can_fragment":["can_fragment","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::from_base_units":["from_base_units","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::is_boundary":["is_boundary","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::measure":["measure","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::next":["next","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::prev":["prev","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::LinesMetric as tree::Metric<rope::RopeInfo>>::to_base_units":["to_base_units","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::LinesRaw<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"rope/src/rope.rs\"))","std::iter::Iterator"],"<rope::RopeInfo as tree::NodeInfo>::accumulate":["accumulate","Real(LocalPath(\"rope/src/rope.rs\"))","tree::NodeInfo"],"<rope::RopeInfo as tree::NodeInfo>::compute_info":["compute_info","Real(LocalPath(\"rope/src/rope.rs\"))","tree::NodeInfo"],"<rope::RopeInfo as tree::NodeInfo>::identity":["identity","Real(LocalPath(\"rope/src/rope.rs\"))","tree::NodeInfo"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::can_fragment":["can_fragment","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::from_base_units":["from_base_units","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::is_boundary":["is_boundary","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::measure":["measure","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::next":["next","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::prev":["prev","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<rope::Utf16CodeUnitsMetric as tree::Metric<rope::RopeInfo>>::to_base_units":["to_base_units","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Metric"],"<spans::SpanIter<'a, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"rope/src/spans.rs\"))","std::iter::Iterator"],"<spans::SpansInfo<T> as tree::NodeInfo>::accumulate":["accumulate","Real(LocalPath(\"rope/src/spans.rs\"))","tree::NodeInfo"],"<spans::SpansInfo<T> as tree::NodeInfo>::compute_info":["compute_info","Real(LocalPath(\"rope/src/spans.rs\"))","tree::NodeInfo"],"<spans::SpansLeaf<T> as std::default::Default>::default":["default","Real(LocalPath(\"rope/src/spans.rs\"))","std::default::Default"],"<spans::SpansLeaf<T> as tree::Leaf>::is_ok_child":["is_ok_child","Real(LocalPath(\"rope/src/spans.rs\"))","tree::Leaf"],"<spans::SpansLeaf<T> as tree::Leaf>::len":["len","Real(LocalPath(\"rope/src/spans.rs\"))","tree::Leaf"],"<spans::SpansLeaf<T> as tree::Leaf>::push_maybe_split":["push_maybe_split","Real(LocalPath(\"rope/src/spans.rs\"))","tree::Leaf"],"<std::ops::RangeFrom<usize> as interval::IntervalBounds>::into_interval":["into_interval","Real(LocalPath(\"rope/src/interval.rs\"))","interval::IntervalBounds"],"<std::ops::RangeFull as interval::IntervalBounds>::into_interval":["into_interval","Real(LocalPath(\"rope/src/interval.rs\"))","interval::IntervalBounds"],"<tree::CursorIter<'c, 'a, N, M> as std::iter::Iterator>::next":["next","Real(LocalPath(\"rope/src/tree.rs\"))","std::iter::Iterator"],"<tree::Node<N> as std::default::Default>::default":["default","Real(LocalPath(\"rope/src/tree.rs\"))","std::default::Default"],"breaks::<impl tree::Node<breaks::BreaksInfo>>::new_no_break":["new_no_break","Real(LocalPath(\"rope/src/breaks.rs\"))",""],"breaks::BreakBuilder::add_break":["add_break","Real(LocalPath(\"rope/src/breaks.rs\"))",""],"breaks::BreakBuilder::add_no_break":["add_no_break","Real(LocalPath(\"rope/src/breaks.rs\"))",""],"breaks::BreakBuilder::build":["build","Real(LocalPath(\"rope/src/breaks.rs\"))",""],"breaks::BreakBuilder::new":["new","Real(LocalPath(\"rope/src/breaks.rs\"))",""],"breaks::BreaksLeaf::get_data_cloned":["get_data_cloned","Real(LocalPath(\"rope/src/breaks.rs\"))",""],"compare::RopeScanner::<'a>::find_min_diff_range":["find_min_diff_range","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::RopeScanner::<'a>::find_ne_char":["find_ne_char","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::RopeScanner::<'a>::find_ne_char_back":["find_ne_char_back","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::RopeScanner::<'a>::load_next_chunk":["load_next_chunk","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::RopeScanner::<'a>::load_prev_chunk":["load_prev_chunk","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::RopeScanner::<'a>::new":["new","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::avx_compare_mask":["avx_compare_mask","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::ne_idx":["ne_idx","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::ne_idx_avx":["ne_idx_avx","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::ne_idx_fallback":["ne_idx_fallback","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::ne_idx_rev":["ne_idx_rev","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::ne_idx_rev_fallback":["ne_idx_rev_fallback","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::ne_idx_rev_sse":["ne_idx_rev_sse","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::ne_idx_sse":["ne_idx_sse","Real(LocalPath(\"rope/src/compare.rs\"))",""],"compare::sse_compare_mask":["sse_compare_mask","Real(LocalPath(\"rope/src/compare.rs\"))",""],"delta::Builder::<N>::build":["build","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Builder::<N>::delete":["delete","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Builder::<N>::is_empty":["is_empty","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Builder::<N>::new":["new","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Builder::<N>::replace":["replace","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::apply":["apply","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::as_simple_insert":["as_simple_insert","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::factor":["factor","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::inserts_len":["inserts_len","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::is_identity":["is_identity","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::is_simple_delete":["is_simple_delete","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::iter_deletions":["iter_deletions","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::iter_inserts":["iter_inserts","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::new_document_len":["new_document_len","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::simple_edit":["simple_edit","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::summary":["summary","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::synthesize":["synthesize","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Delta::<N>::total_element_len":["total_element_len","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::DeltaRegion::new":["new","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::InsertDelta::<N>::inserted_subset":["inserted_subset","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::InsertDelta::<N>::transform_expand":["transform_expand","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::InsertDelta::<N>::transform_shrink":["transform_shrink","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Transformer::<'a, N>::interval_untouched":["interval_untouched","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Transformer::<'a, N>::new":["new","Real(LocalPath(\"rope/src/delta.rs\"))",""],"delta::Transformer::<'a, N>::transform":["transform","Real(LocalPath(\"rope/src/delta.rs\"))",""],"diff::DiffBuilder::copy":["copy","Real(LocalPath(\"rope/src/diff.rs\"))",""],"diff::DiffBuilder::to_delta":["to_delta","Real(LocalPath(\"rope/src/diff.rs\"))",""],"diff::expand_match":["expand_match","Real(LocalPath(\"rope/src/diff.rs\"))",""],"diff::longest_increasing_region_set":["longest_increasing_region_set","Real(LocalPath(\"rope/src/diff.rs\"))",""],"diff::make_line_hashes":["make_line_hashes","Real(LocalPath(\"rope/src/diff.rs\"))",""],"diff::non_ws_offset":["non_ws_offset","Real(LocalPath(\"rope/src/diff.rs\"))",""],"engine::Engine::compute_undo":["compute_undo","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::deletes_from_cur_union_for_index":["deletes_from_cur_union_for_index","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::deletes_from_union_before_index":["deletes_from_union_before_index","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::deletes_from_union_for_index":["deletes_from_union_for_index","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::edit_rev":["edit_rev","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::empty":["empty","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::empty_subset_before_first_rev":["empty_subset_before_first_rev","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::find_first_undo_candidate_index":["find_first_undo_candidate_index","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::find_rev":["find_rev","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::find_rev_token":["find_rev_token","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::gc":["gc","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::get_head":["get_head","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::get_head_rev_id":["get_head_rev_id","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::get_rev":["get_rev","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::is_equivalent_revision":["is_equivalent_revision","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::max_undo_group_id":["max_undo_group_id","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::merge":["merge","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::mk_new_rev":["mk_new_rev","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::new":["new","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::next_rev_id":["next_rev_id","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::rev_content_for_index":["rev_content_for_index","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::set_session_id":["set_session_id","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::try_delta_rev_head":["try_delta_rev_head","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::try_edit_rev":["try_edit_rev","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::Engine::undo":["undo","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::RevId::session_id":["session_id","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::RevId::token":["token","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::compute_deltas":["compute_deltas","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::compute_transforms":["compute_transforms","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::default_session":["default_session","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::find_base_index":["find_base_index","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::find_common":["find_common","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::rearrange":["rearrange","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::rebase":["rebase","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::shuffle":["shuffle","Real(LocalPath(\"rope/src/engine.rs\"))",""],"engine::shuffle_tombstones":["shuffle_tombstones","Real(LocalPath(\"rope/src/engine.rs\"))",""],"find::compare_cursor_regex":["compare_cursor_regex","Real(LocalPath(\"rope/src/find.rs\"))",""],"find::compare_cursor_str":["compare_cursor_str","Real(LocalPath(\"rope/src/find.rs\"))",""],"find::compare_cursor_str_casei":["compare_cursor_str_casei","Real(LocalPath(\"rope/src/find.rs\"))",""],"find::find":["find","Real(LocalPath(\"rope/src/find.rs\"))",""],"find::find_core":["find_core","Real(LocalPath(\"rope/src/find.rs\"))",""],"find::find_progress":["find_progress","Real(LocalPath(\"rope/src/find.rs\"))",""],"find::find_progress_iter":["find_progress_iter","Real(LocalPath(\"rope/src/find.rs\"))",""],"find::is_multiline_regex":["is_multiline_regex","Real(LocalPath(\"rope/src/find.rs\"))",""],"find::scan_lowercase":["scan_lowercase","Real(LocalPath(\"rope/src/find.rs\"))",""],"interval::Interval::contains":["contains","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::end":["end","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::intersect":["intersect","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::is_after":["is_after","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::is_before":["is_before","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::is_empty":["is_empty","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::new":["new","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::new_closed_closed":["new_closed_closed","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::new_closed_open":["new_closed_open","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::new_open_closed":["new_open_closed","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::new_open_open":["new_open_open","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::prefix":["prefix","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::size":["size","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::start":["start","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::start_end":["start_end","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::suffix":["suffix","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::translate":["translate","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::translate_neg":["translate_neg","Real(LocalPath(\"rope/src/interval.rs\"))",""],"interval::Interval::union":["union","Real(LocalPath(\"rope/src/interval.rs\"))",""],"multiset::CountMatcher::matches":["matches","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Mapper::<'a>::doc_index_to_subset":["doc_index_to_subset","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::bitxor":["bitxor","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::complement":["complement","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::complement_iter":["complement_iter","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::count":["count","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::delete_from":["delete_from","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::delete_from_string":["delete_from_string","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::is_empty":["is_empty","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::len":["len","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::len_after_delete":["len_after_delete","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::mapper":["mapper","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::new":["new","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::range_iter":["range_iter","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::subtract":["subtract","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::transform":["transform","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::transform_expand":["transform_expand","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::transform_shrink":["transform_shrink","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::transform_union":["transform_union","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::union":["union","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::Subset::zip":["zip","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::SubsetBuilder::add_range":["add_range","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::SubsetBuilder::build":["build","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::SubsetBuilder::new":["new","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::SubsetBuilder::pad_to_len":["pad_to_len","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"multiset::SubsetBuilder::push_segment":["push_segment","Real(LocalPath(\"rope/src/multiset.rs\"))",""],"rope::<impl std::convert::From<&'a tree::Node<rope::RopeInfo>> for std::string::String>::from":["from","Real(LocalPath(\"rope/src/rope.rs\"))","std::convert::From"],"rope::<impl std::convert::From<T> for tree::Node<rope::RopeInfo>>::from":["from","Real(LocalPath(\"rope/src/rope.rs\"))","std::convert::From"],"rope::<impl std::convert::From<tree::Node<rope::RopeInfo>> for std::string::String>::from":["from","Real(LocalPath(\"rope/src/rope.rs\"))","std::convert::From"],"rope::<impl std::fmt::Debug for tree::Node<rope::RopeInfo>>::fmt":["fmt","Real(LocalPath(\"rope/src/rope.rs\"))","std::fmt::Debug"],"rope::<impl std::fmt::Display for tree::Node<rope::RopeInfo>>::fmt":["fmt","Real(LocalPath(\"rope/src/rope.rs\"))","std::fmt::Display"],"rope::<impl std::ops::Add for tree::Node<rope::RopeInfo>>::add":["add","Real(LocalPath(\"rope/src/rope.rs\"))","std::ops::Add"],"rope::<impl std::str::FromStr for tree::Node<rope::RopeInfo>>::from_str":["from_str","Real(LocalPath(\"rope/src/rope.rs\"))","std::str::FromStr"],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_codepoint":["next_codepoint","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::next_grapheme":["next_grapheme","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::peek_next_codepoint":["peek_next_codepoint","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_codepoint":["prev_codepoint","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Cursor<'a, rope::RopeInfo>>::prev_grapheme":["prev_grapheme","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Leaf for std::string::String>::is_ok_child":["is_ok_child","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Leaf"],"rope::<impl tree::Leaf for std::string::String>::len":["len","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Leaf"],"rope::<impl tree::Leaf for std::string::String>::push_maybe_split":["push_maybe_split","Real(LocalPath(\"rope/src/rope.rs\"))","tree::Leaf"],"rope::<impl tree::Node<rope::RopeInfo>>::at_or_next_codepoint_boundary":["at_or_next_codepoint_boundary","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::at_or_prev_codepoint_boundary":["at_or_prev_codepoint_boundary","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::byte_at":["byte_at","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::edit_str":["edit_str","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::is_codepoint_boundary":["is_codepoint_boundary","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::iter_chunks":["iter_chunks","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::line_of_offset":["line_of_offset","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::lines":["lines","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::lines_raw":["lines_raw","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::next_codepoint_offset":["next_codepoint_offset","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::next_grapheme_offset":["next_grapheme_offset","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::offset_of_line":["offset_of_line","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::prev_codepoint_offset":["prev_codepoint_offset","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::prev_grapheme_offset":["prev_grapheme_offset","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::slice":["slice","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::Node<rope::RopeInfo>>::slice_to_cow":["slice_to_cow","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::<impl tree::TreeBuilder<rope::RopeInfo>>::push_str":["push_str","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::count_newlines":["count_newlines","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::count_utf16_code_units":["count_utf16_code_units","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::cow_append":["cow_append","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::find_leaf_split":["find_leaf_split","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::find_leaf_split_for_bulk":["find_leaf_split_for_bulk","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::find_leaf_split_for_merge":["find_leaf_split_for_merge","Real(LocalPath(\"rope/src/rope.rs\"))",""],"rope::len_utf8_from_first_byte":["len_utf8_from_first_byte","Real(LocalPath(\"rope/src/rope.rs\"))",""],"spans::<impl std::fmt::Debug for tree::Node<spans::SpansInfo<T>>>::fmt":["fmt","Real(LocalPath(\"rope/src/spans.rs\"))","std::fmt::Debug"],"spans::<impl tree::Node<spans::SpansInfo<T>>>::apply_shape":["apply_shape","Real(LocalPath(\"rope/src/spans.rs\"))",""],"spans::<impl tree::Node<spans::SpansInfo<T>>>::delete_after":["delete_after","Real(LocalPath(\"rope/src/spans.rs\"))",""],"spans::<impl tree::Node<spans::SpansInfo<T>>>::iter":["iter","Real(LocalPath(\"rope/src/spans.rs\"))",""],"spans::<impl tree::Node<spans::SpansInfo<T>>>::merge":["merge","Real(LocalPath(\"rope/src/spans.rs\"))",""],"spans::<impl tree::Node<spans::SpansInfo<T>>>::transform":["transform","Real(LocalPath(\"rope/src/spans.rs\"))",""],"spans::SpansBuilder::<T>::add_span":["add_span","Real(LocalPath(\"rope/src/spans.rs\"))",""],"spans::SpansBuilder::<T>::build":["build","Real(LocalPath(\"rope/src/spans.rs\"))",""],"spans::SpansBuilder::<T>::new":["new","Real(LocalPath(\"rope/src/spans.rs\"))",""],"tree::Cursor::<'a, N>::at_or_next":["at_or_next","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::at_or_prev":["at_or_prev","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::descend":["descend","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::descend_metric":["descend_metric","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::get_leaf":["get_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::is_boundary":["is_boundary","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::iter":["iter","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::last_inside_leaf":["last_inside_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::measure_leaf":["measure_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::new":["new","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::next":["next","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::next_inside_leaf":["next_inside_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::next_leaf":["next_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::pos":["pos","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::prev":["prev","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::prev_leaf":["prev_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::root":["root","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::set":["set","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Cursor::<'a, N>::total_len":["total_len","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::CursorIter::<'c, 'a, N, M>::pos":["pos","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Leaf::subseq":["subseq","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::concat":["concat","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::convert_metrics":["convert_metrics","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::count":["count","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::count_base_units":["count_base_units","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::edit":["edit","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::from_leaf":["from_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::from_nodes":["from_nodes","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::get_children":["get_children","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::get_leaf":["get_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::height":["height","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::interval":["interval","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::is_empty":["is_empty","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::is_leaf":["is_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::is_ok_child":["is_ok_child","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::len":["len","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::measure":["measure","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::merge_leaves":["merge_leaves","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::merge_nodes":["merge_nodes","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::ptr_eq":["ptr_eq","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::push_subseq":["push_subseq","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::subseq":["subseq","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::Node::<N>::with_leaf_mut":["with_leaf_mut","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::NodeInfo::identity":["identity","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::NodeInfo::interval":["interval","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::TreeBuilder::<N>::build":["build","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::TreeBuilder::<N>::new":["new","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::TreeBuilder::<N>::pop":["pop","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::TreeBuilder::<N>::push":["push","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::TreeBuilder::<N>::push_leaf":["push_leaf","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::TreeBuilder::<N>::push_leaf_slice":["push_leaf_slice","Real(LocalPath(\"rope/src/tree.rs\"))",""],"tree::TreeBuilder::<N>::push_leaves":["push_leaves","Real(LocalPath(\"rope/src/tree.rs\"))",""]},"trait_to_struct":{"diff::Diff":["diff::LineHashDiff"],"interval::IntervalBounds":["<T as interval::IntervalBounds>::T","std::ops::RangeFrom","std::ops::RangeFull"],"std::clone::Clone":["breaks::BreaksBaseMetric","breaks::BreaksInfo","breaks::BreaksLeaf","breaks::BreaksMetric","delta::Delta","delta::DeltaElement","delta::InsertDelta","diff::DiffBuilder","diff::DiffOp","engine::Contents","engine::DeltaOp","engine::Error","engine::FullPriority","engine::RevId","find::CaseMatching","interval::Interval","multiset::CountMatcher","multiset::Segment","multiset::Subset","multiset::ZipSegment","rope::BaseMetric","rope::LinesMetric","rope::RopeInfo","rope::Utf16CodeUnitsMetric","spans::Span","spans::SpansInfo","spans::SpansLeaf","tree::Node","tree::NodeBody","tree::NodeVal"],"std::cmp::Eq":["breaks::BreaksLeaf","engine::FullPriority","engine::RevId","interval::Interval","multiset::Segment","multiset::Subset"],"std::cmp::Ord":["engine::FullPriority","engine::RevId"],"std::cmp::PartialEq":["breaks::BreaksLeaf","delta::DeltaRegion","engine::FullPriority","engine::RevId","find::CaseMatching","interval::Interval","multiset::Segment","multiset::Subset"],"std::cmp::PartialOrd":["engine::FullPriority","engine::RevId"],"std::convert::From":["interval::Interval","rope::Rope","std::string::String"],"std::default::Default":["breaks::BreakBuilder","breaks::BreaksLeaf","diff::DiffBuilder","multiset::SubsetBuilder","spans::SpansLeaf","tree::Node"],"std::error::Error":["engine::Error"],"std::fmt::Debug":["breaks::BreaksInfo","breaks::BreaksLeaf","delta::Delta","delta::DeltaRegion","delta::InsertDelta","diff::DiffBuilder","diff::DiffOp","engine::Contents","engine::DeltaOp","engine::Engine","engine::Error","engine::RevId","engine::Revision","interval::Interval","multiset::CountMatcher","multiset::Segment","multiset::Subset","multiset::ZipSegment","rope::Rope","spans::Spans"],"std::fmt::Display":["engine::Error","interval::Interval","rope::Rope"],"std::hash::Hash":["engine::RevId"],"std::iter::Iterator":["delta::DeletionsIter","delta::InsertsIter","multiset::RangeIter","multiset::ZipIter","rope::ChunkIter","rope::Lines","rope::LinesRaw","spans::SpanIter","tree::CursorIter"],"std::marker::Copy":["breaks::BreaksBaseMetric","breaks::BreaksMetric","diff::DiffOp","engine::FullPriority","engine::RevId","find::CaseMatching","interval::Interval","multiset::CountMatcher","rope::BaseMetric","rope::LinesMetric","rope::RopeInfo","rope::Utf16CodeUnitsMetric"],"std::marker::StructuralEq":["breaks::BreaksLeaf","engine::FullPriority","engine::RevId","interval::Interval","multiset::Segment","multiset::Subset"],"std::marker::StructuralPartialEq":["breaks::BreaksLeaf","delta::DeltaRegion","engine::FullPriority","engine::RevId","find::CaseMatching","interval::Interval","multiset::Segment","multiset::Subset"],"std::ops::Add":["rope::Rope"],"std::ops::Deref":["delta::InsertDelta"],"std::str::FromStr":["rope::Rope"],"tree::DefaultMetric":["breaks::BreaksInfo","rope::RopeInfo"],"tree::Leaf":["breaks::BreaksLeaf","spans::SpansLeaf","std::string::String"],"tree::Metric":["breaks::BreaksBaseMetric","breaks::BreaksMetric","rope::BaseMetric","rope::LinesMetric","rope::Utf16CodeUnitsMetric"],"tree::NodeInfo":["breaks::BreaksInfo","rope::RopeInfo","spans::SpansInfo"]},"type_to_def_path":{"breaks::BreakBuilder":"breaks::BreakBuilder","breaks::BreaksBaseMetric":"breaks::BreaksBaseMetric","breaks::BreaksInfo":"breaks::BreaksInfo","breaks::BreaksLeaf":"breaks::BreaksLeaf","breaks::BreaksMetric":"breaks::BreaksMetric","compare::RopeScanner<'a>":"compare::RopeScanner","delta::Builder<N>":"delta::Builder","delta::DeletionsIter<'a, N>":"delta::DeletionsIter","delta::Delta<N>":"delta::Delta","delta::DeltaElement<N>":"delta::DeltaElement","delta::DeltaRegion":"delta::DeltaRegion","delta::InsertDelta<N>":"delta::InsertDelta","delta::InsertsIter<'a, N>":"delta::InsertsIter","delta::Transformer<'a, N>":"delta::Transformer","diff::DiffBuilder":"diff::DiffBuilder","diff::DiffOp":"diff::DiffOp","diff::LineHashDiff":"diff::LineHashDiff","engine::Contents":"engine::Contents","engine::DeltaOp":"engine::DeltaOp","engine::Engine":"engine::Engine","engine::Error":"engine::Error","engine::FullPriority":"engine::FullPriority","engine::RevId":"engine::RevId","engine::Revision":"engine::Revision","find::CaseMatching":"find::CaseMatching","find::FindResult":"find::FindResult","interval::Interval":"interval::Interval","multiset::CountMatcher":"multiset::CountMatcher","multiset::Mapper<'a>":"multiset::Mapper","multiset::RangeIter<'a>":"multiset::RangeIter","multiset::Segment":"multiset::Segment","multiset::Subset":"multiset::Subset","multiset::SubsetBuilder":"multiset::SubsetBuilder","multiset::ZipIter<'a>":"multiset::ZipIter","multiset::ZipSegment":"multiset::ZipSegment","rope::BaseMetric":"rope::BaseMetric","rope::ChunkIter<'a>":"rope::ChunkIter","rope::Lines<'a>":"rope::Lines","rope::LinesMetric":"rope::LinesMetric","rope::LinesRaw<'a>":"rope::LinesRaw","rope::RopeInfo":"rope::RopeInfo","rope::Utf16CodeUnitsMetric":"rope::Utf16CodeUnitsMetric","spans::Span<T>":"spans::Span","spans::SpanIter<'a, T>":"spans::SpanIter","spans::SpansBuilder<T>":"spans::SpansBuilder","spans::SpansInfo<T>":"spans::SpansInfo","spans::SpansLeaf<T>":"spans::SpansLeaf","tree::Cursor<'a, N>":"tree::Cursor","tree::CursorIter<'c, 'a, N, M>":"tree::CursorIter","tree::Node<N>":"tree::Node","tree::NodeBody<N>":"tree::NodeBody","tree::NodeVal<N>":"tree::NodeVal","tree::TreeBuilder<N>":"tree::TreeBuilder"}}