{"dependencies":{"<&'a [u8] as peg::Peg>::p":["std::marker::Sized","std::option::Option"],"<&'a str as peg::Peg>::p":["std::marker::Sized","std::option::Option"],"<(P1, P2) as peg::Peg>::p":["std::marker::Sized","std::option::Option"],"<(P1, P2, P3) as peg::Peg>::p":["std::marker::Sized","std::option::Option"],"<(P1, P2, P3, P4) as peg::Peg>::p":["std::marker::Sized","std::option::Option"],"<F as peg::Peg>::p":["std::marker::Sized","std::option::Option"],"<LangPlugin as xi_plugin_lib::Plugin>::config_changed":["LangPlugin","serde_json::map::Map","std::collections::HashMap","std::marker::Sized","xi_plugin_lib::View"],"<LangPlugin as xi_plugin_lib::Plugin>::did_close":["LangPlugin","std::collections::HashMap","std::marker::Sized","xi_plugin_lib::View"],"<LangPlugin as xi_plugin_lib::Plugin>::did_save":["LangPlugin","std::collections::HashMap","std::marker::Sized","std::option::Option","xi_plugin_lib::View"],"<LangPlugin as xi_plugin_lib::Plugin>::idle":["LangPlugin","std::collections::HashMap","std::marker::Sized","xi_plugin_lib::View"],"<LangPlugin as xi_plugin_lib::Plugin>::language_changed":["LangPlugin","std::collections::HashMap","std::marker::Sized","xi_core_lib::LanguageId","xi_plugin_lib::View"],"<LangPlugin as xi_plugin_lib::Plugin>::new_view":["LangPlugin","std::collections::HashMap","std::marker::Sized","xi_plugin_lib::View"],"<LangPlugin as xi_plugin_lib::Plugin>::update":["LangPlugin","std::collections::HashMap","std::marker::Sized","std::option::Option","std::string::String","xi_plugin_lib::View"],"<char as peg::Peg>::p":["std::marker::Sized","std::option::Option"],"<language::plaintext::PlaintextParser as parser::Parser>::get_all_scopes":["language::plaintext::PlaintextParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::plaintext::PlaintextParser as parser::Parser>::get_scope_id_for_state":["language::plaintext::PlaintextParser","statestack::Context","statestack::State","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::plaintext::PlaintextParser as parser::Parser>::has_offset":["language::plaintext::PlaintextParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::plaintext::PlaintextParser as parser::Parser>::parse":["language::plaintext::PlaintextParser","statestack::Context","statestack::State","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::plaintext::PlaintextParser as parser::Parser>::set_scope_offset":["language::plaintext::PlaintextParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::rust::OneOrMoreWithSep<P, SEP> as peg::Peg>::p":["language::rust::OneOrMoreWithSep","std::marker::Sized","std::option::Option"],"<language::rust::RustParser as parser::Parser>::get_all_scopes":["language::rust::RustParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::rust::RustParser as parser::Parser>::get_scope_id_for_state":["language::rust::RustParser","statestack::Context","statestack::State","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::rust::RustParser as parser::Parser>::has_offset":["language::rust::RustParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::rust::RustParser as parser::Parser>::parse":["language::rust::RustParser","statestack::Context","statestack::State","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::rust::RustParser as parser::Parser>::set_scope_offset":["language::rust::RustParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"<language::rust::StateEl as std::clone::Clone>::clone":["language::rust::StateEl"],"<language::rust::StateEl as std::cmp::Eq>::assert_receiver_is_total_eq":["language::rust::StateEl"],"<language::rust::StateEl as std::cmp::PartialEq>::eq":["language::rust::StateEl"],"<language::rust::StateEl as std::fmt::Debug>::fmt":["language::rust::StateEl","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<language::rust::StateEl as std::hash::Hash>::hash":["language::rust::StateEl","std::hash::Hasher","std::marker::Sized"],"<peg::Alt3<P1, P2, P3> as peg::Peg>::p":["peg::Alt3","std::marker::Sized","std::option::Option"],"<peg::Alt<P1, P2> as peg::Peg>::p":["peg::Alt","std::marker::Sized","std::option::Option"],"<peg::FailIf<P> as peg::Peg>::p":["peg::FailIf","std::marker::Sized","std::option::Option"],"<peg::Inclusive<std::ops::Range<u8>> as peg::Peg>::p":["peg::Inclusive","std::marker::Sized","std::option::Option"],"<peg::OneByte<F> as peg::Peg>::p":["peg::OneByte","std::marker::Sized","std::option::Option"],"<peg::OneChar<F> as peg::Peg>::p":["peg::OneChar","std::marker::Sized","std::option::Option"],"<peg::OneOf<'a, P> as peg::Peg>::p":["peg::OneOf","std::marker::Sized","std::option::Option"],"<peg::OneOrMore<P> as peg::Peg>::p":["peg::OneOrMore","std::marker::Sized","std::option::Option"],"<peg::Optional<P> as peg::Peg>::p":["peg::Optional","std::marker::Sized","std::option::Option"],"<peg::Ref<'a, P> as peg::Peg>::p":["peg::Ref","std::marker::Sized","std::option::Option"],"<peg::Repeat<P, std::ops::Range<usize>> as peg::Peg>::p":["peg::Repeat","std::marker::Sized","std::option::Option"],"<peg::Repeat<P, std::ops::RangeFrom<usize>> as peg::Peg>::p":["peg::Repeat","std::marker::Sized","std::option::Option"],"<peg::Repeat<P, std::ops::RangeFull> as peg::Peg>::p":["peg::Repeat","std::marker::Sized","std::option::Option"],"<peg::Repeat<P, std::ops::RangeTo<usize>> as peg::Peg>::p":["peg::Repeat","std::marker::Sized","std::option::Option"],"<peg::Repeat<P, usize> as peg::Peg>::p":["peg::Repeat","std::marker::Sized","std::option::Option"],"<peg::ZeroOrMore<P> as peg::Peg>::p":["peg::ZeroOrMore","std::marker::Sized","std::option::Option"],"<statestack::State as std::clone::Clone>::clone":["statestack::State"],"<statestack::State as std::cmp::Eq>::assert_receiver_is_total_eq":["statestack::State"],"<statestack::State as std::cmp::PartialEq>::eq":["statestack::State"],"<statestack::State as std::default::Default>::default":["statestack::State"],"<statestack::State as std::fmt::Debug>::fmt":["statestack::State","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<statestack::State as std::hash::Hash>::hash":["statestack::State","std::hash::Hasher","std::marker::Sized"],"<std::ops::Range<u8> as peg::Peg>::p":["std::marker::Sized","std::ops::Range","std::option::Option"],"<u8 as peg::Peg>::p":["std::marker::Sized","std::option::Option"],"LangPlugin":["LangPlugin","std::collections::HashMap","std::marker::Sized"],"LangPlugin::new":["LangPlugin","std::collections::HashMap","std::marker::Sized"],"ViewState":["ViewState","statestack::State","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","xi_core_lib::LanguageId"],"ViewState::compute_syntax":["ViewState","statestack::State","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","xi_core_lib::LanguageId"],"ViewState::do_highlighting":["ViewState","statestack::State","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","xi_core_lib::LanguageId","xi_plugin_lib::View"],"ViewState::flush_spans":["ViewState","statestack::State","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","xi_core_lib::LanguageId","xi_plugin_lib::View"],"ViewState::highlight_one_line":["ViewState","statestack::State","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","xi_core_lib::LanguageId","xi_plugin_lib::View"],"ViewState::new":["ViewState","statestack::State","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec","xi_core_lib::LanguageId"],"language::plaintext::PlaintextParser":["language::plaintext::PlaintextParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"language::plaintext::PlaintextParser::new":["language::plaintext::PlaintextParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"language::rust::OneOrMoreWithSep":["language::rust::OneOrMoreWithSep","std::marker::Sized"],"language::rust::RustParser":["language::rust::RustParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"language::rust::RustParser::new":["language::rust::RustParser","statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"language::rust::RustParser::quoted_str":["language::rust::RustParser","statestack::Context","statestack::State","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"language::rust::StateEl":["language::rust::StateEl"],"language::rust::StateEl::scope_id":["language::rust::StateEl"],"language::rust::char_literal":["std::marker::Sized","std::option::Option"],"language::rust::escape":["std::marker::Sized","std::option::Option"],"language::rust::ident":["std::marker::Sized","std::option::Option"],"language::rust::int_suffix":["std::marker::Sized","std::option::Option"],"language::rust::is_digit":[],"language::rust::is_hex_digit":[],"language::rust::is_ident_continue":[],"language::rust::is_ident_start":[],"language::rust::numeric_literal":["std::marker::Sized","std::option::Option"],"language::rust::positive_decimal":["std::marker::Sized","std::option::Option"],"language::rust::positive_nondecimal":["std::marker::Sized","std::option::Option"],"language::rust::raw_numeric":["std::marker::Sized","std::option::Option"],"language::rust::test":[],"language::rust::whitespace":["std::marker::Sized","std::option::Option"],"main":[],"parser::Parser::get_all_scopes":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"parser::Parser::get_scope_id_for_state":["statestack::State"],"parser::Parser::has_offset":[],"parser::Parser::parse":["statestack::State"],"parser::Parser::set_scope_offset":[],"peg::Alt":["peg::Alt","std::marker::Sized"],"peg::Alt3":["peg::Alt3","std::marker::Sized"],"peg::FailIf":["peg::FailIf","std::marker::Sized"],"peg::Inclusive":["peg::Inclusive","std::marker::Sized"],"peg::OneByte":["peg::OneByte","std::marker::Sized"],"peg::OneChar":["peg::OneChar","std::marker::Sized"],"peg::OneOf":["peg::OneOf","std::marker::Sized"],"peg::OneOrMore":["peg::OneOrMore","std::marker::Sized"],"peg::Optional":["peg::Optional","std::marker::Sized"],"peg::Peg::p":["std::marker::Sized","std::option::Option"],"peg::Ref":["peg::Ref","std::marker::Sized"],"peg::Repeat":["peg::Repeat","std::marker::Sized"],"peg::ZeroOrMore":["peg::ZeroOrMore","std::marker::Sized"],"peg::char_helper":["std::marker::Sized","std::option::Option"],"peg::decode_utf8":["std::marker::Sized","std::option::Option"],"statestack::Context":["statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"statestack::Context::<T>::entry":["statestack::Context","statestack::State","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"statestack::Context::<T>::new":["statestack::Context","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"statestack::Context::<T>::pop":["statestack::Context","statestack::State","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"statestack::Context::<T>::push":["statestack::Context","statestack::State","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"statestack::Context::<T>::tos":["statestack::Context","statestack::State","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"statestack::Entry":["statestack::Entry","statestack::State","std::marker::Sized"],"statestack::State":["statestack::State"]},"glob_path_import":{},"self_to_fn":{"<F as peg::Peg>::F":["impl<F: Fn(&[u8]) -> Option<usize>> Peg for F {\n    #[inline(always)]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        self(s)\n    }\n}"],"LangPlugin":["impl LangPlugin {\n    fn new() -> LangPlugin {\n        LangPlugin { view_states: HashMap::new() }\n    }\n}","impl Plugin for LangPlugin {\n    type Cache = StateCache<State>;\n\n    fn update(\n        &mut self,\n        view: &mut View<Self::Cache>,\n        _delta: Option<&RopeDelta>,\n        _edit_type: String,\n        _author: String,\n    ) {\n        view.schedule_idle();\n    }\n\n    fn did_save(&mut self, view: &mut View<Self::Cache>, _old_path: Option<&Path>) {\n        let view_id = view.get_id();\n        if let Some(view_state) = self.view_states.get_mut(&view_id) {\n            view_state.do_highlighting(view);\n        }\n    }\n\n    fn did_close(&mut self, view: &View<Self::Cache>) {\n        let view_id = view.get_id();\n        self.view_states.remove(&view_id);\n    }\n\n    fn new_view(&mut self, view: &mut View<Self::Cache>) {\n        let view_id = view.get_id();\n        let mut view_state = ViewState::new();\n\n        view_state.do_highlighting(view);\n        self.view_states.insert(view_id, view_state);\n    }\n\n    fn config_changed(&mut self, _view: &mut View<Self::Cache>, _changes: &ConfigTable) {}\n\n    fn language_changed(\n        &mut self,\n        view: &mut View<<Self as Plugin>::Cache>,\n        _old_lang: LanguageId,\n    ) {\n        let view_id = view.get_id();\n        if let Some(view_state) = self.view_states.get_mut(&view_id) {\n            view_state.do_highlighting(view);\n        }\n    }\n\n    fn idle(&mut self, view: &mut View<Self::Cache>) {\n        let view_id = view.get_id();\n\n        if let Some(view_state) = self.view_states.get_mut(&view_id) {\n            for _ in 0..LINES_PER_RPC {\n                if !view_state.highlight_one_line(view) {\n                    view_state.flush_spans(view);\n                    return;\n                }\n\n                if view.request_is_pending() {\n                    trace(\"yielding for request\", &[\"experimental-lang\"]);\n                    break;\n                }\n            }\n\n            view_state.flush_spans(view);\n            view.schedule_idle();\n        }\n    }\n}"],"ViewState":["impl ViewState {\n    fn new() -> ViewState {\n        ViewState {\n            current_language: LanguageId::from(\"Plain Text\"),\n            parser: Box::new(PlaintextParser::new()),\n            offset: 0,\n            initial_state: State::default(),\n            spans_start: 0,\n            spans: Vec::new(),\n            scope_offset: 0,\n        }\n    }\n\n    fn do_highlighting(&mut self, view: &mut View<StateCache<State>>) {\n        self.offset = 0;\n        self.spans_start = 0;\n        self.initial_state = State::default();\n        self.spans = Vec::new();\n        view.get_cache().clear();\n\n        if view.get_language_id() != &self.current_language {\n            let parser: Box<dyn Parser> = match view.get_language_id().as_ref() {\n                \"Rust\" => Box::new(RustParser::new()),\n                \"Plain Text\" => Box::new(PlaintextParser::new()),\n                language_id => {\n                    trace_payload(\n                        \"unsupported language\",\n                        &[\"experimental-lang\"],\n                        format!(\"language id: {}\", language_id),\n                    );\n                    Box::new(PlaintextParser::new())\n                }\n            };\n\n            self.current_language = view.get_language_id().clone();\n            self.parser = parser;\n        }\n\n        let scopes = self.parser.get_all_scopes();\n        view.add_scopes(&scopes);\n\n        if !self.parser.has_offset() {\n            self.parser.set_scope_offset(self.scope_offset);\n            self.scope_offset += scopes.len() as u32;\n        }\n\n        view.schedule_idle();\n    }\n\n    fn highlight_one_line(&mut self, view: &mut View<StateCache<State>>) -> bool {\n        if let Some(line_num) = view.get_frontier() {\n            let (line_num, offset, _state) = view.get_prev(line_num);\n\n            if offset != self.offset {\n                self.flush_spans(view);\n                self.offset = offset;\n                self.spans_start = offset;\n            }\n\n            let new_frontier = match view.get_line(line_num) {\n                Ok(\"\") => None,\n                Ok(line) => {\n                    let new_state = self.compute_syntax(line);\n                    self.offset += line.len();\n\n                    if line.as_bytes().last() == Some(&b'\\n') {\n                        Some((new_state, line_num + 1))\n                    } else {\n                        None\n                    }\n                }\n                Err(_) => None,\n            };\n\n            let mut converged = false;\n            if let Some((ref new_state, new_line_num)) = new_frontier {\n                if let Some(old_state) = view.get(new_line_num) {\n                    converged = old_state == new_state;\n                }\n            }\n\n            if !converged {\n                if let Some((new_state, new_line_num)) = new_frontier {\n                    view.set(new_line_num, new_state);\n                    view.update_frontier(new_line_num);\n                    return true;\n                }\n            }\n\n            view.close_frontier();\n        }\n\n        false\n    }\n\n    fn compute_syntax(&mut self, line: &str) -> State {\n        let _guard = trace_block(\"ExperimentalLang::compute_syntax\", &[\"experimental-lang\"]);\n\n        let mut i = 0;\n        let mut state = self.initial_state;\n        while i < line.len() {\n            let (prevlen, s0, len, s1) = self.parser.parse(&line[i..], state);\n\n            if prevlen > 0 {\n                // TODO: maybe make an iterator to avoid this duplication\n                let scope_id = self.parser.get_scope_id_for_state(self.initial_state);\n\n                let start = self.offset - self.spans_start + i;\n                let end = start + prevlen;\n\n                let span = ScopeSpan { start, end, scope_id };\n                self.spans.push(span);\n\n                i += prevlen;\n            }\n\n            let scope_id = self.parser.get_scope_id_for_state(s0);\n\n            let start = self.offset - self.spans_start + i;\n            let end = start + len;\n\n            let span = ScopeSpan { start, end, scope_id };\n            self.spans.push(span);\n\n            i += len;\n            state = s1;\n        }\n\n        state\n    }\n\n    fn flush_spans(&mut self, view: &mut View<StateCache<State>>) {\n        if self.spans_start != self.offset {\n            trace_payload(\n                \"flushing spans\",\n                &[\"experimental-lang\"],\n                format!(\"flushing spans: {:?}\", self.spans),\n            );\n            view.update_spans(self.spans_start, self.offset - self.spans_start, &self.spans);\n            self.spans.clear();\n        }\n\n        self.spans_start = self.offset;\n    }\n}"],"language::plaintext::PlaintextParser":["impl Parser for PlaintextParser {\n    fn has_offset(&mut self) -> bool {\n        self.scope_offset.is_some()\n    }\n\n    fn set_scope_offset(&mut self, offset: u32) {\n        if !self.has_offset() {\n            self.scope_offset = Some(offset)\n        }\n    }\n\n    fn get_all_scopes(&self) -> Vec<Vec<String>> {\n        vec![PLAINTEXT_SOURCE_SCOPE.iter().map(|it| (*it).to_string()).collect()]\n    }\n\n    fn get_scope_id_for_state(&self, _state: State) -> ScopeId {\n        self.scope_offset.unwrap_or_default()\n    }\n\n    fn parse(&mut self, text: &str, state: State) -> (usize, State, usize, State) {\n        (0, self.ctx.push(state, ()), text.as_bytes().len(), state)\n    }\n}","impl PlaintextParser {\n    pub fn new() -> PlaintextParser {\n        PlaintextParser { scope_offset: None, ctx: Context::new() }\n    }\n}"],"language::rust::OneOrMoreWithSep":["impl<P: Peg, SEP: Peg> Peg for OneOrMoreWithSep<P, SEP> {\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        let OneOrMoreWithSep(ref p, ref sep) = *self;\n        (ZeroOrMore(Ref(sep)), Ref(p), ZeroOrMore(Alt(Ref(p), Ref(sep)))).p(s)\n    }\n}"],"language::rust::RustParser":["impl Parser for RustParser {\n    fn has_offset(&mut self) -> bool {\n        self.scope_offset.is_some()\n    }\n\n    fn set_scope_offset(&mut self, offset: u32) {\n        if !self.has_offset() {\n            self.scope_offset = Some(offset)\n        }\n    }\n\n    fn get_all_scopes(&self) -> Vec<Vec<String>> {\n        ALL_SCOPES\n            .iter()\n            .map(|stack| stack.iter().map(|s| (*s).to_string()).collect::<Vec<_>>())\n            .collect()\n    }\n\n    fn get_scope_id_for_state(&self, state: State) -> ScopeId {\n        let offset = self.scope_offset.unwrap_or_default();\n\n        if let Some(element) = self.ctx.tos(state) {\n            element.scope_id() + offset\n        } else {\n            offset\n        }\n    }\n\n    fn parse(&mut self, text: &str, mut state: State) -> (usize, State, usize, State) {\n        let t = text.as_bytes();\n        match self.ctx.tos(state) {\n            Some(StateEl::Comment) => {\n                for i in 0..t.len() {\n                    if let Some(len) = \"/*\".p(&t[i..]) {\n                        state = self.ctx.push(state, StateEl::Comment);\n                        return (i, state, len, state);\n                    } else if let Some(len) = \"*/\".p(&t[i..]) {\n                        return (0, state, i + len, self.ctx.pop(state).unwrap());\n                    }\n                }\n                return (0, state, t.len(), state);\n            }\n            Some(StateEl::StrQuote) => return self.quoted_str(t, state),\n            _ => (),\n        }\n        let mut i = 0;\n        while i < t.len() {\n            let b = t[i];\n            if let Some(len) = \"/*\".p(&t[i..]) {\n                state = self.ctx.push(state, StateEl::Comment);\n                return (i, state, len, state);\n            } else if \"//\".p(&t[i..]).is_some() {\n                return (i, self.ctx.push(state, StateEl::Comment), t.len(), state);\n            } else if let Some(len) = numeric_literal.p(&t[i..]) {\n                return (i, self.ctx.push(state, StateEl::NumericLiteral), len, state);\n            } else if b == b'\"' {\n                state = self.ctx.push(state, StateEl::StrQuote);\n                return (i, state, 1, state);\n            } else if let Some(len) = char_literal.p(&t[i..]) {\n                return (i, self.ctx.push(state, StateEl::CharQuote), len, state);\n            } else if let Some(len) = OneOf(RUST_OPERATORS).p(&t[i..]) {\n                return (i, self.ctx.push(state, StateEl::Operator), len, state);\n            } else if let Some(len) = ident.p(&t[i..]) {\n                if RUST_KEYWORDS.binary_search(&&t[i..i + len]).is_ok() {\n                    return (i, self.ctx.push(state, StateEl::Keyword), len, state);\n                } else if RUST_PRIM_TYPES.binary_search(&&t[i..i + len]).is_ok() {\n                    return (i, self.ctx.push(state, StateEl::PrimType), len, state);\n                } else {\n                    i += len;\n                    continue;\n                }\n            } else if let Some(len) = whitespace.p(&t[i..]) {\n                return (i, self.ctx.push(state, StateEl::Source), len, state);\n            }\n\n            i += 1;\n        }\n\n        (0, self.ctx.push(state, StateEl::Source), t.len(), state)\n    }\n}","impl RustParser {\n    pub fn new() -> RustParser {\n        RustParser { scope_offset: None, ctx: Context::new() }\n    }\n\n    fn quoted_str(&mut self, t: &[u8], state: State) -> (usize, State, usize, State) {\n        let mut i = 0;\n        while i < t.len() {\n            let b = t[i];\n            if b == b'\"' {\n                return (0, state, i + 1, self.ctx.pop(state).unwrap());\n            } else if b == b'\\\\' {\n                if let Some(len) = escape.p(&t[i..]) {\n                    return (i, self.ctx.push(state, StateEl::CharConst), len, state);\n                } else if let Some(len) =\n                    (FailIf(OneOf(b\"\\r\\nbu\")), OneChar(|_| true)).p(&t[i + 1..])\n                {\n                    return (i + 1, self.ctx.push(state, StateEl::Invalid), len, state);\n                }\n            }\n            i += 1;\n        }\n        (0, state, i, state)\n    }\n}"],"language::rust::StateEl":["Clone","Debug","Eq","Hash","PartialEq","impl StateEl {\n    pub fn scope_id(&self) -> ScopeId {\n        match self {\n            StateEl::Source => 0,\n            StateEl::StrQuote => 1,\n            StateEl::CharQuote => 2,\n            StateEl::Comment => 3,\n            StateEl::CharConst => 4,\n            StateEl::NumericLiteral => 5,\n            StateEl::Invalid => 6,\n            StateEl::Keyword => 7,\n            StateEl::Operator => 8,\n            StateEl::PrimType => 9,\n        }\n    }\n}"],"peg::Alt":["impl<P1: Peg, P2: Peg> Peg for Alt<P1, P2> {\n    #[inline(always)]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        self.0.p(s).or_else(|| self.1.p(s))\n    }\n}"],"peg::Alt3":["impl<P1: Peg, P2: Peg, P3: Peg> Peg for Alt3<P1, P2, P3> {\n    #[inline(always)]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        self.0.p(s).or_else(|| self.1.p(s).or_else(|| self.2.p(s)))\n    }\n}"],"peg::FailIf":["impl<P: Peg> Peg for FailIf<P> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        match self.0.p(s) {\n            Some(_) => None,\n            None => Some(0),\n        }\n    }\n}"],"peg::Inclusive":["impl Peg for Inclusive<ops::Range<u8>> {\n    #[inline(always)]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        OneByte(|x| x >= self.0.start && x <= self.0.end).p(s)\n    }\n}"],"peg::OneByte":["impl<F: Fn(u8) -> bool> Peg for OneByte<F> {\n    #[inline(always)]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        if s.is_empty() || !self.0(s[0]) {\n            None\n        } else {\n            Some(1)\n        }\n    }\n}"],"peg::OneChar":["impl<F: Fn(char) -> bool> Peg for OneChar<F> {\n    #[inline(always)]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        if let Some((ch, len)) = decode_utf8(s) {\n            if self.0(ch) {\n                return Some(len);\n            }\n        }\n        None\n    }\n}"],"peg::OneOf":["impl<'a, P: Peg> Peg for OneOf<'a, P> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        for p in self.0.iter() {\n            if let Some(len) = p.p(s) {\n                return Some(len);\n            }\n        }\n        None\n    }\n}"],"peg::OneOrMore":["impl<P: Peg> Peg for OneOrMore<P> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        Repeat(Ref(&self.0), 1..).p(s)\n    }\n}"],"peg::Optional":["impl<P: Peg> Peg for Optional<P> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        self.0.p(s).or(Some(0))\n    }\n}"],"peg::Ref":["impl<'a, P: Peg> Peg for Ref<'a, P> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        self.0.p(s)\n    }\n}"],"peg::Repeat":["impl<P: Peg> Peg for Repeat<P, ops::Range<usize>> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        let Repeat(ref p, ops::Range { start, end }) = *self;\n        let mut i = 0;\n        let mut count = 0;\n        while count + 1 < end {\n            if let Some(len) = p.p(&s[i..]) {\n                i += len;\n                count += 1;\n            } else {\n                break;\n            }\n        }\n        if count >= start {\n            Some(i)\n        } else {\n            None\n        }\n    }\n}","impl<P: Peg> Peg for Repeat<P, ops::RangeFrom<usize>> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        let Repeat(ref p, ops::RangeFrom { start }) = *self;\n        let mut i = 0;\n        let mut count = 0;\n        while let Some(len) = p.p(&s[i..]) {\n            i += len;\n            count += 1;\n        }\n        if count >= start {\n            Some(i)\n        } else {\n            None\n        }\n    }\n}","impl<P: Peg> Peg for Repeat<P, ops::RangeFull> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        ZeroOrMore(Ref(&self.0)).p(s)\n    }\n}","impl<P: Peg> Peg for Repeat<P, ops::RangeTo<usize>> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        let Repeat(ref p, ops::RangeTo { end }) = *self;\n        Repeat(Ref(p), 0..end).p(s)\n    }\n}","impl<P: Peg> Peg for Repeat<P, usize> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        let Repeat(ref p, reps) = *self;\n        let mut i = 0;\n        let mut count = 0;\n        while count < reps {\n            if let Some(len) = p.p(&s[i..]) {\n                i += len;\n                count += 1;\n            } else {\n                break;\n            }\n        }\n        Some(i)\n    }\n}"],"peg::ZeroOrMore":["impl<P: Peg> Peg for ZeroOrMore<P> {\n    #[inline]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        let mut i = 0;\n        while let Some(len) = self.0.p(&s[i..]) {\n            i += len;\n        }\n        Some(i)\n    }\n}"],"statestack::Context":["impl<T: Clone + Hash + Eq> Context<T> {\n    pub fn new() -> Context<T> {\n        Context { entries: Vec::new(), next: HashMap::new() }\n    }\n\n    fn entry(&self, s: State) -> Option<&Entry<T>> {\n        if s.0 == 0 {\n            None\n        } else {\n            Some(&self.entries[s.0 - 1])\n        }\n    }\n\n    /// The top of the stack for the given state.\n    pub fn tos(&self, s: State) -> Option<T> {\n        self.entry(s).map(|entry| entry.tos.clone())\n    }\n\n    pub fn pop(&self, s: State) -> Option<State> {\n        self.entry(s).map(|entry| entry.prev)\n    }\n\n    pub fn push(&mut self, s: State, el: T) -> State {\n        let entries = &mut self.entries;\n        *self.next.entry((s, el.clone())).or_insert_with(|| {\n            entries.push(Entry { tos: el, prev: s });\n            State(entries.len())\n        })\n    }\n}"],"statestack::State":["Clone","Copy","Debug","Default","Eq","Hash","PartialEq"],"std::ops::Range":["impl Peg for ops::Range<u8> {\n    #[inline(always)]\n    fn p(&self, s: &[u8]) -> Option<usize> {\n        OneByte(|x| x >= self.start && x < self.end).p(s)\n    }\n}"]},"single_path_import":{},"srcs":{"<&'a [u8] as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        let len = self.len();\n        if s.len() >= len && &s[..len] == *self {\n            Some(len)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<&'a str as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        self.as_bytes().p(s)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<(P1, P2) as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        self.0.p(s).and_then(|len1| self.1.p(&s[len1..]).map(|len2| len1 + len2))\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<(P1, P2, P3) as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        self.0.p(s).and_then(|len1| {\n            self.1\n                .p(&s[len1..])\n                .and_then(|len2| self.2.p(&s[len1 + len2..]).map(|len3| len1 + len2 + len3))\n        })\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<(P1, P2, P3, P4) as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n                let ( $( ref $ix ),* ) = *self;\n                let mut i = 0;\n                $(\n                    if let Some(len) = $ix.p(&s[i..]) {\n                        i += len;\n                    } else {\n                        return None;\n                    }\n                )*\n                Some(i)\n            }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<F as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        self(s)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<LangPlugin as xi_plugin_lib::Plugin>::config_changed":["fn config_changed(&mut self, _view: &mut View<Self::Cache>, _changes: &ConfigTable){}","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"<LangPlugin as xi_plugin_lib::Plugin>::did_close":["fn did_close(&mut self, view: &View<Self::Cache>){\n        let view_id = view.get_id();\n        self.view_states.remove(&view_id);\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"<LangPlugin as xi_plugin_lib::Plugin>::did_save":["fn did_save(&mut self, view: &mut View<Self::Cache>, _old_path: Option<&Path>){\n        let view_id = view.get_id();\n        if let Some(view_state) = self.view_states.get_mut(&view_id) {\n            view_state.do_highlighting(view);\n        }\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"<LangPlugin as xi_plugin_lib::Plugin>::idle":["fn idle(&mut self, view: &mut View<Self::Cache>){\n        let view_id = view.get_id();\n\n        if let Some(view_state) = self.view_states.get_mut(&view_id) {\n            for _ in 0..LINES_PER_RPC {\n                if !view_state.highlight_one_line(view) {\n                    view_state.flush_spans(view);\n                    return;\n                }\n\n                if view.request_is_pending() {\n                    trace(\"yielding for request\", &[\"experimental-lang\"]);\n                    break;\n                }\n            }\n\n            view_state.flush_spans(view);\n            view.schedule_idle();\n        }\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"<LangPlugin as xi_plugin_lib::Plugin>::language_changed":["fn language_changed(\n        &mut self,\n        view: &mut View<<Self as Plugin>::Cache>,\n        _old_lang: LanguageId,\n    ){\n        let view_id = view.get_id();\n        if let Some(view_state) = self.view_states.get_mut(&view_id) {\n            view_state.do_highlighting(view);\n        }\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"<LangPlugin as xi_plugin_lib::Plugin>::new_view":["fn new_view(&mut self, view: &mut View<Self::Cache>){\n        let view_id = view.get_id();\n        let mut view_state = ViewState::new();\n\n        view_state.do_highlighting(view);\n        self.view_states.insert(view_id, view_state);\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"<LangPlugin as xi_plugin_lib::Plugin>::update":["fn update(\n        &mut self,\n        view: &mut View<Self::Cache>,\n        _delta: Option<&RopeDelta>,\n        _edit_type: String,\n        _author: String,\n    ){\n        view.schedule_idle();\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"<char as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        let c = *self;\n        if c <= '\\x7f' {\n            (c as u8).p(s)\n        } else {\n            char_helper(s, c)\n        }\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<language::plaintext::PlaintextParser as parser::Parser>::get_all_scopes":["fn get_all_scopes(&self) -> Vec<Vec<String>>{\n        vec![PLAINTEXT_SOURCE_SCOPE.iter().map(|it| (*it).to_string()).collect()]\n    }","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))"],"<language::plaintext::PlaintextParser as parser::Parser>::get_scope_id_for_state":["fn get_scope_id_for_state(&self, _state: State) -> ScopeId{\n        self.scope_offset.unwrap_or_default()\n    }","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))"],"<language::plaintext::PlaintextParser as parser::Parser>::has_offset":["fn has_offset(&mut self) -> bool{\n        self.scope_offset.is_some()\n    }","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))"],"<language::plaintext::PlaintextParser as parser::Parser>::parse":["fn parse(&mut self, text: &str, state: State) -> (usize, State, usize, State){\n        (0, self.ctx.push(state, ()), text.as_bytes().len(), state)\n    }","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))"],"<language::plaintext::PlaintextParser as parser::Parser>::set_scope_offset":["fn set_scope_offset(&mut self, offset: u32){\n        if !self.has_offset() {\n            self.scope_offset = Some(offset)\n        }\n    }","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))"],"<language::rust::OneOrMoreWithSep<P, SEP> as peg::Peg>::p":["fn p(&self, s: &[u8]) -> Option<usize>{\n        let OneOrMoreWithSep(ref p, ref sep) = *self;\n        (ZeroOrMore(Ref(sep)), Ref(p), ZeroOrMore(Alt(Ref(p), Ref(sep)))).p(s)\n    }","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"<language::rust::RustParser as parser::Parser>::get_all_scopes":["fn get_all_scopes(&self) -> Vec<Vec<String>>{\n        ALL_SCOPES\n            .iter()\n            .map(|stack| stack.iter().map(|s| (*s).to_string()).collect::<Vec<_>>())\n            .collect()\n    }","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"<language::rust::RustParser as parser::Parser>::get_scope_id_for_state":["fn get_scope_id_for_state(&self, state: State) -> ScopeId{\n        let offset = self.scope_offset.unwrap_or_default();\n\n        if let Some(element) = self.ctx.tos(state) {\n            element.scope_id() + offset\n        } else {\n            offset\n        }\n    }","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"<language::rust::RustParser as parser::Parser>::has_offset":["fn has_offset(&mut self) -> bool{\n        self.scope_offset.is_some()\n    }","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"<language::rust::RustParser as parser::Parser>::parse":["fn parse(&mut self, text: &str, mut state: State) -> (usize, State, usize, State){\n        let t = text.as_bytes();\n        match self.ctx.tos(state) {\n            Some(StateEl::Comment) => {\n                for i in 0..t.len() {\n                    if let Some(len) = \"/*\".p(&t[i..]) {\n                        state = self.ctx.push(state, StateEl::Comment);\n                        return (i, state, len, state);\n                    } else if let Some(len) = \"*/\".p(&t[i..]) {\n                        return (0, state, i + len, self.ctx.pop(state).unwrap());\n                    }\n                }\n                return (0, state, t.len(), state);\n            }\n            Some(StateEl::StrQuote) => return self.quoted_str(t, state),\n            _ => (),\n        }\n        let mut i = 0;\n        while i < t.len() {\n            let b = t[i];\n            if let Some(len) = \"/*\".p(&t[i..]) {\n                state = self.ctx.push(state, StateEl::Comment);\n                return (i, state, len, state);\n            } else if \"//\".p(&t[i..]).is_some() {\n                return (i, self.ctx.push(state, StateEl::Comment), t.len(), state);\n            } else if let Some(len) = numeric_literal.p(&t[i..]) {\n                return (i, self.ctx.push(state, StateEl::NumericLiteral), len, state);\n            } else if b == b'\"' {\n                state = self.ctx.push(state, StateEl::StrQuote);\n                return (i, state, 1, state);\n            } else if let Some(len) = char_literal.p(&t[i..]) {\n                return (i, self.ctx.push(state, StateEl::CharQuote), len, state);\n            } else if let Some(len) = OneOf(RUST_OPERATORS).p(&t[i..]) {\n                return (i, self.ctx.push(state, StateEl::Operator), len, state);\n            } else if let Some(len) = ident.p(&t[i..]) {\n                if RUST_KEYWORDS.binary_search(&&t[i..i + len]).is_ok() {\n                    return (i, self.ctx.push(state, StateEl::Keyword), len, state);\n                } else if RUST_PRIM_TYPES.binary_search(&&t[i..i + len]).is_ok() {\n                    return (i, self.ctx.push(state, StateEl::PrimType), len, state);\n                } else {\n                    i += len;\n                    continue;\n                }\n            } else if let Some(len) = whitespace.p(&t[i..]) {\n                return (i, self.ctx.push(state, StateEl::Source), len, state);\n            }\n\n            i += 1;\n        }\n\n        (0, self.ctx.push(state, StateEl::Source), t.len(), state)\n    }","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"<language::rust::RustParser as parser::Parser>::set_scope_offset":["fn set_scope_offset(&mut self, offset: u32){\n        if !self.has_offset() {\n            self.scope_offset = Some(offset)\n        }\n    }","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"<peg::Alt3<P1, P2, P3> as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        self.0.p(s).or_else(|| self.1.p(s).or_else(|| self.2.p(s)))\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::Alt<P1, P2> as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        self.0.p(s).or_else(|| self.1.p(s))\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::FailIf<P> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        match self.0.p(s) {\n            Some(_) => None,\n            None => Some(0),\n        }\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::Inclusive<std::ops::Range<u8>> as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        OneByte(|x| x >= self.0.start && x <= self.0.end).p(s)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::OneByte<F> as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        if s.is_empty() || !self.0(s[0]) {\n            None\n        } else {\n            Some(1)\n        }\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::OneChar<F> as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        if let Some((ch, len)) = decode_utf8(s) {\n            if self.0(ch) {\n                return Some(len);\n            }\n        }\n        None\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::OneOf<'a, P> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        for p in self.0.iter() {\n            if let Some(len) = p.p(s) {\n                return Some(len);\n            }\n        }\n        None\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::OneOrMore<P> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        Repeat(Ref(&self.0), 1..).p(s)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::Optional<P> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        self.0.p(s).or(Some(0))\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::Ref<'a, P> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        self.0.p(s)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::Repeat<P, std::ops::Range<usize>> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        let Repeat(ref p, ops::Range { start, end }) = *self;\n        let mut i = 0;\n        let mut count = 0;\n        while count + 1 < end {\n            if let Some(len) = p.p(&s[i..]) {\n                i += len;\n                count += 1;\n            } else {\n                break;\n            }\n        }\n        if count >= start {\n            Some(i)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::Repeat<P, std::ops::RangeFrom<usize>> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        let Repeat(ref p, ops::RangeFrom { start }) = *self;\n        let mut i = 0;\n        let mut count = 0;\n        while let Some(len) = p.p(&s[i..]) {\n            i += len;\n            count += 1;\n        }\n        if count >= start {\n            Some(i)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::Repeat<P, std::ops::RangeFull> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        ZeroOrMore(Ref(&self.0)).p(s)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::Repeat<P, std::ops::RangeTo<usize>> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        let Repeat(ref p, ops::RangeTo { end }) = *self;\n        Repeat(Ref(p), 0..end).p(s)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::Repeat<P, usize> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        let Repeat(ref p, reps) = *self;\n        let mut i = 0;\n        let mut count = 0;\n        while count < reps {\n            if let Some(len) = p.p(&s[i..]) {\n                i += len;\n                count += 1;\n            } else {\n                break;\n            }\n        }\n        Some(i)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<peg::ZeroOrMore<P> as peg::Peg>::p":["#[inline]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        let mut i = 0;\n        while let Some(len) = self.0.p(&s[i..]) {\n            i += len;\n        }\n        Some(i)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<std::ops::Range<u8> as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        OneByte(|x| x >= self.start && x < self.end).p(s)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"<u8 as peg::Peg>::p":["#[inline(always)]\nfn p(&self, s: &[u8]) -> Option<usize>{\n        OneByte(|b| b == *self).p(s)\n    }","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"LangPlugin":["struct LangPlugin {\n    view_states: HashMap<ViewId, ViewState>,\n}","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"LangPlugin::new":["fn new() -> LangPlugin{\n        LangPlugin { view_states: HashMap::new() }\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"ViewState":["struct ViewState {\n    current_language: LanguageId,\n    parser: Box<dyn Parser>,\n    offset: usize,\n    initial_state: State,\n    spans_start: usize,\n    spans: Vec<ScopeSpan>,\n    scope_offset: u32,\n}","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"ViewState::compute_syntax":["fn compute_syntax(&mut self, line: &str) -> State{\n        let _guard = trace_block(\"ExperimentalLang::compute_syntax\", &[\"experimental-lang\"]);\n\n        let mut i = 0;\n        let mut state = self.initial_state;\n        while i < line.len() {\n            let (prevlen, s0, len, s1) = self.parser.parse(&line[i..], state);\n\n            if prevlen > 0 {\n                // TODO: maybe make an iterator to avoid this duplication\n                let scope_id = self.parser.get_scope_id_for_state(self.initial_state);\n\n                let start = self.offset - self.spans_start + i;\n                let end = start + prevlen;\n\n                let span = ScopeSpan { start, end, scope_id };\n                self.spans.push(span);\n\n                i += prevlen;\n            }\n\n            let scope_id = self.parser.get_scope_id_for_state(s0);\n\n            let start = self.offset - self.spans_start + i;\n            let end = start + len;\n\n            let span = ScopeSpan { start, end, scope_id };\n            self.spans.push(span);\n\n            i += len;\n            state = s1;\n        }\n\n        state\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"ViewState::do_highlighting":["fn do_highlighting(&mut self, view: &mut View<StateCache<State>>){\n        self.offset = 0;\n        self.spans_start = 0;\n        self.initial_state = State::default();\n        self.spans = Vec::new();\n        view.get_cache().clear();\n\n        if view.get_language_id() != &self.current_language {\n            let parser: Box<dyn Parser> = match view.get_language_id().as_ref() {\n                \"Rust\" => Box::new(RustParser::new()),\n                \"Plain Text\" => Box::new(PlaintextParser::new()),\n                language_id => {\n                    trace_payload(\n                        \"unsupported language\",\n                        &[\"experimental-lang\"],\n                        format!(\"language id: {}\", language_id),\n                    );\n                    Box::new(PlaintextParser::new())\n                }\n            };\n\n            self.current_language = view.get_language_id().clone();\n            self.parser = parser;\n        }\n\n        let scopes = self.parser.get_all_scopes();\n        view.add_scopes(&scopes);\n\n        if !self.parser.has_offset() {\n            self.parser.set_scope_offset(self.scope_offset);\n            self.scope_offset += scopes.len() as u32;\n        }\n\n        view.schedule_idle();\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"ViewState::flush_spans":["fn flush_spans(&mut self, view: &mut View<StateCache<State>>){\n        if self.spans_start != self.offset {\n            trace_payload(\n                \"flushing spans\",\n                &[\"experimental-lang\"],\n                format!(\"flushing spans: {:?}\", self.spans),\n            );\n            view.update_spans(self.spans_start, self.offset - self.spans_start, &self.spans);\n            self.spans.clear();\n        }\n\n        self.spans_start = self.offset;\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"ViewState::highlight_one_line":["fn highlight_one_line(&mut self, view: &mut View<StateCache<State>>) -> bool{\n        if let Some(line_num) = view.get_frontier() {\n            let (line_num, offset, _state) = view.get_prev(line_num);\n\n            if offset != self.offset {\n                self.flush_spans(view);\n                self.offset = offset;\n                self.spans_start = offset;\n            }\n\n            let new_frontier = match view.get_line(line_num) {\n                Ok(\"\") => None,\n                Ok(line) => {\n                    let new_state = self.compute_syntax(line);\n                    self.offset += line.len();\n\n                    if line.as_bytes().last() == Some(&b'\\n') {\n                        Some((new_state, line_num + 1))\n                    } else {\n                        None\n                    }\n                }\n                Err(_) => None,\n            };\n\n            let mut converged = false;\n            if let Some((ref new_state, new_line_num)) = new_frontier {\n                if let Some(old_state) = view.get(new_line_num) {\n                    converged = old_state == new_state;\n                }\n            }\n\n            if !converged {\n                if let Some((new_state, new_line_num)) = new_frontier {\n                    view.set(new_line_num, new_state);\n                    view.update_frontier(new_line_num);\n                    return true;\n                }\n            }\n\n            view.close_frontier();\n        }\n\n        false\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"ViewState::new":["fn new() -> ViewState{\n        ViewState {\n            current_language: LanguageId::from(\"Plain Text\"),\n            parser: Box::new(PlaintextParser::new()),\n            offset: 0,\n            initial_state: State::default(),\n            spans_start: 0,\n            spans: Vec::new(),\n            scope_offset: 0,\n        }\n    }","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"language::plaintext::PlaintextParser":["pub struct PlaintextParser {\n    scope_offset: Option<u32>,\n    ctx: Context<()>,\n}","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))"],"language::plaintext::PlaintextParser::new":["pub fn new() -> PlaintextParser{\n        PlaintextParser { scope_offset: None, ctx: Context::new() }\n    }","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))"],"language::rust::OneOrMoreWithSep":["struct OneOrMoreWithSep<P, SEP>(P, SEP);","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::RustParser":["pub struct RustParser {\n    scope_offset: Option<u32>,\n    ctx: Context<StateEl>,\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::RustParser::new":["pub fn new() -> RustParser{\n        RustParser { scope_offset: None, ctx: Context::new() }\n    }","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::RustParser::quoted_str":["fn quoted_str(&mut self, t: &[u8], state: State) -> (usize, State, usize, State){\n        let mut i = 0;\n        while i < t.len() {\n            let b = t[i];\n            if b == b'\"' {\n                return (0, state, i + 1, self.ctx.pop(state).unwrap());\n            } else if b == b'\\\\' {\n                if let Some(len) = escape.p(&t[i..]) {\n                    return (i, self.ctx.push(state, StateEl::CharConst), len, state);\n                } else if let Some(len) =\n                    (FailIf(OneOf(b\"\\r\\nbu\")), OneChar(|_| true)).p(&t[i + 1..])\n                {\n                    return (i + 1, self.ctx.push(state, StateEl::Invalid), len, state);\n                }\n            }\n            i += 1;\n        }\n        (0, state, i, state)\n    }","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::StateEl":["pub enum StateEl {\n    Source,\n    StrQuote,\n    CharQuote,\n    Comment,\n    // One for each /*\n    CharConst,\n    NumericLiteral,\n    Invalid,\n    Keyword,\n    Operator,\n    PrimType,\n    //RawStrHash,  // One for each hash in a raw string\n    //Block,    // One for each {\n    //Bracket,  // One for each [\n    //Paren,    // One for each (\n    // generics etc\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::StateEl::scope_id":["pub fn scope_id(&self) -> ScopeId{\n        match self {\n            StateEl::Source => 0,\n            StateEl::StrQuote => 1,\n            StateEl::CharQuote => 2,\n            StateEl::Comment => 3,\n            StateEl::CharConst => 4,\n            StateEl::NumericLiteral => 5,\n            StateEl::Invalid => 6,\n            StateEl::Keyword => 7,\n            StateEl::Operator => 8,\n            StateEl::PrimType => 9,\n        }\n    }","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::char_literal":["fn char_literal(s: &[u8]) -> Option<usize>{\n    (b'\\'', Alt(OneChar(|c| c != '\\\\' && c != '\\''), escape), b'\\'').p(s)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::escape":["fn escape(s: &[u8]) -> Option<usize>{\n    (\n        b'\\\\',\n        Alt3(\n            OneOf(b\"\\\\\\'\\\"0nrt\"),\n            (b'x', Repeat(OneByte(is_hex_digit), 2)),\n            (\"u{\", Repeat(OneByte(is_hex_digit), 1..7), b'}'),\n        ),\n    )\n        .p(s)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::ident":["fn ident(s: &[u8]) -> Option<usize>{\n    (OneByte(is_ident_start), ZeroOrMore(OneByte(is_ident_continue))).p(s)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::int_suffix":["fn int_suffix(s: &[u8]) -> Option<usize>{\n    (Alt(b'u', b'i'), OneOf(&[\"8\", \"16\", \"32\", \"64\", \"128\", \"size\"])).p(s)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::is_digit":["fn is_digit(c: u8) -> bool{\n    c >= b'0' && c <= b'9'\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::is_hex_digit":["fn is_hex_digit(c: u8) -> bool{\n    (c >= b'0' && c <= b'9') || (c >= b'a' && c <= b'f') || (c >= b'A' && c <= b'F')\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::is_ident_continue":["fn is_ident_continue(c: u8) -> bool{\n    is_ident_start(c) || is_digit(c)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::is_ident_start":["fn is_ident_start(c: u8) -> bool{\n    (c >= b'A' && c <= b'Z') || (c >= b'a' && c <= b'z') || c == b'_'\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::numeric_literal":["fn numeric_literal(s: &[u8]) -> Option<usize>{\n    (Optional(b'-'), Alt(positive_nondecimal, positive_decimal)).p(s)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::positive_decimal":["fn positive_decimal(s: &[u8]) -> Option<usize>{\n    (\n        raw_numeric,\n        Alt(\n            int_suffix,\n            (\n                Optional((b'.', FailIf(OneByte(is_ident_start)), Optional(raw_numeric))),\n                Optional((Alt(b'e', b'E'), Optional(Alt(b'+', b'-')), raw_numeric)),\n                Optional(Alt(\"f32\", \"f64\")),\n            ),\n        ),\n    )\n        .p(s)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::positive_nondecimal":["fn positive_nondecimal(s: &[u8]) -> Option<usize>{\n    (\n        b'0',\n        Alt3(\n            (b'x', OneOrMoreWithSep(OneByte(is_hex_digit), b'_')),\n            (b'o', OneOrMoreWithSep(Inclusive(b'0'..b'7'), b'_')),\n            (b'b', OneOrMoreWithSep(Alt(b'0', b'1'), b'_')),\n        ),\n        Optional(int_suffix),\n    )\n        .p(s)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::raw_numeric":["fn raw_numeric(s: &[u8]) -> Option<usize>{\n    (OneByte(is_digit), ZeroOrMore(Alt(b'_', OneByte(is_digit)))).p(s)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::test":["pub fn test(){\n    let mut buf = String::new();\n    let _ = stdin().read_to_string(&mut buf).unwrap();\n    let mut c = RustParser::new();\n\n    let mut state = State::default();\n    for line in buf.lines() {\n        let mut i = 0;\n        while i < line.len() {\n            let (prevlen, s0, len, s1) = c.parse(&line[i..], state);\n            if prevlen > 0 {\n                println!(\"{}: {:?}\", &line[i..i + prevlen], state);\n                i += prevlen;\n            }\n            println!(\"{}: {:?}\", &line[i..i + len], s0);\n            i += len;\n            state = s1;\n        }\n    }\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"language::rust::whitespace":["fn whitespace(s: &[u8]) -> Option<usize>{\n    // 0x0B -> \\v\n    // 0x0C -> \\f\n    (OneOrMore(OneOf(&[b' ', b'\\t', b'\\n', b'\\r', 0x0B, 0x0C]))).p(s)\n}","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))"],"main":["fn main(){\n    if let Some(ref s) = env::args().nth(1) {\n        if s == \"test\" {\n            language::rust::test();\n            return;\n        }\n    }\n\n    let mut plugin = LangPlugin::new();\n    mainloop(&mut plugin).unwrap()\n}","Real(LocalPath(\"experimental/lang/src/main.rs\"))"],"parser::Parser":["/// Trait for abstracting over text parsing and [Scope] extraction\npub trait Parser {\n    fn has_offset(&mut self) -> bool;\n    fn set_scope_offset(&mut self, offset: u32);\n    fn get_all_scopes(&self) -> Vec<Vec<String>>;\n    fn get_scope_id_for_state(&self, state: State) -> ScopeId;\n    fn parse(&mut self, text: &str, state: State) -> (usize, State, usize, State);\n}","Real(LocalPath(\"experimental/lang/src/parser.rs\"))"],"peg::Alt":["/// Choice from two heterogeneous alternatives.\npub struct Alt<P1, P2>(pub P1, pub P2);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::Alt3":["/// Choice from three heterogeneous alternatives.\npub struct Alt3<P1, P2, P3>(pub P1, pub P2, pub P3);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::FailIf":["/// Fail to match if the arg matches, otherwise match empty.\npub struct FailIf<P>(pub P);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::Inclusive":["/// Use Inclusive(a..b) to indicate an inclusive range. When a...b syntax becomes\n/// stable, we'll get rid of this and switch to that.\npub struct Inclusive<T>(pub T);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::OneByte":["pub struct OneByte<F>(pub F);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::OneChar":["pub struct OneChar<F>(pub F);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::OneOf":["/// Choice from a homogenous slice of parsers.\npub struct OneOf<'a, P: 'a>(pub &'a [P]);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::OneOrMore":["#[allow(dead_code)]\npub struct OneOrMore<P>(pub P);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::Optional":["pub struct Optional<P>(pub P);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::Peg":["pub trait Peg {\n    fn p(&self, s: &[u8]) -> Option<usize>;\n}","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::Ref":["/// A wrapper to use whenever you have a reference to a Peg object\npub struct Ref<'a, P: 'a>(pub &'a P);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::Repeat":["/// Repetition with a minimum and maximum (inclusive) bound\npub struct Repeat<P, R>(pub P, pub R);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::ZeroOrMore":["pub struct ZeroOrMore<P>(pub P);","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::char_helper":["fn char_helper(s: &[u8], c: char) -> Option<usize>{\n    OneChar(|x| x == c).p(s)\n}","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"peg::decode_utf8":["fn decode_utf8(s: &[u8]) -> Option<(char, usize)>{\n    if s.is_empty() {\n        return None;\n    }\n    let b = s[0];\n    if b < 0x80 {\n        return Some((b as char, 1));\n    } else if b >= 0xc2 && b < 0xe0 && s.len() >= 2 {\n        let b2 = s[1];\n        if (b2 as i8) > -0x40 {\n            return None;\n        }\n        let cp = (u32::from(b) << 6) + u32::from(b2) - 0x3080;\n        return from_u32(cp).map(|ch| (ch, 2));\n    } else if b >= 0xe0 && b < 0xf0 && s.len() >= 3 {\n        let b2 = s[1];\n        let b3 = s[2];\n        if (b2 as i8) > -0x40 || (b3 as i8) > -0x40 {\n            return None;\n        }\n        let cp = (u32::from(b) << 12) + (u32::from(b2) << 6) + u32::from(b3) - 0xe2080;\n        if cp < 0x800 {\n            return None;\n        } // overlong encoding\n        return from_u32(cp).map(|ch| (ch, 3));\n    } else if b >= 0xf0 && b < 0xf5 && s.len() >= 4 {\n        let b2 = s[1];\n        let b3 = s[2];\n        let b4 = s[3];\n        if (b2 as i8) > -0x40 || (b3 as i8) > -0x40 || (b4 as i8) > -0x40 {\n            return None;\n        }\n        let cp =\n            (u32::from(b) << 18) + (u32::from(b2) << 12) + (u32::from(b3) << 6) + u32::from(b4)\n                - 0x03c8_2080;\n        if cp < 0x10000 {\n            return None;\n        } // overlong encoding\n        return from_u32(cp).map(|ch| (ch, 4));\n    }\n    None\n}","Real(LocalPath(\"experimental/lang/src/peg.rs\"))"],"statestack::Context":["/// All states are interpreted in a context.\npub struct Context<T> {\n    // oddly enough, this is 1-based, as state 0 doesn't have an entry.\n    entries: Vec<Entry<T>>,\n\n    next: HashMap<(State, T), State>,\n}","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))"],"statestack::Context::<T>::entry":["fn entry(&self, s: State) -> Option<&Entry<T>>{\n        if s.0 == 0 {\n            None\n        } else {\n            Some(&self.entries[s.0 - 1])\n        }\n    }","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))"],"statestack::Context::<T>::new":["pub fn new() -> Context<T>{\n        Context { entries: Vec::new(), next: HashMap::new() }\n    }","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))"],"statestack::Context::<T>::pop":["pub fn pop(&self, s: State) -> Option<State>{\n        self.entry(s).map(|entry| entry.prev)\n    }","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))"],"statestack::Context::<T>::push":["pub fn push(&mut self, s: State, el: T) -> State{\n        let entries = &mut self.entries;\n        *self.next.entry((s, el.clone())).or_insert_with(|| {\n            entries.push(Entry { tos: el, prev: s });\n            State(entries.len())\n        })\n    }","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))"],"statestack::Context::<T>::tos":["/// The top of the stack for the given state.\npub fn tos(&self, s: State) -> Option<T>{\n        self.entry(s).map(|entry| entry.tos.clone())\n    }","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))"],"statestack::Entry":["struct Entry<T> {\n    tos: T,\n    prev: State,\n}","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))"],"statestack::State":["/// An entire state stack is represented as a single integer.\npub struct State(usize);","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))"]},"struct_constructor":{"(char, usize)":["decode_utf8"],"(usize, statestack::State, usize, statestack::State)":["parse","quoted_str"],"LangPlugin":["new"],"ViewState":["new"],"bool":["eq","has_offset","highlight_one_line","is_digit","is_hex_digit","is_ident_continue","is_ident_start"],"language::plaintext::PlaintextParser":["new"],"language::rust::RustParser":["new"],"language::rust::StateEl":["clone"],"statestack::Context":["new"],"statestack::State":["clone","compute_syntax","default"],"std::vec::Vec":["get_all_scopes"],"u32":["get_scope_id_for_state","scope_id"],"usize":["char_helper","char_literal","escape","ident","int_suffix","numeric_literal","p","positive_decimal","positive_nondecimal","raw_numeric","whitespace"]},"struct_to_trait":{"<F as peg::Peg>::F":["peg::Peg"],"LangPlugin":["xi_plugin_lib::Plugin"],"language::plaintext::PlaintextParser":["parser::Parser"],"language::rust::OneOrMoreWithSep":["peg::Peg"],"language::rust::RustParser":["parser::Parser"],"language::rust::StateEl":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"peg::Alt":["peg::Peg"],"peg::Alt3":["peg::Peg"],"peg::FailIf":["peg::Peg"],"peg::Inclusive":["peg::Peg"],"peg::OneByte":["peg::Peg"],"peg::OneChar":["peg::Peg"],"peg::OneOf":["peg::Peg"],"peg::OneOrMore":["peg::Peg"],"peg::Optional":["peg::Peg"],"peg::Ref":["peg::Peg"],"peg::Repeat":["peg::Peg"],"peg::ZeroOrMore":["peg::Peg"],"statestack::State":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"std::ops::Range":["peg::Peg"]},"targets":{"<&'a [u8] as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<&'a str as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<(P1, P2) as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<(P1, P2, P3) as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<(P1, P2, P3, P4) as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<F as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<LangPlugin as xi_plugin_lib::Plugin>::config_changed":["config_changed","Real(LocalPath(\"experimental/lang/src/main.rs\"))","xi_plugin_lib::Plugin"],"<LangPlugin as xi_plugin_lib::Plugin>::did_close":["did_close","Real(LocalPath(\"experimental/lang/src/main.rs\"))","xi_plugin_lib::Plugin"],"<LangPlugin as xi_plugin_lib::Plugin>::did_save":["did_save","Real(LocalPath(\"experimental/lang/src/main.rs\"))","xi_plugin_lib::Plugin"],"<LangPlugin as xi_plugin_lib::Plugin>::idle":["idle","Real(LocalPath(\"experimental/lang/src/main.rs\"))","xi_plugin_lib::Plugin"],"<LangPlugin as xi_plugin_lib::Plugin>::language_changed":["language_changed","Real(LocalPath(\"experimental/lang/src/main.rs\"))","xi_plugin_lib::Plugin"],"<LangPlugin as xi_plugin_lib::Plugin>::new_view":["new_view","Real(LocalPath(\"experimental/lang/src/main.rs\"))","xi_plugin_lib::Plugin"],"<LangPlugin as xi_plugin_lib::Plugin>::update":["update","Real(LocalPath(\"experimental/lang/src/main.rs\"))","xi_plugin_lib::Plugin"],"<char as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<language::plaintext::PlaintextParser as parser::Parser>::get_all_scopes":["get_all_scopes","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))","parser::Parser"],"<language::plaintext::PlaintextParser as parser::Parser>::get_scope_id_for_state":["get_scope_id_for_state","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))","parser::Parser"],"<language::plaintext::PlaintextParser as parser::Parser>::has_offset":["has_offset","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))","parser::Parser"],"<language::plaintext::PlaintextParser as parser::Parser>::parse":["parse","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))","parser::Parser"],"<language::plaintext::PlaintextParser as parser::Parser>::set_scope_offset":["set_scope_offset","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))","parser::Parser"],"<language::rust::OneOrMoreWithSep<P, SEP> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))","peg::Peg"],"<language::rust::RustParser as parser::Parser>::get_all_scopes":["get_all_scopes","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))","parser::Parser"],"<language::rust::RustParser as parser::Parser>::get_scope_id_for_state":["get_scope_id_for_state","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))","parser::Parser"],"<language::rust::RustParser as parser::Parser>::has_offset":["has_offset","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))","parser::Parser"],"<language::rust::RustParser as parser::Parser>::parse":["parse","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))","parser::Parser"],"<language::rust::RustParser as parser::Parser>::set_scope_offset":["set_scope_offset","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))","parser::Parser"],"<peg::Alt3<P1, P2, P3> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::Alt<P1, P2> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::FailIf<P> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::Inclusive<std::ops::Range<u8>> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::OneByte<F> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::OneChar<F> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::OneOf<'a, P> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::OneOrMore<P> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::Optional<P> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::Ref<'a, P> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::Repeat<P, std::ops::Range<usize>> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::Repeat<P, std::ops::RangeFrom<usize>> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::Repeat<P, std::ops::RangeFull> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::Repeat<P, std::ops::RangeTo<usize>> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::Repeat<P, usize> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<peg::ZeroOrMore<P> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<std::ops::Range<u8> as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"<u8 as peg::Peg>::p":["p","Real(LocalPath(\"experimental/lang/src/peg.rs\"))","peg::Peg"],"LangPlugin::new":["new","Real(LocalPath(\"experimental/lang/src/main.rs\"))",""],"ViewState::compute_syntax":["compute_syntax","Real(LocalPath(\"experimental/lang/src/main.rs\"))",""],"ViewState::do_highlighting":["do_highlighting","Real(LocalPath(\"experimental/lang/src/main.rs\"))",""],"ViewState::flush_spans":["flush_spans","Real(LocalPath(\"experimental/lang/src/main.rs\"))",""],"ViewState::highlight_one_line":["highlight_one_line","Real(LocalPath(\"experimental/lang/src/main.rs\"))",""],"ViewState::new":["new","Real(LocalPath(\"experimental/lang/src/main.rs\"))",""],"language::plaintext::PlaintextParser::new":["new","Real(LocalPath(\"experimental/lang/src/language/plaintext.rs\"))",""],"language::rust::RustParser::new":["new","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::RustParser::quoted_str":["quoted_str","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::StateEl::scope_id":["scope_id","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::char_literal":["char_literal","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::escape":["escape","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::ident":["ident","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::int_suffix":["int_suffix","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::is_digit":["is_digit","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::is_hex_digit":["is_hex_digit","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::is_ident_continue":["is_ident_continue","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::is_ident_start":["is_ident_start","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::numeric_literal":["numeric_literal","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::positive_decimal":["positive_decimal","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::positive_nondecimal":["positive_nondecimal","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::raw_numeric":["raw_numeric","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::test":["test","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"language::rust::whitespace":["whitespace","Real(LocalPath(\"experimental/lang/src/language/rust.rs\"))",""],"main":["main","Real(LocalPath(\"experimental/lang/src/main.rs\"))",""],"peg::char_helper":["char_helper","Real(LocalPath(\"experimental/lang/src/peg.rs\"))",""],"peg::decode_utf8":["decode_utf8","Real(LocalPath(\"experimental/lang/src/peg.rs\"))",""],"statestack::Context::<T>::entry":["entry","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))",""],"statestack::Context::<T>::new":["new","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))",""],"statestack::Context::<T>::pop":["pop","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))",""],"statestack::Context::<T>::push":["push","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))",""],"statestack::Context::<T>::tos":["tos","Real(LocalPath(\"experimental/lang/src/statestack.rs\"))",""]},"trait_to_struct":{"parser::Parser":["language::plaintext::PlaintextParser","language::rust::RustParser"],"peg::Peg":["<F as peg::Peg>::F","language::rust::OneOrMoreWithSep","peg::Alt","peg::Alt3","peg::FailIf","peg::Inclusive","peg::OneByte","peg::OneChar","peg::OneOf","peg::OneOrMore","peg::Optional","peg::Ref","peg::Repeat","peg::ZeroOrMore","std::ops::Range"],"std::clone::Clone":["language::rust::StateEl","statestack::State"],"std::cmp::Eq":["language::rust::StateEl","statestack::State"],"std::cmp::PartialEq":["language::rust::StateEl","statestack::State"],"std::default::Default":["statestack::State"],"std::fmt::Debug":["language::rust::StateEl","statestack::State"],"std::hash::Hash":["language::rust::StateEl","statestack::State"],"std::marker::Copy":["statestack::State"],"std::marker::StructuralEq":["language::rust::StateEl","statestack::State"],"std::marker::StructuralPartialEq":["language::rust::StateEl","statestack::State"],"xi_plugin_lib::Plugin":["LangPlugin"]},"type_to_def_path":{"LangPlugin":"LangPlugin","ViewState":"ViewState","language::plaintext::PlaintextParser":"language::plaintext::PlaintextParser","language::rust::OneOrMoreWithSep<P, SEP>":"language::rust::OneOrMoreWithSep","language::rust::RustParser":"language::rust::RustParser","language::rust::StateEl":"language::rust::StateEl","peg::Alt3<P1, P2, P3>":"peg::Alt3","peg::Alt<P1, P2>":"peg::Alt","peg::FailIf<P>":"peg::FailIf","peg::Inclusive<T>":"peg::Inclusive","peg::OneByte<F>":"peg::OneByte","peg::OneChar<F>":"peg::OneChar","peg::OneOf<'a, P>":"peg::OneOf","peg::OneOrMore<P>":"peg::OneOrMore","peg::Optional<P>":"peg::Optional","peg::Ref<'a, P>":"peg::Ref","peg::Repeat<P, R>":"peg::Repeat","peg::ZeroOrMore<P>":"peg::ZeroOrMore","statestack::Context<T>":"statestack::Context","statestack::Entry<T>":"statestack::Entry","statestack::State":"statestack::State"}}