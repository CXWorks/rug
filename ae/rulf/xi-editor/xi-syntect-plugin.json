{"dependencies":{"<EditType as std::clone::Clone>::clone":["EditType"],"<EditType as std::cmp::PartialEq>::eq":["EditType"],"<EditType as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<IndentationTask as std::clone::Clone>::clone":["IndentationTask","std::marker::Sized","std::ops::Range"],"<IndentationTask as std::cmp::PartialEq>::eq":["IndentationTask","std::marker::Sized","std::ops::Range"],"<Syntect<'a> as xi_plugin_lib::Plugin>::config_changed":["Syntect","serde_json::Map","std::collections::HashMap","std::marker::Sized","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"<Syntect<'a> as xi_plugin_lib::Plugin>::custom_command":["Syntect","serde_json::Value","std::collections::HashMap","std::marker::Sized","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"<Syntect<'a> as xi_plugin_lib::Plugin>::did_close":["Syntect","std::collections::HashMap","std::marker::Sized","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"<Syntect<'a> as xi_plugin_lib::Plugin>::did_save":["Syntect","std::collections::HashMap","std::marker::Sized","std::option::Option","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"<Syntect<'a> as xi_plugin_lib::Plugin>::idle":["Syntect","std::collections::HashMap","std::marker::Sized","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"<Syntect<'a> as xi_plugin_lib::Plugin>::language_changed":["Syntect","std::collections::HashMap","std::marker::Sized","syntect::parsing::SyntaxSet","xi_core::LanguageId","xi_plugin_lib::View"],"<Syntect<'a> as xi_plugin_lib::Plugin>::new_view":["Syntect","std::collections::HashMap","std::marker::Sized","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"<Syntect<'a> as xi_plugin_lib::Plugin>::update":["Syntect","std::collections::HashMap","std::marker::Sized","std::option::Option","std::string::String","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"<stackmap::LookupResult as std::cmp::PartialEq>::eq":["stackmap::LookupResult"],"<stackmap::LookupResult as std::fmt::Debug>::fmt":["stackmap::LookupResult","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<stackmap::Node as std::default::Default>::default":["stackmap::Node","std::collections::HashMap","std::marker::Sized","std::option::Option"],"<stackmap::Node as std::fmt::Debug>::fmt":["stackmap::Node","std::collections::HashMap","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<stackmap::StackMap as std::default::Default>::default":["stackmap::Node","stackmap::StackMap","std::collections::HashMap","std::marker::Sized","std::option::Option"],"<stackmap::StackMap as std::fmt::Debug>::fmt":["stackmap::Node","stackmap::StackMap","std::collections::HashMap","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"EditType":["EditType"],"IndentationTask":["IndentationTask","std::marker::Sized","std::ops::Range"],"PluginState":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"PluginState::autoindent_line":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View","xi_rope::DeltaBuilder","xi_rope::tree::NodeInfo"],"PluginState::bulk_autoindent":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::ops::Range","std::option::Option","std::result::Result","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View","xi_rope::DeltaBuilder","xi_rope::tree::NodeInfo"],"PluginState::check_indent_active_edit":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View","xi_rope::DeltaBuilder","xi_rope::tree::NodeInfo"],"PluginState::compute_syntax":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","syntect::parsing::SyntaxSet"],"PluginState::consider_indentation":["EditType","PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","xi_plugin_lib::View","xi_rope::Delta","xi_rope::tree::NodeInfo"],"PluginState::flush_spans":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","xi_plugin_lib::View"],"PluginState::get_metadata":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"PluginState::highlight_one_line":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"PluginState::identifier_for_stack":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::MutexGuard","std::vec::Vec","syntect::parsing::ScopeStack"],"PluginState::indent_level_of_line":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","xi_plugin_lib::View"],"PluginState::indent_lines":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"PluginState::insert_comment_marker":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::ops::Range","std::option::Option","std::vec::Vec","xi_plugin_lib::View","xi_rope::DeltaBuilder","xi_rope::tree::NodeInfo"],"PluginState::new":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"PluginState::previous_nonblank_line":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","xi_plugin_lib::View"],"PluginState::reindent":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"PluginState::remove_comment_marker":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::ops::Range","std::option::Option","std::vec::Vec","xi_plugin_lib::View","xi_rope::DeltaBuilder","xi_rope::tree::NodeInfo"],"PluginState::set_indent":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","xi_plugin_lib::View","xi_rope::DeltaBuilder","xi_rope::tree::NodeInfo"],"PluginState::test_decrease":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"PluginState::test_increase":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"PluginState::toggle_comment":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"PluginState::toggle_comment_line_range":["PluginState","stackmap::Node","stackmap::StackMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::ops::Range","std::option::Option","std::vec::Vec","syntect::parsing::SyntaxSet","xi_plugin_lib::View","xi_rope::DeltaBuilder","xi_rope::tree::NodeInfo"],"Syntect":["Syntect","std::collections::HashMap","std::marker::Sized","syntect::parsing::SyntaxSet"],"Syntect::<'a>::do_highlighting":["Syntect","std::collections::HashMap","std::marker::Sized","syntect::parsing::SyntaxSet","xi_plugin_lib::View"],"Syntect::<'a>::new":["Syntect","std::collections::HashMap","std::marker::Sized","syntect::parsing::SyntaxSet"],"main":[],"n_spaces":[],"n_tabs":[],"stackmap::LookupResult":["stackmap::LookupResult"],"stackmap::LookupResult::is_new":["stackmap::LookupResult"],"stackmap::Node":["stackmap::Node","std::collections::HashMap","std::marker::Sized","std::option::Option"],"stackmap::Node::get_value":["stackmap::LookupResult","stackmap::Node","std::collections::HashMap","std::marker::Sized","std::option::Option","syntect::parsing::Scope"],"stackmap::Node::new":["stackmap::Node","std::collections::HashMap","std::marker::Sized","std::option::Option"],"stackmap::StackMap":["stackmap::Node","stackmap::StackMap","std::collections::HashMap","std::marker::Sized","std::option::Option"],"stackmap::StackMap::get_value":["stackmap::LookupResult","stackmap::Node","stackmap::StackMap","std::collections::HashMap","std::marker::Sized","std::option::Option","syntect::parsing::Scope"]},"glob_path_import":{},"self_to_fn":{"EditType":["Clone","Copy","PartialEq","impl FromStr for EditType {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<EditType, ()> {\n        match s {\n            \"insert\" => Ok(EditType::Insert),\n            \"newline\" => Ok(EditType::Newline),\n            \"other\" => Ok(EditType::Other),\n            _ => Err(()),\n        }\n    }\n}"],"IndentationTask":["Clone","PartialEq"],"PluginState":["impl<'a> PluginState {\n    fn new() -> Self {\n        PluginState {\n            stack_idents: StackMap::default(),\n            offset: 0,\n            initial_state: None,\n            spans_start: 0,\n            spans: Vec::new(),\n            new_scopes: Vec::new(),\n            indentation_state: Vec::new(),\n        }\n    }\n\n    /// Compute syntax for one line, optionally also accumulating the style spans.\n    ///\n    /// NOTE: `accumulate_spans` should be true if we're doing syntax highlighting,\n    /// and want to update the client. It should be `false` if we need syntax\n    /// information for another purpose, such as auto-indent.\n    fn compute_syntax(\n        &mut self,\n        line: &str,\n        state: LineState,\n        syntax_set: &SyntaxSet,\n        accumulate_spans: bool,\n    ) -> LineState {\n        let (mut parse_state, mut scope_state) =\n            state.or_else(|| self.initial_state.clone()).unwrap();\n        let ops = parse_state.parse_line(&line, syntax_set);\n\n        let mut prev_cursor = 0;\n        let repo = SCOPE_REPO.lock().unwrap();\n        for (cursor, batch) in ops {\n            if !scope_state.is_empty() {\n                let scope_id = self.identifier_for_stack(&scope_state, &repo);\n                let start = self.offset - self.spans_start + prev_cursor;\n                let end = start + (cursor - prev_cursor);\n                if accumulate_spans && start != end {\n                    let span = ScopeSpan { start, end, scope_id };\n                    self.spans.push(span);\n                }\n            }\n            prev_cursor = cursor;\n            scope_state.apply(&batch);\n        }\n\n        if accumulate_spans {\n            // add span for final state\n            let start = self.offset - self.spans_start + prev_cursor;\n            let end = start + (line.len() - prev_cursor);\n            let scope_id = self.identifier_for_stack(&scope_state, &repo);\n            let span = ScopeSpan { start, end, scope_id };\n            self.spans.push(span);\n        }\n        Some((parse_state, scope_state))\n    }\n\n    /// Returns the unique identifier for this `ScopeStack`. We use identifiers\n    /// so we aren't constantly sending long stack names to the peer.\n    fn identifier_for_stack(&mut self, stack: &ScopeStack, repo: &LockedRepo) -> u32 {\n        let identifier = self.stack_idents.get_value(stack.as_slice());\n        match identifier {\n            LookupResult::Existing(id) => id,\n            LookupResult::New(id) => {\n                let stack_strings =\n                    stack.as_slice().iter().map(|slice| repo.to_string(*slice)).collect::<Vec<_>>();\n                self.new_scopes.push(stack_strings);\n                id\n            }\n        }\n    }\n\n    // Return true if there's any more work to be done.\n    fn highlight_one_line(&mut self, ctx: &mut MyView, syntax_set: &SyntaxSet) -> bool {\n        if let Some(line_num) = ctx.get_frontier() {\n            let (line_num, offset, state) = ctx.get_prev(line_num);\n            if offset != self.offset {\n                self.flush_spans(ctx);\n                self.offset = offset;\n                self.spans_start = offset;\n            }\n            let new_frontier = match ctx.get_line(line_num) {\n                Ok(\"\") => None,\n                Ok(s) => {\n                    let new_state = self.compute_syntax(s, state, syntax_set, true);\n                    self.offset += s.len();\n                    if s.as_bytes().last() == Some(&b'\\n') {\n                        Some((new_state, line_num + 1))\n                    } else {\n                        None\n                    }\n                }\n                Err(_) => None,\n            };\n            let mut converged = false;\n            if let Some((ref new_state, new_line_num)) = new_frontier {\n                if let Some(old_state) = ctx.get(new_line_num) {\n                    converged = old_state.as_ref().unwrap().0 == new_state.as_ref().unwrap().0;\n                }\n            }\n            if !converged {\n                if let Some((new_state, new_line_num)) = new_frontier {\n                    ctx.set(new_line_num, new_state);\n                    ctx.update_frontier(new_line_num);\n                    return true;\n                }\n            }\n            ctx.close_frontier();\n        }\n        false\n    }\n\n    fn flush_spans(&mut self, ctx: &mut MyView) {\n        let _t = trace_block(\"PluginState::flush_spans\", &[\"syntect\"]);\n        if !self.new_scopes.is_empty() {\n            ctx.add_scopes(&self.new_scopes);\n            self.new_scopes.clear();\n        }\n        if self.spans_start != self.offset {\n            ctx.update_spans(self.spans_start, self.offset - self.spans_start, &self.spans);\n            self.spans.clear();\n        }\n        self.spans_start = self.offset;\n    }\n\n    pub fn indent_lines(&mut self, view: &mut MyView, syntax_set: &SyntaxSet) {\n        let mut builder = DeltaBuilder::new(view.get_buf_size());\n\n        for indentation_task in self.indentation_state.to_vec() {\n            match indentation_task {\n                IndentationTask::Newline(line) => self\n                    .autoindent_line(view, &mut builder, syntax_set, line)\n                    .expect(\"auto-indent error on newline\"),\n                IndentationTask::Edit(line) => self\n                    .check_indent_active_edit(view, &mut builder, syntax_set, line)\n                    .expect(\"auto-indent error on insert\"),\n                IndentationTask::Batch(range) => self\n                    .bulk_autoindent(view, &mut builder, syntax_set, range)\n                    .expect(\"auto-indent error on other\"),\n            };\n        }\n\n        if !builder.is_empty() {\n            view.edit(builder.build(), INDENTATION_PRIORITY, false, false, String::from(\"syntect\"));\n        }\n\n        self.indentation_state.clear();\n    }\n\n    /// Returns the metadata relevant to the given line. Computes the syntax\n    /// for this line (during normal editing this is only likely for line 0) if\n    /// necessary; in general reuses the syntax state calculated for highlighting.\n    fn get_metadata(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &'a SyntaxSet,\n        line: usize,\n    ) -> Option<ScopedMetadata<'a>> {\n        let text = view.get_line(line).unwrap_or(\"\");\n        let scope = self.compute_syntax(&text, None, syntax_set, false).map(|(_, scope)| scope)?;\n        Some(syntax_set.metadata().metadata_for_scope(scope.as_slice()))\n    }\n\n    /// Checks for possible auto-indent changes after an appropriate edit.\n    fn consider_indentation(&mut self, view: &mut MyView, delta: &RopeDelta, edit_type: EditType) {\n        for region in delta.iter_inserts() {\n            let line_of_edit = view.line_of_offset(region.new_offset).unwrap();\n            let last_line_of_edit = view.line_of_offset(region.new_offset + region.len).unwrap();\n            match edit_type {\n                EditType::Newline => {\n                    self.indentation_state.push(IndentationTask::Newline(line_of_edit + 1))\n                }\n                EditType::Insert => {\n                    let range = region.new_offset..region.new_offset + region.len;\n                    let is_whitespace = {\n                        let insert_region =\n                            view.get_region(range).expect(\"view must return region\");\n                        insert_region.as_bytes().iter().all(u8::is_ascii_whitespace)\n                    };\n                    if !is_whitespace {\n                        self.indentation_state.push(IndentationTask::Edit(line_of_edit));\n                    }\n                }\n                EditType::Other => {\n                    // we are mainly interested in auto-indenting after paste\n                    let range = Range { start: line_of_edit, end: last_line_of_edit };\n                    self.indentation_state.push(IndentationTask::Batch(range));\n                }\n            };\n        }\n    }\n\n    fn bulk_autoindent(\n        &mut self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        syntax_set: &SyntaxSet,\n        range: Range<usize>,\n    ) -> Result<(), Error> {\n        let _t = trace_block(\"Syntect::bulk_autoindent\", &[\"syntect\"]);\n        let tab_size = view.get_config().tab_size;\n        let use_spaces = view.get_config().translate_tabs_to_spaces;\n\n        let mut base_indent = if range.start > 0 {\n            self.previous_nonblank_line(view, range.start)?\n                .map(|l| self.indent_level_of_line(view, l))\n                .unwrap_or(0)\n        } else {\n            0\n        };\n\n        for line in range.start..=range.end {\n            let current_line_indent = self.indent_level_of_line(view, line);\n\n            if line > 0 {\n                let increase_level = self.test_increase(view, syntax_set, line)?;\n                let decrease_level = self.test_decrease(view, syntax_set, line)?;\n                let increase = if increase_level { tab_size } else { 0 };\n                let decrease = if decrease_level { tab_size } else { 0 };\n                let final_level = base_indent + increase - decrease;\n                base_indent = final_level;\n            }\n\n            if base_indent != current_line_indent {\n                let edit_start = view.offset_of_line(line)?;\n                let edit_len = {\n                    let line = view.get_line(line)?;\n                    line.as_bytes().iter().take_while(|b| **b == b' ' || **b == b'\\t').count()\n                };\n\n                let indent_text =\n                    if use_spaces { n_spaces(base_indent) } else { n_tabs(base_indent / tab_size) };\n\n                let iv = Interval::new(edit_start, edit_start + edit_len);\n                builder.replace(iv, indent_text.into());\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Called when freshly computing a line's indent level, such as after\n    /// a newline, or when re-indenting a block.\n    fn autoindent_line(\n        &mut self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        syntax_set: &SyntaxSet,\n        line: usize,\n    ) -> Result<(), Error> {\n        let _t = trace_block(\"Syntect::autoindent\", &[\"syntect\"]);\n        debug_assert!(line > 0);\n        let tab_size = view.get_config().tab_size;\n        let current_indent = self.indent_level_of_line(view, line);\n        let base_indent = self\n            .previous_nonblank_line(view, line)?\n            .map(|l| self.indent_level_of_line(view, l))\n            .unwrap_or(0);\n        let increase_level = self.test_increase(view, syntax_set, line)?;\n        let decrease_level = self.test_decrease(view, syntax_set, line)?;\n        let increase = if increase_level { tab_size } else { 0 };\n        let decrease = if decrease_level { tab_size } else { 0 };\n        let final_level = base_indent + increase - decrease;\n\n        if final_level != current_indent {\n            self.set_indent(view, builder, line, final_level)\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Called when actively editing a line; chiefly checks for whether or not\n    /// the current line should be de-indented, such as after a closing '}'.\n    fn check_indent_active_edit(\n        &mut self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        syntax_set: &SyntaxSet,\n        line: usize,\n    ) -> Result<(), Error> {\n        let _t = trace_block(\"Syntect::check_indent_active_line\", &[\"syntect\"]);\n        if line == 0 {\n            return Ok(());\n        }\n        let tab_size = view.get_config().tab_size;\n        let current_indent = self.indent_level_of_line(view, line);\n        if line == 0 || current_indent == 0 {\n            return Ok(());\n        }\n        let just_increased = self.test_increase(view, syntax_set, line)?;\n        let decrease = self.test_decrease(view, syntax_set, line)?;\n        let prev_line = self.previous_nonblank_line(view, line)?;\n        let mut indent_level = prev_line.map(|l| self.indent_level_of_line(view, l)).unwrap_or(0);\n        if decrease {\n            // the first line after an increase should just match the previous line\n            if !just_increased {\n                indent_level = indent_level.saturating_sub(tab_size);\n            }\n            // we don't want to change indent level if this line doesn't\n            // match `test_decrease`, because the user could have changed\n            // it manually, and we respect that.\n            if indent_level != current_indent {\n                return self.set_indent(view, builder, line, indent_level);\n            }\n        }\n        Ok(())\n    }\n\n    fn set_indent(\n        &self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        line: usize,\n        level: usize,\n    ) -> Result<(), Error> {\n        let edit_start = view.offset_of_line(line)?;\n        let edit_len = {\n            let line = view.get_line(line)?;\n            line.as_bytes().iter().take_while(|b| **b == b' ' || **b == b'\\t').count()\n        };\n\n        let use_spaces = view.get_config().translate_tabs_to_spaces;\n        let tab_size = view.get_config().tab_size;\n\n        let indent_text = if use_spaces { n_spaces(level) } else { n_tabs(level / tab_size) };\n\n        let iv = Interval::new(edit_start, edit_start + edit_len);\n        builder.replace(iv, indent_text.into());\n        Ok(())\n    }\n\n    /// Test whether the indent level should be increased for this line,\n    /// by testing the _previous_ line against a regex.\n    fn test_increase(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &SyntaxSet,\n        line: usize,\n    ) -> Result<bool, Error> {\n        debug_assert!(line > 0, \"increasing indent requires a previous line\");\n        let prev_line = match self.previous_nonblank_line(view, line) {\n            Ok(Some(l)) => l,\n            Ok(None) => return Ok(false),\n            Err(e) => return Err(e),\n        };\n        let metadata =\n            self.get_metadata(view, syntax_set, prev_line).ok_or(Error::PeerDisconnect)?;\n        let line = view.get_line(prev_line)?;\n\n        let comment_str = match metadata.line_comment().map(|s| s.to_owned()) {\n            Some(s) => s,\n            None => return Ok(metadata.increase_indent(line)),\n        };\n\n        // if the previous line is a comment, the indent level should not be increased\n        if line.trim().starts_with(&comment_str.trim()) {\n            Ok(false)\n        } else {\n            Ok(metadata.increase_indent(line))\n        }\n    }\n\n    /// Test whether the indent level for this line should be decreased, by\n    /// checking this line against a regex.\n    fn test_decrease(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &SyntaxSet,\n        line: usize,\n    ) -> Result<bool, Error> {\n        if line == 0 {\n            return Ok(false);\n        }\n        let metadata = self.get_metadata(view, syntax_set, line).ok_or(Error::PeerDisconnect)?;\n        let line = view.get_line(line)?;\n        Ok(metadata.decrease_indent(line))\n    }\n\n    fn previous_nonblank_line(\n        &self,\n        view: &mut MyView,\n        line: usize,\n    ) -> Result<Option<usize>, Error> {\n        debug_assert!(line > 0);\n        let mut line = line;\n        while line > 0 {\n            line -= 1;\n            let text = view.get_line(line)?;\n            if !text.bytes().all(|b| b.is_ascii_whitespace()) {\n                return Ok(Some(line));\n            }\n        }\n        Ok(None)\n    }\n\n    fn indent_level_of_line(&self, view: &mut MyView, line: usize) -> usize {\n        let tab_size = view.get_config().tab_size;\n        let line = view.get_line(line).unwrap_or(\"\");\n        line.as_bytes()\n            .iter()\n            .take_while(|b| **b == b' ' || **b == b'\\t')\n            .map(|b| if b == &b' ' { 1 } else { tab_size })\n            .sum()\n    }\n\n    fn reindent(&mut self, view: &mut MyView, syntax_set: &SyntaxSet, lines: &[(usize, usize)]) {\n        let mut builder = DeltaBuilder::new(view.get_buf_size());\n\n        for (start, end) in lines {\n            let range = Range { start: *start, end: *end - 1 };\n            self.bulk_autoindent(view, &mut builder, syntax_set, range).expect(\"error on reindent\");\n        }\n\n        view.edit(builder.build(), INDENTATION_PRIORITY, false, false, String::from(\"syntect\"));\n    }\n\n    fn toggle_comment(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &SyntaxSet,\n        lines: &[(usize, usize)],\n    ) {\n        let _t = trace_block(\"Syntect::toggle_comment\", &[\"syntect\"]);\n        if lines.is_empty() {\n            return;\n        }\n\n        let mut builder = DeltaBuilder::new(view.get_buf_size());\n\n        for (start, end) in lines {\n            let range = Range { start: *start, end: *end };\n            self.toggle_comment_line_range(view, syntax_set, &mut builder, range);\n        }\n\n        if builder.is_empty() {\n            eprintln!(\"no delta for lines {:?}\", &lines);\n        } else {\n            view.edit(builder.build(), INDENTATION_PRIORITY, false, true, String::from(\"syntect\"));\n        }\n    }\n\n    fn toggle_comment_line_range(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &SyntaxSet,\n        builder: &mut EditBuilder,\n        line_range: Range<usize>,\n    ) {\n        let comment_str = match self\n            .get_metadata(view, syntax_set, line_range.start)\n            .and_then(|s| s.line_comment().map(|s| s.to_owned()))\n        {\n            Some(s) => s,\n            None => return,\n        };\n\n        match view\n            .get_line(line_range.start)\n            .map(|l| comment_str.trim() == l.trim() || l.trim().starts_with(&comment_str))\n        {\n            Ok(true) => self.remove_comment_marker(view, builder, line_range, &comment_str),\n            Ok(false) => self.insert_comment_marker(view, builder, line_range, &comment_str),\n            Err(e) => eprintln!(\"toggle comment error: {:?}\", e),\n        }\n    }\n\n    fn insert_comment_marker(\n        &self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        line_range: Range<usize>,\n        comment_str: &str,\n    ) {\n        // when commenting out multiple lines, we insert all comment markers at\n        // the same indent level: that of the least indented line.\n        let line_offset = line_range\n            .clone()\n            .map(|num| {\n                view.get_line(num)\n                    .ok()\n                    .and_then(|line| line.as_bytes().iter().position(|b| *b != b' ' && *b != b'\\t'))\n                    .unwrap_or(0)\n            })\n            .min()\n            .unwrap_or(0);\n\n        let comment_txt = Rope::from(&comment_str);\n        for num in line_range {\n            let offset = view.offset_of_line(num).unwrap();\n            let line = view.get_line(num).unwrap();\n            if line.trim().starts_with(&comment_str) {\n                continue;\n            }\n\n            let iv = Interval::new(offset + line_offset, offset + line_offset);\n            builder.replace(iv, comment_txt.clone());\n        }\n    }\n\n    fn remove_comment_marker(\n        &self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        lines: Range<usize>,\n        comment_str: &str,\n    ) {\n        for num in lines {\n            let offset = view.offset_of_line(num).unwrap();\n            let line = view.get_line(num).unwrap();\n            let (comment_start, len) = match line.find(&comment_str) {\n                Some(off) => (offset + off, comment_str.len()),\n                None if line.trim() == comment_str.trim() => (offset, comment_str.trim().len()),\n                None => continue,\n            };\n\n            let iv = Interval::new(comment_start, comment_start + len);\n            builder.delete(iv);\n        }\n    }\n}"],"Syntect":["impl<'a> Plugin for Syntect<'a> {\n    type Cache = StateCache<LineState>;\n\n    fn new_view(&mut self, view: &mut View<Self::Cache>) {\n        let _t = trace_block(\"Syntect::new_view\", &[\"syntect\"]);\n        let view_id = view.get_id();\n        let state = PluginState::new();\n        self.view_state.insert(view_id, state);\n        self.do_highlighting(view);\n    }\n\n    fn did_close(&mut self, view: &View<Self::Cache>) {\n        self.view_state.remove(&view.get_id());\n    }\n\n    fn did_save(&mut self, view: &mut View<Self::Cache>, _old: Option<&Path>) {\n        let _t = trace_block(\"Syntect::did_save\", &[\"syntect\"]);\n        self.do_highlighting(view);\n    }\n\n    fn config_changed(&mut self, _view: &mut View<Self::Cache>, _changes: &ConfigTable) {}\n\n    fn language_changed(&mut self, view: &mut View<Self::Cache>, _old_lang: LanguageId) {\n        self.do_highlighting(view);\n    }\n\n    fn update(\n        &mut self,\n        view: &mut View<Self::Cache>,\n        delta: Option<&RopeDelta>,\n        edit_type: String,\n        author: String,\n    ) {\n        let _t = trace_block(\"Syntect::update\", &[\"syntect\"]);\n        view.schedule_idle();\n        let should_auto_indent = view.get_config().auto_indent;\n        let edit_type = edit_type.parse::<EditType>().ok();\n        if should_auto_indent\n            && author == \"core\"\n            && (edit_type == Some(EditType::Newline)\n                || edit_type == Some(EditType::Insert)\n                || edit_type == Some(EditType::Other))\n        {\n            if let Some(delta) = delta {\n                let state = self.view_state.get_mut(&view.get_id()).unwrap();\n                state.consider_indentation(view, delta, edit_type.unwrap());\n            }\n        }\n    }\n\n    fn custom_command(\n        &mut self,\n        view: &mut View<Self::Cache>,\n        method: &str,\n        params: serde_json::Value,\n    ) {\n        match method {\n            \"toggle_comment\" => {\n                let lines: Vec<(usize, usize)> = serde_json::from_value(params).unwrap();\n                let state = self.view_state.get_mut(&view.get_id()).unwrap();\n                state.toggle_comment(view, self.syntax_set, &lines);\n            }\n            \"reindent\" => {\n                let lines: Vec<(usize, usize)> = serde_json::from_value(params).unwrap();\n                let state = self.view_state.get_mut(&view.get_id()).unwrap();\n                state.reindent(view, self.syntax_set, &lines);\n            }\n            other => eprintln!(\"syntect received unexpected command {}\", other),\n        }\n    }\n\n    fn idle(&mut self, view: &mut View<Self::Cache>) {\n        let state = self.view_state.get_mut(&view.get_id()).unwrap();\n        state.indent_lines(view, self.syntax_set);\n\n        for _ in 0..LINES_PER_RPC {\n            if !state.highlight_one_line(view, self.syntax_set) {\n                state.flush_spans(view);\n                return;\n            }\n            if view.request_is_pending() {\n                trace(\"yielding for request\", &[\"syntect\"]);\n                break;\n            }\n        }\n        state.flush_spans(view);\n        view.schedule_idle();\n    }\n}","impl<'a> Syntect<'a> {\n    fn new(syntax_set: &'a SyntaxSet) -> Self {\n        Syntect { view_state: HashMap::new(), syntax_set }\n    }\n\n    /// Wipes any existing state and starts highlighting with `syntax`.\n    fn do_highlighting(&mut self, view: &mut MyView) {\n        let initial_state = {\n            let language_id = view.get_language_id();\n            let syntax = self\n                .syntax_set\n                .find_syntax_by_name(language_id.as_ref())\n                .unwrap_or_else(|| self.syntax_set.find_syntax_plain_text());\n            Some((ParseState::new(syntax), ScopeStack::new()))\n        };\n\n        let state = self.view_state.get_mut(&view.get_id()).unwrap();\n        state.initial_state = initial_state;\n        state.spans = Vec::new();\n        state.new_scopes = Vec::new();\n        state.offset = 0;\n        state.spans_start = 0;\n        view.get_cache().clear();\n        view.schedule_idle();\n    }\n}"],"stackmap::LookupResult":["Debug","PartialEq","impl LookupResult {\n    pub fn is_new(&self) -> bool {\n        matches!(*self, LookupResult::New(_))\n    }\n}"],"stackmap::Node":["Debug","Default","impl Node {\n    pub fn new(value: u32) -> Self {\n        Node { value: Some(value), children: HashMap::new() }\n    }\n\n    fn get_value(&mut self, stack: &[Scope], next_id: u32) -> LookupResult {\n        // if this is last item on the stack, get the value, inserting if necessary.\n        let first = stack.first().unwrap();\n        if stack.len() == 1 {\n            if !self.children.contains_key(first) {\n                self.children.insert(first.to_owned(), Node::new(next_id));\n                return LookupResult::New(next_id);\n            }\n\n            // if key exists, value still might not be assigned:\n            let needs_value = self.children[first].value.is_none();\n            if needs_value {\n                let node = self.children.get_mut(first).unwrap();\n                node.value = Some(next_id);\n                return LookupResult::New(next_id);\n            } else {\n                let value = self.children[first].value.unwrap();\n                return LookupResult::Existing(value);\n            }\n        }\n        // not the last item: recurse, creating node as necessary\n        if self.children.get(first).is_none() {\n            self.children.insert(first.to_owned(), Node::default());\n        }\n        self.children.get_mut(first).unwrap().get_value(&stack[1..], next_id)\n    }\n}"],"stackmap::StackMap":["Debug","Default","impl StackMap {\n    /// Returns the identifier for this stack, creating it if needed.\n    pub fn get_value(&mut self, stack: &[Scope]) -> LookupResult {\n        assert!(!stack.is_empty());\n        let result = self.scopes.get_value(stack, self.next_id);\n        if result.is_new() {\n            self.next_id += 1;\n        }\n        result\n    }\n}"]},"single_path_import":{},"srcs":{"<EditType as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<EditType, ()>{\n        match s {\n            \"insert\" => Ok(EditType::Insert),\n            \"newline\" => Ok(EditType::Newline),\n            \"other\" => Ok(EditType::Other),\n            _ => Err(()),\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"<Syntect<'a> as xi_plugin_lib::Plugin>::config_changed":["fn config_changed(&mut self, _view: &mut View<Self::Cache>, _changes: &ConfigTable){}","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"<Syntect<'a> as xi_plugin_lib::Plugin>::custom_command":["fn custom_command(\n        &mut self,\n        view: &mut View<Self::Cache>,\n        method: &str,\n        params: serde_json::Value,\n    ){\n        match method {\n            \"toggle_comment\" => {\n                let lines: Vec<(usize, usize)> = serde_json::from_value(params).unwrap();\n                let state = self.view_state.get_mut(&view.get_id()).unwrap();\n                state.toggle_comment(view, self.syntax_set, &lines);\n            }\n            \"reindent\" => {\n                let lines: Vec<(usize, usize)> = serde_json::from_value(params).unwrap();\n                let state = self.view_state.get_mut(&view.get_id()).unwrap();\n                state.reindent(view, self.syntax_set, &lines);\n            }\n            other => eprintln!(\"syntect received unexpected command {}\", other),\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"<Syntect<'a> as xi_plugin_lib::Plugin>::did_close":["fn did_close(&mut self, view: &View<Self::Cache>){\n        self.view_state.remove(&view.get_id());\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"<Syntect<'a> as xi_plugin_lib::Plugin>::did_save":["fn did_save(&mut self, view: &mut View<Self::Cache>, _old: Option<&Path>){\n        let _t = trace_block(\"Syntect::did_save\", &[\"syntect\"]);\n        self.do_highlighting(view);\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"<Syntect<'a> as xi_plugin_lib::Plugin>::idle":["fn idle(&mut self, view: &mut View<Self::Cache>){\n        let state = self.view_state.get_mut(&view.get_id()).unwrap();\n        state.indent_lines(view, self.syntax_set);\n\n        for _ in 0..LINES_PER_RPC {\n            if !state.highlight_one_line(view, self.syntax_set) {\n                state.flush_spans(view);\n                return;\n            }\n            if view.request_is_pending() {\n                trace(\"yielding for request\", &[\"syntect\"]);\n                break;\n            }\n        }\n        state.flush_spans(view);\n        view.schedule_idle();\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"<Syntect<'a> as xi_plugin_lib::Plugin>::language_changed":["fn language_changed(&mut self, view: &mut View<Self::Cache>, _old_lang: LanguageId){\n        self.do_highlighting(view);\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"<Syntect<'a> as xi_plugin_lib::Plugin>::new_view":["fn new_view(&mut self, view: &mut View<Self::Cache>){\n        let _t = trace_block(\"Syntect::new_view\", &[\"syntect\"]);\n        let view_id = view.get_id();\n        let state = PluginState::new();\n        self.view_state.insert(view_id, state);\n        self.do_highlighting(view);\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"<Syntect<'a> as xi_plugin_lib::Plugin>::update":["fn update(\n        &mut self,\n        view: &mut View<Self::Cache>,\n        delta: Option<&RopeDelta>,\n        edit_type: String,\n        author: String,\n    ){\n        let _t = trace_block(\"Syntect::update\", &[\"syntect\"]);\n        view.schedule_idle();\n        let should_auto_indent = view.get_config().auto_indent;\n        let edit_type = edit_type.parse::<EditType>().ok();\n        if should_auto_indent\n            && author == \"core\"\n            && (edit_type == Some(EditType::Newline)\n                || edit_type == Some(EditType::Insert)\n                || edit_type == Some(EditType::Other))\n        {\n            if let Some(delta) = delta {\n                let state = self.view_state.get_mut(&view.get_id()).unwrap();\n                state.consider_indentation(view, delta, edit_type.unwrap());\n            }\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"EditType":["/// Edit types that will get processed.\npub enum EditType {\n    Insert,\n    Newline,\n    Other,\n}","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"IndentationTask":["enum IndentationTask {\n    Newline(usize),\n    Edit(usize),\n    Batch(Range<usize>),\n}","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState":["/// The state for syntax highlighting of one file.\nstruct PluginState {\n    stack_idents: StackMap,\n    offset: usize,\n    initial_state: LineState,\n    spans_start: usize,\n    // unflushed spans\n    spans: Vec<ScopeSpan>,\n    new_scopes: Vec<Vec<String>>,\n    // keeps track of the lines (start, end) that might need indentation after edit\n    indentation_state: Vec<IndentationTask>,\n}","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::autoindent_line":["/// Called when freshly computing a line's indent level, such as after\n/// a newline, or when re-indenting a block.\nfn autoindent_line(\n        &mut self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        syntax_set: &SyntaxSet,\n        line: usize,\n    ) -> Result<(), Error>{\n        let _t = trace_block(\"Syntect::autoindent\", &[\"syntect\"]);\n        debug_assert!(line > 0);\n        let tab_size = view.get_config().tab_size;\n        let current_indent = self.indent_level_of_line(view, line);\n        let base_indent = self\n            .previous_nonblank_line(view, line)?\n            .map(|l| self.indent_level_of_line(view, l))\n            .unwrap_or(0);\n        let increase_level = self.test_increase(view, syntax_set, line)?;\n        let decrease_level = self.test_decrease(view, syntax_set, line)?;\n        let increase = if increase_level { tab_size } else { 0 };\n        let decrease = if decrease_level { tab_size } else { 0 };\n        let final_level = base_indent + increase - decrease;\n\n        if final_level != current_indent {\n            self.set_indent(view, builder, line, final_level)\n        } else {\n            Ok(())\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::bulk_autoindent":["fn bulk_autoindent(\n        &mut self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        syntax_set: &SyntaxSet,\n        range: Range<usize>,\n    ) -> Result<(), Error>{\n        let _t = trace_block(\"Syntect::bulk_autoindent\", &[\"syntect\"]);\n        let tab_size = view.get_config().tab_size;\n        let use_spaces = view.get_config().translate_tabs_to_spaces;\n\n        let mut base_indent = if range.start > 0 {\n            self.previous_nonblank_line(view, range.start)?\n                .map(|l| self.indent_level_of_line(view, l))\n                .unwrap_or(0)\n        } else {\n            0\n        };\n\n        for line in range.start..=range.end {\n            let current_line_indent = self.indent_level_of_line(view, line);\n\n            if line > 0 {\n                let increase_level = self.test_increase(view, syntax_set, line)?;\n                let decrease_level = self.test_decrease(view, syntax_set, line)?;\n                let increase = if increase_level { tab_size } else { 0 };\n                let decrease = if decrease_level { tab_size } else { 0 };\n                let final_level = base_indent + increase - decrease;\n                base_indent = final_level;\n            }\n\n            if base_indent != current_line_indent {\n                let edit_start = view.offset_of_line(line)?;\n                let edit_len = {\n                    let line = view.get_line(line)?;\n                    line.as_bytes().iter().take_while(|b| **b == b' ' || **b == b'\\t').count()\n                };\n\n                let indent_text =\n                    if use_spaces { n_spaces(base_indent) } else { n_tabs(base_indent / tab_size) };\n\n                let iv = Interval::new(edit_start, edit_start + edit_len);\n                builder.replace(iv, indent_text.into());\n            }\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::check_indent_active_edit":["/// Called when actively editing a line; chiefly checks for whether or not\n/// the current line should be de-indented, such as after a closing '}'.\nfn check_indent_active_edit(\n        &mut self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        syntax_set: &SyntaxSet,\n        line: usize,\n    ) -> Result<(), Error>{\n        let _t = trace_block(\"Syntect::check_indent_active_line\", &[\"syntect\"]);\n        if line == 0 {\n            return Ok(());\n        }\n        let tab_size = view.get_config().tab_size;\n        let current_indent = self.indent_level_of_line(view, line);\n        if line == 0 || current_indent == 0 {\n            return Ok(());\n        }\n        let just_increased = self.test_increase(view, syntax_set, line)?;\n        let decrease = self.test_decrease(view, syntax_set, line)?;\n        let prev_line = self.previous_nonblank_line(view, line)?;\n        let mut indent_level = prev_line.map(|l| self.indent_level_of_line(view, l)).unwrap_or(0);\n        if decrease {\n            // the first line after an increase should just match the previous line\n            if !just_increased {\n                indent_level = indent_level.saturating_sub(tab_size);\n            }\n            // we don't want to change indent level if this line doesn't\n            // match `test_decrease`, because the user could have changed\n            // it manually, and we respect that.\n            if indent_level != current_indent {\n                return self.set_indent(view, builder, line, indent_level);\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::compute_syntax":["/// Compute syntax for one line, optionally also accumulating the style spans.\n///\n/// NOTE: `accumulate_spans` should be true if we're doing syntax highlighting,\n/// and want to update the client. It should be `false` if we need syntax\n/// information for another purpose, such as auto-indent.\nfn compute_syntax(\n        &mut self,\n        line: &str,\n        state: LineState,\n        syntax_set: &SyntaxSet,\n        accumulate_spans: bool,\n    ) -> LineState{\n        let (mut parse_state, mut scope_state) =\n            state.or_else(|| self.initial_state.clone()).unwrap();\n        let ops = parse_state.parse_line(&line, syntax_set);\n\n        let mut prev_cursor = 0;\n        let repo = SCOPE_REPO.lock().unwrap();\n        for (cursor, batch) in ops {\n            if !scope_state.is_empty() {\n                let scope_id = self.identifier_for_stack(&scope_state, &repo);\n                let start = self.offset - self.spans_start + prev_cursor;\n                let end = start + (cursor - prev_cursor);\n                if accumulate_spans && start != end {\n                    let span = ScopeSpan { start, end, scope_id };\n                    self.spans.push(span);\n                }\n            }\n            prev_cursor = cursor;\n            scope_state.apply(&batch);\n        }\n\n        if accumulate_spans {\n            // add span for final state\n            let start = self.offset - self.spans_start + prev_cursor;\n            let end = start + (line.len() - prev_cursor);\n            let scope_id = self.identifier_for_stack(&scope_state, &repo);\n            let span = ScopeSpan { start, end, scope_id };\n            self.spans.push(span);\n        }\n        Some((parse_state, scope_state))\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::consider_indentation":["/// Checks for possible auto-indent changes after an appropriate edit.\nfn consider_indentation(&mut self, view: &mut MyView, delta: &RopeDelta, edit_type: EditType){\n        for region in delta.iter_inserts() {\n            let line_of_edit = view.line_of_offset(region.new_offset).unwrap();\n            let last_line_of_edit = view.line_of_offset(region.new_offset + region.len).unwrap();\n            match edit_type {\n                EditType::Newline => {\n                    self.indentation_state.push(IndentationTask::Newline(line_of_edit + 1))\n                }\n                EditType::Insert => {\n                    let range = region.new_offset..region.new_offset + region.len;\n                    let is_whitespace = {\n                        let insert_region =\n                            view.get_region(range).expect(\"view must return region\");\n                        insert_region.as_bytes().iter().all(u8::is_ascii_whitespace)\n                    };\n                    if !is_whitespace {\n                        self.indentation_state.push(IndentationTask::Edit(line_of_edit));\n                    }\n                }\n                EditType::Other => {\n                    // we are mainly interested in auto-indenting after paste\n                    let range = Range { start: line_of_edit, end: last_line_of_edit };\n                    self.indentation_state.push(IndentationTask::Batch(range));\n                }\n            };\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::flush_spans":["fn flush_spans(&mut self, ctx: &mut MyView){\n        let _t = trace_block(\"PluginState::flush_spans\", &[\"syntect\"]);\n        if !self.new_scopes.is_empty() {\n            ctx.add_scopes(&self.new_scopes);\n            self.new_scopes.clear();\n        }\n        if self.spans_start != self.offset {\n            ctx.update_spans(self.spans_start, self.offset - self.spans_start, &self.spans);\n            self.spans.clear();\n        }\n        self.spans_start = self.offset;\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::get_metadata":["/// Returns the metadata relevant to the given line. Computes the syntax\n/// for this line (during normal editing this is only likely for line 0) if\n/// necessary; in general reuses the syntax state calculated for highlighting.\nfn get_metadata(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &'a SyntaxSet,\n        line: usize,\n    ) -> Option<ScopedMetadata<'a>>{\n        let text = view.get_line(line).unwrap_or(\"\");\n        let scope = self.compute_syntax(&text, None, syntax_set, false).map(|(_, scope)| scope)?;\n        Some(syntax_set.metadata().metadata_for_scope(scope.as_slice()))\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::highlight_one_line":["fn highlight_one_line(&mut self, ctx: &mut MyView, syntax_set: &SyntaxSet) -> bool{\n        if let Some(line_num) = ctx.get_frontier() {\n            let (line_num, offset, state) = ctx.get_prev(line_num);\n            if offset != self.offset {\n                self.flush_spans(ctx);\n                self.offset = offset;\n                self.spans_start = offset;\n            }\n            let new_frontier = match ctx.get_line(line_num) {\n                Ok(\"\") => None,\n                Ok(s) => {\n                    let new_state = self.compute_syntax(s, state, syntax_set, true);\n                    self.offset += s.len();\n                    if s.as_bytes().last() == Some(&b'\\n') {\n                        Some((new_state, line_num + 1))\n                    } else {\n                        None\n                    }\n                }\n                Err(_) => None,\n            };\n            let mut converged = false;\n            if let Some((ref new_state, new_line_num)) = new_frontier {\n                if let Some(old_state) = ctx.get(new_line_num) {\n                    converged = old_state.as_ref().unwrap().0 == new_state.as_ref().unwrap().0;\n                }\n            }\n            if !converged {\n                if let Some((new_state, new_line_num)) = new_frontier {\n                    ctx.set(new_line_num, new_state);\n                    ctx.update_frontier(new_line_num);\n                    return true;\n                }\n            }\n            ctx.close_frontier();\n        }\n        false\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::identifier_for_stack":["/// Returns the unique identifier for this `ScopeStack`. We use identifiers\n/// so we aren't constantly sending long stack names to the peer.\nfn identifier_for_stack(&mut self, stack: &ScopeStack, repo: &LockedRepo) -> u32{\n        let identifier = self.stack_idents.get_value(stack.as_slice());\n        match identifier {\n            LookupResult::Existing(id) => id,\n            LookupResult::New(id) => {\n                let stack_strings =\n                    stack.as_slice().iter().map(|slice| repo.to_string(*slice)).collect::<Vec<_>>();\n                self.new_scopes.push(stack_strings);\n                id\n            }\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::indent_level_of_line":["fn indent_level_of_line(&self, view: &mut MyView, line: usize) -> usize{\n        let tab_size = view.get_config().tab_size;\n        let line = view.get_line(line).unwrap_or(\"\");\n        line.as_bytes()\n            .iter()\n            .take_while(|b| **b == b' ' || **b == b'\\t')\n            .map(|b| if b == &b' ' { 1 } else { tab_size })\n            .sum()\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::indent_lines":["pub fn indent_lines(&mut self, view: &mut MyView, syntax_set: &SyntaxSet){\n        let mut builder = DeltaBuilder::new(view.get_buf_size());\n\n        for indentation_task in self.indentation_state.to_vec() {\n            match indentation_task {\n                IndentationTask::Newline(line) => self\n                    .autoindent_line(view, &mut builder, syntax_set, line)\n                    .expect(\"auto-indent error on newline\"),\n                IndentationTask::Edit(line) => self\n                    .check_indent_active_edit(view, &mut builder, syntax_set, line)\n                    .expect(\"auto-indent error on insert\"),\n                IndentationTask::Batch(range) => self\n                    .bulk_autoindent(view, &mut builder, syntax_set, range)\n                    .expect(\"auto-indent error on other\"),\n            };\n        }\n\n        if !builder.is_empty() {\n            view.edit(builder.build(), INDENTATION_PRIORITY, false, false, String::from(\"syntect\"));\n        }\n\n        self.indentation_state.clear();\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::insert_comment_marker":["fn insert_comment_marker(\n        &self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        line_range: Range<usize>,\n        comment_str: &str,\n    ){\n        // when commenting out multiple lines, we insert all comment markers at\n        // the same indent level: that of the least indented line.\n        let line_offset = line_range\n            .clone()\n            .map(|num| {\n                view.get_line(num)\n                    .ok()\n                    .and_then(|line| line.as_bytes().iter().position(|b| *b != b' ' && *b != b'\\t'))\n                    .unwrap_or(0)\n            })\n            .min()\n            .unwrap_or(0);\n\n        let comment_txt = Rope::from(&comment_str);\n        for num in line_range {\n            let offset = view.offset_of_line(num).unwrap();\n            let line = view.get_line(num).unwrap();\n            if line.trim().starts_with(&comment_str) {\n                continue;\n            }\n\n            let iv = Interval::new(offset + line_offset, offset + line_offset);\n            builder.replace(iv, comment_txt.clone());\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::new":["fn new() -> Self{\n        PluginState {\n            stack_idents: StackMap::default(),\n            offset: 0,\n            initial_state: None,\n            spans_start: 0,\n            spans: Vec::new(),\n            new_scopes: Vec::new(),\n            indentation_state: Vec::new(),\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::previous_nonblank_line":["fn previous_nonblank_line(\n        &self,\n        view: &mut MyView,\n        line: usize,\n    ) -> Result<Option<usize>, Error>{\n        debug_assert!(line > 0);\n        let mut line = line;\n        while line > 0 {\n            line -= 1;\n            let text = view.get_line(line)?;\n            if !text.bytes().all(|b| b.is_ascii_whitespace()) {\n                return Ok(Some(line));\n            }\n        }\n        Ok(None)\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::reindent":["fn reindent(&mut self, view: &mut MyView, syntax_set: &SyntaxSet, lines: &[(usize, usize)]){\n        let mut builder = DeltaBuilder::new(view.get_buf_size());\n\n        for (start, end) in lines {\n            let range = Range { start: *start, end: *end - 1 };\n            self.bulk_autoindent(view, &mut builder, syntax_set, range).expect(\"error on reindent\");\n        }\n\n        view.edit(builder.build(), INDENTATION_PRIORITY, false, false, String::from(\"syntect\"));\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::remove_comment_marker":["fn remove_comment_marker(\n        &self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        lines: Range<usize>,\n        comment_str: &str,\n    ){\n        for num in lines {\n            let offset = view.offset_of_line(num).unwrap();\n            let line = view.get_line(num).unwrap();\n            let (comment_start, len) = match line.find(&comment_str) {\n                Some(off) => (offset + off, comment_str.len()),\n                None if line.trim() == comment_str.trim() => (offset, comment_str.trim().len()),\n                None => continue,\n            };\n\n            let iv = Interval::new(comment_start, comment_start + len);\n            builder.delete(iv);\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::set_indent":["fn set_indent(\n        &self,\n        view: &mut MyView,\n        builder: &mut EditBuilder,\n        line: usize,\n        level: usize,\n    ) -> Result<(), Error>{\n        let edit_start = view.offset_of_line(line)?;\n        let edit_len = {\n            let line = view.get_line(line)?;\n            line.as_bytes().iter().take_while(|b| **b == b' ' || **b == b'\\t').count()\n        };\n\n        let use_spaces = view.get_config().translate_tabs_to_spaces;\n        let tab_size = view.get_config().tab_size;\n\n        let indent_text = if use_spaces { n_spaces(level) } else { n_tabs(level / tab_size) };\n\n        let iv = Interval::new(edit_start, edit_start + edit_len);\n        builder.replace(iv, indent_text.into());\n        Ok(())\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::test_decrease":["/// Test whether the indent level for this line should be decreased, by\n/// checking this line against a regex.\nfn test_decrease(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &SyntaxSet,\n        line: usize,\n    ) -> Result<bool, Error>{\n        if line == 0 {\n            return Ok(false);\n        }\n        let metadata = self.get_metadata(view, syntax_set, line).ok_or(Error::PeerDisconnect)?;\n        let line = view.get_line(line)?;\n        Ok(metadata.decrease_indent(line))\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::test_increase":["/// Test whether the indent level should be increased for this line,\n/// by testing the _previous_ line against a regex.\nfn test_increase(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &SyntaxSet,\n        line: usize,\n    ) -> Result<bool, Error>{\n        debug_assert!(line > 0, \"increasing indent requires a previous line\");\n        let prev_line = match self.previous_nonblank_line(view, line) {\n            Ok(Some(l)) => l,\n            Ok(None) => return Ok(false),\n            Err(e) => return Err(e),\n        };\n        let metadata =\n            self.get_metadata(view, syntax_set, prev_line).ok_or(Error::PeerDisconnect)?;\n        let line = view.get_line(prev_line)?;\n\n        let comment_str = match metadata.line_comment().map(|s| s.to_owned()) {\n            Some(s) => s,\n            None => return Ok(metadata.increase_indent(line)),\n        };\n\n        // if the previous line is a comment, the indent level should not be increased\n        if line.trim().starts_with(&comment_str.trim()) {\n            Ok(false)\n        } else {\n            Ok(metadata.increase_indent(line))\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::toggle_comment":["fn toggle_comment(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &SyntaxSet,\n        lines: &[(usize, usize)],\n    ){\n        let _t = trace_block(\"Syntect::toggle_comment\", &[\"syntect\"]);\n        if lines.is_empty() {\n            return;\n        }\n\n        let mut builder = DeltaBuilder::new(view.get_buf_size());\n\n        for (start, end) in lines {\n            let range = Range { start: *start, end: *end };\n            self.toggle_comment_line_range(view, syntax_set, &mut builder, range);\n        }\n\n        if builder.is_empty() {\n            eprintln!(\"no delta for lines {:?}\", &lines);\n        } else {\n            view.edit(builder.build(), INDENTATION_PRIORITY, false, true, String::from(\"syntect\"));\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"PluginState::toggle_comment_line_range":["fn toggle_comment_line_range(\n        &mut self,\n        view: &mut MyView,\n        syntax_set: &SyntaxSet,\n        builder: &mut EditBuilder,\n        line_range: Range<usize>,\n    ){\n        let comment_str = match self\n            .get_metadata(view, syntax_set, line_range.start)\n            .and_then(|s| s.line_comment().map(|s| s.to_owned()))\n        {\n            Some(s) => s,\n            None => return,\n        };\n\n        match view\n            .get_line(line_range.start)\n            .map(|l| comment_str.trim() == l.trim() || l.trim().starts_with(&comment_str))\n        {\n            Ok(true) => self.remove_comment_marker(view, builder, line_range, &comment_str),\n            Ok(false) => self.insert_comment_marker(view, builder, line_range, &comment_str),\n            Err(e) => eprintln!(\"toggle comment error: {:?}\", e),\n        }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"Syntect":["/// The state of syntax highlighting for a collection of buffers.\nstruct Syntect<'a> {\n    view_state: HashMap<ViewId, PluginState>,\n    syntax_set: &'a SyntaxSet,\n}","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"Syntect::<'a>::do_highlighting":["/// Wipes any existing state and starts highlighting with `syntax`.\nfn do_highlighting(&mut self, view: &mut MyView){\n        let initial_state = {\n            let language_id = view.get_language_id();\n            let syntax = self\n                .syntax_set\n                .find_syntax_by_name(language_id.as_ref())\n                .unwrap_or_else(|| self.syntax_set.find_syntax_plain_text());\n            Some((ParseState::new(syntax), ScopeStack::new()))\n        };\n\n        let state = self.view_state.get_mut(&view.get_id()).unwrap();\n        state.initial_state = initial_state;\n        state.spans = Vec::new();\n        state.new_scopes = Vec::new();\n        state.offset = 0;\n        state.spans_start = 0;\n        view.get_cache().clear();\n        view.schedule_idle();\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"Syntect::<'a>::new":["fn new(syntax_set: &'a SyntaxSet) -> Self{\n        Syntect { view_state: HashMap::new(), syntax_set }\n    }","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"main":["fn main(){\n    let mut syntax_set: SyntaxSet = from_binary(include_bytes!(\"../assets/default.packdump\"));\n    let metadata = from_binary(include_bytes!(\"../assets/default_meta.packdump\"));\n    syntax_set.set_metadata(metadata);\n    let mut state = Syntect::new(&syntax_set);\n    mainloop(&mut state).unwrap();\n}","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"n_spaces":["fn n_spaces(n: usize) -> &'static str{\n    // when someone opens an issue complaining about this we know we've made it\n    const MAX_SPACES: usize = 160;\n    static MANY_SPACES: [u8; MAX_SPACES] = [b' '; MAX_SPACES];\n    unsafe { ::std::str::from_utf8_unchecked(&MANY_SPACES[..n.min(MAX_SPACES)]) }\n}","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"n_tabs":["fn n_tabs(n: usize) -> &'static str{\n    const MAX_TABS: usize = 40;\n    static MANY_TABS: [u8; MAX_TABS] = [b'\\t'; MAX_TABS];\n    unsafe { ::std::str::from_utf8_unchecked(&MANY_TABS[..n.min(MAX_TABS)]) }\n}","Real(LocalPath(\"syntect-plugin/src/main.rs\"))"],"stackmap::LookupResult":["/// Result type for `StackMap` lookups. Used to communicate to the user\n/// whether or not a new identifier has been assigned, which will need to\n/// be communicated to the peer.\npub enum LookupResult {\n    Existing(u32),\n    New(u32),\n}","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))"],"stackmap::LookupResult::is_new":["pub fn is_new(&self) -> bool{\n        matches!(*self, LookupResult::New(_))\n    }","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))"],"stackmap::Node":["struct Node {\n    value: Option<u32>,\n    children: HashMap<Scope, Node>,\n}","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))"],"stackmap::Node::get_value":["fn get_value(&mut self, stack: &[Scope], next_id: u32) -> LookupResult{\n        // if this is last item on the stack, get the value, inserting if necessary.\n        let first = stack.first().unwrap();\n        if stack.len() == 1 {\n            if !self.children.contains_key(first) {\n                self.children.insert(first.to_owned(), Node::new(next_id));\n                return LookupResult::New(next_id);\n            }\n\n            // if key exists, value still might not be assigned:\n            let needs_value = self.children[first].value.is_none();\n            if needs_value {\n                let node = self.children.get_mut(first).unwrap();\n                node.value = Some(next_id);\n                return LookupResult::New(next_id);\n            } else {\n                let value = self.children[first].value.unwrap();\n                return LookupResult::Existing(value);\n            }\n        }\n        // not the last item: recurse, creating node as necessary\n        if self.children.get(first).is_none() {\n            self.children.insert(first.to_owned(), Node::default());\n        }\n        self.children.get_mut(first).unwrap().get_value(&stack[1..], next_id)\n    }","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))"],"stackmap::Node::new":["pub fn new(value: u32) -> Self{\n        Node { value: Some(value), children: HashMap::new() }\n    }","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))"],"stackmap::StackMap":["/// Nested lookup table for stacks of scopes.\npub struct StackMap {\n    next_id: u32,\n    scopes: Node,\n}","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))"],"stackmap::StackMap::get_value":["/// Returns the identifier for this stack, creating it if needed.\npub fn get_value(&mut self, stack: &[Scope]) -> LookupResult{\n        assert!(!stack.is_empty());\n        let result = self.scopes.get_value(stack, self.next_id);\n        if result.is_new() {\n            self.next_id += 1;\n        }\n        result\n    }","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))"]},"struct_constructor":{"&'static str":["n_spaces","n_tabs"],"EditType":["clone","from_str"],"IndentationTask":["clone"],"PluginState":["new"],"Syntect":["new"],"bool":["eq","highlight_one_line","is_new","test_decrease","test_increase"],"stackmap::LookupResult":["get_value"],"stackmap::Node":["default","new"],"stackmap::StackMap":["default"],"syntect::parsing::ScopedMetadata":["get_metadata"],"u32":["identifier_for_stack"]},"struct_to_trait":{"EditType":["std::clone::Clone","std::cmp::PartialEq","std::marker::Copy","std::marker::StructuralPartialEq","std::str::FromStr"],"IndentationTask":["std::clone::Clone","std::cmp::PartialEq","std::marker::StructuralPartialEq"],"Syntect":["xi_plugin_lib::Plugin"],"stackmap::LookupResult":["std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"stackmap::Node":["std::default::Default","std::fmt::Debug"],"stackmap::StackMap":["std::default::Default","std::fmt::Debug"]},"targets":{"<EditType as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"syntect-plugin/src/main.rs\"))","std::str::FromStr"],"<Syntect<'a> as xi_plugin_lib::Plugin>::config_changed":["config_changed","Real(LocalPath(\"syntect-plugin/src/main.rs\"))","xi_plugin_lib::Plugin"],"<Syntect<'a> as xi_plugin_lib::Plugin>::custom_command":["custom_command","Real(LocalPath(\"syntect-plugin/src/main.rs\"))","xi_plugin_lib::Plugin"],"<Syntect<'a> as xi_plugin_lib::Plugin>::did_close":["did_close","Real(LocalPath(\"syntect-plugin/src/main.rs\"))","xi_plugin_lib::Plugin"],"<Syntect<'a> as xi_plugin_lib::Plugin>::did_save":["did_save","Real(LocalPath(\"syntect-plugin/src/main.rs\"))","xi_plugin_lib::Plugin"],"<Syntect<'a> as xi_plugin_lib::Plugin>::idle":["idle","Real(LocalPath(\"syntect-plugin/src/main.rs\"))","xi_plugin_lib::Plugin"],"<Syntect<'a> as xi_plugin_lib::Plugin>::language_changed":["language_changed","Real(LocalPath(\"syntect-plugin/src/main.rs\"))","xi_plugin_lib::Plugin"],"<Syntect<'a> as xi_plugin_lib::Plugin>::new_view":["new_view","Real(LocalPath(\"syntect-plugin/src/main.rs\"))","xi_plugin_lib::Plugin"],"<Syntect<'a> as xi_plugin_lib::Plugin>::update":["update","Real(LocalPath(\"syntect-plugin/src/main.rs\"))","xi_plugin_lib::Plugin"],"PluginState::autoindent_line":["autoindent_line","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::bulk_autoindent":["bulk_autoindent","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::check_indent_active_edit":["check_indent_active_edit","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::compute_syntax":["compute_syntax","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::consider_indentation":["consider_indentation","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::flush_spans":["flush_spans","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::get_metadata":["get_metadata","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::highlight_one_line":["highlight_one_line","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::identifier_for_stack":["identifier_for_stack","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::indent_level_of_line":["indent_level_of_line","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::indent_lines":["indent_lines","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::insert_comment_marker":["insert_comment_marker","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::new":["new","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::previous_nonblank_line":["previous_nonblank_line","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::reindent":["reindent","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::remove_comment_marker":["remove_comment_marker","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::set_indent":["set_indent","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::test_decrease":["test_decrease","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::test_increase":["test_increase","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::toggle_comment":["toggle_comment","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"PluginState::toggle_comment_line_range":["toggle_comment_line_range","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"Syntect::<'a>::do_highlighting":["do_highlighting","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"Syntect::<'a>::new":["new","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"main":["main","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"n_spaces":["n_spaces","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"n_tabs":["n_tabs","Real(LocalPath(\"syntect-plugin/src/main.rs\"))",""],"stackmap::LookupResult::is_new":["is_new","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))",""],"stackmap::Node::get_value":["get_value","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))",""],"stackmap::Node::new":["new","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))",""],"stackmap::StackMap::get_value":["get_value","Real(LocalPath(\"syntect-plugin/src/stackmap.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["EditType","IndentationTask"],"std::cmp::PartialEq":["EditType","IndentationTask","stackmap::LookupResult"],"std::default::Default":["stackmap::Node","stackmap::StackMap"],"std::fmt::Debug":["stackmap::LookupResult","stackmap::Node","stackmap::StackMap"],"std::marker::Copy":["EditType"],"std::marker::StructuralPartialEq":["EditType","IndentationTask","stackmap::LookupResult"],"std::str::FromStr":["EditType"],"xi_plugin_lib::Plugin":["Syntect"]},"type_to_def_path":{"EditType":"EditType","IndentationTask":"IndentationTask","PluginState":"PluginState","Syntect<'a>":"Syntect","stackmap::LookupResult":"stackmap::LookupResult","stackmap::Node":"stackmap::Node","stackmap::StackMap":"stackmap::StackMap"}}