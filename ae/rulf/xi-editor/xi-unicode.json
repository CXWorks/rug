{"dependencies":{"<LineBreakIterator<'a> as core::clone::Clone>::clone":["LineBreakIterator"],"<LineBreakIterator<'a> as core::iter::Iterator>::next":["LineBreakIterator","core::marker::Sized","core::option::Option"],"<LineBreakLeafIter as core::clone::Clone>::clone":["LineBreakLeafIter"],"<LineBreakLeafIter as core::default::Default>::default":["LineBreakLeafIter"],"<char as EmojiExt>::is_emoji":[],"<char as EmojiExt>::is_emoji_cancel_tag":[],"<char as EmojiExt>::is_emoji_combining_enclosing_keycap":[],"<char as EmojiExt>::is_emoji_modifier":[],"<char as EmojiExt>::is_emoji_modifier_base":[],"<char as EmojiExt>::is_regional_indicator_symbol":[],"<char as EmojiExt>::is_tag_spec_char":[],"<char as EmojiExt>::is_zwj":[],"EmojiExt::is_emoji":[],"EmojiExt::is_emoji_cancel_tag":[],"EmojiExt::is_emoji_combining_enclosing_keycap":[],"EmojiExt::is_emoji_modifier":[],"EmojiExt::is_emoji_modifier_base":[],"EmojiExt::is_regional_indicator_symbol":[],"EmojiExt::is_tag_spec_char":[],"EmojiExt::is_zwj":[],"LineBreakIterator":["LineBreakIterator"],"LineBreakIterator::<'a>::new":["LineBreakIterator"],"LineBreakLeafIter":["LineBreakLeafIter"],"LineBreakLeafIter::new":["LineBreakLeafIter"],"LineBreakLeafIter::next":["LineBreakLeafIter"],"is_in_asc_list":["core::cmp::PartialOrd","core::marker::Sized"],"is_keycap_base":[],"is_variation_selector":[],"linebreak_property":[],"linebreak_property_str":[]},"glob_path_import":{},"self_to_fn":{"LineBreakIterator":["Clone","Copy","impl<'a> Iterator for LineBreakIterator<'a> {\n    type Item = (usize, bool);\n\n    // return break pos and whether it's a hard break\n    fn next(&mut self) -> Option<(usize, bool)> {\n        loop {\n            match self.ix.cmp(&self.s.len()) {\n                Ordering::Greater => {\n                    return None;\n                }\n                Ordering::Equal => {\n                    // LB3, break at EOT\n                    self.ix += 1;\n                    let i = (self.state as usize) * N_LINEBREAK_CATEGORIES;\n                    let new = LINEBREAK_STATE_MACHINE[i];\n                    return Some((self.s.len(), new >= 0xc0));\n                }\n                Ordering::Less => {\n                    let (lb, len) = linebreak_property_str(self.s, self.ix);\n                    let i = (self.state as usize) * N_LINEBREAK_CATEGORIES + (lb as usize);\n                    let new = LINEBREAK_STATE_MACHINE[i];\n                    //println!(\"{:?}[{}], state {} + lb {} -> {}\", &self.s[self.ix..], self.ix, self.state, lb, new);\n                    let result = self.ix;\n                    self.ix += len;\n                    if (new as i8) < 0 {\n                        // break found\n                        self.state = new & 0x3f;\n                        return Some((result, new >= 0xc0));\n                    } else {\n                        self.state = new;\n                    }\n                }\n            }\n        }\n    }\n}","impl<'a> LineBreakIterator<'a> {\n    /// Create a new iterator for the given string slice.\n    pub fn new(s: &str) -> LineBreakIterator {\n        if s.is_empty() {\n            LineBreakIterator {\n                s,\n                ix: 1, // LB2, don't break; sot takes priority for empty string\n                state: 0,\n            }\n        } else {\n            let (lb, len) = linebreak_property_str(s, 0);\n            LineBreakIterator { s, ix: len, state: lb }\n        }\n    }\n}"],"LineBreakLeafIter":["Clone","Copy","impl Default for LineBreakLeafIter {\n    // A default value. No guarantees on what happens when next() is called\n    // on this. Intended to be useful for empty ropes.\n    fn default() -> LineBreakLeafIter {\n        LineBreakLeafIter { ix: 0, state: 0 }\n    }\n}","impl LineBreakLeafIter {\n    /// Create a new line break iterator suitable for leaves in a rope.\n    /// Precondition: ix is at a code point boundary within s.\n    pub fn new(s: &str, ix: usize) -> LineBreakLeafIter {\n        let (lb, len) = if ix == s.len() { (0, 0) } else { linebreak_property_str(s, ix) };\n        LineBreakLeafIter { ix: ix + len, state: lb }\n    }\n\n    /// Return break pos and whether it's a hard break. Note: hard break\n    /// indication may go away, this may not be useful in actual application.\n    /// If end of leaf is found, return leaf's len. This does not indicate\n    /// a break, as that requires at least one more codepoint of context.\n    /// If it is a break, then subsequent next call will return an offset of 0.\n    /// EOT is always a break, so in the EOT case it's up to the caller\n    /// to figure that out.\n    ///\n    /// For consistent results, always supply same `s` until end of leaf is\n    /// reached (and initially this should be the same as in the `new` call).\n    pub fn next(&mut self, s: &str) -> (usize, bool) {\n        loop {\n            if self.ix == s.len() {\n                self.ix = 0; // in preparation for next leaf\n                return (s.len(), false);\n            }\n            let (lb, len) = linebreak_property_str(s, self.ix);\n            let i = (self.state as usize) * N_LINEBREAK_CATEGORIES + (lb as usize);\n            let new = LINEBREAK_STATE_MACHINE[i];\n            //println!(\"\\\"{}\\\"[{}], state {} + lb {} -> {}\", &s[self.ix..], self.ix, self.state, lb, new);\n            let result = self.ix;\n            self.ix += len;\n            if (new as i8) < 0 {\n                // break found\n                self.state = new & 0x3f;\n                return (result, new >= 0xc0);\n            } else {\n                self.state = new;\n            }\n        }\n    }\n}"]},"single_path_import":{},"srcs":{"<LineBreakIterator<'a> as core::iter::Iterator>::next":["fn next(&mut self) -> Option<(usize, bool)>{\n        loop {\n            match self.ix.cmp(&self.s.len()) {\n                Ordering::Greater => {\n                    return None;\n                }\n                Ordering::Equal => {\n                    // LB3, break at EOT\n                    self.ix += 1;\n                    let i = (self.state as usize) * N_LINEBREAK_CATEGORIES;\n                    let new = LINEBREAK_STATE_MACHINE[i];\n                    return Some((self.s.len(), new >= 0xc0));\n                }\n                Ordering::Less => {\n                    let (lb, len) = linebreak_property_str(self.s, self.ix);\n                    let i = (self.state as usize) * N_LINEBREAK_CATEGORIES + (lb as usize);\n                    let new = LINEBREAK_STATE_MACHINE[i];\n                    //println!(\"{:?}[{}], state {} + lb {} -> {}\", &self.s[self.ix..], self.ix, self.state, lb, new);\n                    let result = self.ix;\n                    self.ix += len;\n                    if (new as i8) < 0 {\n                        // break found\n                        self.state = new & 0x3f;\n                        return Some((result, new >= 0xc0));\n                    } else {\n                        self.state = new;\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"<LineBreakLeafIter as core::default::Default>::default":["fn default() -> LineBreakLeafIter{\n        LineBreakLeafIter { ix: 0, state: 0 }\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"<char as EmojiExt>::is_emoji":["fn is_emoji(self) -> bool{\n        is_in_asc_list(self, &EMOJI_TABLE, 0, EMOJI_TABLE.len() - 1)\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"<char as EmojiExt>::is_emoji_cancel_tag":["fn is_emoji_cancel_tag(self) -> bool{\n        self == '\\u{E007F}'\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"<char as EmojiExt>::is_emoji_combining_enclosing_keycap":["fn is_emoji_combining_enclosing_keycap(self) -> bool{\n        self == '\\u{20E3}'\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"<char as EmojiExt>::is_emoji_modifier":["fn is_emoji_modifier(self) -> bool{\n        self >= '\\u{1F3FB}' && self <= '\\u{1F3FF}'\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"<char as EmojiExt>::is_emoji_modifier_base":["fn is_emoji_modifier_base(self) -> bool{\n        is_in_asc_list(self, &EMOJI_MODIFIER_BASE_TABLE, 0, EMOJI_MODIFIER_BASE_TABLE.len() - 1)\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"<char as EmojiExt>::is_regional_indicator_symbol":["fn is_regional_indicator_symbol(self) -> bool{\n        self >= '\\u{1F1E6}' && self <= '\\u{1F1FF}'\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"<char as EmojiExt>::is_tag_spec_char":["fn is_tag_spec_char(self) -> bool{\n        '\\u{E0020}' <= self && self <= '\\u{E007E}'\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"<char as EmojiExt>::is_zwj":["fn is_zwj(self) -> bool{\n        self == '\\u{200D}'\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"EmojiExt":["pub trait EmojiExt {\n    fn is_regional_indicator_symbol(self) -> bool;\n    fn is_emoji_modifier(self) -> bool;\n    fn is_emoji_combining_enclosing_keycap(self) -> bool;\n    fn is_emoji(self) -> bool;\n    fn is_emoji_modifier_base(self) -> bool;\n    fn is_tag_spec_char(self) -> bool;\n    fn is_emoji_cancel_tag(self) -> bool;\n    fn is_zwj(self) -> bool;\n}","Real(LocalPath(\"unicode/src/lib.rs\"))"],"LineBreakIterator":["/// An iterator which produces line breaks according to the UAX 14 line\n/// breaking algorithm. For each break, return a tuple consisting of the offset\n/// within the source string and a bool indicating whether it's a hard break.\n///\n/// There is never a break at the beginning of the string (thus, the empty string\n/// produces no breaks). For non-empty strings, there is always a break at the\n/// end. It is indicated as a hard break when the string is terminated with a\n/// newline or other Unicode explicit line-end character.\npub struct LineBreakIterator<'a> {\n    s: &'a str,\n    ix: usize,\n    state: u8,\n}","Real(LocalPath(\"unicode/src/lib.rs\"))"],"LineBreakIterator::<'a>::new":["/// Create a new iterator for the given string slice.\npub fn new(s: &str) -> LineBreakIterator{\n        if s.is_empty() {\n            LineBreakIterator {\n                s,\n                ix: 1, // LB2, don't break; sot takes priority for empty string\n                state: 0,\n            }\n        } else {\n            let (lb, len) = linebreak_property_str(s, 0);\n            LineBreakIterator { s, ix: len, state: lb }\n        }\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"LineBreakLeafIter":["/// A struct useful for computing line breaks in a rope or other non-contiguous\n/// string representation. This is a trickier problem than iterating in a string\n/// for a few reasons, the trickiest of which is that in the general case,\n/// line breaks require an indeterminate amount of look-behind.\n///\n/// This is something of an \"expert-level\" interface, and should only be used if\n/// the caller is prepared to respect all the invariants. Otherwise, you might\n/// get inconsistent breaks depending on start position and leaf boundaries.\npub struct LineBreakLeafIter {\n    ix: usize,\n    state: u8,\n}","Real(LocalPath(\"unicode/src/lib.rs\"))"],"LineBreakLeafIter::new":["/// Create a new line break iterator suitable for leaves in a rope.\n/// Precondition: ix is at a code point boundary within s.\npub fn new(s: &str, ix: usize) -> LineBreakLeafIter{\n        let (lb, len) = if ix == s.len() { (0, 0) } else { linebreak_property_str(s, ix) };\n        LineBreakLeafIter { ix: ix + len, state: lb }\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"LineBreakLeafIter::next":["/// Return break pos and whether it's a hard break. Note: hard break\n/// indication may go away, this may not be useful in actual application.\n/// If end of leaf is found, return leaf's len. This does not indicate\n/// a break, as that requires at least one more codepoint of context.\n/// If it is a break, then subsequent next call will return an offset of 0.\n/// EOT is always a break, so in the EOT case it's up to the caller\n/// to figure that out.\n///\n/// For consistent results, always supply same `s` until end of leaf is\n/// reached (and initially this should be the same as in the `new` call).\npub fn next(&mut self, s: &str) -> (usize, bool){\n        loop {\n            if self.ix == s.len() {\n                self.ix = 0; // in preparation for next leaf\n                return (s.len(), false);\n            }\n            let (lb, len) = linebreak_property_str(s, self.ix);\n            let i = (self.state as usize) * N_LINEBREAK_CATEGORIES + (lb as usize);\n            let new = LINEBREAK_STATE_MACHINE[i];\n            //println!(\"\\\"{}\\\"[{}], state {} + lb {} -> {}\", &s[self.ix..], self.ix, self.state, lb, new);\n            let result = self.ix;\n            self.ix += len;\n            if (new as i8) < 0 {\n                // break found\n                self.state = new & 0x3f;\n                return (result, new >= 0xc0);\n            } else {\n                self.state = new;\n            }\n        }\n    }","Real(LocalPath(\"unicode/src/lib.rs\"))"],"is_in_asc_list":["fn is_in_asc_list<T: core::cmp::PartialOrd>(c: T, list: &[T], start: usize, end: usize) -> bool{\n    if c == list[start] || c == list[end] {\n        return true;\n    }\n    if end - start <= 1 {\n        return false;\n    }\n\n    let mid = (start + end) / 2;\n\n    if c >= list[mid] {\n        is_in_asc_list(c, &list, mid, end)\n    } else {\n        is_in_asc_list(c, &list, start, mid)\n    }\n}","Real(LocalPath(\"unicode/src/lib.rs\"))"],"is_keycap_base":["pub fn is_keycap_base(c: char) -> bool{\n    ('0' <= c && c <= '9') || c == '#' || c == '*'\n}","Real(LocalPath(\"unicode/src/lib.rs\"))"],"is_variation_selector":["pub fn is_variation_selector(c: char) -> bool{\n    (c >= '\\u{FE00}' && c <= '\\u{FE0F}') || (c >= '\\u{E0100}' && c <= '\\u{E01EF}')\n}","Real(LocalPath(\"unicode/src/lib.rs\"))"],"linebreak_property":["/// The Unicode line breaking property of the given code point.\n///\n/// This is given as a numeric value which matches the ULineBreak\n/// enum value from ICU.\npub fn linebreak_property(cp: char) -> u8{\n    let cp = cp as usize;\n    if cp < 0x800 {\n        LINEBREAK_1_2[cp]\n    } else if cp < 0x10000 {\n        let child = LINEBREAK_3_ROOT[cp >> 6];\n        LINEBREAK_3_CHILD[(child as usize) * 0x40 + (cp & 0x3f)]\n    } else {\n        let mid = LINEBREAK_4_ROOT[cp >> 12];\n        let leaf = LINEBREAK_4_MID[(mid as usize) * 0x40 + ((cp >> 6) & 0x3f)];\n        LINEBREAK_4_LEAVES[(leaf as usize) * 0x40 + (cp & 0x3f)]\n    }\n}","Real(LocalPath(\"unicode/src/lib.rs\"))"],"linebreak_property_str":["/// The Unicode line breaking property of the given code point.\n///\n/// Look up the line breaking property for the first code point in the\n/// string. Return the property as a numeric value, and also the utf-8\n/// length of the codepoint, for convenience.\npub fn linebreak_property_str(s: &str, ix: usize) -> (u8, usize){\n    let b = s.as_bytes()[ix];\n    if b < 0x80 {\n        (LINEBREAK_1_2[b as usize], 1)\n    } else if b < 0xe0 {\n        // 2 byte UTF-8 sequences\n        let cp = ((b as usize) << 6) + (s.as_bytes()[ix + 1] as usize) - 0x3080;\n        (LINEBREAK_1_2[cp], 2)\n    } else if b < 0xf0 {\n        // 3 byte UTF-8 sequences\n        let mid_ix = ((b as usize) << 6) + (s.as_bytes()[ix + 1] as usize) - 0x3880;\n        let mid = LINEBREAK_3_ROOT[mid_ix];\n        (LINEBREAK_3_CHILD[(mid as usize) * 0x40 + (s.as_bytes()[ix + 2] as usize) - 0x80], 3)\n    } else {\n        // 4 byte UTF-8 sequences\n        let mid_ix = ((b as usize) << 6) + (s.as_bytes()[ix + 1] as usize) - 0x3c80;\n        let mid = LINEBREAK_4_ROOT[mid_ix];\n        let leaf_ix = ((mid as usize) << 6) + (s.as_bytes()[ix + 2] as usize) - 0x80;\n        let leaf = LINEBREAK_4_MID[leaf_ix];\n        (LINEBREAK_4_LEAVES[(leaf as usize) * 0x40 + (s.as_bytes()[ix + 3] as usize) - 0x80], 4)\n    }\n}","Real(LocalPath(\"unicode/src/lib.rs\"))"]},"struct_constructor":{"(u8, usize)":["linebreak_property_str"],"(usize, bool)":["next"],"LineBreakIterator":["clone","new"],"LineBreakLeafIter":["clone","default","new"],"bool":["is_emoji","is_emoji_cancel_tag","is_emoji_combining_enclosing_keycap","is_emoji_modifier","is_emoji_modifier_base","is_in_asc_list","is_keycap_base","is_regional_indicator_symbol","is_tag_spec_char","is_variation_selector","is_zwj"],"core::option::Option":["next"],"u8":["linebreak_property"]},"struct_to_trait":{"LineBreakIterator":["core::clone::Clone","core::iter::Iterator","core::marker::Copy"],"LineBreakLeafIter":["core::clone::Clone","core::default::Default","core::marker::Copy"]},"targets":{"<LineBreakIterator<'a> as core::iter::Iterator>::next":["next","Real(LocalPath(\"unicode/src/lib.rs\"))","core::iter::Iterator"],"<LineBreakLeafIter as core::default::Default>::default":["default","Real(LocalPath(\"unicode/src/lib.rs\"))","core::default::Default"],"<char as EmojiExt>::is_emoji":["is_emoji","Real(LocalPath(\"unicode/src/lib.rs\"))","EmojiExt"],"<char as EmojiExt>::is_emoji_cancel_tag":["is_emoji_cancel_tag","Real(LocalPath(\"unicode/src/lib.rs\"))","EmojiExt"],"<char as EmojiExt>::is_emoji_combining_enclosing_keycap":["is_emoji_combining_enclosing_keycap","Real(LocalPath(\"unicode/src/lib.rs\"))","EmojiExt"],"<char as EmojiExt>::is_emoji_modifier":["is_emoji_modifier","Real(LocalPath(\"unicode/src/lib.rs\"))","EmojiExt"],"<char as EmojiExt>::is_emoji_modifier_base":["is_emoji_modifier_base","Real(LocalPath(\"unicode/src/lib.rs\"))","EmojiExt"],"<char as EmojiExt>::is_regional_indicator_symbol":["is_regional_indicator_symbol","Real(LocalPath(\"unicode/src/lib.rs\"))","EmojiExt"],"<char as EmojiExt>::is_tag_spec_char":["is_tag_spec_char","Real(LocalPath(\"unicode/src/lib.rs\"))","EmojiExt"],"<char as EmojiExt>::is_zwj":["is_zwj","Real(LocalPath(\"unicode/src/lib.rs\"))","EmojiExt"],"LineBreakIterator::<'a>::new":["new","Real(LocalPath(\"unicode/src/lib.rs\"))",""],"LineBreakLeafIter::new":["new","Real(LocalPath(\"unicode/src/lib.rs\"))",""],"LineBreakLeafIter::next":["next","Real(LocalPath(\"unicode/src/lib.rs\"))",""],"is_in_asc_list":["is_in_asc_list","Real(LocalPath(\"unicode/src/lib.rs\"))",""],"is_keycap_base":["is_keycap_base","Real(LocalPath(\"unicode/src/lib.rs\"))",""],"is_variation_selector":["is_variation_selector","Real(LocalPath(\"unicode/src/lib.rs\"))",""],"linebreak_property":["linebreak_property","Real(LocalPath(\"unicode/src/lib.rs\"))",""],"linebreak_property_str":["linebreak_property_str","Real(LocalPath(\"unicode/src/lib.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["LineBreakIterator","LineBreakLeafIter"],"core::default::Default":["LineBreakLeafIter"],"core::iter::Iterator":["LineBreakIterator"],"core::marker::Copy":["LineBreakIterator","LineBreakLeafIter"]},"type_to_def_path":{"LineBreakIterator<'a>":"LineBreakIterator","LineBreakLeafIter":"LineBreakLeafIter"}}