{"dependencies":{"EnvFlagConfig":["EnvFlagConfig"],"LogfileConfig":["LogfileConfig","std::marker::Sized","std::option::Option"],"create_log_directory":["std::ffi::OsStr","std::marker::Sized","std::path::Path","std::result::Result","std::sys::unix::os_str::Slice"],"extract_env_or_flag":["EnvFlagConfig","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"generate_logfile_config":["LogfileConfig","hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull"],"generate_logging_path":["LogfileConfig","std::marker::Sized","std::option::Option","std::result::Result"],"get_flags":["hashbrown::map::HashMap","hashbrown::raw::RawTable","hashbrown::raw::RawTableInner","std::alloc::Allocator","std::clone::Clone","std::collections::HashMap","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull"],"get_logging_directory_path":["std::convert::AsRef","std::marker::Sized","std::result::Result"],"main":[],"setup_logging":["std::marker::Sized","std::option::Option","std::result::Result"]},"glob_path_import":{},"self_to_fn":{},"single_path_import":{},"srcs":{"EnvFlagConfig":["struct EnvFlagConfig {\n    env_name: &'static str,\n    flag_name: &'static str,\n}","Real(LocalPath(\"src/main.rs\"))"],"LogfileConfig":["struct LogfileConfig {\n    directory: Option<PathBuf>,\n    file: Option<PathBuf>,\n}","Real(LocalPath(\"src/main.rs\"))"],"create_log_directory":["/// This function tries to create the parent directories for a file\n///\n/// It wraps around the `parent()` function of `Path` which returns an `Option<&Path>` and\n/// `fs::create_dir_all` which returns an `io::Result<()>`.\n///\n/// This allows you to use `?`/`try!()` to create the dir and you recive the additional custom error for when `parent()`\n/// returns nothing.\n///\n/// # Errors\n/// This can return an `io::Error` if `fs::create_dir_all` fails or if `parent()` returns `None`.\n/// See `Path`'s `parent()` function for more details.\n/// # Examples\n/// ```\n/// use std::path::Path;\n/// use std::ffi::OsStr;\n///\n/// let path_with_file = Path::new(\"/some/directory/then/file\");\n/// assert_eq!(Some(OsStr::new(\"file\")), path_with_file.file_name());\n/// assert_eq!(create_log_directory(path_with_file).is_ok(), true);\n///\n/// let path_with_other_file = Path::new(\"/other_file\");\n/// assert_eq!(Some(OsStr::new(\"other_file\")), path_with_other_file.file_name());\n/// assert_eq!(create_log_directory(path_with_file).is_ok(), true);\n///\n/// // Path that is just the root or prefix:\n/// let path_without_file = Path::new(\"/\");\n/// assert_eq!(None, path_without_file.file_name());\n/// assert_eq!(create_log_directory(path_without_file).is_ok(), false);\n/// ```\nfn create_log_directory(path_with_file: &Path) -> io::Result<()>{\n    let log_dir = path_with_file.parent().ok_or_else(|| io::Error::new(\n        io::ErrorKind::InvalidInput,\n        format!(\n            \"Unable to get the parent of the following Path: {}, Your path should contain a file name\",\n            path_with_file.display(),\n        ),\n    ))?;\n    fs::create_dir_all(log_dir)?;\n    Ok(())\n}","Real(LocalPath(\"src/main.rs\"))"],"extract_env_or_flag":["/// Extracts a value from the flags and the env.\n///\n/// In this order: `String` from the flags, then `String` from the env, then `None`\nfn extract_env_or_flag(\n    flags: &HashMap<String, Option<String>>,\n    conf: &EnvFlagConfig,\n) -> Option<String>{\n    flags.get(conf.flag_name).cloned().unwrap_or_else(|| std::env::var(conf.env_name).ok())\n}","Real(LocalPath(\"src/main.rs\"))"],"generate_logfile_config":["fn generate_logfile_config(flags: &HashMap<String, Option<String>>) -> LogfileConfig{\n    // If the key is set, get the Option within\n    let log_dir_env_flag = EnvFlagConfig { env_name: \"XI_LOG_DIR\", flag_name: \"log-dir\" };\n    let log_file_env_flag = EnvFlagConfig { env_name: \"XI_LOG_FILE\", flag_name: \"log-file\" };\n    let log_dir_flag_option = extract_env_or_flag(&flags, &log_dir_env_flag).map(PathBuf::from);\n\n    let log_file_flag_option = extract_env_or_flag(&flags, &log_file_env_flag).map(PathBuf::from);\n\n    LogfileConfig { directory: log_dir_flag_option, file: log_file_flag_option }\n}","Real(LocalPath(\"src/main.rs\"))"],"generate_logging_path":["fn generate_logging_path(logfile_config: LogfileConfig) -> Result<PathBuf, io::Error>{\n    // Use the file name set in logfile_config or fallback to the default\n    let logfile_file_name = match logfile_config.file {\n        Some(file_name) => file_name,\n        None => PathBuf::from(XI_LOG_FILE),\n    };\n    if logfile_file_name.eq(Path::new(\"\")) {\n        return Err(io::Error::new(io::ErrorKind::InvalidInput, \"A blank file name was supplied\"));\n    };\n    // Use the directory name set in logfile_config or fallback to the default\n    let logfile_directory_name = match logfile_config.directory {\n        Some(dir) => dir,\n        None => PathBuf::from(XI_LOG_DIR),\n    };\n\n    let mut logging_directory_path = get_logging_directory_path(logfile_directory_name)?;\n\n    // Add the file name & return the full path\n    logging_directory_path.push(logfile_file_name);\n    Ok(logging_directory_path)\n}","Real(LocalPath(\"src/main.rs\"))"],"get_flags":["fn get_flags() -> HashMap<String, Option<String>>{\n    let mut flags: HashMap<String, Option<String>> = HashMap::new();\n\n    let flag_prefix = \"-\";\n    let mut args_iterator = std::env::args().peekable();\n    while let Some(arg) = args_iterator.next() {\n        if arg.starts_with(flag_prefix) {\n            let key = arg.trim_start_matches(flag_prefix).to_string();\n\n            // Check the next argument doesn't start with the flag prefix\n            // map_or accounts for peek returning an Option\n            let next_arg_not_a_flag: bool =\n                args_iterator.peek().map_or(false, |val| !val.starts_with(flag_prefix));\n            if next_arg_not_a_flag {\n                flags.insert(key, args_iterator.next());\n            }\n        }\n    }\n    flags\n}","Real(LocalPath(\"src/main.rs\"))"],"get_logging_directory_path":["fn get_logging_directory_path<P: AsRef<Path>>(directory: P) -> Result<PathBuf, io::Error>{\n    match dirs::data_local_dir() {\n        Some(mut log_dir) => {\n            log_dir.push(directory);\n            Ok(log_dir)\n        }\n        None => Err(io::Error::new(\n            io::ErrorKind::NotFound,\n            \"No standard logging directory known for this platform\",\n        )),\n    }\n}","Real(LocalPath(\"src/main.rs\"))"],"main":["fn main(){\n    let mut state = XiCore::new();\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let mut rpc_looper = RpcLoop::new(stdout);\n\n    let flags = get_flags();\n\n    let logfile_config = generate_logfile_config(&flags);\n\n    let logging_path_result = generate_logging_path(logfile_config);\n\n    let logging_path =\n        logging_path_result.as_ref().map(|p: &PathBuf| -> &Path { p.as_path() }).ok();\n\n    if let Err(e) = setup_logging(logging_path) {\n        eprintln!(\"[ERROR] setup_logging returned error, logging not enabled: {:?}\", e);\n    }\n    if let Err(e) = logging_path_result.as_ref() {\n        warn!(\"Unable to generate the logging path to pass to set up: {}\", e)\n    }\n\n    match rpc_looper.mainloop(|| stdin.lock(), &mut state) {\n        Ok(_) => (),\n        Err(err) => {\n            error!(\"xi-core exited with error:\\n{:?}\", err);\n            process::exit(1);\n        }\n    }\n}","Real(LocalPath(\"src/main.rs\"))"],"setup_logging":["fn setup_logging(logging_path: Option<&Path>) -> Result<(), fern::InitError>{\n    let level_filter = match std::env::var(\"XI_LOG\") {\n        Ok(level) => match level.to_lowercase().as_ref() {\n            \"trace\" => log::LevelFilter::Trace,\n            \"debug\" => log::LevelFilter::Debug,\n            _ => log::LevelFilter::Info,\n        },\n        // Default to info\n        Err(_) => log::LevelFilter::Info,\n    };\n\n    let mut fern_dispatch = fern::Dispatch::new()\n        .format(|out, message, record| {\n            out.finish(format_args!(\n                \"{}[{}][{}] {}\",\n                chrono::Local::now().format(\"[%Y-%m-%d][%H:%M:%S]\"),\n                record.target(),\n                record.level(),\n                message,\n            ))\n        })\n        .level(level_filter)\n        .chain(io::stderr());\n\n    if let Some(logging_file_path) = logging_path {\n        create_log_directory(logging_file_path)?;\n\n        fern_dispatch = fern_dispatch.chain(fern::log_file(logging_file_path)?);\n    };\n\n    // Start fern\n    fern_dispatch.apply()?;\n    info!(\"Logging with fern is set up\");\n\n    // Log details of the logging_file_path result using fern/log\n    // Either logging the path fern is outputting to or the error from obtaining the path\n    match logging_path {\n        Some(logging_file_path) => info!(\"Writing logs to: {}\", logging_file_path.display()),\n        None => warn!(\"No path was supplied for the log file. Not saving logs to disk, falling back to just stderr\"),\n    }\n    Ok(())\n}","Real(LocalPath(\"src/main.rs\"))"]},"struct_constructor":{"LogfileConfig":["generate_logfile_config"],"std::collections::HashMap":["get_flags"],"std::path::PathBuf":["generate_logging_path","get_logging_directory_path"],"std::string::String":["extract_env_or_flag"]},"struct_to_trait":{},"targets":{"create_log_directory":["create_log_directory","Real(LocalPath(\"src/main.rs\"))",""],"extract_env_or_flag":["extract_env_or_flag","Real(LocalPath(\"src/main.rs\"))",""],"generate_logfile_config":["generate_logfile_config","Real(LocalPath(\"src/main.rs\"))",""],"generate_logging_path":["generate_logging_path","Real(LocalPath(\"src/main.rs\"))",""],"get_flags":["get_flags","Real(LocalPath(\"src/main.rs\"))",""],"get_logging_directory_path":["get_logging_directory_path","Real(LocalPath(\"src/main.rs\"))",""],"main":["main","Real(LocalPath(\"src/main.rs\"))",""],"setup_logging":["setup_logging","Real(LocalPath(\"src/main.rs\"))",""]},"trait_to_struct":{},"type_to_def_path":{"EnvFlagConfig":"EnvFlagConfig","LogfileConfig":"LogfileConfig"}}